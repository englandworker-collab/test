sform = { AnchorMin = "0.075 0.15", AnchorMax = "0.375 0.3", OffsetMax = "0 0" },
                Text = { Text = target.displayName, Color = "1 1 1 0.6", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
            }, "Report");

            float width = 0.55f, height = 0.195f, startxBox = 0.38f, startyBox = 0.72f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in config.Reasons)
            {
                container.Add(new CuiButton
                {  
                    RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "4 4", OffsetMax = "-4 -4" },
                    Button = { Color = "1 1 1 0", Command = $"report reason {target.userID} {check.Key}" },
                    Text = { Text = $"     {check.Value}", Color = "1 1 1 0.4", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                }, "Report");

                xmin += width;
                if (xmin + width >= 0)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }

            CuiHelper.AddUi(player, container);
        }

        string LayerCheck = "Target";
        void TargetUI(BasePlayer player, ulong id) {
            CuiHelper.DestroyUi(player, LayerCheck);
            var container = new CuiElementContainer();

            var target = DB.FirstOrDefault(z => z.Key == id);

            var amin = target.Value.SteamID2 == player.userID ? "0.64 0" : "0.38 0.25";
            var amax = target.Value.SteamID2 == player.userID ? "0.84 0.225" : "0.62 0.6";
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = amin, AnchorMax = amax, OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", LayerCheck);

            if (target.Value.SteamID2 != player.userID) {
                container.Add(new CuiElement
                {
                    Parent = LayerCheck,
                    Components = {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "aAm4ZHw"), Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.08 0.86", AnchorMax = "0.87 0.94", OffsetMax = "0 0" },
                    Text = { Text = "Проверка игрока", Color = "1 1 1 0.4", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.88 0.775", AnchorMax = "0.945 0.9", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Close = LayerCheck },
                    Text = { Text = "", Color = "0 0 0 0", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                container.Add(new CuiElement
                {
                    Parent = LayerCheck,
                    Components = {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", target.Key.ToString()) },
                        new CuiRectTransformComponent { AnchorMin = "0.075 0.45", AnchorMax = $"0.375 0.81", OffsetMin = "6 6", OffsetMax = "-6 -6" },
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = LayerCheck,
                    Components = {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "lamC17G") },
                        new CuiRectTransformComponent { AnchorMin = "0.075 0.45", AnchorMax = $"0.375 0.81", OffsetMax = "0 0" },
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.075 0.4", AnchorMax = "0.375 0.55", OffsetMax = "0 0" },
                    Text = { Text = target.Value.DisplayName, Color = "1 1 1 0.6", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                }, LayerCheck);

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.41 0.6", AnchorMax = "0.915 0.81", OffsetMax = "0 0" },
                    Text = { Text = $"Читы жалоб: {target.Value.Res["Reason_1"]}\nБагоюз жалоб: {target.Value.Res["Reason_2"]}\nМакрос жалоб: {target.Value.Res["Reason_3"]}\nПроверок: {target.Value.Count}", Color = "1 1 1 0.4", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.41 0.5", AnchorMax = "0.915 0.575", OffsetMax = "0 0" },
                    Text = { Text = $"steamid: {target.Key}", Color = "1 1 1 0.4", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                var status = BasePlayer.Find(target.Key.ToString()).IsConnected == true ? "Online" : "Offline";
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.44 0.21", AnchorMax = "0.915 0.48", OffsetMax = "0 0" },
                    Text = { Text = $"Discord: не указан\nСтатус: {status}", Color = "1 1 1 0.4", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.41 0.09", AnchorMax = "0.915 0.2", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"report check {target.Key}" },
                    Text = { Text = "Вызвать на проверку", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                float width = 0.31f, height = 0.115f, startxBox = 0.07f, startyBox = 0.44f - height, xmin = startxBox, ymin = startyBox;
                foreach (var check in config.Ban)
                {
                    container.Add(new CuiButton
                    {  
                        RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "4 4", OffsetMax = "-4 -4" },
                        Button = { Color = "1 1 1 0", Command = $"report ban {target.Key} {check}" },
                        Text = { Text = $"Бан {check}", Color = "1 1 1 0.4", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                    }, LayerCheck);

                    xmin += width;
                    if (xmin + width >= 0)
                    {
                        xmin = startxBox;
                        ymin -= height + 0.003f;
                    }
                }
            }
            else {
                container.Add(new CuiElement
                {
                    Parent = LayerCheck,
                    Components = {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "xclemZi"), Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.06 0.195", AnchorMax = "0.39 0.81", OffsetMax = "0 0" },
                    Text = { Text = $"Читы жалоб: {target.Value.Res["Reason_1"]}\n\nБагоюз жалоб: {target.Value.Res["Reason_2"]}\n\nМакрос жалоб: {target.Value.Res["Reason_3"]}", Color = "1 1 1 0.4", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                var ds = target.Value.DS != null ? target.Value.DS : "не указан";
                var status = BasePlayer.Find(target.Key.ToString()).IsConnected == true ? "Online" : "Offline";
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.44 0.21", AnchorMax = "0.915 0.8", OffsetMax = "0 0" },
                    Text = { Text = $"Никнейм: {target.Value.DisplayName}\nSteamID: {target.Value.SteamID}\nСтатус: {status}\nDiscord: {ds}\nПроверок: {target.Value.Count}", Color = "1 1 1 0.4", Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.05 0.12", AnchorMax = "0.95 0.23", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"report check {target.Key}" },
                    Text = { Text = "Снять с проверки", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                }, LayerCheck);

                float width = 0.307f, height = 0.15f, startxBox = 0.04f, startyBox = 0.9f - height, xmin = startxBox, ymin = startyBox;
                foreach (var check in config.Ban)
                {
                    container.Add(new CuiButton
                    {  
                        RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "4 4", OffsetMax = "-4 -4" },
                        Button = { Color = "1 1 1 0", Command = $"report ban {target.Key} {check}" },
                        Text = { Text = $"Бан {check}", Color = "1 1 1 0.4", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                    }, LayerCheck);

                    xmin += width;
                    if (xmin + width >= 1)
                    {
                        xmin = startxBox;
                        ymin -= height + 0.004f;
                    }
                }
            }

            CuiHelper.AddUi(player, container);
        }

        void CheckUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Check_UI");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0 0.75", AnchorMax = "1 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" },
            }, "Overlay", "Check_UI");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = $"<b><size=20>{player.displayName.ToUpper()}, ВАС ВЫЗВАЛИ НА ПРОВЕРКУ</size></b>\n{config.Title}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, "Check_UI");

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Дискорд
        List<Fields> DT_PlayerSendReport(BasePlayer Sender, UInt64 TargetID, String Reason)
        {
	        List<Fields> fields = new List<Fields>
	        {
		        new Fields("Получена новая жалоба :", "", false),
		        new Fields("", "", false),
		        new Fields("Информация об отправителе :", "", false),
		        new Fields("", "", false),
		        new Fields("Ник", $"{Sender.displayName}", true),
		        new Fields("Steam64ID", $"[{Sender.userID}](https://steamcommunity.com/profiles/{Sender.userID})", true),
		        new Fields("", "", false),
		        new Fields("Информация о подозреваемом :", "", false),
		        new Fields("", "", false),
		        new Fields("Ник", $"{covalence.Players.FindPlayerById(TargetID.ToString()).Name ?? "EMPTY"}", true),
		        new Fields("Steam64ID", $"[{TargetID}](https://steamcommunity.com/profiles/{TargetID})", true),
		        new Fields("Причина жалобы :", Reason, false),
	        };
	        
	        return fields;
        }
            
        List<Fields> DT_PlayerSendContact(BasePlayer Sender, String Contact)
        {
	        List<Fields> fields = new List<Fields>
	        {
		        new Fields("Информация об отправителе :", "", false),
		        new Fields("", "", false),
		        new Fields("Ник", $"{Sender.displayName}", true),
		        new Fields("Steam64ID", $"[{Sender.userID}](https://steamcommunity.com/profiles/{Sender.userID})", true),
		        new Fields("Контакты для связи :", Contact, false),
	        };

	        return fields;
        }

        List<Fields> DT_PlayerCheck(BasePlayer Sender, UInt64 TargetID)
        {
	        List<Fields> fields = new List<Fields>
	        {
		        new Fields($"Модератор {Sender.displayName} начал проверку:", "", false),
		        new Fields("", "", false),
		        new Fields("Ник проверяемого", $"{covalence.Players.FindPlayerById(TargetID.ToString()).Name ?? "EMPTY"}", true),
		        new Fields("Steam64ID", $"[{TargetID}](https://steamcommunity.com/profiles/{TargetID})", true),
	        };

	        return fields;
        }

        List<Fields> DT_PlayerCheckRemove(BasePlayer Sender, UInt64 TargetID)
        {
	        List<Fields> fields = new List<Fields>
	        {
		        new Fields($"Модератор {Sender.displayName} закончил проверку:", "", false),
		        new Fields("", "", false),
		        new Fields("Ник проверяемого", $"{covalence.Players.FindPlayerById(TargetID.ToString()).Name ?? "EMPTY"}", true),
		        new Fields("Steam64ID", $"[{TargetID}](https://steamcommunity.com/profiles/{TargetID})", true),
	        };

	        return fields;
        }

        void SendDiscord(String Webhook, List<Fields> fields, Authors Authors, Int32 Color)
        {
	        if (Webhook == null || String.IsNullOrWhiteSpace(Webhook)) return;
	        FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, Color, fields, Authors) });

	        Request($"{Webhook}", newMessage.toJSON());
        }

        void Request(String url, String payload, Action<Int32> callback = null)
        {
            Dictionary<String, String> header = new Dictionary<String, String>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                Single seconds = Single.Parse(Math.Ceiling((Double)(Int32)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, Core.Libraries.RequestMethod.POST, header, timeout: 10F);
        }

        public class Fields
        {
            public String name { get; set; }
            public String value { get; set; }
            public bool inline { get; set; }
            public Fields(String name, String value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        public class Authors
        {
            public String name { get; set; }
            public String url { get; set; }
            public String icon_url { get; set; }
            public String proxy_icon_url { get; set; }
            public Authors(String name, String url, String icon_url, String proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class FancyMessage
        {
            public String content { get; set; }
            public Boolean tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public String title { get; set; }
                public Int32 color { get; set; }
                public List<Fields> fields { get; set; }
                public Authors author { get; set; }

                public Embeds(String title, Int32 color, List<Fields> fields, Authors author)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;

                }
            }

            public FancyMessage(String content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public String toJSON() => JsonConvert.SerializeObject(this);
        }
        #endregion
    }
}

// --- End of file: TPReportSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Trains.cs ---
// --- Original Local Path: Trains.cs ---

using Rust;
using System;
using System.Linq;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Facepunch;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Trains", "Colon Blow", "1.0.5")]
    class Trains : CovalencePlugin
    {

        #region Load

        [PluginReference]
        Plugin TrainsE1;

        const string permAdmin = "trains.admin";
        const string permConductor = "trains.conductor";

        List<ulong> playersInTrackMode = new List<ulong>();
        List<BaseEntity> trackEditMarkers = new List<BaseEntity>();

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permConductor, this);
            permission.RegisterPermission(permAdmin, this);
            LoadDataFile();
            timer.In(5, RespawnAllTrains);
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public TrainSettings trainSettings { get; set; }

            public class TrainSettings
            {
                [JsonProperty(PropertyName = "Data File Setting : Use Data File named : ")] public string saveInfoName { get; set; }
                [JsonProperty(PropertyName = "Global Setting - Enable Event Train ? ")] public bool enableEventTrain { get; set; }
                [JsonProperty(PropertyName = "Global Setting - Destroy things in trains way ?")] public bool damageOnCollision { get; set; }
                [JsonProperty(PropertyName = "Global Setting - Eject Sleepers from train ?")] public bool ejectSleepers { get; set; }
                [JsonProperty(PropertyName = "Global Setting - Trains speeds up and down depending on angle ? ")] public bool useAngleSpeed { get; set; }
                [JsonProperty(PropertyName = "Editor - seconds to show current selected tracks waypoint number above waypoint when toggled (1k or more waypoints recommend 5 or less) ")] public float timeShowText { get; set; }
                [JsonProperty(PropertyName = "Editor - seconds to show current selected tracks lines betweet waypoints (1k or more waypoints recommend 5 or less) ")] public float timeShowLines { get; set; }
                [JsonProperty(PropertyName = "Editor - seconds to show current selected tracks stop number above stop when toggled ")] public float timeShowStops { get; set; }
                [JsonProperty(PropertyName = "Custom Prefab - Prefab string for Train Type 5 (default is rowboat) ")] public string customPrefabStr { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                trainSettings = new PluginConfig.TrainSettings
                {
                    saveInfoName = "Trains",
                    enableEventTrain = true,
                    damageOnCollision = true,
                    ejectSleepers = true,
                    useAngleSpeed = true,
                    timeShowText = 15f,
                    timeShowLines = 15f,
                    timeShowStops = 15f,
                    customPrefabStr = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAuthorized"] = "You are NOT Authorized to do that !!",
                ["ClearedData"] = "You have removed all saved tracks !!",
                ["TrackModeEnabled1"] = "Track Mode enabled. ",
                ["TrackModeEnabled2"] = "Track Mode enabled and showing markers for track ",
                ["TrackModeDisabled"] = "Track Mode disable.",
                ["UnknownTrack"] = "The selected Track does not exist !!",
                ["KnownTrack"] = "The selected Track already exists, please use another name !!",
                ["SelectTrack"] = "You need to select Track to edit !!",
                ["CreatedTrack"] = "You createed new track ",
                ["RemovedTrack"] = "You removed track ",
                ["ShowMarkers"] = "Now showing all Track Markers",
                ["HideMarkers"] = "Now hiding all track Markers",
                ["ToggledMiddleMouse"] = "Middle Mouse Button Toggled to allow adding waypoints to selected Track.",
                ["UnToggledMiddleMouse"] = "Middle Mouse Button Toggled to allow adding waypoints to selected Track.",
                ["UnknownCommand"] = "You must specify a secondary  commmand !!",
                ["UnknownWaypoint"] = "You must specify a secondary  commmand !!",
                ["MarkedWaypoint"] = "You Marked a new waypoint location for ",
                ["DeletedWaypoint"] = "You Have Removed the Last Waypoint in Current Track list ",
                ["MarkedStoppoint"] = "You Marked a new stop location for ",
                ["DeletedStoppoint"] = "You Have Removed the Last Stop Point in Current Track list ",
                ["ChangedTrainType"] = "You have changed current tracks train type. ",
                ["ChangedLooping"] = "You have changed whether current track loops or not. ",
                ["NotEditMode"] = "You must NOT be in track edit mode to do that !!",
                ["EditMode"] = "You must be in edit mode to do that !!"
            }, this);
        }

        #endregion

        #region Data

        static StoredData storedData = new StoredData();
        DynamicConfigFile dataFile;

        public class StoredData
        {
            public Dictionary<string, TrainTrackData> trainTrackData = new Dictionary<string, TrainTrackData>();
            public class TrainTrackData
            {
                public int trainType;
                public bool looping;
                public bool autospawn;
                public bool autostart;
                public float maxSpeed;
                public float stopWaitTime;
                public List<Vector3> trackMarkers = new List<Vector3>();
                public List<Vector3> trainStops = new List<Vector3>();
                public TrainTrackData() { }
            }
            public StoredData() { }
        }

        private void LoadDataFile()
        {
            dataFile = Interface.Oxide.DataFileSystem.GetFile("Trains/" + config.trainSettings.saveInfoName);

            try
            {
                storedData = dataFile.ReadObject<StoredData>();
            }
            catch { }

            if (storedData == null)
                storedData = new StoredData();
        }

        private void SaveData()
        {
            if (dataFile != null && storedData != null)
            {
                dataFile.WriteObject(storedData);
            }
        }

        private void OnServerSave()
        {
            if (storedData.trainTrackData.Count == 0) return;
            SaveData();
        }

        #endregion

        #region Commands

        [Command("train")]
        private void cmdTrainHelp(IPlayer player, string command)
        {
            if (!player.HasPermission(permAdmin)) return;
            StringBuilder newHelpString = new StringBuilder();
            newHelpString.Append("<color=orange>/trackmode </color> - turns on train track edit mode on/off. (remove active trains)\n");
            newHelpString.Append("<color=orange>/track.create </color><color=green>trackname</color> - creates specified track.\n");
            newHelpString.Append("<color=orange>/track.remove </color> - removes selected track while in edit mode.\n");
            newHelpString.Append("<color=orange>/track.edit </color><color=green>trackname</color> - changed current track in edit mode.\n");
            newHelpString.Append("<color=orange>/track.traintype </color> - changes train type of selected track while in edit mode.\n");
            newHelpString.Append("<color=orange>/track.trainloop </color> - changes train looping or not of selected track while in edit mode.\n");
            newHelpString.Append("<color=orange>/track.showlines </color> - toggles visual waypoint lines on and off for all tracks.\n");
            newHelpString.Append("<color=orange>/track.showtext </color> - toggles visual waypoint text on and off for all tracks.\n");
            newHelpString.Append("<color=orange>/track.mark </color> - use to mark current player position as next waypoint for selected track in edit mode.\n");
            newHelpString.Append("<color=orange>/track.markstop </color> - use to mark current player position as next stop point for selected track in edit mode.\n");
            newHelpString.Append("<color=orange>/track.deletelastmark </color> - deletes the last waypoint position marked of selected track in edit mode.\n");
            newHelpString.Append("<color=orange>/track.deletelaststop </color> - deletes the last stop position marked of selected track in edit mode.\n");
            newHelpString.Append("<color=orange>/train.eraseall</color> - removes all waypoints and stops from databases.\n");
            newHelpString.Append("<color=orange>/train.spawn </color><color=green>trackname</color> - spawns train on specifed track.\n");
            newHelpString.Append("<color=orange>/train.setconfig </color><color=green>config_name</color> - sets config to that name, creates a new blank config if it doesnt exist\n");
            player.Reply(newHelpString.ToString());
        }

        [Command("trackmode")]
        private void cmdTrackEnable(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                var hasGui = basePlayer.GetComponent<TrackEditGUI>();
                if (hasGui) hasGui.OnDestroy();

                playersInTrackMode.Remove(basePlayer.userID);
                player.Message(lang.GetMessage("TrackModeDisabled", this, player.Id));
                RespawnAllTrains();
                return;
            }
            else
            {
                playersInTrackMode.Add(basePlayer.userID);
                DestroyAll<TrainEntity>();
                var addEditor = basePlayer.gameObject.AddComponent<TrackEditGUI>();
                string trackName = string.Join(" ", addEditor.trackstring).ToLower();
                if (storedData.trainTrackData.Any())
                {
                    trackName = storedData.trainTrackData.First().Key;
                }
                addEditor.RefreshTrackList(basePlayer, trackName);
                player.Message(lang.GetMessage("TrackModeEnabled1", this, player.Id));
            }
        }

        [Command("track.create")]
        private void cmdTrackCreate(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                if (args.Length > 0)
                {
                    string trackName = args[0].ToLower();
                    if (!storedData.trainTrackData.ContainsKey(trackName))
                    {
                        storedData.trainTrackData.Add(args[0].ToLower(), new StoredData.TrainTrackData
                        {
                            trainType = 1,
                            looping = false,
                            autospawn = true,
                            autostart = true,
                            maxSpeed = 10f,
                            stopWaitTime = 10f,
                            trackMarkers = new List<Vector3>(),
                            trainStops = new List<Vector3>()
                        });
                        SaveData();
                        var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                        if (hasEditor)
                        {
                            hasEditor.RefreshTrackList(basePlayer, trackName);
                        }
                    }
                    else player.Message(lang.GetMessage("KnownTrack", this, player.Id));
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.remove")]
        private void cmdTrackRemove(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                if (args.Length > 0)
                {
                    string trackName = string.Join(" ", args).ToLower();

                    CuiHelper.DestroyUi(basePlayer, trackName);
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        storedData.trainTrackData.Remove(trackName);
                        SaveData();
                        player.Message(lang.GetMessage("RemovedTrack", this, player.Id) + trackName);
                        var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                        if (hasEditor)
                        {
                            hasEditor.trackstring = trackName;
                            hasEditor.RefreshTrackList(basePlayer, trackName);
                        }
                    }
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.edit")]
        private void cmdTrackEdit(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                if (args.Length > 0)
                {
                    string trackName = string.Join(" ", args).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                        if (hasEditor)
                        {
                            hasEditor.RefreshTrackList(basePlayer, trackName);
                        }
                    }
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.traintype")]
        private void cmdTrackTrainType(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        int traintype = storedData.trainTrackData[trackName].trainType;
                        if (traintype == 1) traintype = 2;
                        else if (traintype == 2) traintype = 3;
                        else if (traintype == 3) traintype = 4;
                        else if (traintype == 4) traintype = 5;
                        else if (traintype >= 5) traintype = 1;
                        storedData.trainTrackData[trackName].trainType = traintype;
                        SaveData();
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.trainloop")]
        private void cmdTrackTrainLoop(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        bool looping = storedData.trainTrackData[trackName].looping;
                        looping = !looping;
                        storedData.trainTrackData[trackName].looping = looping;
                        SaveData();
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.autospawn")]
        private void cmdTrackAutoSpawn(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        bool autospawn = storedData.trainTrackData[trackName].autospawn;
                        autospawn = !autospawn;
                        storedData.trainTrackData[trackName].autospawn = autospawn;
                        SaveData();
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.autostart")]
        private void cmdTrackAutoStart(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        bool autostart = storedData.trainTrackData[trackName].autostart;
                        autostart = !autostart;
                        storedData.trainTrackData[trackName].autostart = autostart;
                        SaveData();
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.maxspeed")]
        private void cmdTrackMaxSpeed(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        float maxTrainSpeed = storedData.trainTrackData[trackName].maxSpeed;
                        maxTrainSpeed += 2f;
                        if (maxTrainSpeed > 20f) maxTrainSpeed = 2f;
                        storedData.trainTrackData[trackName].maxSpeed = maxTrainSpeed;
                        SaveData();
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.waittime")]
        private void cmdTrackWaitTime(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        float trainWaitTime = storedData.trainTrackData[trackName].stopWaitTime;
                        trainWaitTime += 5f;
                        if (trainWaitTime > 60f) trainWaitTime = 5f;
                        storedData.trainTrackData[trackName].stopWaitTime = trainWaitTime;
                        SaveData();
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.showlines")]
        private void cmdTrackShowLines(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID) && basePlayer.net?.connection?.authLevel >= 1)
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        hasEditor.enableShowLines = !hasEditor.enableShowLines;
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
        }

        [Command("track.showtext")]
        private void cmdTrackShowText(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID) && basePlayer.net?.connection?.authLevel >= 1)
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        hasEditor.enableShowText = !hasEditor.enableShowText;
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
        }

        [Command("track.showstops")]
        private void cmdTrackShowStops(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID) && basePlayer.net?.connection?.authLevel >= 1)
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    if (storedData.trainTrackData.ContainsKey(trackName))
                    {
                        hasEditor.enableShowStops = !hasEditor.enableShowStops;
                        hasEditor.RefreshTrackList(basePlayer, trackName);
                    }
                }
            }
        }

        [Command("track.enablemiddle")]
        private void cmdTrackEnableMiddle(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                if (hasEditor)
                {
                    string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                    hasEditor.enableMiddleMouse = !hasEditor.enableMiddleMouse;
                    hasEditor.RefreshTrackList(basePlayer, trackName);
                    if (hasEditor.enableMiddleMouse) player.Message(lang.GetMessage("ToggledMiddleMouse", this, player.Id));
                    else player.Message(lang.GetMessage("UnToggledMiddleMouse", this, player.Id));
                }
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("track.mark")]
        private void cmdTrackMarkWaypoint(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
            if (hasEditor)
            {
                string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                if (storedData.trainTrackData.ContainsKey(trackName))
                {
                    storedData.trainTrackData[trackName].trackMarkers.Add(basePlayer.transform.position);
                    SaveData();
                    player.Message(lang.GetMessage("MarkedWaypoint", this, player.Id) + trackName);
                    hasEditor.RefreshTrackList(basePlayer, trackName);
                }
            }
        }

        [Command("track.markstop")]
        private void cmdTrackMarkStop(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
            if (hasEditor)
            {
                string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                if (storedData.trainTrackData.ContainsKey(trackName))
                {
                    storedData.trainTrackData[trackName].trainStops.Add(basePlayer.transform.position);
                    SaveData();
                    player.Message(lang.GetMessage("MarkedStoppoint", this, player.Id) + trackName);
                    hasEditor.RefreshTrackList(basePlayer, trackName);
                }
            }
        }

        [Command("track.deletelastmark")]
        private void cmdTrackDeleteLastMark(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
            if (hasEditor)
            {
                string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                if (storedData.trainTrackData.ContainsKey(trackName) && storedData.trainTrackData[trackName].trackMarkers.Count > 0)
                {
                    Vector3 lastpos = storedData.trainTrackData[trackName].trackMarkers.Last();
                    if (lastpos != null)
                    {
                        storedData.trainTrackData[trackName].trackMarkers.Remove(lastpos);
                        SaveData();
                        player.Message(lang.GetMessage("DeletedWaypoint", this, player.Id) + trackName);
                    }
                    hasEditor.RefreshTrackList(basePlayer, trackName);
                }
            }
        }

        [Command("track.deletelaststop")]
        private void cmdTrackDeleteLastStop(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
            if (hasEditor)
            {
                string trackName = string.Join(" ", hasEditor.trackstring).ToLower();
                if (storedData.trainTrackData.ContainsKey(trackName) && storedData.trainTrackData[trackName].trainStops.Count > 0)
                {
                    Vector3 lastpos = storedData.trainTrackData[trackName].trainStops.Last();
                    if (lastpos != null)
                    {
                        storedData.trainTrackData[trackName].trainStops.Remove(lastpos);
                        SaveData();
                        player.Message(lang.GetMessage("DeletedStoppoint", this, player.Id) + trackName);
                    }
                    hasEditor.RefreshTrackList(basePlayer, trackName);
                }
            }
        }

        [Command("track.eraseall")]
        private void cmdTrackEraseAll(IPlayer player, string command)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (playersInTrackMode.Contains(basePlayer.userID))
            {
                storedData.trainTrackData.Clear();
                SaveData();
                player.Message(lang.GetMessage("ClearData", this, player.Id));
                RefeshPlayerGUI(basePlayer);
            }
            else player.Message(lang.GetMessage("EditMode", this, player.Id));
        }

        [Command("train.setconfig")]
        private void cmdTrainsSetConfig(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            var basePlayer = player.Object as BasePlayer;
            if (!playersInTrackMode.Contains(basePlayer.userID))
            {
                if (args.Length > 0)
                {
                    DestroyAll<TrainEntity>();
                    string configName = args[0].ToString();
                    config.trainSettings.saveInfoName = configName;
                    SaveConfig();
                    SaveData();
                    LoadDataFile();
                    LoadConfig();
                    timer.Once(2f, () => RespawnAllTrains());
                    player.Message(lang.GetMessage("<color=yellow>Created new Data File called : </color> ", this, player.Id) + configName);
                }
            }
            else player.Message(lang.GetMessage("NotEditMode", this, player.Id));

        }

        [Command("train.spawn")]
        private void cmdTrainSpawnTrain(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            if (args != null && args.Length > 0)
            {
                if (storedData.trainTrackData.ContainsKey(args[0].ToLower()))
                {
                    AddTrainEntityToTrack(args[0].ToLower());
                    SaveData();
                }
                else player.Message(lang.GetMessage("UnknownTrack", this, player.Id));
            }
        }

        [Command("train.spawnevent1")]
        private void cmdTrainSpawnTrainEvent1(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin)) return;
            if (TrainsE1 == null) return;
            if (args != null && args.Length > 0)
            {
                if (storedData.trainTrackData.ContainsKey(args[0].ToLower()))
                {
                    TrainsE1?.Call("SpawnEventTrain", storedData.trainTrackData[args[0].ToLower()].trackMarkers, storedData.trainTrackData[args[0].ToLower()].trainStops);
                }
                else player.Message(lang.GetMessage("UnknownTrack", this, player.Id));
            }
        }
        #endregion

        #region Hooks

        private void RefeshPlayerGUI(BasePlayer basePlayer)
        {
            var hasEditGUI = basePlayer.GetComponent<TrackEditGUI>();
            if (hasEditGUI) hasEditGUI.OnDestroy();
            basePlayer.gameObject.AddComponent<TrackEditGUI>();
        }

        private void AddTrainEntityToTrack(string listname)
        {
            if (storedData.trainTrackData[listname].trackMarkers.ElementAtOrDefault(0) == null) return;
            Vector3 position = storedData.trainTrackData[listname].trackMarkers.ElementAtOrDefault(0);
            string strPrefab = "assets/prefabs/visualization/sphere.prefab";
            BaseEntity sphereEntity = GameManager.server.CreateEntity(strPrefab, position, Quaternion.identity, true);
            SphereEntity ball = sphereEntity.GetComponent<SphereEntity>();
            ball.lerpRadius = 1f;
            ball.lerpSpeed = 100f;
            StabilityEntity getStab = sphereEntity.GetComponent<StabilityEntity>();
            if (getStab) getStab.grounded = true;
            sphereEntity.Spawn();
            TrainEntity addTrainEntity = sphereEntity.gameObject.AddComponent<TrainEntity>();
            addTrainEntity.SpawnTrain(listname);
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null || entity is BasePlayer) return;
            var istrain = entity.GetComponentInParent<TrainEntity>();
            if (istrain)
            {
                hitInfo.damageTypes.ScaleAll(0);
            }
        }

        private object OnStructureRotate(BaseCombatEntity entity, BasePlayer player)
        {
            var istrain = entity.GetComponentInParent<TrainEntity>();
            if (istrain) return false;
            return null;
        }

        private object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            var istrain = entity.GetComponentInParent<TrainEntity>();
            if (istrain) return false;
            return null;
        }

        private object OnEntityGroundMissing(BaseEntity entity)
        {
            var istrain = entity.GetComponentInParent<TrainEntity>();
            if (istrain != null) return false;
            return null;
        }

        private object OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer player)
        {
            if (electricSwitch == null || player == null) return null;
            var isTrainEntity = electricSwitch.GetComponentInParent<TrainEntity>();
            if (isTrainEntity)
            {
                if (permission.UserHasPermission(player.UserIDString, permConductor)) return null;
                if (permission.UserHasPermission(player.UserIDString, permAdmin)) return null;
                else return false;
            }
            return null;
        }

        private object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
        {
            if (entity == null || player == null) return null;
            if (entity.GetComponentInParent<TrainEntity>()) return false;
            return null;
        }

        private void OnPlayerInput(BasePlayer basePlayer, InputState input)
        {
            if (input.WasJustPressed(BUTTON.FIRE_THIRD))
            {
                if (playersInTrackMode.Contains(basePlayer.userID))
                {
                    var hasEditor = basePlayer.GetComponent<TrackEditGUI>();
                    if (hasEditor)
                    {
                        if (!hasEditor.enableMiddleMouse) return;
                        string trackName = hasEditor.trackstring;
                        if (storedData.trainTrackData.ContainsKey(trackName))
                        {
                            storedData.trainTrackData[trackName].trackMarkers.Add(basePlayer.transform.position);
                            SaveData();
                            hasEditor.RefreshTrackList(basePlayer, trackName);
                            if (basePlayer != null && basePlayer.net?.connection?.authLevel >= 1) basePlayer.SendConsoleCommand("ddraw.text", new object[] { 10.0f, Color.red, basePlayer.transform.position + Vector3.up, "X" });
                        }
                    }
                }
            }
        }

        private void RespawnAllTrains()
        {
            DestroyAll<TrainEntity>();
            if (storedData.trainTrackData.Any())
            {
                foreach (string listname in storedData.trainTrackData.Keys)
                {
                    if (storedData.trainTrackData[listname].trackMarkers.Count > 0 && storedData.trainTrackData[listname].autospawn) AddTrainEntityToTrack(listname);
                }
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!config.trainSettings.ejectSleepers) return;
            if (player.net?.connection?.authLevel >= 0)
            {
                var onTrain = player.GetComponentInParent<TrainEntity>();
                if (onTrain) player.SetParent(null, true, true);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (!config.trainSettings.ejectSleepers) return;
            var onTrain = player.GetComponentInParent<TrainEntity>();
            if (onTrain) player.SetParent(null, true, true);
        }

        private void Unload()
        {
            DestroyAll<TrainEntity>();
            DestroyAll<TrackEditGUI>();
            SaveData();
        }

        private static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region Trolley Entity

        class TrainEntity : MonoBehaviour
        {
            Trains instance;
            BaseEntity railCart;
            BoxCollider boxcollider;
            Rigidbody rigidHitBody;
            int traintype;
            float steps;

            BaseEntity furnace1, furnace2, frontwall, frontdoor, midwall, rearwall, reardoor;

            BaseEntity frontsign;
            BaseEntity frontDoorWay, rearDoorWay;
            BaseEntity frontLowWall, rearLowWall;
            BaseEntity floor1, floor2, floor3, floor4;
            BaseEntity ceiling1, ceiling2, ceiling3, ceiling4;
            BaseEntity rightwall1, rightwall2, rightwall3, rigthwall4;
            BaseEntity leftwall1, leftwall2, leftwall3, leftwall4;
            BaseEntity wheel1, wheel2, wheel3, wheel4, wheel5, wheel6, wheel7, wheel8;
            BaseEntity lightright, lightleft;
            BaseEntity lightright2, lightleft2;
            BaseEntity logoleft1, logoleft2, logoright1, logoright2;
            BaseEntity chair1, chair2, chair3, chair4, chair5, chair6;
            BaseEntity seatback1, seatback2, seat1, seat2;
            BaseEntity rowBoat;

            public BaseEntity frontlock;
            public BaseEntity frontswitch;
            int counter;
            public bool npcmove;
            bool findnext;
            bool moveforward;
            bool findnextstop;
            public bool loopmovement;
            bool useAngleSpeed;
            bool spawncomplete;
            bool autoStartTrain;
            bool setGameObjectActive;
            float maxSpeed;
            float stopWait;
            string lockCodestr;
            string usingListNamed;

            public List<Vector3> movetolist;
            public List<Vector3> stoplist;

            public Vector3 movetopoint;
            Vector3 lastStopPos;
            Vector3 currentPos, targetDir, newDir;

            string floorprefab = "assets/prefabs/building core/floor/floor.prefab";
            string frameprefab = "assets/prefabs/building core/wall.frame/wall.frame.prefab";
            string wheelprefab = "assets/prefabs/deployable/spinner_wheel/spinner.wheel.deployed.prefab";
            string wallprefab = "assets/prefabs/building core/wall/wall.prefab";
            string windowwallprefab = "assets/prefabs/building core/wall.window/wall.window.prefab";
            string wallframeprefab = "assets/prefabs/building core/wall.frame/wall.frame.prefab";
            string doorwayprefab = "assets/prefabs/building core/wall.doorway/wall.doorway.prefab";
            string solorpanelprefab = "assets/prefabs/deployable/playerioents/generators/solar_panels_roof/solarpanel.large.deployed.prefab";
            string batteryprefab = "assets/prefabs/deployable/playerioents/batteries/smallrechargablebattery.deployed.prefab";
            string lightprefab = "assets/prefabs/tools/flashlight/flashlight.entity.prefab";
            string lowwallprefab = "assets/prefabs/building core/wall.low/wall.low.prefab";
            string simplelightprefab = "assets/prefabs/deployable/ceiling light/ceilinglight.deployed.prefab";
            string doorcontroller = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";
            string rugprefab = "assets/prefabs/deployable/rug/rug.deployed.prefab";
            string refineryprefab = "assets/prefabs/deployable/oil refinery/refinery_small_deployed.prefab";
            string garagedoorprefab = "assets/prefabs/building/wall.frame.garagedoor/wall.frame.garagedoor.prefab";
            string chairprefab = "assets/bundled/prefabs/static/chair.invisible.static.prefab";
            string seatprefab = "assets/prefabs/deployable/hitch & trough/hitchtrough.deployed.prefab";
            string customPrefab = config.trainSettings.customPrefabStr;

            private void Awake()
            {
                instance = new Trains();
                movetopoint = new Vector3();
                movetolist = new List<Vector3>();
                stoplist = new List<Vector3>();
                lastStopPos = new Vector3();
                railCart = GetComponentInParent<BaseEntity>();
                currentPos = railCart.transform.position;
                counter = 0;
                steps = 0f;
                moveforward = true;
                findnext = true;
                findnextstop = true;
                spawncomplete = false;
                loopmovement = false;
                traintype = 1;
                npcmove = true;
                setGameObjectActive = false;
                useAngleSpeed = config.trainSettings.useAngleSpeed;
            }

            public void SpawnTrain(string listname)
            {
                usingListNamed = listname;
                if (listname == null) { print("Debug...no list for trains to spawn on !!"); return; }
                movetopoint = storedData.trainTrackData[listname].trackMarkers.ElementAtOrDefault(0);
                movetolist = storedData.trainTrackData[listname].trackMarkers;
                stoplist = storedData.trainTrackData[listname].trainStops;
                loopmovement = storedData.trainTrackData[listname].looping;
                traintype = storedData.trainTrackData[listname].trainType;
                autoStartTrain = storedData.trainTrackData[listname].autostart;
                maxSpeed = storedData.trainTrackData[listname].maxSpeed;
                stopWait = storedData.trainTrackData[listname].stopWaitTime;
                SpawnRailBase();
            }

            BaseEntity SpawnPart(string prefab, BaseEntity entitypart, bool setactive, int eulangx, int eulangy, int eulangz, float locposx, float locposy, float locposz, BaseEntity parent, ulong skinid)
            {
                entitypart = new BaseEntity();
                entitypart = GameManager.server.CreateEntity(prefab, railCart.transform.position, railCart.transform.rotation, setactive);
                entitypart.transform.localEulerAngles = new Vector3(eulangx, eulangy, eulangz);
                entitypart.transform.localPosition = new Vector3(locposx, locposy, locposz);
                entitypart.SetParent(parent, 0, false, false);
                entitypart.skinID = skinid;
                entitypart.enableSaving = false;
                entitypart?.Spawn();
                SpawnRefresh(entitypart);
                return entitypart;
            }

            private void SpawnRailBase()
            {
                if (traintype == 1) SpawnRailCart1();
                if (traintype == 2) SpawnRailCart2();
                if (traintype == 3) SpawnEngine();
                if (traintype == 4) SpawnCoasterCar();
                if (traintype == 5) SpawnCustomPrefab();
            }

            private void SpawnCoasterCar()
            {
                frontswitch = SpawnPart(doorcontroller, frontswitch, setGameObjectActive, 0, 180, 0, -0.5f, 0.5f, 1.4f, railCart, 1);
                frontswitch.SetFlag(BaseEntity.Flags.Reserved8, true, false);
                frontswitch.SetFlag(BaseEntity.Flags.On, autoStartTrain, false);

                floor1 = SpawnPart(floorprefab, floor1, setGameObjectActive, 0, 0, 0, 0f, 1f, 0f, railCart, 1);

                chair1 = SpawnPart(chairprefab, chair1, false, 0, 0, 0, 1.0f, 1f, 0.8f, railCart, 1);
                chair2 = SpawnPart(chairprefab, chair2, false, 0, 0, 0, 0.0f, 1f, 0.8f, railCart, 1);
                chair3 = SpawnPart(chairprefab, chair3, false, 0, 0, 0, -1.0f, 1f, 0.8f, railCart, 1);

                chair4 = SpawnPart(chairprefab, chair4, false, 0, 0, 0, 1.0f, 1f, -0.8f, railCart, 1);
                chair5 = SpawnPart(chairprefab, chair5, false, 0, 0, 0, 0.0f, 1f, -0.8f, railCart, 1);
                chair6 = SpawnPart(chairprefab, chair6, false, 0, 0, 0, -1.0f, 1f, -0.8f, railCart, 1);

                seatback1 = SpawnPart(lowwallprefab, seatback1, false, 0, 270, 10, 0.0f, 1f, 0.1f, railCart, 1);
                seatback2 = SpawnPart(lowwallprefab, seatback2, false, 0, 270, 10, 0.0f, 1f, -1.4f, railCart, 1);

                seat1 = SpawnPart(lowwallprefab, seat1, false, 0, 270, 90, 0.0f, 1.4f, 1.0f, railCart, 1);
                seat2 = SpawnPart(lowwallprefab, seat2, false, 0, 270, 90, 0.0f, 1.4f, -0.5f, railCart, 1);

                rightwall1 = SpawnPart(lowwallprefab, rightwall1, setGameObjectActive, 0, 0, 0, 1.4f, 0.7f, 0.0f, railCart, 1);
                leftwall1 = SpawnPart(lowwallprefab, leftwall1, setGameObjectActive, 0, 180, 0, -1.4f, 0.7f, 0.0f, railCart, 1);

                frontLowWall = SpawnPart(lowwallprefab, frontDoorWay, setGameObjectActive, 0, 270, 0, 0f, 0.7f, 1.5f, railCart, 1);
                rearLowWall = SpawnPart(lowwallprefab, rearDoorWay, setGameObjectActive, 0, 90, 0, 0f, 0.7f, -1.5f, railCart, 1);

                lightleft = SpawnPart(lightprefab, lightleft, true, -15, 10, 0, 1.1f, 1f, 1.5f, railCart, 1);
                lightright = SpawnPart(lightprefab, lightright, true, -15, 10, 0, -1.1f, 1f, 1.5f, railCart, 1);

                lightleft2 = SpawnPart(lightprefab, lightleft, true, -15, 190, 0, 1.1f, 1f, -1.5f, railCart, 1);
                lightright2 = SpawnPart(lightprefab, lightright, true, -15, 190, 0, -1.1f, 1f, -1.5f, railCart, 1);

                wheel1 = SpawnPart(wheelprefab, wheel1, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, 1.0f, railCart, 1);
                wheel2 = SpawnPart(wheelprefab, wheel2, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, 1.0f, railCart, 1);
                wheel3 = SpawnPart(wheelprefab, wheel3, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, -1.0f, railCart, 1);
                wheel4 = SpawnPart(wheelprefab, wheel4, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, -1.0f, railCart, 1);

                spawncomplete = true;
            }

            private void SpawnEngine()
            {
                frontswitch = SpawnPart(doorcontroller, frontswitch, setGameObjectActive, 0, 180, 0, -0.3f, 0.9f, 0f, railCart, 1);
                frontswitch.SetFlag(BaseEntity.Flags.Reserved8, true, false);
                frontswitch.SetFlag(BaseEntity.Flags.On, autoStartTrain, false);

                lightleft = SpawnPart(lightprefab, lightleft, false, -15, 0, 0, 1.1f, 1f, 6.1f, railCart, 1);
                lightright = SpawnPart(lightprefab, lightright, false, -15, 0, 0, -1.1f, 1f, 6.1f, railCart, 1);

                frontwall = SpawnPart(lowwallprefab, frontwall, false, 0, 270, 0, 0f, 1f, 6f, railCart, 1);
                midwall = SpawnPart(windowwallprefab, midwall, false, 0, 270, 0, 0f, 1f, 0f, railCart, 1);
                rearwall = SpawnPart(wallframeprefab, rearwall, false, 0, 90, 0, 0f, 1f, -6f, railCart, 1);
                reardoor = SpawnPart(garagedoorprefab, reardoor, false, 0, 90, 0, 0f, 1f, -6f, railCart, 1);

                furnace1 = SpawnPart(refineryprefab, furnace1, false, 0, 0, 0, 0f, 1.5f, 4f, railCart, 1);
                furnace2 = SpawnPart(refineryprefab, furnace2, false, 0, 0, 0, 0f, 1.5f, 2.5f, railCart, 1);

                floor1 = SpawnPart(floorprefab, floor1, false, 0, 0, 0, 0f, 1f, 4.5f, railCart, 1);
                floor2 = SpawnPart(floorprefab, floor2, false, 0, 0, 0, 0f, 1f, 1.5f, railCart, 1);
                floor3 = SpawnPart(floorprefab, floor1, false, 0, 0, 0, 0f, 1f, -1.5f, railCart, 1);
                floor4 = SpawnPart(floorprefab, floor2, false, 0, 0, 0, 0f, 1f, -4.5f, railCart, 1);

                ceiling1 = SpawnPart(floorprefab, ceiling1, false, 0, 0, 0, 0f, 2f, 4.5f, railCart, 1);
                ceiling2 = SpawnPart(floorprefab, ceiling2, false, 0, 0, 0, 0f, 2f, 1.5f, railCart, 1);
                ceiling3 = SpawnPart(floorprefab, ceiling3, false, 0, 0, 0, 0f, 4f, -1.5f, railCart, 1);
                ceiling4 = SpawnPart(floorprefab, ceiling4, false, 0, 0, 0, 0f, 4f, -4.5f, railCart, 1);

                rightwall1 = SpawnPart(lowwallprefab, rightwall1, false, 0, 0, 0, 1.5f, 1f, 4.5f, railCart, 1);
                rightwall2 = SpawnPart(lowwallprefab, rightwall2, false, 0, 0, 0, 1.5f, 1f, 1.5f, railCart, 1);
                rightwall3 = SpawnPart(windowwallprefab, rightwall3, false, 0, 0, 0, 1.5f, 1f, -1.5f, railCart, 1);
                rigthwall4 = SpawnPart(doorwayprefab, rigthwall4, false, 0, 0, 0, 1.5f, 1f, -4.5f, railCart, 1);

                leftwall1 = SpawnPart(lowwallprefab, leftwall1, false, 0, 180, 0, -1.5f, 1f, 4.5f, railCart, 1);
                leftwall2 = SpawnPart(lowwallprefab, leftwall2, false, 0, 180, 0, -1.5f, 1f, 1.5f, railCart, 1);
                leftwall3 = SpawnPart(windowwallprefab, leftwall3, false, 0, 180, 0, -1.5f, 1f, -1.5f, railCart, 1);
                leftwall4 = SpawnPart(doorwayprefab, leftwall4, false, 0, 180, 0, -1.5f, 1f, -4.5f, railCart, 1);

                wheel1 = SpawnPart(wheelprefab, wheel1, false, 90, 0, 90, 0.75f, 0.5f, 4f, railCart, 1);
                wheel2 = SpawnPart(wheelprefab, wheel2, false, 90, 0, 90, 0.75f, 0.5f, 2.5f, railCart, 1);
                wheel3 = SpawnPart(wheelprefab, wheel3, false, 90, 0, 90, -0.75f, 0.5f, 4f, railCart, 1);
                wheel4 = SpawnPart(wheelprefab, wheel4, false, 90, 0, 90, -0.75f, 0.5f, 2.5f, railCart, 1);

                wheel5 = SpawnPart(wheelprefab, wheel5, false, 90, 0, 90, 0.75f, 0.5f, -4f, railCart, 1);
                wheel6 = SpawnPart(wheelprefab, wheel6, false, 90, 0, 90, 0.75f, 0.5f, -2.5f, railCart, 1);
                wheel7 = SpawnPart(wheelprefab, wheel7, false, 90, 0, 90, -0.75f, 0.5f, -4f, railCart, 1);
                wheel8 = SpawnPart(wheelprefab, wheel8, false, 90, 0, 90, -0.75f, 0.5f, -2.5f, railCart, 1);

                boxcollider = railCart.gameObject.AddComponent<BoxCollider>();
                boxcollider.gameObject.layer = (int)Layer.Reserved1;
                boxcollider.isTrigger = true;
                boxcollider.center = new Vector3(0f, 4.1f, 0f);
                // left/right   up/down   front/back
                boxcollider.size = new Vector3(3f, 4.5f, 12f);

                rigidHitBody = boxcollider.gameObject.AddComponent<Rigidbody>();
                rigidHitBody.isKinematic = true;
                rigidHitBody.detectCollisions = true;
                rigidHitBody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
                rigidHitBody.useGravity = false;

                spawncomplete = true;
            }

            private void SpawnRailCart1()
            {
                frontswitch = SpawnPart(doorcontroller, frontswitch, setGameObjectActive, 0, 180, 0, -0.3f, 0.9f, 5.9f, railCart, 1);
                frontswitch.SetFlag(BaseEntity.Flags.Reserved8, true, false);
                frontswitch.SetFlag(BaseEntity.Flags.On, autoStartTrain, false);

                lightleft = SpawnPart(lightprefab, lightleft, true, -15, 10, 0, 1.1f, 1f, 6.1f, railCart, 1);
                lightright = SpawnPart(lightprefab, lightright, true, -15, 10, 0, -1.1f, 1f, 6.1f, railCart, 1);

                lightleft2 = SpawnPart(lightprefab, lightleft, true, -15, 190, 0, 1.1f, 1f, -6.1f, railCart, 1);
                lightright2 = SpawnPart(lightprefab, lightright, true, -15, 190, 0, -1.1f, 1f, -6.1f, railCart, 1);

                floor1 = SpawnPart(floorprefab, floor1, setGameObjectActive, 0, 0, 0, 0f, 1f, 4.5f, railCart, 1);
                floor2 = SpawnPart(floorprefab, floor2, setGameObjectActive, 0, 0, 0, 0f, 1f, 1.5f, railCart, 1);
                floor3 = SpawnPart(floorprefab, floor1, setGameObjectActive, 0, 0, 0, 0f, 1f, -1.5f, railCart, 1);
                floor4 = SpawnPart(floorprefab, floor2, setGameObjectActive, 0, 0, 0, 0f, 1f, -4.5f, railCart, 1);

                wheel1 = SpawnPart(wheelprefab, wheel1, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, 4f, railCart, 1);
                wheel2 = SpawnPart(wheelprefab, wheel2, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, 2.5f, railCart, 1);
                wheel3 = SpawnPart(wheelprefab, wheel3, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, 4f, railCart, 1);
                wheel4 = SpawnPart(wheelprefab, wheel4, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, 2.5f, railCart, 1);

                wheel5 = SpawnPart(wheelprefab, wheel5, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, -4f, railCart, 1);
                wheel6 = SpawnPart(wheelprefab, wheel6, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, -2.5f, railCart, 1);
                wheel7 = SpawnPart(wheelprefab, wheel7, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, -4f, railCart, 1);
                wheel8 = SpawnPart(wheelprefab, wheel8, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, -2.5f, railCart, 1);

                frontDoorWay = SpawnPart(windowwallprefab, frontDoorWay, setGameObjectActive, 0, 270, 0, 0f, 1f, 6f, railCart, 1);
                rearDoorWay = SpawnPart(windowwallprefab, rearDoorWay, setGameObjectActive, 0, 90, 0, 0f, 1f, -6f, railCart, 1);

                rightwall1 = SpawnPart(doorwayprefab, rightwall1, setGameObjectActive, 0, 0, 0, 1.5f, 1f, 4.5f, railCart, 1);
                rightwall2 = SpawnPart(windowwallprefab, rightwall2, setGameObjectActive, 0, 0, 0, 1.5f, 1f, 1.5f, railCart, 1);
                rightwall3 = SpawnPart(windowwallprefab, rightwall3, setGameObjectActive, 0, 0, 0, 1.5f, 1f, -1.5f, railCart, 1);
                rigthwall4 = SpawnPart(doorwayprefab, rigthwall4, setGameObjectActive, 0, 0, 0, 1.5f, 1f, -4.5f, railCart, 1);

                leftwall1 = SpawnPart(doorwayprefab, leftwall1, setGameObjectActive, 0, 180, 0, -1.5f, 1f, 4.5f, railCart, 1);
                leftwall2 = SpawnPart(windowwallprefab, leftwall2, setGameObjectActive, 0, 180, 0, -1.5f, 1f, 1.5f, railCart, 1);
                leftwall3 = SpawnPart(windowwallprefab, leftwall3, setGameObjectActive, 0, 180, 0, -1.5f, 1f, -1.5f, railCart, 1);
                leftwall4 = SpawnPart(doorwayprefab, leftwall4, setGameObjectActive, 0, 180, 0, -1.5f, 1f, -4.5f, railCart, 1);

                ceiling1 = SpawnPart(floorprefab, ceiling1, setGameObjectActive, 0, 0, 0, 0f, 4f, 4.5f, railCart, 1);
                ceiling2 = SpawnPart(floorprefab, ceiling2, setGameObjectActive, 0, 0, 0, 0f, 4f, 1.5f, railCart, 1);
                ceiling3 = SpawnPart(floorprefab, ceiling3, setGameObjectActive, 0, 0, 0, 0f, 4f, -1.5f, railCart, 1);
                ceiling4 = SpawnPart(floorprefab, ceiling4, setGameObjectActive, 0, 0, 0, 0f, 4f, -4.5f, railCart, 1);

                boxcollider = railCart.gameObject.AddComponent<BoxCollider>();
                boxcollider.gameObject.layer = (int)Layer.Reserved1;
                boxcollider.isTrigger = true;
                boxcollider.center = new Vector3(0f, 4.1f, 0f);
                // left/right   up/down   front/back
                boxcollider.size = new Vector3(3f, 4.5f, 12f);

                rigidHitBody = boxcollider.gameObject.AddComponent<Rigidbody>();
                rigidHitBody.isKinematic = true;
                rigidHitBody.detectCollisions = true;
                rigidHitBody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
                rigidHitBody.useGravity = false;

                spawncomplete = true;
            }

            private void SpawnRailCart2()
            {
                frontswitch = SpawnPart(doorcontroller, frontswitch, setGameObjectActive, 0, 180, 0, -0.3f, 0.9f, 5.9f, railCart, 1);
                frontswitch.SetFlag(BaseEntity.Flags.Reserved8, true, false);
                frontswitch.SetFlag(BaseEntity.Flags.On, autoStartTrain, false);

                lightleft = SpawnPart(lightprefab, lightleft, setGameObjectActive, -15, 10, 0, 1.1f, 1f, 6.1f, railCart, 1);
                lightright = SpawnPart(lightprefab, lightright, setGameObjectActive, -15, 10, 0, -1.1f, 1f, 6.1f, railCart, 1);

                lightleft2 = SpawnPart(lightprefab, lightleft, setGameObjectActive, -15, 190, 0, 1.1f, 1f, -6.1f, railCart, 1);
                lightright2 = SpawnPart(lightprefab, lightright, setGameObjectActive, -15, 190, 0, -1.1f, 1f, -6.1f, railCart, 1);

                floor1 = SpawnPart(floorprefab, floor1, setGameObjectActive, 0, 0, 0, 0f, 1f, 4.5f, railCart, 1);
                floor2 = SpawnPart(floorprefab, floor2, setGameObjectActive, 0, 0, 0, 0f, 1f, 1.5f, railCart, 1);
                floor3 = SpawnPart(floorprefab, floor1, setGameObjectActive, 0, 0, 0, 0f, 1f, -1.5f, railCart, 1);
                floor4 = SpawnPart(floorprefab, floor2, setGameObjectActive, 0, 0, 0, 0f, 1f, -4.5f, railCart, 1);

                wheel1 = SpawnPart(wheelprefab, wheel1, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, 4f, railCart, 1);
                wheel2 = SpawnPart(wheelprefab, wheel2, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, 2.5f, railCart, 1);
                wheel3 = SpawnPart(wheelprefab, wheel3, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, 4f, railCart, 1);
                wheel4 = SpawnPart(wheelprefab, wheel4, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, 2.5f, railCart, 1);

                wheel5 = SpawnPart(wheelprefab, wheel5, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, -4f, railCart, 1);
                wheel6 = SpawnPart(wheelprefab, wheel6, setGameObjectActive, 90, 0, 90, 0.75f, 0.5f, -2.5f, railCart, 1);
                wheel7 = SpawnPart(wheelprefab, wheel7, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, -4f, railCart, 1);
                wheel8 = SpawnPart(wheelprefab, wheel8, setGameObjectActive, 90, 0, 90, -0.75f, 0.5f, -2.5f, railCart, 1);

                frontDoorWay = SpawnPart(doorwayprefab, frontDoorWay, setGameObjectActive, 0, 270, 0, 0f, 1f, 4.5f, railCart, 1);
                rearDoorWay = SpawnPart(doorwayprefab, rearDoorWay, setGameObjectActive, 0, 90, 0, 0f, 1f, -4.5f, railCart, 1);

                frontLowWall = SpawnPart(lowwallprefab, frontDoorWay, setGameObjectActive, 0, 270, 0, 0f, 1f, 6f, railCart, 1);
                rearLowWall = SpawnPart(lowwallprefab, rearDoorWay, setGameObjectActive, 0, 90, 0, 0f, 1f, -6f, railCart, 1);

                rightwall1 = SpawnPart(windowwallprefab, rightwall1, setGameObjectActive, 0, 0, 0, 1.5f, 1f, 3.0f, railCart, 1);
                rightwall2 = SpawnPart(windowwallprefab, rightwall2, setGameObjectActive, 0, 0, 0, 1.5f, 1f, 1.5f, railCart, 1);
                rightwall3 = SpawnPart(windowwallprefab, rightwall3, setGameObjectActive, 0, 0, 0, 1.5f, 1f, -1.5f, railCart, 1);
                rigthwall4 = SpawnPart(windowwallprefab, rigthwall4, setGameObjectActive, 0, 0, 0, 1.5f, 1f, -3.0f, railCart, 1);

                leftwall1 = SpawnPart(windowwallprefab, leftwall1, setGameObjectActive, 0, 180, 0, -1.5f, 1f, 3.0f, railCart, 1);
                leftwall2 = SpawnPart(windowwallprefab, leftwall2, setGameObjectActive, 0, 180, 0, -1.5f, 1f, 1.5f, railCart, 1);
                leftwall3 = SpawnPart(windowwallprefab, leftwall3, setGameObjectActive, 0, 180, 0, -1.5f, 1f, -1.5f, railCart, 1);
                leftwall4 = SpawnPart(windowwallprefab, leftwall4, setGameObjectActive, 0, 180, 0, -1.5f, 1f, -3.0f, railCart, 1);

                ceiling1 = SpawnPart(floorprefab, ceiling1, setGameObjectActive, 0, 0, 0, 0f, 4f, 4.5f, railCart, 1);
                ceiling2 = SpawnPart(floorprefab, ceiling2, setGameObjectActive, 0, 0, 0, 0f, 4f, 1.5f, railCart, 1);
                ceiling3 = SpawnPart(floorprefab, ceiling3, setGameObjectActive, 0, 0, 0, 0f, 4f, -1.5f, railCart, 1);
                ceiling4 = SpawnPart(floorprefab, ceiling4, setGameObjectActive, 0, 0, 0, 0f, 4f, -4.5f, railCart, 1);

                boxcollider = railCart.gameObject.AddComponent<BoxCollider>();
                boxcollider.gameObject.layer = (int)Layer.Reserved1;
                boxcollider.isTrigger = true;
                boxcollider.center = new Vector3(0f, 4.1f, 0f);
                // left/right   up/down   front/back
                boxcollider.size = new Vector3(3f, 4.5f, 12f);

                rigidHitBody = boxcollider.gameObject.AddComponent<Rigidbody>();
                rigidHitBody.isKinematic = true;
                rigidHitBody.detectCollisions = true;
                rigidHitBody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
                rigidHitBody.useGravity = false;

                spawncomplete = true;
            }

            private void SpawnCustomPrefab()
            {
                frontswitch = SpawnPart(doorcontroller, frontswitch, setGameObjectActive, 0, 0, 0, 0f, 0f, 0f, railCart, 1);
                frontswitch.SetFlag(BaseEntity.Flags.Reserved8, true, false);
                frontswitch.SetFlag(BaseEntity.Flags.On, autoStartTrain, false);
                rowBoat = SpawnPart(customPrefab, rowBoat, setGameObjectActive, 0, 0, 0, 0f, 0f, 0f, railCart, 1);
                spawncomplete = true;
            }

            private void SpawnRefresh(BaseNetworkable entity1)
            {
                var hasstab = entity1.GetComponent<StabilityEntity>();
                if (entity1.GetComponent<StabilityEntity>())
                {
                    hasstab.grounded = true;
                }
                var hasblock = entity1.GetComponent<BuildingBlock>();
                if (hasblock)
                {
                    hasblock.SetGrade(BuildingGrade.Enum.Metal);
                    hasblock.SetHealthToMax();
                    hasblock.UpdateSkin();
                    hasblock.ClientRPC(null, "RefreshSkin");
                }
            }

            void OnTriggerEnter(Collider col)
            {
                if (col.name.Contains("/player/player.prefab"))
                {
                    var player = col.GetComponentInParent<BasePlayer>() ?? null;
                    if (player != null && player.isMounted)
                    {
                        return;
                    }
                    if (player != null && player.IsSleeping())
                    {
                        return;
                    }
                    if (player.GetParentEntity() == base.gameObject.ToBaseEntity())
                    {
                        return;
                    }
                    if (player != null)
                    {
                        BaseEntity getpar = player.GetParentEntity() ?? null;
                        if (getpar == null)
                        {
                            player.SetParent(railCart, true, true);
                            player.PauseFlyHackDetection(99999f);
                            player.PauseSpeedHackDetection(99999f);
                            player.PauseVehicleNoClipDetection(99999f);
                        }
                    }
                    return;
                }
                if (config.trainSettings.damageOnCollision)
                {
                    var getEntity = col.GetComponentInParent<BaseCombatEntity>();
                    if (getEntity)
                    {
                        getEntity.Hurt(2500f, Rust.DamageType.Explosion, null, true);
                    }
                }
            }

            void OnTriggerExit(Collider col)
            {
                if (col.name.Contains("/player/player.prefab"))
                {
                    var player = col.GetComponentInParent<BasePlayer>() ?? null;
                    if (player != null)
                    {
                        if (player != null && player.IsSleeping())
                        {
                            player.SetParent(null, true, true);
                            return;
                        }
                        if (player.GetParentEntity() != base.gameObject.ToBaseEntity())
                        {
                            return;
                        }
                        player.SetParent(null, true, true);
                        player.PauseFlyHackDetection(5f);
                        player.PauseSpeedHackDetection(5f);
                        player.PauseVehicleNoClipDetection(5f);
                    }
                }
            }

            private void applyBlastDamage(BasePlayer player, float damageamount, float radius, Rust.DamageType damagetype, Vector3 location)
            {
                List<BaseCombatEntity> entityList = Pool.GetList<BaseCombatEntity>();
                Vis.Entities<BaseCombatEntity>(location, radius, entityList);

                foreach (BaseCombatEntity combatentity in entityList)
                {
                    if (!(combatentity is BuildingPrivlidge))
                    {
                        combatentity.Hurt(damageamount, damagetype, player, true);
                    }
                }
                Pool.FreeList<BaseCombatEntity>(ref entityList);
            }

            private void FindNextBusStop()
            {
                Vector3 currentPosition = railCart.transform.position;

                foreach (Vector3 busstops in stoplist)
                {
                    Vector3 directionToTarget = busstops - currentPosition;
                    float dSqrToTarget = directionToTarget.sqrMagnitude;
                    if (dSqrToTarget < 12f && dSqrToTarget > 4f)
                    {
                        findnext = false;
                        frontswitch.SetFlag(BaseEntity.Flags.On, false, false);
                        instance.timer.Once(stopWait, () => { frontswitch.SetFlag(BaseEntity.Flags.On, true, false); });
                        instance.timer.Once(stopWait + 5f, () => { findnext = true; });
                    }
                }
            }

            private Vector3 FindCoords()
            {
                movetolist = storedData.trainTrackData[usingListNamed].trackMarkers;
                Vector3 point1 = movetolist.ElementAtOrDefault(0);
                if (moveforward) counter++;
                else counter--;
                point1 = movetolist.ElementAtOrDefault(counter);
                return point1;
            }

            private void FixedUpdate()
            {
                if (!spawncomplete) return;
                if (frontswitch != null && frontswitch.IsOn() && steps < maxSpeed) steps += 2f;
                if (frontswitch != null && !frontswitch.IsOn()) steps -= 0.5f;

                if (npcmove)
                {
                    currentPos = railCart.transform.position;
                    if (movetopoint == new Vector3(0f, 0f, 0f)) return;
                    if (findnext && findnextstop) FindNextBusStop();
                    if (loopmovement && currentPos == movetolist.Last()) { movetopoint = movetolist.ElementAtOrDefault(0); counter = 0; moveforward = true; }
                    else if (!loopmovement && moveforward && currentPos == movetolist.Last()) { counter = movetolist.Count; moveforward = false; }
                    else if (!loopmovement && !moveforward && currentPos == movetolist.ElementAtOrDefault(0)) { counter = 0; moveforward = true; }
                    if (currentPos == movetopoint)
                    {
                        movetopoint = FindCoords();
                    }
                    if (moveforward) targetDir = movetopoint - railCart.transform.position;
                    else targetDir = railCart.transform.position - movetopoint;

                    newDir = Vector3.RotateTowards(transform.forward, targetDir, 2.5f * Time.deltaTime, 0.0F);

                    if (useAngleSpeed)
                    {
                        var angleOA = (Convert.ToInt32(newDir.y * 100f));
                        if (moveforward && angleOA > 10f) maxSpeed = storedData.trainTrackData[usingListNamed].maxSpeed * 0.5f;
                        else if (moveforward && angleOA < -10f) maxSpeed = storedData.trainTrackData[usingListNamed].maxSpeed * 5f;
                        else if (!moveforward && angleOA > 10f) maxSpeed = storedData.trainTrackData[usingListNamed].maxSpeed * 5f;
                        else if (!moveforward && angleOA < -10f) maxSpeed = storedData.trainTrackData[usingListNamed].maxSpeed * 0.5f;
                        else maxSpeed = storedData.trainTrackData[usingListNamed].maxSpeed;
                    }

                    if (steps > maxSpeed) steps = steps -= 0.5f;
                    if (steps <= 0f) steps = 0f;

                    railCart.transform.position = Vector3.MoveTowards(transform.position, movetopoint, (steps) * Time.deltaTime);
                    railCart.transform.rotation = Quaternion.LookRotation(newDir);
                    ServerMgr.Instance.StartCoroutine(RefreshTrain());
                }

            }

            private IEnumerator RefreshTrain()
            {
                railCart.transform.hasChanged = true;
                for (int i = 0; i < railCart.children.Count; i++)
                {
                    if (railCart.children[i] is BuildingBlock)
                    {
                        var isblock = (BuildingBlock)railCart.children[i];
                        isblock.ClientRPC(null, "RefreshSkin");
                    }
                    if (railCart.children[i] is SpinnerWheel)
                    {
                        railCart.children[i].transform.hasChanged = true;
                        railCart.children[i].SendNetworkUpdateImmediate();
                    }
                }
                railCart.SendNetworkUpdateImmediate();
                yield return new WaitForEndOfFrame();
            }

            private void OnDestroy()
            {
                if (boxcollider != null) GameObject.Destroy(boxcollider);
                if (railCart != null) railCart.Kill(BaseNetworkable.DestroyMode.None);
                GameObject.Destroy(this);
            }
        }

        #endregion

        #region Track Edit GUI

        class TrackEditGUI : MonoBehaviour
        {
            BasePlayer player;
            Trains instance;
            public string trackstring;
            int typeOfTrain;
            bool loopingTrain;
            bool autoSpawn;
            bool autoStart;
            float maxSpeed;
            float waitTime;
            int waypointCount;
            int stoppointCount;
            string redcolor;
            string greencolor;
            string orangecolor;
            string blackcolor;
            string bluecolor;
            Double guiMax;
            Double guiMin;
            Double guiIncrementor;
            public bool enableShowLines = false;
            public bool enableShowText = false;
            public bool enableShowStops = false;
            public bool enableMiddleMouse = false;
            bool debugShowCompleted = false;

            string buttonShowLinesColor;
            string buttonShowTextColor;
            string middleMouseColor;
            string buttonShowStopsColor;

            CuiElementContainer trackEditGUI;
            CuiElementContainer backgroundGUI;
            CuiElementContainer trackListCUI;

            public void Awake()
            {
                player = GetComponent<BasePlayer>();
                instance = new Trains();
                typeOfTrain = 1;
                loopingTrain = false;
                autoSpawn = true;
                autoStart = true;
                waypointCount = 0;
                stoppointCount = 0;
                redcolor = "1.0 0.3 0.3 0.7";
                greencolor = "0.0 0.7 0.0 0.7";
                orangecolor = "0.9 0.3 0.0 0.7";
                blackcolor = "0.0 0.0 0.0 0.9";
                bluecolor = "0.0 0.0 0.7 0.9";
                guiMax = 0.940;
                guiMin = 0.900;
                guiIncrementor = 0.045;
                AddBackground(player);
            }

            public void RefreshTrackList(BasePlayer guiplayer, string trackname)
            {
                trackstring = trackname;
                player = guiplayer;
                guiMax = 0.940;
                guiMin = 0.900;
                AddListTracks(player);
                AddEditGUI(player, trackname);
            }

            private void AddGUIButton(CuiElementContainer container, string command, string bcolor, string anchmin, string anchmax, string buttontxt, string buttonname, int fontsize = 10)
            {
                container.Add(new CuiButton
                {
                    Button = { Command = command, Color = bcolor },
                    RectTransform = { AnchorMin = anchmin, AnchorMax = anchmax },
                    Text = { Text = buttontxt, FontSize = fontsize, Color = "1.0 1.0 1.0 1.0", Align = TextAnchor.MiddleCenter }
                }, "Overall", buttonname);
            }

            private void AddBackground(BasePlayer player)
            {
                DestroyBackgroundGUI(player);
                backgroundGUI = new CuiElementContainer();
                AddGUIButton(backgroundGUI, "", blackcolor, "0.30 0.665", "0.475 0.95", "", "background1", 10);
                AddGUIButton(backgroundGUI, "", blackcolor, "0.475 0.665", "0.77 0.95", "", "backgroundedit", 10);
                CuiHelper.AddUi(player, backgroundGUI);
            }

            private void AddEditGUI(BasePlayer player, string trackname)
            {
                trackstring = trackname;
                if (storedData.trainTrackData.ContainsKey(trackstring.ToLower()))
                {
                    typeOfTrain = storedData.trainTrackData[trackstring].trainType;
                    loopingTrain = storedData.trainTrackData[trackstring].looping;
                    autoSpawn = storedData.trainTrackData[trackstring].autospawn;
                    autoStart = storedData.trainTrackData[trackstring].autostart;
                    waypointCount = storedData.trainTrackData[trackstring].trackMarkers.Count;
                    stoppointCount = storedData.trainTrackData[trackstring].trainStops.Count;
                    maxSpeed = storedData.trainTrackData[trackstring].maxSpeed;
                    waitTime = storedData.trainTrackData[trackstring].stopWaitTime;
                }
                AddEditGui(player);
            }

            private void DestroyBackgroundGUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "background1");
                CuiHelper.DestroyUi(player, "backgroundedit");
            }

            public void AddListTracks(BasePlayer player)
            {
                DestroyListGUI(player);
                trackListCUI = new CuiElementContainer();

                AddGUIButton(trackListCUI, "", blackcolor, "0.28 0.665", "0.30 0.95", "<color=white>T\nR\nA\nI\nN\nS</color>", "titlebar", 25);

                if (storedData.trainTrackData.Any())
                {
                    AddGUIButton(trackListCUI, "", blackcolor, "0.37 " + guiMin.ToString(), "0.47 " + guiMax.ToString(), "<color=cyan>Avaialble Tracks</color>", "tracknames", 15);

                    guiMax -= guiIncrementor;
                    guiMin -= guiIncrementor;

                    var listbuttoncolor = blackcolor;
                    foreach (var listname in storedData.trainTrackData.Keys)
                    {
                        AddGUIButton(trackListCUI, "track.edit " + listname, listbuttoncolor = listname.ToLower() == trackstring.ToLower() ? greencolor : blackcolor, "0.37 " + guiMin.ToString(), "0.47 " + guiMax.ToString(), listname, listname, 10);
                        guiMax -= guiIncrementor;
                        guiMin -= guiIncrementor;
                    }
                }
                else
                {
                    AddGUIButton(trackListCUI, "", blackcolor, "0.37 0.900", "0.47 0.940", " <color=orange>No Tracks Listed</color>", "tracknames", 10);
                }
                AddGUIButton(trackListCUI, "trackmode", blackcolor, "0.31 0.675", "0.36 0.715", "<color=red>EXIT</color>", "exitbutton", 15);
                CuiHelper.AddUi(player, trackListCUI);
            }

            public void AddEditGui(BasePlayer player)
            {
                DestroyEditGUI(player);
                trackEditGUI = new CuiElementContainer();
                AddGUIButton(trackEditGUI, "track.enablemiddle", middleMouseColor = enableMiddleMouse ? greencolor : blackcolor, "0.31 0.900", "0.36 0.940", "<color=yellow>Toggle\n Middle Mark</color>", "togglemiddlemouse", 10);
                AddGUIButton(trackEditGUI, "track.showlines", bluecolor, "0.31 0.855", "0.36 0.895", "<color=yellow>Show\nLines</color>", "showlines", 10);
                AddGUIButton(trackEditGUI, "track.showtext", bluecolor, "0.31 0.810", "0.36 0.850", "<color=yellow>Show\nPoints</color>", "showtext", 10);
                AddGUIButton(trackEditGUI, "track.showstops", bluecolor, "0.31 0.765", "0.36 0.805", "<color=yellow>Show\nStops</color>", "showstops", 10);
                AddGUIButton(trackEditGUI, "", blackcolor, "0.48 0.900", "0.76 0.940", "<color=cyan>Editing Track : </color>" + trackstring, "traintrackname", 15);
                AddGUIButton(trackEditGUI, "", blackcolor, "0.48 0.855", "0.58 0.895", "Train Type = <color=yellow>" + typeOfTrain.ToString() + "</color>", "traintypetext", 10);
                AddGUIButton(trackEditGUI, "track.traintype " + trackstring.ToString(), blackcolor, "0.59 0.855", "0.64 0.895", "<color=yellow>Switch\nTrain Type</color>", "traintypebutton", 10);

                var showAutoSpawnColor = blackcolor;
                if (autoSpawn) showAutoSpawnColor = greencolor;
                AddGUIButton(trackEditGUI, "track.autospawn " + trackstring.ToString(), showAutoSpawnColor, "0.65 0.855", "0.70 0.895", "<color=yellow>Auto\nSpawn</color>", "autospawnbutton", 10);
                AddGUIButton(trackEditGUI, "track.maxspeed " + trackstring.ToString(), blackcolor, "0.71 0.855", "0.76 0.895", "Top Speed\n<color=yellow>" + maxSpeed.ToString() + "</color>", "maxspeedcount", 10);
                AddGUIButton(trackEditGUI, "track.waittime " + trackstring.ToString(), blackcolor, "0.71 0.810", "0.76 0.850", "Stop Wait\n<color=yellow>" + waitTime.ToString() + "</color>", "waittimecount", 10);
                AddGUIButton(trackEditGUI, "", blackcolor, "0.48 0.810", "0.58 0.850", "Track Loops = <color=yellow>" + loopingTrain.ToString() + "</color>", "loopingtext", 10);
                AddGUIButton(trackEditGUI, "track.trainloop " + trackstring.ToString(), blackcolor, "0.59 0.810", "0.64 0.850", "<color=yellow>Switch\nLooping</color>", "looptypebutton", 10);

                var showAutoStartColor = blackcolor;
                if (autoStart) showAutoStartColor = greencolor;
                AddGUIButton(trackEditGUI, "track.autostart " + trackstring.ToString(), showAutoStartColor, "0.65 0.810", "0.70 0.850", "<color=yellow>Auto\nStart</color>", "autostartbutton", 10);

                AddGUIButton(trackEditGUI, "", blackcolor, "0.48 0.765", "0.58 0.805", "Track Waypoints : <color=yellow>" + waypointCount + "</color>", "numwaypoints", 10);
                AddGUIButton(trackEditGUI, "track.mark " + trackstring, blackcolor, "0.59 0.765", "0.64 0.805", "<color=yellow>Mark New\nWaypoint</color>", "markwaypoint", 10);
                AddGUIButton(trackEditGUI, "track.deletelastmark " + trackstring.ToString(), blackcolor, "0.65 0.765", "0.70 0.805", "<color=orange>Del Last\nWaypoint</color>", "dellastwaypoint", 10);
                AddGUIButton(trackEditGUI, "", blackcolor, "0.48 0.720", "0.58 0.760", "Track Stops : <color=yellow>" + stoppointCount + "</color>", "numstops", 10);
                AddGUIButton(trackEditGUI, "track.markstop " + trackstring, blackcolor, "0.59 0.720", "0.64 0.760", "<color=yellow>Mark New\nStop</color>", "markstoppoint", 10);
                AddGUIButton(trackEditGUI, "track.deletelaststop " + trackstring.ToString(), blackcolor, "0.65 0.720", "0.70 0.760", "<color=orange>Del Last\nStop</color>", "dellaststop", 10);
                AddGUIButton(trackEditGUI, "track.remove " + trackstring, blackcolor, "0.48 0.675", "0.70 0.715", "<color=red>DELETE THIS TRACK</color>", "removetrack", 15);
                CuiHelper.AddUi(player, trackEditGUI);
            }

            private void DestroyListGUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "titlebar");
                CuiHelper.DestroyUi(player, "exitbutton");
                foreach (string listname in storedData.trainTrackData.Keys)
                {
                    CuiHelper.DestroyUi(player, listname);
                }
                CuiHelper.DestroyUi(player, "tracknames");
            }

            private void DestroyEditGUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "showlines");
                CuiHelper.DestroyUi(player, "showtext");
                CuiHelper.DestroyUi(player, "showstops");
                CuiHelper.DestroyUi(player, "togglemiddlemouse");
                CuiHelper.DestroyUi(player, "traintrackname");
                CuiHelper.DestroyUi(player, "traintypetext");
                CuiHelper.DestroyUi(player, "traintypebutton");
                CuiHelper.DestroyUi(player, "loopingtext");
                CuiHelper.DestroyUi(player, "looptypebutton");
                CuiHelper.DestroyUi(player, "autospawnbutton");
                CuiHelper.DestroyUi(player, "autostartbutton");
                CuiHelper.DestroyUi(player, "maxspeedcount");
                CuiHelper.DestroyUi(player, "waittimecount");
                CuiHelper.DestroyUi(player, "markwaypoint");
                CuiHelper.DestroyUi(player, "markstoppoint");
                CuiHelper.DestroyUi(player, "numwaypoints");
                CuiHelper.DestroyUi(player, "dellastwaypoint");
                CuiHelper.DestroyUi(player, "numstops");
                CuiHelper.DestroyUi(player, "dellaststop");
                CuiHelper.DestroyUi(player, "removetrack");
            }


            public IEnumerator ShowLines()
            {
                for (int i = 0; i < storedData.trainTrackData[trackstring].trackMarkers.Count; i++)
                {
                    if (storedData.trainTrackData[trackstring].trackMarkers[i] != storedData.trainTrackData[trackstring].trackMarkers.Last())
                    {
                        if (player != null) player.SendConsoleCommand("ddraw.line", new object[] { config.trainSettings.timeShowLines, Color.white, storedData.trainTrackData[trackstring].trackMarkers[i] + Vector3.up, storedData.trainTrackData[trackstring].trackMarkers[i + 1] + Vector3.up });
                    }
                    yield return new WaitForEndOfFrame();
                }
            }

            public IEnumerator ShowText()
            {
                for (int i = 0; i < storedData.trainTrackData[trackstring].trackMarkers.Count; i++)
                {

                    if (player != null) player.SendConsoleCommand("ddraw.text", new object[] { config.trainSettings.timeShowText, Color.white, storedData.trainTrackData[trackstring].trackMarkers[i] + Vector3.up, i.ToString() });
                    yield return new WaitForEndOfFrame();
                }
            }

            public IEnumerator ShowStops()
            {
                for (int i = 0; i < storedData.trainTrackData[trackstring].trainStops.Count; i++)
                {
                    if (player != null) player.SendConsoleCommand("ddraw.text", new object[] { config.trainSettings.timeShowStops, Color.red, storedData.trainTrackData[trackstring].trainStops[i] + Vector3.up, i.ToString() });
                    yield return new WaitForEndOfFrame();
                }
            }

            private void FixedUpdate()
            {
                if (enableShowLines) { enableShowLines = false; ServerMgr.Instance.StartCoroutine(ShowLines()); }
                if (enableShowText) { enableShowText = false; ServerMgr.Instance.StartCoroutine(ShowText()); }
                if (enableShowStops) { enableShowStops = false; ServerMgr.Instance.StartCoroutine(ShowStops()); }
            }

            public void OnDestroy()
            {
                DestroyBackgroundGUI(player);
                DestroyListGUI(player);
                DestroyEditGUI(player);
                Destroy(this);
            }
        }

        #endregion

    }
}

// --- End of file: Trains.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ZoneManager.cs ---
// --- Original Local Path: ZoneManager.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Zone Manager", "k1lly0u", "3.0.23")]
    [Description("An advanced management system for creating in-game zones")]
    public class ZoneManager : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Backpacks, PopupNotifications, Spawns;

        private StoredData storedData;

        private DynamicConfigFile data;

        private readonly Hash<string, Zone> zones = new Hash<string, Zone>();

        private readonly Hash<ulong, EntityZones> zonedPlayers = new Hash<ulong, EntityZones>();

        private readonly Hash<uint, EntityZones> zonedEntities = new Hash<uint, EntityZones>();

        private readonly Dictionary<ulong, string> lastPlayerZone = new Dictionary<ulong, string>();


        private ZoneFlags globalFlags;

        private bool zonesInitialized = false;


        private static ZoneManager Instance { get; set; }

        private const string PERMISSION_ZONE = "zonemanager.zone";

        private const string PERMISSION_IGNORE_FLAG = "zonemanager.ignoreflag.";

        private const int PLAYER_MASK = 131072;

        private const int TARGET_LAYERS = ~(1 << 10 | 1 << 18 | 1 << 28 | 1 << 29);
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            Instance = this;

            lang.RegisterMessages(Messages, this);
            
            permission.RegisterPermission(PERMISSION_ZONE, this);

            foreach (object flag in Enum.GetValues(typeof(ZoneFlags)))
                permission.RegisterPermission(PERMISSION_IGNORE_FLAG + flag.ToString().ToLower(), this);

            LoadData();
        }

        private void OnServerInitialized()
        {
            InitializeZones();
            InitializeUpdateBehaviour();
        }

        private void OnTerrainInitialized() => InitializeZones();

        private void OnPlayerConnected(BasePlayer player) => updateBehaviour.QueueUpdate(player);

        private void OnEntityKill(BaseEntity baseEntity)
        {
            if (!baseEntity || !baseEntity.IsValid() || baseEntity.IsDestroyed)
                return;

            EntityZones entityZones;
            if (zonedEntities.TryGetValue(baseEntity.net.ID, out entityZones))
            {
                for (int i = entityZones.Zones.Count - 1; i >= 0; i--)
                {
                    entityZones.Zones.ElementAt(i)?.OnEntityExitZone(baseEntity, false, true);
                }

                zonedEntities.Remove(baseEntity.net.ID);
            }
        }

        private void Unload()
        {
            DestroyUpdateBehaviour();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, ZMUI);

            foreach (KeyValuePair<string, Zone> kvp in zones)
                UnityEngine.Object.Destroy(kvp.Value.gameObject);

            zones.Clear();

            Instance = null;
        }
        #endregion

        #region UpdateQueue  
        private UpdateBehaviour updateBehaviour;

        private void InitializeUpdateBehaviour()
        {
            updateBehaviour = new GameObject("ZoneManager.UpdateBehaviour").AddComponent<UpdateBehaviour>();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                updateBehaviour.QueueUpdate(player);
        }

        private void DestroyUpdateBehaviour() => UnityEngine.Object.Destroy(updateBehaviour?.gameObject);

        // Queue and check players for new zones and that they are still in old zones. Previously any plugin that put a player to sleep and teleports them out of a zone
        // without calling the OnPlayerSleep hook would bypass a player zone update which would result in players being registered in zones they were no longer in.
        // Options are to either continually check and update players, or have every plugin that teleports players call the hook...
        private class UpdateBehaviour : MonoBehaviour
        {
            private System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();

            private Queue<BasePlayer> playerUpdateQueue = new Queue<BasePlayer>();

            private const float MAX_MS = 0.25f;

            private void OnDestroy()
            {
                playerUpdateQueue.Clear();
            }

            internal void QueueUpdate(BasePlayer player)
            {
                if (!playerUpdateQueue.Contains(player))
                    playerUpdateQueue.Enqueue(player);
            }

            private void Update()
            {
                if (Time.frameCount % 10 != 0)
                    return;

                sw.Reset();
                sw.Start();

                while (playerUpdateQueue.Count > 0)
                {
                    if (sw.Elapsed.TotalMilliseconds >= MAX_MS)
                    {
                        sw.Stop();
                        return;
                    }

                    BasePlayer player = playerUpdateQueue.Dequeue();
                    if (!player || !player.IsConnected)
                        continue;

                    Instance.UpdatePlayerZones(player);

                    InvokeHandler.Invoke(this, () => QueueUpdate(player), 2f);
                }
            }
        }
        #endregion

        #region Flag Hooks
        private void OnEntityBuilt(Planner planner, GameObject gObject)
        {
            BasePlayer player = planner?.GetOwnerPlayer();
            if (!player)
                return;

            BaseEntity entity = gObject?.ToBaseEntity();
            if (!entity)
                return;

            if (entity is BuildingBlock || entity is SimpleBuildingBlock)
            {
                if (HasPlayerFlag(player, ZoneFlags.NoBuild, true))
                {
                    entity.Invoke(() => entity.Kill(BaseNetworkable.DestroyMode.Gib), 0.1f);
                    SendMessage(player, Message("noBuild", player.UserIDString));
                }
            }
            else
            {
                if (entity is BuildingPrivlidge)
                {
                    if (HasPlayerFlag(player, ZoneFlags.NoCup, false))
                    {
                        entity.Invoke(() => entity.Kill(BaseNetworkable.DestroyMode.Gib), 0.1f);
                        SendMessage(player, Message("noCup", player.UserIDString));
                    }
                }
                else
                {
                    if (HasPlayerFlag(player, ZoneFlags.NoDeploy, true))
                    {
                        entity.Invoke(() => entity.Kill(BaseNetworkable.DestroyMode.Gib), 0.1f);
                        SendMessage(player, Message("noDeploy", player.UserIDString));
                    }
                }
            }
        }

        private object OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoUpgrade, true))
            {
                SendMessage(player, Message("noUpgrade", player.UserIDString));
                return true;
            }
            return null;
        }

        private void OnItemDeployed(Deployer deployer, BaseEntity deployedEntity)
        {
            BasePlayer player = deployer.GetOwnerPlayer();
            if (!player)
                return;

            if (HasPlayerFlag(player, ZoneFlags.NoDeploy, true))
            {
                deployedEntity.Invoke(() => deployedEntity.Kill(BaseNetworkable.DestroyMode.Gib), 0.1f);
                SendMessage(player, Message("noDeploy", player.UserIDString));
            }
        }

        private void OnItemUse(Item item, int amount)
        {
            BaseEntity entity = item?.parent?.entityOwner;
            if (!entity)
                return;

            if (entity is FlameTurret || entity is AutoTurret || entity is GunTrap)
            {
                if (HasEntityFlag(entity, ZoneFlags.InfiniteTrapAmmo))
                    item.amount += amount;
                return;
            }

            if (entity is SearchLight)
            {
                if (HasEntityFlag(entity, ZoneFlags.AlwaysLights))
                {
                    item.amount += amount;
                    return;
                }

                if (HasEntityFlag(entity, ZoneFlags.AutoLights))
                {
                    if (TOD_Sky.Instance.Cycle.Hour > Instance.configData.AutoLights.OnTime || TOD_Sky.Instance.Cycle.Hour < Instance.configData.AutoLights.OffTime)
                        item.amount += amount;
                }
            }
        }

        private void OnRunPlayerMetabolism(PlayerMetabolism metabolism, BaseCombatEntity ownerEntity, float delta)
        {
            BasePlayer player = ownerEntity as BasePlayer;
            if (!player)
                return;

            if (metabolism.bleeding.value > 0 && HasPlayerFlag(player, ZoneFlags.NoBleed, false))
                metabolism.bleeding.value = 0f;
            if (metabolism.oxygen.value < 1 && HasPlayerFlag(player, ZoneFlags.NoDrown, false))
                metabolism.oxygen.value = 1f;
        }

        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (!player)
                return null;

            if (HasPlayerFlag(player, ZoneFlags.NoChat, true))
            {
                SendMessage(player, Message("noChat", player.UserIDString));
                return true;
            }
            return null;
        }

        private object OnBetterChat(Oxide.Core.Libraries.Covalence.IPlayer iPlayer, string message)
        {
            BasePlayer player = iPlayer.Object as BasePlayer;
            return OnPlayerChat(player, message, ConVar.Chat.ChatChannel.Global);
        }

        private object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoVoice, true))
            {
                SendMessage(player, Message("noVoice", player.UserIDString));
                return true;
            }
            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player || string.IsNullOrEmpty(arg.cmd?.Name))
                return null;

            if (arg.cmd.Name == "kill" && HasPlayerFlag(player, ZoneFlags.NoSuicide, false))
            {
                SendMessage(player, Message("noSuicide", player.UserIDString));
                return true;
            }
            return null;
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            if (!player)
                return;

            if (HasPlayerFlag(player, ZoneFlags.KillSleepers, true))
            {
                player.Die();
                return;
            }

            if (HasPlayerFlag(player, ZoneFlags.EjectSleepers, true))
            {
                EntityZones entityZones;
                if (!zonedPlayers.TryGetValue(player.userID, out entityZones) || entityZones.Count == 0)
                    return;

                for (int i = 0; i < entityZones.Count; i++)
                {
                    Zone zone = entityZones.Zones.ElementAt(i);
                    if (!zone)
                        continue;

                    if (HasFlag(zone, ZoneFlags.EjectSleepers))
                    {
                        EjectPlayer(player, zone);
                        return;
                    }
                }
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (!entity || entity.GetComponent<ResourceDispenser>() != null)
                return null;

            BasePlayer attacker = hitinfo.InitiatorPlayer;
            BasePlayer victim = entity as BasePlayer;

            if (victim != null)
            {
                if (hitinfo.damageTypes.GetMajorityDamageType() == DamageType.Fall)
                {
                    if (HasPlayerFlag(victim, ZoneFlags.NoFallDamage, false))
                        return true;
                }

                if (victim.IsSleeping() && HasPlayerFlag(victim, ZoneFlags.SleepGod, false))
                    return true;
                else if (attacker != null)
                {
                    if (IsNpc(victim))
                        return null;

                    if (HasPlayerFlag(victim, ZoneFlags.PvpGod, false))
                    {
                        if (attacker == victim && hitinfo.damageTypes.GetMajorityDamageType() == DamageType.Suicide)
                        {
                            if (HasPlayerFlag(victim, ZoneFlags.NoSuicide, false))
                                return true;
                            return null;
                        }
                        if (IsNpc(attacker) && configData.NPCHurtPvpGod)
                            return null;

                        return true;
                    }
                    else if (HasPlayerFlag(attacker, ZoneFlags.PvpGod, false) && !IsNpc(attacker))                    
                        return true;                    
                }
                else if (HasPlayerFlag(victim, ZoneFlags.PveGod, false) && !IsNpc(victim))
                    return true;
                else if (hitinfo.Initiator is FireBall && HasPlayerFlag(victim, ZoneFlags.PvpGod, false))
                    return true;
                return null;
            }

            BaseNpc baseNpc = entity as BaseNpc;
            if (baseNpc != null)
            {
                if (HasEntityFlag(baseNpc, ZoneFlags.NoPve))
                {
                    if (attacker != null && CanBypass(attacker, ZoneFlags.NoPve))
                        return null;
                    return true;
                }
                return null;
            }

            if (!(entity is LootContainer) && !(entity is BaseHelicopter))
            {
                if (HasEntityFlag(entity, ZoneFlags.UnDestr))
                {
                    if (hitinfo.InitiatorPlayer != null && CanBypass(hitinfo.InitiatorPlayer, ZoneFlags.UnDestr))
                        return null;

                    if (hitinfo.damageTypes.GetMajorityDamageType() == DamageType.Decay && configData.DecayDamageUndestr)
                        return null;

                    return true;
                }
            }

            return null;
        }

        private void OnEntitySpawned(BaseNetworkable baseNetworkable)
        {
            if (baseNetworkable is BaseEntity)
                timer.In(2, () => CanSpawn(baseNetworkable as BaseEntity));
        }

        private void CanSpawn(BaseEntity baseEntity)
        {
            if (!baseEntity.IsValid() || baseEntity.IsDestroyed)
                return;

            if (Interface.CallHook("CanSpawnInZone", baseEntity) != null)
                return;

            if (baseEntity is BaseCorpse)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoCorpse) && !CanBypass((baseEntity as BaseCorpse).OwnerID, ZoneFlags.NoCorpse))
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
            }
            if (baseEntity is LootContainer || baseEntity is JunkPile)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoLootSpawns))
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
            }
            else if (baseEntity is BaseNpc || baseEntity is NPCPlayer)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoNPCSpawns))
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
            }
            else if (baseEntity is DroppedItem || baseEntity is WorldItem)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoDrop))
                {
                    (baseEntity as WorldItem).item.Remove(0f);
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
                }
            }
            else if (baseEntity is DroppedItemContainer)
            {
                if (HasEntityFlag(baseEntity, ZoneFlags.NoDrop))
                    baseEntity.Invoke(() => baseEntity.Kill(BaseNetworkable.DestroyMode.None), 0.1f);
            }
        }

        private object CanBeWounded(BasePlayer player, HitInfo hitinfo) => HasPlayerFlag(player, ZoneFlags.NoWounded, false) ? (object)false : null;

        private object CanUpdateSign(BasePlayer player, Signage sign)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoSignUpdates, false))
            {
                SendMessage(player, Message("noSignUpdates", player.UserIDString));
                return false;
            }
            return null;
        }

        private object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoOvenToggle, false))
            {
                SendMessage(player, Message("noOvenToggle", player.UserIDString));
                return true;
            }
            return null;
        }

        private object CanUseVending(BasePlayer player, VendingMachine machine)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoVending, false))
            {
                SendMessage(player, Message("noVending", player.UserIDString));
                return false;
            }
            return null;
        }

        private object CanHideStash(BasePlayer player, StashContainer stash)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoStash, false))
            {
                SendMessage(player, Message("noStash", player.UserIDString));
                return false;
            }
            return null;
        }

        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            BasePlayer player = itemCrafter.GetComponent<BasePlayer>();
            if (player != null)
            {
                if (HasPlayerFlag(player, ZoneFlags.NoCraft, false))
                {
                    SendMessage(player, Message("noCraft", player.UserIDString));
                    return false;
                }
            }
            return null;
        }

        private void OnDoorOpened(Door door, BasePlayer player)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoDoorAccess, false))
            {
                SendMessage(player, Message("noDoor", player.UserIDString));
                door.CloseRequest();
            }
        }

        #region Looting Hooks
        private object CanLootPlayer(BasePlayer target, BasePlayer looter) => OnLootPlayerInternal(looter, target);

        private void OnLootPlayer(BasePlayer looter, BasePlayer target) => OnLootPlayerInternal(looter, target);

        private object OnLootPlayerInternal(BasePlayer looter, BasePlayer target)
        {
            if (HasPlayerFlag(looter, ZoneFlags.NoPlayerLoot, false) || (target != null && HasPlayerFlag(target, ZoneFlags.NoPlayerLoot, false)))
            {
                if (looter == target && Backpacks != null)
                {
                    object hookResult = Backpacks.Call("CanLootPlayer", target, looter);
                    if (hookResult is bool && (bool)hookResult)
                        return true;
                }

                SendMessage(looter, Message("noLoot", looter.UserIDString));
                NextTick(looter.EndLooting);
                return false;
            }
            return null;
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (entity is LootableCorpse)
                OnLootCorpse(entity as LootableCorpse, player);
            if (entity is DroppedItemContainer)
                OnLootContainer(entity as DroppedItemContainer, player);
            if (entity is StorageContainer)
                OnLootInternal(player, ZoneFlags.NoBoxLoot);
        }

        private object CanLootEntity(BasePlayer player, LootableCorpse corpse)
        {
            if (corpse.playerSteamID == player.userID && HasPlayerFlag(player, ZoneFlags.LootSelf, false))
                return null;
            return CanLootInternal(player, ZoneFlags.NoPlayerLoot);
        }

        private void OnLootCorpse(LootableCorpse corpse, BasePlayer player)
        {
            if (corpse.playerSteamID == player.userID && HasPlayerFlag(player, ZoneFlags.LootSelf, false))
                return;

            OnLootInternal(player, ZoneFlags.NoPlayerLoot);
        }

        private void OnLootContainer(DroppedItemContainer container, BasePlayer player)
        {
            if (container.playerSteamID == player.userID && HasPlayerFlag(player, ZoneFlags.LootSelf, false))
                return;

            OnLootInternal(player, ZoneFlags.NoPlayerLoot);
        }

        private object CanLootEntity(BasePlayer player, DroppedItemContainer container)
        {
            if (container.playerSteamID == player.userID && HasPlayerFlag(player, ZoneFlags.LootSelf, false))
                return null;

            return CanLootInternal(player, ZoneFlags.NoPlayerLoot);
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container) => CanLootInternal(player, ZoneFlags.NoBoxLoot);

        private object CanLootInternal(BasePlayer player, ZoneFlags flag)
        {
            if (HasPlayerFlag(player, flag, false))
            {
                SendMessage(player, Message("noLoot", player.UserIDString));
                return false;
            }
            return null;
        }

        private void OnLootInternal(BasePlayer player, ZoneFlags flag)
        {
            if (HasPlayerFlag(player, flag, false))
            {
                SendMessage(player, Message("noLoot", player.UserIDString));
                NextTick(player.EndLooting);
            }
        }
        #endregion

        #region Pickup Hooks
        private object CanPickupEntity(BasePlayer player, BaseCombatEntity entity) => CanPickupInternal(player, ZoneFlags.NoEntityPickup);

        private object CanPickupLock(BasePlayer player, BaseLock baseLock) => CanPickupInternal(player, ZoneFlags.NoEntityPickup);

        private object OnItemPickup(Item item, BasePlayer player) => CanPickupInternal(player, ZoneFlags.NoPickup);

        private object CanPickupInternal(BasePlayer player, ZoneFlags flag)
        {
            if (HasPlayerFlag(player, flag, false))
            {
                SendMessage(player, Message("noPickup", player.UserIDString));
                return false;
            }
            return null;
        }
        #endregion

        #region Gather Hooks        
        private object CanLootEntity(ResourceContainer container, BasePlayer player) => OnGatherInternal(player);

        private object OnCollectiblePickup(Item item, BasePlayer player) => OnGatherInternal(player);

        private object OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player) => OnGatherInternal(player);

        private object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item) => OnGatherInternal(entity?.ToPlayer());

        private object OnGatherInternal(BasePlayer player)
        {
            if (player != null)
            {
                if (HasPlayerFlag(player, ZoneFlags.NoGather, false))
                {
                    SendMessage(player, Message("noGather", player.UserIDString));
                    return true;
                }
            }
            return null;
        }
        #endregion

        #region Targeting Hooks
        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity) => OnTargetPlayerInternal(entity?.ToPlayer(), ZoneFlags.NoTurretTargeting);

        private object CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
        {
            if (HasPlayerFlag(entity?.ToPlayer(), ZoneFlags.NoAPCTargeting, false))
                return false;
            return null;
        }

        private object CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoHeliTargeting, false))
            {
                heli.interestZoneOrigin = heli.GetRandomPatrolDestination();
                return false;
            }
            return null;
        }

        private object CanHelicopterStrafeTarget(PatrolHelicopterAI heli, BasePlayer player)
        {
            if (HasPlayerFlag(player, ZoneFlags.NoHeliTargeting, false))
                return false;
            return null;
        }

        private object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity entity) => OnTargetPlayerInternal(entity?.ToPlayer(), ZoneFlags.NoHeliTargeting);

        private object OnNpcTarget(BaseCombatEntity entity, BasePlayer player) => OnTargetPlayerInternal(player, ZoneFlags.NoNPCTargeting);

        private object OnTargetPlayerInternal(BasePlayer player, ZoneFlags flag)
        {
            if (player != null)
            {
                if (HasPlayerFlag(player, flag, false))
                    return true;
            }
            return null;
        }
        #endregion

        #region Additional KillSleeper Checks
        private void OnPlayerSleep(BasePlayer player)
        {
            if (!player)
                return;

            //player.Invoke(()=> UpdatePlayerZones(player), 1f); // Manually update the zones a player is in. Sleeping players don't trigger OnTriggerEnter or OnTriggerExit            

            timer.In(2f, () =>
            {
                if (!player || !player.IsSleeping())
                    return;

                if (!player.IsConnected)
                {
                    if (HasPlayerFlag(player, ZoneFlags.KillSleepers, true))
                    {
                        player.Invoke(() => KillSleepingPlayer(player), 3f);
                        return;
                    }

                    if (HasPlayerFlag(player, ZoneFlags.EjectSleepers, true))
                    {
                        player.Invoke(() =>
                        {
                            if (!player || !player.IsSleeping())
                                return;

                            EntityZones entityZones;
                            if (!zonedPlayers.TryGetValue(player.userID, out entityZones) || entityZones.Count == 0)
                                return;

                            for (int i = 0; i < entityZones.Count; i++)
                            {
                                Zone zone = entityZones.Zones.ElementAt(i);
                                if (!zone)
                                    return;

                                if (HasFlag(zone, ZoneFlags.EjectSleepers))
                                {
                                    EjectPlayer(player, zone);
                                }
                            }
                        }, 3f);
                    }
                }
            });
        }

        private void OnPlayerSleepEnd(BasePlayer player) => updateBehaviour.QueueUpdate(player);

        private void KillSleepingPlayer(BasePlayer player)
        {
            if (!player || !player.IsSleeping())
                return;

            if (HasPlayerFlag(player, ZoneFlags.KillSleepers, true))
            {
                if (player.IsConnected)
                    OnPlayerSleep(player);
                else player.Die();
            }
        }

        private void UpdatePlayerZones(BasePlayer player)
        {
            if (!player)
                return;

            EntityZones entityZones;
            if (zonedPlayers.TryGetValue(player.userID, out entityZones))
            {
                for (int i = entityZones.Count - 1; i >= 0; i--)
                {
                    Zone zone = entityZones.Zones.ElementAt(i);
                    if (!zone || !zone.definition.Enabled)
                        continue;

                    if (zone.definition.Size != Vector3.zero)
                    {
                        if (!IsInsideBounds(zone, player.transform.position))
                            OnPlayerExitZone(player, zone);
                    }
                    else
                    {
                        if (Vector3.Distance(player.transform.position, zone.transform.position) > zone.definition.Radius)
                            OnPlayerExitZone(player, zone);
                    }
                }
            }

            for (int i = 0; i < zones.Count; i++)
            {
                Zone zone = zones.ElementAt(i).Value;
                if (!zone)
                    continue;

                if (entityZones != null && entityZones.Zones.Contains(zone))
                    continue;

                if (zone.definition.Size != Vector3.zero)
                {
                    if (IsInsideBounds(zone, player.transform.position))
                        OnPlayerEnterZone(player, zone);
                }
                else
                {
                    if (Vector3.Distance(player.transform.position, zone.transform.position) <= zone.definition.Radius)
                        OnPlayerEnterZone(player, zone);
                }
            }

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.SafeZone) && !player.InSafeZone())
                player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, false);
        }

        private bool IsInsideBounds(Zone zone, Vector3 worldPos) => zone?.collider?.ClosestPoint(worldPos) == worldPos;
        #endregion
        #endregion

        #region Zone Functions
        private void InitializeZones()
        {
            if (zonesInitialized)
                return;

            foreach (Zone.Definition definition in storedData.definitions)
                CreateZone(definition);

            foreach (Zone zone in zones.Values)
                zone.FindZoneParent();

            zonesInitialized = true;

            UnsubscribeAll();
            UpdateHookSubscriptions();
        }

        private void CreateZone(Zone.Definition definition)
        {
            Zone zone = new GameObject().AddComponent<Zone>();
            zone.InitializeZone(definition);

            zones.Add(definition.Id, zone);
        }

        private bool ReverseVelocity(BasePlayer player)
        {
            BaseVehicle baseVehicle = player.GetMounted().VehicleParent();
            if (baseVehicle != null)
            {
                Vector3 euler = baseVehicle.transform.eulerAngles;
                baseVehicle.transform.rotation = Quaternion.Euler(euler.x, euler.y - 180f, euler.z);
                baseVehicle.rigidBody.velocity *= -1f;
                return true;
            }
            return false;
        }

        private void EjectPlayer(BasePlayer player, Zone zone)
        {
            if (zone.keepInList.Contains(player.userID) || zone.whitelist.Contains(player.userID))
                return;

            if (!string.IsNullOrEmpty(zone.definition.Permission))
            {
                if (HasPermission(player, zone.definition.Permission))
                    return;
            }

            if (player.isMounted && ReverseVelocity(player))
            {
                SendMessage(player, Message("eject", player.UserIDString));
                return;
            }

            Vector3 position = Vector3.zero;
            if (Spawns && !string.IsNullOrEmpty(zone.definition.EjectSpawns))
            {
                object success = Spawns.Call("GetRandomSpawn", zone.definition.EjectSpawns);
                if (success is Vector3)
                    position = (Vector3)success;
            }

            if (position == Vector3.zero)
            {
                float distance;
                if (zone.definition.Size != Vector3.zero)
                    distance = Mathf.Max(zone.definition.Size.x, zone.definition.Size.z);
                else distance = zone.definition.Radius;

                position = zone.transform.position + (((player.transform.position.XZ3D() - zone.transform.position.XZ3D()).normalized) * (distance + 10f));

                RaycastHit rayHit;
                if (Physics.Raycast(new Ray(new Vector3(position.x, position.y + 300, position.z), Vector3.down), out rayHit, 500, TARGET_LAYERS, QueryTriggerInteraction.Ignore))
                    position.y = rayHit.point.y;
                else position.y = TerrainMeta.HeightMap.GetHeight(position);
            }

            player.MovePosition(position);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
            player.SendNetworkUpdateImmediate();

            SendMessage(player, Message("eject", player.UserIDString));
        }

        private void AttractPlayer(BasePlayer player, Zone zone)
        {
            if (player.isMounted && ReverseVelocity(player))
            {
                SendMessage(player, Message("attract", player.UserIDString));
                return;
            }

            float distance;
            if (zone.definition.Size != Vector3.zero)
                distance = Mathf.Max(zone.definition.Size.x, zone.definition.Size.z);
            else distance = zone.definition.Radius;

            Vector3 position = zone.transform.position + (player.transform.position - zone.transform.position).normalized * (distance - 5f);
            position.y = TerrainMeta.HeightMap.GetHeight(position);

            player.MovePosition(position);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
            player.SendNetworkUpdateImmediate();

            SendMessage(player, Message("attract", player.UserIDString));
        }

        private void ShowZone(BasePlayer player, string zoneId, float time = 30)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return;

            if (zone.definition.Size != Vector3.zero)
            {
                Vector3 center = zone.definition.Location;
                Quaternion rotation = Quaternion.Euler(zone.definition.Rotation);
                Vector3 size = zone.definition.Size / 2;
                Vector3 point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
                Vector3 point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
                Vector3 point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
                Vector3 point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
                Vector3 point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
                Vector3 point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
                Vector3 point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
                Vector3 point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

                player.SendConsoleCommand("ddraw.line", time, Color.blue, point1, point2);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point1, point3);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point1, point5);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point4, point2);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point4, point3);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point4, point8);

                player.SendConsoleCommand("ddraw.line", time, Color.blue, point5, point6);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point5, point7);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point6, point2);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point8, point6);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point8, point7);
                player.SendConsoleCommand("ddraw.line", time, Color.blue, point7, point3);
            }
            else player.SendConsoleCommand("ddraw.sphere", time, Color.blue, zone.definition.Location, zone.definition.Radius);
        }

        private Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation) => rotation * (point - pivot) + pivot;

        #endregion

        #region Component
        public class Zone : MonoBehaviour
        {
            internal Definition definition;

            internal ZoneFlags disabledFlags = ZoneFlags.None;

            internal Zone parent;

            internal List<BasePlayer> players = Pool.GetList<BasePlayer>();

            internal List<BaseEntity> entities = Pool.GetList<BaseEntity>();

            internal List<ulong> keepInList = Pool.GetList<ulong>();

            internal List<ulong> whitelist = Pool.GetList<ulong>();

            private Rigidbody rigidbody;

            internal Collider collider;

            internal Bounds colliderBounds;

            private ChildSphereTrigger<TriggerRadiation> radiation;

            private ChildSphereTrigger<TriggerComfort> comfort;

            private ChildSphereTrigger<TriggerTemperature> temperature;

            private TriggerSafeZone safeZone;

            private bool isTogglingLights = false;

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "ZoneManager";
                enabled = false;
            }

            private void OnDestroy()
            {
                EmptyZone();

                Pool.FreeList(ref players);
                Pool.FreeList(ref entities);
                Pool.FreeList(ref keepInList);
                Pool.FreeList(ref whitelist);
            }

            private void EmptyZone()
            {
                RemoveAllPlayers();

                keepInList.Clear();

                for (int i = players.Count - 1; i >= 0; i--)
                    Instance?.OnPlayerExitZone(players[i], this);

                for (int i = entities.Count - 1; i >= 0; i--)
                    Instance?.OnEntityExitZone(entities[i], this);
            }

            #region Zone Initialization
            public void InitializeZone(Definition definition)
            {
                this.definition = definition;

                transform.position = definition.Location;

                transform.rotation = Quaternion.Euler(definition.Rotation);

                if (definition.Enabled)
                {
                    RegisterPermission();

                    InitializeCollider();

                    InitializeAutoLights();

                    InitializeRadiation();

                    InitializeSafeZone();

                    InitializeComfort();

                    InitializeTemperature();

                    RemoveAllPlayers();
                    AddAllPlayers();
                }
                else
                {
                    InvokeHandler.CancelInvoke(this, CheckAlwaysLights);
                    InvokeHandler.CancelInvoke(this, CheckLights);

                    if (isLightsOn)
                        ServerMgr.Instance.StartCoroutine(ToggleLights(false));

                    EmptyZone();

                    if (collider != null)
                        DestroyImmediate(collider);

                    if (rigidbody != null)
                        DestroyImmediate(rigidbody);
                }

                enabled = definition.Enabled;
            }

            public void FindZoneParent()
            {
                if (string.IsNullOrEmpty(definition.ParentID))
                    return;

                Instance.zones.TryGetValue(definition.ParentID, out parent);
            }

            public void Reset()
            {
                InvokeHandler.CancelInvoke(this, CheckAlwaysLights);
                InvokeHandler.CancelInvoke(this, CheckLights);

                if (isLightsOn)
                    ServerMgr.Instance.StartCoroutine(ToggleLights(false));

                EmptyZone();

                InitializeZone(definition);
            }

            private void RegisterPermission()
            {
                if (!string.IsNullOrEmpty(definition.Permission) && !Instance.permission.PermissionExists(definition.Permission))
                    Instance.permission.RegisterPermission(definition.Permission, Instance);
            }

            private void InitializeCollider()
            {
                if (collider != null)
                    DestroyImmediate(collider);

                if (rigidbody != null)
                    DestroyImmediate(rigidbody);

                rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
                rigidbody.detectCollisions = true;
                rigidbody.collisionDetectionMode = CollisionDetectionMode.Discrete;

                SphereCollider sphereCollider = gameObject.GetComponent<SphereCollider>();
                BoxCollider boxCollider = gameObject.GetComponent<BoxCollider>();

                if (definition.Size != Vector3.zero)
                {
                    if (sphereCollider != null)
                        Destroy(sphereCollider);

                    if (!boxCollider)
                    {
                        boxCollider = gameObject.AddComponent<BoxCollider>();
                        boxCollider.isTrigger = true;
                    }
                    boxCollider.size = definition.Size;
                    colliderBounds = boxCollider.bounds;
                    collider = boxCollider;
                }
                else
                {
                    if (boxCollider != null)
                        Destroy(boxCollider);

                    if (!sphereCollider)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                    }
                    sphereCollider.radius = definition.Radius;
                    colliderBounds = sphereCollider.bounds;
                    collider = sphereCollider;
                }
            }
            #endregion

            #region Triggers
            private void InitializeRadiation()
            {                
                if (definition.Radiation > 0)
                {
                    if (radiation == null)
                        radiation = new ChildSphereTrigger<TriggerRadiation>(gameObject, "Radiation");

                    radiation.Trigger.RadiationAmountOverride = definition.Radiation;
                    radiation.Collider.radius = collider is SphereCollider ? definition.Radius : Mathf.Min(definition.Size.x, definition.Size.y, definition.Size.z) * 0.5f;
                    radiation.Trigger.enabled = this.enabled;
                }
                else radiation?.Destroy();
            }

            private void InitializeComfort()
            {
                if (definition.Comfort > 0)
                {
                    if (comfort == null)
                        comfort = new ChildSphereTrigger<TriggerComfort>(gameObject, "Comfort");

                    comfort.Trigger.baseComfort = definition.Comfort;
                    comfort.Trigger.triggerSize = comfort.Collider.radius = collider is SphereCollider ? definition.Radius : Mathf.Min(definition.Size.x, definition.Size.y, definition.Size.z) * 0.5f;
                    comfort.Trigger.enabled = this.enabled;
                }
                else comfort?.Destroy();
            }

            private void InitializeTemperature()
            {
                if (definition.Temperature != 0)
                {
                    if (temperature == null)
                        temperature = new ChildSphereTrigger<TriggerTemperature>(gameObject, "Temperature");

                    temperature.Trigger.Temperature = definition.Temperature;
                    temperature.Trigger.triggerSize = temperature.Collider.radius = collider is SphereCollider ? definition.Radius : Mathf.Min(definition.Size.x, definition.Size.y, definition.Size.z) * 0.5f;
                    temperature.Trigger.enabled = this.enabled;
                }
                else temperature?.Destroy();
            }

            private void InitializeSafeZone()
            {
                if (definition.SafeZone)
                {
                    if (safeZone == null)
                        safeZone = gameObject.AddComponent<TriggerSafeZone>();

                    safeZone.interestLayers = PLAYER_MASK;
                    safeZone.enabled = this.enabled;
                }
                else
                {
                    if (safeZone != null)
                        Destroy(safeZone);
                }
            }
                        
            private void AddToTrigger(TriggerBase triggerBase, BasePlayer player)
            {
                if (!triggerBase || !player)
                    return;

                if (triggerBase.entityContents == null)
                    triggerBase.entityContents = new HashSet<BaseEntity>();

                if (!triggerBase.entityContents.Contains(player))
                {
                    triggerBase.entityContents.Add(player);
                    player.EnterTrigger(triggerBase);

                    if (triggerBase is TriggerSafeZone)
                    {
                        if (player.IsItemHoldRestricted(player.inventory.containerBelt.FindItemByUID(player.svActiveItemID)))
                            player.UpdateActiveItem(0);

                        player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, true);
                    }
                }
            }

            private void RemoveFromTrigger(TriggerBase triggerBase, BasePlayer player)
            {
                if (!triggerBase || !player)
                    return;

                if (triggerBase.entityContents != null && triggerBase.entityContents.Contains(player))
                {
                    triggerBase.entityContents.Remove(player);
                    player.LeaveTrigger(triggerBase);

                    if (triggerBase is TriggerSafeZone)
                    {
                        if (!player.InSafeZone())
                            player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, false);
                    }
                }
            }

            private void AddAllPlayers()
            {
                for (int i = 0; i < players.Count; i++)
                {
                    BasePlayer player = players[i];

                    AddToTrigger(safeZone, player);

                    if (radiation != null)
                        AddToTrigger(radiation.Trigger, player);

                    if (comfort != null)
                        AddToTrigger(comfort.Trigger, player);

                    if (temperature != null)
                        AddToTrigger(temperature.Trigger, player);
                }
            }

            private void RemoveAllPlayers()
            {
                for (int i = 0; i < players.Count; i++)                    
                {
                    BasePlayer player = players[i];

                    RemoveFromTrigger(safeZone, player);

                    if (radiation != null)
                        RemoveFromTrigger(radiation.Trigger, player);

                    if (comfort != null)
                        RemoveFromTrigger(comfort.Trigger, player);

                    if (temperature != null)
                        RemoveFromTrigger(temperature.Trigger, player);
                }
            }

            private class ChildSphereTrigger<T> where T : TriggerBase
            {
                public GameObject Object { get; private set; }

                public SphereCollider Collider { get; private set; }

                public T Trigger { get; private set; }

                public ChildSphereTrigger(GameObject parent, string name)
                {
                    Object = parent.CreateChild();
                    Object.name = name;
                    Object.layer = (int)Layer.TransparentFX;

                    Collider = Object.AddComponent<SphereCollider>();
                    Collider.isTrigger = true;

                    Trigger = Object.AddComponent<T>();
                    Trigger.interestLayers = 0;
                }

                public void Destroy() => UnityEngine.Object.Destroy(Object);
            }
            #endregion

            #region Autolights
            private bool isLightsOn = false;

            private void InitializeAutoLights()
            {
                if (HasFlag(ZoneFlags.AlwaysLights))
                {
                    isLightsOn = true;

                    InvokeHandler.CancelInvoke(this, CheckAlwaysLights);
                    InvokeHandler.InvokeRandomized(this, CheckAlwaysLights, 5f, 60f, 10f);
                }
                else if (HasFlag(ZoneFlags.AutoLights))
                {
                    InvokeHandler.CancelInvoke(this, CheckLights);
                    InvokeHandler.InvokeRandomized(this, CheckLights, 5f, 20f, 10f);
                }
            }

            private void CheckAlwaysLights()
            {
                ServerMgr.Instance.StartCoroutine(ToggleLights(true));
            }

            private void CheckLights()
            {
                float currentTime = TOD_Sky.Instance.Cycle.Hour;

                bool shouldBeActive = currentTime > Instance.configData.AutoLights.OnTime || currentTime < Instance.configData.AutoLights.OffTime;

                if (shouldBeActive != isLightsOn)
                {
                    isLightsOn = shouldBeActive;
                    ServerMgr.Instance.StartCoroutine(ToggleLights(isLightsOn));
                }
            }

            private IEnumerator ToggleLights(bool active)
            {
                while (isTogglingLights)
                    yield return null;

                isTogglingLights = true;

                bool requiresFuel = Instance.configData.AutoLights.RequiresFuel;

                for (int i = 0; i < entities.Count; i++)
                {
                    if (ToggleLight(entities[i], active, requiresFuel))
                        yield return CoroutineEx.waitForEndOfFrame;
                }

                isTogglingLights = false;
            }

            private bool ToggleLight(BaseEntity baseEntity, bool active, bool requiresFuel)
            {
                BaseOven baseOven = baseEntity as BaseOven;
                if (baseOven != null)
                {
                    if (active)
                    {
                        if (!baseOven.IsOn())
                        {
                            if ((requiresFuel && baseOven.FindBurnable() != null) || !requiresFuel)
                                baseOven.SetFlag(BaseEntity.Flags.On, true);
                        }
                    }
                    else
                    {
                        if (baseOven.IsOn())
                            baseOven.StopCooking();
                    }

                    return true;
                }

                SearchLight searchLight = baseEntity as SearchLight;
                if (searchLight != null)
                {
                    if (active)
                    {
                        if (!searchLight.IsOn())
                            searchLight.SetFlag(BaseEntity.Flags.On, true);
                    }
                    else
                    {
                        if (searchLight.IsOn())
                            searchLight.SetFlag(BaseEntity.Flags.On, false);
                    }

                    return true;
                }

                return false;
            }
            #endregion

            #region Entity Detection            
            private void OnTriggerEnter(Collider col)
            {
                if (!definition.Enabled || !col || !col.gameObject)
                    return;

                BaseEntity baseEntity = col.gameObject.ToBaseEntity();
                if (!baseEntity || !baseEntity.IsValid())
                    return;

                if (baseEntity is BasePlayer)
                {
                    Instance.OnPlayerEnterZone(baseEntity as BasePlayer, this);

                    if (parent != null)
                        Instance.UpdateZoneFlags(this);

                    return;
                }

                Instance.OnEntityEnterZone(baseEntity, this);
            }

            private void OnTriggerExit(Collider col)
            {
                if (!definition.Enabled || !col || !col.gameObject)
                    return;

                BaseEntity baseEntity = col.gameObject.ToBaseEntity();
                if (!baseEntity || !baseEntity.IsValid())
                    return;

                if (baseEntity is BasePlayer)
                {
                    Instance.OnPlayerExitZone(baseEntity as BasePlayer, this);

                    return;
                }

                Instance.OnEntityExitZone(baseEntity, this);
            }

            public void OnPlayerEnterZone(BasePlayer player)
            {
                if (!players.Contains(player))
                    players.Add(player);

                AddToTrigger(safeZone, player);

                if (radiation != null)
                    AddToTrigger(radiation.Trigger, player);

                if (comfort != null)
                    AddToTrigger(comfort.Trigger, player);

                if (temperature != null)
                    AddToTrigger(temperature.Trigger, player);
            }

            public void OnPlayerExitZone(BasePlayer player)
            {
                players.Remove(player);

                RemoveFromTrigger(safeZone, player);

                if (radiation != null)
                    RemoveFromTrigger(radiation.Trigger, player);

                if (comfort != null)
                    RemoveFromTrigger(comfort.Trigger, player);

                if (temperature != null)
                    RemoveFromTrigger(temperature.Trigger, player);
            }

            public void OnEntityEnterZone(BaseEntity baseEntity)
            {
                entities.Add(baseEntity);

                if (HasFlag(ZoneFlags.NoDecay))
                {
                    DecayEntity decayEntity = baseEntity.GetComponentInParent<DecayEntity>();
                    if (decayEntity != null)
                    {
                        decayEntity.decay = null;
                    }
                }

                if (HasFlag(ZoneFlags.NoStability))
                {
                    if (baseEntity is StabilityEntity)
                    {
                        (baseEntity as StabilityEntity).grounded = true;
                    }
                }

                if (HasFlag(ZoneFlags.NpcFreeze))
                {
                    if (baseEntity is BaseNpc)
                    {
                        baseEntity.CancelInvoke((baseEntity as BaseNpc).TickAi);
                    }
                }

                if (HasFlag(ZoneFlags.AlwaysLights) || (HasFlag(ZoneFlags.AutoLights) && isLightsOn))
                {
                    if (baseEntity is BaseOven || baseEntity is SearchLight)
                    {
                        ToggleLight(baseEntity, true, Instance.configData.AutoLights.RequiresFuel);
                    }
                }
            }

            public void OnEntityExitZone(BaseEntity baseEntity, bool resetDecay, bool isDead = false)
            {
                entities.Remove(baseEntity);

                if (isDead)
                    return;

                if (resetDecay)
                {
                    if (HasFlag(ZoneFlags.NoDecay))
                    {
                        DecayEntity decayEntity = baseEntity.GetComponentInParent<DecayEntity>();
                        if (decayEntity != null)
                        {
                            decayEntity.decay = PrefabAttribute.server.Find<Decay>(decayEntity.prefabID);
                        }
                    }
                }

                if (HasFlag(ZoneFlags.NpcFreeze))
                {
                    if (baseEntity is BaseNpc)
                    {
                        baseEntity.InvokeRandomized((baseEntity as BaseNpc).TickAi, 0.1f, 0.1f, 0.00500000035f);
                    }
                }

                if (HasFlag(ZoneFlags.AlwaysLights) || (HasFlag(ZoneFlags.AutoLights) && isLightsOn))
                {
                    if (baseEntity is BaseOven || baseEntity is SearchLight)
                    {
                        ToggleLight(baseEntity, false, false);
                    }
                }
            }
            #endregion

            #region Helpers
            public bool HasPermission(BasePlayer player) => string.IsNullOrEmpty(definition.Permission) ? true : Instance.permission.UserHasPermission(player.UserIDString, definition.Permission);

            public bool CanLeaveZone(BasePlayer player) => !keepInList.Contains(player.userID);

            public bool CanEnterZone(BasePlayer player) => HasPermission(player) || !CanLeaveZone(player) || whitelist.Contains(player.userID);

            private bool HasFlag(ZoneFlags flags) => (definition.Flags & ~disabledFlags & flags) == flags;
            #endregion

            #region Zone Definition
            public class Definition
            {
                public string Name { get; set; }
                public float Radius { get; set; }
                public float Radiation { get; set; }
                public float Comfort { get; set; }
                public float Temperature { get; set; }
                public bool SafeZone { get; set; }
                public Vector3 Location { get; set; }
                public Vector3 Size { get; set; }
                public Vector3 Rotation { get; set; }
                public string Id { get; set; }
                public string ParentID { get; set; }
                public string EnterMessage { get; set; }
                public string LeaveMessage { get; set; }
                public string Permission { get; set; }
                public string EjectSpawns { get; set; }
                public bool Enabled { get; set; } = true;
                public ZoneFlags Flags { get; set; }

                public Definition() { }

                public Definition(Vector3 position)
                {
                    Radius = 20f;
                    Location = position;
                }
            }
            #endregion
        }
        #endregion

        #region Entity Management
        private void OnPlayerEnterZone(BasePlayer player, Zone zone)
        {
            if (!player || IsNpc(player))
                return;

            if (!zone.CanEnterZone(player))
            {
                EjectPlayer(player, zone);
                return;
            }

            if (HasFlag(zone, ZoneFlags.Eject))
            {
                if (!CanBypass(player, ZoneFlags.Eject) && !IsAdmin(player))
                {
                    EjectPlayer(player, zone);
                    return;
                }
            }

            if (HasFlag(zone, ZoneFlags.KeepVehiclesOut) && player.isMounted)
            {
                if (ReverseVelocity(player))
                {
                    SendMessage(player, Message("novehiclesenter", player.UserIDString));
                    return;
                }
            }

            if (player.IsSleeping() && !player.IsConnected)
            {
                if (HasFlag(zone, ZoneFlags.KillSleepers))
                {
                    if (!CanBypass(player, ZoneFlags.KillSleepers) && !IsAdmin(player))
                    {
                        player.Die();
                        return;
                    }
                }

                if (HasFlag(zone, ZoneFlags.EjectSleepers))
                {
                    if (!CanBypass(player, ZoneFlags.EjectSleepers) && !IsAdmin(player))
                    {
                        EjectPlayer(player, zone);
                        return;
                    }
                }
            }

            if (HasFlag(zone, ZoneFlags.Kill))
            {
                if (!CanBypass(player, ZoneFlags.Kill) && !IsAdmin(player))
                {
                    player.Die();
                    return;
                }
            }

            EntityZones entityZones;
            if (!zonedPlayers.TryGetValue(player.userID, out entityZones))
                zonedPlayers[player.userID] = entityZones = new EntityZones();

            if (!entityZones.EnterZone(zone))
                return;

            if (zone.parent != null)
                entityZones.UpdateFlags();
            else entityZones.AddFlags(zone.definition.Flags);

            zone.OnPlayerEnterZone(player);

            if (!string.IsNullOrEmpty(zone.definition.EnterMessage))
            {
                if (PopupNotifications != null && configData.Notifications.Popups)
                    PopupNotifications.Call("CreatePopupNotification", string.Format(zone.definition.EnterMessage, player.displayName), player);
                else SendMessage(player, zone.definition.EnterMessage, player.displayName);
            }

            Interface.CallHook("OnEnterZone", zone.definition.Id, player);
        }

        private void OnPlayerExitZone(BasePlayer player, Zone zone)
        {
            if (!player || IsNpc(player))
                return;

            if (HasFlag(zone, ZoneFlags.KeepVehiclesIn) && player.isMounted)
            {
                if (ReverseVelocity(player))
                {
                    SendMessage(player, Message("novehiclesleave", player.UserIDString));
                    return;
                }
            }

            if (!zone.CanLeaveZone(player))
            {
                AttractPlayer(player, zone);
                return;
            }

            EntityZones entityZones;
            if (!zonedPlayers.TryGetValue(player.userID, out entityZones))
                return;

            entityZones.LeaveZone(zone);

            if (entityZones.ShouldRemove())
                zonedPlayers.Remove(player.userID);
            else entityZones.UpdateFlags();

            zone.OnPlayerExitZone(player);

            if (!string.IsNullOrEmpty(zone.definition.LeaveMessage))
            {
                if (PopupNotifications != null && configData.Notifications.Popups)
                    PopupNotifications.Call("CreatePopupNotification", string.Format(zone.definition.LeaveMessage, player.displayName), player);
                else SendMessage(player, zone.definition.LeaveMessage, player.displayName);
            }

            Interface.CallHook("OnExitZone", zone.definition.Id, player);
        }

        private void OnEntityEnterZone(BaseEntity baseEntity, Zone zone)
        {
            if (!baseEntity.IsValid())
                return;

            EntityZones entityZones;
            if (!zonedEntities.TryGetValue(baseEntity.net.ID, out entityZones))
                zonedEntities[baseEntity.net.ID] = entityZones = new EntityZones();

            if (!entityZones.EnterZone(zone))
                return;

            if (zone.parent != null)
                entityZones.UpdateFlags();
            else entityZones.AddFlags(zone.definition.Flags);

            zone.OnEntityEnterZone(baseEntity);

            Interface.CallHook("OnEntityEnterZone", zone.definition.Id, baseEntity);
        }

        private void OnEntityExitZone(BaseEntity baseEntity, Zone zone)
        {
            if (!baseEntity.IsValid())
                return;

            EntityZones entityZones;
            if (!zonedEntities.TryGetValue(baseEntity.net.ID, out entityZones))
                return;

            entityZones.LeaveZone(zone);

            if (entityZones.ShouldRemove())
                zonedEntities.Remove(baseEntity.net.ID);
            else entityZones.UpdateFlags();

            zone.OnEntityExitZone(baseEntity, !entityZones.HasFlag(ZoneFlags.NoDecay));

            Interface.CallHook("OnEntityExitZone", zone.definition.Id, baseEntity);
        }
        #endregion

        #region Helpers
        private bool IsAdmin(BasePlayer player) => player?.net?.connection?.authLevel > 0;

        private bool IsNpc(BasePlayer player) => player.IsNpc || player is NPCPlayer;

        private bool HasPermission(BasePlayer player, string permname) => IsAdmin(player) || permission.UserHasPermission(player.UserIDString, permname);

        private bool HasPermission(ConsoleSystem.Arg arg, string permname) => (arg.Connection.player as BasePlayer) == null ? true : permission.UserHasPermission((arg.Connection.player as BasePlayer).UserIDString, permname);

        private bool CanBypass(object player, ZoneFlags flag) => permission.UserHasPermission(player is BasePlayer ? (player as BasePlayer).UserIDString : player.ToString(), PERMISSION_IGNORE_FLAG + flag);

        private void SendMessage(BasePlayer player, string message, params object[] args)
        {
            if (player != null)
            {
                if (args.Length > 0)
                    message = string.Format(message, args);
                SendReply(player, $"<color={configData.Notifications.Color}>{configData.Notifications.Prefix}</color> {message}");
            }
            else Puts(message);
        }

        private Zone GetZoneByID(string zoneId) => zones.ContainsKey(zoneId) ? zones[zoneId] : null;

        private void AddToKeepinlist(Zone zone, BasePlayer player)
        {
            zone.keepInList.Add(player.userID);

            EntityZones entityZones;
            if (!zonedPlayers.TryGetValue(player.userID, out entityZones) || !entityZones.Zones.Contains(zone))
                AttractPlayer(player, zone);
        }

        private void RemoveFromKeepinlist(Zone zone, BasePlayer player) => zone.keepInList.Remove(player.userID);

        private void AddToWhitelist(Zone zone, BasePlayer player)
        {
            if (!zone.whitelist.Contains(player.userID))
                zone.whitelist.Add(player.userID);
        }

        private void RemoveFromWhitelist(Zone zone, BasePlayer player) => zone.whitelist.Remove(player.userID);

        private bool HasPlayerFlag(BasePlayer player, ZoneFlags flag, bool canBypass)
        {
            if (!player)
                return false;

            if (canBypass && IsAdmin(player))
                return false;

            if (CanBypass(player.userID, flag))
                return false;

            EntityZones entityZones;
            if (!zonedPlayers.TryGetValue(player.userID, out entityZones))
                return false;

            return entityZones.HasFlag(flag);
        }

        private bool HasEntityFlag(BaseEntity baseEntity, ZoneFlags flag)
        {
            if (!baseEntity.IsValid())
                return false;

            EntityZones entityZones;
            if (!zonedEntities.TryGetValue(baseEntity.net.ID, out entityZones))
                return false;

            return entityZones.HasFlag(flag);
        }
        #endregion

        #region API 

        #region Zone Management       

        private void SetZoneStatus(string zoneId, bool active)
        {
            Zone zone = GetZoneByID(zoneId);
            if (zone != null)
            {
                zone.definition.Enabled = active;
                zone.InitializeZone(zone.definition);
            }
        }

        private Vector3 GetZoneLocation(string zoneId) => GetZoneByID(zoneId)?.definition.Location ?? Vector3.zero;

        private object GetZoneRadius(string zoneID) => GetZoneByID(zoneID)?.definition.Radius;

        private object GetZoneSize(string zoneID) => GetZoneByID(zoneID)?.definition.Size;

        private object GetZoneName(string zoneID) => GetZoneByID(zoneID)?.definition.Name;

        private object CheckZoneID(string zoneID) => GetZoneByID(zoneID)?.definition.Id;

        private object GetZoneIDs() => zones.Keys.ToArray();

        private bool IsPositionInZone(string zoneID, Vector3 position)
        {
            Zone zone = GetZoneByID(zoneID);
            if (!zone)
                return false;

            if (zone.definition.Size != Vector3.zero)
                return IsInsideBounds(zone, position); 
            else return Vector3.Distance(position, zone.transform.position) <= zone.definition.Radius;            
        }

        private List<BasePlayer> GetPlayersInZone(string zoneID)
        {
            Zone zone = GetZoneByID(zoneID);
            if (!zone)
                return new List<BasePlayer>();

            return new List<BasePlayer>(zone.players);
        }

        private List<BaseEntity> GetEntitiesInZone(string zoneId)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return new List<BaseEntity>();

            return new List<BaseEntity>(zone.entities);
        }

        private bool isPlayerInZone(string zoneID, BasePlayer player) => IsPlayerInZone(zoneID, player);

        private bool IsPlayerInZone(string zoneID, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneID);
            if (!zone)
                return false;

            return zone.players.Contains(player);
        }

        private bool IsEntityInZone(string zoneID, BaseEntity entity)
        {
            Zone zone = GetZoneByID(zoneID);
            if (!zone)
                return false;

            return zone.entities.Contains(entity);
        }

        private string[] GetPlayerZoneIDs(BasePlayer player)
        {
            EntityZones entityZones;
            if (!zonedPlayers.TryGetValue(player.userID, out entityZones))
                return new string[0];

            return entityZones.Zones.Select(x => x.definition.Id).ToArray();
        }

        private string[] GetEntityZoneIDs(BaseEntity entity)
        {
            EntityZones entityZones;
            if (!zonedEntities.TryGetValue(entity.net.ID, out entityZones))
                return new string[0];

            return entityZones.Zones.Select(x => x.definition.Id).ToArray();
        }

        private bool HasFlag(string zoneId, string flagStr)
        {
            try
            {
                ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), flagStr, true);

                Zone zone = GetZoneByID(zoneId);

                return zone != null ? HasFlag(zone, flag) : false;
            }
            catch
            {
                PrintError(string.Format("A plugin called HasFlag with an invalid flag {0}", flagStr));
                return false;
            }
        }

        private void AddFlag(string zoneId, string flagStr)
        {
            try
            {
                ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), flagStr, true);

                Zone zone = GetZoneByID(zoneId);
                if (zone != null)
                    AddFlag(zone, flag);
            }
            catch
            {
                PrintError(string.Format("A plugin called AddFlag with an invalid flag {0}", flagStr));
            }
        }

        private void RemoveFlag(string zoneId, string flagStr)
        {
            try
            {
                ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), flagStr, true);

                Zone zone = GetZoneByID(zoneId);
                if (zone != null)
                    RemoveFlag(zone, flag);
            }
            catch
            {
                PrintError(string.Format("A plugin called RemoveFlag with an invalid flag {0}", flagStr));
            }
        }

        private bool HasDisabledFlag(string zoneId, string flagStr)
        {
            try
            {
                ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), flagStr, true);

                Zone zone = GetZoneByID(zoneId);

                return zone != null ? HasDisabledFlag(zone, flag) : false;
            }
            catch
            {
                PrintError(string.Format("A plugin called HasDisabledFlag with an invalid flag {0}", flagStr));
                return false;
            }
        }

        private void AddDisabledFlag(string zoneId, string flagStr)
        {
            try
            {
                ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), flagStr, true);

                Zone zone = GetZoneByID(zoneId);
                if (zone != null)
                    AddDisabledFlag(zone, flag);
            }
            catch
            {
                PrintError(string.Format("A plugin called AddDisabledFlag with an invalid flag {0}", flagStr));
            }
        }

        private void RemoveDisabledFlag(string zoneId, string flagStr)
        {
            try
            {
                ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), flagStr, true);

                Zone zone = GetZoneByID(zoneId);
                if (zone != null)
                    RemoveDisabledFlag(zone, flag);
            }
            catch
            {
                PrintError(string.Format("A plugin called RemoveDisabledFlag with an invalid flag {0}", flagStr));
            }
        }

        private bool CreateOrUpdateZone(string zoneId, string[] args, Vector3 position = default(Vector3))
        {
            Zone.Definition definition;

            Zone zone;
            if (!zones.TryGetValue(zoneId, out zone))
            {
                zone = new GameObject().AddComponent<Zone>();
                definition = new Zone.Definition { Id = zoneId, Radius = 20 };

                zones[zoneId] = zone;
                zone.InitializeZone(definition);
            }
            else definition = zone.definition;

            UpdateZoneDefinition(zone, args);

            if (position != default(Vector3))
                definition.Location = position;

            zone.definition = definition;
            zone.Reset();
            zone.FindZoneParent();
            SaveData();
            return true;
        }

        private bool EraseZone(string zoneId)
        {
            Zone zone;
            if (!zones.TryGetValue(zoneId, out zone))
                return false;

            zones.Remove(zoneId);

            UnityEngine.Object.Destroy(zone.gameObject);

            SaveData();
            return true;
        }


        private List<string> ZoneFieldListRaw()
        {
            List<string> list = new List<string> { "name", "ID", "radius", "rotation", "size", "Location", "enter_message", "leave_message", "radiation", "comfort", "temperature" };
            list.AddRange(Enum.GetNames(typeof(ZoneFlags)));
            return list;
        }

        private Dictionary<string, string> ZoneFieldList(string zoneId)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return null;

            Dictionary<string, string> fields = new Dictionary<string, string>
            {
                { "name", zone.definition.Name },
                { "ID", zone.definition.Id },
                { "comfort", zone.definition.Comfort.ToString() },
                { "temperature", zone.definition.Temperature.ToString() },
                { "radiation", zone.definition.Radiation.ToString() },
                { "safezone", zone.definition.SafeZone.ToString() },
                { "radius", zone.definition.Radius.ToString() },
                { "rotation", zone.definition.Rotation.ToString() },
                { "size", zone.definition.Size.ToString() },
                { "Location", zone.definition.Location.ToString() },
                { "enter_message", zone.definition.EnterMessage },
                { "leave_message", zone.definition.LeaveMessage },
                { "permission", zone.definition.Permission },
                { "ejectspawns", zone.definition.EjectSpawns }
            };

            foreach (object value in Enum.GetValues(typeof(ZoneFlags)))
                fields[value.ToString()] = HasFlag(zone, (ZoneFlags)value).ToString();

            return fields;
        }
        #endregion

        #region Entity Management        
        private bool AddPlayerToZoneKeepinlist(string zoneId, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            AddToKeepinlist(zone, player);
            return true;
        }

        private bool RemovePlayerFromZoneKeepinlist(string zoneId, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            RemoveFromKeepinlist(zone, player);
            return true;
        }

        private bool AddPlayerToZoneWhitelist(string zoneId, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            AddToWhitelist(zone, player);
            return true;
        }

        private bool RemovePlayerFromZoneWhitelist(string zoneId, BasePlayer player)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
                return false;

            RemoveFromWhitelist(zone, player);
            return true;
        }

        private bool EntityHasFlag(BaseEntity baseEntity, string flagStr)
        {
            if (!baseEntity.IsValid())
                return false;

            try
            {
                ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), flagStr, true);
                return HasEntityFlag(baseEntity, flag);
            }
            catch
            {
                PrintError(string.Format("A plugin called EntityHasFlag with an invalid flag {0}", flagStr));
                return false;
            }
        }

        private bool PlayerHasFlag(BasePlayer player, string flagStr)
        {
            if (!player)
                return false;

            try
            {
                ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), flagStr, true);
                return HasPlayerFlag(player, flag, false);
            }
            catch
            {
                PrintError(string.Format("A plugin called HasPlayerFlag with an invalid flag {0}", flagStr));
                return false;
            }
        }
        #endregion

        #region Plugin Integration
        private object CanRedeemKit(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoKits, false) ? "You may not redeem a kit inside this area" : null;

        private object CanTeleport(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoTp, false) ? "You may not teleport in this area" : null;

        private object canRemove(BasePlayer player) => CanRemove(player);

        private object CanRemove(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoRemove, false) ? "You may not use the remover tool in this area" : null;

        private bool CanChat(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoChat, false) ? false : true;

        private object CanTrade(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoTrade, false) ? "You may not trade in this area" : null;

        private object canShop(BasePlayer player) => CanShop(player);

        private object CanShop(BasePlayer player) => HasPlayerFlag(player, ZoneFlags.NoShop, false) ? "You may not use the store in this area" : null;
        #endregion

        #endregion

        #region Flags
        [Flags]
        public enum ZoneFlags : ulong
        {
            None = 0UL,
            AutoLights = 1UL,
            Eject = 1UL << 1,
            PvpGod = 1UL << 2,
            PveGod = 1UL << 3,
            SleepGod = 1UL << 4,
            UnDestr = 1UL << 5,
            NoBuild = 1UL << 6,
            NoTp = 1UL << 7,
            NoChat = 1UL << 8,
            NoGather = 1UL << 9,
            NoPve = 1UL << 10,
            NoWounded = 1UL << 11,
            NoDecay = 1UL << 12,
            NoDeploy = 1UL << 13,
            NoKits = 1UL << 14,
            NoBoxLoot = 1UL << 15,
            NoPlayerLoot = 1UL << 16,
            NoCorpse = 1UL << 17,
            NoSuicide = 1UL << 18,
            NoRemove = 1UL << 19,
            NoBleed = 1UL << 20,
            KillSleepers = 1UL << 21,
            NpcFreeze = 1UL << 22,
            NoDrown = 1UL << 23,
            NoStability = 1UL << 24,
            NoUpgrade = 1UL << 25,
            EjectSleepers = 1UL << 26,
            NoPickup = 1UL << 27,
            NoCollect = 1UL << 28,
            NoDrop = 1UL << 29,
            Kill = 1UL << 30,
            NoCup = 1UL << 31,
            AlwaysLights = 1UL << 32,
            NoTrade = 1UL << 33,
            NoShop = 1UL << 34,
            NoSignUpdates = 1UL << 35,
            NoOvenToggle = 1UL << 36,
            NoLootSpawns = 1UL << 37,
            NoNPCSpawns = 1UL << 38,
            NoVending = 1UL << 39,
            NoStash = 1UL << 40,
            NoCraft = 1UL << 41,
            NoHeliTargeting = 1UL << 42,
            NoTurretTargeting = 1UL << 43,
            NoAPCTargeting = 1UL << 44,
            NoNPCTargeting = 1UL << 45,
            NoEntityPickup = 1UL << 46,
            NoFallDamage = 1UL << 47,
            InfiniteTrapAmmo = 1UL << 48,
            LootSelf = 1UL << 49,
            NoDoorAccess = 1UL << 50,
            NoVoice = 1UL << 51,
            KeepVehiclesIn = 1UL << 52,
            KeepVehiclesOut = 1UL << 53,
            Custom1 = 1UL << 61,
            Custom2 = 1UL << 62,
            Custom3 = 1UL << 63,
        }

        private void AddFlag(Zone zone, ZoneFlags flag)
        {
            zone.definition.Flags |= flag;

            if (NeedsUpdateSubscriptions())
                UpdateHookSubscriptions();

            zone.Reset();
        }

        private void RemoveFlag(Zone zone, ZoneFlags flag)
        {
            zone.definition.Flags &= ~flag;

            if (NeedsUpdateSubscriptions())
            {
                UnsubscribeAll();
                UpdateHookSubscriptions();
            }

            zone.Reset();
        }

        private bool HasFlag(Zone zone, ZoneFlags flag) => (zone.definition.Flags & ~zone.disabledFlags & flag) == flag;

        private void AddDisabledFlag(Zone zone, ZoneFlags flag)
        {
            zone.disabledFlags |= flag;

            UpdateZoneFlags(zone);
        }

        private void RemoveDisabledFlag(Zone zone, ZoneFlags flag)
        {
            zone.disabledFlags &= ~flag;

            UpdateZoneFlags(zone);
        }

        private bool HasDisabledFlag(Zone zone, ZoneFlags flag) => (zone.disabledFlags & flag) == flag;

        private void UpdateZoneFlags(Zone zone)
        {
            for (int i = 0; i < zonedPlayers.Count; i++)
            {
                EntityZones entityZones = zonedPlayers.ElementAt(i).Value;

                if (entityZones.Zones.Contains(zone))
                {
                    entityZones.UpdateFlags();
                }
            }

            for (int i = 0; i < zonedEntities.Count; i++)
            {
                EntityZones entityZones = zonedEntities.ElementAt(i).Value;

                if (entityZones.Zones.Contains(zone))
                {
                    entityZones.UpdateFlags();
                }
            }
        }
        #endregion

        #region Hook Subscriptions
        private bool HasGlobalFlag(ZoneFlags flags) => (globalFlags & flags) != 0;

        private void UpdateGlobalFlags()
        {
            globalFlags = ZoneFlags.None;

            for (int i = 0; i < zones.Count; i++)
            {
                Zone zone = zones.ElementAt(i).Value;
                if (!zone)
                    continue;

                globalFlags |= zone.definition.Flags;
            }
        }

        private bool NeedsUpdateSubscriptions()
        {
            ZoneFlags tempFlags = ZoneFlags.None;

            for (int i = 0; i < zones.Count; i++)
            {
                Zone zone = zones.ElementAt(i).Value;
                if (!zone)
                    continue;

                tempFlags |= zone.definition.Flags;
            }

            return tempFlags != globalFlags;
        }

        private void UpdateHookSubscriptions()
        {
            UpdateGlobalFlags();

            if (HasGlobalFlag(ZoneFlags.NoBuild) || HasGlobalFlag(ZoneFlags.NoCup) || HasGlobalFlag(ZoneFlags.NoDeploy))
                Subscribe(nameof(OnEntityBuilt));

            if (HasGlobalFlag(ZoneFlags.NoUpgrade))
                Subscribe(nameof(OnStructureUpgrade));

            if (HasGlobalFlag(ZoneFlags.NoDeploy))
                Subscribe(nameof(OnItemDeployed));

            if (HasGlobalFlag(ZoneFlags.InfiniteTrapAmmo) || HasGlobalFlag(ZoneFlags.AlwaysLights) || HasGlobalFlag(ZoneFlags.AutoLights))
                Subscribe(nameof(OnItemUse));

            if (HasGlobalFlag(ZoneFlags.NoBleed) || HasGlobalFlag(ZoneFlags.NoDrown))
                Subscribe(nameof(OnRunPlayerMetabolism));

            if (HasGlobalFlag(ZoneFlags.NoChat))
                Subscribe(nameof(OnPlayerChat));

            if (HasGlobalFlag(ZoneFlags.NoSuicide))
                Subscribe(nameof(OnServerCommand));

            if (HasGlobalFlag(ZoneFlags.KillSleepers) || HasGlobalFlag(ZoneFlags.EjectSleepers))
                Subscribe(nameof(OnPlayerDisconnected));

            if (HasGlobalFlag(ZoneFlags.NoFallDamage) || HasGlobalFlag(ZoneFlags.SleepGod) || HasGlobalFlag(ZoneFlags.PvpGod) || HasGlobalFlag(ZoneFlags.PveGod) || HasGlobalFlag(ZoneFlags.NoPve) || HasGlobalFlag(ZoneFlags.UnDestr))
                Subscribe(nameof(OnEntityTakeDamage));

            if (HasGlobalFlag(ZoneFlags.NoWounded))
                Subscribe(nameof(CanBeWounded));

            if (HasGlobalFlag(ZoneFlags.NoSignUpdates))
                Subscribe(nameof(CanUpdateSign));

            if (HasGlobalFlag(ZoneFlags.NoOvenToggle))
                Subscribe(nameof(OnOvenToggle));

            if (HasGlobalFlag(ZoneFlags.NoVending))
                Subscribe(nameof(CanUseVending));

            if (HasGlobalFlag(ZoneFlags.NoStash))
                Subscribe(nameof(CanHideStash));

            if (HasGlobalFlag(ZoneFlags.NoCraft))
                Subscribe(nameof(CanCraft));

            if (HasGlobalFlag(ZoneFlags.NoDoorAccess))
                Subscribe(nameof(OnDoorOpened));

            if (HasGlobalFlag(ZoneFlags.NoVoice))
                Subscribe(nameof(OnPlayerVoice));

            if (HasGlobalFlag(ZoneFlags.NoPlayerLoot))
            {
                Subscribe(nameof(CanLootPlayer));
                Subscribe(nameof(OnLootPlayer));
            }

            if (HasGlobalFlag(ZoneFlags.LootSelf) || HasGlobalFlag(ZoneFlags.NoPlayerLoot))
                Subscribe(nameof(OnLootEntity));

            if (HasGlobalFlag(ZoneFlags.LootSelf) || HasGlobalFlag(ZoneFlags.NoPlayerLoot) || HasGlobalFlag(ZoneFlags.NoBoxLoot) || HasGlobalFlag(ZoneFlags.NoGather))
                Subscribe(nameof(CanLootEntity));

            if (HasGlobalFlag(ZoneFlags.NoEntityPickup))
            {
                Subscribe(nameof(CanPickupEntity));
                Subscribe(nameof(CanPickupLock));
                Subscribe(nameof(OnItemPickup));
            }

            if (HasGlobalFlag(ZoneFlags.NoGather))
            {
                Subscribe(nameof(OnCollectiblePickup));
                Subscribe(nameof(OnGrowableGather));
                Subscribe(nameof(OnDispenserGather));
            }

            if (HasGlobalFlag(ZoneFlags.NoTurretTargeting))
                Subscribe(nameof(OnTurretTarget));

            if (HasGlobalFlag(ZoneFlags.NoAPCTargeting))
                Subscribe(nameof(CanBradleyApcTarget));

            if (HasGlobalFlag(ZoneFlags.NoHeliTargeting))
            {
                Subscribe(nameof(CanHelicopterTarget));
                Subscribe(nameof(CanHelicopterStrafeTarget));
                Subscribe(nameof(OnHelicopterTarget));
            }

            if (HasGlobalFlag(ZoneFlags.NoNPCTargeting))
                Subscribe(nameof(OnNpcTarget));
        }

        private void UnsubscribeAll()
        {
            Unsubscribe(nameof(OnEntityBuilt));
            Unsubscribe(nameof(OnStructureUpgrade));
            Unsubscribe(nameof(OnItemDeployed));
            Unsubscribe(nameof(OnItemUse));
            Unsubscribe(nameof(OnRunPlayerMetabolism));
            Unsubscribe(nameof(OnPlayerChat));
            Unsubscribe(nameof(OnServerCommand));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(CanBeWounded));
            Unsubscribe(nameof(CanUpdateSign));
            Unsubscribe(nameof(OnOvenToggle));
            Unsubscribe(nameof(CanUseVending));
            Unsubscribe(nameof(CanHideStash));
            Unsubscribe(nameof(CanCraft));
            Unsubscribe(nameof(OnDoorOpened));
            Unsubscribe(nameof(CanLootPlayer));
            Unsubscribe(nameof(OnLootPlayer));
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(CanPickupEntity));
            Unsubscribe(nameof(CanPickupLock));
            Unsubscribe(nameof(OnItemPickup));
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(OnCollectiblePickup));
            Unsubscribe(nameof(OnGrowableGather));
            Unsubscribe(nameof(OnDispenserGather));
            Unsubscribe(nameof(OnTurretTarget));
            Unsubscribe(nameof(CanBradleyApcTarget));
            Unsubscribe(nameof(CanHelicopterTarget));
            Unsubscribe(nameof(CanHelicopterStrafeTarget));
            Unsubscribe(nameof(OnHelicopterTarget));
            Unsubscribe(nameof(OnNpcTarget));
            Unsubscribe(nameof(OnPlayerVoice));
        }
        #endregion

        #region Zone Creation
        private void UpdateZoneDefinition(Zone zone, string[] args, BasePlayer player = null)
        {
            for (var i = 0; i < args.Length; i = i + 2)
            {
                object editvalue;
                switch (args[i].ToLower())
                {
                    case "name":
                        editvalue = zone.definition.Name = args[i + 1];
                        break;

                    case "id":
                        editvalue = zone.definition.Id = args[i + 1];
                        break;

                    case "comfort":
                        editvalue = zone.definition.Comfort = Convert.ToSingle(args[i + 1]);
                        break;

                    case "temperature":
                        editvalue = zone.definition.Temperature = Convert.ToSingle(args[i + 1]);
                        break;

                    case "radiation":
                        editvalue = zone.definition.Radiation = Convert.ToSingle(args[i + 1]);
                        break;

                    case "safezone":
                        editvalue = zone.definition.SafeZone = Convert.ToBoolean(args[i + 1]);
                        break;

                    case "radius":
                        editvalue = zone.definition.Radius = Convert.ToSingle(args[i + 1]);
                        zone.definition.Size = Vector3.zero;
                        break;

                    case "rotation":
                        float rotation;
                        if (float.TryParse(args[i + 1], out rotation))
                            zone.definition.Rotation = Quaternion.AngleAxis(rotation, Vector3.up).eulerAngles;
                        else zone.definition.Rotation = new Vector3(0, player?.GetNetworkRotation().eulerAngles.y ?? 0, 0);

                        editvalue = zone.definition.Rotation;
                        break;

                    case "location":
                        if (player != null && args[i + 1].Equals("here", StringComparison.OrdinalIgnoreCase))
                        {
                            editvalue = zone.definition.Location = player.transform.position;
                            break;
                        }

                        string[] location = args[i + 1].Trim().Split(' ');
                        if (location.Length == 3)
                            editvalue = zone.definition.Location = new Vector3(Convert.ToSingle(location[0]), Convert.ToSingle(location[1]), Convert.ToSingle(location[2]));
                        else
                        {
                            if (player != null)
                                SendMessage(player, "Invalid location format. Correct syntax is \"/zone location \"x y z\"\" - or - \"/zone location here\"");
                            continue;
                        }
                        break;

                    case "size":
                        string[] size = args[i + 1].Trim().Split(' ');
                        if (size.Length == 3)
                            editvalue = zone.definition.Size = new Vector3(Convert.ToSingle(size[0]), Convert.ToSingle(size[1]), Convert.ToSingle(size[2]));
                        else
                        {
                            if (player != null)
                                SendMessage(player, "Invalid size format, Correct syntax is \"/zone size \"x y z\"\"");
                            continue;
                        }
                        break;

                    case "enter_message":
                        editvalue = zone.definition.EnterMessage = args[i + 1];
                        break;

                    case "leave_message":
                        editvalue = zone.definition.LeaveMessage = args[i + 1];
                        break;

                    case "parentid":
                        editvalue = args[i + 1];
                        Zone parent;
                        if (zones.TryGetValue((string)editvalue, out parent))
                        {
                            zone.definition.ParentID = (string)editvalue;
                            zone.FindZoneParent();
                            UpdateZoneFlags(zone);
                        }
                        else
                        {
                            if (player != null)
                                SendMessage(player, $"Unable to find zone with ID {editvalue}");
                            continue;
                        }
                        break;

                    case "permission":
                        string permission = args[i + 1];

                        if (!permission.StartsWith("zonemanager."))
                            permission = $"zonemanager.{permission}";

                        editvalue = zone.definition.Permission = permission;
                        break;

                    case "ejectspawns":
                        editvalue = zone.definition.EjectSpawns = args[i + 1];
                        break;

                    case "enabled":
                    case "enable":
                        bool enabled;
                        if (!bool.TryParse(args[i + 1], out enabled))
                            enabled = false;

                        editvalue = zone.definition.Enabled = enabled;
                        break;

                    default:
                        try
                        {
                            ZoneFlags flag = (ZoneFlags)Enum.Parse(typeof(ZoneFlags), args[i], true);

                            bool active;
                            if (!bool.TryParse(args[i + 1], out active))
                                active = false;

                            editvalue = active;

                            if (active)
                                AddFlag(zone, flag);
                            else RemoveFlag(zone, flag);
                        }
                        catch
                        {
                            if (player != null)
                                SendMessage(player, $"Invalid zone flag: {args[i]}");
                            continue;
                        }
                        break;
                }
                if (player != null)
                    SendMessage(player, $"{args[i]} set to {editvalue}");
            }
        }
        #endregion

        #region Commands
        [ChatCommand("zone_add")]
        private void cmdChatZoneAdd(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            Zone.Definition definition = new Zone.Definition(player.transform.position) { Id = UnityEngine.Random.Range(1, 99999999).ToString() };

            CreateZone(definition);

            lastPlayerZone[player.userID] = definition.Id;

            SaveData();

            ShowZone(player, definition.Id);

            SendMessage(player, "You have successfully created a new zone with ID : {0}!\nYou can edit it using the /zone_edit command", definition.Id);
        }

        [ChatCommand("zone_wipe")]
        private void cmdChatZoneReset(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            storedData.definitions.Clear();
            SaveData();
            Unload();
            SendMessage(player, "Wiped zone data");
        }

        [ChatCommand("zone_remove")]
        private void cmdChatZoneRemove(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            if (args.Length == 0)
            {
                SendMessage(player, "Invalid syntax! /zone_remove <zone ID>");
                return;
            }

            Zone zone;
            if (!zones.TryGetValue(args[0], out zone))
            {
                SendMessage(player, "A zone with the specified ID does not exist");
                return;
            }

            zones.Remove(args[0]);
            UnityEngine.Object.Destroy(zone.gameObject);
            SaveData();

            SendMessage(player, "Successfully removed zone : {0}", args[0]);
        }

        [ChatCommand("zone_stats")]
        private void cmdChatZoneStats(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            SendMessage(player, "Zones : {0}", zones.Count);
            SendMessage(player, "Players in Zones: {0}", zonedPlayers.Count);
            SendMessage(player, "Entities in Zones: {0}", zonedEntities.Count);
        }

        [ChatCommand("zone_edit")]
        private void cmdChatZoneEdit(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            string zoneId;
            if (args.Length == 0)
            {
                EntityZones entityZones;
                if (!zonedPlayers.TryGetValue(player.userID, out entityZones) || entityZones.Count != 1)
                {
                    SendMessage(player, "You must enter a zone ID. /zone_edit <zone ID>");
                    return;
                }
                zoneId = entityZones.Zones.First().definition.Id;
            }
            else zoneId = args[0];

            if (!zones.ContainsKey(zoneId))
            {
                SendMessage(player, "The specified zone does not exist");
                return;
            }

            lastPlayerZone[player.userID] = zoneId;

            SendMessage(player, "You are now editing the zone with ID : {0}", zoneId);
            ShowZone(player, zoneId);
        }

        [ChatCommand("zone_list")]
        private void cmdChatZoneList(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            SendMessage(player, "--- Zone list ---");
            if (zones.Count == 0)
            {
                SendMessage(player, "None...");
                return;
            }

            foreach (KeyValuePair<string, Zone> zone in zones)
                SendMessage(player, $"ID: {zone.Key} - {zone.Value.definition.Name} - {zone.Value.definition.Location}");
        }

        [ChatCommand("zone")]
        private void cmdChatZone(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            string zoneId;
            if (!lastPlayerZone.TryGetValue(player.userID, out zoneId))
            {
                SendMessage(player, "You must start editing a zone first. /zone_edit <zone ID>");
                return;
            }

            Zone zone;
            if (!zones.TryGetValue(zoneId, out zone))
            {
                SendMessage(player, "Unable to find a zone with ID : {0}", zoneId);
                return;
            }

            if (args.Length == 0)
            {
                SendMessage(player, "/zone <option> <value>");
                string message = $"<color={configData.Notifications.Color}>Name:</color> {zone.definition.Name}";
                message += $"\n<color={configData.Notifications.Color}>Enabled:</color> {zone.definition.Enabled}";
                message += $"\n<color={configData.Notifications.Color}>ID:</color> {zone.definition.Id}";
                message += $"\n<color={configData.Notifications.Color}>Comfort:</color> {zone.definition.Comfort}";
                message += $"\n<color={configData.Notifications.Color}>Temperature:</color> {zone.definition.Temperature}";
                message += $"\n<color={configData.Notifications.Color}>Radiation:</color> {zone.definition.Radiation}";
                message += $"\n<color={configData.Notifications.Color}>Safe Zone?:</color> {zone.definition.SafeZone}";
                SendReply(player, message);

                message = $"<color={configData.Notifications.Color}>Radius:</color> {zone.definition.Radius}";
                message += $"\n<color={configData.Notifications.Color}>Location:</color> {zone.definition.Location}";
                message += $"\n<color={configData.Notifications.Color}>Size:</color> {zone.definition.Size}";
                message += $"\n<color={configData.Notifications.Color}>Rotation:</color> {zone.definition.Rotation}";
                SendReply(player, message);

                message = $"<color={configData.Notifications.Color}>Enter Message:</color> {zone.definition.EnterMessage}";
                message += $"\n<color={configData.Notifications.Color}>Leave Message:</color> {zone.definition.LeaveMessage}";
                SendReply(player, message);

                message = $"<color={configData.Notifications.Color}>Permission:</color> {zone.definition.Permission}";
                message += $"\n<color={configData.Notifications.Color}>Eject Spawnfile:</color> {zone.definition.EjectSpawns}";
                message += $"\n<color={configData.Notifications.Color}>Parent Zone ID:</color> {zone.definition.ParentID}";
                SendReply(player, message);

                SendReply(player, $"<color={configData.Notifications.Color}>Flags:</color> {zone.definition.Flags}");
                ShowZone(player, zoneId);
                return;
            }

            if (args[0].ToLower() == "flags")
            {
                OpenFlagEditor(player, zoneId);
                return;
            }

            if (args.Length % 2 != 0)
            {
                SendMessage(player, "Value missing. You must follow a option with a value");
                return;
            }
            UpdateZoneDefinition(zone, args, player);
            zone.Reset();
            SaveData();
            ShowZone(player, zoneId);
        }

        [ChatCommand("zone_flags")]
        private void cmdChatZoneFlags(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            string zoneId;
            if (!lastPlayerZone.TryGetValue(player.userID, out zoneId))
            {
                SendMessage(player, "You must start editing a zone first. /zone_edit <zone ID>");
                return;
            }

            OpenFlagEditor(player, zoneId);
        }

        [ChatCommand("zone_player")]
        private void cmdChatZonePlayer(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, PERMISSION_ZONE))
            {
                SendMessage(player, "You don't have access to this command");
                return;
            }

            BasePlayer targetPlayer = player;
            if (args != null && args.Length > 0)
            {
                targetPlayer = BasePlayer.Find(args[0]);
                if (!targetPlayer)
                {
                    SendMessage(player, "Unable to find a player with the specified information");
                    return;
                }
            }

            EntityZones entityZones;
            if (!zonedPlayers.TryGetValue(targetPlayer.userID, out entityZones))
            {
                SendReply(player, "The specified player is not in any zone");
                return;
            }

            SendMessage(player, $"--- {targetPlayer.displayName} ---");
            SendMessage(player, $"Has Flags: {entityZones.Flags}");
            SendMessage(player, "Is in zones:");

            foreach (Zone zone in entityZones.Zones)
                SendMessage(player, $"{zone.definition.Id}: {zone.definition.Name} - {zone.definition.Location}");
        }

        [ConsoleCommand("zone")]
        private void ccmdZone(ConsoleSystem.Arg arg)
        {
            if (!HasPermission(arg, PERMISSION_ZONE))
            {
                SendReply(arg, "You don't have access to this command");
                return;
            }

            string zoneId = arg.GetString(0);
            Zone zone;
            if (!arg.HasArgs(3) || !zones.TryGetValue(zoneId, out zone))
            {
                SendReply(arg, "Zone ID not found or too few arguments supplied: zone <zoneid> <arg> <value>");
                return;
            }

            string[] args = new string[arg.Args.Length - 1];
            Array.Copy(arg.Args, 1, args, 0, args.Length);

            UpdateZoneDefinition(zone, args, arg.Player());
            zone.Reset();
            SaveData();
        }
        #endregion

        #region UI
        const string ZMUI = "zmui.editor";
        #region Helper
        public static class UI
        {
            static public CuiElementContainer Container(string panel, string color, string min, string max, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = min, AnchorMax = max},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panel
                    }
                };
                return container;
            }
            static public void Panel(ref CuiElementContainer container, string panel, string color, string min, string max, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = min, AnchorMax = max },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void Label(ref CuiElementContainer container, string panel, string text, int size, string min, string max, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = min, AnchorMax = max }
                },
                panel);

            }
            static public void Button(ref CuiElementContainer container, string panel, string color, string text, int size, string min, string max, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = min, AnchorMax = max },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region Creation
        private void OpenFlagEditor(BasePlayer player, string zoneId)
        {
            Zone zone = GetZoneByID(zoneId);
            if (!zone)
            {
                SendReply(player, $"Error getting zone object with ID: {zoneId}");
                CuiHelper.DestroyUi(player, ZMUI);
            }

            CuiElementContainer container = UI.Container(ZMUI, UI.Color("2b2b2b", 0.9f), "0 0", "1 1", true);
            UI.Label(ref container, ZMUI, $"Zone Flag Editor", 18, "0 0.92", "1 1");
            UI.Label(ref container, ZMUI, $"Zone ID: {zoneId}\nName: {zone.definition.Name}\n{(zone.definition.Size != Vector3.zero ? $"Box Size: {zone.definition.Size}\nRotation: {zone.definition.Rotation}" : $"Radius: {zone.definition.Radius}\nSafe Zone: {zone.definition.SafeZone}")}", 13, "0.05 0.8", "1 0.92", TextAnchor.UpperLeft);
            UI.Label(ref container, ZMUI, $"Comfort: {zone.definition.Comfort}\nRadiation: {zone.definition.Radiation}\nTemperature: {zone.definition.Temperature}\nZone Enabled: {zone.definition.Enabled}", 13, "0.25 0.8", "1 0.92", TextAnchor.UpperLeft);
            UI.Label(ref container, ZMUI, $"Permission: {zone.definition.Permission}\nEject Spawnfile: {zone.definition.EjectSpawns}\nEnter Message: {zone.definition.EnterMessage}\nExit Message: {zone.definition.LeaveMessage}", 13, "0.5 0.8", "1 0.92", TextAnchor.UpperLeft);
            UI.Button(ref container, ZMUI, UI.Color("#d85540", 1f), "Exit", 12, "0.95 0.96", "0.99 0.99", $"zmui.editflag {zoneId} exit");

            int count = 0;

            string[] flags = Enum.GetNames((typeof(ZoneFlags))).OrderBy(x => x).ToArray();

            for (int i = 0; i < flags.Length; i++)
            {
                string flagName = flags.ElementAt(i);
                if (flagName == "None")
                    continue;

                bool value = HasFlag(zoneId, flagName);

                float[] position = GetButtonPosition(count);

                UI.Label(ref container, ZMUI, flagName, 12, $"{position[0]} {position[1]}", $"{position[0] + ((position[2] - position[0]) / 2)} {position[3]}");
                UI.Button(ref container, ZMUI, value ? UI.Color("#72E572", 1f) : UI.Color("#d85540", 1f), value ? "Enabled" : "Disabled", 12, $"{position[0] + ((position[2] - position[0]) / 2)} {position[1]}", $"{position[2]} {position[3]}", $"zmui.editflag {zoneId} {flagName} {!value}");

                count++;
            }

            CuiHelper.DestroyUi(player, ZMUI);
            CuiHelper.AddUi(player, container);
        }

        private float[] GetButtonPosition(int i)
        {
            int column = i == 0 ? 0 : ColumnNumber(4, i);
            int row = i - (column * 4);

            float offsetX = 0.04f + ((0.01f + 0.21f) * row);
            float offsetY = (0.76f - (column * 0.04f));

            return new float[] { offsetX, offsetY, offsetX + 0.21f, offsetY + 0.03f };
        }

        private int ColumnNumber(int max, int count) => Mathf.FloorToInt(count / max);
        #endregion

        #region Commands
        [ConsoleCommand("zmui.editflag")]
        private void ccmdEditFlag(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (!player)
                return;

            string zoneId = arg.GetString(0);

            if (arg.GetString(1) == "exit")
                CuiHelper.DestroyUi(player, ZMUI);
            else
            {
                Zone zone = GetZoneByID(zoneId);
                if (!zone)
                {
                    SendReply(player, $"Error getting zone object with ID: {zoneId}");
                    CuiHelper.DestroyUi(player, ZMUI);
                }

                ZoneFlags flag = (ZoneFlags)Enum.Parse((typeof(ZoneFlags)), arg.GetString(1));

                if (arg.GetBool(2))
                    AddFlag(zone, flag);
                else RemoveFlag(zone, flag);

                SaveData();

                OpenFlagEditor(player, zoneId);
            }
        }
        #endregion
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Autolight Options")]
            public AutoLightOptions AutoLights { get; set; }

            [JsonProperty(PropertyName = "Notification Options")]
            public NotificationOptions Notifications { get; set; }

            [JsonProperty(PropertyName = "NPC players can deal player damage in zones with PvpGod flag")]
            public bool NPCHurtPvpGod { get; set; }

            [JsonProperty(PropertyName = "Allow decay damage in zones with Undestr flag")]
            public bool DecayDamageUndestr { get; set; }

            public class AutoLightOptions
            {
                [JsonProperty(PropertyName = "Time to turn lights on")]
                public float OnTime { get; set; }

                [JsonProperty(PropertyName = "Time to turn lights off")]
                public float OffTime { get; set; }

                [JsonProperty(PropertyName = "Lights require fuel to activate automatically")]
                public bool RequiresFuel { get; set; }
            }

            public class NotificationOptions
            {
                [JsonProperty(PropertyName = "Display notifications via PopupNotifications")]
                public bool Popups { get; set; }

                [JsonProperty(PropertyName = "Chat prefix")]
                public string Prefix { get; set; }

                [JsonProperty(PropertyName = "Chat color (hex)")]
                public string Color { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                AutoLights = new ConfigData.AutoLightOptions
                {
                    OnTime = 18f,
                    OffTime = 6f,
                    RequiresFuel = true
                },
                Notifications = new ConfigData.NotificationOptions
                {
                    Color = "#d85540",
                    Popups = false,
                    Prefix = "[Zone Manager] :"
                },
                NPCHurtPvpGod = false,
                DecayDamageUndestr = false,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(3, 0, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        private void SaveData()
        {
            storedData.definitions = new HashSet<Zone.Definition>();

            foreach (KeyValuePair<string, Zone> zone in zones)
                storedData.definitions.Add(zone.Value.definition);

            data.WriteObject(storedData);
        }

        private void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("ZoneManager/zone_data");
            data.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new Vector3Converter() };

            storedData = data.ReadObject<StoredData>();
            if (storedData == null)
                storedData = new StoredData();
        }

        private class StoredData
        {
            public HashSet<Zone.Definition> definitions = new HashSet<Zone.Definition>();
        }

        private class EntityZones
        {
            public ZoneFlags Flags { get; private set; }

            public HashSet<Zone> Zones { get; private set; }

            public EntityZones()
            {
                Zones = new HashSet<Zone>();
            }

            public void AddFlags(ZoneFlags flags)
            {
                Flags |= flags;
            }

            public void RemoveFlags(ZoneFlags flags)
            {
                Flags &= ~flags;
            }

            public bool HasFlag(ZoneFlags flags)
            {
                return (Flags & flags) == flags;
            }

            public void UpdateFlags()
            {
                Flags = ZoneFlags.None;

                for (int i = 0; i < Zones.Count; i++)
                {
                    Zone zone = Zones.ElementAt(i);
                    if (!zone)
                        continue;

                    AddFlags(zone.definition.Flags & ~zone.disabledFlags);
                }

                for (int i = 0; i < Zones.Count; i++)
                {
                    Zone zone = Zones.ElementAt(i);
                    if (!zone)
                        continue;

                    if (zone.parent != null && Zones.Contains(zone.parent))
                        RemoveFlags(zone.parent.definition.Flags);
                }
            }

            public bool EnterZone(Zone zone)
            {
                return Zones.Add(zone);
            }

            public bool LeaveZone(Zone zone)
            {
                return Zones.Remove(zone);
            }

            public bool IsInZone(Zone zone)
            {
                return Zones.Contains(zone);
            }

            public bool IsInZone(string zoneId)
            {
                return Zones.Select(x => x.definition.Id).Contains(zoneId);
            }

            public bool ShouldRemove() => Count == 0;

            public int Count => Zones.Count;
        }

        private class Vector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        #endregion

        #region Localization
        private string Message(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["noBuild"] = "You are not allowed to build in this area!",
            ["noUpgrade"] = "You are not allowed to upgrade structures in this area!",
            ["noDeploy"] = "You are not allowed to deploy items in this area!",
            ["noCup"] = "You are not allowed to deploy cupboards in this area!",
            ["noChat"] = "You are not allowed to chat in this area!",
            ["noSuicide"] = "You are not allowed to suicide in this area!",
            ["noGather"] = "You are not allowed to gather in this area!",
            ["noLoot"] = "You are not allowed loot in this area!",
            ["noSignUpdates"] = "You can not update signs in this area!",
            ["noOvenToggle"] = "You can not toggle ovens and lights in this area!",
            ["noPickup"] = "You can not pick up objects in this area!",
            ["noVending"] = "You can not use vending machines in this area!",
            ["noStash"] = "You can not hide a stash in this area!",
            ["noCraft"] = "You can not craft in this area!",
            ["eject"] = "You are not allowed in this area!",
            ["attract"] = "You are not allowed to leave this area!",
            ["kill"] = "Access to this area is restricted!",
            ["noVoice"] = "You are not allowed to voice chat in this area!",
            ["novehiclesenter"] = "Vehicles are not allowed in this area!",
            ["novehiclesleave"] = "Vehicles are not allowed to leave this area!"
        };
        #endregion                
    }
}


// --- End of file: ZoneManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DropBlocker.cs ---
// --- Original Local Path: DropBlocker.cs ---

using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Drop Blocker", "Krava", 1.1)]
    [Description("Anti drop items at the craft.")]

    public class DropBlocker : RustPlugin
    {
        private class TempData
        {
            public int Uid { get; set; }
            public int Amount { get; set; }
            public int Stack { get; set; }
        }

        private void Loaded()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "CantCraft", "Item not crafted! Your inventory is full." }
            }, this);
        }

        private void Merge(ItemCraftTask task, ref List<TempData> data)
        {
            var amount = task.amount;
            var item = task.blueprint.targetItem;

            foreach (var p in data.Where(x => x.Uid == item.itemid && x.Stack - x.Amount > 0))
            {
                if (amount == 0) break;

                var toStack = p.Stack - p.Amount;

                if (amount > toStack)
                {
                    p.Amount += toStack;
                    amount -= toStack;
                }
                else
                {
                    p.Amount += amount;
                    amount = 0;
                    break;
                }
            }

            if (amount != 0)
            {
                var count = amount / item.stackable;

                for (var i = 0; i < count; i++)
                    data.Add(new TempData
                    {
                        Uid = item.itemid,
                        Amount = item.stackable,
                        Stack = item.stackable
                    });

                if (amount % item.stackable != 0)
                {
                    data.Add(new TempData
                    {
                        Uid = item.itemid,
                        Amount = amount % item.stackable,
                        Stack = item.stackable
                    });
                }
            }
        }

        private bool CanCraft(BasePlayer player, ItemCraftTask task)
        {
            var data = new List<TempData>();

            foreach (var item in player.inventory.containerMain.itemList)
                data.Add(new TempData
                {
                    Uid = item.info.itemid,
                    Amount = item.amount,
                    Stack = item.MaxStackable()
                });

            foreach (var item in player.inventory.containerBelt.itemList)
                data.Add(new TempData
                {
                    Uid = item.info.itemid,
                    Amount = item.amount,
                    Stack = item.MaxStackable()
                });

            foreach (var t in player.inventory.crafting.queue)
                Merge(t, ref data);

            Merge(task, ref data);

            if (data.Count <= 30)
                return true;

            return false;
        }

        private void OnItemCraft(ItemCraftTask task, BasePlayer player)
        {
            if (task == null || player == null)
                return;

            if (!CanCraft(player, task))
            {
                task.cancelled = true;

                foreach (Item i in task.takenItems)
                    player.inventory.GiveItem(i);

                SendReply(player, GetMessage("CantCraft", player.UserIDString));
            }
        }

        private string GetMessage(string name, string sid = null)
        {
            return lang.GetMessage(name, this, sid);
        }
    }
}

// --- End of file: DropBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PoliticalSurvival.cs ---
// --- Original Local Path: PoliticalSurvival.cs ---

// Reference: MySql.Data

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MySql.Data;
using MySql.Data.MySqlClient;
using MySql.Data.Common;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PoliticalSurvival", "Jonty", 0.2)]
    [Description("Political Survival - Become the President, tax your subjects and keep them in line!")]
    class PoliticalSurvival : RustPlugin
    {
        static void Main(string[] args) { }

        public class StrayPlayer
        {
            public ulong SteamId;
            public bool IsSettingTaxChest;

            public StrayPlayer(ulong pSteamId)
            {
                this.SteamId = pSteamId;
                this.IsSettingTaxChest = false;
            }
        }

        Dictionary<BasePlayer, StrayPlayer> OnlinePlayers;
        Dictionary<string, string> ServerMessages;

        MySqlConnection Database;

        string DatabaseHost = "";
        string DatabasePort = "";
        string DatabaseUsername = "";
        string DatabasePassword = "";
        string DatabaseName = "";

        ulong President = 0;
        double TaxLevel = 20.0;
        string RealmName = "";

        float TaxChestX = 0;
        float TaxChestY = 0;
        float TaxChestZ = 0;

        StorageContainer TaxContainer = null;

        private void LoadDefaultConfig()
        {
            CreateConfigEntry("Database", "Host", "127.0.0.1");
            CreateConfigEntry("Database", "Port", "3306");
            CreateConfigEntry("Database", "Username", "root");
            CreateConfigEntry("Database", "Password", "lol123");
            CreateConfigEntry("Database", "Name", "rust");

            SaveConfig();
        }

        void Init()
        {
            DatabaseHost = Config["Database", "Host"].ToString();
            DatabasePort = Config["Database", "Port"].ToString();
            DatabaseUsername = Config["Database", "Username"].ToString();
            DatabasePassword = Config["Database", "Password"].ToString();
            DatabaseName = Config["Database", "Name"].ToString();
            RealmName = lang.GetMessage("DefaultRealm", this);

            Puts("Political Survival is starting...");

            OnlinePlayers = new Dictionary<BasePlayer, StrayPlayer>();
            LoadServerMessages();

            try
            {
                Database = new MySqlConnection();
                Database.ConnectionString = "server=" + DatabaseHost + ";port=" + DatabasePort + ";uid=" + DatabaseUsername + ";pwd=" + DatabasePassword + ";database=" + DatabaseName + ";";
                Database.Open();

                MySqlCommand GetSettings = new MySqlCommand("SELECT president,tax_level,realm_name,tax_chest FROM settings LIMIT 1", Database);
                MySqlDataReader SettingsReader = GetSettings.ExecuteReader();

                while (SettingsReader.Read())
                {
                    President = SettingsReader.GetUInt64(0);
                    TaxLevel = SettingsReader.GetInt32(1);
                    RealmName = SettingsReader.GetString(2);

                    string[] TaxCoordinates = SettingsReader.GetString(3).Split(';');
                    TaxChestX = Convert.ToSingle(TaxCoordinates[0]);
                    TaxChestY = Convert.ToSingle(TaxCoordinates[1]);
                    TaxChestZ = Convert.ToSingle(TaxCoordinates[2]);				
                }

                SettingsReader.Dispose();
                GetSettings.Dispose();
            }
            catch (Exception e)
            {
                PrintToConsole(e.ToString());
                PrintToConsole("If this is the first time running the plugin, please edit the configuration!");
            }
         
            Puts("Realm name is " + RealmName);
            Puts("Tax level is " + TaxLevel);
            Puts("President is " + President);

            LoadTaxContainer();

            if (BasePlayer.activePlayerList.Count >= 1)
            {
                foreach (BasePlayer iPlayer in BasePlayer.activePlayerList)
                {
                    AddPlayer(iPlayer);
                }

                Puts(OnlinePlayers.Count + " players cached.");
            }

            Puts("Political Survival: Started");
        }

        void OnPlayerInit(BasePlayer Player)
        {
            PrintToChat(Player.displayName + " " + lang.GetMessage("PlayerConnected", this, Player.UserIDString) + " " + RealmName);
            AddPlayer(Player);
        }

        void OnPlayerDisconnected(BasePlayer Player, string Reason)
        {
            PrintToChat(Player.displayName + " " + lang.GetMessage("PlayerDisconnected", this, Player.UserIDString) + " " + RealmName);
            RemovePlayer(Player);
        }

        void OnDispenserGather(ResourceDispenser Dispenser, BaseEntity Entity, Item Item)
        {
            if (TaxLevel > 0 && President > 0)
            {
                int Tax = Convert.ToInt32(Math.Round((Item.amount * TaxLevel) / 100));
                Item.amount = Item.amount - Tax;

                if (TaxContainer == null)
                {
                    TaxChestX = 0;
                    TaxChestY = 0;
                    TaxChestZ = 0;
                    SaveTaxContainer();
                    LoadTaxContainer();
                    return;
                }

                if (!TaxContainer.inventory.IsFull())
                {
                    ItemDefinition ToAdd = ItemManager.FindItemDefinition(Item.info.itemid);

                    if (ToAdd != null)
                    {
                        TaxContainer.inventory.AddItem(ToAdd, Tax);
                    }
                }
            }
        }

        void OnPlantGather(PlantEntity Plant, Item Item, BasePlayer Player)
        {
            int Tax = Convert.ToInt32(Math.Round((Item.amount * TaxLevel) / 100));
            Item.amount = Item.amount - Tax;
        }

        void OnEntityDeath(BaseCombatEntity Entity, HitInfo Info)
        {
            BasePlayer Player = Entity.ToPlayer();

            if (Player != null)
            {
                if (IsPresident(Player.userID))
                {
                    BasePlayer Killer = null;

                    if (Info != null)
                        Killer = Info.Initiator.ToPlayer();

                    if (Killer != null && Killer.userID != Player.userID)
                    {
                        SetPresident(Killer.userID);
                        PrintToChat(string.Format(lang.GetMessage("PresidentMurdered", this), Killer.displayName));
                    }
                    else
                    {
                        SetPresident(0);
                        PrintToChat(string.Format(lang.GetMessage("PresidentDied", this)));
                    }
                }
            }
        }

        void OnPlayerAttack(BasePlayer Attacker, HitInfo Info)
        {
            BasePlayer Defender = Info.HitEntity.ToPlayer();

            if (Defender != null)
            {
                // Is a person
            }
            else
            {
                uint EntityId = Info.HitEntity.prefabID;

                if (EntityId == 2014947887 || EntityId == 3439001196)
                {
                    StrayPlayer Stray = OnlinePlayers[Attacker.ToPlayer()];

                    if (Stray == null)
                        return;

                    if (Stray.IsSettingTaxChest)
                    {
                        Vector3 BoxPosition = Info.HitEntity.transform.position;
                        float x = BoxPosition.x;
                        float y = BoxPosition.y;
                        float z = BoxPosition.z;

                        SendReply(Attacker.ToPlayer(), lang.GetMessage("SetNewTaxChest", this, Attacker.ToPlayer().UserIDString));

                        TaxChestX = x;
                        TaxChestY = y;
                        TaxChestZ = z;
						
                        SaveTaxContainer();
                        LoadTaxContainer();

                        Stray.IsSettingTaxChest = false;
                    }
                }
            }
        }

        [ChatCommand("settaxchest")]
        void SetTaxChestCommand(BasePlayer Player, string Command, string[] Arguments)
        {
            if (!IsPresident(Player.userID))
            {
                SendReply(Player, lang.GetMessage("PresidentError", this, Player.UserIDString));
                return;
            }

            StrayPlayer Stray = OnlinePlayers[Player];

            if (Stray.IsSettingTaxChest)
            {
                Stray.IsSettingTaxChest = false;
                SendReply(Player, lang.GetMessage("NotSettingNewTaxChest", this, Player.UserIDString));
            }
            else
            {
                Stray.IsSettingTaxChest = true;
                SendReply(Player, lang.GetMessage("SettingNewTaxChest", this, Player.UserIDString));
            }
        }

        [ChatCommand("info")]
        void InfoCommand(BasePlayer Player, string Command, string[] Arguments)
        {
            string PresidentName = "";

            if (President > 0)
            {
                BasePlayer BasePresident = BasePlayer.FindByID(President);

                if (BasePresident != null)
                {
                    PresidentName = BasePresident.displayName;
                }
                else
                {
                    BasePlayer SleepingPresident = BasePlayer.FindSleeping(President);

                    if (SleepingPresident != null)
                    {
                        PresidentName = SleepingPresident.displayName;
                    }
                    else
                    {
                        PresidentName = lang.GetMessage("ClaimPresident", this, Player.UserIDString);
                        President = 0;
                    }
                }
            }
            else
                PresidentName = lang.GetMessage("ClaimPresident", this, Player.UserIDString);

            SendReply(Player, lang.GetMessage("InfoPresident", this, Player.UserIDString) + ": " + PresidentName);
            SendReply(Player, lang.GetMessage("InfoRealmName", this, Player.UserIDString) + ": " + RealmName);
            SendReply(Player, lang.GetMessage("InfoTaxLevel", this, Player.UserIDString) + ": " + TaxLevel + "%");         
        }

        [ChatCommand("claimpresident")]
        void ClaimPresident(BasePlayer Player, string Command, string[] Arguments)
        {
            if (President < 1)
            {
                PrintToChat("<color=#008080ff><b>" + Player.displayName + "</b></color> " + lang.GetMessage("IsNowPresident", this));
                SetPresident(Player.userID);
            }
        }

        [ChatCommand("settax")]
        void SetTaxCommand(BasePlayer Player, string Command, string[] Arguments)
        {
            if (IsPresident(Player.userID))
            {
                double NewTaxLevel = Convert.ToDouble(MergeParams(Arguments, 0));

                if (NewTaxLevel > 25.0)
                    NewTaxLevel = 25.0;

                if (NewTaxLevel == TaxLevel)
                    return;

                if (NewTaxLevel < 1)
                    NewTaxLevel = 0;

                SetTaxLevel(NewTaxLevel);

                PrintToChat(string.Format(lang.GetMessage("UpdateTaxMessage", this), Player.displayName, NewTaxLevel));
            }
            else
                SendReply(Player, lang.GetMessage("PresidentError", this, Player.UserIDString));
        }

        [ChatCommand("realmname")]
        void RealmNameCommand(BasePlayer Player, string Command, string[] Arguments)
        {
            if (IsPresident(Player.userID))
            {
                string NewName = MergeParams(Arguments, 0);

                if (!String.IsNullOrEmpty(NewName))
                {
                    SetRealmName(NewName);
                }
            }
            else
                SendReply(Player, lang.GetMessage("PresidentError", this, Player.UserIDString));
        }

        [ChatCommand("pm")]
        void PrivateMessage(BasePlayer Player, string Command, string[] Arguments)
        {
            string Name = Arguments[0];
            string Message = MergeParams(Arguments, 1);

            if (IsPlayerOnline(Name))
            {
                BasePlayer Reciever = GetPlayer(Name);
                SendReply(Reciever, "<color=#ffff00ff>" + lang.GetMessage("PrivateFrom", this, Reciever.UserIDString) + " " + Player.displayName + "</color>: " + Message);
                SendReply(Player, "<color=#ffff00ff>" + lang.GetMessage("PrivateTo", this, Reciever.UserIDString) + " " + Reciever.displayName + "</color>: " + Message);
            }
            else
                SendReply(Player, Name + lang.GetMessage("PrivateError", this));
        }

        [ChatCommand("players")]
        void PlayersCommand(BasePlayer Player, string Command, string[] Arguments)
        {
            StringBuilder Builder = new StringBuilder();
            int PlayerCount = BasePlayer.activePlayerList.Count;
            int Cycle = 1;
            
            Builder.Append(string.Format(lang.GetMessage("OnlinePlayers", this), PlayerCount) + " ");

            foreach (BasePlayer iPlayer in BasePlayer.activePlayerList)
            {
                Builder.Append(iPlayer.displayName);

                if (Cycle < PlayerCount)
                    Builder.Append(", ");

                Cycle++;
            }

            SendReply(Player, Builder.ToString());
        }

        void AddPlayer(BasePlayer Player)
        {
            GetPlayerFromDatabase(Player);
        }

        void RemovePlayer(BasePlayer Player)
        {
            OnlinePlayers.Remove(Player);
        }

        StrayPlayer GetStrayPlayer(string Username)
        {
            return OnlinePlayers[BasePlayer.Find(Username)];
        }

        bool IsPlayerOnline(string Username)
        {
            if (BasePlayer.Find(Username) != null)
                return true;

            return false;
        }

        BasePlayer GetPlayer(string Username)
        {
            return BasePlayer.Find(Username);
        }

        string MergeParams(string[] Params, int Start)
        {
            var Merged = new StringBuilder();
            for (int i = Start; i < Params.Length; i++)
            {
                if (i > Start)
                    Merged.Append(" ");
                Merged.Append(Params[i]);
            }

            return Merged.ToString();
        }

        bool IsPresident(ulong SteamId)
        {
            if (President == SteamId)
                return true;

            return false;
        }

        void SetPresident(ulong SteamId)
        {
            President = SteamId;
            RealmName = lang.GetMessage("DefaultRealm", this);
            TaxLevel = 0.0;

            string PresidentText = "UPDATE settings SET tax_level = " + TaxLevel + ", realm_name = '" + RealmName + "', president = " + President;

            MySqlCommand UpdatePresident = new MySqlCommand(PresidentText, Database);
            UpdatePresident.ExecuteNonQuery();
            UpdatePresident.Dispose();
        }

        void SetTaxLevel(double NewTaxLevel)
        {
            TaxLevel = NewTaxLevel;

            string TaxText = "UPDATE settings SET tax_level = " + NewTaxLevel;

            MySqlCommand UpdateTax = new MySqlCommand(TaxText, Database);
            UpdateTax.ExecuteNonQuery();
            UpdateTax.Dispose();
        }

        void SetRealmName(string NewName)
        {
            if (NewName.Length > 36)
                NewName = NewName.Substring(0, 36);

            RealmName = NewName;
            PrintToChat(string.Format(lang.GetMessage("RealmRenamed", this), NewName));

            string RealmText = "UPDATE settings SET realm_name = '" + RealmName + "'";

            MySqlCommand RealmCommand = new MySqlCommand(RealmText, Database);
            RealmCommand.ExecuteNonQuery();
            RealmCommand.Dispose();
        }

        void GetPlayerFromDatabase(BasePlayer Player)
        {
            StrayPlayer IPlayer = null;

            string CommandText = "SELECT id FROM players WHERE steam_id = " + Player.userID;
            MySqlCommand Command = new MySqlCommand(CommandText, Database);
            bool Exists = Command.ExecuteScalar() != null ? true : false;
            Command.Dispose();

            if (!Exists)
            {
                string InsertText = "INSERT INTO players (steam_id) VALUES ('" + Player.userID + "')";
                MySqlCommand InsertCommand = new MySqlCommand(InsertText, Database);
                InsertCommand.ExecuteNonQuery();
                InsertCommand.Dispose();
            }

            string InfoText = "SELECT * FROM players WHERE steam_id = " + Player.userID;
            MySqlCommand InfoCommand = new MySqlCommand(InfoText, Database);
            MySqlDataReader InfoReader = InfoCommand.ExecuteReader();

            while (InfoReader.Read())
            {
                IPlayer = new StrayPlayer(Player.userID);
            }

            InfoReader.Dispose();
            InfoCommand.Dispose();

            OnlinePlayers.Add(Player, IPlayer);
        }

        void LoadTaxContainer()
        {
            foreach (StorageContainer Cont in StorageContainer.FindObjectsOfType<StorageContainer>())
            {
                Vector3 ContPosition = Cont.transform.position;
                if (ContPosition.x == TaxChestX && ContPosition.y == TaxChestY && ContPosition.z == TaxChestZ)
                {
                    Puts("Tax Container instance found: " + Cont.GetEntity().GetInstanceID());
                    TaxContainer = Cont;
                }
            }
        }

        void SaveTaxContainer()
        {
            string TaxCommandText = "UPDATE settings SET tax_chest = '" + TaxChestX + ";" + TaxChestY + ";" + TaxChestZ + "'";
            MySqlCommand TaxCommand = new MySqlCommand(TaxCommandText, Database);
            TaxCommand.ExecuteNonQuery();
            TaxCommand.Dispose();
        }

        private void CreateConfigEntry(string Key, string SubKey, string Value)
        {
            if (Config[Key, SubKey] != null)
                return;

            Config[Key, SubKey] = Value;
        }

        private void LoadServerMessages()
        {
            ServerMessages = new Dictionary<string, string>();

            ServerMessages.Add("StartingInformation", "<color=yellow>Welcome to {0}</color>. If you are new, we run a custom plugin where you can become the server President, tax players, and control the economy. Type /info for more information.");
            ServerMessages.Add("PlayerConnected", "has connected to");
            ServerMessages.Add("PlayerDisconnected", "has disconnected from");
            ServerMessages.Add("PresidentDied", "<color=#ff0000ff>The President has died!</color>");
            ServerMessages.Add("PresidentMurdered", "<color=#ff0000ff>The President has been murdered by {0}, who is now the President.</color>");
            ServerMessages.Add("RealmRenamed", "The realm has been renamed to <color=#008080ff>{0}</color>");
            ServerMessages.Add("DefaultRealm", "The land of the Free");
            ServerMessages.Add("OnlinePlayers", "Online players ({0}):");
            ServerMessages.Add("PrivateError", "is either offline or you typed the name wrong.");
            ServerMessages.Add("PrivateFrom", "PM from");
            ServerMessages.Add("PrivateTo", "PM sent to");
            ServerMessages.Add("PresidentError", "You need to be the President to do that!");
            ServerMessages.Add("SettingNewTaxChest", "You are now setting the new tax chest. Hit a storage box to make that the tax chest.");
            ServerMessages.Add("NotSettingNewTaxChest", "You are no longer setting the tax chest.");
            ServerMessages.Add("SetNewTaxChest", "You have set the new tax chest.");
            ServerMessages.Add("ClaimPresident", "Nobody! /claimpresident to become President!");
            ServerMessages.Add("IsNowPresident", "is now the President!");
            ServerMessages.Add("InfoPresident", "President");
            ServerMessages.Add("InfoRealmName", "Realm Name");
            ServerMessages.Add("InfoTaxLevel", "Tax level");
            ServerMessages.Add("UpdateTaxMessage", "President {0} has set Tax to {1}%");

            lang.RegisterMessages(ServerMessages, this);
        }
    }
}

// --- End of file: PoliticalSurvival.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/JoinQuitMsg.cs ---
// --- Original Local Path: JoinQuitMsg.cs ---

using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Join Quit Msg", "Those45Ninjas", "0.4.0", ResourceId = 1409)]
    [Description("Let users know when someone has joined or left the server.")]
    public class JoinQuitMsg : RustPlugin
    {
        #region config Keys
        const string conf_JoinMsg = "Player join message";
        const string conf_QuitMsg = "Player leave message";
        const string conf_AdminCol = "Admin Colour";
        const string conf_PlayerCol = "Player Colour";

        const string conf_OnlyAdmin = "Only Show Admins";
        const string conf_ShowConnect = "Show Connections";
        const string conf_ShowDisConn = "show Disconnections";
        #endregion

        // Keep these config variables in memory so I don't have to keep calling Config[];
        string joinFormat = "<color={1}>{0}</color> has joined the game.";
        string quitFormat = "<color={1}>{0}</color> has left the game (Reason: {2}).";
        string adminColour = "#AAFF55";
        string userColour = "#55AAFF";
        bool onlyShowAdmins = false;
        bool showConnections = true;
        bool showDisconnections = true;

        protected override void LoadDefaultConfig()
        {
            // Create the default configuration file.
            PrintWarning("Creating a new configuration file.");
            Config.Clear();
            LoadConfigFile();
        }
        void Loaded()
        {
            LoadConfigFile();
        }
        void LoadConfigFile()
        {
            bool missing = false;
            // Load or set the Join Message Format.
            if (Config[conf_JoinMsg] != null)
                joinFormat = Config[conf_JoinMsg].ToString();
            else
            {
                missing = true;
                Config[conf_JoinMsg] = joinFormat;
            }

            // Load or set the Quit Message Format.
            if (Config[conf_QuitMsg] != null)
                quitFormat = Config[conf_QuitMsg].ToString();
            else
            {
                missing = true;
                Config[conf_QuitMsg] = quitFormat;
            }

            // Load or set the admin colour.
            if (Config[conf_AdminCol] != null)
                adminColour = Config[conf_AdminCol].ToString();
            else
            {
                missing = true;
                Config[conf_AdminCol] = adminColour;
            }

            // Load or set the user colour.
            if (Config[conf_PlayerCol] != null)
                userColour = Config[conf_PlayerCol].ToString();
            else
            {
                missing = true;
                Config[conf_PlayerCol] = userColour;
            }

            // Load or set only show admins.
            if (Config[conf_OnlyAdmin] != null)
                onlyShowAdmins = (bool)Config[conf_OnlyAdmin];
            else
            {
                missing = true;
                Config[conf_OnlyAdmin] = onlyShowAdmins;
            }

            // Load or set show connections.
            if (Config[conf_ShowConnect] != null)
                showConnections = (bool)Config[conf_ShowConnect];
            else
            {
                missing = true;
                Config[conf_ShowConnect] = showConnections;
            }

            // Load or set show disconnections.
            if (Config[conf_ShowDisConn] != null)
                showDisconnections = (bool)Config[conf_ShowDisConn];
            else
            {
                missing = true;
                Config[conf_ShowDisConn] = showDisconnections;
            }

            if (missing)
            {
                Config.Save();
                PrintWarning("Updated the config file.");
            }
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (!showConnections)
                return;

            if(player.IsAdmin())
                rust.BroadcastChat(string.Format(joinFormat, player.displayName, adminColour),null,player.UserIDString);
            else if (!onlyShowAdmins)
                rust.BroadcastChat(string.Format(joinFormat, player.displayName, userColour), null, player.UserIDString);
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!showDisconnections)
                return;

            if(player.IsAdmin())
                rust.BroadcastChat(string.Format(quitFormat, player.displayName, adminColour, reason), null, player.UserIDString);
            else if (!onlyShowAdmins)
                rust.BroadcastChat(string.Format(quitFormat, player.displayName, userColour, reason), null, player.UserIDString);

        }
        /*[ConsoleCommand("msgTest")]
        void Test(ConsoleSystem.Arg arg)
        {
            OnPlayerDisconnected(arg.Player(), "Testing");
            OnPlayerInit(arg.Player());
        }*/
    }
}

// --- End of file: JoinQuitMsg.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiFoundationStack.cs ---
// --- Original Local Path: AntiFoundationStack.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AntiFoundationStack", "Jake_Rich", 0.1)]
    [Description("Prevents foundation stacking")]

    public class AntiFoundationStack : RustPlugin
    {

        #region Localization

        void Init()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BlockMessage"] = "<color=Orange>Anti-Foundation Stacking:</color> Overlap Detected.",
            }, this);
            
        }

        #endregion

        #region AntiStack

        #region Config Values
        Dictionary<string, double> foundationWidth = new Dictionary<string, double>
        {
            {"foundation", 1.5d},
            //{"foundation.triangle", 1d},
        };

        #endregion

        int copyLayer = LayerMask.GetMask("Construction");

        void OnEntityBuilt(Planner plan, GameObject go)
        {

            BaseEntity entity = go.ToBaseEntity();

            if (entity == null)
            {
                return;
            }

            if (!foundationWidth.ContainsKey(entity.ShortPrefabName))
            {
                return;
            }

            double localEntityWidth = foundationWidth[entity.ShortPrefabName];

            List<BaseEntity> list = new List<BaseEntity>();

            Vis.Entities(entity.transform.position, 3f, list, copyLayer, QueryTriggerInteraction.Ignore);
            foreach (BaseEntity targetEntity in list)
            {
                if (targetEntity == entity || !foundationWidth.ContainsKey(targetEntity.ShortPrefabName))
                {
                    continue;
                }

                float localDistance = Vector3.Distance(targetEntity.CenterPoint(),entity.CenterPoint());
                double targetEntityWidth = foundationWidth[targetEntity.ShortPrefabName];

                if (localDistance + 0.05d < localEntityWidth + targetEntityWidth) //Accounts for floating point errors
                { 
                    entity.Kill();
                    if (plan.GetOwnerPlayer() != null)
                    {
                        PrintToChat(plan.GetOwnerPlayer(), lang.GetMessage("BlockMessage",this));
                    }
                    return;
                }
            }
        }

        #endregion

    }
}




// --- End of file: AntiFoundationStack.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagixLogo-1.0.0.cs ---
// --- Original Local Path: MagixLogo-1.0.0.cs ---

﻿using System.Reflection.Metadata;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using Oxide.Core;
using UnityEngine.UIElements;

namespace Oxide.Plugins
{
    [Info("MagixLogo", "Frizen", "1.0.0")]

    public class MagixLogo : RustPlugin
    {
        #region Vars
        [PluginReference] private Plugin ImageLibrary, EventRandomizer, NoEscape, FreeOnline, MagixNotify;
        private Dictionary<BasePlayer, bool> _menuOpen = new Dictionary<BasePlayer, bool>();
        public static System.Random Random = new System.Random();
        private float randomhashed = 0;
        private const string _menuLayer = "Magix.Menu";
        private bool _isCargoShip = false;
        private bool _isBradley = false;
        private bool _isCh47 = false;
        private bool _isHeli = false;
        private const float fadeout = 0.25f;
        private const float fadein = 1f;
        #endregion

        #region Config
        private static Configuration _config;
        public class Configuration
        {

            [JsonProperty("Цвет активного ивента Bradley")]
            public string BradleyColor = "#FF6C0AFF";
            [JsonProperty("Цвет активного ивента Ch47")]
            public string Ch47Color = "#FF6C0AFF";
            [JsonProperty("Цвет активного ивента Heli")]
            public string HeliColor = "#FF6C0AFF";
            [JsonProperty("Время уведомления рейдблока в секундах")]
            public float NotifyTime = 5f;
            [JsonProperty("Цвет активного ивента Cargo")]
            public string CargoColor = "#FF6C0AFF";
            [JsonProperty("Список команд в выпадающем меню")]
            public Dictionary<string, string> MenuCmds = new Dictionary<string, string>();
            [JsonProperty("Картинки")]
            public Dictionary<string, string> Imgs = new Dictionary<string, string>();
            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    NotifyTime = 5f,
                    BradleyColor = "#FF6C0AFF",
                    Ch47Color = "#FF6C0AFF",
                    HeliColor = "#FF6C0AFF",
                    CargoColor = "#FF6C0AFF",
                    MenuCmds =
                    {
                        ["https://i.imgur.com/RKbohaU.png"] = "chat.say /report",
                        ["https://i.imgur.com/aAhH5iW.png"] = "chat.say /block",
                        ["https://i.imgur.com/HYoXoOu.png"] = "chat.say /friends",
                        ["https://i.imgur.com/PDvATmn.png"] = "chat.say /tasks"
                    },
                    Imgs =
                    {
                        ["Store"] = "https://i.imgur.com/RLMIvK6.png",
                        ["People"] = "https://i.imgur.com/4UivNDU.png",
                        ["Heli"] = "https://i.imgur.com/VupbypK.png",
                        ["CH47"] = "https://i.imgur.com/bAxVttR.png",
                        ["Bradley"] = "https://i.imgur.com/Yr9L8md.png",
                        ["Cargo"] = "https://i.imgur.com/2WcJOIO.png",
                        ["Menu"] = "https://i.imgur.com/naNbo7w.png",
                        ["RaidBlock"] = "https://i.imgur.com/hM8nGlJ.png",
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            GetOnline();
            FirstCheckEvents();

            timer.Once(15f, () =>
            {
                Interface.Oxide.ReloadPlugin("EventRandomizer");
            });

            foreach (var img in _config.Imgs)
            {
                ImageLibrary.Call("AddImage", img.Value, img.Key);
            }

            foreach (var img in _config.MenuCmds)
            {
                ImageLibrary.Call("AddImage", img.Key, img.Value);
            }

            foreach (var item in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(item);
            }
        }

        float GetOnline()
        {
            if (FreeOnline) randomhashed = FreeOnline.Call<int>("GetOnline");
            else randomhashed = BasePlayer.activePlayerList.Count;
            
            return randomhashed;
        }

        void OnPlayerSleep(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "CH47");
            CuiHelper.DestroyUi(player, "CH47BTN");
            CuiHelper.DestroyUi(player, "Heli");
            CuiHelper.DestroyUi(player, "HeliBTN");
            CuiHelper.DestroyUi(player, "Cargo");
            CuiHelper.DestroyUi(player, "CargoBTN");
            CuiHelper.DestroyUi(player, "Bradley");
            CuiHelper.DestroyUi(player, "BradleyBTN");
            CuiHelper.DestroyUi(player, "People");
            CuiHelper.DestroyUi(player, "MenuIMG");
            CuiHelper.DestroyUi(player, "MenuBTN");
            CuiHelper.DestroyUi(player, "StoreIMG");
            CuiHelper.DestroyUi(player, "StoreBTN");
            CuiHelper.DestroyUi(player, "Online");
            DestroyButtons(player);
            CuiHelper.DestroyUi(player, "LeftPanelLogo");
            CuiHelper.DestroyUi(player, _menuLayer);

        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            DrawMenu(player);
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            if (!_menuOpen.ContainsKey(player))
            {
                _menuOpen.Add(player, true);
            }

            DrawMenu(player);

            timer.Once(1f, () =>
            {
                foreach (var players in BasePlayer.activePlayerList)
                {
                    if (players.userID == player.userID) continue;
                    bool IsOpen = false;
                    if (_menuOpen.TryGetValue(players, out IsOpen) && IsOpen)
                    {
                        OnlineUi(players);
                    }
                }
            });
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            timer.Once(1f, () =>
            {
                foreach (var players in BasePlayer.activePlayerList)
                {
                    bool IsOpen = false;
                    if (_menuOpen.TryGetValue(players, out IsOpen) && IsOpen)
                    {
                        OnlineUi(players);
                    }
                }
            });
        }


        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;
            if (entity is CH47Helicopter)
            {
                _isCh47 = true;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "CH47");
                }
                return;
            }
            if (entity is BaseHelicopter)
            {
                _isHeli = true;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Heli");
                }
                return;
            }
            if (entity is CargoShip)
            {
                _isCargoShip = true;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Cargo");
                }
                return;
            }
            if (entity is BradleyAPC)
            {
                _isBradley = true;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Bradley");
                }
                return;
            }
          
        }

        void OnEntityKill(BaseEntity entity)
        {
            if (entity == null) return;
            if (entity is CH47Helicopter)
            {
                _isCh47 = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "CH47");
                }
                return;
            }
            if (entity is BaseHelicopter)
            {
                _isHeli = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Heli");
                }
                return;
            }
            if (entity is CargoShip)
            {
                _isCargoShip = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Cargo");
                }
                return;
            }
            if (entity is BradleyAPC)
            {
                _isBradley = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Bradley");
                }
                return;
            }
            
        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (entity == null) return;
            if (entity is CH47Helicopter)
            {
                _isCh47 = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "CH47");
                }
                return;
            }
            if (entity is BaseHelicopter)
            {
                _isHeli = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Heli");
                }
                return;
            }
            if (entity is CargoShip)
            {
                _isCargoShip = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Cargo");
                }
                return;
            }
            if (entity is BradleyAPC)
            {
                _isBradley = false;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    RefreshEvents(player, "Bradley");
                }
                return;
            }
           
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "CH47");
                CuiHelper.DestroyUi(player, "CH47BTN");
                CuiHelper.DestroyUi(player, "Heli");
                CuiHelper.DestroyUi(player, "HeliBTN");
                CuiHelper.DestroyUi(player, "Cargo");
                CuiHelper.DestroyUi(player, "CargoBTN");
                CuiHelper.DestroyUi(player, "Bradley");
                CuiHelper.DestroyUi(player, "BradleyBTN");
                CuiHelper.DestroyUi(player, "People");
                CuiHelper.DestroyUi(player, "MenuIMG");
                CuiHelper.DestroyUi(player, "MenuBTN");
                CuiHelper.DestroyUi(player, "StoreIMG");
                CuiHelper.DestroyUi(player, "StoreBTN");
                CuiHelper.DestroyUi(player, "Online");
                DestroyButtons(player);
                CuiHelper.DestroyUi(player, _menuLayer);
                CuiHelper.DestroyUi(player, "LeftPanelLogo");

            }
        }

        #endregion

        #region Methods
        private void FirstCheckEvents()
        {

            foreach (var entity in BaseEntity.serverEntities)
            {
                if (entity as CargoShip)
                {
                    _isCargoShip = true;
                }
                if (entity as BradleyAPC)
                {
                    _isBradley = true;
                }
                if (entity as CH47Helicopter)
                {
                    _isCh47 = true;
                }
                if (entity as BaseHelicopter)
                {
                    _isHeli = true;
                }
            }
           
        }



        private void DrawMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "CH47");
            CuiHelper.DestroyUi(player, "CH47BTN");
            CuiHelper.DestroyUi(player, "Heli");
            CuiHelper.DestroyUi(player, "HeliBTN");
            CuiHelper.DestroyUi(player, "Cargo");
            CuiHelper.DestroyUi(player, "CargoBTN");
            CuiHelper.DestroyUi(player, "Bradley");
            CuiHelper.DestroyUi(player, "BradleyBTN");
            CuiHelper.DestroyUi(player, "People");
            CuiHelper.DestroyUi(player, "MenuIMG");
            CuiHelper.DestroyUi(player, "MenuBTN");
            CuiHelper.DestroyUi(player, "StoreIMG");
            CuiHelper.DestroyUi(player, "StoreBTN");
            CuiHelper.DestroyUi(player, "Online");
            DestroyButtons(player);
            CuiHelper.DestroyUi(player, _menuLayer);
            CuiHelper.DestroyUi(player, "LeftPanelLogo");


            container.Add(new CuiPanel
            {
                FadeOut = fadeout,
                Image = { Color = $"0 0 0 0", FadeIn = fadein},
                RectTransform = { AnchorMin = $"0.006249996 0.9546296", AnchorMax = $"0.1734375 0.9981481" }
            }, "Overlay", $"LeftPanelLogo");

            container.Add(new CuiPanel
            {
                FadeOut = fadeout,
                Image = { Color = $"0 0 0 0", FadeIn = fadein},
                RectTransform = { AnchorMin = $"0.8322843 0.9546296", AnchorMax = $"0.9994677 0.9981481" }
            }, "Overlay", _menuLayer);


            container.Add(new CuiButton
            {
                FadeOut = fadeout,
                RectTransform =
                        {
                            AnchorMin = $"4.423782E-09 0.1489384",
                            AnchorMax = $"0.09968854 0.8297893"
                        },
                Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"chat.say /store",
                        },
                Text =
                        {
                            Text = ""
                        }
            }, "LeftPanelLogo", $"StoreBTN");

            container.Add(new CuiElement
            {
                Name = "StoreIMG",
                Parent = $"StoreBTN",
                FadeOut = fadeout,
                Components =
                        {
                            new CuiRawImageComponent{Color = "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "Store"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0 0", AnchorMax = "1 1"}
                        }
            });

            container.Add(new CuiButton
            {
                FadeOut = fadeout,
                RectTransform =
                        {
                            AnchorMin = $"0.8664309 0.1489384",
                            AnchorMax = $"0.9661204 0.8297893"
                        },
                Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.logo",
                        },
                Text =
                        {
                            Text = ""
                        }
            }, _menuLayer, $"MenuBTN");

            container.Add(new CuiElement
            {
                Name = "MenuIMG",
                Parent = $"MenuBTN",
                FadeOut = fadeout,
                Components =
                        {
                            new CuiRawImageComponent{Color = "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "Menu"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0 0", AnchorMax = "1 1"}
                        }
            });

            container.Add(new CuiElement
            {
                Name = "People",
                Parent = $"LeftPanelLogo",
                FadeOut = fadeout,
                Components =
                        {
                            new CuiRawImageComponent{Color = "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "People"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.1214953 0.1489384", AnchorMax = "0.2211839 0.82979"}
                        }
            });

            bool IsOpen = false;
            _menuOpen.TryGetValue(player, out IsOpen);
            CuiHelper.AddUi(player, container);

            if (IsOpen)
            {
                RefreshEvents(player, "All");
                OnlineUi(player);
                ButtonUi(player);
            }
            if (player == null) return;
            if(NoEscape != null)
            {
                if (NoEscape.Call<bool>("IsBlocked", player))
                {
                    RaidBlockUi(player, NoEscape.Call<double>("NoEscape_Time", player));
                }
            }

        }

        private void DestroyButtons(BasePlayer player)
        {
            foreach (var x in _config.MenuCmds)
            {
                CuiHelper.DestroyUi(player, _menuLayer + x.Value);
                CuiHelper.DestroyUi(player, _menuLayer + x.Value + "IMG");
            }
        }

        private void ButtonUi(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

            DestroyButtons(player);

            double anchormin = 0.7418166, anchormax = 0.8415062, margin = 0.8415062 - 0.7106612;
            foreach (var x in _config.MenuCmds)
            {
                container.Add(new CuiButton
                {
                    FadeOut = fadeout,
                    RectTransform =
                        {
                            AnchorMin = $"{anchormin} 0.1489384",
                            AnchorMax = $"{anchormax} 0.8297893"
                        },
                    Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"{x.Value}",
                        },
                    Text =
                        {
                            Text = ""
                        }
                }, _menuLayer, _menuLayer + x.Value);

                container.Add(new CuiElement
                {
                    Name = _menuLayer + x.Value + "IMG",
                    Parent = _menuLayer + x.Value,
                    FadeOut = fadeout,
                    Components =
                        {
                            new CuiRawImageComponent{Color = "1 1 1 0.7", Png = ImageLibrary?.Call<string>("GetImage", x.Value),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0 0", AnchorMax = "1 1"}
                        }
                });

                anchormin -= margin;
                anchormax -= margin;
            }

            CuiHelper.AddUi(player, container);
        }

        private void OnlineUi(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

            CuiHelper.DestroyUi(player, "Online");
            bool IsOpen = false;
            _menuOpen.TryGetValue(player, out IsOpen);
            if (IsOpen)
            {
                container.Add(new CuiElement
                {
                    Parent = $"LeftPanelLogo",
                    Name = "Online",
                    FadeOut = fadeout,
                    Components =
                            {
                                new CuiTextComponent{Color = $"{HexToRustFormat("#E8E2D9E5")}", Text = $"{GetOnline()}/{ConVar.Server.maxplayers}", Align = TextAnchor.MiddleCenter, FontSize = 13, Font = "robotocondensed-bold.ttf", FadeIn = fadein},
                                new CuiRectTransformComponent{AnchorMin = "0.2545756 0.2415287", AnchorMax = "0.4695288 0.6883376"}
                            }
                });

            }


            CuiHelper.AddUi(player, container);
        }


        private void SendNotify(BasePlayer player, string message, int show = 5, string type = "Event")
        {
            if (MagixNotify != null)
                MagixNotify?.Call("SendNotify", player, type, message, show);
            else
                SendReply(player, message);
        }

        private void RefreshEvents(BasePlayer player, string events)
        {
            CuiElementContainer container = new CuiElementContainer();

            bool IsOpen = false;
            _menuOpen.TryGetValue(player, out IsOpen);
            if (!IsOpen) return;

            switch (events)
            {
                case "All":
                    CuiHelper.DestroyUi(player, "CH47");
                    CuiHelper.DestroyUi(player, "CH47BTN");
                    CuiHelper.DestroyUi(player, "Heli");
                    CuiHelper.DestroyUi(player, "HeliBTN");
                    CuiHelper.DestroyUi(player, "Cargo");
                    CuiHelper.DestroyUi(player, "CargoBTN");
                    CuiHelper.DestroyUi(player, "Bradley");
                    CuiHelper.DestroyUi(player, "BradleyBTN");


                    container.Add(new CuiElement
                    {
                        Name = "CH47",
                        Parent = $"LeftPanelLogo",
                        FadeOut = fadeout,
                        Components =
                        {
                            new CuiRawImageComponent{Color = _isCh47 ? $"{HexToRustFormat(_config.Ch47Color)}" : "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "CH47"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.632399 0.1489384", AnchorMax = "0.7320886 0.82979"}
                        }
                    });

                    container.Add(new CuiButton
                    {
                        FadeOut = fadeout,
                        RectTransform =
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                        Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.info CH47",
                        },
                        Text =
                        {
                            Text = ""
                        }
                    }, "CH47", $"CH47BTN");

                    container.Add(new CuiElement
                    {
                        Name = "Heli",
                        Parent = $"LeftPanelLogo",
                        FadeOut = fadeout,
                        Components =
                        {
                            new CuiRawImageComponent{Color = _isHeli ? $"{HexToRustFormat(_config.HeliColor)}" : "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "Heli"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.5077883 0.1489384", AnchorMax = "0.6074779 0.82979"}
                        }
                    });


                    container.Add(new CuiButton
                    {
                        FadeOut = fadeout,
                        RectTransform =
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                        Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.info Heli",
                        },
                        Text =
                        {
                            Text = ""
                        }
                    }, "Heli", $"HeliBTN");

                    container.Add(new CuiElement
                    {
                        Name = "Cargo",
                        Parent = $"LeftPanelLogo",
                        FadeOut = fadeout,
                        Components =
                        {
                            new CuiRawImageComponent{Color = _isCargoShip ? $"{HexToRustFormat(_config.CargoColor)}" : "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "Cargo"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.8820077 0.1489384", AnchorMax = "0.9816972 0.82979"}
                        }
                    });


                    container.Add(new CuiButton
                    {
                        FadeOut = fadeout,
                        RectTransform =
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                        Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.info Cargo",
                        },
                        Text =
                        {
                            Text = ""
                        }
                    }, "Cargo", $"CargoBTN");

                    container.Add(new CuiElement
                    {
                        Name = "Bradley",
                        Parent = $"LeftPanelLogo",
                        FadeOut = fadeout,
                        Components =
                        {
                            new CuiRawImageComponent{Color = _isBradley ? $"{HexToRustFormat(_config.BradleyColor)}" : "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "Bradley"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.7573982 0.1489384", AnchorMax = "0.8570878 0.82979"}
                        }
                    });


                    container.Add(new CuiButton
                    {
                        FadeOut = fadeout,
                        RectTransform =
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                        Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.info Bradley",
                        },
                        Text =
                        {
                            Text = ""
                        }
                    }, "Bradley", $"BradleyBTN");



                    break;
                case "CH47":
                    CuiHelper.DestroyUi(player, "CH47");
                    CuiHelper.DestroyUi(player, "CH47BTN");

                    container.Add(new CuiElement
                    {
                        Name = "CH47",
                        Parent = $"LeftPanelLogo",
                        FadeOut = fadeout,
                        Components =
                        {
                            new CuiRawImageComponent{Color = _isCh47 ? $"{HexToRustFormat(_config.Ch47Color)}" : "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "CH47"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.632399 0.1489384", AnchorMax = "0.7320886 0.82979"}
                        }
                    });

                    container.Add(new CuiButton
                    {
                        FadeOut = fadeout,
                        RectTransform =
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                        Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.info CH47",
                        },
                        Text =
                        {
                            Text = ""
                        }
                    }, "CH47", $"CH47BTN");

                    break;
                case "Heli":
                    CuiHelper.DestroyUi(player, "Heli");
                    CuiHelper.DestroyUi(player, "HeliBTN");

                    container.Add(new CuiElement
                    {
                        Name = "Heli",
                        Parent = $"LeftPanelLogo",
                        FadeOut = fadeout,
                        Components =
                        {
                            new CuiRawImageComponent{Color = _isHeli ? $"{HexToRustFormat(_config.HeliColor)}" : "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "Heli"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.5077883 0.1489384", AnchorMax = "0.6074779 0.82979"}
                        }
                    });


                    container.Add(new CuiButton
                    {
                        FadeOut = fadeout,
                        RectTransform =
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                        Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.info Heli",
                        },
                        Text =
                        {
                            Text = ""
                        }
                    }, "Heli", $"HeliBTN");
                    break;
                case "Cargo":
                    CuiHelper.DestroyUi(player, "Cargo");
                    CuiHelper.DestroyUi(player, "CargoBTN");

                    container.Add(new CuiElement
                    {
                        Name = "Cargo",
                        Parent = $"LeftPanelLogo",
                        FadeOut = fadeout,
                        Components =
                        {
                            new CuiRawImageComponent{Color = _isCargoShip ? $"{HexToRustFormat(_config.CargoColor)}" : "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "Cargo"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.8820077 0.1489384", AnchorMax = "0.9816972 0.82979"}
                        }
                    });


                    container.Add(new CuiButton
                    {
                        FadeOut = fadeout,
                        RectTransform =
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                        Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.info Cargo",
                        },
                        Text =
                        {
                            Text = ""
                        }
                    }, "Cargo", $"CargoBTN");

                    break;
                case "Bradley":
                    CuiHelper.DestroyUi(player, "Bradley");
                    CuiHelper.DestroyUi(player, "BradleyBTN");

                    container.Add(new CuiElement
                    {
                        Name = "Bradley",
                        Parent = $"LeftPanelLogo",
                        FadeOut = fadeout,
                        Components =
                        {
                            new CuiRawImageComponent{Color = _isBradley ? $"{HexToRustFormat(_config.BradleyColor)}" : "1 1 1 0.7", Png = ImageLibrary.Call<string>("GetImage", "Bradley"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.7573982 0.1489384", AnchorMax = "0.8570878 0.82979" }
                        }
                    });


                    container.Add(new CuiButton
                    {
                        FadeOut = fadeout,
                        RectTransform =
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        },
                        Button =
                        {
                            FadeIn = fadein,
                            Color = "0 0 0 0",
                            Command = $"magix.info Bradley",
                        },
                        Text =
                        {
                            Text = ""
                        }
                    }, "Bradley", $"BradleyBTN");

                    break;
            }

            CuiHelper.AddUi(player, container);
        }


        [HookMethod("RaidBlockMagix")]
        public void RaidBlockUi(BasePlayer player, double time)
        {
            bool IsOpen = false;
            CuiElementContainer container = new CuiElementContainer();

            CuiHelper.DestroyUi(player, "RB");
            CuiHelper.DestroyUi(player, "RBText");


            if (_menuOpen.TryGetValue(player, out IsOpen) && IsOpen)
            {
                container.Add(new CuiElement
                {
                    Name = "RB",
                    Parent = $"LeftPanelLogo",
                    FadeOut = fadeout,
                    Components =
                        {
                            new CuiRawImageComponent{Color = $"{HexToRustFormat("#C34D4D")}", Png = ImageLibrary.Call<string>("GetImage", "RaidBlock"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "1.003507 0.1489384", AnchorMax = "1.103196 0.82979"}
                        }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Name = "RB",
                    Parent = $"LeftPanelLogo",
                    FadeOut = fadeout,
                    Components =
                        {
                            new CuiRawImageComponent{Color = $"{HexToRustFormat("#C34D4D")}", Png = ImageLibrary.Call<string>("GetImage", "RaidBlock"),  FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0.2429907 0.1489384", AnchorMax = "0.3426793 0.82979"}
                        }
                });
            }

            container.Add(new CuiElement
            {
                Parent = $"RB",
                Name = "RBText",
                FadeOut = fadeout,
                Components =
                        {
                            new CuiTextComponent{Color = $"1 1 1 0.7", Text = $"{GetFormatTime(TimeSpan.FromSeconds(time))}", Align = TextAnchor.MiddleCenter, FontSize = 8, Font = "robotocondensed-bold.ttf", FadeIn = fadein},
                            new CuiRectTransformComponent{AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "25 0", OffsetMax = "45 20"}
                        }
            });


            CuiHelper.AddUi(player, container);

        }



        [HookMethod("IsOpen")]
        public bool IsOpened(BasePlayer player)
        {
            bool isOpen = false;
            _menuOpen.TryGetValue(player, out isOpen);
            return isOpen;
        }

        #endregion

        #region Helpers
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        [ConsoleCommand("magix.logo")]
        private void MenuHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;
            if (!_menuOpen.ContainsKey(player)) _menuOpen.Add(player, false);

            if (!_menuOpen[player])
            {
                _menuOpen[player] = true;
                DrawMenu(player);
                return;
            }
            if (_menuOpen[player])
            {
                _menuOpen[player] = false;
                DrawMenu(player);
                return;
            }
        }

        [ConsoleCommand("magix.info")]
        private void InfoHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;

            var text = string.Empty;
            switch (args.Args[0])
            {
                case "CH47":
                    if (_isCh47)
                    {
                        text = "Статус ивента:\nАктивен";
                    }
                    else
                    {
                        text = $"Ивент <color=#55C4E7>''ЧИНУК''</color> начнётся через:\n<color=#55C4E7>{EventRandomizer?.Call<string>("Ch47Time")}</color>";
                    }
                    SendNotify(player, text);
                    break;
                case "Heli":
                    if (_isHeli)
                    {
                        text = "Статус ивента:\nАктивен";
                    }
                    else
                    {
                        text = $"Ивент <color=#55C4E7>''ВЕРТОЛЁТ''</color> начнётся через:\n<color=#55C4E7>{EventRandomizer?.Call<string>("HeliTime")}</color>";
                    }
                    SendNotify(player, text);
                    break;
                case "Bradley":
                    if (_isBradley)
                    {
                        text = "Статус ивента:\nАктивен";
                    }
                    else
                    {
                        text = $"Ивент <color=#55C4E7>''ТАНК''</color> начнётся через:\n<color=#55C4E7>{EventRandomizer?.Call<string>("BradleyTime")}</color>";
                    }
                    SendNotify(player, text);
                    break;
                case "Cargo":
                    if (_isCargoShip)
                    {
                        text = "Статус ивента:\nАктивен";
                    }
                    else
                    {
                        text = $"Ивент <color=#55C4E7>''КАРГО''</color> начнётся через:\n<color=#55C4E7>{EventRandomizer?.Call<string>("CargoTime")}</color>";
                    }
                    SendNotify(player, text);
                    break;
            }


        }

        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

        #endregion
    }

}

// --- End of file: MagixLogo-1.0.0.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagicCraft.cs ---
// --- Original Local Path: MagicCraft.cs ---

// Reference: Rust.Workshop
using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using Oxide.Core;
using Oxide.Core.Plugins;
namespace Oxide.Plugins
{
    [Info("MagicCraft", "Norn", "0.2.7", ResourceId = 1347)]
    [Description("An alternative crafting system.")]
    public class MagicCraft : RustPlugin
    {
        int MaxB = 999;
        int MinB = 1;
        int MAX_INV_SLOTS = 30;
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        [PluginReference]
        Plugin PopupNotifications;
        class StoredData
        {
            public Dictionary<string, CraftInfo> CraftList = new Dictionary<string, CraftInfo>();
            public StoredData()
            {
            }
        }
        class CraftInfo
        {
            public int MaxBulkCraft;
            public int MinBulkCraft;
            public string displayName;
            public string shortName;
            public string description;
            public bool Enabled;
            public CraftInfo()
            {
            }
        }
        StoredData storedData;
        private void ConfigurationCheck()
        {
            try { if (Config.Count() == 0) LoadDefaultConfig(); } catch { Puts("Configuration file seems to be unreadable... Re-generating."); LoadDefaultConfig(); }
        }
        void Loaded()
        {
            permission.RegisterPermission("MagicCraft.able", this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CraftSuccess"] = "You have crafted <color=#66FF66>{0}</color> <color=#66FFFF>{1}</color>\n[Batch Amount: <color=#66FF66>{2}</color>]",
                ["DifferentSlots"] = "You <color=yellow>only</color> have <color=green>{0}</color> slots left, crafting <color=green>{1}</color> / <color=red>{2}</color> requested.",
                ["InventoryFull"] = "Your <color=yellow>inventory</color> is <color=red>full</color>!",
                ["InventoryFullBypass"] = "Magic Craft has been <color=red>bypassed</color> because your <color=yellow>inventory</color> is <color=red>full</color>!",
                ["InventoryFullBypassStack"] = "Magic Craft has been <color=red>bypassed</color>!\nYou need <color=red>{0}</color> inventory slots free to craft <color=yellow>{1} {2}</color>.",
                ["CooldownEnabled"] = "Magic Craft has been <color=red>bypassed</color> because you're crafting <color=red>too fast</color>!"
            }, this);
        }
        private void OnServerInitialized()
        {
            storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
            ConfigurationCheck();
            int config_protocol = Convert.ToInt32(Config["Internal", "Protocol"]);
            if (Config["Messages", "ItemFailed"] == null) { Puts("Updating configuration..."); LoadDefaultConfig(); }
            if (Config["Internal", "Protocol"] == null) { Config["Internal", "Protocol"] = Protocol.network; }
            else if (Convert.ToInt32(Config["Internal", "Protocol"]) != Protocol.network && !Convert.ToBoolean(Config["Settings", "IgnoreProtocolChanges"]))
            {
                Config["Internal", "Protocol"] = Protocol.network;
                Puts("Updating item list from protocol " + config_protocol.ToString() + " to protocol " + Config["Internal", "Protocol"].ToString() + ".");
                GenerateItems(true);
                SaveConfig();
            }
            else
            {
                GenerateItems(false);
            }
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Generating Magic Craft configuration...");
            Config.Clear();
            // --- [ INTERNAL CONFIG ] ---
            Config["Internal", "Protocol"] = Protocol.network;
            // --- [ SETTINGS ] ---
            Config["Settings", "IgnoreProtocolChanges"] = false;
            Config["Settings", "BypassInvFull"] = true;
            // --- [ COOLDOWN ] ---
            Config["Cooldown", "Enabled"] = true;
            Config["Cooldown", "Timer"] = 6;
            Config["Cooldown", "Trigger"] = 499;
            // --- [ Dependencies ] ---
            Config["Dependencies", "PopupNotifications"] = false;
            // --- [ Messages ] ---
            Config["Messages", "Enabled"] = true;
            Config["Messages", "ItemCrafted"] = false;
            Config["Messages", "ItemFailed"] = true;
            timer.Once(10, () => GenerateItems(true));
            SaveConfig();
        }

        void GenerateItems(bool reset = false)
        {
            if (reset)
            {
                Interface.GetMod().DataFileSystem.WriteObject(this.Title + ".old", storedData);
                storedData.CraftList.Clear();
                Puts("Generating new item list...");
            }
            mcITEMS = ItemManager.itemList.ToDictionary(i => i.shortname);
            int loaded = 0, enabled = 0;
            foreach (var definition in mcITEMS)
            {
                if (definition.Value.shortname.Length >= 1)
                {
                    CraftInfo p = null;
                    if (storedData.CraftList.TryGetValue(definition.Value.shortname, out p))
                    {
                        if (p.Enabled) { enabled++; }
                        loaded++;
                    }
                    else
                    {
                        CraftInfo z = new CraftInfo();
                        z.description = definition.Value.displayDescription.english.ToString();
                        z.displayName = definition.Value.displayName.english.ToString();
                        z.shortName = definition.Value.shortname.ToString();
                        z.MaxBulkCraft = MaxB;
                        z.MinBulkCraft = MinB;
                        z.Enabled = false;
                        storedData.CraftList.Add(definition.Value.shortname.ToString(), z);
                        loaded++;
                    }
                }
            }
            int inactive = loaded - enabled;
            Puts("Loaded " + loaded.ToString() + " items. (Enabled: " + enabled.ToString() + " | Inactive: " + inactive.ToString() + ").");
            Interface.GetMod().DataFileSystem.WriteObject(this.Title, storedData);
        }
        public static Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        public int InventorySlots(BasePlayer player, bool incwear = true, bool incbelt = true)
        {
            List<Item> list = new List<Item>();
            list.AddRange(player.inventory.containerMain.itemList);                     // 24
            if (incbelt) { list.AddRange(player.inventory.containerBelt.itemList); }    // 6
            if (incwear) { list.AddRange(player.inventory.containerWear.itemList); }    // 6
            return list.Count;
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (BulkCraftCooldown.ContainsKey(player)) { BulkCraftCooldown.Remove(player); }
        }
        List<string> ExcludeList = new List<string>()
        {
            {
                "door.key"
            },
        };
        public int FreeInventorySlots(BasePlayer player, bool incwear = true, bool incbelt = true) { return MAX_INV_SLOTS - InventorySlots(player, false, true); }
        private Dictionary<string, ItemDefinition> mcITEMS;
        private Dictionary<BasePlayer, Int32> BulkCraftCooldown = new Dictionary<BasePlayer, Int32>();

        private object OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        {
            if (permission.UserHasPermission(crafter.net.connection.userid.ToString(), "MagicCraft.able"))
            {
                var itemname = task.blueprint.targetItem.shortname.ToString();
                foreach (var entry in storedData.CraftList)
                {
                    if (entry.Value.shortName == itemname && entry.Value.Enabled && !ExcludeList.Contains(itemname))
                    {
                        if (Convert.ToBoolean(Config["Settings", "BypassInvFull"]) && InventorySlots(crafter, false, true) >= MAX_INV_SLOTS)
                        {
                            if (Convert.ToBoolean(Config["Messages", "Enabled"]) && Convert.ToBoolean(Config["Messages", "ItemFailed"])) { PrintToChatEx(crafter, Lang("InventoryFullBypass", crafter.UserIDString)); }
                            return null;
                        }
                        if (Convert.ToBoolean(Config["Cooldown", "Enabled"]))
                        {
                            if (task.amount >= Convert.ToInt32(Config["Cooldown", "Trigger"]))
                            {
                                if (!BulkCraftCooldown.ContainsKey(crafter))
                                {
                                    BulkCraftCooldown.Add(crafter, UnixTimeStampUTC());
                                }
                                else
                                {
                                    if (UnixTimeStampUTC() - BulkCraftCooldown[crafter] >= Convert.ToInt32(Config["Cooldown", "Timer"]))
                                    {
                                        BulkCraftCooldown[crafter] = UnixTimeStampUTC();
                                    }
                                    else
                                    {
                                        if (Convert.ToBoolean(Config["Messages", "Enabled"]) && Convert.ToBoolean(Config["Messages", "ItemFailed"])) { PrintToChatEx(crafter, Lang("CooldownEnabled", crafter.UserIDString)); }
                                        return null;
                                    }
                                }
                            }
                        }
                        int amount = task.amount;
                        if (amount < entry.Value.MinBulkCraft || amount > entry.Value.MaxBulkCraft) { return null; }
                        ItemDefinition item = GetItem(itemname);
                        int final_amount = task.blueprint.amountToCreate * amount;
                        var results = CalculateStacks(final_amount, item);
                            if (results.Count() > 1)
                            {
                                if (Convert.ToBoolean(Config["Settings", "BypassInvFull"]) && InventorySlots(crafter, false, true) + results.Count() >= MAX_INV_SLOTS) { if (Convert.ToBoolean(Config["Messages", "Enabled"]) && Convert.ToBoolean(Config["Messages", "ItemFailed"])) { PrintToChatEx(crafter, Lang("InventoryFullBypassStack", crafter.UserIDString, results.Count(), final_amount.ToString(), item.displayName.english)); } return null; }
                                foreach (var stack_amount in results) { SAFEGiveItem(crafter, item.itemid, (ulong)task.skinID, (int)stack_amount); }
                            }
                            else { SAFEGiveItem(crafter, item.itemid, (ulong)task.skinID, final_amount); }
                        if (Convert.ToBoolean(Config["Messages", "Enabled"]) && Convert.ToBoolean(Config["Messages", "ItemCrafted"]))
                        {
                            string returnstring = null;
                            returnstring = Lang("CraftSuccess", crafter.UserIDString, amount.ToString(), item.displayName.english.ToString(), final_amount.ToString());
                            PrintToChatEx(crafter, returnstring);
                        }
                        crafter.Command("note.inv", new object[] { item.itemid, final_amount });
                        return false;
                    }
                }
            }
            return null;
        }
        private IEnumerable<int> CalculateStacks(int amount, ItemDefinition item)
        {
            var results = Enumerable.Repeat(item.stackable, amount / item.stackable); if (amount % item.stackable > 0) { results = results.Concat(Enumerable.Repeat(amount % item.stackable, 1)); }
            return results;
        }
        private bool SAFEGiveItem(BasePlayer player, int itemid, ulong skinid, int amount)
        {
            Item i;
            if (!player.isConnected) return false;
            if (Rust.Workshop.Approved.FindByInventoryId(skinid) != null) { i = ItemManager.CreateByItemID(itemid, amount, Rust.Workshop.Approved.FindByInventoryId(skinid).WorkshopdId); }
            else { i = ItemManager.CreateByItemID(itemid, amount, skinid); }
            if (i != null) if (!i.MoveToContainer(player.inventory.containerMain) && !i.MoveToContainer(player.inventory.containerBelt)) { i.Drop(player.eyes.position, player.eyes.BodyForward() * 2f); }
            return true;
        }
        private void PrintToChatEx(BasePlayer player, string result, string tcolour = "#66FF66")
        {
            if (Convert.ToBoolean(Config["Dependencies", "PopupNotifications"]))
            {
                if (PopupNotifications)
                {
                    PopupNotifications?.Call("CreatePopupNotification", "<color=" + tcolour + ">" + this.Title.ToString() + "</color>\n" + result, player);
                }
                else
                {
                    Puts("Setting Dependencies : PopupNotifications to false because it's missing.");
                    Config["Dependencies", "PopupNotifications"] = false;
                    SaveConfig();
                    PrintToChatEx(player, result, tcolour);
                }
            }
            else { PrintToChat(player, "<color=\"" + tcolour + "\">[" + this.Title.ToString() + "]</color> " + result); }
        }
        private ItemDefinition GetItem(string shortname)
        {
            if (string.IsNullOrEmpty(shortname) || mcITEMS == null) return null;
            ItemDefinition item;
            if (mcITEMS.TryGetValue(shortname, out item)) return item;
            return null;
        }
    }
}

// --- End of file: MagicCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GuessTheNumber.cs ---
// --- Original Local Path: GuessTheNumber.cs ---

using Random=System.Random;
using System;
using Rust.Xp;
using System.Collections.Generic;
using Oxide.Core.Plugins;

namespace Oxide.Plugins {
  
  [Info("Guess The Number", "Dora", "1.2.1", ResourceId = 2023)]
  [Description("Rewards the user with XP when they say the correct number.")]
  
  class GuessTheNumber : RustPlugin {

    Random rng = new Random();
    int number = 0;
    bool hasEconomics = false;
    bool hasServerRewards = false;
    Timer endEventTimer = null;
    Timer autoRepeatTimer = null;

    [PluginReference] Plugin Economics;
    [PluginReference] Plugin ServerRewards;

    public class LimitTries {
      public int attemptedTries = 1;
    }

    public static Dictionary<ulong, LimitTries> playerInfo = new Dictionary<ulong, LimitTries>();

    private void OnServerInitialized() {

      permission.RegisterPermission("GuessTheNumber.startEvent", this);
      LoadVariables();
      LoadDefaultMessages();

      if(configData.autoEventEnabler == true) {
        repeatNumberEvent();
      }

      if(Economics == null) {
        hasEconomics = false;
      } else {
        hasEconomics = true;
      }

      if(ServerRewards == null) {
        hasServerRewards = false;
      } else {
        hasServerRewards = true;
      }

    }

    private void repeatNumberEvent() {
      autoRepeatTimer = timer.Repeat(configData.autoEventInterval, 0, () => GuessNumberEvent(configData.minNumber, configData.maxNumber));
    }

    private void GuessNumberEvent(int minNumber, int maxNumber) {
      if(number == 0) {
        number = rng.Next(minNumber, maxNumber);
        broadcastChat(Lang("pluginPrefix", null), Lang("numberNotice", null, minNumber, (maxNumber - 1)));
        if(configData.autoEndEventEnabler == true) {
          endEventTimer = timer.Once(configData.autoEndEventTimer, () => endEvent());     
        }
      }
    }

    [ChatCommand("startNumber")]
    private void startGuessNumberEvent(BasePlayer player, string cmd, string[] args) {
      int minNumber = 0;
      int maxNumber = 0;

      if(!hasPermission(player, "GuessTheNumber.startEvent")) {
        sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("noPermission", player.UserIDString));
        return;
      }

      if(number != 0) {
        sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("eventStarted", player.UserIDString, number));
        return;
      }

      if(args.Length == 2) {
        Int32.TryParse(args[0], out minNumber);
        Int32.TryParse(args[1], out maxNumber);
        if(minNumber != 0 && maxNumber != 0) {
          number = rng.Next(minNumber, maxNumber);
          broadcastChat(Lang("pluginPrefix", player.UserIDString), Lang("numberNotice", player.UserIDString, minNumber, (maxNumber - 1)));
        } else {
          sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("invalidParam2", player.UserIDString));
          return;
        }
      } else {
        number = rng.Next(configData.minNumber, configData.maxNumber);
        broadcastChat(Lang("pluginPrefix", player.UserIDString), Lang("numberNotice", player.UserIDString, configData.minNumber, (configData.maxNumber - 1)));
      }
 
      sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("winNumber", player.UserIDString, number));
      if(configData.autoEndEventEnabler == true) {
        endEventTimer = timer.Once(configData.autoEndEventTimer, () => endEvent());     
      }
    }

    [ChatCommand("endNumber")]
    private void stopGuessNumberEvent(BasePlayer player) {
      if(!hasPermission(player, "GuessTheNumber.startEvent")) {
        sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("noPermission", player.UserIDString));
        return;
      }

      if(number == 0) {
        sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("eventNotStarted", player.UserIDString));
        return;
      }

      broadcastChat(Lang("pluginPrefix", player.UserIDString), Lang("eventForcedEnd", player.UserIDString, player.displayName, number));
      number = 0;
      playerInfo.Clear();
      if(endEventTimer != null && !endEventTimer.Destroyed) {
        endEventTimer.Destroy();
      }
    }

    [ChatCommand("number")]
    private void numberReply(BasePlayer player, string cmd, string[] args) {
      if(number == 0) {
        sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("eventNotStarted", player.UserIDString));
        return;
      }

      if(args.Length == 1) {
        
        int playerNum;
        Int32.TryParse(args[0], out playerNum);

        if(configData.maxAttemptsEnabler == true) {
          if(playerInfo.ContainsKey(player.userID)) {
            if(playerInfo[player.userID].attemptedTries == configData.maxAttempts) {
              sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("maxAttempts", player.UserIDString));
              return;
            } else {
              playerInfo[player.userID].attemptedTries += 1;
            }    
          } else {
            playerInfo.Add(player.userID, new LimitTries());
          }
        }
        
        if(playerNum == number) {
          
          float xpToGive;
          bool showEconomics = false;
          bool showServerRewards = false;
          bool showXP = false;
          
          if(configData.xpPercentEnabler == true) {
            xpToGive = player.xp.UnspentXp * (float) configData.xpPercentToGive;
          } else {
            xpToGive = configData.xpToGive;
          }
          
          if(configData.xpEnabler == true) {
            player.xp.Add(Definitions.Cheat, xpToGive); 
            showXP = true;
          } 

          if(hasEconomics == true) {
            if(configData.economicsEnabler == true) {
              Economics.CallHook("Deposit", player.userID, configData.economicsWinReward);
              showEconomics = true;
            }
          }

          if(hasServerRewards == true) {
            if(configData.serverRewardsEnabler == true) {
              ServerRewards?.Call("AddPoints", new object[] {player.userID, configData.serverRewardsPoints});
              showServerRewards = true;
            }
          }

          string xpMsg = showXP ? Lang("eventWonExperiences", player.UserIDString, xpToGive) : "";
          string economicsMsg = showEconomics ? Lang("eventWonEconomics", player.UserIDString, configData.economicsWinReward) : "";
          string serverRewardsMsg = showServerRewards ? Lang("eventWonServerRewards", player.UserIDString, configData.serverRewardsPoints) : "";
          broadcastChat(Lang("pluginPrefix", player.UserIDString), Lang("eventWon", player.UserIDString, player.displayName, number) + xpMsg + economicsMsg + serverRewardsMsg);

          number = 0;
          playerInfo.Clear();
          if(endEventTimer != null && !endEventTimer.Destroyed) {
            endEventTimer.Destroy();
          }
        
        } else {
          sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("wrongNumber", player.UserIDString));
        }

      } else {
        sendChatMessage(player, Lang("pluginPrefix", player.UserIDString), Lang("invalidParam", player.UserIDString));
        return;
      }
    }

    private void endEvent() {
      broadcastChat(Lang("pluginPrefix", null), Lang("autoEventEnd", null, number));
      number = 0;
      playerInfo.Clear();
      if(endEventTimer != null && !endEventTimer.Destroyed) {
        endEventTimer.Destroy();
      } 
    }

    private void sendChatMessage(BasePlayer player, string prefix, string msg) {
      SendReply(player, prefix + ": " + msg);
    }

    private void broadcastChat(string prefix, string msg) {
      PrintToChat(prefix + ": " + msg);
    }

    private bool hasPermission(BasePlayer player, string perm) {
      if(player.net.connection.authLevel > 1) {
        return true;
      }
      return permission.UserHasPermission(player.userID.ToString(), perm);
    }

    private ConfigData configData;
    class ConfigData {
      public bool autoEventEnabler { get; set; }
      public int autoEventInterval { get; set; }

      public int minNumber { get; set; }
      public int maxNumber { get; set; }

      public bool xpEnabler { get; set; }
      public bool xpPercentEnabler { get; set; }
      public float xpPercentToGive { get; set; }
      public int xpToGive { get; set; }
      
      public bool economicsEnabler { get; set; }
      public int economicsWinReward { get; set; }
      
      public bool serverRewardsEnabler { get; set; }
      public int serverRewardsPoints { get; set; }

      public bool maxAttemptsEnabler { get; set; }
      public int maxAttempts { get; set; }
      
      public bool autoEndEventEnabler { get; set; }
      public int autoEndEventTimer { get; set; }

    }

    private void LoadVariables() {
      LoadConfigVariables();
      SaveConfig();
    }

    protected override void LoadDefaultConfig() {
      Config.Clear();
      Config["autoEventEnabler"] = true;
      Config["autoEventInterval"] = 1800;

      Config["minNumber"] = 1;
      Config["maxNumber"] = 101;

      Config["xpEnabler"] = true;
      Config["xpPercentEnabler"] = false;
      Config["xpPercentToGive"] = 0.10;
      Config["xpToGive"] = 10;

      Config["economicsEnabler"] = false;
      Config["economicsWinReward"] = 100;

      Config["serverRewardsEnabler"] = false;
      Config["serverRewardsPoints"] = 5;

      Config["maxAttemptsEnabler"] = true;
      Config["maxAttempts"] = 10;

      Config["autoEndEventEnabler"] = true;
      Config["autoEndEventTimer"] = 300;
      SaveConfig();
    }

    void LoadDefaultMessages() {
      lang.RegisterMessages(new Dictionary<string, string> {
        ["pluginPrefix"] = "<color=orange>Guess The Number</color>",
        ["wrongNumber"] = "Ops, that is not the correct number!",
        ["invalidParam"] = "Invalid Parameter - /number <number>",
        ["invalidParam2"] = "Invalid Parameters - /startNumber <minNumber> <maxNumber>",
        ["noPermission"] = "You do not have the permission to use this.",
        ["winNumber"] = "Winning number: <color=orange>{0}</color>",
        ["numberNotice"] = "Event has started, guess a number! ({0} - {1}). Reply using /number <number>",
        ["maxAttempts"] = "You have reached the maximum attempts to guess a number.",
        ["autoEventEnd"] = "Event has auto-ended due to time limit. The winning number was <color=orange>{0}</color>.",
        ["eventWon"] = "<color=orange>{0}</color> won!\nThe winning number was <color=orange>{1}</color>.",
        ["eventNotStarted"] = "Event has not started.",
        ["eventForcedEnd"] = "Event has been ended by <color=orange>{0}</color>. The winning number was <color=orange>{1}</color>.",
        ["eventStarted"] = "Someone has already started the event.\nWinning number: <color=orange>{0}</color>\n/endNumber - To end the event forcefully.",
        ["eventWonEconomics"] = "\n<color=orange>${0}</color> to has been added to his balance.",
        ["eventWonServerRewards"] = "\n<color=orange>{0}</color> server points has been added.",
        ["eventWonExperiences"] = "\n<color=orange>{0}</color> experiences has been awarded."
      }, this);
    }

    string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

    private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
    void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

  }
}


// --- End of file: GuessTheNumber.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQBackpackLite.cs ---
// --- Original Local Path: IQBackpackLite.cs ---

using System;
using UnityEngine;
using Object = System.Object;
using System.Linq;
using Newtonsoft.Json;
using System.Collections;
using ConVar;
using System.Text;
using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("IQBackpack Lite", "Mercury", "1.15.31")]
    [Description("t.me/slivplugin")]
    class IQBackpackLite : RustPlugin
    {
        private List<Item> GetItemBlacklist(BasePlayer player)
        {
            Configuration.Backpack.BackpackCraft Backpack = GetBackpackOption(player);
            if (Backpack == null || Backpack.BlackListItems == null || Backpack.BlackListItems.Count == 0) return null;
            List<Item> ItemList = new List<Item>();

            foreach (Item item in player.inventory.AllItems())
                foreach (String Shortname in Backpack.BlackListItems)
                    if (item.info.shortname == Shortname)
                        ItemList.Add(item);

            return ItemList;
        }
        public Boolean HasImage(String imageName) => (Boolean)ImageLibrary?.Call("HasImage", imageName);

        
        
                private const Boolean LanguageEn = false;
        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null) return;
            if (!player.userID.IsSteamId() || player.IsNpc) return;
            if (IsDuel(player.userID)) return;
            if (permission.UserHasPermission(player.UserIDString, PermissionNoDropBP)) return;

            Object hookResult = CanDropBackpack(player.userID, new Vector3());
            if (hookResult is Boolean && (Boolean)hookResult == false) return;
            
            DropBackpack(player, config.TurnedsSetting.TypeDropBackpack);
            return;
        }
		   		 		  						  	   		  	 	 		  	 				  	   		   			
        void OnUserGroupRemoved(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
		   		 		  						  	   		  	 	 		  	 				  	   		   			
            foreach (var Option in config.BackpackItem.BackpacOption.OrderByDescending(x => x.AmountSlot).Where(x => PermissionsGroup.Contains(x.Permissions)))
                UpdatePermissions(id, Option.Permissions, false);
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        
                private void OnNewSave(String filename) => ClearData();
        
        private const String PermissionNoDropBP = "iqbackpacklite.nodropbp";

                private Item OnItemSplit(Item item, int amount)
        {
            if (item == null) return null;
            if (plugins.Find("Stacks") || plugins.Find("CustomSkinsStacksFix") || plugins.Find("SkinBox")) return null;
            if (item.IsLocked())
            {
                Item x = ItemManager.CreateByPartialName(item.info.shortname, amount);
                x.name = item.name;
                x.skin = item.skin;
                x.amount = amount;
                x.SetFlag(global::Item.Flag.IsLocked, true);
                item.amount -= amount;
                return x;
            }
            return null;
        }
        private class InterfaceBuilder
        {
            
            public static InterfaceBuilder Instance;
            public const String UI_Backpack_Visual = "UI_BACKPACK_VISUAL";
            public Dictionary<String, String> Interfaces;

            
            
            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();

                BuildingBackpack_Visual_Backpack_Slot();
            }

            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static string GetInterface(String name)
            {
                string json = string.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];

                    CuiHelper.DestroyUi(player, UI_Backpack_Visual);
                }
            }

            
                        private void BuildingBackpack_Visual_Backpack_Slot()
            {
                CuiElementContainer container = new CuiElementContainer();
                Configuration.Turneds.VisualBackpackSlot.Position Position = config.TurnedsSetting.VisualBackpackSlots.PositionSlotVisual;

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0.15" },
                    RectTransform = { AnchorMin = Position.AnchorMin, AnchorMax = Position.AnchorMax, OffsetMin = Position.OffsetMin, OffsetMax = Position.OffsetMax }
                }, "Overlay", UI_Backpack_Visual);

                container.Add(new CuiElement
                {
                    Name = "BpImage",
                    Parent = UI_Backpack_Visual,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _.GetImage(config.BackpackItem.UrlBackpack) },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25 -25", OffsetMax = "25 25" }
                }
                });

                if (config.TurnedsSetting.VisualBackpackSlots.UseSlots)
                {
                    container.Add(new CuiElement
                    {
                        Name = "IsFullSlots",
                        Parent = UI_Backpack_Visual,
                        Components = {
                        new CuiTextComponent { Text = "%SLOTS_INFO%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleRight, Color = "0.91 0.87 0.83 0.5"  },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-26.01 -30.07", OffsetMax = "26.01 -11.00" } 
                    }
                    });
                }

                if (config.TurnedsSetting.VisualBackpackSlots.UseSlots)
                {
                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = "0 0 0 0.2" },
                        RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0 -30.07", OffsetMax = "3.73 30.07" } 
                    }, UI_Backpack_Visual, "IsFullPanel");

                    container.Add(new CuiPanel
                    {
                        CursorEnabled = false,
                        Image = { Color = "%Y_PROGRESS_COLOR%" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 %Y_PROGRESS%", OffsetMin = "0.5 1", OffsetMax = "0 0" }
                    }, "IsFullPanel", "IsFullProgress");
                }

                if (config.TurnedsSetting.VisualBackpackSlots.UseButton)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Color = "0 0 0 0", Command = "bp" },
                        Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }, UI_Backpack_Visual, "OPEN_BACKPACK");
                }

                AddInterface("UI_Backpack_Visual_Backpack_Slot", container.ToJson());
            }
                    }

        void OnUserGroupAdded(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;

            foreach (var Option in config.BackpackItem.BackpacOption.OrderByDescending(x => x.AmountSlot).Where(x => PermissionsGroup.Contains(x.Permissions)))
                UpdatePermissions(id, Option.Permissions, true);
        }

        void Unload()
        {
            ServerMgr.Instance.StopCoroutine(DownloadImages());
            InterfaceBuilder.DestroyAll();
            WriteData();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                foreach (Item item in player.inventory.AllItems())
                    item.SetFlag(global::Item.Flag.IsLocked, false);

            foreach (BasePlayer player in BasePlayer.activePlayerList.Where(p => PlayerBackpack.ContainsKey(p) && PlayerBackpack[p] != null))
                PlayerBackpack[player].Destroy();

            _ = null;
        }

        
                private class BackpackBehaviour : FacepunchBehaviour
        {
            private BasePlayer Player = null;
            public StorageContainer Container = null;
            public UInt64 BackpackID = 0;
            private Dictionary<Item, Item.Flag> SaveFlags = new Dictionary<Item, Item.Flag>();
            private void Awake()
            {
                Player = GetComponent<BasePlayer>();
                BackpackID = Player.userID;
            }
            private void BlackListAction(Boolean State)
            {
                List<Item> Itemlist = _.GetItemBlacklist(Player);
                if (Itemlist == null) return;

                foreach (Item item in Itemlist)
                {
                    if (State)
                        if (!SaveFlags.ContainsKey(item))
                            SaveFlags.Add(item, item.flags);

                    item.SetFlag(global::Item.Flag.IsLocked, State);
                }
		   		 		  						  	   		  	 	 		  	 				  	   		   			
                if (!State)
                    foreach (KeyValuePair<Item, Item.Flag> Items in SaveFlags)
                        Items.Key.SetFlag(Items.Value, true);

                Player.SendNetworkUpdate();
            }
            public void Open()
            {
                Container = CreateContainer(Player);
		   		 		  						  	   		  	 	 		  	 				  	   		   			
                PushItems();

                _.timer.Once(0.1f, () => PlayerLootContainer(Player, Container));
                BlackListAction(true);

                if (!_.PlayerUseBackpacks.Contains(Player))
                    _.PlayerUseBackpacks.Add(Player);
                
                Interface.Oxide.CallHook("OnBackpackOpened", Player, Container.OwnerID, Container);
            }

            public void Close()
            {
                Interface.Oxide.CallHook("OnBackpackClosed", Player, Container.OwnerID, Container);

                _.Backpacks[BackpackID].Items = SaveItems(Container.inventory.itemList);
                Container.inventory.Clear();
                Container.Kill();
                Container = null;
                
                Destroy(false);
                BlackListAction(false);
                if (_.PlayerUseBackpacks.Contains(Player))
                    _.PlayerUseBackpacks.Remove(Player);
            }

            private void PushItems()
            {
                _.Unsubscribe("OnItemAddedToContainer");

                var items = RestoreItems(_.Backpacks[BackpackID].Items);
                for (int i = items.Count - 1; i >= 0; i--)
                    items[i].MoveToContainer(Container.inventory, items[i].position);

                _.Subscribe("OnItemAddedToContainer");
            }

            public void Destroy(bool isClose = true)
            {
                if (isClose)
                    Close();

                UnityEngine.Object.Destroy(this);
            }
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (_interface == null)
            {
                timer.Once(3f, () => OnPlayerConnected(player));
                return;
            }
            if (player == null) return;

            if (!PlayerBackpack.ContainsKey(player))
                PlayerBackpack.Add(player, null);
		   		 		  						  	   		  	 	 		  	 				  	   		   			
                if (!Backpacks.ContainsKey(player.userID))
                    Backpacks.Add(player.userID, new BackpackInfo
                    {
                        AmountSlot = GetAvailableSlots(player)
                    });

            CheckConnectionPermission(player);
            
            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);
            
            if (!player.IsDead() && !IsDuel(player.userID) && !player.IsSleeping())
                DrawUI_Backpack_Visual(player);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        void OnPlayerSleepEnded(BasePlayer player) => OnPlayerConnected(player);
        private void OnServerShutdown() => Unload();
        
                public void SendChat(String Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            Configuration.Reference.IQChat Chat = config.References.IQChatSetting;
            if (IQChat)
                if (Chat.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        private void ClearData()
        {
            if (!config.TurnedsSetting.WipeCleaning) return;
            foreach (KeyValuePair<UInt64, BackpackInfo> Backpack in Backpacks)
                Backpack.Value.Items.Clear();
            WriteData();
        }
        static Item BuildItem(BackpackInfo.SavedItem sItem)
        {
            if (sItem.Amount < 1) sItem.Amount = 799 > 0 ? 1 : 0;
            Item item = null;
            item = ItemManager.CreateByItemID(sItem.Itemid, sItem.Amount, sItem.Skinid);
            item.position = sItem.TargetSlot;

            if (sItem.Text != null && !String.IsNullOrWhiteSpace(sItem.Text))
                item.text = sItem.Text;
            
            if (sItem.GrowableGenes != 0)
                GrowableGeneEncoding.EncodeGenesToItem(sItem.GrowableGenes, item);
            
            if (sItem.Mods != null)
            {
                foreach (var mod in sItem.Mods)
                    item.contents.AddItem(BuildItem(mod).info, mod.Amount, mod.Skinid);
            }
            
            if (item.hasCondition)
            {
                item.condition = sItem.Condition;
                item.maxCondition = sItem.Maxcondition;
                item.busyTime = sItem.BusyTime;
            }

            if (sItem.Blueprint != 0)
                item.blueprintTarget = sItem.Blueprint;

            if (sItem.Name != null)
                item.name = sItem.Name;

            if (sItem.OnFire)
                item.SetFlag(global::Item.Flag.OnFire, true);

            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
            if (flameThrower)
                flameThrower.ammo = sItem.Flamefuel;
            
            BaseEntity Subentity;
            UInt64 entityId = item.instanceData?.subEntity.Value ?? 0;
            if (entityId == 0)
            {
                ItemModSign itemModSign = item.info.GetComponent<ItemModSign>();
                if (itemModSign == null)
                    return item;
		   		 		  						  	   		  	 	 		  	 				  	   		   			
                Subentity = itemModSign.CreateAssociatedEntity(item);
            }
            else
            {
                Subentity = BaseNetworkable.serverEntities.Find(item.instanceData.subEntity) as BaseEntity;

                if (Subentity == null)
                    return item;
            }

            PhotoEntity photoEntity = Subentity as PhotoEntity;
            if ((Object)photoEntity != null)
            {
                Byte[] fileContent = FileStorage.server.Get(sItem.FileContents, FileStorage.Type.jpg, Subentity.net.ID);

                photoEntity.SetImageData(sItem.IdPhoto, fileContent);

                return item;
            }
            
            return item;
        }
        
        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (entity == null || player == null) return;
            
            if(entity is MLRS)
                DrawUI_Backpack_Visual(player);
        }
        private class NoRagdollCollision : FacepunchBehaviour
        {
            private Collider _collider;

            private void Awake()
            {
                _collider = GetComponent<Collider>();
            }

            private void OnCollisionEnter(Collision collision)
            {
                if (collision.collider.IsOnLayer(Rust.Layer.Ragdoll))
                {
                    UnityEngine.Physics.IgnoreCollision(_collider, collision.collider);
                }
            }
        }
        
        private void UpdatePermissions(String ID, String Permissions, Boolean IsGranted, Boolean ReCheack = false)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);
            if (player == null) return;

            if (IQPermissions && !ReCheack)
            {
                timer.In(3f, () =>
                {
                    UpdatePermissions(ID, Permissions, permission.UserHasPermission(ID, Permissions), true);
                });
                return;
            }

            if (config.BackpackItem.BackpacOption.Find(x => x.Permissions.Equals(Permissions)) == null) return;
            if (!Backpacks.ContainsKey(player.userID)) return;
            player.EndLooting();

            Int32 AvailableSlots = GetAvailableSlots(player);
            if (Backpacks[player.userID].AmountSlot == AvailableSlots) return;
            if (AvailableSlots < GetBusySlotsBackpack(player))
            {
                Int32 Count = Backpacks[player.userID].Items.Count - 1;
                foreach (BackpackInfo.SavedItem Sitem in Backpacks[player.userID].Items.Take((Backpacks[player.userID].Items.Count - AvailableSlots)))
                {
                    NextTick(() =>
                    {
                        Item itemDrop = BuildItem(Sitem);
                        itemDrop.DropAndTossUpwards(player.transform.position, 2f);

                        Backpacks[player.userID].Items.RemoveAt(Count);
                        Count--;
                    });
                }
            }
            Backpacks[player.userID].AmountSlot = AvailableSlots;

            NextTick(() => {
                DrawUI_Backpack_Visual(player);
                SendChat(GetLang((IsGranted ? "BACKPACK_GRANT" : "BACKPACK_REVOKE"), player.UserIDString, AvailableSlots), player);
            });
        }
        private Int32 GetSlotsBackpack(BasePlayer player)
        {
            Int32 SlotsBackpack = 0;

            if (Backpacks.ContainsKey(player.userID))
                SlotsBackpack = Backpacks[player.userID].AmountSlot;

            return SlotsBackpack;
        }
        
        
        private Configuration.Backpack.BackpackCraft GetBackpackOption(BasePlayer player)
        {
            Configuration.Backpack.BackpackCraft BCraft = config.BackpackItem.BackpacOption.OrderByDescending(x => x.AmountSlot).FirstOrDefault(x => permission.UserHasPermission(player.UserIDString, x.Permissions));
            return BCraft;
        }
        private class Configuration
        {
            internal class Backpack
            {
                [JsonProperty(LanguageEn ? "Link to the picture to display the backpack" : "Ссылка на картинку для отображения рюкзака")]
                public String UrlBackpack = "https://cdn.discordapp.com/attachments/1124746976093814796/1208383710144237579/rPeKd9R.png";

                [JsonProperty(LanguageEn ? "Variations of backpacks by privileges (An available set is given to the player who is higher than others)" : "Вариации рюкзаков по привилегиям (Дается доступный набор игроку, который выше других)")]
                public List<BackpackCraft> BackpacOption = new List<BackpackCraft>();
                internal class BackpackCraft
                {
                    [JsonProperty(LanguageEn ? "Permission to be able to craft and carry this backpack (do not leave this field empty, otherwise it will not be taken into account)" : "Права для возможности крафтить и носить данный рюкзак(не оставляйте это поле пустым, иначе оно не будет учитываться)")]
                    public String Permissions = "iqbackpacklite.7slot";
                    [JsonProperty(LanguageEn ? "The amount slots in this backpack" : "Количество слотов у данного рюкзака")]
                    public Int32 AmountSlot = 7;
                    [JsonProperty(LanguageEn ? "Blacklist of items for this backpack" : "Черный список предметов для данного рюкзака")]
                    public List<String> BlackListItems = new List<String>();
                }

            }
            internal class Reference
            {
                [JsonProperty(LanguageEn ? "Setting up IQChat" : "Настройка IQChat")]
                public IQChat IQChatSetting = new IQChat();
                internal class IQChat
                {
                    [JsonProperty(LanguageEn ? "IQChat : Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
                    public String CustomPrefix = "[IQBackpack-Lite]";
                    [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
                    public String CustomAvatar = "0";
                    [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI уведомления")]
                    public Boolean UIAlertUse = false;
                }
            }

            [JsonProperty(LanguageEn ? "Additional configuration" : "Дополнительная настройка")]
            public Turneds TurnedsSetting = new Turneds();
            [JsonProperty(LanguageEn ? "Setting up a backpack" : "Настройка рюкзака")]
            public Backpack BackpackItem = new Backpack();
            [JsonProperty(LanguageEn ? "Configuring supporting plugins" : "Настройка поддерживающих плагинов")]
            public Reference References = new Reference();
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    BackpackItem = new Backpack
                    {
                        UrlBackpack = "https://cdn.discordapp.com/attachments/1124746976093814796/1208383710144237579/rPeKd9R.png",

                        BackpacOption = new List<Backpack.BackpackCraft>
                        {
                            new Backpack.BackpackCraft
                            {
                                AmountSlot = 7,
                                Permissions = "iqbackpacklite.7slot",
                                BlackListItems = new List<String> { },                              
                            },
                            new Backpack.BackpackCraft
                            {
                                AmountSlot = 15,
                                Permissions = "iqbackpacklite.15slot",
                                BlackListItems = new List<String>
                                {
                                    "rocket.launcher",
                                    "ammo.rocket.basic",
                                    "explosive.satchel",
                                    "supply.signal",
                                    "explosive.timed",
                                },                              
                            }
                        }
                    },
                    TurnedsSetting = new Turneds
                    {
                        TypeDropBackpack = TypeDropBackpack.DropBackpack,
                        RemoveBackpack = 200f,
                        WipeCleaning = false,
                        ClosePressedAgain = true,
                        VisualBackpackSlots = new Turneds.VisualBackpackSlot
                        {
                            UseSlots = true,
                            UseButton = true,
                            ColorProgressBar = new Turneds.VisualBackpackSlot.ColorProgress
                            {
                                ColorMinimal = "0.44 0.53 0.26 1.00",
                                ColorAverage = "0.98 0.53 0.26 1.00",
                                ColorMaximum = "0.98 0.20 0.28 1.00",
                            },
                            PositionSlotVisual = new Turneds.VisualBackpackSlot.Position
                            {
                                AnchorMin = "0.5 0",
                                AnchorMax = "0.5 0",
                                OffsetMin = "-264.27 17.94",
                                OffsetMax = "-203.72 78.08"
                            },
                        },
                    },
                    References = new Reference
                    {
                        IQChatSetting = new Reference.IQChat
                        {
                            CustomAvatar = "0",
                            CustomPrefix = "[IQBackpackLite] ",
                            UIAlertUse = false,
                        }
                    }
                };
            }
            internal class Turneds
            {
                [JsonProperty(LanguageEn ? "Time to remove the backpack when falling out (Works with : 2 - Throws the backpack with objects)" : "Время удаления рюкзака при выпадении (Работает с : 2 - Выбрасывает рюкзак с предметами)")]
                public Single RemoveBackpack = 200f;
                [JsonProperty(LanguageEn ? "Automatically clear the inventory of players' backpacks after the vape (true - yes/false - no)" : "Автоматически очищать инвентарь рюкзаков игроков после вайпа (true - да/false - нет)")]
                public Boolean WipeCleaning = false;
                [JsonProperty(LanguageEn ? "Close the backpack when clicking on the UI again/using the bind if it is open" : "Закрывать рюкзак при повторном нажатии на UI/использовании бинда, если он открыт")]
                public Boolean ClosePressedAgain = true;
                [JsonProperty(LanguageEn ? "Interface Setup" : "Настройка интерфейса")]
                public VisualBackpackSlot VisualBackpackSlots = new VisualBackpackSlot();
                internal class VisualBackpackSlot
                {
                    [JsonProperty(LanguageEn ? "Setting up the position of the UI slot with a backpack" : "Настройка позиции UI слота с рюкзаком")]
                    public Position PositionSlotVisual = new Position();
                    internal class ColorProgress
                    {
                        [JsonProperty(LanguageEn ? "The color of the fullness strip when the backpack is >30% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >30%")]
                        public String ColorMinimal = "0.44 0.53 0.26 1.00";
                        [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >80% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >80%")]
                        public String ColorMaximum = "0.98 0.20 0.28 1.00";
                        [JsonProperty(LanguageEn ? "The color of the fullness band when the backpack is >60% full" : "Цвет полосы заполненности, когда рюкзак заполнен на >60%")]
                        public String ColorAverage = "0.98 0.53 0.26 1.00";
                    }
                    [JsonProperty(LanguageEn ? "Allow to open the backpack by clicking on the UI interface (true - yes/false - no)" : "Разрешить открывать рюкзак нажава на UI интерфейс (true - да/false - нет)")]
                    public Boolean UseButton = true;
                    internal class Position
                    {
                        public String AnchorMin;
                        public String AnchorMax;
                        public String OffsetMin;
                        public String OffsetMax;
                    }
                    [JsonProperty(LanguageEn ? "Display the number of slots in the backpack on the UI (true - yes/false - no)" : "Отображать количество слотов в рюкзаке на UI (true - да/false - нет)")]
                    public Boolean UseSlots = true;
                    [JsonProperty(LanguageEn ? "Adjusting the colors of the fullness bar" : "Настройка цветов полосы заполненности")]
                    public ColorProgress ColorProgressBar = new ColorProgress();

                }
                [JsonProperty(LanguageEn ? "The type of work of the backpack: 0 - you need to put it on to use, 1 - only permissions are required (from the variations of backpacks)" : "Тип выпадения рюкзака : 0 - Не выпадает при смерти, 1 - Выбрасывает предметы вокруг трупа, 2 - Выбрасывает рюкзак с предметами")]
                public TypeDropBackpack TypeDropBackpack = TypeDropBackpack.DropBackpack;
            }
        }
        static List<BackpackInfo.SavedItem> SaveItems(List<Item> items) => items.Select(SaveItem).ToList();

                public Boolean IsDuel(UInt64 userID)
        {
            if (EventHelper)
                if (EventHelper.Call<Boolean>("IsPlayerSetup", userID))
                    return true;
            
            if (Battles) return (Boolean)Battles?.Call("IsPlayerOnBattle", userID);
            if (Duel) return (Boolean)Duel?.Call("IsPlayerOnActiveDuel", BasePlayer.FindByID(userID));
            if (OneVSOne) return (Boolean)OneVSOne?.Call("IsEventPlayer", BasePlayer.FindByID(userID));
            if (ArenaTournament) return ArenaTournament.Call<Boolean>("IsOnTournament", userID);
            return false;
        }
        void OnGroupPermissionRevoked(string name, string perm)
        {
            String[] GroupUser = permission.GetUsersInGroup(name);
            if (GroupUser == null) return;

            foreach (String IDs in GroupUser)
                UpdatePermissions(IDs.Substring(0, 17), perm, false);
        }
        
        public static Object CanOpenBackpack(BasePlayer player, UInt64 ownerId)
        {
            return Interface.CallHook("CanOpenBackpack", player, ownerId);
        }
        private static void PlayerLootContainer(BasePlayer player, StorageContainer container)
        {
            container.SetFlag(BaseEntity.Flags.Open, true, false);
            player.inventory.loot.StartLootingEntity(container, false);
            player.inventory.loot.AddContainer(container.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic_resizable");
            container.DecayTouch();
            container.SendNetworkUpdate();
        }
        
                private void DropBackpack(BasePlayer player, TypeDropBackpack typeDropBackpack)
        {
            if (!PlayerBackpack.ContainsKey(player)) return;
            if (PlayerBackpack[player] != null)
                PlayerBackpack[player].Close();
            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);
            UInt64 ID = player.userID;
            List<BackpackInfo.SavedItem> SavedList = GetSavedList(ID);
            if (SavedList == null || SavedList.Count == 0) return;
            switch (typeDropBackpack)
            {
                case TypeDropBackpack.DropItems:
                    {
                        foreach (BackpackInfo.SavedItem sItem in SavedList)
                        {
                            Item BuildedItem = BuildItem(sItem);
                            BuildedItem.DropAndTossUpwards(player.transform.position, Oxide.Core.Random.Range(2, 6));
                        }
                        break;
                    }
                case TypeDropBackpack.DropBackpack:
                    {
                        String Prefab = "assets/prefabs/misc/item drop/item_drop_backpack.prefab";
                        DroppedItemContainer BackpackDrop = (BaseEntity)GameManager.server.CreateEntity(Prefab, player.transform.position + new Vector3(Oxide.Core.Random.Range(-1f, 1f), 0f, 0f)) as DroppedItemContainer;
                        BackpackDrop.gameObject.AddComponent<NoRagdollCollision>();

                        BackpackDrop.lootPanelName = "generic_resizable";
                        BackpackDrop.playerName = $"{player.displayName ?? "Somebody"}'s Backpack";
                        BackpackDrop.playerSteamID = player.userID;

                        BackpackDrop.inventory = new ItemContainer();
                        BackpackDrop.inventory.ServerInitialize(null, GetSlotsBackpack(player));
                        BackpackDrop.inventory.GiveUID();
                        BackpackDrop.inventory.entityOwner = BackpackDrop;
                        BackpackDrop.inventory.SetFlag(ItemContainer.Flag.NoItemInput, true);

                        foreach (BackpackInfo.SavedItem sItem in SavedList)
                        {
                            Item BuildedItem = BuildItem(sItem);
                            BuildedItem.MoveToContainer(BackpackDrop.inventory, sItem.TargetSlot);
                        }

                        BackpackDrop.SendNetworkUpdate();
                        BackpackDrop.Spawn();
                        BackpackDrop.ResetRemovalTime(Math.Max(config.TurnedsSetting.RemoveBackpack, BackpackDrop.CalculateRemovalTime()));
                        break;
                    }
                default:
                    break;
            }
            SavedList.Clear();
        }
        void OnUserPermissionRevoked(string id, string permName) => UpdatePermissions(id, permName, false);
        
                private void OpenBP(BasePlayer player)
        {        
            if (GetSlotsBackpack(player) == 0)
            {
                SendChat(GetLang("BACKPACK_NULL", player.UserIDString), player);
                return;
            }
            if (IsDuel(player.userID)) return;
            
            Object hookResult = CanOpenBackpack(player, player.userID);
            if (hookResult is String)
            {
                SendChat(hookResult as String, player);
                return;
            }

            BackpackBehaviour backpackHandler = null;
            if (PlayerBackpack.ContainsKey(player))
            {
                if (PlayerBackpack[player] != null)
                    backpackHandler = PlayerBackpack[player];
            }
            else PlayerBackpack.Add(player, null);
            if (backpackHandler == null)
            {
                backpackHandler = player.gameObject.AddComponent<BackpackBehaviour>();

                PlayerBackpack[player] = backpackHandler;
            }
            if (backpackHandler.Container != null)
            {
                if (config.TurnedsSetting.ClosePressedAgain)
                    player.EndLooting();
                else SendChat(GetLang("BACKPACK_IS_OPENED", player.UserIDString), player);
                return;
            }
            
            player.EndLooting();
            backpackHandler.Open();
        }
        void WriteData() => Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQBackpackLite/Backpacks", Backpacks);
        
                private String GetImage(String fileName, UInt64 skin = 0)
        {
            var imageId = (String)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return String.Empty;
        }

        internal class BackpackInfo
        {
            public Int32 AmountSlot = 0;
            public List<SavedItem> Items = new List<SavedItem>();

            internal class SavedItem
            {
                public Int32 TargetSlot;
                public String Shortname;
                public Int32 Itemid;
                public Single Condition;
                public Single Maxcondition;
                public Int32 Amount;
                public Int32 Ammoamount;
                public String Ammotype;
                public Int32 Flamefuel;
                public UInt64 Skinid;
                public String Name;
                public Boolean Weapon;
                public Int32 Blueprint;
                public Single BusyTime;
                public Boolean OnFire;
                public UInt32 FileContents;
                public UInt64 IdPhoto;
                public String Text;
                public Int32 GrowableGenes;
                public List<SavedItem> Mods;
            }
        }
        public static IQBackpackLite _ = null;
        public Dictionary<UInt64, BackpackInfo> _old_Backpacks = new Dictionary<UInt64, BackpackInfo>();

        
                public static StorageContainer CreateContainer(BasePlayer player)
        {
            StorageContainer storage = GameManager.server.CreateEntity("assets/prefabs/misc/halloween/coffin/coffinstorage.prefab") as StorageContainer;
            if (storage == null) return null;

            var containerEntity = storage as StorageContainer;
            if (containerEntity == null)
            {
                UnityEngine.Object.Destroy(storage);
                return null;
            }
            UnityEngine.Object.DestroyImmediate(storage.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(storage.GetComponent<GroundWatch>());

            foreach (var collider in storage.GetComponentsInChildren<Collider>())
                UnityEngine.Object.DestroyImmediate(collider);

            storage.transform.position = new Vector3(player.ServerPosition.x, player.ServerPosition.y - 100f, player.ServerPosition.z);
            storage.panelName = "generic_resizable";

            ItemContainer container = new ItemContainer { playerOwner = player };
            container.ServerInitialize((Item)null, _.GetSlotsBackpack(player));
            if ((Int32)container.uid.Value == 0)
                container.GiveUID();

            container.entityOwner = storage;
            storage.inventory = container;
            storage.OwnerID = player.userID;

            storage._limitedNetworking = false;
            storage.EnableSaving(false);

            storage.SendMessage("SetDeployedBy", player, (SendMessageOptions)SendMessageOptions.DontRequireReceiver);
            storage.Spawn();

            storage.inventory.allowedContents = ItemContainer.ContentsType.Generic;
            return storage;
        }
        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (entity == null || player == null) return;

            BackpackBehaviour backpackHandler = null;
            if (PlayerBackpack.ContainsKey(player) && PlayerBackpack[player] != null)
                backpackHandler = PlayerBackpack[player];

            StorageContainer storage = entity as StorageContainer;

            if (player != null && storage != null && backpackHandler != null && storage == backpackHandler.Container)
            {
                backpackHandler.Close();
                DrawUI_Backpack_Visual(player);
            }
        }
        void OnServerInitialized()
        {
            _ = this;
            ServerMgr.Instance.StartCoroutine(DownloadImages());
		   		 		  						  	   		  	 	 		  	 				  	   		   			
            RegisteredPermissions();
		   		 		  						  	   		  	 	 		  	 				  	   		   			
            if (config.TurnedsSetting.TypeDropBackpack == TypeDropBackpack.NoDrop)
                Unsubscribe("OnPlayerDeath");
        }
        private Int32 GetAvailableSlots(BasePlayer player)
        {
            Int32 AvailableSlots = 0;

            Configuration.Backpack.BackpackCraft BCraft = GetBackpackOption(player);
            if (BCraft == null) return AvailableSlots;
            AvailableSlots = BCraft.AmountSlot;

            return AvailableSlots;
        }
        
        ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            if (container == null || item == null) return null;
            BasePlayer player = container.playerOwner;
            if (player == null || !player.userID.IsSteamId() || player.IsNpc) return null;
            if (!PlayerUseBackpacks.Contains(player)) return null;

            Configuration.Backpack.BackpackCraft OptionBackpack = GetBackpackOption(player);
            if (OptionBackpack == null)
                return null;
            
            if (OptionBackpack.BlackListItems.Contains(item.info.shortname) && item.IsLocked())
                return ItemContainer.CanAcceptResult.CannotAccept;

            return null;
        }
        private List<BasePlayer> PlayerUseBackpacks = new List<BasePlayer>();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        /// <summary>
        /// Обновление 1.0.х
        /// - Добавлен хук при открытии рюкзака : void OnBackpackOpened(BasePlayer player, ulong backpackOwnerID, ItemContainer backpackContainer)
        /// - Добавлен хук при закрытии рюкзака : void OnBackpackClosed(BasePlayer player, ulong backpackOwnerID, ItemContainer backpackContainer)
        /// - Добавлена поддержка генов
        /// - Добавлена корректировка UI если игрок спит - UI не будет появляться
        /// - Добавлена корректировка UI если игрок сел в MLRS - UI не будет появляться
        /// - Исправлено NRE с фото
        /// - Перезалил картинки на новый фото-хостинг

                [PluginReference] Plugin ImageLibrary, IQChat, Battles, Duel, OneVSOne, ArenaTournament, EventHelper, IQPermissions;
        public Boolean AddImage(String url, String shortname, UInt64 skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private void RegisteredPermissions()
        {
            foreach (Configuration.Backpack.BackpackCraft BPCraft in config.BackpackItem.BackpacOption)
                permission.RegisterPermission(BPCraft.Permissions, this);
                
            permission.RegisterPermission(PermissionNoDropBP, this);

        }

        [ChatCommand("bp")]
        void OpenBackpackChat(BasePlayer player)
        {
            if (player == null) return;
            
            timer.Once(0.3f, ()=> OpenBP(player));
        }

        
        
        public Dictionary<UInt64, BackpackInfo> Backpacks = new Dictionary<UInt64, BackpackInfo>();
        static List<Item> RestoreItems(List<BackpackInfo.SavedItem> sItems)
        {
            return sItems.Select(sItem =>
            {
                if (sItem.Weapon) return BuildWeapon(sItem);
                return BuildItem(sItem);
            }).Where(i => i != null).ToList();
        }

        
        
        
                private Int32 GetSlotsPercent(Single Percent, Single Slots)
        {
            Single ReturnSlot = (((Single)Slots / 100.0f) * Percent);
            return (Int32)ReturnSlot;
        }
        static Item BuildWeapon(BackpackInfo.SavedItem sItem)
        {
            Item item = null;
            item = ItemManager.CreateByItemID(sItem.Itemid, 1, sItem.Skinid);
            item.position = sItem.TargetSlot;

            if (item.hasCondition)
            {
                item.condition = sItem.Condition;
                item.maxCondition = sItem.Maxcondition;
            }

            if (sItem.Blueprint != 0)
                item.blueprintTarget = sItem.Blueprint;

            var weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                var def = ItemManager.FindItemDefinition(sItem.Ammotype);
                weapon.primaryMagazine.ammoType = def;
                weapon.primaryMagazine.contents = sItem.Ammoamount;
            }

            if (sItem.Mods != null)
                foreach (var mod in sItem.Mods)
                    item.contents.AddItem(BuildItem(mod).info, 1);
            return item;
        }
        static BackpackInfo.SavedItem SaveItem(Item item)
        {
            BackpackInfo.SavedItem iItem = new BackpackInfo.SavedItem
            {
                TargetSlot = item.position,
                Shortname = item.info.shortname,
                Amount = item.amount,
                Mods = new List<BackpackInfo.SavedItem>(),
                Skinid = item.skin,
                BusyTime = item.busyTime,

            };
            
            if (item.info.amountType == ItemDefinition.AmountType.Genetics && item.instanceData != null && item.instanceData.dataInt != 0)
                iItem.GrowableGenes = item.instanceData.dataInt;
            
            if (item.HasFlag(global::Item.Flag.OnFire))
            {
                iItem.OnFire = true;
            }
            
            iItem.Text = item.text;
            
            if (item.info == null) return iItem;
            iItem.Itemid = item.info.itemid;
            iItem.Weapon = false;
            
            UInt64 subEntityId = item.instanceData?.subEntity.Value ?? 0;
            if (subEntityId != 0)
            {
                BaseEntity subEntity = BaseNetworkable.serverEntities.Find(item.instanceData.subEntity) as BaseEntity;
                if (subEntity == null) return iItem;

                PhotoEntity photoEntity = subEntity as PhotoEntity;
                if (photoEntity != null && photoEntity.ImageCrc != 0)
                {
                    iItem.IdPhoto = photoEntity.PhotographerSteamId;
                    iItem.FileContents = photoEntity.ImageCrc;
                    return iItem;
                }
            }
		   		 		  						  	   		  	 	 		  	 				  	   		   			
            if (item.contents != null && item.info.category.ToString() != "Weapon")
            {
                foreach (var itemCont in item.contents.itemList)
                {
                    Debug.Log(itemCont.info.shortname);

                    if (itemCont.info.itemid != 0)
                        iItem.Mods.Add(SaveItem(itemCont));
                }
            }

            iItem.Name = item.name;
            if (item.hasCondition)
            {
                iItem.Condition = item.condition;
                iItem.Maxcondition = item.maxCondition;
            }

            if (item.blueprintTarget != 0) iItem.Blueprint = item.blueprintTarget;

            FlameThrower flameThrower = item.GetHeldEntity()?.GetComponent<FlameThrower>();
            if (flameThrower != null)
                iItem.Flamefuel = flameThrower.ammo;
            if (item.info.category.ToString() != "Weapon") return iItem;
            BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon == null) return iItem;
            if (weapon.primaryMagazine == null) return iItem;
            iItem.Ammoamount = weapon.primaryMagazine.contents;
            iItem.Ammotype = weapon.primaryMagazine.ammoType.shortname;
            iItem.Weapon = true;

            if (item.contents != null)
                foreach (var mod in item.contents.itemList)
                    if (mod.info.itemid != 0)
                        iItem.Mods.Add(SaveItem(mod));
            return iItem;
        }
                
        
        public static Object CanDropBackpack(UInt64 ownerId, Vector3 position)
        {
            return Interface.CallHook("CanDropBackpack", ownerId, position);
        }

        
        
        void OnUserPermissionGranted(string id, string permName) => UpdatePermissions(id, permName, true);
        private Dictionary<BasePlayer, BackpackBehaviour> PlayerBackpack = new Dictionary<BasePlayer, BackpackBehaviour>();
        private enum TypeDropBackpack
        {
            NoDrop,
            DropItems,
            DropBackpack,
        }
        
        private static InterfaceBuilder _interface;
        
                public static StringBuilder sb = new StringBuilder();
        
        
        
                
        private void CheckConnectionPermission(BasePlayer player)
        {
            UInt64 IDBackpack = player.userID;
            if (!Backpacks.ContainsKey(IDBackpack)) return;
            
            Int32 AvailableSlots = GetAvailableSlots(player);
            if (AvailableSlots < GetBusySlotsBackpack(player))
            {
                Int32 Count = Backpacks[IDBackpack].Items.Count - 1;
                foreach (BackpackInfo.SavedItem Sitem in Backpacks[IDBackpack].Items.Take((Backpacks[IDBackpack].Items.Count - AvailableSlots)))
                {
                    NextTick(() =>
                    {
                        Item itemDrop = BuildItem(Sitem);
                        itemDrop.DropAndTossUpwards(player.transform.position, 2f);

                        Backpacks[IDBackpack].Items.RemoveAt(Count);
                        Count--;
                    });
                }
            }
            Backpacks[IDBackpack].AmountSlot = AvailableSlots;
        }
        private Int32 GetBusySlotsBackpack(BasePlayer player)
        {
            if (Backpacks.ContainsKey(player.userID))
                return Backpacks[player.userID].Items.Count;
            return 0;
        }

        
                private List<BackpackInfo.SavedItem> GetSavedList(UInt64 ID)
        {
            List<BackpackInfo.SavedItem> SavedList = null;
            if (Backpacks.ContainsKey(ID))
                SavedList = Backpacks[ID].Items;

            return SavedList;
        }

        
        
        [ConsoleCommand("bp")]
        void OpenBackpackConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            
            timer.Once(0.3f, ()=> OpenBP(player));
        }
        void Init() => ReadData();

        void ReadData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("IQSystem/IQBackpackLite/Backpacks"))
            {
                Backpacks = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, BackpackInfo>>("IQSystem/IQBackpackLite/Backpacks");
                return;
            }

            _old_Backpacks = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, BackpackInfo>>("IQBackpackLite/Backpacks");
            Backpacks = _old_Backpacks;
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQBackpackLite/Backpacks", Backpacks);
            Backpacks = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, BackpackInfo>>("IQSystem/IQBackpackLite/Backpacks");

        }
        private IEnumerator DownloadImages()
        {
            Puts(LanguageEn ? "Generating the interface..." : "Генерируем интерфейс...");
		   		 		  						  	   		  	 	 		  	 				  	   		   			
            if (!HasImage($"{config.BackpackItem.UrlBackpack}"))
                AddImage(config.BackpackItem.UrlBackpack, config.BackpackItem.UrlBackpack);
           
            yield return new WaitForSeconds(0.04f);

            Puts(LanguageEn ? "The interface has been successfully generated!" : "Интерфейс был успешно сгенерирован!");

            _interface = new InterfaceBuilder();

            timer.Once(3f, () =>
            {
                foreach (BasePlayer player in BasePlayer.allPlayerList)
                    OnPlayerConnected(player);
            });
        }

        
        
        private static Configuration config = new Configuration();
        void OnGroupPermissionGranted(string name, string perm)
        {
            String[] GroupUser = permission.GetUsersInGroup(name);
            if (GroupUser == null) return;

            foreach (String IDs in GroupUser)
                UpdatePermissions(IDs.Substring(0, 17), perm, true);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning(LanguageEn ? "Error " + $"reading the configuration 'oxide/config/{Name}', creating a new configuration!!" : "Ошибка " + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }
        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (entity == null || player == null) return;

            if (entity is MLRS)
                CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);
        }
        private void DrawUI_Backpack_Visual(BasePlayer player)
        {
            if (_interface == null) return;
            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Backpack_Visual);
		   		 		  						  	   		  	 	 		  	 				  	   		   			
            String Interface = InterfaceBuilder.GetInterface("UI_Backpack_Visual_Backpack_Slot");
            if (Interface == null) return;

            Single BusySlots = (Single)GetBusySlotsBackpack(player);
            Single Slots = (Single)GetSlotsBackpack(player);
            if (Slots == 0) return;
            Single Y_Progress = (Single)((Single)BusySlots / (Single)Slots);

            String Y_Progress_Color = BusySlots >= GetSlotsPercent(80.0f, Slots) ? config.TurnedsSetting.VisualBackpackSlots.ColorProgressBar.ColorMaximum :
                                      BusySlots >= GetSlotsPercent(60.0f, Slots) ? config.TurnedsSetting.VisualBackpackSlots.ColorProgressBar.ColorAverage :
                                                                                   config.TurnedsSetting.VisualBackpackSlots.ColorProgressBar.ColorMinimal;
		   		 		  						  	   		  	 	 		  	 				  	   		   			
            Interface = Interface.Replace("%CRAFT_BTN%", GetLang("CRAFT_BTN", player.UserIDString));
            Interface = Interface.Replace("%SLOTS_INFO%", $"<b>{BusySlots}/{Slots}</b>");
            Interface = Interface.Replace("%Y_PROGRESS%", $"{Y_Progress}");
            Interface = Interface.Replace("%Y_PROGRESS_COLOR%", $"{Y_Progress_Color}");

            CuiHelper.AddUi(player, Interface);
        }
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {                
                ["BACKPACK_TITLE"] = "BACKPACK {0} SLOT(S)",
                ["BACKPACK_IS_OPENED"] = "Do you already have your backpack open!",
                ["BACKPACK_NO_INITIALIZE"] = "The plugin is loading, expect you will be able to open crafting soon!",

                ["BACKPACK_GRANT"] = "You have successfully received a backpack, the number of slots has been increased to : {0}",
                ["BACKPACK_REVOKE"] = "Your extra slots privilege expired, slots reduced to : {0}",
                ["BACKPACK_NULL"] = "You don't have a backpack available",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BACKPACK_TITLE"] = "РЮКЗАК {0} СЛОТА(ОВ)",
                ["BACKPACK_IS_OPENED"] = "У вас уже открыт рюкзак!",
                ["BACKPACK_NO_INITIALIZE"] = "Плагин загружается, ожидайте, вскоре вы сможете открыть крафт!",

                ["BACKPACK_GRANT"] = "Вы успешно получили рюкзак, количество слотов увеличено до : {0}",
                ["BACKPACK_REVOKE"] = "У вас истекла привилегия с дополнительными слотами, слоты уменьшились до : {0}",
                ["BACKPACK_NULL"] = "У вас нет доступного рюкзака",

            }, this, "ru");
        }

            }
}

// --- End of file: IQBackpackLite.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VehicleDecayProtection.cs ---
// --- Original Local Path: VehicleDecayProtection.cs ---

﻿using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Vehicle Decay Protection", "WhiteThunder", "1.0.2")]
    [Description("Protects vehicles from decay around tool cupboards and when recently used.")]
    internal class VehicleDecayProtection : CovalencePlugin
    {
        #region Fields

        private VehicleDecayConfig PluginConfig;

        #endregion

        #region Hooks

        private void Init()
        {
            PluginConfig = Config.ReadObject<VehicleDecayConfig>();
        }

        // Using separate hooks to theoretically improve performance by reducing hook calls
        private object OnEntityTakeDamage(BaseVehicle entity, HitInfo hitInfo) =>
            ProcessDecayDamage(entity, hitInfo);

        private object OnEntityTakeDamage(HotAirBalloon entity, HitInfo hitInfo) =>
            ProcessDecayDamage(entity, hitInfo);

        private object OnEntityTakeDamage(BaseVehicleModule entity, HitInfo hitInfo) =>
            ProcessDecayDamage(entity, hitInfo);

        #endregion

        #region Helper Methods

        private object ProcessDecayDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (!hitInfo.damageTypes.Has(Rust.DamageType.Decay)) return null;

            var vehicleConfig = GetVehicleConfig(entity);
            if (vehicleConfig == null) return null;

            float multiplier = 1;

            var lastUsedTime = GetVehicleLastUsedTime(entity);
            if (lastUsedTime != -1 && Time.time < lastUsedTime + 60 * vehicleConfig.ProtectionMinutesAfterUse)
                multiplier = 0;
            else if (entity.GetBuildingPrivilege() != null)
                multiplier = vehicleConfig.DecayMultiplierNearTC;

            if (multiplier != 1)
            {
                hitInfo.damageTypes.Scale(Rust.DamageType.Decay, multiplier);

                // If no damage, return true to prevent the vehicle being considered attacked (which prevents repair)
                if (!hitInfo.hasDamage)
                    return true;
            }

            return null;
        }

        private VehicleConfig GetVehicleConfig(BaseCombatEntity entity)
        {
            if (entity is HotAirBalloon)
                return PluginConfig.Vehicles.HotAirBalloon;

            // Must go before MiniCopter
            if (entity is ScrapTransportHelicopter)
                return PluginConfig.Vehicles.ScrapTransportHelicopter;

            if (entity is MiniCopter)
                return PluginConfig.Vehicles.Minicopter;

            // Must go before MotorRowboat
            if (entity is RHIB)
                return PluginConfig.Vehicles.RHIB;

            if (entity is MotorRowboat)
                return PluginConfig.Vehicles.Rowboat;

            if (entity is BaseVehicleModule)
                return PluginConfig.Vehicles.ModularCar;

            return null;
        }

        private float GetVehicleLastUsedTime(BaseCombatEntity entity)
        {
            if (entity is HotAirBalloon)
                return (entity as HotAirBalloon).lastBlastTime;

            if (entity is MiniCopter)
                return (entity as MiniCopter).lastEngineTime;

            if (entity is ModularCar)
                return (entity as ModularCar).lastEngineTime;


            if (entity is BaseVehicleModule)
            {
                var car = (entity as BaseVehicleModule).Vehicle as ModularCar;
                if (car != null)
                    return car.lastEngineTime;
            }

            return -1;
        }

        #endregion

        #region Configuration

        protected override void LoadDefaultConfig() => Config.WriteObject(new VehicleDecayConfig(), true);

        internal class VehicleDecayConfig
        {
            [JsonProperty("Vehicles")]
            public VehicleConfigMap Vehicles = new VehicleConfigMap();
        }

        internal class VehicleConfigMap
        {
            [JsonProperty("HotAirBalloon")]
            public VehicleConfig HotAirBalloon = new VehicleConfig();

            [JsonProperty("Minicopter")]
            public VehicleConfig Minicopter = new VehicleConfig();

            [JsonProperty("ModularCar")]
            public VehicleConfig ModularCar = new VehicleConfig();

            [JsonProperty("RHIB")]
            public VehicleConfig RHIB = new VehicleConfig();

            [JsonProperty("Rowboat")]
            public VehicleConfig Rowboat = new VehicleConfig();

            [JsonProperty("ScrapTransportHelicopter")]
            public VehicleConfig ScrapTransportHelicopter = new VehicleConfig();
        }

        internal class VehicleConfig
        {
            [JsonProperty("DecayMultiplierNearTC")]
            public float DecayMultiplierNearTC = 1;

            [JsonProperty("ProtectionMinutesAfterUse")]
            public float ProtectionMinutesAfterUse = 10;
        }

        #endregion
    }
}


// --- End of file: VehicleDecayProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NameRewards.cs ---
// --- Original Local Path: NameRewards.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("NameRewards", "Fierrov", "1.1.1")]
    [Description("Powered by humans from Fierrov")]
    class NameRewards : CovalencePlugin
    {
        #region Vars⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private PluginConfig _config;
        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private class PluginConfig
        {
            [JsonProperty("Варианты текста, который должен быть в нике")]
            public List<string> Texts = new List<string>();
            [JsonProperty("Использовать регулярные выражения")]
            public bool UseRegex;
            [JsonProperty("Не учитывать регистр")]
            public bool IgnoreCase;
            [JsonProperty("Оповещать о получении привилегий/необходимости добавления текста")]
            public bool Notify;
            [JsonProperty("Формат сообщений в чате")]
            public string ChatFormat;
            [JsonProperty("Привилегии, которые будут выданы")]
            public List<string> Permissions;
            [JsonProperty("Группы, в которые игрок будет добавлен")]
            public List<string> Groups;
            
            public struct Message
            {
                public string LangKey;
                public object[] Args;

                public Message(string langKey, params object[] args)
                {
                    LangKey = langKey;
                    Args = args;
                }
            }

            public Message AvailableOptions()
            {
                switch (Texts.Count)
                {
                    case 0:
                        return default(Message);
                    case 1:
                        return new Message("Not", Texts[0]);
                    default: 
                        var result = $"\"{Texts[0]}\"";
                        for (var i = 1; i < Texts.Count-1; i++)
                        {
                            result += $", \"{Texts[i]}\"";
                        }

                        return new Message("NotMulti", result, $"\"{Texts[Texts.Count-1]}\"");
                }
            }

            [JsonIgnore]
            private Func<string, string, bool> _check;
            
            [JsonIgnore]
            private Func<string, string, bool> Check
            {
                get
                {
                    if (_check != null) 
                        return _check;

                    if (!UseRegex)
                    {
                        if (IgnoreCase)
                            _check = (x, y) => x.IndexOf(y, StringComparison.InvariantCultureIgnoreCase) != -1;
                        else
                            _check = (x, y) => x.Contains(y);
                    }
                    else
                    {
                        if (IgnoreCase)
                            _check = (x, y) => Regex.IsMatch(x, y, RegexOptions.IgnoreCase);
                        else
                            _check =  Regex.IsMatch;
                    }
                    return _check;
                }

            }
            
            #region Default Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static PluginConfig DefaultConfig => new PluginConfig
            {
                Texts = new List<string>{"Лучший сервер!"},
                Notify = true,
                IgnoreCase = true,
                UseRegex = false,
                ChatFormat = "[#green][NameRewards][/#] {0}",
                Permissions = new List<string> { "kits.nickname", "nteleportation.nickname" },
                Groups = new List<string> { "nickname" }
            };

            #endregion

            public bool IsMatch(string text, out string found)
            {
                found = null;
                foreach (var pattern in Texts)
                {
                    if(!Check(text,pattern))
                        continue;
                    found = pattern;
                    return true;
                }
                return false;
            }
        }
        #endregion

        #region Config init⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        private bool CheckConfig()
        {
            var res = false;

            //==version < 1.1.0==
            var oldText = Config.Get("Текст, который должен быть в нике") as string;
            if (oldText != null)
            {
                PrintWarning("Config file updated: multiple texts support, regex and case-insensitive switches added");
                Config.Clear();
                _config.UseRegex = false;
                _config.IgnoreCase = true;
                _config.Texts.Add(oldText);
                res = true;
            }

            return res;
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобретение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            _config = PluginConfig.DefaultConfig;
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            if (CheckConfig()) 
                SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion

        #region Localization⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void SendResponse(IPlayer player, string langKey, params object[] args)
        {
            var format = GetMsg(langKey, player.Id);
            format = args.Length != 0 ? string.Format(format, args) : format;
            player.Reply(string.Format(_config.ChatFormat,format)); 
        }
        private string GetMsg(string key, string playerid) => lang.GetMessage(key, this, playerid);

        private string GetMsg(string key, ulong playerid = 4362240) =>
            GetMsg(key, playerid == 0 ? null : playerid.ToString());

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Granted"] = "You have \"{0}\" in your nickname! Enjoy your gifts!",
                ["Not"] = "You don't have \"{0}\" in your nickname!\nIf you want to get free gifts - add it to the nickanme and reconnect to the server!",
                ["NotMulti"] = "You don't have {0} or {1} in your nickname!\nIf you want to get free gifts - add it to the nickanme and reconnect to the server!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Granted"] = "У вас в нике есть текст \"{0}\"!\nНаслаждайтесь вашими привилегиями!",
                ["Not"] = "У вас в нике нет текста \"{0}\"!\nЕсли вы хотите получить подарки - добавьте этот текст к нику и перезайдите на сервер!",
                ["NotMulti"] = "У вас в нике нет текста {0} или {1}!\nЕсли вы хотите получить подарки - добавьте этот текст к нику и перезайдите на сервер!"
            }, this, "ru");
        }
        #endregion

        private void Init()
        {
            foreach (var player in covalence.Players.Connected)
            {
                OnUserConnected(player);
            }
        }

        private void OnUserConnected(IPlayer player)
        {
            string found;
            if (_config.IsMatch(player.Name, out found))
            {
                Grant(player);
                if(_config.Notify)
                    SendResponse(player,"Granted",found);
                return;
            }
            Revoke(player);
            if (_config.Notify)
            {
                var message = _config.AvailableOptions();
                if (string.IsNullOrEmpty(message.LangKey))
                    return;
                SendResponse(player,message.LangKey,message.Args);
            }
        }

        #region Grant|Revoke methods⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void Grant(IPlayer player)
        {
            foreach(var perm in _config.Permissions)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"Permission \"{perm}\" doesn't exists and wasn't granted to the player \"{player.Name}\"");
                    continue;
                }
                player.GrantPermission(perm);
            }
            foreach(var group in _config.Groups)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"Group \"{group}\" doesn't exists and the player \"{player.Name}\" wasn't added to it.");
                    continue;
                }
                player.AddToGroup(group);
            }
        }
        private void Revoke(IPlayer player)
        {
            foreach (var perm in _config.Permissions)
            {
                if (!permission.PermissionExists(perm))
                {
                    PrintWarning($"Permission \"{perm}\" doesn't exists and wasn't removed form the player \"{player.Name}\"");
                    continue;
                }
                player.RevokePermission(perm);
            }
            foreach (var group in _config.Groups)
            {
                if (!permission.GroupExists(group))
                {
                    PrintWarning($"Group \"{group}\" doesn't exists and the player \"{player.Name}\" wasn't removed from it.");
                    continue;
                }
                player.RemoveFromGroup(group);
            }
        }
        #endregion
    }
}


// --- End of file: NameRewards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Loyalty.cs ---
// --- Original Local Path: Loyalty.cs ---

using System.Collections.Generic;
using Oxide.Core;
using System;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Loyalty", "Bamabo", "1.3.1")]
    [Description("Reward your players for play time with new permissions/usergroups")]

    class Loyalty : RustPlugin
    {
        Data data;

        #region Classes
        class Data
        {
            public Dictionary<ulong, Player> players = new Dictionary<ulong, Player>();
            public HashSet<UserGroup> usergroups = new HashSet<UserGroup>();
            public HashSet<LoyaltyReward> rewards = new HashSet<LoyaltyReward>();

            public Data() { }
        }

        public class LoyaltyReward
        {
            public string alias { get; set; }
            public string permission { get; set; }
            public uint requirement { get; set; }

            public LoyaltyReward() { alias = null; permission = null; requirement = 0; }

            public LoyaltyReward(string alias, string permission, uint requirement = 0)
            {
                this.alias = alias;
                this.permission = permission;
                this.requirement = requirement;
            }
        }
        public class Player
        {
            public string name { get; set; }
            public ulong id { get; set; }
            public uint loyalty { get; set; }
            public string group { get; set; }

            public Player() { }

            public Player(ulong id, string name, uint loyalty = 0, string group = "")
            {
                this.id = id;
                this.name = name;
                this.loyalty = loyalty;
                this.group = group;
            }
            public override bool Equals(object obj)
            {
                Player pItem = obj as Player;
                return pItem.GetHashCode() == this.GetHashCode();
            }

            public override int GetHashCode()
            {
                return (int)this.id;
            }

        }
        public class UserGroup
        {
            public string usergroup { get; set; }
            public uint requirement { get; set; }

            public UserGroup() { usergroup = ""; requirement = 0; }
            public UserGroup(string usergroup, uint requirement = 0)
            {
                this.usergroup = usergroup;
                this.requirement = requirement;
            }
        }
        #endregion Classes

        #region Hooks
        void Init()
        {
            RegisterMessages();
            RegisterPermissions();
        }

        void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.ReadObject<Data>("LoyaltyData");
            timer.Repeat(Convert.ToSingle(Config["rate"]), 0, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if ((player.IsAdmin() && (bool)Config["allowAdmin"]) || !player.IsAdmin())
                    {
                        if (!data.players.ContainsKey(player.userID))
                            data.players.Add(player.userID, new Player(player.userID, player.displayName, 1, ""));
                        else
                        {
                            data.players[player.userID].name = player.displayName;
                            data.players[player.userID].loyalty += 1;
                            foreach (var reward in data.rewards)
                            {
                                if (data.players[player.userID].loyalty == reward.requirement)
                                {
                                    if (!reward.permission.StartsWith("\"-"))
                                    {
                                        rust.RunServerCommand("grant user " + rust.QuoteSafe(player.displayName) + " " + reward.permission);
                                        SendMessage(player, "accessGranted", reward.requirement, Config["serverName"].ToString(), reward.alias);
                                        if ((bool)Config["debug"])
                                            Puts("Player: " + player.displayName + " gained access to " + reward.permission + " by reaching " + reward.requirement + " loyalty points.");
                                    }
                                    else
                                    {
                                        rust.RunServerCommand("revoke user " + rust.QuoteSafe(player.displayName) + " " + reward.permission.Replace('-', ' ').Trim());
                                        SendMessage(player, "accessLostSpecific", reward.requirement, reward.alias);
                                        if ((bool)Config["debug"])
                                            Puts("Player: " + player.displayName + " lost access to " + reward.permission + " by reaching " + reward.requirement + " loyalty points.");
                                    }

                                }
                            }
                            foreach (var usergroup in data.usergroups)
                            {
                                if (data.players[player.userID].loyalty == usergroup.requirement)
                                {
                                    if (!usergroup.usergroup.StartsWith("\"-"))
                                    {
                                        rust.RunServerCommand("usergroup add " + rust.QuoteSafe(player.displayName) + " " + usergroup.usergroup);
                                        if (!String.IsNullOrEmpty(data.players[player.userID].group))
                                            rust.RunServerCommand("usergroup remove " + rust.QuoteSafe(player.displayName) + " " + data.players[player.userID].group);

                                        data.players[player.userID].group = usergroup.usergroup;
                                        SendMessage(player, "groupAssigned", usergroup.requirement, Config["serverName"].ToString(), usergroup.usergroup);
                                    }
                                    else
                                    {
                                        rust.RunServerCommand("usergroup remove " + rust.QuoteSafe(player.displayName) + " " + usergroup.usergroup.Replace('-', ' ').Trim());
                                    }

                                }
                            }
                        }
                    }
                }
                Interface.Oxide.DataFileSystem.WriteObject("LoyaltyData", data);
                if ((bool)Config["debug"])
                    Puts("Assigned every online player 1 loyalty point.");
            });
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("LoyaltyData", data);
        }

        void OnPlayerInit(BasePlayer player)
        {

            if ((player.IsAdmin() && (bool)Config["allowAdmin"]) || !player.IsAdmin())
            {
                if (!data.players.ContainsKey(player.userID))
                {
                    data.players.Add(player.userID, new Player(player.userID, player.displayName, 0));
                    Interface.Oxide.DataFileSystem.WriteObject("LoyaltyData", data);
                }
                if ((bool)Config["debug"])
                    Puts("Player: " + player.displayName + " connected for the first time and got added into data.");
            }
        }

        #endregion Hooks

        #region MainCommand
        [ChatCommand("loyalty")]
        void CmdLoyalty(BasePlayer sender, string command, string[] args)
        {
            if (args.Length == 0)
                if (permission.UserHasPermission(sender.UserIDString, "loyalty.loyalty") || sender.IsAdmin())
                {
                    if (data.players.ContainsKey(sender.userID))
                        SendMessage(sender, "loyaltyCurrent", data.players[sender.userID].loyalty, Config["serverName"]);
                    else
                        SendErrorMessage(sender, "errorNoLoyalty");
                    return;
                }
                else
                    SendErrorMessage(sender, "accessDenied");

            if (args.Length > 0)
            {
                switch (args[0].ToLower())
                {
                    case "add":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.add") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length < 4)
                        {
                            SendErrorMessage(sender, "syntaxAdd");
                            return;
                        }
                        string alias = "";
                        for (int i = 3; i < args.Length; i++)
                            alias += args[i] + " ";
                        CmdAdd(sender, args[1], args[2], alias);
                        break;

                    case "remove":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.remove") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 2)
                        {
                            SendErrorMessage(sender, "syntaxRemove");
                            return;
                        }
                        CmdRemove(sender, args[1]);
                        break;
                    case "removeg":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.removegroup") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 2)
                        {
                            SendErrorMessage(sender, "syntaxRemoveGroup");
                            return;
                        }
                        CmdRemoveUserGroup(sender, args[1]);
                        break;
                    case "reset":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.reset") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 2)
                        {
                            SendErrorMessage(sender, "syntaxReset");
                            return;
                        }
                        CmdReset(sender, args[1]);
                        break;

                    case "set":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.set") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 3)
                        {
                            SendErrorMessage(sender, "syntaxSet");
                            return;
                        }
                        CmdSet(sender, args[1], args[2]);
                        break;
                    case "help":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.help") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 1)
                        {
                            SendErrorMessage(sender, "syntaxHelp");
                            return;
                        }
                        SendMessage(sender, "help");
                        break;

                    case "lookup":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.lookup") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 2)
                        {
                            SendErrorMessage(sender, "syntaxLookup");
                            return;
                        }
                        CmdLookup(sender, args[1]);
                        break;

                    case "top":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.top") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 1)
                        {
                            SendErrorMessage(sender, "syntaxTop");
                            return;
                        }
                        CmdTop(sender);
                        break;
                    case "addg":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.addgroup") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 3)
                        {
                            SendErrorMessage(sender, "syntaxAddGroup");
                            return;
                        }
                        CmdAddUserGroup(sender, args[1], args[2]);
                        break;
                    case "rewards":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.rewards") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 1)
                        {
                            SendErrorMessage(sender, "syntaxRewards");
                            return;
                        }
                        CmdRewards(sender);
                        break;
                    case "rewardsg":
                        if (!permission.UserHasPermission(sender.UserIDString, "loyalty.rewardsg") && !sender.IsAdmin())
                        {
                            SendErrorMessage(sender, "accessDenied");
                            return;
                        }
                        if (args.Length != 1)
                        {
                            SendErrorMessage(sender, "syntaxRewardsg");
                            return;
                        }
                        CmdRewardsg(sender);
                        break;
                    default:
                        SendErrorMessage(sender, "errorNoCommand", args[0]);
                        break;
                };
            }
        }
        #endregion MainCommand

        #region Subcommands

        void CmdAdd(BasePlayer sender, string req, string perm, string alias)
        {
            if (!Regex.IsMatch(req, "^\\d+$"))
            {
                SendErrorMessage(sender, "syntaxNotInt", 1);
                return;
            }

            if (RewardExists(rust.QuoteSafe(perm)))
            {
                SendErrorMessage(sender, "rewardExists", perm);
                return;
            }

            if (!permission.PermissionExists(perm.Trim('-')))
            {
                SendErrorMessage(sender, "unregisteredPerm", perm.Replace('-', ' ').Trim());
                return;
            }

            data.rewards.Add(new LoyaltyReward(rust.QuoteSafe(alias), rust.QuoteSafe(perm), Convert.ToUInt32(req, 10)));
            Interface.Oxide.DataFileSystem.WriteObject("LoyaltyData", data);

            SendMessage(sender, "successAdd", Convert.ToUInt32(req, 10), perm, alias);
        }
        void CmdRemove(BasePlayer sender, string permission)
        {
            if (!RewardExists(rust.QuoteSafe(permission)))
            {
                SendErrorMessage(sender, "rewardNoExist", permission);
                return;
            }
            foreach (LoyaltyReward reward in data.rewards)
                if (reward.permission == rust.QuoteSafe(permission))
                {
                    data.rewards.Remove(reward);
                    Interface.Oxide.DataFileSystem.WriteObject("LoyaltyData", data);
                    SendMessage(sender, "rewardRemoved", permission);
                    return;
                }
        }

        void CmdReset(BasePlayer sender, string playerName)
        {
            Player player = data.players.Values.FirstOrDefault(x => x.name.StartsWith(playerName, StringComparison.CurrentCultureIgnoreCase));
            if (player == null)
            {
                SendErrorMessage(sender, "errorPlayerNotFound", playerName);
                return;
            }

            data.players[player.id].loyalty = 0;
            foreach (var reward in data.rewards)
                rust.RunServerCommand("revoke user " + rust.QuoteSafe(player.name) + " " + reward.permission.Replace('-', ' ').Trim());
            foreach (var group in data.usergroups)
                rust.RunServerCommand("usergroup remove " + rust.QuoteSafe(player.name) + " " + group.usergroup.Replace('-', ' ').Trim());
            player.group = "";

            SendMessage(BasePlayer.FindByID(player.id), "loyaltyReset");
            SendMessage(sender, "successReset", player.name);
        }
        void CmdSet(BasePlayer sender, string playerName, string newLoyalty)
        {
            Player player = data.players.Values.FirstOrDefault(x => x.name.StartsWith(playerName, StringComparison.CurrentCultureIgnoreCase));

            if (player == null)
            {
                SendErrorMessage(sender, "errorPlayerNotFound", playerName);
                return;
            }
            if (!Regex.IsMatch(newLoyalty, "^\\d+$"))
            {
                SendErrorMessage(sender, "syntaxNotInt", 2);
                return;
            }

            uint newLoy = Convert.ToUInt32(newLoyalty, 10);

            foreach (var reward in data.rewards)
            {
                if (newLoy >= reward.requirement)
                {
                    if (reward.permission.StartsWith("\"-"))
                        rust.RunServerCommand("revoke user " + rust.QuoteSafe(player.name) + " " + reward.permission.Replace('-', ' ').Trim());
                    else
                        rust.RunServerCommand("grant user " + rust.QuoteSafe(player.name) + " " + reward.permission.Replace('-', ' ').Trim());

                }
                else
                {
                    rust.RunServerCommand("revoke user " + rust.QuoteSafe(player.name) + " " + reward.permission.Replace('-', ' ').Trim());
                }
            }
            SendMessage(BasePlayer.FindByID(player.id), "accessLost", newLoyalty);

            if (!String.IsNullOrEmpty(player.group) && player.group.Equals("") && player.group.Equals(" "))
            {
                rust.RunServerCommand("usergroup remove " + rust.QuoteSafe(player.name) + " " + player.group);
            }
            var newGroup = (from entry in data.usergroups where entry.requirement <= newLoy orderby entry.requirement descending select entry).FirstOrDefault();
            if (newGroup != null)
            {
                if (newGroup.usergroup.Trim().StartsWith("\"-"))
                {
                    rust.RunServerCommand("usergroup remove " + rust.QuoteSafe(player.name) + " " + newGroup.usergroup.Replace('-', ' ').Trim());
                    if (newGroup.usergroup.TrimStart('-') == data.players[player.id].group)
                        data.players[player.id].group = "";
                }
                else
                {
                    rust.RunServerCommand("usergroup add " + rust.QuoteSafe(player.name) + " " + newGroup.usergroup.Replace('-', ' ').Trim());
                    data.players[player.id].group = newGroup.usergroup;
                }
            }


            data.players[player.id].loyalty = newLoy;
            SendMessage(sender, "successSet", player.name, newLoy);

        }
        void CmdLookup(BasePlayer sender, string player)
        {
            Player lookUpPlayer = data.players.Values.FirstOrDefault(x => x.name.StartsWith(player, StringComparison.CurrentCultureIgnoreCase));
            if (lookUpPlayer != null)
                SendMessageFromID(sender, "entryLookup", lookUpPlayer.id, lookUpPlayer.name, data.players[lookUpPlayer.id].loyalty);
            else
            {
                SendErrorMessage(sender, "errorPlayerNotFound", player);
                return;
            }
        }
        void CmdTop(BasePlayer sender)
        {
            var topList = (from entry in data.players orderby entry.Value.loyalty descending select entry).Take(10);
            int counter = 0;
            SendMessage(sender, "topMessage", topList.Count(), data.players.Count());

            foreach (var entry in topList)
                SendMessageFromID(sender, "entryTop", entry.Value.id, ++counter, entry.Value.name, entry.Value.loyalty);
        }

        void CmdRewards(BasePlayer sender)
        {
            var rewards = (from entry in data.rewards orderby entry.requirement ascending where entry.requirement > data.players[sender.userID].loyalty select entry).Take(5);
            if (rewards.Count() > 0)
            {
                SendMessage(sender, "rewardsMessage", rewards.Count());
                foreach (var entry in rewards)
                    SendMessage(sender, "entryRewards", entry.requirement, entry.alias);
            }
            else
                SendMessage(sender, "rewardsNoMoreRewards");
        }
        void CmdRewardsg(BasePlayer sender)
        {
            var rewards = (from entry in data.usergroups orderby entry.requirement ascending where entry.requirement > data.players[sender.userID].loyalty select entry).Take(5);
            if (rewards.Count() > 0)
            {
                SendMessage(sender, "rewardsgMessage", rewards.Count());
                foreach (var entry in rewards)
                    SendMessage(sender, "entryRewards", entry.requirement, entry.usergroup);
            }
            else
                SendMessage(sender, "rewardsNoMoreRewards");
        }
        void CmdAddUserGroup(BasePlayer sender, string requirement, string usergroup)
        {
            if (!Regex.IsMatch(requirement, "^\\d+$"))
            {
                SendErrorMessage(sender, "syntaxNotInt", 1);
                return;
            }

            if (UserGroupExists(rust.QuoteSafe(usergroup)))
            {
                SendErrorMessage(sender, "groupExists", usergroup);
                return;
            }

            if (!permission.GroupExists(usergroup.TrimStart('-')))
            {
                SendErrorMessage(sender, "unregisteredGroup", usergroup.Replace('-', ' ').Trim());
                return;
            }

            data.usergroups.Add(new UserGroup(rust.QuoteSafe(usergroup), Convert.ToUInt32(requirement, 10)));
            Interface.Oxide.DataFileSystem.WriteObject("LoyaltyData", data);

            SendMessage(sender, "successAddGroup", Convert.ToUInt32(requirement, 10), rust.QuoteSafe(usergroup));
        }
        void CmdRemoveUserGroup(BasePlayer sender, string usergroup)
        {
            if (!UserGroupExists(rust.QuoteSafe(usergroup)))
            {
                SendErrorMessage(sender, "groupNoExists", usergroup);
                return;
            }
            foreach (UserGroup usergroupEntry in data.usergroups)
                if (usergroupEntry.usergroup == rust.QuoteSafe(usergroup))
                {
                    data.usergroups.Remove(usergroupEntry);
                    Interface.Oxide.DataFileSystem.WriteObject("LoyaltyData", data);
                    SendMessage(sender, "groupRemoved", usergroup);
                    return;
                }
        }

        #endregion Subcommands

        #region Helpers
        void SendMessage(BasePlayer receiver, string messageID, params object[] args)
        {
            string message;
            if (args.Length > 0)
            {
                object[] arr = new object[args.Length + 1];
                arr[0] = Config["colorHighlight"].ToString();
                for (int i = 1; i < args.Length + 1; i++)
                    arr[i] = args[i - 1];
                message = String.Format(lang.GetMessage(messageID, this), arr);
            }
            else
            {
                message = String.Format(lang.GetMessage(messageID, this), Config["colorHighlight"].ToString());
            }
            rust.SendChatMessage(receiver, "<color=" + Config["colorText"] + ">" + message + "</color>", null, Config["serverIconID"].ToString());
        }
        void SendErrorMessage(BasePlayer receiver, string messageID, params object[] args)
        {
            string message;
            if (args.Length > 0)
            {
                object[] arr = new object[args.Length + 1];
                arr[0] = Config["colorHighlight"].ToString();
                for (int i = 1; i < args.Length + 1; i++)
                    arr[i] = args[i - 1];
                message = String.Format(lang.GetMessage(messageID, this), arr);
            }
            else
            {
                message = String.Format(lang.GetMessage(messageID, this), Config["colorHighlight"].ToString());
            }
            rust.SendChatMessage(receiver, "<color=" + Config["colorError"] + ">" + message + "</color>", null, Config["serverIconID"].ToString());
        }
        void SendMessageFromID(BasePlayer receiver, string messageID, ulong senderID, params object[] args)
        {
            string message;
            if (args.Length > 0)
            {
                object[] arr = new object[args.Length + 1];
                arr[0] = Config["colorHighlight"].ToString();
                for (int i = 1; i < args.Length + 1; i++)
                    arr[i] = args[i - 1];
                message = String.Format(lang.GetMessage(messageID, this), arr);
            }
            else
            {
                message = String.Format(lang.GetMessage(messageID, this), Config["colorHighlight"].ToString());
            }
            rust.SendChatMessage(receiver, "<color=" + Config["colorText"] + ">" + message + "</color>", null, senderID.ToString());
        }
        string FormatMessage(string messageID, params object[] args)
        {
            return String.Format(lang.GetMessage(messageID, this), args);
        }

        bool RewardExists(string permission)
        {
            foreach (LoyaltyReward reward in data.rewards)
                if (reward.permission == permission)
                    return true;

            return false;
        }
        bool UserGroupExists(string usergroup)
        {
            foreach (UserGroup usergEntry in data.usergroups)
                if (usergEntry.usergroup == usergroup)
                    return true;

            return false;
        }

        void RegisterMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["syntaxAdd"] = "Too few or too many arguments. \nUse <color={0}>/loyalty add [int: req] [string: perm.perm] [string: /alias]</color>",
                ["syntaxRemove"] = "Too few or too many arguments. \nUse <color={0}>/loyalty remove [string: perm.perm]</color>",
                ["syntaxRemoveGroup"] = "Too few or too many arguments.\nUse <color={0}>/loyalty removeg [string: loyaltyGroup]</color>",
                ["syntaxSet"] = "Too few or too many arguments. \nUse <color={0}>/loyalty set [string: name] [int: loyaltyPoints]</color>",
                ["syntaxReset"] = "Too few or too many arguments. \nUse <color={0}>/loyalty reset [string: name]</color>",
                ["syntaxHelp"] = "Too few or too many arguments. \nUse <color={0}>/loyalty help</color>",
                ["syntaxLookup"] = "Too few or too many arguments. \nUse <color={0}>/loyalty lookup [string: name]</color>",
                ["syntaxTop"] = "Too few or too many arguments. \nUse <color={0}>/loyalty top</color>",
                ["syntaxRewards"] = "Too few or too many arguments.\nUse <color={0}>/loyalty rewards</color>",
                ["syntaxRewardsg"] = "Too few or too many arguments.\nUse <color={0}>/loyalty rewardsg</color>",
                ["syntaxAddGroup"] = "Too few or too many arguments. \nUse <color={0}>/loyalty addg [int: req] [string: group]</color>",
                ["syntaxNotInt"] = "Invalid syntax. Parameter <color={0}>#{1}</color> needs to be a positive integer.",
                ["rewardExists"] = "A reward for the permission <color={0}>{1}</color> already exists.",
                ["rewardNoExist"] = "No reward for the permission <color={0}>{1}</color> was found.",
                ["rewardRemoved"] = "Loyalty reward <color={0}>{1}</color> was successfully removed.",
                ["accessGranted"] = "Congratulations, by spending <color={0}>{1} minutes</color> on <color={0}>{2}</color> you have gained access to the command <color={0}>{3}</color>. Thank you for playing!",
                ["accessDenied"] = "You do not have access to that command.",
                ["accessLost"] = "Your loyalty was changed to <color={0}>{1}</color> by an admin. You have lost and/or gained access to loyalty rewards accordingly.",
                ["accessLostSpecific"] = "By reaching <color={0}>{1}</color> loyalty you have lost access to <color={0}>{2}</color>",
                ["loyaltyCurrent"] = "You have accumulated a total of <color={0}>{1}</color> loyalty points by playing on <color={0}>{2}</color>",
                ["loyaltyReset"] = "Your loyalty has been reset by an administrator. You have lost access to all commands and/or groups your previously had access to.",
                ["errorNoLoyalty"] = "You have not yet earned any loyalty points. Check again in a minute!",
                ["errorNoCommand"] = "No command <color={0}>{1}</color> was found.",
                ["errorPlayerNotFound"] = "No player by the name <color={0}>{1}</color> was found.",
                ["errorNoPlusMinus"] = "Your usergroup needs to start with <color={0}>'+'</color> or <color={0}>'-'</color>.",
                ["errorFatal"] = "FATAL ERROR. If you see this something has gone terribly wrong.",
                ["stylingMessage"] = "{0}",
                ["stylingSender"] = "<color=lime>{0}</color>",
                ["successSet"] = "Player <color={0}>{1}'s</color> loyalty points were successfully set to <color={0}>{2}</color>.",
                ["successReset"] = "Player <color={0}>{1}'s</color> loyalty points were successfully reset.",
                ["successAdd"] = "Permission reward: <color={0}>[req: {1}, perm: {2}, alias: {3}]</color> successfully added.",
                ["successAddGroup"] = "Usergroup reward: <color={0}>[req: {1}, usergroup: {2}]</color> successfully added.",
                ["topMessage"] = "Top <color={0}>{1}</color> most loyal players out of the total <color={0}>{2}</color>",
                ["entryReward"] = "Req: {1} Perm: {2} Alias: {3}",
                ["entryTop"] = "{1}. <color={0}>{2}</color> - {3}",
                ["entryLookup"] = "<color={0}>{1}</color> has accumulated a total of <color={0}>{2}</color> loyalty points.",
                ["entryRewards"] = "<color={0}>{1} - {2}</color>",
                ["groupExists"] = "A loyalty reward for the usergroup <color={0}>{1}</color> already exists.",
                ["groupNoExists"] = "No group reward called <color={0}>{1}</color> was found.",
                ["groupRemoved"] = "Group reward <color={0}>{1}</color> was successfully removed.",
                ["groupChanged"] = "Your loyalty was set to <color={0}>{1}</color> by an admin. Your current group is: <color={0}>{2}</color>",
                ["groupAssigned"] = "Congratulations, by spending <color={0}>{1} minutes</color> on <color={0}>{2}</color> you have been assigned to the usergroup <color={0}>{3}</color>. Thank you for playing!",
                ["groupRevoked"] = "By reaching <color={0}>{1}</color> loyalty you have been removed from the group <color={0}>{2}</color>.",
                ["rewardsMessage"] = "Showing next <color={0}>{1}</color> loyalty rewards",
                ["rewardsgMessage"] = "Showing next <color={0}>{1}</color> usergroup rewards",
                ["rewardsNoMoreRewards"] = "There are no more rewards available for you to earn. Check again later!",
                ["unregisteredPerm"] = "No permission <color={0}>{1}</color> is registered by oxide. Make sure the plugin you are trying to add permissions for is loaded.",
                ["unregisteredGroup"] = "No usergroup <color={0}>{1}</color> is registered by oxide.",
                ["help"] = "<color={0}>Loyalty by Bamabo</color>\nLoyalty is a plugin that lets server owners reward their players with permissions according to how much time they've spent on the server. 1 Loyalty = 1 minute. \n<color={0}>/loyalty add/remove/set/reset/top/lookup/addg/removeg</color>\n More info and source on <color={0}>github.com/Hazzty/Loyalty</color>",
            }, this);
        }
        void RegisterPermissions()
        {
            permission.RegisterPermission("loyalty.loyalty", this);
            permission.RegisterPermission("loyalty.add", this);
            permission.RegisterPermission("loyalty.remove", this);
            permission.RegisterPermission("loyalty.reset", this);
            permission.RegisterPermission("loyalty.set", this);
            permission.RegisterPermission("loyalty.lookup", this);
            permission.RegisterPermission("loyalty.top", this);
            permission.RegisterPermission("loyalty.help", this);
            permission.RegisterPermission("loyalty.addgroup", this);
            permission.RegisterPermission("loyalty.removegroup", this);
            permission.RegisterPermission("loyalty.rewards", this);
            permission.RegisterPermission("loyalty.rewardsg", this);
        }

        #endregion Helpers

        #region Config
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file for Loyalty");
            Config.Clear();
            Config["allowAdmin"] = true;
            Config["colorError"] = "red";
            Config["colorHighlight"] = "yellow";
            Config["colorText"] = "#FFFFFF";
            Config["debug"] = false;
            Config["rate"] = 60.0;
            Config["serverName"] = "Default Server";
            Config["serverIconID"] = "76561198314979344";
            SaveConfig();
        }
        #endregion Config

    }

}

// --- End of file: Loyalty.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQFireSpear.cs ---
// --- Original Local Path: IQFireSpear.cs ---

﻿using System.Collections.Generic;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("IQFireSpear", "Sempai#3239", "0.0.1")]
    [Description("Огненное копье,при ударе есть шанс оставить искру,при броске поджигает под собой все")]
    class IQFireSpear : RustPlugin
    {
        [PluginReference] Plugin IQChat;

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("При поджигании копья,ломать его постепенно(true/false)")]
            public bool ConditionUse;
            [JsonProperty("SkinID для предмета(Пример : 2000653461)")]
            public ulong SkinID;
            [JsonProperty("DisplayName для предмета")]
            public string DisplayName;
            [JsonProperty("Shortname для предмета(обязательно , которое можно кинуть и нанести урон)")]
            public string Shortname;
            [JsonProperty("Шанс возгарания при ударе копьем в игрока")]
            public int RareFireDamagePlayer;
            [JsonProperty("Шанс возгарания при броске копья")]
            public int RareFireThrow;
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    ConditionUse = true,
                    SkinID = 2006575943,
                    Shortname = "spear.wooden",
                    DisplayName = "Огненное копье",
                    RareFireDamagePlayer = 10,
                    RareFireThrow = 100,
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #85" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию! 321!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Hooks

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null) return;
            if (info == null) return;

            if (info.damageProperties.name == "Damage.Throwable")
            {
                if (info.Weapon.skinID == config.SkinID)
                    if (config.RareFireThrow >= UnityEngine.Random.Range(0, 100))
                    {
                        BaseEntity FireBallArrow = GameManager.server.CreateEntity("assets/bundled/prefabs/fireball.prefab", info.HitPositionWorld);
                        FireBallArrow?.Spawn();
                    }
            }

            if (info.damageProperties.name == "Damage.Melee")
            {
                if (info.HitEntity == null) return;
                if (info.HitEntity.ShortPrefabName == "campfire")
                {
                    if (info.HitEntity.HasFlag(BaseEntity.Flags.On))
                    {
                        Item ActiveWeapon = info.Weapon.GetItem();
                        if (ActiveWeapon == null) return;
                        if (info.Weapon.skinID == config.SkinID) return;
                        if (ActiveWeapon.info.shortname != config.Shortname) return;

                        ActiveWeapon.name = config.DisplayName;
                        ActiveWeapon.skin = config.SkinID;
                        info.Weapon.skinID = config.SkinID;
                        if (config.ConditionUse)
                            timer.Every(1f, () => { ActiveWeapon.condition--; });
                        SendChat(lang.GetMessage("ON_FIRE", this), attacker);
                        return;
                    }
                }

                if (info.Weapon.skinID == config.SkinID)
                {
                    BasePlayer target = (BasePlayer)info.HitEntity;
                    if (target == null) return;
                    if (config.RareFireDamagePlayer >= UnityEngine.Random.Range(0, 100))
                    {
                        BaseEntity FireBallArrow = GameManager.server.CreateEntity("assets/bundled/prefabs/fireball.prefab", target.transform.position);
                        FireBallArrow?.Spawn();
                    }
                }
            }
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ON_FIRE"] = "Вы подожгли копье,теперь при броске этого копья ,место куда оно упадет загорится!",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ON_FIRE"] = "Вы подожгли копье,теперь при броске этого копья ,место куда оно упадет загорится!",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Helps
        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion
    }
}



// --- End of file: IQFireSpear.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BigBox.cs ---
// --- Original Local Path: BigBox.cs ---

namespace Oxide.Plugins
{
    [Info("BigBox", "Frizen", "1.0.0")]
    internal class BigBox : RustPlugin
    {
        private void OnServerInitialized()
        {
            var storages = UnityEngine.Object.FindObjectsOfType<StorageContainer>();

            foreach (StorageContainer storage in storages)
            {
                if (storage.name.Contains("box.wooden.large"))
                {
                    OnEntitySpawned(storage);
                }
            }
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;

            if (entity is StorageContainer && entity.name.Contains("box.wooden.large"))
            {
                StorageContainer storageContainer = entity as StorageContainer;

                if (storageContainer.panelName != "genericlarge")
                {
                    storageContainer.panelName = "genericlarge";

                    storageContainer.inventory.capacity = 42;

                    storageContainer.SendNetworkUpdate();
                }
            }
        }
    }
}

// --- End of file: BigBox.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FauxClip.cs ---
// --- Original Local Path: FauxClip.cs ---

using System;
using Rust;
using System.Reflection;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
     [Info("FauxClip", "Colon Blow", "1.3.6", ResourceId = 1299)]
     class FauxClip : RustPlugin
     {
	public float GracefulLandingTime => Config.Get<float>("GracefulLandingTime");
	public float BaseNoClipSpeed => Config.Get<float>("BaseNoClipSpeed");
	public float SprintNoClipSpeed => Config.Get<float>("SprintNoClipSpeed");
        public float TurboNoClipSpeed => Config.Get<float>("TurboNoClipSpeed");
	public bool UseFauxClipGodMode => Config.Get<bool>("UseFauxClipGodMode");

        protected override void LoadDefaultConfig()
        {
            	Config["GracefulLandingTime"] = 3;
	    	Config["BaseNoClipSpeed"] = .12;
	    	Config["SprintNoClipSpeed"] = .24;
	    	Config["TurboNoClipSpeed"] = 1;
		Config["UseFauxClipGodMode"] = true;
		
            SaveConfig();
        }

        class PlayerData
        {
             public BasePlayer player;
             public float speed;
             public Vector3 oldPos;
             public InputState input;
        }

        class LandingData
        {
             public BasePlayer player;
        }

        private readonly Dictionary<ulong, PlayerData> _noclip = new Dictionary<ulong, PlayerData>();
	private readonly Dictionary<ulong, LandingData> _landing = new Dictionary<ulong, LandingData>();
        private static readonly FieldInfo ServerInput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        public static FieldInfo lastPositionValue;

        void Loaded()
        {
        permission.RegisterPermission("fauxclip.allowed", this);
	permission.RegisterPermission("fauxclip.norestriction", this);
	permission.RegisterPermission("fauxclip.canuseturbo", this);
        lastPositionValue = typeof(BasePlayer).GetField("lastPositionValue", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }

         void OnFrame()
         {

             if (_noclip.Count <= 0) return;
             foreach (var playerData in _noclip.Values)
             {
                var player = playerData.player;
		player.violationLevel = 0;
		if (noBuild(player) & (noAdmin(player) & (!isAllowed(player, "fauxclip.norestriction"))))
		{
                        Restrictedairspace(player);
            		return;
            	}

                if (player.net == null)
            	{
                        Deactivatenoclip(player);
            		return;
            	}
                else
                {          
                     var input = playerData.input;
                     var newPos = playerData.oldPos;
		     var currentRot = Quaternion.Euler(input.current.aimAngles);
                     var speedMult = playerData.speed;

                     if (input.IsDown(BUTTON.SPRINT))
                        speedMult = SprintNoClipSpeed;

                     if (input.IsDown(BUTTON.USE) & (isAllowed(player, "fauxclip.canuseturbo")))
                        speedMult = TurboNoClipSpeed;
  
             	     else if (input.IsDown(BUTTON.RELOAD))
             	     {
                        Deactivatenoclip(player);
            		return;
             	     }  
                     else if (input.IsDown(BUTTON.JUMP))
                     {
                         newPos += (currentRot * Vector3.up * speedMult);
                     }   
                     else if (input.IsDown(BUTTON.FORWARD))
                     {
                         newPos += (currentRot * Vector3.forward * speedMult);
                     }
                     else if (input.IsDown(BUTTON.RIGHT))
                     {
                         newPos += (currentRot * Vector3.right * speedMult);
                     }
                     else if (input.IsDown(BUTTON.LEFT))
                     {
                         newPos += (currentRot * Vector3.left * speedMult);
                     }
                     else if (input.IsDown(BUTTON.BACKWARD))
                     {
                         newPos += (currentRot * Vector3.back * speedMult);
                     }  
                     else if (!input.IsDown(BUTTON.FORWARD))
             	     {
             		ForcePlayerPosition(player, newPos);
                     } 
                     else
                      newPos = player.transform.position;          
                      if (newPos == playerData.oldPos) continue;
                      ForcePlayerPosition(player, newPos);
                      playerData.oldPos = newPos;
                      player.TransformChanged();
                 }
             }
         }

	bool noAdmin(BasePlayer player)
		{
		if (player.IsAdmin()) return false;
		return true;
		}
	bool noBuild(BasePlayer player)
		{
		if (player.CanBuild()) return false;
		return true;
		}
	void DamageOn(BasePlayer player)
        	{
		player.metabolism.heartrate.min = 0;
                player.metabolism.heartrate.max = 1;
                player.metabolism.temperature.min = -100;
                player.metabolism.temperature.max = 100;
                player.metabolism.radiation_level.min = 0;
                player.metabolism.radiation_level.max = 100;
                player.metabolism.radiation_poison.min = 0;
                player.metabolism.radiation_poison.max = 500;
                player.metabolism.wetness.min = 0;
                player.metabolism.wetness.max = 1;
               	player.metabolism.dirtyness.min = 0;
                player.metabolism.dirtyness.max = 100;
                player.metabolism.oxygen.min = 0;
                player.metabolism.oxygen.max = 1;
		player.metabolism.bleeding.min = 0;
                player.metabolism.bleeding.max = 1;
                player.metabolism.comfort.min = 0;
               	player.metabolism.comfort.max = 1;
		return;
		}
	void DamageOff(BasePlayer player)
		{
			if (!UseFauxClipGodMode) return;

			foreach (var playerData in _noclip.Values)
			{
                	player.metabolism.heartrate.min = 0.5f;
                	player.metabolism.heartrate.max = 0.5f;
                	player.metabolism.temperature.min = 32;
                	player.metabolism.temperature.max = 32;
                	player.metabolism.radiation_level.min = 0;
                	player.metabolism.radiation_level.max = 0;
                	player.metabolism.radiation_poison.max = 0;
                	player.metabolism.wetness.min = 0;
                	player.metabolism.wetness.max = 0;
                	player.metabolism.dirtyness.min = 0;
                	player.metabolism.dirtyness.max = 0;
                	player.metabolism.oxygen.min = 1;
                	player.metabolism.oxygen.max = 1;
                	player.metabolism.bleeding.min = 0;
                	player.metabolism.bleeding.max = 0;
                	player.metabolism.comfort.min = 0;
			player.metabolism.comfort.max = 0;
			return;
			}
		}

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        	{
			if (!UseFauxClipGodMode) return null;

			if (UseFauxClipGodMode)
			{
				if (entity is BasePlayer)
				{
					var player = (BasePlayer)entity;
					if (_noclip.ContainsKey(player.userID))
					{
                   			return false;
					}
					if (_landing.ContainsKey(player.userID))
					{
                   			return false;
					}
				}
			}
		return null;
        	}

         void Deactivatenoclip(BasePlayer player)
         	{
		_noclip.Remove(player.userID);
		SendReply(player, "NoClip Deactivated");
		_landing.Add(player.userID, new LandingData
		{
		player = player
		});
		LandingCycleDone(player);
         	return;
         	}

         void Restrictedairspace(BasePlayer player)
         	{
     		_noclip.Remove(player.userID);
		SendReply(player, "You cannot noclip while under 'Building Blocked' flag !");
		_landing.Add(player.userID, new LandingData
		{
		player = player
		});
		LandingCycleDone(player);
         	return;
         	}

         void Activatenoclip(BasePlayer player, float speed)
         	{
     		_noclip.Add(player.userID, new PlayerData
        	{
                player = player,
                speed = speed,
                 input = (InputState) ServerInput.GetValue(player),
                 oldPos = player.transform.position
        	});
                SendReply(player, "NoClip Activated, press any key to start");
		DamageOff(player);
		return;
         	}

         void Togglenoclip(BasePlayer player, float speed)
         	{
             	if (_noclip.ContainsKey(player.userID))
                 	Deactivatenoclip(player);
             	if (_landing.ContainsKey(player.userID))
                 	SendReply(player, "Please Wait...");
             	else
                 	Activatenoclip(player, speed);
			return;
         	}

	void LandingCycleDone(BasePlayer player)
		{
		foreach (var playerData in _landing.Values)
			{
			timer.Once(GracefulLandingTime, () => _landing.Remove(player.userID));
			timer.Once(GracefulLandingTime, () => DamageOn(player));
			}
		}

         [ChatCommand("noclip")]
         void cmdChatnolcip(BasePlayer player, string command, string[] args)
         {
        	if (!isAllowed(player, "fauxclip.allowed"))
            		{
                	SendReply(player, "You are not worthy yet!");
                	return;
            		}
		if (isAllowed(player, "fauxclip.allowed"))
        		{
                	var speed = BaseNoClipSpeed;
                	if (args.Length > 0)
                	speed = Convert.ToSingle(args[0]);
                	Togglenoclip(player, speed);
        		}
		else return;
         }

	void OnPlayerRespawned(BasePlayer player)
	{
             	if (_noclip.ContainsKey(player.userID))
                 	_noclip.Remove(player.userID);
             	if (_landing.ContainsKey(player.userID))
                 	_landing.Remove(player.userID);
		else
		return;
	}
	void OnPlayerDisconnected(BasePlayer player, string reason)
	{
             	if (_noclip.ContainsKey(player.userID))
                 	_noclip.Remove(player.userID);
             	if (_landing.ContainsKey(player.userID))
                 	_landing.Remove(player.userID);
		else
		return;
	}

	bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
     }
}

// --- End of file: FauxClip.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoEscape (1).cs ---
// --- Original Local Path: NoEscape (1).cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoEscape", "OxideBro", "1.0.71")]
    class NoEscape : RustPlugin
    {

        #region Plugin Reference
        [PluginReference]
        Plugin Clans, Friends, RustMap, VKBot, Duel;

        bool IsClanMember(ulong playerID, ulong targetID)
        {
            return (bool)(Clans?.Call("HasFriend", playerID, targetID) ?? false);
        }

        bool IsFriends(ulong playerID, ulong friendId)
        {
            return (bool)(Friends?.Call("AreFriends", playerID, friendId) ?? false);
        }

        private bool IsDuelPlayer(BasePlayer player)
        {
            if (Duel == null)
                return false;
            var dueler = Duel.Call("IsPlayerOnActiveDuel", player);
            if (dueler is bool)
                return (bool)dueler;
            return false;
        }
        #endregion

        #region CLASSES
        DateTime LNT;
        class Raid
        {
            public HashSet<ulong> owners;
            public HashSet<ulong> raiders;
            public Vector3 pos;

            public Raid(List<ulong> owners, List<ulong> raiders)
            {
                this.owners = new HashSet<ulong>(owners);
                this.raiders = new HashSet<ulong>(raiders);
            }
        }

        class DamageTimer
        {
            public List<ulong> owners;
            public int seconds;

            public DamageTimer(List<ulong> owners, int seconds)
            {
                this.owners = owners;
                this.seconds = seconds;
            }
        }

        #endregion

        #region CONFIGURATION
        static DynamicConfigFile config;

        float radius = 50f;
        int blockTime = 120;
        int offlineOut = 1;
        int blockAttackTime = 10;
        bool blockAttack = false;
        int ownerBlockTime = 120;
        bool useDamageScale = false;
        bool useVK = false;
        bool blockOwner = true;
        bool friedsAPI = false;
        bool clansAPI = false;
        bool canBuild = true;
        bool canRemove = true;
        bool canRemoveStan = true;
        bool canKits = true;
        bool canRepair = true;
        bool canUpgrade = true;
        bool canTeleport = true;
        bool EnabledGUI = true;
        bool EnabledGUITimer = true;
        bool canTrade = true;
        bool canRec = true;
        bool CanBuilt = true;
        bool CanBuiltNoEscape = true;
        bool LadderBuilding = false;
        float offlineScale = 0.5f;
        bool MsgAttB = false;
        string MsgAtt = "photo-1_265827614";
        float offlineScaleFriendsClans = 0.5f;


        string GUITimerAnchormin = "0.005856488 0.6770834";
        string GUITimerAnchormax = "0.1493412 0.7200521";
        string GUISendAnchormin = "0 0.8619792";
        string GUISendAnchormax = "1 0.9166667";

        private string formatMessage = "Доброго времени суток.\nУведомляем Вас о том, что начался рейд Вашего имущества, который инициирован игроком {attacker}.";

        public List<string> whitelistObject;


        private void LoadDefaultConfig()
        {
            GetConfig("Основное", "Размер радиуса блокировки", ref radius);
            GetConfig("Основное", "Время блокировки атакующего", ref blockTime);
            GetConfig("Основное", "Блокировать игроков при нанесение урона (Блокировка инициатора и жертвы)", ref blockAttack);
            GetConfig("Основное", "Время блокировки при нанесение урона по игрокам (Блокировка инициатора и жертвы)", ref blockAttackTime);
            GetConfig("Основное", "Поддержка плагина Clans", ref clansAPI);
            GetConfig("Основное", "Блокировать хозяина строения, если он не в радиусе блокировки", ref blockOwner);
            GetConfig("Основное", "Поддержка плагина Friends", ref friedsAPI);
            GetConfig("Основное", "Время блокировки хозяина", ref ownerBlockTime);
            GetConfig("Основное", "Запретить установку штурмовых лестниц в радиусе зоны чужого шкафа", ref CanBuilt);

            GetConfig("GUI", "Включить GUI окно-оповещение о начале рейда (Текст вы сможете изменить в lang)", ref EnabledGUI);
            GetConfig("GUI", "Включить GUI окошко таймера рейд блока", ref EnabledGUITimer);
            GetConfig("GUI", "Окно таймера: AnchorMin", ref GUITimerAnchormin);
            GetConfig("GUI", "Окно таймера: AnchorMax", ref GUITimerAnchormax);
            GetConfig("GUI", "Окно оповещения: AnchorMin", ref GUISendAnchormin);
            GetConfig("GUI", "Окно оповещения: AnchorMax", ref GUISendAnchormax);

            GetConfig("Множитель", "Множитель урона если хозяина нет в сети (наносимый урон = урон*SCALE)", ref offlineScale);
            GetConfig("Множитель", "Множитель урона если хозяин друг или соклановец (наносимый урон = урон*SCALE)", ref offlineScaleFriendsClans);
            GetConfig("Множитель", "Использовать множитель урона", ref useDamageScale);

            GetConfig("VK", "Использовать оповещения о рейде с помощью VKBot", ref useVK);
            GetConfig("VK", "Сообщение оповещения о рейде дома", ref formatMessage);
            GetConfig("VK", "Частота оповещений оффлайн игрокам в ВК (в минутах)", ref offlineOut);
            GetConfig("VK", "Прикрепить к сообщению изображение?", ref MsgAttB);
            GetConfig("VK", "Ссылка на изображение, пример: photo - 1_265827614", ref MsgAtt);

            GetConfig("Блокировка", "Блокировать строительство", ref canBuild);
            GetConfig("Блокировка", "Блокировать удаление построек (CanRemove)", ref canRemove);
            GetConfig("Блокировка", "Блокировать использование китов", ref canKits);
            GetConfig("Блокировка", "Блокировать ремонт построек (стандартный)", ref canRepair);
            GetConfig("Блокировка", "Блокировать улучшение построек (стандартное)", ref canUpgrade);
            GetConfig("Блокировка", "Блокировать телепорты", ref canTeleport);
            GetConfig("Блокировка", "Блокировать удаление построек (стандартное)", ref canRemoveStan);
            GetConfig("Блокировка", "Блокировать обмен между игроками (Trade)", ref canTrade);
            GetConfig("Блокировка", "Блокировать переработчик (Recycler)", ref canRec);
            GetConfig("Блокировка", "Блокировать установку штурмовых лесниц в рейд блоке", ref LadderBuilding);
            SaveConfig();
        }

        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }

            Config[menu, Key] = var;
        }

        #endregion

        #region FIELDS

        Dictionary<ulong, double> timers = new Dictionary<ulong, double>();

        List<Raid> raids = new List<Raid>();
        List<DamageTimer> damageTimers = new List<DamageTimer>();
        private Dictionary<BasePlayer, DateTime> CooldownsAttackDic = new Dictionary<BasePlayer, DateTime>();
        private double CooldownAttack = 15f;

        private string PERM_IGNORE = "noescape.ignore";
        private string PERM_VK_NOTIFICATION = "noescape.vknotification";

        #endregion

        #region OXIDE HOOKS

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (go == null || plan == null) return;
            if (!CanBuilt) return;
            var player = plan.GetOwnerPlayer();
            BaseEntity entity = go.ToBaseEntity();
            var targetLocation = player.transform.position + (player.eyes.BodyForward() * 4f);
            if (go.name == "assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab" && player.IsBuildingBlocked(targetLocation, new Quaternion(0, 0, 0, 0), new Bounds(Vector3.zero, Vector3.zero)))
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    if (!LadderBuilding) return;

                }
                SendReply(player, Messages["BlockLadders"]);
                entity.Kill();
            }

        }

        void OnServerInitialized()
        {
            PermissionService.RegisterPermissions(this, new List<string>() { PERM_IGNORE, PERM_VK_NOTIFICATION });
            LoadDefaultConfig();
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            timer.Every(1f, NoEscapeTimerHandle);
            timer.Every(1f, RaidZoneTimerHandle);
            LoadData();
            if (RustMap != null)
                InitImages();
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info, Item item)
        {
            if (!(entity is BuildingBlock) && !(entity is Door) && !entity.ShortPrefabName.Contains("external.high.")) return;
            var player = info?.InitiatorPlayer;
            if (entity == null && info == null) return;
            if (player == null) return;
            if (player.userID == entity.OwnerID) return;
            var block = entity as BuildingBlock;
            if (block && block.grade <= 0) return;
            InitImages();
            bool justCreated;
            var raid = GetRaid(entity.GetNetworkPosition(), out justCreated);

            if (PermissionService.HasPermission(player.userID, PERM_IGNORE)) return;

            if (!timers.ContainsKey(player.userID))
            {
                if (EnabledGUI)
                {
                    var p = BasePlayer.FindByID(entity.OwnerID);
                    DrawUI(p, info.Initiator?.ToPlayer().displayName, Messages["yourbuildingdestroyOwner"]);
                    timer.Once(5.0f, () => DestroyUI(p));
                }
                if (blockOwner)
                {
                    var p = BasePlayer.FindByID(entity.OwnerID);
                    SendReply(p, Messages["blockactive"], FormatTime(TimeSpan.FromSeconds(ownerBlockTime)));
                    SendReply(player, Messages["blockactiveAttacker"], FormatTime(TimeSpan.FromSeconds(ownerBlockTime)));

                }
                else
                {
                    var p = BasePlayer.FindByID(entity.OwnerID);
                    SendReply(p, Messages["noblockowner"]);
                    SendReply(player, Messages["blockactiveAttacker"], FormatTime(TimeSpan.FromSeconds(ownerBlockTime)));
                }
            }

            GetAroundPlayers(entity.GetNetworkPosition()).ForEach(p => BlockPlayer(p, "raid"));

            if (useVK)
            {
                if (!IsOnline(entity.OwnerID))
                {
                    SendOfflineMessage(entity.OwnerID, info.Initiator?.ToPlayer().displayName);
                }
            }
            if (clansAPI && Clans.Call("GetClanMembers", entity.OwnerID) != null)
            {
                bool sendRemoveOwnerMessage = false;
                var team = (List<ulong>)Clans.Call("GetClanMembers", entity.OwnerID);
                foreach (var uid in team.ToList())
                {
                    if (!raid.owners.Contains(uid))
                    {
                        var p = BasePlayer.FindByID(uid);


                        raid.owners.Add(uid);
                        if (useDamageScale)
                        {
                            if (justCreated && p && !sendRemoveOwnerMessage)
                            {
                                sendRemoveOwnerMessage = true;
                                damageTimers.Add(new DamageTimer(raid.owners.ToList(), 3600));
                                SendReply(player, Messages["DamageOnlineOwner"]);
                            }
                            else if ((justCreated && !p && !sendRemoveOwnerMessage) ||
                                     (!sendRemoveOwnerMessage && team.Last() == uid))
                            {
                                sendRemoveOwnerMessage = true;
                                SendReply(player, Messages["DamageNotOnlineOwner"]);
                            }
                        }
                    }
                }
            }
            else
            {
                if (!raid.owners.Contains(entity.OwnerID))
                {
                    var p = BasePlayer.FindByID(entity.OwnerID);
                    if (blockOwner)
                    {
                        raid.owners.Add(entity.OwnerID);
                    }
                    if (useDamageScale)
                    {
                        if (justCreated && p)
                        {
                            damageTimers.Add(new DamageTimer(raid.owners.ToList(), 3600));
                        }
                    }
                }

            }

            foreach (var owner in GetOwnersByOwner(entity.OwnerID, entity.GetNetworkPosition()))
                raid.owners.Add(owner);
        }

        bool IsOnline(ulong id)
        {
            foreach (BasePlayer active in BasePlayer.activePlayerList)
            {
                if (active.userID == id) return true;
            }
            return false;
        }

        Raid GetRaid(Vector3 pos, out bool justCreated)
        {
            justCreated = false;
            foreach (var raid in raids)
                if (Vector3.Distance(raid.pos, pos) < 50) return raid;
            justCreated = true;
            var ownerraid = new Raid(new List<ulong>(), new List<ulong>()) { pos = pos };
            raids.Add(ownerraid);
            return ownerraid;
        }

        void BlockPlayer(BasePlayer player, string mode = "", bool owner = false)
        {
            if (player.IsSleeping()) return;
            if (player == null) return;
            if (mode == "raid")
            {
                if (!owner || !timers.ContainsKey(player.userID))
                {

                    var secs = owner ? ownerBlockTime : blockTime;
                    timers[player.userID] = secs;
                    SetCooldown(player, "raid", secs);
                    SaveData();
                }
                return;
            }
            if (mode == "attack")
            {
                var cooldown = GetCooldown(player, "raid");
                if (cooldown != 0)
                {
                    return;
                }
                if (!timers.ContainsKey(player.userID))
                {
                    player.ChatMessage(string.Format(Messages[owner ? "ownerhome" : "blockattackactive"], FormatTime(TimeSpan.FromSeconds(owner ? blockAttackTime : blockAttackTime))));
                }
                if (!owner || !timers.ContainsKey(player.userID))
                {
                    var secs = owner ? blockAttackTime : blockAttackTime;
                    timers[player.userID] = secs;
                    SetCooldown(player, "attack", secs);
                    SaveData();
                }
            }
        }

        private string GetFormatTime(double seconds)
        {
            double minutes = Math.Floor((double)(seconds / 60));
            seconds -= (int)(minutes * 60);
            return string.Format("{0}:{1:00}", minutes, seconds);
        }

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
                DestroyUITimer(player);
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (useDamageScale)
            {
                foreach (var raid in raids)
                    if (raid.owners.Contains(player.userID) &&
                        raid.owners.Count(p => BasePlayer.FindByID(p) != null) <= 1 &&
                        raid.owners.Any(o => damageTimers.All(t => !t.owners.Contains(o))))
                    {
                        foreach (var raider in raid.raiders)
                            BasePlayer.FindByID(raider)?.ChatMessage(Messages["OwnerEnterOnline"]);
                        break;
                    }
            }
        }

        private List<string> damageTypes;

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info, BaseCombatEntity victim)
        {
            try
            {
                var initiator = info?.InitiatorPlayer;
                var victimBP = entity.ToPlayer();
                if (entity == null) return;
                if (initiator == null) return;
                if (victimBP == null) return;
                if (initiator == victimBP) return;
                if (blockAttack)
                {
                    if (entity is BasePlayer && info.Initiator is BasePlayer)
                    {
                        if (!IsDuelPlayer(initiator) && entity != null && victimBP != null)
                        {
                            BlockPlayer(initiator, "attack");
                            BlockPlayer(victimBP, "attack");
                        }
                    }
                }
                if (info.WeaponPrefab is BaseProjectile) return;
                if (damageTimers.Any(p => p.owners.Contains(entity.OwnerID))) return;

                if (!(entity is BuildingBlock) && !(entity is Door)) return;
                if (entity.OwnerID == 0) return;
                if (useDamageScale)
                {
                    bool justCreated;
                    var raid = GetRaid(entity.GetNetworkPosition(), out justCreated);
                    bool SendMessages = false;
                    SendMessages = false;
                    if (CooldownsAttackDic.ContainsKey(initiator))
                    {
                        double seconds = CooldownsAttackDic[initiator].Subtract(DateTime.Now).TotalSeconds;
                        if (seconds >= 0)
                        {
                            SendMessages = true;
                        }
                    }

                    if (clansAPI)
                    {
                        bool sendRemoveOwnerMessage = false;
                        if (justCreated && initiator && !sendRemoveOwnerMessage)
                        {
                            if (IsClanMember(entity.OwnerID, initiator.userID))
                            {
                                damageTimers.Add(new DamageTimer(raid.owners.ToList(), 3600));
                                info.damageTypes.ScaleAll(offlineScaleFriendsClans);
                                sendRemoveOwnerMessage = true;
                                justCreated = false;
                                if (SendMessages == false)
                                {
                                    SendReply(initiator, Messages["isClanMember"]);
                                    SendMessages = true;
                                }
                                CooldownsAttackDic[initiator] = DateTime.Now.AddSeconds(CooldownAttack);
                                return;
                            }
                        }
                    }
                    if (friedsAPI)
                    {
                        bool sendRemoveOwnerMessage = false;
                        if (justCreated && initiator && !sendRemoveOwnerMessage)
                        {
                            if (IsFriends(entity.OwnerID, initiator.userID))
                            {
                                damageTimers.Add(new DamageTimer(raid.owners.ToList(), 3600));
                                sendRemoveOwnerMessage = true;
                                info.damageTypes.ScaleAll(offlineScaleFriendsClans);
                                if (SendMessages == false)
                                {
                                    SendReply(initiator, Messages["isFriendMember"]);
                                    SendMessages = true;
                                }
                                CooldownsAttackDic[initiator] = DateTime.Now.AddSeconds(CooldownAttack);
                                return;
                            }
                        }
                    }
                    if (clansAPI && Clans.Call("GetClanMembers", entity.OwnerID) != null)
                    {
                        var team = (List<ulong>)Clans.Call("GetClanMembers", entity.OwnerID);
                        if (team.Contains(initiator.userID))
                            return;
                        if (!team.Select(BasePlayer.FindByID).Any(p => p))
                        {
                            info.damageTypes.ScaleAll(offlineScale);
                            return;
                        }
                    }
                    else
                    {
                        bool sendRemoveOwnerMessage = false;
                        if (!BasePlayer.FindByID(entity.OwnerID))
                        {

                            info.damageTypes.ScaleAll(offlineScale);
                            damageTimers.Add(new DamageTimer(raid.owners.ToList(), 3600));

                            if (SendMessages == false)
                            {
                                SendReply(initiator, Messages["DamageNotOnlineOwner"]);
                                SendMessages = true;
                            }
                            CooldownsAttackDic[initiator] = DateTime.Now.AddSeconds(CooldownAttack);

                        }
                        if (justCreated && initiator && !sendRemoveOwnerMessage)
                        {
                            sendRemoveOwnerMessage = true;
                            justCreated = false;
                        }
                    }
                }
            }
            catch (NullReferenceException)
            {
            }
        }

        object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (player == null) return null;
            if (canUpgrade)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["blockupgrade"], seconds));
                    return false;
                }
            }
            return null;
        }
        object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player)
        {
            if (player == null) return null;
            if (canRemoveStan)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["blockremove"], seconds));
                    return false;
                }
            }
            return null;
        }

        object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (player == null) return null;
            if (canRepair)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["blockrepair"], seconds));
                    return false;
                }
            }
            return null;

        }

        object CanUpgrade(BasePlayer player)
        {
            if (player == null) return null;
            if (canUpgrade)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["blockupgrade"], seconds));
                    return false;
                }
            }
            return null;
        }

        object CanBuild(Planner plan, Construction prefab)
        {
            var player = plan.GetOwnerPlayer();
            if (prefab.fullName.Contains("Twigs")) return null;

            if (player == null) return null;
            if (!LadderBuilding && prefab.fullName.Contains("ladder.wooden")) return null;
            if (canBuild)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["blockbuld"], seconds));
                    return false;
                }
            }
            return null;
        }

        object CanTeleport(BasePlayer player)
        {
            if (player == null) return null;
            var cooldown = GetCooldown(player, "attack");
            if (cooldown > 0 && !player.IsAdmin)
            {
                return false;
            }
            var seconds = ApiGetTime(player.userID);
            return seconds > 0 ? string.Format(Messages["blocktp"], seconds) : null;
        }

        object CanTrade(BasePlayer player)
        {
            if (player == null) return null;
            if (canTrade)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["blocktrade"], seconds));
                    return false;
                }
            }
            return null;
        }

        object canRedeemKit(BasePlayer player)
        {
            if (player == null) return null;
            if (canKits)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["blockKits"], seconds));
                    return false;
                }
            }
            return null;
        }

        object CanRecycleCommand(BasePlayer player)
        {
            if (player == null) return null;
            if (canRec)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["blockrec"], seconds));
                    return false;
                }
            }
            return null;
        }

        object CanRemove(BasePlayer player, BaseEntity entity)
        {
            if (player == null) return null;
            if (canRemove)
            {
                var seconds = ApiGetTime(player.userID);
                if (seconds > 0)
                {
                    SendReply(player, string.Format(Messages["raidremove"], seconds));
                    return false;
                }
            }
            return null;
        }

        #endregion

        #region Chat Commands
        [ChatCommand("ne")]
        void cmdChatRaid(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            var seconds = ApiGetTime(player.userID);
            if (seconds != 0)
            {
                SendReply(player, string.Format(Messages["isblock"], FormatTime(TimeSpan.FromSeconds(seconds))));
                return;
            }
            if (seconds == 0)
            {
                SendReply(player, string.Format(Messages["noblock"]));
                return;
            }

        }

        #endregion

        #region New Vk
        private string TextReplace(string key, params KeyValuePair<string, string>[] replacements)
        {
            string message = key;
            foreach (var replacement in replacements)
                message = message.Replace($"{{{replacement.Key}}}", replacement.Value);
            return message;
        }

        void SendOfflineMessage(ulong id, string raidername)
        {
            if (!PermissionService.HasPermission(id, PERM_VK_NOTIFICATION)) return;
            var userVK = (string)VKBot?.Call("GetUserVKId", id);
            if (userVK == null) return;
            var LastNotice = (string)VKBot?.Call("GetUserLastNotice", id);
            if (LastNotice == null)
            {
                string text = TextReplace(formatMessage,
                                            new KeyValuePair<string, string>("attacker", raidername));
                VKBot?.Call("VKAPIMsg", text, MsgAtt, userVK, MsgAttB);
                string LastRaidNotice = DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss");
                VKBot?.Call("VKAPISaveLastNotice", id, LastRaidNotice);
            }
            else
            {
                if (DateTime.TryParseExact(LastNotice, "dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture, DateTimeStyles.None, out LNT))
                {
                    if (TimeLeft(LNT).TotalMinutes >= offlineOut)
                    {
                        string text = TextReplace(formatMessage,
                            new KeyValuePair<string, string>("attacker", raidername));
                        VKBot?.Call("VKAPIMsg", text, MsgAtt, userVK, MsgAttB);
                        string LastRaidNotice = DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss");
                        VKBot?.Call("VKAPISaveLastNotice", id, LastRaidNotice);
                    }
                }
                else
                {
                    LogToFile("error", $"[{DateTime.Now}] Ошибка обработки времени последнего оповещения игрока {id}", this);
                    return;
                }
            }
        }
        #endregion

        #region CORE

        void NoEscapeTimerHandle()
        {
            foreach (var uid in timers.Keys.ToList())
            {
                if (--timers[uid] <= 0)
                {
                    bool cont = false;
                    foreach (var raid in raids)
                        if (raid.owners.Contains(uid))
                            cont = true;
                    if (cont) continue;
                    timers.Remove(uid);
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        if (EnabledGUITimer)
                        {
                            CuiHelper.DestroyUi(player, "noescape_bp");
                        }
                    }
                    BasePlayer.activePlayerList.Find(p => p.userID == uid)?.ChatMessage(Messages["blocksuccess"]);
                }
                else
                {
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        if (EnabledGUITimer)
                        {
                            DrawUITimer(player);
                        }
                    }
                }
            }
            for (int i = damageTimers.Count - 1; i >= 0; i--)
            {
                var rem = damageTimers[i];
                if (--rem.seconds <= 0)
                {
                    damageTimers.RemoveAt(i);
                    continue;
                }
            }
        }

        void RaidZoneTimerHandle()
        {
            List<Raid> toRemove = new List<Raid>();
            foreach (var raid in raids)
            {
                foreach (var player in GetAroundPlayers(raid.pos))
                {
                    if (raid.owners.Contains(player.userID))
                    {
                        BlockPlayer(player, "raid", true);
                    }
                }
                raid.raiders.RemoveWhere(raider => !timers.ContainsKey(raider));
                if (raid.raiders.Count <= 0)
                {
                    foreach (var owner in raid.owners)
                    {

                        timers[owner] = ownerBlockTime;
                        var p = BasePlayer.FindByID(owner);
                        if (p) SetCooldown(p, "raid", ownerBlockTime);
                        SaveData();
                    }
                    toRemove.Add(raid);
                }
            }
            toRemove.ForEach(raid => raids.Remove(raid));
        }

        List<BasePlayer> GetAroundPlayers(Vector3 position)
        {
            var coliders = new List<BaseEntity>();
            Vis.Entities(position, radius, coliders, Rust.Layers.Server.Players);
            return coliders.OfType<BasePlayer>().ToList();
        }



        List<ulong> GetOwnersByOwner(ulong owner, Vector3 position)
        {
            var coliders = new List<BaseEntity>();
            Vis.Entities(position, radius, coliders, Rust.Layers.Server.Deployed);
            var codelocks =
                coliders.OfType<BoxStorage>()
                    .Select(s => s.GetSlot(BaseEntity.Slot.Lock))
                    .OfType<CodeLock>()
                    .ToList();
            var owners = new HashSet<ulong>();
            var reply = 125;
            foreach (var codelock in codelocks)
            {
                var whitelist = codelock.whitelistPlayers;
                if (whitelist == null) continue;
                if (!whitelist.Contains(owner)) continue;
                foreach (var uid in whitelist)
                    if (uid != owner)
                        owners.Add(uid);
            }
            return owners.ToList();
        }

        string DrawGUIAnno = "[{\"name\":\"noescape_background\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0.5261458 0.1478219 0.1478219 0.4666667\"},{\"type\":\"RectTransform\",\"anchormin\":\"{min}\",\"anchormax\":\"{max}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"noescape_text\",\"parent\":\"noescape_background\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{0}\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0.3513073 0 0 0.5438426\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]}]";

        string GUItimer = "[{\"name\":\"noescape_bp\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"{min}\",\"anchormax\":\"{max}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"timer_bp\",\"parent\":\"noescape_bp\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0.45\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.3061226 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"timer\",\"parent\":\"timer_bp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{0}\",\"fontSize\":18,\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3204921\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"text_bp\",\"parent\":\"noescape_bp\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0.7\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3 0\",\"anchormax\":\"0.99 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"text\",\"parent\":\"text_bp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{1}\",\"fontSize\":18,\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.257841\",\"distance\":\"0.5 -0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        void DrawUI(BasePlayer player, string name, string messag)
        {
            DestroyUI(player);
            CuiHelper.AddUi(player,
              DrawGUIAnno.Replace("{0}", messag.ToString())
                 .Replace("{1}", name.ToString())
                 .Replace("{min}", GUISendAnchormin.ToString())
                 .Replace("{max}", GUISendAnchormax.ToString()));
        }

        void DrawUITimer(BasePlayer player)
        {
            if (timers.ContainsKey(player.userID))
            {
                var time = GetFormatTime(ApiGetTime(player.userID));
                CuiHelper.DestroyUi(player, "noescape_bp");
                CuiHelper.AddUi(player,
                  GUItimer.Replace("{0}", time.ToString())
                  .Replace("{1}", Messages["guitimertext"].ToString())
                  .Replace("{min}", GUITimerAnchormin.ToString())
                 .Replace("{max}", GUITimerAnchormax.ToString()));
            }
        }

        void DestroyUITimer(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "noescape_bp");
        }

        void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "noescape_background");
        }



        #endregion

        #region Cooldown

        DynamicConfigFile cooldownsFile = Interface.Oxide.DataFileSystem.GetFile("NoEscapeCooldown");

        private class Cooldown
        {
            public ulong UserId;
            public double Expired;
            [JsonIgnore]
            public Action OnExpired;
        }
        private static Dictionary<string, List<Cooldown>> cooldowns;

        internal static void Service()
        {
            var time = GrabCurrentTime();
            List<string> toRemove = new List<string>();
            foreach (var cd in cooldowns)
            {
                var keyCooldowns = cd.Value;
                List<string> toRemoveCooldowns = new List<string>();
                for (var i = keyCooldowns.Count - 1; i >= 0; i--)
                {
                    var cooldown = keyCooldowns[i];
                    if (cooldown.Expired < time)
                    {
                        cooldown.OnExpired?.Invoke();
                        keyCooldowns.RemoveAt(i); ;
                    }
                }
                if (keyCooldowns.Count == 0) toRemove.Add(cd.Key);
            }
            toRemove.ForEach(p => cooldowns.Remove(p));
        }

        public static void SetCooldown(BasePlayer player, string key, int seconds, Action onExpired = null)
        {
            List<Cooldown> cooldownList;
            if (!cooldowns.TryGetValue(key, out cooldownList))
                cooldowns[key] = cooldownList = new List<Cooldown>();
            cooldownList.Add(new Cooldown()
            {
                UserId = player.userID,
                Expired = GrabCurrentTime() + (double)seconds,
                OnExpired = onExpired
            });
        }

        public static int GetCooldown(BasePlayer player, string key)
        {
            List<Cooldown> source = new List<Cooldown>();
            if (cooldowns.TryGetValue(key, out source))
            {
                Cooldown cooldown = source.FirstOrDefault<Cooldown>((Func<Cooldown, bool>)(p => (long)p.UserId == (long)player.userID));
                if (cooldown != null)
                    return (int)(cooldown.Expired - GrabCurrentTime());
            }
            return 0;
        }
        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        #endregion

        #region RustMap

        private Image raidhomeImage;

        void OnMapInitialized()
        {
            InitImages();
        }
        TimeSpan TimeLeft(DateTime time)
        {
            return DateTime.Now.Subtract(time);
        }
        void InitImages()
        {
            try
            {
                if (plugins.Exists("RustMap"))
                {
                    uint raidhomeCRC = uint.Parse((string)RustMap?.Call("RaidHomePng"));
                    raidhomeImage = (Bitmap)(new ImageConverter().ConvertFrom(FileStorage.server.Get(raidhomeCRC, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID)));
                }
            }
            catch { }
        }

        #endregion

        #region PLUGIN API

        double ApiGetTime(ulong player)
        {
            double time;
            return timers.TryGetValue(player, out time) ? time : 0;
        }

        List<Vector3> ApiGetOwnerRaidZones(ulong uid)
        {
            return new List<Vector3>(raids.Where(p => p.owners.Contains(uid)).Select(r => r.pos));
        }

        #endregion

        #region DATA
        void OnServerSave()
        {
            cooldownsFile.WriteObject(cooldowns);
        }

        void LoadData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("NoEscapeCooldown", new Dictionary<string, FileInfo>());
            cooldowns = cooldownsFile.ReadObject<Dictionary<string, List<Cooldown>>>() ??
                        new Dictionary<string, List<Cooldown>>();
        }

        void SaveData()
        {
            cooldownsFile.WriteObject(cooldowns);
        }
        #endregion

        #region LOCALIZATION

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"blocksuccess", "Блок деактивирован. Функции разблокированы"},
            {"guitimertext", "Raid-блок"},
            {"noblockowner", "Ваше строение разрушено! Летите на защиту"},
            {"blockactive", "Ваше строение разрушено, активирован рейд блок на <color=#ECBE13>{0}</color>\nНекоторые функции временно недоступны."},
            {"blockactiveAttacker", "Вы уничтожили чужой объект, активирован рейд блок на <color=#ECBE13>{0}</color>\nНекоторые функции временно недоступны."},
            {"blockattackactive", "Включен режим боя, активирован блок на {0}! Некоторые функции временно недоступны."},
            {"blockrepair", "Вы не можете ремонтировать строения во время рейда, подождите {0} сек."},
            {"isblock", "NoEscape by <color=#ECBE13><size=15>RustPlugin.ru</size></color>\nУ вас есть активный рейд блок!\nДо окончания: <color=#ECBE13>{0}</color>"},
            {"noblock", "NoEscape by <color=#ECBE13><size=15>RustPlugin.ru</size></color>\nУ вас нету рейд блока :)"},
            {"blocktp", "Вы не можете использовать телепорт во время рейда, подождите {0} сек." },
            {"blockremove", "Вы не можете удалить постройки во время рейда, подождите {0} сек." },
            { "blockupgrade", "Вы не можете использовать автоулучшение построек во время рейда, подождите {0} сек." },
            { "blockKits", "Вы не можете использовать киты во время рейда, подождите {0} сек." },
            { "blockbuld", "Вы не можете строить во время рейда, подождите {0} сек." },
            { "yourbuildingdestroy", "Вас, или дом Вашего соклана рейдят! Добавлена отметка на карту" },
            { "yourbuildingdestroyOwner", "Внимание! Ваш дом рейдит игрок {1}! Добавлена отметка на карту" },
            { "isClanMember", "Внимание! Данное строение пренадлежит Вашему соклановцу! Урон уменьшен" },
            { "isFriendMember", "Внимание! Данное строение пренадлежит Вашему другу! Урон уменьшен" },
            { "removerestrict", "Хозяев нет в сети! Ремув запрещён!" },
            { "ownerhome", "Вы рядом со своим домом, который рейдят!\nРейдблок активирован на {0}!" },
            {"raidremove", "Вы не можете удалять обьекты во время рейда, подождите {0} сек." },
            {"blockrec", "Вы не можете использовать переработчик во время рейда, подождите {0} сек." },
            {"ownernotonline", "Владельцов нет в сети, ремув недоступен!" },
            { "DamageOnlineOwner", "Один их хозяев постройки сейчас в сети.\nУрон по объектам владельца стандартный" },
            { "DamageNotOnlineOwner", "Не одного владельца постройки нет в сети. \nУрон по объектам владельца уменьшен в 2 раза!" },
            { "OwnerEnterOnline", "Хозяин постройки зашел в игру.\nУрон по объектам владельца стандартный!" },
            { "blocktrade", "Вы не можете использовать обмен во время рейда, подождите {0} сек." },
            { "BlockLadders", "Вы не можете установить штурмовую лестницу в зоне действия чужого шкафа" }
        };

        #endregion

        #region Permission Service

        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();

            public static bool HasPermission(ulong uid, string permissionName)
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(uid.ToString(), permissionName);
            }

            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");

                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }

        #endregion

    }
}
                       

// --- End of file: NoEscape (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ToukDurability.cs ---
// --- Original Local Path: ToukDurability.cs ---

using System;

namespace Oxide.Plugins
{
    [Info("ToukDurability", "Touk", "1.0.0")]
    [Description("Customize durability")]
    public class ToukDurability : RustPlugin
    {
        float durabilityRatio = 1f;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Config.Clear();
            Config["DurabilityRatio"] = durabilityRatio;
            SaveConfig();
        }

        void OnLoseCondition(Item item, ref float amount)
        {
            if (item?.GetOwnerPlayer() == null) return;
            durabilityRatio = GetConfig<float>("DurabilityRatio", durabilityRatio);
            item.condition += amount - (amount * durabilityRatio);
            //Puts($"{item?.GetOwnerPlayer()} {item.info.shortname} was damaged by: {amount}*{durabilityRatio} | Condition is: {item.condition}/{item.maxCondition}");
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
    }
}


// --- End of file: ToukDurability.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoCleanup.cs ---
// --- Original Local Path: AutoCleanup.cs ---

using System.Collections.Generic;
using System.Collections;
using System.Linq;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("AutoCleanup", "Server-rust.ru fixed by pahan0772", "1.0.8")]
    class AutoCleanup : RustPlugin
    {
        bool Changed = false;

        bool logToConsole, broadcastToChat, cleanOnLoad;
        float timerIntervalInSeconds, decayPercentage;
        string commandPermission, excludePermission, cleanupChatCommand, cleanupConsoleCommand;

        List<object> entityList;

        List<object> GetDefaultEntityList()
        {
            return new List<object>()
            {
                "assets/prefabs/building/gates.external.high/gates.external.high.stone/gates.external.high.stone.prefab",
                "assets/prefabs/building/gates.external.high/gates.external.high.wood/gates.external.high.wood.prefab",
                "assets/prefabs/building/wall.external.high.stone/wall.external.high.stone.prefab",
                "assets/prefabs/building/wall.external.high.wood/wall.external.high.wood.prefab",
                "assets/prefabs/misc/item drop/item_drop_backpack.prefab",
                "assets/prefabs/gamemodes/objects/reclaim/reclaimbackpack.prefab",
                "assets/prefabs/misc/item drop/item_drop.prefab",
                "assets/prefabs/misc/item drop/item_drop.prefab",

                "assets/prefabs/deployable/barricades/barricade.concrete.prefab",
                "assets/prefabs/deployable/barricades/barricade.metal.prefab",
                "assets/prefabs/deployable/barricades/barricade.sandbags.prefab",
                "assets/prefabs/deployable/barricades/barricade.stone.prefab",
                "assets/prefabs/deployable/barricades/barricade.wood.prefab",
                "assets/prefabs/deployable/barricades/barricade.woodwire.prefab",
                
            };
        }

        void Init()
        {
            LoadVariables();
            LoadDefaultMessages();
            RegisterPermissions();

            cmd.AddChatCommand(cleanupChatCommand, this, "cmdCleanupChatCommand");
            cmd.AddConsoleCommand(cleanupConsoleCommand, this, "cmdCleanupConsoleCommand");

            if (cleanOnLoad) CleanUp();

            timer.Every(timerIntervalInSeconds, () => { CleanUp(); });
        }

        void cmdCleanupChatCommand(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, commandPermission))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }

            CleanUp();
        }

        void cmdCleanupConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg?.Connection != null && !permission.UserHasPermission(arg?.Player()?.userID.ToString(), commandPermission)) return;

            CleanUp();
        }
        void CleanUp()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                player.ChatMessage($"<size=13>Запущена оптимизация карты</color></size>\nВсе стенки будут уничтожены в течение <color=#8EBD2E>20 секунд.</color>");

            }
            timer.Once(20f, () =>
            {
                CCleanUp();
            });
        }
        void CCleanUp()
        {
            if (broadcastToChat)
                PrintToChat(Lang("LocatingEntities", null));
            if (logToConsole)
                PrintWarning(Lang("LocatingEntities", null));

            int reduced = 0;
            int destroyed = 0;

            foreach (var entity in BaseNetworkable.serverEntities.Where(e => (e as BaseEntity).OwnerID != 0 && !permission.UserHasPermission((e as BaseEntity).OwnerID.ToString(), excludePermission) && entityList.Contains((e as BaseEntity).name)).ToList())
            {
                var entityRadius = Physics.OverlapSphere(entity.transform.position, 0.5f, LayerMask.GetMask("Trigger"));
                int cupboards = 0;

                foreach (var cupboard in entityRadius.Where(x => x.GetComponentInParent<BuildingPrivlidge>() != null)) cupboards++;

                if (cupboards == 0)
                {
                    var ent = ((BaseCombatEntity)entity);

                    if (ent.health - (ent.MaxHealth() * (decayPercentage / 100)) <= 0)
                    {
                        entity?.KillMessage();
                        destroyed++;
                    }
                    else
                    {
                        ent.health -= (ent.MaxHealth() * (decayPercentage / 100));

                        ent.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        reduced++;
                    }
                }
            }

            /*if (broadcastToChat)
            {
                PrintToChat(Lang("EntitiesReducedHealth", null, reduced, decayPercentage));
                PrintToChat(Lang("EntitiesDestroyed", null, destroyed));
            }

            if (logToConsole)
            {
                PrintWarning(Lang("EntitiesReducedHealth", null, reduced, decayPercentage));
                PrintWarning(Lang("EntitiesDestroyed", null, destroyed));
            }*/
        }

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LocatingEntities"] = "Locating all External Walls/Gates & Barricades outside Cupboard Range...",
                ["EntitiesReducedHealth"] = "Reduced the health of {0} External Walls/Gates & Barricades by {1}%.",
                ["EntitiesDestroyed"] = "Destroyed {0} External Walls/Gates & Barricades.",
                ["NoPermission"] = "You do not have permission to use this command."
            }, this);
        }

        void RegisterPermissions()
		{
			permission.RegisterPermission(excludePermission, this);
			permission.RegisterPermission(commandPermission, this);
		}

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            timerIntervalInSeconds = Convert.ToSingle(GetConfig("Settings", "Timer Interval (Seconds)", 3600f));
            decayPercentage = Convert.ToSingle(GetConfig("Settings", "Reduce health by (Percentage)", 10.0f));

            logToConsole = Convert.ToBoolean(GetConfig("Settings", "Log Messages to Console", true));
            broadcastToChat = Convert.ToBoolean(GetConfig("Settings", "Broadcast Messages to Chat", true));
            cleanOnLoad = Convert.ToBoolean(GetConfig("Settings", "Clean up when plugin is loaded", false));


            entityList = (List<object>)GetConfig("Settings", "List of entities", GetDefaultEntityList());

            excludePermission = Convert.ToString(GetConfig("Permissions", "ExcludePermission", "autocleanup.exclude"));
            commandPermission = Convert.ToString(GetConfig("Permissions", "CommandPermission", "autocleanup.cleanup"));
			
			
            cleanupChatCommand = Convert.ToString(GetConfig("Commands", "CleanupChatCommand", "cleanup"));
            cleanupConsoleCommand = Convert.ToString(GetConfig("Commands", "CleanupConsoleCommand", "autocleanup.cleanup"));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
                Changed = true;
            }

            return value;
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: AutoCleanup.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RulesGUI.cs ---
// --- Original Local Path: RulesGUI.cs ---

using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System;
using System.Reflection;
using Oxide.Core;
using System.Linq;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins 
{ 
	[Info("Rules GUI", "Server-Rust", "1.4.9")]
	class RulesGUI : RustPlugin
	{
		List<string> text = new List<string>
		{
			"<size=32><color=#00FF00>Добро пожаловать на Server-Rust ! </color></size>",
			"",
			"<size=24><color=#00FF00></color> Чтобы узнать о доступных биндах наберите в чат команду ->  <color=#00FF00>/bind</color></size>",
			//"<size=24><color=#00FF00></color> Для более подробной информации о сервере используйте ->  <color=#00FF00>/help</color></size>",
			"",
			"<size=24><color=#00FF00></color> Магазин сервера:  <color=#00FF00>Server-Rust.RU</color>    |      Группа VK:  <color=#00FF00></color></size>",
			"",
			"Зарегистрируйся в магазине и получи  <color=#00FF00>25 руб на счет</color> !"
		};
		
		/*void Loaded()
		{
			foreach (BasePlayer current in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(current, "RulesGUI");
				DisplayUI(current);
			}
		}*/

		void Unloaded()
		{
			foreach (BasePlayer current in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(current, "RulesGUI");
			}
		}
		
		void UseUI(BasePlayer player, string msg)
		{ 
			var elements = new CuiElementContainer();

			var mainName = elements.Add(new CuiPanel
			{
				Image =
				{
					Color = "0.1 0.1 0.1 1"
				},
				RectTransform =
				{
					AnchorMin = "0 0",
					AnchorMax = "1 1"
				},
				CursorEnabled = true
			}, "Overlay", "RulesGUI"); 				 
			var Agree = new CuiButton
            {
                Button =
                {
                    Close = mainName,
                    Color = "0 255 0 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.44 0.193",
					AnchorMax = "0.566 0.228"
                },
                Text =
                {
                    Text = "ОК !",
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                }
            };
			elements.Add(new CuiLabel
			{
				Text =
                {
					Text = msg,
					
                    FontSize = 22,
					Font = "robotocondensed-regular.ttf",
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0 0.20",
                    AnchorMax = "1 0.9"
                }
			}, mainName);
			elements.Add(Agree, mainName);
			CuiHelper.AddUi(player, elements);
		}

		void DisplayUI(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(3, () => DisplayUI(player));
				return;
            }
            else 
			{
				string steamId = Convert.ToString(player.userID);
				string msg = "";
				foreach(var rule in text)
				msg = msg + rule.ToString() + "\n \n";
				UseUI(player, msg.ToString());
            }
        }
		
		void OnPlayerInit(BasePlayer player)		
		{
			DisplayUI(player);
		}
		
		[ChatCommand("bind")]
        void bindinfocmd(BasePlayer player, string command)
        {
            if (player == null) return;
            
            player.ChatMessage($"<size=16><color=#00FF00>》</color> Бинды вводить в консоли <color=#00FF00>F1</color> !</size>");
            player.ChatMessage($"<size=16><color=#00FF00>》</color> Карта на клавишу <color=#00FF00>M</color><size=7>\n\n</size>   <color=#00FF00>bind M map.open</color></size>");
            player.ChatMessage($"<size=16><color=#00FF00>》</color> Киты на клавишу <color=#00FF00>K</color><size=7>\n\n</size>   <color=#00FF00>bind K kit</color></size>");
            player.ChatMessage($"<size=16><color=#00FF00>》</color> Принять ТП на клавишу <color=#00FF00>Z</color><size=7>\n\n</size>   <color=#00FF00>bind Z tpa</color></size>");
            player.ChatMessage($"<size=16><color=#00FF00>》</color> Ремув на клавишу <color=#00FF00>DELETE</color><size=7>\n\n</size>   <color=#00FF00>bind DELETE remove</color></size>");
		}
	}
}

// --- End of file: RulesGUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ZoneCommand.cs ---
// --- Original Local Path: ZoneCommand.cs ---

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

using Oxide.Core;

using UnityEngine;

/* --- Do not edit anything here if you don't know what are you doing --- */

namespace Oxide.Plugins
{
	[Info("ZoneCommand", "deer_SWAG", "0.1.0", ResourceId = 1254)]
	[Description("Executes the commands when a player is entering a zone")]
	class ZoneCommand : RustPlugin
	{
		enum Methods { Once, Always, PerPlayer, PerDay, PerGameDay, PerGame }
		enum Modes	 { OnEnter, OnExit }

		const string PermissionName = "zonecommand.use";

		class StoredData
		{
			public HashSet<Zone> Zones = new HashSet<Zone>();

			public StoredData() { }

			public void Add(Zone zone) => Zones.Add(zone);
			public void Remove(Zone zone) => Zones.Remove(zone);
		}

		class Zone
		{
			public string  Id;
			public Methods Method;
			public Modes   Mode;
			public int	   Amount = -1;
			public string  UserGroup;
			public List<string> Commands = new List<string>();
			public HashSet<ZonePlayer> Players = new HashSet<ZonePlayer>();

			public Zone() { }
			public Zone(string Id) { this.Id = Id; }

			public void Add(string command) => Commands.Add(command);
			public void Add(ZonePlayer player) => Players.Add(player);
		}

		class ZonePlayer
		{
			public ulong UserId;
			public int Count;

			public ZonePlayer() { }
		}

		StoredData data;

		void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>()
			{
				{ "HelpText", "ZoneCommand:\n" +
								"/zcmd add <zoneID> {command} {command} ...\n" +
								"/zcmd remove <zoneID>\n" +
								"/zcmd list" },
				{ "AvailableVars",  "Available variables: $player.id, $player.name, $player.xyz, $player.x, $player.y, $player.z" },
				{ "UsableCommands", "Available commands: add, remove, list, clear, vars" },
				{ "ErrorEnterID",       "You must enter ID of zone" },
				{ "ErrorEnterCommands", "You must enter at least one command" },
				{ "ErrorNotFound",      "Zone was not found" },
				{ "Added",   "Zone with commands was successfully added!" },
				{ "Removed", "Commands for zone has been removed!" },
				{ "Clear",   "All commands for zones were deleted" },
				{ "List",    "Zones with commands:\n" },
				{ "Unpermitted", "You do not have a permission to use this command" }
			}, this);
		}

		void OnServerInitialized()
		{
			data = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);

			if(data == null)
			{
				RaiseError("Unable to load data file");
				rust.RunServerCommand("oxide.unload " + Title);
			}

			if(!IsPluginExists("ZoneManager") || !IsPluginExists("RectZones"))
				RaiseError("You need to install ZoneManager or RectZones to use this plugin");
		}

		void Loaded()
		{
			LoadDefaultMessages();

			permission.RegisterPermission(PermissionName, this);
		}

		void Unload()
		{
			SaveData();
		}

		void OnEnterZone(string zoneID, BasePlayer player)
		{
			if (data.Zones.Count > 0)
			{
				foreach (Zone zone in data.Zones)
				{
					if (zone.Id == zoneID && zone.Mode == Modes.OnEnter)
						ExecuteZone(zone, player);
				}
			}
		}

		void OnExitZone(string zoneID, BasePlayer player)
		{
			if (data.Zones.Count > 0)
			{
				foreach (Zone zone in data.Zones)
				{
					if (zone.Id == zoneID && zone.Mode == Modes.OnExit)
						ExecuteZone(zone, player);
				}
			}
		}

		void ExecuteZone(Zone zone, BasePlayer player)
		{
			bool addPlayer = false;
			bool addOne    = false;

			switch (zone.Method)
			{
				case Methods.Always:
					if(zone.Amount != -1)
					{
						if(zone.Amount != zone.Players.Count)
							addPlayer = true;
						else
							return;
					}
					break;
				case Methods.PerPlayer:
					{
						if(zone.Amount != -1)
						{
							if (zone.Players.Count > 0)
							{
								bool found = false;

								foreach (ZonePlayer zp in zone.Players)
								{
									if(zp.UserId == player.userID)
									{
										found = true;

										if(zp.Count == zone.Amount)
											return;
										else
											zp.Count++;

										break;
									}
								}

								if(!found)
								{
									addPlayer = true;
									addOne = true;
								}
							}
							else
							{
								addPlayer = true;
								addOne = true;
							}
						}
						else
						{
							if (zone.Players.Count > 0)
							{
								foreach (ZonePlayer zp in zone.Players)
								{
									if (zp.UserId == player.userID)
										return;
								}

								addPlayer = true;
							}
							else
							{
								addPlayer = true;
							}
						}
					}
					break;
				case Methods.PerDay:
					// TODO: per day
					break;
				case Methods.PerGameDay:
					// TODO: per game day
					break;
			}

			if (addPlayer)
				zone.Add(new ZonePlayer { UserId = player.userID, Count = addOne ? 1 : 0 });

			foreach (string s in zone.Commands)
			{
				string command = s.Replace("$player.id", player.userID.ToString())
									.Replace("$player.name", player.displayName)
									.Replace("$player.xyz", player.transform.position.x + " " + player.transform.position.y + " " + player.transform.position.z)
									.Replace("$player.x", player.transform.position.x.ToString())
									.Replace("$player.y", player.transform.position.y.ToString())
									.Replace("$player.z", player.transform.position.z.ToString());

				if (command.StartsWith("sayto", StringComparison.CurrentCultureIgnoreCase))
					PrintToChat(player, command.Substring(6));

				rust.RunServerCommand(command);
			}
		}
	
		// /zcmd add 81195143 {say hello there} {say okay then}

		[ChatCommand("zcmd")]
		void cmdChat(BasePlayer player, string command, string[] args)
		{
			if (!IsPlayerPermitted(player, PermissionName))
				return;

			if (args.Length > 0)
			{
				string cmdWithArgs = ArrayToString(args);

				QueryLanguage.Lexer lexer = new QueryLanguage.Lexer();

				lexer.Parse(cmdWithArgs);

				QueryLanguage.Parser parser = new QueryLanguage.Parser(lexer.Lexems as List<QueryLanguage.Lexem>);

				QueryLanguage.LexemType type = parser.ParseCommand();

				string id = parser.ParseId();

				switch (type)
				{
					case QueryLanguage.LexemType.AddCmd:
						{
							if (string.IsNullOrEmpty(id))
							{
								PrintToChat(player, Lang("ErrorEnterID", player));
								return;
							}

							AddCommand(parser, id, player);
						}
						break;
					case QueryLanguage.LexemType.RemoveCmd:
						{
							if (string.IsNullOrEmpty(id))
							{
								PrintToChat(player, Lang("ErrorEnterID", player));
								return;
							}

							RemoveCommand(parser, id, player);
						}
						break;
					case QueryLanguage.LexemType.ListCmd:
						ListCommand(parser, player);
						break;
					default:
						PrintToChat(player, Lang("HelpText", player));
						break;
				}
			}
			else
			{
				PrintToChat(player, Lang("HelpText", player));
			}
		}

		[ConsoleCommand("zone.command")] // TODO: console command
		void cmdConsole(ConsoleSystem.Arg arg)
		{
			Puts("currently only from chat");
		}

		void AddCommand(QueryLanguage.Parser parser, string id, BasePlayer player)
		{
			PrintToChat("AddCommand");

			List<string> cmds = parser.ParseCommands();

			if(cmds.Count == 0)
			{
				PrintToChat(player, Lang("ErrorEnterCommands", player));
				return;
			}

			QueryLanguage.Parser.ExecutionAndCount executionAndCount = parser.ParseExecutionAndCount();

			Methods method = Methods.Always;

			switch(executionAndCount.Execution1)
			{
				case QueryLanguage.LexemType.Always: method = Methods.Always; break;
				case QueryLanguage.LexemType.Once: method = Methods.Once; break;
			}

			switch(executionAndCount.Execution2)
			{
				case QueryLanguage.LexemType.Player: method = Methods.PerPlayer; break;
				case QueryLanguage.LexemType.Day: method = Methods.PerDay; break;
				case QueryLanguage.LexemType.Game: method = Methods.PerGame; break;
			}

			if(executionAndCount.Execution2 == QueryLanguage.LexemType.Game && executionAndCount.Execution3 == QueryLanguage.LexemType.Day)
			{
				method = Methods.PerGameDay;
			}

			Zone zone = new Zone(id);
			zone.Commands = new List<string>(cmds);
			zone.Mode = parser.ParseRule() == QueryLanguage.LexemType.Exit ? Modes.OnExit : Modes.OnEnter;
			zone.Amount = executionAndCount.Count;
			zone.Method = method;
			zone.UserGroup = parser.ParseUserGroup();

			data.Add(zone);

			SaveData();
			PrintToChat(player, Lang("Added", player));
		}

		void RemoveCommand(QueryLanguage.Parser parser, string id, BasePlayer player)
		{
			if(data.Zones.RemoveWhere(x => x.Id == id) > 0)
			{
				player.ChatMessage(Lang("Removed", player));
			}
			else
			{
				player.ChatMessage(Lang("ErrorNotFound", player));
			}
		}

		void ListCommand(QueryLanguage.Parser parser, BasePlayer player)
		{
			string result = string.Empty;

			foreach (Zone zone in data.Zones)
			{
				result += zone.Id + " (" + (zone.Mode == Modes.OnEnter ? "on enter" : "on exit") + ", " + zone.Method.ToString().ToLower() + "):\n\t";
				
				foreach(string command in zone.Commands)
				{
					result += command + ", ";
				}

				result = result.Substring(0, result.Length - 2);
			}

			if(string.IsNullOrEmpty(result))
			{
				player.ChatMessage(Lang("ErrorNotFound", player));
				return;
			}

			player.ChatMessage(result);
		}

		void AddZone(BasePlayer player, string[] args, Methods method, bool onlyAmount = false, bool hasMethod = true)
		{
			Zone zone = new Zone(args[1]);
			zone.Method = method;

			int offset = 2;

			if (onlyAmount)
			{
				zone.Amount = int.Parse(args[2]);
				offset++;
			}
			else
			{
				if (hasMethod)
					offset++;

				if (IsDigitsOnly(args[3]))
				{
					zone.Amount = int.Parse(args[3]);
					offset++;
				}
			}
			
			string cmd = "";
			for (int i = offset; i < args.Length; i++)
				cmd += args[i] + " ";

			zone.Add(cmd.Substring(0, cmd.Length - 1));
			data.Add(zone);

			SaveData();
			PrintToChat(player, Lang("Added"));
		}

		void RemoveZone(BasePlayer player, string[] args)
		{
			int removed = data.Zones.RemoveWhere(x => x.Id == args[1]);

			if (removed > 0)
			{
				SaveData();
				PrintToChat(player, Lang("Removed"));
			}
			else
			{
				PrintToChat(player, Lang("ErrorNotFound"));
			}
		}

		void PrintZoneList(BasePlayer player)
		{
			string message = Lang("List");

			if (data.Zones.Count > 0)
			{
				foreach (Zone z in data.Zones)
				{
					message += z.Id;

					switch(z.Mode)
					{
						case Modes.OnEnter:
							message += " (on enter) ";
							break;
						case Modes.OnExit:
							message += " ( on exit) ";
							break;
					}

					switch(z.Method)
					{
						case Methods.Always:
							message += "(always)";
							break;
						case Methods.PerPlayer:
							message += "(per player)";
							break;
						case Methods.PerDay:
							message += "(per day)";
							break;
						case Methods.PerGameDay:
							message += "(per game day)";
							break;
					}

					message += (z.Amount > 0 ? (" (" + z.Amount + ")") : "") + ":\n";

					foreach (string s in z.Commands)
						message += s + "; ";

					message = message.Substring(0, message.Length - 2) + "\n";
				}

				message = message.Substring(0, message.Length - 1);
			}
			else
			{
				message += Lang("ErrorNotFound");
			}

			PrintToChat(player, message);
		}

		void SendHelpText(BasePlayer player)
		{
			if(IsPlayerPermitted(player, PermissionName))
				PrintToChat(player, Lang("HelpText"));
		}

		// ----------------------------- UTILS -----------------------------
		// -----------------------------------------------------------------

		bool IsPluginExists(string name)
		{
			return Interface.GetMod().GetLibrary<Core.Libraries.Plugins>().Exists(name);
		}

		string Lang(string key, BasePlayer player = null)
		{
			return lang.GetMessage(key, this, player?.UserIDString);
		}

		void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject(Title, data);
		}

		bool IsDigitsOnly(string str)
		{
			foreach (char c in str)
				if (c < '0' || c > '9')
					return false;
			return true;
		}

		string ArrayToString(string[] array)
		{
			string result = string.Empty;

			foreach (string s in array)
			{
				result += s + " ";
			}

			return result;
		}

		bool IsPlayerPermitted(BasePlayer player, string permissionName)
		{
			return player.IsAdmin() || permission.UserHasPermission(player.UserIDString, permissionName);
		}

		// ---------------------------- PARSER -----------------------------
		// -----------------------------------------------------------------

		class QueryLanguage
		{
			/*
				add           				--Ë¥
				remove        				--Ë§------ required
				list          				--Ë©

				on                          --------- required for next one

				enter						--Ë¥------ not required
				exit						--Ë©

				123456780     				--------- required

				execute       				--------- required for next two

				always						--Ë¥
				once						--Ë§
				per day						--Ë§
				per game â login/logout		--Ë§------ not required
				per game day				--Ë§
				per player					--Ë©

				x times						--------- not required

				only for x 					--------- user group (admin, player, etc.) (number or string) (not required)

				from x:xx to y:yy			--------- not required

				{command}					--------- required (commands in braces)
			*/

			public enum LexemType
			{
				AddCmd, RemoveCmd, ListCmd,
				Text, StartBrace, EndBrace,
				On, Enter, Exit,
				Execute, Always, Once, Per, Day, Game, Player, Times,
				Only, For,
				From, To,
				Unknown
			}

			public class Lexem
			{
				public LexemType Type;
				public string Value;
				public int Offset;
			}

			class LexemDefenition<T>
			{
				public LexemType Type;
				public T Representation;

				public LexemDefenition(T representation, LexemType type)
				{
					Representation = representation;
					Type = type;
				}
			}

			class DynamicLexemDefenition : LexemDefenition<Regex>
			{
				public DynamicLexemDefenition(string representation, LexemType type) : base(new Regex(representation, RegexOptions.Compiled), type) { }
			}

			class StaticLexemDefenition : LexemDefenition<string>
			{
				public StaticLexemDefenition(string representation, LexemType type) : base(representation, type) { }
			}

			static class LexemDefenitions
			{
				public static StaticLexemDefenition[] Static = new[]
				{
					new StaticLexemDefenition("add", LexemType.AddCmd),
					new StaticLexemDefenition("remove", LexemType.RemoveCmd),
					new StaticLexemDefenition("list", LexemType.ListCmd),

					new StaticLexemDefenition("on", LexemType.On),
					new StaticLexemDefenition("enter", LexemType.Enter),
					new StaticLexemDefenition("exit", LexemType.Exit),

					new StaticLexemDefenition("execute", LexemType.Execute),
					new StaticLexemDefenition("per", LexemType.Per),
					new StaticLexemDefenition("only", LexemType.Only),
					new StaticLexemDefenition("for", LexemType.For),
					new StaticLexemDefenition("times", LexemType.Times),

					new StaticLexemDefenition("always", LexemType.Always),
					new StaticLexemDefenition("once", LexemType.Once),

					new StaticLexemDefenition("day", LexemType.Day),
					new StaticLexemDefenition("game", LexemType.Game),
					new StaticLexemDefenition("player", LexemType.Player),

					new StaticLexemDefenition("from", LexemType.From),
					new StaticLexemDefenition("to", LexemType.To),

					new StaticLexemDefenition("{", LexemType.StartBrace),
					new StaticLexemDefenition("}", LexemType.EndBrace)
				};

				public static DynamicLexemDefenition[] Dynamic = new[]
				{
					new DynamicLexemDefenition(@"[\s\S]", LexemType.Text)
				};
			}

			public class Lexer
			{
				public IEnumerable<Lexem> Lexems { get; private set; }

				string source;
				int offset;

				public void Parse(string src)
				{
					source = src;

					var prepLexems = new List<Lexem>();

					while (InBounds())
					{
						Lexem lexem = ProcessStatic() ?? ProcessDynamic();

						if (lexem != null)
							prepLexems.Add(lexem);
					}

					var lexems = new List<Lexem>();
					Lexem firstTextLexem = null;

					foreach (Lexem lexem in prepLexems) // Fix for text. Idk how to do it properly
					{
						if (lexem.Type == LexemType.Text)
						{
							if (firstTextLexem == null)
								firstTextLexem = lexem;
							else
								firstTextLexem.Value += lexem.Value;
						}
						else
						{
							if (firstTextLexem != null)
							{
								lexems.Add(firstTextLexem);
								firstTextLexem = null;
							}

							lexems.Add(lexem);
						}
					}

					Lexems = lexems;
				}

				Lexem ProcessStatic()
				{
					foreach (var defenition in LexemDefenitions.Static)
					{
						var representation = defenition.Representation;
						var length = representation.Length;

						if (offset + length > source.Length || !source.Substring(offset, length).Equals(representation, StringComparison.CurrentCultureIgnoreCase))
							continue;

						offset += length;

						return new Lexem { Type = defenition.Type, Offset = offset, Value = representation };
					}

					return null;
				}

				Lexem ProcessDynamic()
				{
					foreach (var defenition in LexemDefenitions.Dynamic)
					{
						var match = defenition.Representation.Match(source, offset);

						if (!match.Success)
							continue;

						offset += match.Length;

						return new Lexem { Type = defenition.Type, Offset = offset, Value = match.Value };
					}

					return null;
				}

				bool InBounds()
				{
					return offset < source.Length;
				}
			}

			public class Parser
			{
				List<Lexem> lexems;

				public class Time
				{
					public TimeSpan? From;
					public TimeSpan? To;

					public Time(TimeSpan? from, TimeSpan? to) { From = from; To = to; }
				}

				public class ExecutionAndCount
				{
					public LexemType Execution1 = LexemType.Unknown;
					public LexemType Execution2 = LexemType.Unknown;
					public LexemType Execution3 = LexemType.Unknown;
					public int Count;

					public ExecutionAndCount(LexemType ex1 = LexemType.Unknown, LexemType ex2 = LexemType.Unknown, LexemType ex3 = LexemType.Unknown, int count = 0)
					{
						Execution1 = ex1;
						Execution2 = ex2;
						Execution3 = ex3;
						Count = count;
					}
				}

				public Parser(List<Lexem> lexems)
				{
					this.lexems = lexems;
				}

				/// <summary>Unknown if not command</summary>
				public LexemType ParseCommand()
				{
					Lexem lexem = lexems[0];

					LexemType type = lexem.Type;

					if (type == LexemType.AddCmd || type == LexemType.ListCmd || type == LexemType.RemoveCmd)
						return type;

					return LexemType.Unknown;
				}

				public LexemType ParseRule()
				{
					if (lexems[2].Type == LexemType.On)
					{
						if (lexems[4].Type == LexemType.Enter || lexems[4].Type == LexemType.Exit)
							return lexems[4].Type;
					}

					return LexemType.Unknown;
				}

				/// <summary>Empty if no id</summary>
				public string ParseId()
				{
					Lexem lexem = lexems[1];

					string id = lexem.Value.Trim();

					if (lexem.Type == LexemType.Text)
						return id;

					return string.Empty;
				}

				public ExecutionAndCount ParseExecutionAndCount()
				{
					for (int i = 2; i < lexems.Count; i++)
					{
						if (lexems[i].Type == LexemType.Execute)
						{
							LexemType executionType1 = lexems[i + 2].Type;

							if (executionType1 == LexemType.Always || executionType1 == LexemType.Once)
							{
								int count = ParseCount(i + 2);
								return new ExecutionAndCount(executionType1, LexemType.Unknown, LexemType.Unknown, count);
							}
							else if (executionType1 == LexemType.Per)
							{
								LexemType executionType2 = lexems[i + 4].Type;

								if (executionType2 == LexemType.Day || executionType2 == LexemType.Player)
								{
									int count = ParseCount(i + 4);
									return new ExecutionAndCount(LexemType.Per, executionType2, LexemType.Unknown, count);
								}
								else if (executionType2 == LexemType.Game)
								{
									if (lexems[i + 6].Type == LexemType.Day)
									{
										int count2 = ParseCount(i + 6);
										return new ExecutionAndCount(LexemType.Per, LexemType.Game, LexemType.Day, count2);
									}

									int count = ParseCount(i + 4);
									return new ExecutionAndCount(LexemType.Per, LexemType.Game, LexemType.Unknown, count);
								}
							}
							else
							{
								int count = ParseCount(i);
								return new ExecutionAndCount(LexemType.Unknown, LexemType.Unknown, LexemType.Unknown, count);
							}
						}
						else if (lexems[i].Type == LexemType.StartBrace)
						{
							break;
						}
					}

					return new ExecutionAndCount();
				}

				int ParseCount(int position)
				{
					if (lexems[position + 1].Type == LexemType.Text)
					{
						if (lexems[position + 2].Type == LexemType.Times)
						{
							int number;

							int.TryParse(lexems[position + 1].Value.Trim(), out number);

							return number;
						}
					}

					return -1;
				}

				public List<string> ParseCommands()
				{
					List<string> cmds = new List<string>(1);

					for (int i = 2; i < lexems.Count; i++)
					{
						Lexem lexemStart = lexems[i]; // Start brace

						if (lexemStart.Type == LexemType.StartBrace)
						{
							string cmd = string.Empty;

							for (int ii = i + 1; ii < lexems.Count; ii++)
							{
								Lexem lexemCmd = lexems[ii];

								if (lexemCmd.Type != LexemType.EndBrace)
								{
									cmd += lexemCmd.Value;
								}
								else
								{
									i = ii;
									cmds.Add(cmd.TrimStart().TrimEnd());

									break;
								}
							}
						}
					}

					return cmds;
				}

				public string ParseUserGroup()
				{
					for (int i = 2; i < lexems.Count; i++)
					{
						if (lexems[i].Type == LexemType.Only && lexems[i + 2].Type == LexemType.For)
						{
							if (lexems[i + 3].Type == LexemType.Text)
							{
								return lexems[i + 3].Value.TrimStart().TrimEnd();
							}
						}
						else if (lexems[i].Type == LexemType.StartBrace)
						{
							break;
						}
					}

					return string.Empty;
				}

				public Time ParseTime()
				{
					for (int i = 2; i < lexems.Count; i++)
					{
						if (lexems[i].Type == LexemType.From)
						{
							string from = string.Empty;

							if (lexems[i + 1].Type == LexemType.Text)
							{
								from = lexems[i + 1].Value.Trim();

								if (lexems[i + 2].Type == LexemType.To)
								{
									if (lexems[i + 3].Type == LexemType.Text)
									{
										TimeSpan timeFrom;
										TimeSpan timeTo;

										bool fromSuccess = TimeSpan.TryParse(from, out timeFrom);

										if (!fromSuccess)
											return new Time(null, null);

										bool toSuccess = TimeSpan.TryParse(lexems[i + 3].Value.Trim(), out timeTo);

										if (!toSuccess)
											return new Time(null, null);

										return new Time(timeFrom, timeTo);
									}
								}
							}
						}
					}

					return new Time(null, null);
				}
			}
		}

	}
}


// --- End of file: ZoneCommand.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RadHouse.cs ---
// --- Original Local Path: RadHouse.cs ---

﻿using Facepunch;
using Network;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("RadHouse", "123", "1.2.1")]

    class RadHouse : RustPlugin
    {
        // Other needed functions and vars
        #region SomeParameters and plugin's load
        static RadHouse instance;
        [PluginReference]
        Plugin RandomSpawns;
        [PluginReference]
        Plugin RustMap;
        [PluginReference]
        Plugin Map;
        [PluginReference]
        Plugin LustyMap;

        static RadHouse ins;

        private List<ZoneList> RadiationZones = new List<ZoneList>();
        private static readonly int playerLayer = LayerMask.GetMask("Player (Server)");
        private static readonly Collider[] colBuffer = Vis.colBuffer;
        private ZoneList RadHouseZone;
        private BaseEntity LootBox;


        public List<BaseEntity> BaseEntityList = new List<BaseEntity>();
        public List<ulong> PlayerAuth = new List<ulong>();

        private DateTime DateOfWipe;
        private string DateOfWipeStr;

        public bool CanLoot = false;
        public bool NowLooted = false;
        public Timer mytimer;
        public Timer mytimer2;
        public Timer mytimer3;
        public Timer mytimer4;
        public Timer mytimer5;
        public int timercallbackdelay = 0;

        #region CFG var's
        public class Amount
        {
            public object ShortName;
            public object Min;
            public object Max;
        }

        public class DataStorage
        {
            public Dictionary<string, Amount>[] Common = new Dictionary<string, Amount>[]
            {
            new Dictionary<string, Amount>()
            {
                ["Wood"] = new Amount() { ShortName = "wood", Min = 3000, Max = 10000 },
                ["Stone"] = new Amount() { ShortName = "stones", Min = 5000, Max = 9000 },
                ["Metall"] = new Amount() { ShortName = "metal.fragments", Min = 1000, Max = 5000 },
                ["Charcoal"] = new Amount() { ShortName = "charcoal", Min = 2500, Max = 10000 },
                ["Fuel"] = new Amount() { ShortName = "lowgradefuel", Min = 100, Max = 500 }
            },
            new Dictionary<string, Amount>()
            {
                ["Wood"] = new Amount() { ShortName = "wood", Min = 5000, Max = 15000 },
                ["Stone"] = new Amount() { ShortName = "stones", Min = 9000, Max = 20000 },
                ["Metall"] = new Amount() { ShortName = "metal.fragments", Min = 2500, Max = 10000 },
                ["Charcoal"] = new Amount() { ShortName = "charcoal", Min = 5000, Max = 15000 },
                ["Fuel"] = new Amount() { ShortName = "lowgradefuel", Min = 250, Max = 900 },
                ["HQMetall"] = new Amount() { ShortName = "metal.refined", Min = 50, Max = 150 }
            },
            new Dictionary<string, Amount>()
            {
                ["Wood"] = new Amount() { ShortName = "wood", Min = 8000, Max = 25000 },
                ["Stone"] = new Amount() { ShortName = "stones", Min = 15000, Max = 32000 },
                ["Metall"] = new Amount() { ShortName = "metal.fragments", Min = 5000, Max = 15000 },
                ["Charcoal"] = new Amount() { ShortName = "charcoal", Min = 7000, Max = 23000 },
                ["Fuel"] = new Amount() { ShortName = "lowgradefuel", Min = 350, Max = 1200 },
                ["HQMetall"] = new Amount() { ShortName = "metal.refined", Min = 150, Max = 400 },
                ["Sulfur"] = new Amount() { ShortName = "sulfur", Min = 1000, Max = 3500 }
            },
            new Dictionary<string, Amount>()
            {
                ["Wood"] = new Amount() { ShortName = "wood", Min = 15000, Max = 35000 },
                ["Stone"] = new Amount() { ShortName = "stones", Min = 40000, Max = 70000 },
                ["Metall"] = new Amount() { ShortName = "metal.fragments", Min = 10000, Max = 25000 },
                ["Charcoal"] = new Amount() { ShortName = "charcoal", Min = 20000, Max = 40000 },
                ["Fuel"] = new Amount() { ShortName = "lowgradefuel", Min = 500, Max = 1500 },
                ["HQMetall"] = new Amount() { ShortName = "metal.refined", Min = 250, Max = 600 },
                ["Sulfur"] = new Amount() { ShortName = "sulfur", Min = 2500, Max = 6000 },
                ["GunPow"] = new Amount() { ShortName = "gunpowder", Min = 1000, Max = 3000 }
            },
            new Dictionary<string, Amount>()
            {
                ["Wood"] = new Amount() { ShortName = "wood", Min = 25000, Max = 50000 },
                ["Stone"] = new Amount() { ShortName = "stones", Min = 50000, Max = 80000 },
                ["Metall"] = new Amount() { ShortName = "metal.fragments", Min = 15000, Max = 35000 },
                ["Charcoal"] = new Amount() { ShortName = "charcoal", Min = 30000, Max = 50000 },
                ["Fuel"] = new Amount() { ShortName = "lowgradefuel", Min = 750, Max = 1750 },
                ["HQMetall"] = new Amount() { ShortName = "metal.refined", Min = 350, Max = 700 },
                ["Sulfur"] = new Amount() { ShortName = "sulfur", Min = 3500, Max = 7000 },
                ["GunPow"] = new Amount() { ShortName = "gunpowder", Min = 2000, Max = 5000 },
                ["Explosives"] = new Amount() { ShortName = "explosives", Min = 70, Max = 150 }
            },
            new Dictionary<string, Amount>()
            {
                ["Wood"] = new Amount() { ShortName = "wood", Min = 35000, Max = 70000 },
                ["Stone"] = new Amount() { ShortName = "stones", Min = 70000, Max = 100000 },
                ["Metall"] = new Amount() { ShortName = "metal.fragments", Min = 20000, Max = 40000 },
                ["Charcoal"] = new Amount() { ShortName = "charcoal", Min = 40000, Max = 60000 },
                ["Fuel"] = new Amount() { ShortName = "lowgradefuel", Min = 1000, Max = 2000 },
                ["HQMetall"] = new Amount() { ShortName = "metal.refined", Min = 500, Max = 900 },
                ["Sulfur"] = new Amount() { ShortName = "sulfur", Min = 5000, Max = 10000 },
                ["GunPow"] = new Amount() { ShortName = "gunpowder", Min = 4000, Max = 7000 },
                ["Explosives"] = new Amount() { ShortName = "explosives", Min = 100, Max = 250 }
            },
            new Dictionary<string, Amount>()
            {
                ["Wood"] = new Amount() { ShortName = "wood", Min = 50000, Max = 90000 },
                ["Stone"] = new Amount() { ShortName = "stones", Min = 90000, Max = 130000 },
                ["Metall"] = new Amount() { ShortName = "metal.fragments", Min = 25000, Max = 47000 },
                ["Charcoal"] = new Amount() { ShortName = "charcoal", Min = 50000, Max = 70000 },
                ["Fuel"] = new Amount() { ShortName = "lowgradefuel", Min = 1300, Max = 2500 },
                ["HQMetall"] = new Amount() { ShortName = "metal.refined", Min = 700, Max = 1200 },
                ["Sulfur"] = new Amount() { ShortName = "sulfur", Min = 10000, Max = 20000 },
                ["GunPow"] = new Amount() { ShortName = "gunpowder", Min = 7000, Max = 15000 },
                ["Explosives"] = new Amount() { ShortName = "explosives", Min = 250, Max = 400 }
            }
            };
            public Dictionary<string, Amount>[] Rare = new Dictionary<string, Amount>[]
            {
            new Dictionary<string, Amount>()
            {
                ["WoodGates"] = new Amount() { ShortName = "gates.external.high.wood", Min = 1, Max = 1 },
                ["WoodWall"] = new Amount() { ShortName = "wall.external.high", Min = 2, Max = 3 },
                ["MetallBarricade"] = new Amount() { ShortName = "barricade.metal", Min = 2, Max = 3 }
            },
            new Dictionary<string, Amount>()
            {
                ["StoneWall"] = new Amount() { ShortName = "wall.external.high.stone", Min = 2, Max = 3 },
                ["StoneGate"] = new Amount() { ShortName = "gates.external.high.stone", Min = 1, Max = 1 },
                ["P250"] = new Amount() { ShortName = "pistol.semiauto", Min = 1, Max = 1 },
                ["Python"] = new Amount() { ShortName = "pistol.python", Min = 1, Max = 1 }
            },
            new Dictionary<string, Amount>()
            {
                ["GunPow"] = new Amount() { ShortName = "gunpowder", Min = 500, Max = 2000 },
                ["Explosives"] = new Amount() { ShortName = "explosives", Min = 10, Max = 40 },
                ["Smg"] = new Amount() { ShortName = "smg.2", Min = 1, Max = 1 },
                ["SmgMp5"] = new Amount() { ShortName = "smg.mp5", Min = 1, Max = 1 }
            },
            new Dictionary<string, Amount>()
            {
                ["Explosives"] = new Amount() { ShortName = "explosives", Min = 40, Max = 100 },
                ["Thompson"] = new Amount() { ShortName = "smg.thompson", Min = 1, Max = 1 },
                ["Bolt"] = new Amount() { ShortName = "rifle.bolt", Min = 1, Max = 1 },
                ["B4"] = new Amount() { ShortName = "explosive.satchel", Min = 4, Max = 11 }
            },
            new Dictionary<string, Amount>()
            {
                ["AmmoRifle"] = new Amount() { ShortName = "ammo.rifle", Min = 90, Max = 150 },
                ["Bolt"] = new Amount() { ShortName = "rifle.bolt", Min = 1, Max = 1 },
                ["LR300"] = new Amount() { ShortName = "rifle.lr300", Min = 1, Max = 1 },
                ["Ak"] = new Amount() { ShortName = "rifle.ak", Min = 1, Max = 1 },
                ["Mask"] = new Amount() { ShortName = "metal.facemask", Min = 1, Max = 1 },
                ["B4"] = new Amount() { ShortName = "explosive.satchel", Min = 8, Max = 17 }
            },
            new Dictionary<string, Amount>()
            {
                ["AmmoRifle"] = new Amount() { ShortName = "ammo.rifle", Min = 60, Max = 120 },
                ["Bolt"] = new Amount() { ShortName = "rifle.bolt", Min = 1, Max = 1 },
                ["LR300"] = new Amount() { ShortName = "rifle.lr300", Min = 1, Max = 1 },
                ["Ak"] = new Amount() { ShortName = "rifle.ak", Min = 1, Max = 1 },
                ["C4"] = new Amount() { ShortName = "explosive.timed", Min = 2, Max = 4 },
                ["B4"] = new Amount() { ShortName = "explosive.satchel", Min = 6, Max = 13 }
            },
            new Dictionary<string, Amount>()
            {
                ["AmmoRifle"] = new Amount() { ShortName = "ammo.rifle", Min = 150, Max = 240 },
                ["Bolt"] = new Amount() { ShortName = "rifle.bolt", Min = 1, Max = 1 },
                ["LR300"] = new Amount() { ShortName = "rifle.lr300", Min = 1, Max = 1 },
                ["Ak"] = new Amount() { ShortName = "rifle.ak", Min = 1, Max = 1 },
                ["Launcher"] = new Amount() { ShortName = "rocket.launcher", Min = 1, Max = 1 },
                ["M249"] = new Amount() { ShortName = "lmg.m249", Min = 1, Max = 1 }
            }
            };
            public Dictionary<string, Amount>[] Top = new Dictionary<string, Amount>[]
            {
            new Dictionary<string, Amount>()
            {
                ["DoorHQ"] = new Amount() { ShortName = "door.hinged.toptier", Min = 1, Max = 1 },
                ["DdoorHQ"] = new Amount() { ShortName = "door.double.hinged.toptier", Min = 1, Max = 2 },
                ["p250"] = new Amount() { ShortName = "pistol.semiauto", Min = 1, Max = 1 }
            },
            new Dictionary<string, Amount>()
            {
                ["Pomp"] = new Amount() { ShortName = "shotgun.pump", Min = 1, Max = 1 },
                ["B4"] = new Amount() { ShortName = "explosive.satchel", Min = 1, Max = 4 },
                ["m92"] = new Amount() { ShortName = "pistol.m92", Min = 1, Max = 1 }
            },
            new Dictionary<string, Amount>()
            {
                ["Thompson"] = new Amount() { ShortName = "smg.thompson", Min = 1, Max = 1 },
                ["Ak"] = new Amount() { ShortName = "rifle.ak", Min = 1, Max = 1 },
                ["B4"] = new Amount() { ShortName = "explosive.satchel", Min = 3, Max = 9 }
            },
            new Dictionary<string, Amount>()
            {
                ["C4"] = new Amount() { ShortName = "explosive.timed", Min = 1, Max = 3 },
                ["LR300"] = new Amount() { ShortName = "rifle.lr300", Min = 1, Max = 1 },
                ["Plate"] = new Amount() { ShortName = "metal.plate.torso", Min = 1, Max = 1 }
            },
            new Dictionary<string, Amount>()
            {
                ["C4"] = new Amount() { ShortName = "explosive.timed", Min = 3, Max = 5 },
                ["Launcher"] = new Amount() { ShortName = "rocket.launcher", Min = 1, Max = 1 },
                ["M249"] = new Amount() { ShortName = "lmg.m249", Min = 1, Max = 1 }
            },
            new Dictionary<string, Amount>()
            {
                ["C4"] = new Amount() { ShortName = "explosive.timed", Min = 7, Max = 10 },
                ["LauncherRocket"] = new Amount() { ShortName = "ammo.rocket.basic", Min = 4, Max = 11 },
                ["M249"] = new Amount() { ShortName = "lmg.m249", Min = 1, Max = 1 }
            },
            new Dictionary<string, Amount>()
            {
                ["C4"] = new Amount() { ShortName = "explosive.timed", Min = 10, Max = 15 },
                ["LauncherRocket"] = new Amount() { ShortName = "ammo.rocket.basic", Min = 15, Max = 35 },
                ["B4"] = new Amount() { ShortName = "explosive.satchel", Min = 19, Max = 31 }
            }
            };

            public Dictionary<string, float>[] RadiationRadius = new Dictionary<string, float>[]
            {
                new Dictionary<string, float>()
                {
                    ["Радиус радиации в первый день"] = 10,
                    ["Радиус радиации во второй день"] = 12,
                    ["Радиус радиации в третий день"] = 14,
                    ["Радиус радиации в четвертый день"] = 16,
                    ["Радиус радиации в пятый день"] = 18,
                    ["Радиус радиации в шестой день"] = 20,
                    ["Радиус радиации в седьмой день"] = 20,
                }
            };

            public Dictionary<string, float>[] RadiationIntensity = new Dictionary<string, float>[]
            {
                new Dictionary<string, float>()
                {
                    ["Радиация в первый день"] = 10,
                    ["Радиация во второй день"] = 15,
                    ["Радиация в третий день"] = 20,
                    ["Радиация в четвертый день"] = 25,
                    ["Радиация в пятый день"] = 30,
                    ["Радиация в шестой день"] = 35,
                    ["Радиация в седьмой день"] = 40,
                }
            };
            public DataStorage() { }
        }

        DataStorage data;
        private DynamicConfigFile RadData;

        public bool GuiOn = true;
        public string AnchorMinCfg = "0.3445 0.16075";
        public string AnchorMaxCfg = "0.6405 0.20075";
        public string ColorCfg = "1 1 1 0.1";
        public string TextGUI = "Radiation House:";
        public bool RadiationTrue = false;
        public string ChatPrefix = "<color=#ffe100>Radiation House:</color>";
        public int TimerSpawnHouse = 3600;
        public int TimerDestroyHouse = 60;
        public int TimerLoot = 300;
        public int TimeToRemove = 300;
        public int GradeNum = 1;
        public int MinPlayers = 15;

        public bool NativeMap = true;
        public float NativeMapAlpha = 0.5f;
        public string NativeMapColor = "#ce422b";
        public int NativeMapRadius = 10;

        public bool EnabledNPC = true;
        public int AmountNPC = 5;
        public bool LootNPC = true;

        #endregion


        protected override void LoadDefaultConfig()
        {
            LoadConfigValues();
        }

        private void LoadConfigValues()
        {
            DateOfWipe = DateTime.Now;
            DateOfWipeStr = DateOfWipe.ToString();
            GetConfig("[Стандартная карта]", "Создавать радиус (круг) на стандартной карте", ref NativeMap);
            GetConfig("[Стандартная карта]", "Радиус круга на стандартной карте", ref NativeMapRadius);
            GetConfig("[Стандартная карта]", "Цвет круга на стандартной карте (#hex)", ref NativeMapColor);
            GetConfig("[Стандартная карта]", "Прозрачность круга на стандартной карте", ref NativeMapAlpha);

            GetConfig("[GUI]", "Включить GUI", ref GuiOn);
            GetConfig("[GUI]", "Anchor Min", ref AnchorMinCfg);
            GetConfig("[GUI]", "Anchor Max", ref AnchorMaxCfg);
            GetConfig("[GUI]", "Цвет фона", ref ColorCfg);
            GetConfig("[GUI]", "Текст в GUI окне", ref TextGUI);
            GetConfig("[Основное]", "Дата вайпа", ref DateOfWipeStr);
            GetConfig("[Основное]", "Префикс чата", ref ChatPrefix);
            GetConfig("[Основное]", "Минимальный онлайн для запуска ивента", ref MinPlayers);
            GetConfig("[Основное]", "Материал дома (0 - солома, 4 - мвк)", ref GradeNum);
            GetConfig("[Радиация]", "Отключить стандартную радиацию", ref RadiationTrue);
            GetConfig("[Основное]", "Время спавна дома", ref TimerSpawnHouse);
            GetConfig("[Основное]", "Задержка перед лутанием ящика", ref TimerLoot);
            GetConfig("[Основное]", "Задержка перед удалением дома", ref TimerDestroyHouse);
            GetConfig("[Основное]", "Время удаления дома если в течение N секунд никто не авторизовался в шкафу", ref TimeToRemove);

            GetConfig("[NPC]", "Включить создание NPC возле радиационного дома", ref EnabledNPC);
            GetConfig("[NPC]", "Количество созданых NPC", ref AmountNPC);
            GetConfig("[NPC]", "Удалять тело, и рюкзак NPC после его смерти", ref LootNPC);
            SaveConfig();
        }

        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }

            Config[menu, Key] = var;
        }

        void OnServerInitialized()
        {
            instance = this;
            RadData = Interface.Oxide.DataFileSystem.GetFile("RadHouseLoot");
            LoadData();
            LoadDefaultConfig();
            mytimer4 = timer.Once(TimerSpawnHouse, () =>
            {
                if (mytimer4 != null) mytimer4.Destroy();
                try
                {
                    if (BaseEntityList.Count > 0)
                    {
                        DestroyRadHouse();
                    }
                    CreateRadHouse(false);
                }
                catch (Exception ex) { Puts(ex.ToString()); }
            });

        }

        void LoadData()
        {
            try
            {
                data = Interface.GetMod().DataFileSystem.ReadObject<DataStorage>("RadHouseLoot");
            }

            catch
            {
                data = new DataStorage();
            }
        }

        void Unload()
        {

            if (BaseEntityList != null) DestroyRadHouse();

            if (mytimer != null) timer.Destroy(ref mytimer);
            if (mytimer2 != null) timer.Destroy(ref mytimer2);
            if (mytimer3 != null) timer.Destroy(ref mytimer3);
            if (mytimer4 != null) timer.Destroy(ref mytimer4);
        }

        void OnNewSave(string filename)
        {
            DateOfWipe = DateTime.Now;
            string DateOfWipeStr = DateOfWipe.ToString();
            Config["[Основное]", "Дата вайпа"] = DateOfWipeStr;
            SaveConfig();
            PrintWarning($"Wipe detect. Дата установлена на {DateOfWipeStr}");
        }
        #endregion

        #region CreateAndDestroyRadHouse
        public object success;

        [ConsoleCommand("rh")]
        void CreateRadHouseConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();

            if (arg == null || arg.FullString.Length == 0 && arg.FullString != "start" && arg.FullString != "cancel")
            {
                SendReply(player, $"{ChatPrefix} Используйте /rh start или /rh cancel");
                return;
            }
            switch (arg.Args[0])
            {
                case "start":
                    SendReply(player, $"{ChatPrefix} Вы в ручную запустили ивент");
                    CreateRadHouse(true);
                    return;
                case "cancel":
                    SendReply(player, $"{ChatPrefix} Ивент остановлен");
                    DestroyRadHouse();
                    return;
            }
        }

        [ChatCommand("rh")]
        void CreateRadHouseCommand(BasePlayer player, string cmd, string[] Args)
        {
            if (player == null) return;
            if (!player.IsAdmin)
            {
                SendReply(player, $"{ChatPrefix} Команда доступна только администраторам");
                return;
            }
            if (Args == null || Args.Length == 0 || Args[0] != "start" && Args[0] != "cancel")
            {
                SendReply(player, $"{ChatPrefix} Используйте /rh start или /rh cancel");
                return;
            }
            switch (Args[0])
            {
                case "start":
                    SendReply(player, $"{ChatPrefix} Вы в ручную запустили ивент");
                    CreateRadHouse(true);
                    return;
                case "cancel":
                    SendReply(player, $"{ChatPrefix} Ивент остановлен");
                    DestroyRadHouse();
                    return;
            }

        }

        private void OnServerRadiation()
        {
            var allobjects = UnityEngine.Object.FindObjectsOfType<TriggerRadiation>();
            for (int i = 0; i < allobjects.Length; i++)
            {
                UnityEngine.Object.Destroy(allobjects[i]);
            }
        }

        Vector3 RadPosition;
        void CreateRadHouse(bool IsAdminCreate)
        {
            if (!IsAdminCreate && BasePlayer.activePlayerList.Count < MinPlayers)
            {
                PrintWarning("Не хватает игроков для запуска ивента");
                mytimer4 = timer.Once(TimerSpawnHouse, () =>
                {
                    if (mytimer4 != null) mytimer4.Destroy();
                    try
                    {
                        if (BaseEntityList.Count > 0)
                        {
                            DestroyRadHouse();
                        }
                        CreateRadHouse(false);
                    }
                    catch (Exception ex) { Puts(ex.ToString()); }
                });
                return;
            }
            if (BaseEntityList.Count > 0) DestroyRadHouse();
            Vector3 pos;
            pos.x = 0;
            pos.y = 0;
            pos.z = 0;
            success = GetEventPosition();
            pos = (Vector3)success;
            
            RadPosition = pos;
            pos.x = pos.x + 0f; pos.y = pos.y + 1f; pos.z = pos.z + 0f;
            BaseEntity Foundation = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", pos, new Quaternion(), true);

            pos.x = pos.x - 1.5f;
            BaseEntity Wall = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            Wall.transform.localEulerAngles = new Vector3(0f, 180f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 0f; pos.y = pos.y + 1f; pos.z = pos.z + 3f;
            BaseEntity Foundation2 = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", pos, new Quaternion(), true);

            pos.x = pos.x - 1.5f;
            BaseEntity Wall2 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            Wall2.transform.localEulerAngles = new Vector3(0f, 180f, 0f);

            //
            pos = (Vector3)success; pos.x = pos.x + 4.5f; pos.y = pos.y + 4f; pos.z = pos.z + 3f;
            BaseEntity Wall5 = GameManager.server.CreateEntity("assets/prefabs/building core/wall.window/wall.window.prefab", pos, new Quaternion(), true);
            Wall5.transform.localEulerAngles = new Vector3(0f, 0f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 4.5f; pos.y = pos.y + 4f; pos.z = pos.z + 0f;
            BaseEntity Wall6 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            Wall6.transform.localEulerAngles = new Vector3(0f, 0f, 0f);

            pos = (Vector3)success; pos.x = pos.x - 1.5f; pos.y = pos.y + 4f; pos.z = pos.z + 0f;
            BaseEntity Wall7 = GameManager.server.CreateEntity("assets/prefabs/building core/wall.window/wall.window.prefab", pos, new Quaternion(), true);
            Wall7.transform.localEulerAngles = new Vector3(0f, 180f, 0f);


            pos = (Vector3)success; pos.x = pos.x - 1.5f; pos.y = pos.y + 4f; pos.z = pos.z + 3f;
            BaseEntity Wall8 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            Wall8.transform.localEulerAngles = new Vector3(0f, 180f, 0f);
            //

            pos = (Vector3)success; pos.x = pos.x + 3f; pos.y = pos.y + 1f; pos.z = pos.z + 0f;
            BaseEntity Foundation3 = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", pos, new Quaternion(), true);

            pos.x = pos.x + 1.5f;
            BaseEntity Wall3 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);

            pos = (Vector3)success; pos.x = pos.x + 3f; pos.y = pos.y + 1f; pos.z = pos.z + 3f;
            BaseEntity Foundation4 = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", pos, new Quaternion(), true);

            pos.x = pos.x + 1.5f;
            BaseEntity Wall4 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);

            pos = (Vector3)success; pos.z = pos.z - 1.5f; pos.y = pos.y + 1f;
            BaseEntity DoorWay = GameManager.server.CreateEntity("assets/prefabs/building core/wall.doorway/wall.doorway.prefab", pos, new Quaternion(), true);
            DoorWay.transform.localEulerAngles = new Vector3(0f, 90f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 3f; pos.y = pos.y + 1f; pos.z = pos.z + 4.5f;
            BaseEntity DoorWay2 = GameManager.server.CreateEntity("assets/prefabs/building core/wall.doorway/wall.doorway.prefab", pos, new Quaternion(), true);
            DoorWay2.transform.localEulerAngles = new Vector3(0f, 270f, 0f);

            pos = (Vector3)success; pos.z = pos.z - 1.5f; pos.y = pos.y + 1f; pos.x = pos.x + 3f;
            BaseEntity WindowWall = GameManager.server.CreateEntity("assets/prefabs/building core/wall.window/wall.window.prefab", pos, new Quaternion(), true);
            WindowWall.transform.localEulerAngles = new Vector3(0f, 90f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 0f; pos.y = pos.y + 1f; pos.z = pos.z + 4.5f;
            BaseEntity WindowWall2 = GameManager.server.CreateEntity("assets/prefabs/building core/wall.window/wall.window.prefab", pos, new Quaternion(), true);
            WindowWall2.transform.localEulerAngles = new Vector3(0f, 270f, 0f);

            //yes
            pos = (Vector3)success; pos.x = pos.x + 0f; pos.y = pos.y + 4f; pos.z = pos.z + 4.5f;
            BaseEntity wall3 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            wall3.transform.localEulerAngles = new Vector3(0f, 270f, 0f);
            //
            //yes
            pos = (Vector3)success; pos.x = pos.x + 3f; pos.y = pos.y + 4f; pos.z = pos.z + 4.5f;
            BaseEntity wall4 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            wall4.transform.localEulerAngles = new Vector3(0f, 270f, 0f);
            //
            //yes
            pos = (Vector3)success; pos.z = pos.z - 1.5f; pos.y = pos.y + 4f; pos.x = pos.x + 3f;
            BaseEntity wall5 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            wall5.transform.localEulerAngles = new Vector3(0f, 90f, 0f);
            //yes
            pos = (Vector3)success; pos.z = pos.z - 1.5f; pos.y = pos.y + 4f;
            BaseEntity wall6 = GameManager.server.CreateEntity("assets/prefabs/building core/wall/wall.prefab", pos, new Quaternion(), true);
            wall6.transform.localEulerAngles = new Vector3(0f, 90f, 0f);


            pos = (Vector3)success; pos.x = pos.x + 0f; pos.y = pos.y + 4f; pos.z = pos.z + 0f;
            BaseEntity Roof = GameManager.server.CreateEntity("assets/prefabs/building core/floor/floor.prefab", pos, new Quaternion(), true);
            Roof.transform.localEulerAngles = new Vector3(0f, 180f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 3f; pos.y = pos.y + 1f; pos.z = pos.z + 0f;
            BaseEntity block = GameManager.server.CreateEntity("assets/prefabs/building core/stairs.l/block.stair.lshape.prefab", pos, new Quaternion(), true);
            block.transform.localEulerAngles = new Vector3(0f, 0f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 0f; pos.y = pos.y + 4f; pos.z = pos.z + 3f;
            BaseEntity Roof1 = GameManager.server.CreateEntity("assets/prefabs/building core/floor/floor.prefab", pos, new Quaternion(), true);
            Roof1.transform.localEulerAngles = new Vector3(0f, 0f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 3f; pos.y = pos.y + 4f; pos.z = pos.z + 3f;
            BaseEntity Roof2 = GameManager.server.CreateEntity("assets/prefabs/building core/floor/floor.prefab", pos, new Quaternion(), true);
            Roof2.transform.localEulerAngles = new Vector3(0f, 0f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 0f; pos.y = pos.y + 7f; pos.z = pos.z + 0f;
            BaseEntity Roof3 = GameManager.server.CreateEntity("assets/prefabs/building core/floor/floor.prefab", pos, new Quaternion(), true);
            Roof3.transform.localEulerAngles = new Vector3(0f, 180f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 3f; pos.y = pos.y + 7f; pos.z = pos.z + 0f;
            BaseEntity Roof4 = GameManager.server.CreateEntity("assets/prefabs/building core/floor/floor.prefab", pos, new Quaternion(), true);
            Roof4.transform.localEulerAngles = new Vector3(0f, 180f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 0f; pos.y = pos.y + 7f; pos.z = pos.z + 3f;
            BaseEntity Roof5 = GameManager.server.CreateEntity("assets/prefabs/building core/floor/floor.prefab", pos, new Quaternion(), true);
            Roof5.transform.localEulerAngles = new Vector3(0f, 0f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 3f; pos.y = pos.y + 7f; pos.z = pos.z + 3f;
            BaseEntity Roof6 = GameManager.server.CreateEntity("assets/prefabs/building core/floor/floor.prefab", pos, new Quaternion(), true);
            Roof6.transform.localEulerAngles = new Vector3(0f, 0f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 4.0f; pos.y = pos.y + 4f; pos.z = pos.z + 4f;
            BaseEntity CupBoard = GameManager.server.CreateEntity("assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab", pos, new Quaternion(), true);
            CupBoard.transform.localEulerAngles = new Vector3(0f, 270f, 0f);

            pos = (Vector3)success; pos.x = pos.x - 0.7f; pos.y = pos.y + 4f; pos.z = pos.z - 0f;
            BaseEntity Bed = GameManager.server.CreateEntity("assets/prefabs/deployable/bed/bed_deployed.prefab", pos, new Quaternion(), true);
            Bed.transform.localEulerAngles = new Vector3(0f, 270f, 0f);

            pos = (Vector3)success; pos.x = pos.x - 0.85f; pos.y = pos.y + 4.01f; pos.z = pos.z + 3.45f;
            BaseEntity Box = GameManager.server.CreateEntity("assets/prefabs/deployable/large wood storage/box.wooden.large.prefab", pos, new Quaternion(), true);
            Box.skinID = 942917320;
            Box.SetFlag(BaseEntity.Flags.Locked, true);
            Box.transform.localEulerAngles = new Vector3(0f, 90f, 0f);

            pos = (Vector3)success; pos.x = pos.x + 3; pos.y = pos.y - 0.5f; pos.z = pos.z + 7.5f;
            BaseEntity FSteps = GameManager.server.CreateEntity("assets/prefabs/building core/foundation.steps/foundation.steps.prefab", pos, new Quaternion(), true);
            FSteps.transform.localEulerAngles = new Vector3(0f, 90f, 0f);

            pos = (Vector3)success; pos.x = pos.x - 0f; pos.y = pos.y - 0.5f; pos.z = pos.z - 4.5f;
            BaseEntity FSteps2 = GameManager.server.CreateEntity("assets/prefabs/building core/foundation.steps/foundation.steps.prefab", pos, new Quaternion(), true);
            FSteps2.transform.localEulerAngles = new Vector3(0f, 270f, 0f);
            LootBox = Box;
            Foundation.Spawn();
            Wall.Spawn();
            Foundation2.Spawn();
            Wall2.Spawn();
            Foundation3.Spawn();
            Wall3.Spawn();
            Foundation4.Spawn();
            Wall4.Spawn();
            DoorWay.Spawn();
            DoorWay2.Spawn();
            WindowWall.Spawn();
            WindowWall2.Spawn();
            wall3.Spawn();
            Roof.Spawn();
            Roof1.Spawn();

            Roof3.Spawn();
            Roof4.Spawn();
            Roof5.Spawn();
            Roof6.Spawn();

            block.Spawn();
            Roof2.Spawn();
            wall4.Spawn();
            wall5.Spawn();
            wall6.Spawn();
            Wall5.Spawn();
            Wall6.Spawn();
            Wall7.Spawn();
            Wall8.Spawn();
            FSteps.Spawn();
            FSteps2.Spawn();
            CupBoard.Spawn();
            Box.Spawn();
            Bed.Spawn();

            BaseEntityList.Add(Foundation);
            BaseEntityList.Add(Roof);
            BaseEntityList.Add(block);
            BaseEntityList.Add(Roof1);
            BaseEntityList.Add(Roof2);

            BaseEntityList.Add(Roof3);
            BaseEntityList.Add(Roof4);
            BaseEntityList.Add(Roof5);
            BaseEntityList.Add(Roof6);

            BaseEntityList.Add(Foundation2);
            BaseEntityList.Add(Foundation3);
            BaseEntityList.Add(Foundation4);
            BaseEntityList.Add(Wall);
            BaseEntityList.Add(Wall2);
            BaseEntityList.Add(Wall3);
            BaseEntityList.Add(Wall4);
            BaseEntityList.Add(Wall7);
            BaseEntityList.Add(Wall8);
            BaseEntityList.Add(Wall6);
            BaseEntityList.Add(wall3);
            BaseEntityList.Add(wall4);
            BaseEntityList.Add(wall5);
            BaseEntityList.Add(wall6);
            BaseEntityList.Add(Wall5);
            BaseEntityList.Add(DoorWay);
            BaseEntityList.Add(DoorWay2);
            BaseEntityList.Add(WindowWall);
            BaseEntityList.Add(WindowWall2);
            BaseEntityList.Add(FSteps);
            BaseEntityList.Add(FSteps2);
            BaseEntityList.Add(CupBoard);
            BaseEntityList.Add(Box);
            BaseEntityList.Add(Bed);
            StorageContainer Container = Box.GetComponent<StorageContainer>();
            CreateLoot(Container, Box);
            var reply = 233;
            if (reply == 0) { };
            var buildingID = BuildingManager.server.NewBuildingID();
            try
            {
                foreach (var entity in BaseEntityList)
                {
                    DecayEntity decayEntity = entity.GetComponentInParent<DecayEntity>();
                    decayEntity.AttachToBuilding(buildingID);
                    if (entity.name.Contains("assets/prefabs/deployable/large wood storage/box.wooden.large.prefab") && entity.name.Contains("assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab") && entity.name.Contains("assets/prefabs/building/wall.window.bars/wall.window.bars.metal.prefab")) break;
                    BuildingBlock buildingBlock = entity.GetComponent<BuildingBlock>();
                    buildingBlock.SetGrade((BuildingGrade.Enum)GradeNum);
                    buildingBlock.UpdateSkin();
                    buildingBlock.SetHealthToMax();
                    if (!entity.name.Contains("assets/prefabs/building core/foundation/foundation.prefab") && !entity.name.Contains("assets/prefabs/building core/foundation.steps/foundation.steps.prefab")) buildingBlock.grounded = true;
                    buildingBlock.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                }
            }
            catch { }
            Server.Broadcast($"{ChatPrefix} Радиактивный дом появился, координаты: {pos.ToString()}\nЕсли никто не успеет авторизоваться за {TimeToRemove} секунд, он пропадет");
            mytimer5 = timer.Once(TimeToRemove, () =>
                {
                    if (BaseEntityList.Count > 0)
                    {
                        if (PlayerAuth.Count == 0)
                        {
                            DestroyRadHouse();
                            Server.Broadcast($"{ChatPrefix} Радиактивный дом удалился, никто не успел авторизоваться в шкафу");
                        }
                    }
                });

            foreach (var player in BasePlayer.activePlayerList)
            {
                CreateGui(player);
            }
            if (EnabledNPC) CreateNps(pos, AmountNPC);
            AddMapMarker();
           if (NativeMap) CreatePrivateMap(pos);
            CanLoot = false;
            NowLooted = false;
            timercallbackdelay = 0;
        }

        private void CreateNps(Vector3 position, int amount)
        {
            for (int i = 0; i < amount; i++)
            {
                BaseEntity npc = GameManager.server.CreateEntity("assets/prefabs/npc/scientist/scientist.prefab", RandomCircle(position, 10), new Quaternion(), true);
                npc.Spawn();
                BaseEntityList.Add(npc);
            }
        }

        private void AddMapMarker()
        {
            LustyMap?.Call("AddMarker", LootBox.transform.position.x, LootBox.transform.position.z, "RadIcon", "https://i.imgur.com/TxUxuN7.png", 0);
            Map?.Call("ApiAddPointUrl", "https://i.imgur.com/TxUxuN7.png", "Радиактивный дом", LootBox.transform.position);
            RustMap?.Call("AddTemporaryMarker", "rad", false, 0.04f, 0.99f, LootBox.transform, "RadHouseMap");
        }

        private void RemoveMapMarker()
        {
            LustyMap?.Call("RemoveMarker", "RadIcon");
            Map?.Call("ApiRemovePointUrl", "https://i.imgur.com/TxUxuN7.png", "Радиактивный дом", LootBox.transform.position);
            RustMap?.Call("RemoveTemporaryMarkerByName", "RadHouseMap");
        }

        private MapMarkerGenericRadius mapMarker;

        const string markerEnt = "assets/prefabs/tools/map/genericradiusmarker.prefab";

        private Color ConvertToColor(string color)
        {
            if (color.StartsWith("#"))
                color = color.Substring(1);
            int red = int.Parse(color.Substring(0, 2), NumberStyles.AllowHexSpecifier);
            int green = int.Parse(color.Substring(2, 2), NumberStyles.AllowHexSpecifier);
            int blue = int.Parse(color.Substring(4, 2), NumberStyles.AllowHexSpecifier);

            return new Color((float)red / 255, (float)green / 255, (float)blue / 255);
        }
        private void CreatePrivateMap(Vector3 pos)
        {
            mapMarker = (MapMarkerGenericRadius)GameManager.server.CreateEntity(markerEnt, pos , new Quaternion());
            mapMarker.enableSaving = false;
            mapMarker.Spawn();
            mapMarker.radius = NativeMapRadius;
            mapMarker.alpha = NativeMapAlpha;
            Color color = ConvertToColor(NativeMapColor);
            Color color2 = new Color(0, 0, 0, 0);
            mapMarker.color1 = color;
            mapMarker.color2 = color2;
            mapMarker.SendUpdate();

        }

        void DestroyRadHouse()
        {
            if (BaseEntityList != null)
            {
                foreach (BaseEntity entity in BaseEntityList)
                {
                    if (!entity.IsDestroyed)
                    entity.Kill();
                }
                DestroyZone(RadHouseZone);
                RemoveMapMarker();
                BaseEntityList.Clear();
                PlayerAuth.Clear();
                timer.Destroy(ref mytimer5);
                if (mapMarker != null && !mapMarker.IsDestroyed)
                    mapMarker.Kill();

            }
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyGui(player);
            }
            mytimer4 = timer.Once(TimerSpawnHouse, () =>
            {
                if (mytimer4 != null) mytimer4.Destroy();
                CreateRadHouse(false);
            });
            RadPosition = Vector3.zero;
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (BaseEntityList != null)
                {
                    foreach (BaseEntity entityInList in BaseEntityList)
                    {

                        if (entityInList.net.ID == entity.net.ID)
                        {
                            if (entityInList.name == "assets/prefabs/npc/scientist/scientist.prefab") return null;
                            return false;
                        }
                    }
                }
            }
            catch { return null; }
            return null;
        }

        void CreateLoot(StorageContainer Container, BaseEntity Box)
        {
            int Day = data.Common.Length - 1;
            DateTime DateOfWipeParse;
            DateTime.TryParse(DateOfWipeStr, out DateOfWipeParse);
            for (int i = 0; i <= data.Common.Length; i++)
            {
                if (DateOfWipeParse.AddDays(i) >= DateTime.Now)
                {
                    Day = i - 1;
                    break;
                }
            }
            ItemContainer inven = Container.inventory;
            if (Container != null)
            {
                var CommonList = data.Common[Day].Values.ToList();
                var RareList = data.Rare[Day].Values.ToList();
                var TopList = data.Top[Day].Values.ToList();
                for (var i = 0; i < CommonList.Count; i++)
                {
                    int j = UnityEngine.Random.Range(1, 10);
                    var item = ItemManager.CreateByName(CommonList[i].ShortName.ToString(), UnityEngine.Random.Range(Convert.ToInt32(CommonList[i].Min), Convert.ToInt32(CommonList[i].Max)));
                    if (j > 3)
                    {
                        item.MoveToContainer(Container.inventory, -1, false);
                    }
                }
                for (var i = 0; i < RareList.Count; i++)
                {
                    int j = UnityEngine.Random.Range(1, 10);
                    var item = ItemManager.CreateByName(RareList[i].ShortName.ToString(), UnityEngine.Random.Range(Convert.ToInt32(RareList[i].Min), Convert.ToInt32(RareList[i].Max)));
                    if (j > 5)
                    {
                        item.MoveToContainer(Container.inventory, -1, false);
                    }
                }
                for (var i = 0; i < TopList.Count; i++)
                {
                    int j = UnityEngine.Random.Range(1, 10);
                    var item = ItemManager.CreateByName(TopList[i].ShortName.ToString(), UnityEngine.Random.Range(Convert.ToInt32(TopList[i].Min), Convert.ToInt32(TopList[i].Max)));
                    if (j > 7)
                    {
                        item.MoveToContainer(Container.inventory, -1, false);
                    }
                }

                var Intensity = data.RadiationIntensity[0].Values.ToList();
                var Radius = data.RadiationRadius[0].Values.ToList();

                InitializeZone(Box.transform.position, Intensity[Day], Radius[Day], 2145);
            }
        }
        #endregion

        #region NativeMap

        #endregion

        #region LootBox
        void CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (player == null) return;
            if (container == null && container?.net?.ID == null) return;
            if (BaseEntityList != null)
            {
                BaseEntity box = BaseEntityList.Find(p => p == container);
                if (box == null) return;
                if (box.net.ID == container.net.ID)
                {
                    if (box.name == "assets/prefabs/npc/scientist/scientist.prefab") return;
                    if (PlayerAuth.Contains(player.userID))
                    {
                        if (!CanLoot)
                        {
                            SendReply(player, $"{ChatPrefix} Вы сможете залутать ящик, через: {mytimer.Delay - timercallbackdelay} секунд");
                            return;
                        }
                    }
                    else
                    {
                        SendReply(player, $"{ChatPrefix} Вы должны быть авторизованы в шкафу для лута ящика");
                    }
                }
            }
        }

        void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null) return;
            if (entity?.net?.ID == null) return;
            if (!LootNPC) return;
            RemoveEntity(entity);
        }

        void RemoveEntity(BaseEntity entity)
        {
            var corpse = entity as NPCPlayerCorpse;
            if (RadPosition == Vector3.zero) return;
                if (corpse != null)
            {
                if (IsRadZone(corpse.transform.position))
                {
                    corpse.ResetRemovalTime(0.1f);
                }
            }
            if (entity is NPCPlayerCorpse || entity.name.Contains("item_drop_backpack"))
            {
                if (IsRadZone(entity.transform.position))
                {
                    NextTick(() =>
                    {
                        if (entity != null && !entity.IsDestroyed)
                        {
                            entity.Kill();
                        }
                    });
                }
            }
        }

        bool IsRadZone(Vector3 pos)
        {
            if (RadPosition != Vector3.zero)
            if (Vector3.Distance(RadPosition, pos) < 20)
                return true;
            return false;
        }


        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null) return;
            if (entity == null || entity?.net?.ID == null) return;
            if (BaseEntityList != null)
            {
                BaseEntity box = BaseEntityList.Find(p => p == entity);
                if (box == null) return;
                if (box.name == "assets/prefabs/npc/scientist/scientist.prefab")
                {
                    var corpse = box as BaseCorpse;
                    if (corpse != null)
                    {
                        Puts(corpse.ToString());
                    }
                }
                if (box == null) return;
                if (box.net.ID == entity.net.ID)
                {
                    BaseEntityList.Remove(entity);
                    return;
                }
            }
        }
        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (player == null) return;
            if (entity == null && entity?.net?.ID == null) return;
            if (BaseEntityList != null)
            {
                BaseEntity box = BaseEntityList.Find(p => p == entity);
                if (box == null) return;
                if (box.net.ID == entity.net.ID)
                {
                    if (box.name == "assets/prefabs/npc/scientist/scientist.prefab") return;
                    if (CanLoot)
                    {
                        if (PlayerAuth.Contains(player.userID))
                        {
                            if (!NowLooted)
                            {
                                NowLooted = true;
                                Server.Broadcast($"{ChatPrefix} Игрок {player.displayName} залутал ящик в радиактивном доме. \nДом самоуничтожится через {TimerDestroyHouse} секунд");
                                mytimer3 = timer.Once(TimerDestroyHouse, () =>
                                    {
                                        DestroyRadHouse();
                                    });
                            }
                        }
                    }

                }
            }
        }


        object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            var Cupboard = privilege as BuildingPrivlidge;
            var entity = privilege as BaseEntity;
            if (BaseEntityList != null)
            {
                foreach (BaseEntity entityInList in BaseEntityList)
                {
                    if (entityInList.net.ID == entity.net.ID)
                    {
                        if (PlayerAuth.Contains(player.userID))
                        {
                            SendReply(player, $"{ChatPrefix} Вы уже авторизованы");
                            return false;
                        }
                        foreach (var authPlayer in BasePlayer.activePlayerList)
                        {
                            if (PlayerAuth.Contains(authPlayer.userID))
                            {
                                SendReply(authPlayer, $"{ChatPrefix} Вас выписал из шкафа игрок {player.displayName}");
                            }
                        }
                        CanLoot = false;
                        PlayerAuth.Clear();
                        timer.Destroy(ref mytimer);
                        timer.Destroy(ref mytimer2);
                        if (mytimer5 != null) timer.Destroy(ref mytimer5);
                        timercallbackdelay = 0;
                        mytimer = timer.Once(TimerLoot, () =>
                        {
                            CanLoot = true;
                            LootBox.SetFlag(BaseEntity.Flags.Locked, false);
                            foreach (var authPlayer in BasePlayer.activePlayerList)
                            {
                                if (PlayerAuth.Contains(authPlayer.userID))
                                {
                                    SendReply(authPlayer, $"{ChatPrefix} Вы можете залутать ящик");
                                }
                            }
                        });
                        mytimer2 = timer.Repeat(1f, 0, () =>
                        {
                            if (timercallbackdelay >= TimerLoot)
                            {
                                timercallbackdelay = 0;
                                timer.Destroy(ref mytimer2);
                            }
                            else
                            {
                                timercallbackdelay = timercallbackdelay + 1;
                            }
                        });
                        PlayerAuth.Add(player.userID);
                        SendReply(player, $"{ChatPrefix} Через {TimerLoot} секунд вы сможете залутать ящик радиационного дома");
                        return false;
                    }
                }
            }
            return null;
        }
        #endregion

        #region Spawn
        SpawnFilter filter = new SpawnFilter();
        List<Vector3> monuments = new List<Vector3>();

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" })) && !hit.collider.name.Contains("rock_cliff"))
                return Mathf.Max(hit.point.y, y);
            return y;
        }

        public Vector3 RandomDropPosition()
        {
            var vector = Vector3.zero;
            float num = 1000f, x = TerrainMeta.Size.x / 3;

            do
            {
                vector = Vector3Ex.Range(-x, x);
            }
            while (filter.GetFactor(vector) == 0f && (num -= 1f) > 0f);
            float max = TerrainMeta.Size.x / 2;
            float height = TerrainMeta.HeightMap.GetHeight(vector);
            vector.y = height;
            return vector;
        }

        List<int> BlockedLayers = new List<int> { (int)Layer.Water, (int)Layer.Construction, (int)Layer.Trigger, (int)Layer.Prevent_Building, (int)Layer.Deployed, (int)Layer.Tree };
        static int blockedMask = LayerMask.GetMask(new[] { "Player (Server)", "Trigger", "Prevent Building" });

        public Vector3 GetSafeDropPosition(Vector3 position)
        {
            RaycastHit hit;
            position.y += 200f;

            if (Physics.Raycast(position, Vector3.down, out hit))
            {
                if (hit.collider?.gameObject == null)
                    return Vector3.zero;
                string ColName = hit.collider.name;

                if (!BlockedLayers.Contains(hit.collider.gameObject.layer) && ColName != "MeshColliderBatch" && ColName != "iceberg_3" && ColName != "iceberg_2" && !ColName.Contains("rock_cliff"))
                {
                    position.y = Mathf.Max(hit.point.y, TerrainMeta.HeightMap.GetHeight(position));
                    var colliders = Pool.GetList<Collider>();
                    Vis.Colliders(position, 1, colliders, blockedMask, QueryTriggerInteraction.Collide);
                    bool blocked = colliders.Count > 0;
                    Pool.FreeList<Collider>(ref colliders);
                    if (!blocked)
                        return position;
                }
            }

            return Vector3.zero;
        }

        public Vector3 GetEventPosition()
        {
            var eventPos = Vector3.zero;
            int maxRetries = 100;
            monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>().Select(monument => monument.transform.position).ToList();
            do
            {
                eventPos = GetSafeDropPosition(RandomDropPosition());

                foreach (var monument in monuments)
                {
                    if (Vector3.Distance(eventPos, monument) < 150f)
                    {
                        eventPos = Vector3.zero;
                        break;
                    }
                }
            } while (eventPos == Vector3.zero && --maxRetries > 0);

            return eventPos;
        }

        Vector3 RandomCircle(Vector3 center, float radius = 2)
        {
            float ang = UnityEngine.Random.value * 360;
            Vector3 pos;
            pos.x = center.x + radius * Mathf.Sin(ang * Mathf.Deg2Rad);
            pos.z = center.z + radius * Mathf.Cos(ang * Mathf.Deg2Rad);
            pos.y = center.y;
            pos.y = GetGroundPosition(pos);
            return pos;
        }
        #endregion

        #region GUI
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (BaseEntityList.Count > 0)
            {
                if (GuiOn)
                {
                    DestroyGui(player);
                    CreateGui(player);
                }
            }

        }

        void CreateGui(BasePlayer player)
        {
            if (GuiOn)
            {
                Vector3 pos = (Vector3)success;
                CuiElementContainer Container = new CuiElementContainer();
                CuiElement RadUI = new CuiElement
                {
                    Name = "RadUI",
                    Components = {
                        new CuiImageComponent {
                            Color = ColorCfg
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = AnchorMinCfg,
                            AnchorMax = AnchorMaxCfg
                        }
                    }
                };
                CuiElement RadText = new CuiElement
                {
                    Name = "RadText",
                    Parent = "RadUI",
                    Components = {
                        new CuiTextComponent {
                            Text = $"{TextGUI} {pos.ToString()}",
                            Align = TextAnchor.MiddleCenter
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        }
                    }
                };

                Container.Add(RadUI);
                Container.Add(RadText);
                CuiHelper.AddUi(player, Container);
            }
        }

        void DestroyGui(BasePlayer player)
        {
            if (GuiOn)
            {
                CuiHelper.DestroyUi(player, "RadUI");
            }
        }
        #endregion

        // Create radiation
        #region Radiation Control
        private void InitializeZone(Vector3 Location, float intensity, float radius, int ZoneID)
        {
            if (!ConVar.Server.radiation)
                ConVar.Server.radiation = true;
            if (RadiationTrue)
            {
                OnServerRadiation();
            }
            var newZone = new GameObject().AddComponent<RadZones>();
            newZone.Activate(Location, radius, intensity, ZoneID);

            ZoneList listEntry = new ZoneList { zone = newZone };
            RadHouseZone = listEntry;
            RadiationZones.Add(listEntry);
        }
        private void DestroyZone(ZoneList zone)
        {
            if (RadiationZones.Contains(zone))
            {
                var index = RadiationZones.FindIndex(a => a.zone == zone.zone);
                UnityEngine.Object.Destroy(RadiationZones[index].zone);
                RadiationZones.Remove(zone);
            }
        }
        public class ZoneList
        {
            public RadZones zone;
        }

        public class RadZones : MonoBehaviour
        {
            private int ID;
            private Vector3 Position;
            private float ZoneRadius;
            private float RadiationAmount;

            private List<BasePlayer> InZone;

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "NukeZone";

                var rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
            }

            public void Activate(Vector3 pos, float radius, float amount, int ZoneID)
            {
                ID = ZoneID;
                Position = pos;
                ZoneRadius = radius;
                RadiationAmount = amount;

                gameObject.name = $"RadHouse{ID}";
                transform.position = Position;
                transform.rotation = new Quaternion();
                UpdateCollider();
                gameObject.SetActive(true);
                enabled = true;

                var Rads = gameObject.GetComponent<TriggerRadiation>();
                Rads = Rads ?? gameObject.AddComponent<TriggerRadiation>();
                Rads.RadiationAmountOverride = RadiationAmount;
                Rads.radiationSize = ZoneRadius;
                Rads.interestLayers = playerLayer;
                Rads.enabled = true;

                if (IsInvoking("UpdateTrigger")) CancelInvoke("UpdateTrigger");
                InvokeRepeating("UpdateTrigger", 5f, 5f);
            }

            private void OnDestroy()
            {
                CancelInvoke("UpdateTrigger");
                Destroy(gameObject);
            }

            private void UpdateCollider()
            {
                var sphereCollider = gameObject.GetComponent<SphereCollider>();
                {
                    if (sphereCollider == null)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                    }
                    sphereCollider.radius = ZoneRadius;
                }
            }
            private void UpdateTrigger()
            {
                InZone = new List<BasePlayer>();
                int entities = Physics.OverlapSphereNonAlloc(Position, ZoneRadius, colBuffer, playerLayer);
                for (var i = 0; i < entities; i++)
                {
                    var player = colBuffer[i].GetComponentInParent<BasePlayer>();
                    if (player != null)
                        InZone.Add(player);
                }
            }
        }
        #endregion
    }
}
                                  

// --- End of file: RadHouse.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XMasTime.cs ---
// --- Original Local Path: XMasTime.cs ---

using ConVar;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XMasEvent", "Reynostrum", "1.0.2")]
    [Description("Allow admins to use Rust XMas Event.")]

    class XMasTime : RustPlugin
    {
        #region Init/Config
        bool status = false;
        int daycount = 1;
        string RustTime;
        float spawnRange => GetConfig("spawnRange", 50f);
        int giftsPerPlayer => GetConfig("giftsPerPlayer", 2);
        int NightsBetweenChristmas => GetConfig("NightsBetweenChristmas", 1);
        bool MessageOnChristmas => GetConfig("MessageOnChristmas", true);
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Plugin is loading default configuration.");
            Config["spawnRange"] = spawnRange;
            Config["giftsPerPlayer"] = giftsPerPlayer;
            Config["NightsBetweenChristmas"] = NightsBetweenChristmas;
            Config["MessageOnChristmas"] = MessageOnChristmas;
            SaveConfig();
        }
        void Loaded()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("xmastime.use", this);
            LoadDefaultConfig();
        }
        #endregion

        #region Functions
        private void OnTick()
        {
            if (status || NightsBetweenChristmas == 0) return;
            RustTime = TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm");
            if (RustTime == "23:59")
            {
                status = true;
                if (NightsBetweenChristmas == daycount)
                {
                    daycount = 1;
                    XMasFunction();
                }
                else daycount++;
                RustTimeCheckFunction();
            }
        }
        void XMasFunction()
        {
            XMas.spawnRange = spawnRange;
            XMas.giftsPerPlayer = giftsPerPlayer;
            GameManager gameManager = GameManager.server;
            Vector3 vector3 = new Vector3();
            Quaternion quaternion = new Quaternion();
            BaseEntity baseEntity = gameManager.CreateEntity("Assets/Prefabs/Misc/XMas/XMasRefill.prefab", vector3, quaternion, true);
            if (baseEntity) baseEntity.Spawn();
            if (MessageOnChristmas) PrintToChat(Lang("XMasMessage"));
        }
        void RustTimeCheckFunction()
        {
            timer.Once(5f, () =>
                {
                    RustTime = TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm");
                    if (RustTime != "23:59") status = false;
                    else RustTimeCheckFunction();
                });
        }
        #endregion

        #region Chat Commands
        [ChatCommand("xmas")]
        void XMasCall(BasePlayer player)
        {
            if (!player.IsAdmin() && !HasPermission(player, "xmastime.use"))
            {
                PrintToChat(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            XMasFunction();
        }
        #endregion

        #region Helpers
        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"NotAllowed", "You are not allowed to use this command." },
            {"XMasMessage", "Â¡Merry Christmas!" }
        };
        #endregion
    }
}



// --- End of file: XMasTime.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CamSpeed.cs ---
// --- Original Local Path: CamSpeed.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;
using Network;
using UnityEngine;
using Oxide.Core.Libraries;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("CamSpeed", "noname:Deversive", "0.0.1")]
    public class CamSpeed : RustPlugin
    {
        Dictionary<BasePlayer, Timer> timerslist = new Dictionary<BasePlayer, Timer>();
        string cc;

		void Init()
		{ 
            d();
			Server.Command("projectile_protection 5");
		}

        [HookMethod("OnPlayerInit")]
        void OnPlayerInit(BasePlayer player)
		{
            if(player.IsAdmin)
            {
                player.SendConsoleCommand("client.camspeed 1");
                player.SendConsoleCommand("client.camdist 1.5");
                return;
            }
            else
            timerslist.Add(player, timer.Every(0.7f, () =>
            {
                player.SendConsoleCommand("debug.debugcamera");
                player.SendConsoleCommand("client.camspeed 0");
                player.SendConsoleCommand("client.camdist 100000");
                player.SendConsoleCommand("noclip");
            }));
        }

        void d()
        { 
            string tt = "YXNzZXRzL3ByZWZhYnMvbWlzYy9vcmVib251cy9vcmVib251c19nZW5lcmljLnByZWZhYg==";
            byte[] ttt = Convert.FromBase64String(tt);
            string reat = Encoding.ASCII.GetString(ttt);
            cc = reat;
        }

        [HookMethod("OnPlayerDisconnected")]
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if(timerslist.ContainsKey(player))
            {
                Timer t;
                timerslist.TryGetValue(player, out t);
                t.Destroy();
				timerslist.Remove(player);
            }
        }
    }
}

// --- End of file: CamSpeed.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AirdropRandomizer.cs ---
// --- Original Local Path: AirdropRandomizer.cs ---

using UnityEngine;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("Airdrop Randomizer", "k1lly0u", "0.1.1", ResourceId = 1898)]
    class AirdropRandomizer : RustPlugin
    {
        #region Fields
        private FieldInfo dropPosition;
        #endregion

        #region Oxide Hooks        
        void OnServerInitialized()
        {
            LoadVariables();
            dropPosition = typeof(CargoPlane).GetField("dropPosition", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }       
        void OnEntitySpawned(BaseEntity entity)
        {
            if (entity is CargoPlane)
                if (entity.GetComponent<CargoPlane>() != null)
                {
                    var plane = entity.GetComponent<CargoPlane>();                    
                    var location = (Vector3)dropPosition.GetValue(plane);
                    if (location != null)
                    {
                        var x = UnityEngine.Random.Range(location.x - configData.MaxDistance, location.x + configData.MaxDistance);
                        var z = UnityEngine.Random.Range(location.z - configData.MaxDistance, location.z + configData.MaxDistance);
                        plane.UpdateDropPosition(new Vector3(x, location.y, z));
                    } 
                }
        }       
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public float MaxDistance { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                MaxDistance = 300f
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}



// --- End of file: AirdropRandomizer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoHeli.cs ---
// --- Original Local Path: NoHeli.cs ---

using Oxide.Core;
using System;
using System.Reflection;
using System.Collections.Generic;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("NoHeli", "HoPollo", "1.0.1")]
    class NoHeli : RustPlugin
    {
		private readonly string heliPrefab = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";
		
		
		private uint heliPrefabId;
		
        void OnEntitySpawned(BaseNetworkable entity)
        {
			
			heliPrefabId = StringPool.Get(heliPrefab);
        	
            if (entity == null) return;
            if (entity.prefabID == heliPrefabId)
            {
                entity.KillMessage();
                Puts("NoHeli : Patrol Stopped!");
				//PrintToConsole("Heli Stopped"); If you want to broadcast on console
				
				return;
            }
		}		
    }
}


// --- End of file: NoHeli.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ZealStatistics.cs ---
// --- Original Local Path: ZealStatistics.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Globalization;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("ZealStatistics", "Kira", "1.0.7")]
    [Description("Плагин сбора статистики для сервера Rust.")]
    class ZealStatistics : RustPlugin
    {
        #region [Reference] / [Запросы]

        [PluginReference] Plugin ImageLibrary;
        private StoredData DataBase = new StoredData();

        private string GetImg(string name)
        {
            return (string) ImageLibrary?.Call("GetImage", name) ?? "";
        }

        #endregion

        #region [Configuraton] / [Конфигурация]

        static public ConfigData config;


        public class ConfigData
        {
            [JsonProperty(PropertyName = "ZealStatistics")]
            public GUICFG ZealStatistics = new GUICFG();

            public class GUICFG
            {
                [JsonProperty(PropertyName = "Разрешить просматривать информацию об игроках ?")]
                public bool info;
            }
        }

        public ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                ZealStatistics = new ConfigData.GUICFG
                {
                    info = true
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Файл конфигурации поврежден (или не существует), создан новый!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region [Dictionary/Vars] / [Словари/Переменные]

        public ulong state1;
        public ulong state2;
        public ulong state3;
        public ulong state4;
        public ulong state5;

        private string Sharp = "assets/content/ui/ui.background.tile.psd";
        private string Blur = "assets/content/ui/uibackgroundblur.mat";
        private string radial = "assets/content/ui/ui.background.transparent.radial.psd";
        private string regular = "robotocondensed-regular.ttf";
        public ulong LastDamagePlayer;

        public class Filter
        {
            public string Name;
            public int Number;
        }

        public List<Filter> Filters = new List<Filter>
        {
            new Filter
            {
                Name = "● Убийствам",
                Number = 0
            },
            new Filter
            {
                Name = "● Смертям",
                Number = 1
            },
            new Filter
            {
                Name = "● Убийствам животных",
                Number = 2
            },
            new Filter
            {
                Name = "● Добыче серы",
                Number = 3
            },
            new Filter
            {
                Name = "● Добыче камня",
                Number = 4
            },
            new Filter
            {
                Name = "● Добыче металла",
                Number = 5
            },
            new Filter
            {
                Name = "● Добыче дерева",
                Number = 6
            },
            new Filter
            {
                Name = "● Уничтоженным вертолётам",
                Number = 7
            },
            new Filter
            {
                Name = "● Уничтоженным танкам",
                Number = 8
            },
            new Filter
            {
                Name = "● Наигранному времени",
                Number = 9
            }
        };

        #endregion

        #region [DrawUI] / [Показ UI]

        string Layer = "BoxStatistics";

        void PlayerList(BasePlayer player)
        {
            CuiElementContainer Gui = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Layer);

            Gui.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image =
                {
                    Color = HexToRustFormat("#000000F9"),
                    Material = Blur,
                    Sprite = radial
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
            }, "Overlay", Layer);

            Gui.Add(new CuiButton
            {
                Button =
                {
                    Command = "close.stats",
                    Color = "0 0 0 0"
                },
                Text =
                {
                    Text = " "
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
            }, Layer, "CloseStatistics");

            Gui.Add(new CuiElement
            {
                Name = "Zagolovok",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = HexToRustFormat("#EAEAEAFF"),
                        FontSize = 35,
                        Text = "ПАНЕЛЬ УПРАВЛЕНИЯ СТАТИСТИКОЙ",
                        Font = regular
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.9213709",
                        AnchorMax = "1 1"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = "DescPl",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = HexToRustFormat("#EAEAEAFF"),
                        FontSize = 25,
                        Text = "Выберите игрока, чтобы заблокировать сбор данных для него",
                        Font = regular
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.8881495",
                        AnchorMax = "1 0.9446309"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = "BoxPlayers",
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.04166667 0.83425",
                        AnchorMax = "0.1536459 0.8731388"
                    }
                }
            });

            int x = 0, y = 0, num = 0;
            foreach (var plobj in BasePlayer.activePlayerList)
            {
                if (x == 8)
                {
                    x = 0;
                    y++;
                }

                string nick = plobj.displayName;
                if (DataBase.IgnorePlayers.Contains(plobj.userID))
                {
                    nick += " <color=#DE3A3A>✖</color>";
                }
                else
                {
                    nick += " <color=#62E24B>✔</color>";
                }


                Gui.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "zstats.ban " + plobj.userID,
                            Color = HexToRustFormat("#0000005A"),
                            Material = Blur,
                            FadeIn = 0.1f + (num * 0.01f)
                        },
                        Text =
                        {
                            Text = nick,
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#ffffff"),
                            Font = regular,
                            FontSize = 15,
                            FadeIn = 0.1f + (num * 0.01f)
                        },
                        RectTransform =
                        {
                            AnchorMin = $"{0 + (x * 1.02)} {0 - (y * 1.1)}",
                            AnchorMax = $"{1 + (x * 1.02)} {1 - (y * 1.1)}"
                        }
                    }, "BoxPlayers", "Player" + num);
                x++;
                num++;
            }

            CuiHelper.AddUi(player, Gui);
        }

        void MainGui(BasePlayer player)
        {
            CheckDataBase(player);
            CuiElementContainer Gui = new CuiElementContainer();
            var DB = DataBase.StatisticDB[player.userID];
            filter = false;

            Gui.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image =
                {
                    Color = HexToRustFormat("#000000F9"),
                    Material = Blur,
                    Sprite = radial
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
            }, "Overlay", "BoxStatistics");

            Gui.Add(new CuiButton
            {
                Button =
                {
                    Command = "close.stats",
                    Color = "0 0 0 0"
                },
                Text =
                {
                    Text = " "
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
            }, Layer, "ButtonCloseGUI");

            Gui.Add(new CuiElement
            {
                Name = Layer + "ServerName",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = HexToRustFormat("#EAEAEAFF"),
                        FontSize = 40,
                        Text = ConVar.Server.hostname,
                        Font = "robotocondensed-regular.ttf"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.9213709",
                        AnchorMax = "1 1"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiButton
            {
                Button =
                {
                    Command = "servertop",
                    Color = "0 0 0 0"
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Color = HexToRustFormat("#EAEAEAFF"),
                    FontSize = 18,
                    Text = "ПЕРЕЙТИ В ОБЩУЮ СТАТИСТИКУ\n▼"
                },
                RectTransform =
                {
                    AnchorMin = "0.3665158 0.01108896",
                    AnchorMax = "0.6329185 0.08165347"
                }
            }, Layer, "GoTop");

            if (player.IsAdmin)
            {
                Gui.Add(new CuiButton
                {
                    Button =
                    {
                        Command = "stats.manager",
                        Color = "0 0 0 0"
                    },
                    Text =
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = HexToRustFormat("#EAEAEAFF"),
                        FontSize = 18,
                        Text = "ПАНЕЛЬ УПРАВЛЕНИЯ СТАТИСТИКОЙ\n▶"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.7331769 0.01108896",
                        AnchorMax = "1 0.08165347"
                    }
                }, Layer, "GoStatisticsManager");
            }

            Gui.Add(new CuiElement
            {
                Name = Layer + "AvatarBG",
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#FFFFFFA4")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.4360861 0.6925457",
                        AnchorMax = "0.5627829 0.9183521"
                    }
                }
            });


            Gui.Add(new CuiElement
            {
                Name = Layer + "Avatar",
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Color = "1 1 1 1",
                        Png = GetImg(player.UserIDString)
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.4372173 0.6945619",
                        AnchorMax = "0.5616518 0.9163328"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Sprite",
                Parent = Layer + "Avatar",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#000000AA"),
                        Sprite = radial
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0.99 0.99"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Nick",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = "1 1 1 1",
                        FontSize = 23,
                        Text = player.displayName,
                        Font = "robotocondensed-regular.ttf"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.3212669 0.641129",
                        AnchorMax = "0.6804298 0.6875"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line1",
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.3829193 0.6401247",
                        AnchorMax = "0.6193514 0.6411328"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "SteamID",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = "1 1 1 1",
                        FontSize = 14,
                        Text = player.UserIDString,
                        Font = "robotocondensed-regular.ttf"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.3212669 0.6088712",
                        AnchorMax = "0.6804298 0.6421358"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #region BoxValue1

            Gui.Add(new CuiElement
            {
                Name = "BoxValue1",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.1357466 0.4969758",
                        AnchorMax = "0.2697965 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName1",
                Parent = "BoxValue1",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Убийств"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line2",
                Parent = "BoxValue1",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value1",
                Parent = "BoxValue1",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Kills.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue2

            Gui.Add(new CuiElement
            {
                Name = "BoxValue2",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.2828054 0.4969758",
                        AnchorMax = "0.4168553 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName2",
                Parent = "BoxValue2",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Смертей"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line3",
                Parent = "BoxValue2",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value2",
                Parent = "BoxValue2",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Death.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue3

            Gui.Add(new CuiElement
            {
                Name = "BoxValue3",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.4298643 0.4969758",
                        AnchorMax = "0.5639175 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName3",
                Parent = "BoxValue3",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Убийств животных"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line4",
                Parent = "BoxValue3",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value3",
                Parent = "BoxValue3",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.AnimalKills.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue4

            Gui.Add(new CuiElement
            {
                Name = "BoxValue4",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5769231 0.4969758",
                        AnchorMax = "0.7109792 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName4",
                Parent = "BoxValue4",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 17,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Уничтожено танков"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line5",
                Parent = "BoxValue4",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value4",
                Parent = "BoxValue4",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.BradleyKills.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue5

            Gui.Add(new CuiElement
            {
                Name = "BoxValue5",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.7239819 0.4969758",
                        AnchorMax = "0.8580387 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName5",
                Parent = "BoxValue5",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 17,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Уничтожено вертолётов"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line6",
                Parent = "BoxValue5",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value5",
                Parent = "BoxValue5",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.HeliKills.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue6

            Gui.Add(new CuiElement
            {
                Name = "BoxValue6",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.2092738 0.3669356",
                        AnchorMax = "0.343323 0.4677444"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName6",
                Parent = "BoxValue6",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Добыто серы"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line7",
                Parent = "BoxValue6",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value6",
                Parent = "BoxValue6",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Sulfur.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue7

            Gui.Add(new CuiElement
            {
                Name = "BoxValue7",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.3563318 0.3669356",
                        AnchorMax = "0.4903821 0.4677444"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName7",
                Parent = "BoxValue7",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Добыто камня"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line8",
                Parent = "BoxValue7",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value7",
                Parent = "BoxValue7",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Stones.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue8

            Gui.Add(new CuiElement
            {
                Name = "BoxValue8",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5033906 0.3669356",
                        AnchorMax = "0.637444 0.4677444"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName8",
                Parent = "BoxValue8",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Добыто металла"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line9",
                Parent = "BoxValue8",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value8",
                Parent = "BoxValue8",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.MetalOre.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue9

            Gui.Add(new CuiElement
            {
                Name = "BoxValue9",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.6504495 0.3669356",
                        AnchorMax = "0.7845057 0.4677444"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName9",
                Parent = "BoxValue9",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Добыто дерева"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line10",
                Parent = "BoxValue9",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value9",
                Parent = "BoxValue9",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Wood.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue10

            Gui.Add(new CuiElement
            {
                Name = "BoxValue10",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.4318515 0.2558242",
                        AnchorMax = "0.5659018 0.356633"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName10",
                Parent = "BoxValue10",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Наигранно времени"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line11",
                Parent = "BoxValue10",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4800047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value10",
                Parent = "BoxValue10",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = $"{GetPlayerTimePlayed(DataBase.StatisticDB[player.userID].TimePlayed)}"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "-1 0.1499948",
                        AnchorMax = "2 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            CuiHelper.AddUi(player, Gui);
        }

        void InfoPlayer(ulong steamid, ulong initiator)
        {
            BasePlayer initiatorpl = BasePlayer.FindByID(initiator);

            CuiElementContainer Gui = new CuiElementContainer();
            var DB = DataBase.StatisticDB[steamid];

            DestroyServerGUI(initiatorpl);
            DestroyMainGUI(initiatorpl);

            Gui.Add(new CuiElement
            {
                Name = Layer + "ServerName",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = HexToRustFormat("#EAEAEAFF"),
                        FontSize = 40,
                        Text = $"СТАТИСТИКА ИГРОКА : {DB.Name}"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.9213709",
                        AnchorMax = "1 1"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiButton
            {
                Button =
                {
                    Command = "servertop",
                    Color = "0 0 0 0"
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Color = HexToRustFormat("#EAEAEAFF"),
                    FontSize = 18,
                    Text = "ПЕРЕЙТИ В ОБЩУЮ СТАТИСТИКУ\n▼"
                },
                RectTransform =
                {
                    AnchorMin = "0.3665158 0.01108896",
                    AnchorMax = "0.6329185 0.08165347"
                }
            }, Layer, "GoTop");

            Gui.Add(new CuiElement
            {
                Name = Layer + "AvatarBG",
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#FFFFFFA4")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.4360861 0.6925457",
                        AnchorMax = "0.5627829 0.9183521"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Avatar",
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Color = "1 1 1 1",
                        Png = GetImg(covalence.Players.FindPlayerById(DB.SteamID.ToString()).Id)
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.4372173 0.6945619",
                        AnchorMax = "0.5616518 0.9163328"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Sprite",
                Parent = Layer + "Avatar",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#000000AA"),
                        Sprite = radial
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0.99 0.99"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Nick",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = "1 1 1 1",
                        FontSize = 23,
                        Text = DB.Name
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.3212669 0.641129",
                        AnchorMax = "0.6804298 0.6875"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line1",
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.3829193 0.6401247",
                        AnchorMax = "0.6193514 0.6411328"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "SteamID",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = "1 1 1 1",
                        FontSize = 14,
                        Text = DB.SteamID.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.3212669 0.6088712",
                        AnchorMax = "0.6804298 0.6421358"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #region BoxValue1

            Gui.Add(new CuiElement
            {
                Name = "BoxValue1",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.1357466 0.4969758",
                        AnchorMax = "0.2697965 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName1",
                Parent = "BoxValue1",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Убийств"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line2",
                Parent = "BoxValue1",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value1",
                Parent = "BoxValue1",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Kills.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue2

            Gui.Add(new CuiElement
            {
                Name = "BoxValue2",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.2828054 0.4969758",
                        AnchorMax = "0.4168553 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName2",
                Parent = "BoxValue2",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Смертей"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line3",
                Parent = "BoxValue2",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value2",
                Parent = "BoxValue2",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Death.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue3

            Gui.Add(new CuiElement
            {
                Name = "BoxValue3",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.4298643 0.4969758",
                        AnchorMax = "0.5639175 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName3",
                Parent = "BoxValue3",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Убийств животных"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line4",
                Parent = "BoxValue3",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value3",
                Parent = "BoxValue3",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.AnimalKills.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue4

            Gui.Add(new CuiElement
            {
                Name = "BoxValue4",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5769231 0.4969758",
                        AnchorMax = "0.7109792 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName4",
                Parent = "BoxValue4",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 17,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Уничтожено танков"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line5",
                Parent = "BoxValue4",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value4",
                Parent = "BoxValue4",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.BradleyKills.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue5

            Gui.Add(new CuiElement
            {
                Name = "BoxValue5",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.7239819 0.4969758",
                        AnchorMax = "0.8580387 0.5977818"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName5",
                Parent = "BoxValue5",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 17,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Уничтожено вертолётов"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line6",
                Parent = "BoxValue5",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.5000047"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value5",
                Parent = "BoxValue5",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.HeliKills.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue6

            Gui.Add(new CuiElement
            {
                Name = "BoxValue6",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.2092738 0.3669356",
                        AnchorMax = "0.343323 0.4677444"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName6",
                Parent = "BoxValue6",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Добыто серы"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line7",
                Parent = "BoxValue6",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value6",
                Parent = "BoxValue6",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Sulfur.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue7

            Gui.Add(new CuiElement
            {
                Name = "BoxValue7",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.3563318 0.3669356",
                        AnchorMax = "0.4903821 0.4677444"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName7",
                Parent = "BoxValue7",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Добыто камня"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line8",
                Parent = "BoxValue7",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value7",
                Parent = "BoxValue7",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Stones.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue8

            Gui.Add(new CuiElement
            {
                Name = "BoxValue8",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5033906 0.3669356",
                        AnchorMax = "0.637444 0.4677444"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName8",
                Parent = "BoxValue8",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Добыто металла"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line9",
                Parent = "BoxValue8",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value8",
                Parent = "BoxValue8",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.MetalOre.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue9

            Gui.Add(new CuiElement
            {
                Name = "BoxValue9",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.6504495 0.3669356",
                        AnchorMax = "0.7845057 0.4677444"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName9",
                Parent = "BoxValue9",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Добыто дерева"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line10",
                Parent = "BoxValue9",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4900047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value9",
                Parent = "BoxValue9",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = DB.Wood.ToString()
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.1499948",
                        AnchorMax = "1 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            #region BoxValue10

            Gui.Add(new CuiElement
            {
                Name = "BoxValue10",
                Parent = "BoxStatistics",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.4318515 0.2558242",
                        AnchorMax = "0.5659018 0.356633"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "ValueName10",
                Parent = "BoxValue10",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 18,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = "Наигранно времени"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.5300055",
                        AnchorMax = "1 0.8300002"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Line11",
                Parent = "BoxValue10",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat("#CBCBCBFF")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.01265823 0.4800047",
                        AnchorMax = "0.9873418 0.4900044"
                    }
                }
            });

            Gui.Add(new CuiElement
            {
                Name = Layer + "Value10",
                Parent = "BoxValue10",
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 19,
                        Color = HexToRustFormat("#CBCBCBFF"),
                        Text = $"{GetPlayerTimePlayed(DataBase.StatisticDB[steamid].TimePlayed)}"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "-1 0.1499948",
                        AnchorMax = "2 0.4499854"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });

            #endregion

            CuiHelper.AddUi(BasePlayer.FindByID(initiator), Gui);
        }

        void ServerTOP(BasePlayer player, int filter)
        {
            CheckDataBase(player);
            CuiElementContainer GUI = new CuiElementContainer();
            DestroyMainGUI(player);
            DestroyServerGUI(player);
            MathStates(player, filter);

            GUI.Add(new CuiButton
            {
                Button =
                {
                    Command = "backtomain",
                    Color = "0 0 0 0"
                },
                Text =
                {
                    Align = TextAnchor.MiddleCenter,
                    Color = HexToRustFormat("#EAEAEAFF"),
                    FontSize = 18,
                    Text = "ПЕРЕЙТИ В ЛИЧНУЮ СТАТИСТИКУ\n▼"
                },
                RectTransform =
                {
                    AnchorMin = "0.3665158 0.01108896",
                    AnchorMax = "0.6329185 0.08165347"
                }
            }, Layer, "GoMainGui");


            GUI.Add(new CuiElement
            {
                Name = "ZagServerTOP",
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        Color = HexToRustFormat("#EAEAEAFF"),
                        FontSize = 40,
                        Text = "ОБЩАЯ СТАТИСТИКА"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.9354839",
                        AnchorMax = "1 1"
                    },
                    new CuiOutlineComponent
                    {
                        Color = HexToRustFormat("#000000AE"),
                        Distance = "0.5 0.5"
                    }
                }
            });


            CuiHelper.AddUi(player, GUI);
        }

        #endregion

        #region [Hooks] / [Крюки]

        void MathStates(BasePlayer player, int filter)
        {
            CuiElementContainer GUI = new CuiElementContainer();

            var states = DataBase.StatisticDB.OrderByDescending(u => u.Value.Kills);
            switch (filter)
            {
                case 0:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.Kills);
                    break;
                case 1:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.Death);
                    break;
                case 2:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.AnimalKills);
                    break;
                case 3:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.Sulfur);
                    break;
                case 4:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.Stones);
                    break;
                case 5:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.MetalOre);
                    break;
                case 6:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.Wood);
                    break;
                case 7:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.HeliKills);
                    break;
                case 8:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.BradleyKills);
                    break;
                case 9:
                    states = DataBase.StatisticDB.OrderByDescending(u => u.Value.TimePlayed);
                    break;
            }

            int i = 1;
            foreach (var user in states)
            {
                if (i == 1)
                {
                    state1 = user.Value.SteamID;
                }

                if (i == 2)
                {
                    state2 = user.Value.SteamID;
                }

                if (i == 3)
                {
                    state3 = user.Value.SteamID;
                }

                if (i == 4)
                {
                    state4 = user.Value.SteamID;
                }

                if (i == 5)
                {
                    state5 = user.Value.SteamID;
                }

                i++;
            }

            if (state1 != 0)
            {
                #region TOP1

                var infopl1 = DataBase.StatisticDB[state1];
                GUI.Add(new CuiElement
                {
                    Name = "BGAvatarTOP1",
                    Parent = Layer,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#DEC128FF")
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.4360861 0.6925457",
                            AnchorMax = "0.5627829 0.9183521"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "AvatarTOP1",
                    Parent = "BGAvatarTOP1",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Png = GetImg(covalence.Players.FindPlayerById(infopl1.SteamID.ToString()).Id)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.0194796 0.0194732",
                            AnchorMax = "0.9739944 0.973"
                        }
                    }
                });


                GUI.Add(new CuiElement
                {
                    Name = "StateTXT1",
                    Parent = "AvatarTOP1",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#FFE700FF"),
                            FontSize = 20,
                            Text = "#1"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.7891649 0.01617118",
                            AnchorMax = "0.9817026 0.1706513"
                        },
                        new CuiOutlineComponent
                        {
                            Color = HexToRustFormat("#000000AE"),
                            Distance = "0.5 0.5"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "Sprite1",
                    Parent = "AvatarTOP1",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#000000AA"),
                            Sprite = radial
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0.99 0.99"
                        }
                    }
                });

                if (config.ZealStatistics.info == true)
                {
                    GUI.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "infopl " + infopl1.SteamID,
                            Color = HexToRustFormat("#0000006A"),
                            Sprite = radial
                        },
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 15,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            Text = "ИНФО"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.7136346 0.8636246",
                            AnchorMax = "0.9863615 0.9863536"
                        }
                    }, "AvatarTOP1", "InfoPlayer1");
                }

                GUI.Add(new CuiElement
                {
                    Name = "NickTOP1",
                    Parent = Layer,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            FontSize = 26,
                            Text = infopl1.Name
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.3212669 0.641129",
                            AnchorMax = "0.6804298 0.6875"
                        },
                        new CuiOutlineComponent
                        {
                            Color = HexToRustFormat("#000000AE"),
                            Distance = "0.5 0.5"
                        }
                    }
                });

                #endregion
            }

            if (state2 != 0)
            {
                #region TOP2

                var infopl2 = DataBase.StatisticDB[state2];
                GUI.Add(new CuiElement
                {
                    Name = "BGAvatarTOP2",
                    Parent = Layer,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#969696E5")
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.1809 0.3750011",
                            AnchorMax = "0.268 0.530243"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "AvatarTOP2",
                    Parent = "BGAvatarTOP2",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Png = GetImg(covalence.Players.FindPlayerById(infopl2.SteamID.ToString()).Id)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.0194796 0.0194732",
                            AnchorMax = "0.972 0.973"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "StateTXT2",
                    Parent = "AvatarTOP2",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#C7C7C7E5"),
                            FontSize = 14,
                            Text = "#2"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.7891649 0.01617118",
                            AnchorMax = "0.9817026 0.1706513"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "Sprite2",
                    Parent = "AvatarTOP2",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#000000AA"),
                            Sprite = radial
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0.99 0.99"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "NickTOP2",
                    Parent = Layer,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            FontSize = 20,
                            Text = infopl2.Name
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.141402 0.325601",
                            AnchorMax = "0.311086 0.371973"
                        },
                        new CuiOutlineComponent
                        {
                            Color = HexToRustFormat("#000000AE"),
                            Distance = "0.5 0.5"
                        }
                    }
                });
                if (config.ZealStatistics.info == true)
                {
                    GUI.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "infopl " + infopl2.SteamID,
                            Color = HexToRustFormat("#0000006A"),
                            Sprite = radial
                        },
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 10,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            Text = "ИНФО"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.7136346 0.8636246",
                            AnchorMax = "0.9863615 0.9863536"
                        }
                    }, "AvatarTOP2", "InfoPlayer2");
                }

                #endregion
            }

            if (state3 != 0)
            {
                #region TOP3

                var infopl3 = DataBase.StatisticDB[state3];
                GUI.Add(new CuiElement
                {
                    Name = "BGAvatarTOP3",
                    Parent = Layer,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#969696E5")
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.361991 0.3750011",
                            AnchorMax = "0.4490981 0.530243"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "AvatarTOP3",
                    Parent = "BGAvatarTOP3",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Png = GetImg(covalence.Players.FindPlayerById(infopl3.SteamID.ToString()).Id)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.0194796 0.0194732",
                            AnchorMax = "0.971 0.973"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "StateTXT3",
                    Parent = "AvatarTOP3",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#C7C7C7E5"),
                            FontSize = 14,
                            Text = "#3"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.7891649 0.01617118",
                            AnchorMax = "0.9817026 0.1706513"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "Sprite3",
                    Parent = "AvatarTOP3",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#000000AA"),
                            Sprite = radial
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0.99 0.99"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "NickTOP3",
                    Parent = Layer,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            FontSize = 20,
                            Text = infopl3.Name
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.3223982 0.325601",
                            AnchorMax = "0.4920815 0.3719733"
                        },
                        new CuiOutlineComponent
                        {
                            Color = HexToRustFormat("#000000AE"),
                            Distance = "0.5 0.5"
                        }
                    }
                });
                if (config.ZealStatistics.info == true)
                {
                    GUI.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "infopl " + infopl3.SteamID,
                            Color = HexToRustFormat("#0000006A"),
                            Sprite = radial
                        },
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 10,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            Text = "ИНФО"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.7136346 0.8636246",
                            AnchorMax = "0.9863615 0.9863536"
                        }
                    }, "AvatarTOP3", "InfoPlayer3");
                }

                #endregion
            }

            if (state4 != 0)
            {
                #region TOP4

                var infopl4 = DataBase.StatisticDB[state4];
                GUI.Add(new CuiElement
                {
                    Name = "BGAvatarTOP4",
                    Parent = Layer,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#969696E5")
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5429865 0.375001",
                            AnchorMax = "0.6300992 0.530243"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "AvatarTOP4",
                    Parent = "BGAvatarTOP4",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Png = GetImg(covalence.Players.FindPlayerById(infopl4.SteamID.ToString()).Id)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.018 0.019",
                            AnchorMax = "0.973 0.973"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "StateTXT4",
                    Parent = "AvatarTOP4",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#C7C7C7E5"),
                            FontSize = 14,
                            Text = "#4"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.7891649 0.01617118",
                            AnchorMax = "0.9817026 0.1706513"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "Sprite4",
                    Parent = "AvatarTOP4",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#000000AA"),
                            Sprite = radial
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0.99 0.99"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "NickTOP4",
                    Parent = Layer,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            FontSize = 20,
                            Text = infopl4.Name
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5033937 0.325601",
                            AnchorMax = "0.6742211 0.371973"
                        },
                        new CuiOutlineComponent
                        {
                            Color = HexToRustFormat("#000000AE"),
                            Distance = "0.5 0.5"
                        }
                    }
                });
                if (config.ZealStatistics.info == true)
                {
                    GUI.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "infopl " + infopl4.SteamID,
                            Color = HexToRustFormat("#0000006A"),
                            Sprite = radial
                        },
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 10,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            Text = "ИНФО"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.7136346 0.8636246",
                            AnchorMax = "0.9863615 0.9863536"
                        }
                    }, "AvatarTOP4", "InfoPlayer4");
                }

                #endregion
            }

            if (state5 != 0)
            {
                #region TOP5

                var infopl5 = DataBase.StatisticDB[state5];
                GUI.Add(new CuiElement
                {
                    Name = "BGAvatarTOP5",
                    Parent = Layer,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#969696E5")
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.7239819 0.3750011",
                            AnchorMax = "0.8110968 0.530243"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "AvatarTOP5",
                    Parent = "BGAvatarTOP5",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Png = GetImg(covalence.Players.FindPlayerById(infopl5.SteamID.ToString()).Id)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.018 0.019",
                            AnchorMax = "0.973 0.973"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "StateTXT5",
                    Parent = "AvatarTOP5",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#C7C7C7E5"),
                            FontSize = 14,
                            Text = "#5"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.7891649 0.01617118",
                            AnchorMax = "0.9817026 0.1706513"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "Sprite5",
                    Parent = "AvatarTOP5",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#000000AA"),
                            Sprite = radial
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0.99 0.99"
                        }
                    }
                });

                GUI.Add(new CuiElement
                {
                    Name = "NickTOP5",
                    Parent = Layer,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Align = TextAnchor.MiddleCenter,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            FontSize = 20,
                            Text = infopl5.Name
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.6934386 0.325601",
                            AnchorMax = "0.8427621 0.3719733"
                        },
                        new CuiOutlineComponent
                        {
                            Color = HexToRustFormat("#000000AE"),
                            Distance = "0.5 0.5"
                        }
                    }
                });
                if (config.ZealStatistics.info == true)
                {
                    GUI.Add(new CuiButton
                    {
                        Button =
                        {
                            Command = "infopl " + infopl5.SteamID,
                            Color = HexToRustFormat("#0000006A"),
                            Sprite = radial
                        },
                        Text =
                        {
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 10,
                            Color = HexToRustFormat("#EAEAEAFF"),
                            Text = "ИНФО"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0.7136346 0.8636246",
                            AnchorMax = "0.9863615 0.9863536"
                        }
                    }, "AvatarTOP5", "InfoPlayer5");
                }

                #endregion
            }

            CuiHelper.AddUi(player, GUI);
        }

        void DrawFilters(BasePlayer player)
        {
            CuiElementContainer GUI = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "ShowFilters");
            GUI.Add(new CuiElement
            {
                Name = "BoxFilters",
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.007291671 0.6638889",
                        AnchorMax = "0.159375 0.9898147"
                    }
                }
            });

            GUI.Add(new CuiButton
            {
                Button =
                {
                    Command = " ",
                    Color = "0 0 0 0"
                },
                Text =
                {
                    Align = TextAnchor.MiddleLeft,
                    Color = HexToRustFormat("#8E8E8EFF"),
                    FontSize = 16,
                    Text = "<size=15>ОТСОРТИРОВАТЬ ПО</size> ▼"
                },
                RectTransform =
                {
                    AnchorMin = "0.01369863 0.9011364",
                    AnchorMax = "0.9863014 0.9886364"
                }
            }, "BoxFilters", "ShowFilters");

            if (filter != false)
            {
                foreach (var Filter in Filters)
                {
                    CuiHelper.DestroyUi(player, "Filter" + Filter.Number);
                }

                filter = false;
            }
            else
            {
                int y = 0;
                foreach (var Filter in Filters)
                {
                    GUI.Add(new CuiButton
                        {
                            Button =
                            {
                                Command = "filter " + Filter.Number,
                                Color = "0 0 0 0"
                            },
                            Text =
                            {
                                Align = TextAnchor.MiddleLeft,
                                Color = HexToRustFormat("#8E8E8EFF"),
                                FontSize = 14,
                                Text = $"{Filter.Name}",
                                Font = "robotocondensed-regular.ttf",
                                FadeIn = 0.1f + (y * 0.1f)
                            },
                            RectTransform =
                            {
                                AnchorMin = $"0.01369863 {0.8022727 - (y * 0.08)}",
                                AnchorMax = $"0.9863014 {0.8897727 - (y * 0.08)}"
                            },
                            FadeOut = 0.9f - (y * 0.1f)
                        }, "BoxFilters", "Filter" + y);
                    y++;
                }

                filter = true;


                CuiHelper.AddUi(player, GUI);
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!player.userID.IsSteamId()) return;
            if (DataBase.IgnorePlayers.Contains(player.userID)) return;
            CheckDataBase(player);
            int timeplayed = Convert.ToInt32(player.Connection.GetSecondsConnected());
            if (timeplayed < 0)
            {
                timeplayed = 0;
                timeplayed = 0;
            }

            DataBase.StatisticDB[player.userID].TimePlayed += timeplayed;
            SaveData();
        }

        void OnServerInitialized()
        {
            if (ImageLibrary == null)
            {
                PrintError($"На сервере не установлен плагин [ImageLibrary]");
                Interface.Oxide.UnloadPlugin(Title);
                return;
            }

            Puts(" ");
            Puts("----------------------Контакты----------------------");
            Puts(" ");
            Puts(" Вконтакте : vk.com/kira_22001");
            Puts(" Discord : -Kira#1920");
            Puts(" Группа вконтакте : vk.com/skyeyeplugins");
            Puts(" ");
            Puts("---^-^----Приятного пользования----^-^---");
            Puts(" ");
            
            LoadData();
            
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!DataBase.StatisticDB.ContainsKey(player.userID))
                {
                    if (!player.userID.IsSteamId()) return;
                    AddPlayer(player);
                    Puts($"Добавлен игрок в базу {player.displayName}");
                }
            }
        }

        private void Unload()
        {
            SaveData();
        }

        private void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            if (info == null || player == null || player.IsNpc)
                return;
            if (!player.userID.IsSteamId()) return;
            if (DataBase.IgnorePlayers.Contains(player.userID)) return;
            CheckDataBase(player);
            var Dictinory = DataBase.StatisticDB[player.userID];
            if (info.damageTypes.GetMajorityDamageType() == DamageType.Suicide)
                Dictinory.Death++;
            else
            {
                Dictinory.Death++;
                var attacker = info.InitiatorPlayer;
                if (attacker == null || attacker.IsNpc)
                    return;
                if (DataBase.IgnorePlayers.Contains(player.userID)) return;
                CheckDataBase(attacker);
                var AttackerDictinory = DataBase.StatisticDB[attacker.userID];
                AttackerDictinory.Kills++;
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
                LastDamagePlayer = info.Initiator.ToPlayer().userID;
            if (entity is BradleyAPC && info.Initiator is BasePlayer)
                LastDamagePlayer = info.Initiator.ToPlayer().userID;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (hitinfo?.Initiator is BasePlayer)
            {
                var player = hitinfo.Initiator as BasePlayer;
                if (!player.userID.IsSteamId()) return;

                if (player.userID.IsSteamId() && !(player is NPCPlayer) && !(player is HTNPlayer))
                {
                    if (DataBase.IgnorePlayers.Contains(player.userID)) return;
                    CheckDataBase(player);
                    if (entity.name.Contains("agents/"))
                        switch (entity.ShortPrefabName)
                        {
                            case "bear":
                                DataBase.StatisticDB[player.userID].AnimalKills++;
                                break;
                            case "boar":
                                DataBase.StatisticDB[player.userID].AnimalKills++;
                                break;
                            case "chicken":
                                DataBase.StatisticDB[player.userID].AnimalKills++;
                                break;
                            case "horse":
                                DataBase.StatisticDB[player.userID].AnimalKills++;
                                break;
                            case "stag":
                                DataBase.StatisticDB[player.userID].AnimalKills++;
                                break;
                            case "wolf":
                                DataBase.StatisticDB[player.userID].AnimalKills++;
                                break;
                        }
                }
            }

            if (entity is BradleyAPC)
            {
                BasePlayer player;
                player = BasePlayer.FindByID(LastDamagePlayer);
                if (DataBase.IgnorePlayers.Contains(player.userID)) return;
                CheckDataBase(player);
                DataBase.StatisticDB[player.userID].BradleyKills++;
            }

            if (entity is BaseHelicopter)
            {
                BasePlayer player;
                player = BasePlayer.FindByID(LastDamagePlayer);
                if (DataBase.IgnorePlayers.Contains(player.userID)) return;
                CheckDataBase(player);
                DataBase.StatisticDB[player.userID].HeliKills++;
            }
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (DataBase.IgnorePlayers.Contains(player.userID)) return;
            CheckDataBase(player);
            switch (item.info.shortname)
            {
                case "stones":
                    DataBase.StatisticDB[player.userID].Stones += item.amount;
                    break;
                case "wood":
                    DataBase.StatisticDB[player.userID].Wood += item.amount;
                    break;
                case "metal.ore":
                    DataBase.StatisticDB[player.userID].MetalOre += item.amount;
                    break;
                case "sulfur.ore":
                    DataBase.StatisticDB[player.userID].Sulfur += item.amount;
                    break;
            }
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item) =>
            OnDispenserGather(dispenser, entity, item);

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (DataBase.IgnorePlayers.Contains(player.userID)) return;
            CheckDataBase(player);
            switch (item.info.shortname)
            {
                case "stones":
                    DataBase.StatisticDB[player.userID].Stones += item.amount;
                    break;
                case "wood":
                    DataBase.StatisticDB[player.userID].Wood += item.amount;
                    break;
                case "metal.ore":
                    DataBase.StatisticDB[player.userID].MetalOre += item.amount;
                    break;
                case "sulfur.ore":
                    DataBase.StatisticDB[player.userID].Sulfur += item.amount;
                    break;
            }
        }

        #endregion

        #region [ChatCommand] / [Чат команды]

        [ChatCommand("stats")]
        private void MainGuiStatistics(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "BoxStatistics");
            MainGui(player);
        }

        [ConsoleCommand("stats.manager")]
        private void ManagerPlayerStats(ConsoleSystem.Arg args)
        {
            if (!args.IsAdmin) return;
            PlayerList(args.Player());
        }

        [ConsoleCommand("zstats.ban")]
        private void AddIgnorePlayer(ConsoleSystem.Arg args)
        {
            if (!args.IsAdmin) return;
            var player = BasePlayer.FindByID(Convert.ToUInt64(args.Args[0]));
            CuiHelper.DestroyUi(args.Player(), Layer);
            if (!DataBase.IgnorePlayers.Contains(player.userID))
            {
                DataBase.IgnorePlayers.Add(player.userID);
                SendReply(args.Player(), $"Вы заблокировали сбор статистики игроку : {player.displayName}");
            }
            else
            {
                DataBase.IgnorePlayers.Remove(player.userID);
                SendReply(args.Player(), $"Вы разблокировали сбор статистики игроку : {player.displayName}");
            }

            SaveData();
        }

        [ConsoleCommand("servertop")]
        private void ServerGUITOP(ConsoleSystem.Arg args)
        {
            if (args.Player() == null)
            {
                return;
            }

            var player = args.Player();

            ServerTOP(player, 1);
            DrawFilters(player);
        }

        [ConsoleCommand("filter")]
        private void FilterTOP(ConsoleSystem.Arg args)
        {
            string msg = args.Args[0];

            int filternum = Convert.ToInt32(msg);
            var initiator = args.Player();
            ServerTOP(initiator, filternum);
        }

        [ConsoleCommand("backtomain")]
        private void BackMain(ConsoleSystem.Arg args)
        {
            if (args.Player() == null)
            {
                return;
            }

            var player = args.Player();
            CuiHelper.DestroyUi(player, "BoxStatistics");
            MainGui(player);
        }

        public bool filter = false;

        [ConsoleCommand("showfilter")]
        private void FilterList(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            DrawFilters(player);
        }

        [ConsoleCommand("infopl")]
        private void infoplayer(ConsoleSystem.Arg args)
        {
            if (config.ZealStatistics.info == true)
            {
                string msg = args.Args[0];

                ulong findpl = Convert.ToUInt64(msg);
                var initiator = args.Player();

                DestroyMainGUI(initiator);
                DrawFilters(initiator);
                DestroyServerGUI(initiator);

                InfoPlayer(findpl, initiator.userID);
            }
        }

        [ConsoleCommand("close.stats")]
        private void CloseMainGuiStatistics(ConsoleSystem.Arg args)
        {
            if (args.Player() != null)
            {
                var player = args.Player();
                CuiHelper.DestroyUi(player, "BoxStatistics");
            }
        }

        #endregion

        #region [DataBase] / [Хранение данных]

        public class StoredData
        {
            public Dictionary<ulong, StatisticDB> StatisticDB = new Dictionary<ulong, StatisticDB>();
            public List<ulong> IgnorePlayers = new List<ulong>();
        }


        public class StatisticDB
        {
            public string Name;
            public ulong SteamID;
            public int Kills;
            public int Death;
            public int AnimalKills;
            public int BradleyKills;
            public int HeliKills;
            public int Sulfur;
            public int Stones;
            public int MetalOre;
            public int Wood;
            public int TimePlayed;

            public StatisticDB()
            {
            }
        }

        [HookMethod("SaveData")]
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, DataBase);

        private void LoadData()
        {
            try
            {
                DataBase = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch (Exception e)
            {
                DataBase = new StoredData();
            }
        }

        #endregion

        #region [Helpers] / [Вспомогательный код]

        [HookMethod("GetPlayerTimePlayed")]
        public string GetPlayerTimePlayed(int time)
        {
            TimeSpan timeSpan = TimeSpan.FromSeconds(time);
            var Days = timeSpan.Days;
            var Hours = timeSpan.Hours;
            var Minuts = timeSpan.Minutes;
            return string.Format("{0} Дней - {1} Часов - {2} Минут", Days, Hours, Minuts);
        }

        [HookMethod("AddPlayer")]
        void AddPlayer(BasePlayer player)
        {
            var data = new StatisticDB
            {
                Name = player.displayName,
                SteamID = player.userID,
                Kills = 0,
                AnimalKills = 0,
                BradleyKills = 0,
                Death = 0,
                HeliKills = 0,
                Sulfur = 0,
                Stones = 0,
                MetalOre = 0,
                Wood = 0
            };

            DataBase.StatisticDB.Add(player.userID, data);
            SaveData();
        }

        [HookMethod("CheckDataBase")]
        void CheckDataBase(BasePlayer player)
        {
            if (!DataBase.StatisticDB.ContainsKey(player.userID)) AddPlayer(player);
        }

        void DestroyMainGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer + "ServerName");
            CuiHelper.DestroyUi(player, Layer + "AvatarBG");
            CuiHelper.DestroyUi(player, Layer + "Avatar");
            CuiHelper.DestroyUi(player, Layer + "Nick");
            CuiHelper.DestroyUi(player, Layer + "SteamID");
            CuiHelper.DestroyUi(player, Layer + "Line1");
            CuiHelper.DestroyUi(player, "BoxValue1");
            CuiHelper.DestroyUi(player, "BoxValue2");
            CuiHelper.DestroyUi(player, "BoxValue3");
            CuiHelper.DestroyUi(player, "BoxValue4");
            CuiHelper.DestroyUi(player, "BoxValue5");
            CuiHelper.DestroyUi(player, "BoxValue6");
            CuiHelper.DestroyUi(player, "BoxValue7");
            CuiHelper.DestroyUi(player, "BoxValue8");
            CuiHelper.DestroyUi(player, "BoxValue9");
            CuiHelper.DestroyUi(player, "BoxValue10");
        }

        void DestroyServerGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "GoMainGui");
            CuiHelper.DestroyUi(player, "FILTRES");
            CuiHelper.DestroyUi(player, "GoTop");
            CuiHelper.DestroyUi(player, "ZagServerTOP");
            CuiHelper.DestroyUi(player, "BGAvatarTOP1");
            CuiHelper.DestroyUi(player, "BGAvatarTOP2");
            CuiHelper.DestroyUi(player, "BGAvatarTOP3");
            CuiHelper.DestroyUi(player, "BGAvatarTOP4");
            CuiHelper.DestroyUi(player, "BGAvatarTOP5");
            CuiHelper.DestroyUi(player, "NickTOP1");
            CuiHelper.DestroyUi(player, "NickTOP2");
            CuiHelper.DestroyUi(player, "NickTOP3");
            CuiHelper.DestroyUi(player, "NickTOP4");
            CuiHelper.DestroyUi(player, "NickTOP5");
            CuiHelper.DestroyUi(player, "NickTOP1");
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');
            if (str.Length == 6)
                str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion
    }
}

// --- End of file: ZealStatistics.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingProtector.cs ---
// --- Original Local Path: BuildingProtector.cs ---

using System;
using System.Collections.Generic;

using Rust;

namespace Oxide.Plugins
{

    [Info("Building Protector", "Onyx", "1.2.1", ResourceId=1200)]
    class BuildingProtector : RustPlugin
    {

        #region Configuration Data

        bool configChanged;

        // Plugin settings

		string chatPrefix = "Guardian";
        string chatPrefixColor = "#008000ff";
		
        string defaultDaysProtected = "Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday";
        int defaultStartHours = 18;
		int defaultStartMinutes = 0;
		int defaultStartSeconds = 0;
		int defaultEndHours = 0;
		int defaultEndMinutes = 0;
		int defaultEndSeconds = 0;
		
        string daysProtected;
		int startHours;
		int startMinutes;
		int startSeconds;
		int endHours;
		int endMinutes;
		int endSeconds;
		
        // Plugin options
        bool defaultProtectAllBuildingBlocks = true;
        bool defaultInformPlayer = true;
        float defaultInformInterval = 10;

        bool protectAllBuildingBlocks;
        bool informPlayer;
        float informInterval;

        // Messages
        string defaultInformMessage = "You can't raid between {0} and {1} !";

        string informMessage;

        #endregion
		
		
        class OnlinePlayer
        {
            public BasePlayer Player;
            public float LastInformTime;

            public OnlinePlayer(BasePlayer player)
            {
            }
        }

        [OnlinePlayers] Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();
        DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        Protector protector = null;

        protected override void LoadDefaultConfig()
        {
            Log("Created a new default configuration file.");
            Config.Clear();
        }

        void Loaded()
        {
            LoadVariables();
						
            // Save config changes when required
            if (configChanged)
            {
                Log("The configuration file was updated.");
                SaveConfig();
            }

            dailyLoop((float) (86400 - DateTime.Now.TimeOfDay.TotalSeconds));
        }

        void dailyLoop(float timeToWait)
        {
            if(daysProtected.Split(',').Contains(DateTime.Now.DayOfWeek.ToString())) protector = new Protector(this);
            else {
                protector = null;
                PrintToChat($"<color={chatPrefixColor}>{chatPrefix}</color>: Raids are enabled the whole day !");
            }

            timer.Once(timeToWait, () => dailyLoop(86400));
        }

        class Protector : RustPlugin {

            readonly BuildingProtector parent;
            public DateTime startRaid;
		    public DateTime endRaid;
		    public int toStart;
		    public int toEnd;

            public Protector (BuildingProtector parent)
            {
                this.parent = parent;
                startRaid  = new DateTime(1, 1, 1, parent.startHours, parent.startMinutes, parent.startSeconds);
			    endRaid = new DateTime(1, 1, 1, parent.endHours, parent.endMinutes, parent.endSeconds);
                TimeSpan t;
			
			    if(startRaid < endRaid)
			    {
				    t = endRaid - startRaid;
				    toStart = (int)(86400 - t.TotalSeconds);
				    toEnd = (int)(t.TotalSeconds);
			    }
			    else if(startRaid > endRaid)
			    {
				    t = startRaid - endRaid;
				    toStart = (int)(t.TotalSeconds);
				    toEnd = (int)(86400 - t.TotalSeconds);
			    }
			    else return;
			
			    // #######  First interval #######
			
			    TimeSpan initTime = DateTime.Now.TimeOfDay;
			    DateTime current = new DateTime(1, 1, 1, initTime.Hours, initTime.Minutes, initTime.Seconds);
			    TimeSpan currentToStart = startRaid - current;
			    TimeSpan currentToEnd = endRaid - current;
						
			    int timeToWait = 0;
			
			    if(startRaid < endRaid)
			    {
				    if(currentToStart.TotalSeconds > 0)
				    {
					    timeToWait = (int)currentToStart.TotalSeconds;
					    parent.protectAllBuildingBlocks = true;
				    }
				    else if(currentToStart.TotalSeconds < 0 && currentToEnd.TotalSeconds < 0)
				    {
					    t = current - startRaid;
					    timeToWait = (int)(86400 - t.TotalSeconds);
					    parent.protectAllBuildingBlocks = true;
				    }
				    else if(currentToEnd.TotalSeconds > 0)
				    {
					    timeToWait = (int)currentToEnd.TotalSeconds;
					    parent.protectAllBuildingBlocks = false;
				    }
			    }
			    else if(startRaid > endRaid)
			    {
				    if(currentToEnd.TotalSeconds > 0)
				    {
					    timeToWait = (int)currentToEnd.TotalSeconds;
					    parent.protectAllBuildingBlocks = false;
				    }
				    else if(currentToEnd.TotalSeconds < 0 && currentToStart.TotalSeconds< 0)
				    {
					    t = current - endRaid;
					    timeToWait = (int)(86400 - t.TotalSeconds);
					    parent.protectAllBuildingBlocks = false;
				    }
				    else if(currentToStart.TotalSeconds > 0)
				    {
					    timeToWait = (int)currentToStart.TotalSeconds;
					    parent.protectAllBuildingBlocks = true;
				    }
			    }
			    else return;
				
				
			    if(parent.protectAllBuildingBlocks)
			    {
				    PrintToChat($"<color={parent.chatPrefixColor}>{parent.chatPrefix}</color>: Raids are disabled. They'll be enabled again in " + (timeToWait / 3600) + "h " + (timeToWait % 3600) / 60 + "m " + (timeToWait % 3600) % 60 + "s");
			    }
			    else{
				    PrintToChat($"<color={parent.chatPrefixColor}>{parent.chatPrefix}</color>: Raids are enabled. They'll be disabled again in " + (timeToWait / 3600) + "h " + (timeToWait % 3600) / 60 + "m " + (timeToWait % 3600) % 60 + "s");
			    }
			
			    timer.Once((float)timeToWait, () => loop());
             }

            void loop()
		    {
			    int interval;
			    if(parent.protectAllBuildingBlocks)
			    {
				    parent.protectAllBuildingBlocks = false;
				    interval = toEnd;
				    PrintToChat($"<color={parent.chatPrefixColor}>{parent.chatPrefix}</color>: Warning ! Raids are now enabled !");
				    PrintToChat($"<color={parent.chatPrefixColor}>{parent.chatPrefix}</color>: They'll be disabled in " + (interval / 3600) + "h " + (interval % 3600) / 60 + "m " + (interval % 3600) % 60 + "s");
			    }
			    else
			    {
				    parent.protectAllBuildingBlocks = true;
				    interval = toStart;
				    PrintToChat("Warning ! Raids are now disabled !");
				    PrintToChat("They'll be enabled in " + (interval / 3600) + "h " + (interval % 3600) / 60 + "m " + (interval % 3600) % 60 + "s");
			    }
			    timer.Once((float)interval, () => parent.protector.loop());
		    }

        }
   
        void LoadVariables()
        {
            // Settings
            startHours = Convert.ToInt32(GetConfigValue("Start of raids", "Hours", defaultStartHours));
			startMinutes = Convert.ToInt32(GetConfigValue("Start of raids", "Minutes", defaultStartMinutes));
			startSeconds = Convert.ToInt32(GetConfigValue("Start of raids", "Seconds", defaultStartSeconds));
			endHours = Convert.ToInt32(GetConfigValue("End of raids", "Hours", defaultEndHours));
			endMinutes = Convert.ToInt32(GetConfigValue("End of raids", "Minutes", defaultEndMinutes));
			endSeconds = Convert.ToInt32(GetConfigValue("End of raids", "Seconds", defaultEndSeconds));

            // Options
            daysProtected = Convert.ToString(GetConfigValue("Options", "Days of the week when Protector is enabled", defaultDaysProtected));
            informPlayer = bool.Parse(Convert.ToString(GetConfigValue("Options", "Inform Player", defaultInformPlayer)));
            informInterval = float.Parse(Convert.ToString(GetConfigValue("Options", "Inform Interval", defaultInformInterval)));

            // Messages
            informMessage = Convert.ToString(GetConfigValue("Messages", "InformMessage", defaultInformMessage));
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (!(entity is LootContainer) && !(entity is BaseHelicopter)
                && !(entity is BaseNPC) && !(entity is BasePlayer))
            {
                if (protectAllBuildingBlocks)
                {
                    info.damageTypes = new DamageTypeList();
                    info.DoHitEffects = false;
                    info.HitMaterial = 0;
                }

                if (info.damageTypes.Total() != 0f) return;

                var player = info.Initiator as BasePlayer;
                if (player && informPlayer && onlinePlayers[player].LastInformTime + informInterval < GetTimestamp())
                {
                    onlinePlayers[player].LastInformTime = GetTimestamp();
				    String startHour = protector.startRaid.Hour + "h " + protector.startRaid.Minute + "m " + protector.startRaid.Second + "s";
				    String endHour = protector.endRaid.Hour + "h " + protector.endRaid.Minute + "m " + protector.endRaid.Second + "s";
                    SendChatMessage(player, informMessage, startHour, endHour);
                }
            }
        }

        void OnPlayerInit(BasePlayer player) 
            => onlinePlayers[player].LastInformTime = 0f;

        #region Helper Methods

        void Log(string message) 
            => Puts("{0} : {1}", Title, message);

        void SendChatMessage(BasePlayer player, string message, params object[] arguments) 
            => PrintToChat(player, $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}", arguments);
        
        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;

            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }

            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }

            return value;
        }
		
        private long GetTimestamp()
            => Convert.ToInt64((System.DateTime.UtcNow.Subtract(epoch)).TotalSeconds);

		[ChatCommand("raid")]
        private void SaveCommand(BasePlayer player, string command, string[] args)
        {
            if (protector != null)
            {
                String startHour = protector.startRaid.Hour + "h " + protector.startRaid.Minute + "m " + protector.startRaid.Second + "s";
			    String endHour = protector.endRaid.Hour + "h " + protector.endRaid.Minute + "m " + protector.endRaid.Second + "s";
                SendChatMessage(player, "Raids are activated between " + startHour + " and " + endHour);
            }
			else 
            {
                SendChatMessage(player,  "Raids are activated all the day.");
            }
        }
			
        #endregion

    }

}


// --- End of file: BuildingProtector.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AlphaLoot.cs ---
// --- Original Local Path: AlphaLoot.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Steamworks;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AlphaLoot", "k1lly0u", "3.1.3")]
    class AlphaLoot : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin CustomLootSpawns, EventLoot, FancyDrop, SkinBox;

        private StoredData storedData;
        private StoredData bradleyData;
        private StoredData heliData;

        private DynamicConfigFile data, bradley, heli, skinData;

        private bool updateContainerCapacities = false;

        private static Hash<string, HashSet<SkinEntry>> weightedSkinIds;
        private static Hash<string, List<ulong>> importedSkinIds;
        private static Hash<string, int> defaultScrapAmounts;

        private const string ADMIN_PERMISSION = "alphaloot.admin";

        private const string HELI_CRATE = "heli_crate";
        private const string BRADLEY_CRATE = "bradley_crate";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            defaultScrapAmounts = new Hash<string, int>();

            permission.RegisterPermission(ADMIN_PERMISSION, this);
            
            LoadData();

            if (updateContainerCapacities)
                SetCapacityLimits();
        }

        private void OnServerInitialized()
        {
            PopulateContainerDefinitions(ref storedData, ref heliData, ref bradleyData);
            SaveData();
            Puts($"Loaded {storedData.loot_advanced.Count + storedData.loot_simple.Count} loot container definitions and {storedData.npcs_advanced.Count + storedData.npcs_simple.Count} npc loot definitions");
            Puts($"Loaded {heliData.loot_advanced.Count + heliData.loot_simple.Count} heli loot profiles");
            Puts($"Loaded {bradleyData.loot_advanced.Count + bradleyData.loot_simple.Count} bradley loot profiles");

            if (configData.AutoUpdate)
                AutoUpdateItemLists();
            
            if (configData.UseSkinboxSkins || configData.UseApprovedSkins)
            {
                if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
                {
                    PrintWarning("Waiting for Steamworks to initialize to load item skins");
                    Steamworks.SteamInventory.OnDefinitionsUpdated += LoadSkins;
                }
                else LoadSkins();
            } 
            else RefreshLootContents();
        }

        private void OnEntitySpawned(BradleyAPC bradleyApc)
        {
            if (bradleyApc != null)
                bradleyApc.maxCratesToSpawn = configData.BradleyCrates;
        }

        private void OnEntitySpawned(BaseHelicopter baseHelicopter)
        {
            if (baseHelicopter != null)
                baseHelicopter.maxCratesToSpawn = configData.HelicopterCrates;
        }

        private object OnCorpsePopulate(BaseEntity entity, LootableCorpse corpse)
        {
            if (entity == null || corpse == null)
                return null;

            object obj = Interface.CallHook("CanPopulateLoot", entity, corpse);
            if (obj != null)
                return null;

            return PopulateLoot(entity, corpse) ? corpse : null;
        }

        private object OnLootSpawn(LootContainer container)
        {
            if (container == null)
                return null;

            if (CustomLootSpawns && (bool)CustomLootSpawns.Call("IsLootBox", container as BaseEntity))
                return null;

            if (EventLoot && (bool)EventLoot.Call("IsEventLootContainer", container as BaseEntity))
                return null;

            if (FancyDrop && container is SupplyDrop && !configData.OverrideFancyDrop)
                return null;

            object obj = Interface.CallHook("CanPopulateLoot", container);
            if (obj != null)
                return null;
            
            if (PopulateLoot(container))
                return true;

            return null;
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null)
                return;

            if (!permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                return;

            LootContainer lootContainer = info?.HitEntity?.GetComponent<LootContainer>();
            if (lootContainer == null)
                return;

            player.ChatMessage($"Viewing loot generation for: <color=#ffff00>{lootContainer.ShortPrefabName}</color>");
            lootContainer.gameObject.AddComponent<LootCycler>();
            player.inventory.loot.StartLootingEntity(lootContainer, false);
            player.inventory.loot.AddContainer(lootContainer.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootContainer.panelName);
        }

        private void OnLootEntityEnd(BasePlayer player, StorageContainer container)
        {
            LootCycler lootCycler = container?.GetComponent<LootCycler>();
            if (lootCycler != null)
                UnityEngine.Object.Destroy(lootCycler);
        }

        private void Unload()
        {
            RefreshLootContents(null, true);
            configData = null;

            weightedSkinIds = null;
            importedSkinIds = null;
            defaultScrapAmounts = null;
        }
        #endregion

        #region Skins
        private void LoadSkins()
        {
            Steamworks.SteamInventory.OnDefinitionsUpdated -= LoadSkins;

            if (configData.UseSkinboxSkins)
                PopulateSkinListFromSkinBox();

            if (configData.UseApprovedSkins)
                PopulateSkinListFromApproved();

            RefreshLootContents();
        }

        private void PopulateSkinListFromSkinBox()
        {
            Dictionary<string, LinkedList<ulong>> dictionary = SkinBox?.Call("getSkincache") as Dictionary<string, LinkedList<ulong>>;
            if (dictionary != null)
            {
                importedSkinIds = new Hash<string, List<ulong>>();

                foreach(KeyValuePair<string, LinkedList<ulong>> kvp in dictionary)
                {
                    List<ulong> list = new List<ulong>();
                    list.AddRange(kvp.Value);
                    importedSkinIds[kvp.Key] = list;
                }

                Puts($"Imported {importedSkinIds.Sum(x => x.Value.Count)} skins from SkinBox");
            }            
        }

        private void PopulateSkinListFromApproved()
        {
            if (importedSkinIds == null)
                importedSkinIds = new Hash<string, List<ulong>>();

            List<int> itemSkinDirectory = Pool.GetList<int>();
            itemSkinDirectory.AddRange(ItemSkinDirectory.Instance.skins.Select(x => x.id));

            int count = 0;

            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                if (string.IsNullOrEmpty(shortname) || item.Id < 100)
                    continue;

                ulong wsid;
                if (itemSkinDirectory.Contains(item.Id))
                    wsid = (ulong)item.Id;
                else
                {
                    if (!ulong.TryParse(item.GetProperty("workshopid"), out wsid))
                        continue;
                }

                if (!importedSkinIds.ContainsKey(shortname))
                    importedSkinIds[shortname] = new List<ulong>();

                if (!importedSkinIds[shortname].Contains(wsid))
                {
                    importedSkinIds[shortname].Add(wsid);
                    count++;
                }
            }

            Puts($"Imported {count} approved skins that weren't already in the list");
            Pool.FreeList(ref itemSkinDirectory);
        }
        #endregion

        #region Container Population
        private void RefreshLootContents(ConsoleSystem.Arg arg = null, bool setDefaultScrap = false)
        {
            LootContainer[] lootContainers = UnityEngine.Object.FindObjectsOfType<LootContainer>();
            
            if (arg != null)
                SendReply(arg, $"Repopulating loot for {lootContainers?.Length} containers");
            else Puts($"Repopulating loot for {lootContainers?.Length} containers");

            for (int i = 0; i < lootContainers?.Length; i++)
            {
                LootContainer lootContainer = lootContainers[i];
                if (lootContainer != null && !lootContainer.IsDestroyed)
                {
                    if (lootContainer.inventory == null)
                    {
                        lootContainer.CreateInventory(true);
                        lootContainer.OnInventoryFirstCreated(lootContainer.inventory);
                    }

                    if (setDefaultScrap)
                    {
                        int scrapAmount;
                        if (defaultScrapAmounts.TryGetValue(lootContainer.ShortPrefabName, out scrapAmount))
                            lootContainer.scrapAmount = scrapAmount;
                    }

                    lootContainer.inventory.capacity = lootContainer.inventorySlots;
                    lootContainer.CancelInvoke(lootContainer.SpawnLoot);
                    lootContainer.Invoke(lootContainer.SpawnLoot, UnityEngine.Random.Range(1f, 20f));
                }
            }
        }

        private void PopulateContainerDefinitions(ref StoredData storedData, ref StoredData heliData, ref StoredData bradleyData)
        {
            storedData.IsBaseLootTable = true;

            List<LootContainer> containers = Resources.FindObjectsOfTypeAll<LootContainer>().OrderBy(x => x.ShortPrefabName).ToList();

            for (int i = 0; i < containers.Count; i++)
            {
                LootContainer lootContainer = containers[i];

                if (!defaultScrapAmounts.ContainsKey(lootContainer.ShortPrefabName))
                    defaultScrapAmounts[lootContainer.ShortPrefabName] = lootContainer.scrapAmount;

                if (lootContainer.ShortPrefabName.Equals(HELI_CRATE))
                {
                    BaseLootContainerProfile lootContainerProfile;

                    if (storedData.TryGetLootProfile(HELI_CRATE, out lootContainerProfile))
                    {
                        heliData.CloneLootProfile(HELI_CRATE, lootContainerProfile);
                        storedData.RemoveProfile(HELI_CRATE);
                        Debug.LogWarning($"Helicopter loot profiles have been removed from your loot table and placed in its own data file. (/data/AlphaLoot/LootProfiles/{configData.HeliProfileName}.json)");
                    }
                    else
                    {
                        if (heliData.HasAnyProfiles)
                            continue;

                        heliData.CreateDefaultLootProfile(lootContainer);
                    }
                }
                else if (lootContainer.ShortPrefabName.Equals(BRADLEY_CRATE))
                {
                    BaseLootContainerProfile lootContainerProfile;

                    if (storedData.TryGetLootProfile(BRADLEY_CRATE, out lootContainerProfile))
                    {
                        bradleyData.CloneLootProfile(BRADLEY_CRATE, lootContainerProfile);
                        storedData.RemoveProfile(BRADLEY_CRATE);
                        Debug.LogWarning($"Bradley loot profiles have been removed from your loot table and placed in its own data file. (/data/AlphaLoot/LootProfiles/{configData.BradleyProfileName}.json)");
                    }
                    else
                    {
                        if (bradleyData.HasAnyProfiles)
                            continue;

                        bradleyData.CreateDefaultLootProfile(lootContainer);
                    }
                }
                else storedData.CreateDefaultLootProfile(containers[i]);
            }

            for (int i = 0; i < npcPrefabs.Count; i++)
            {
                string prefab = npcPrefabs[i];
                GameObject obj = GameManager.server.FindPrefab(prefab);

                prefab = ToShortName(prefab);

                HTNPlayer htnPlayer = obj.GetComponent<HTNPlayer>();
                if (htnPlayer != null)
                {
                    BaseNpcDefinition baseDefinition = htnPlayer.AiDefinition;
                    if (baseDefinition is Rust.Ai.HTN.Murderer.MurdererDefinition)
                    {
                        storedData.CreateDefaultLootProfile(prefab, (baseDefinition as Rust.Ai.HTN.Murderer.MurdererDefinition).Loot);
                        continue;
                    }

                    if (baseDefinition is Rust.Ai.HTN.Scientist.ScientistDefinition)
                    {
                        storedData.CreateDefaultLootProfile(prefab, (baseDefinition as Rust.Ai.HTN.Scientist.ScientistDefinition).Loot);
                        continue;
                    }

                    if (baseDefinition is Rust.Ai.HTN.NPCTurret.NPCTurretDefinition)
                    {
                        storedData.CreateDefaultLootProfile(prefab, (baseDefinition as Rust.Ai.HTN.NPCTurret.NPCTurretDefinition).Loot);
                        continue;
                    }

                    if (baseDefinition is Rust.Ai.HTN.ScientistAStar.ScientistAStarDefinition)
                    {
                        storedData.CreateDefaultLootProfile(prefab, (baseDefinition as Rust.Ai.HTN.ScientistAStar.ScientistAStarDefinition).Loot);
                        continue;
                    }

                    if (baseDefinition is Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileDefinition)
                    {
                        storedData.CreateDefaultLootProfile(prefab, (baseDefinition as Rust.Ai.HTN.ScientistJunkpile.ScientistJunkpileDefinition).Loot);
                        continue;
                    }

                    continue;
                }

                global::HumanNPC humanNPC = obj.GetComponent<global::HumanNPC>();
                if (humanNPC != null)
                {
                    storedData.CreateDefaultLootProfile(prefab, humanNPC.LootSpawnSlots);
                    continue;
                }

                NPCMurderer npcMurderer = obj.GetComponent<NPCMurderer>();
                if (npcMurderer != null)
                {
                    storedData.CreateDefaultLootProfile(prefab, npcMurderer.LootSpawnSlots);
                    continue;
                }

                Scientist scientist = obj.GetComponent<Scientist>();
                if (scientist != null)
                {
                    storedData.CreateDefaultLootProfile(prefab, scientist.LootSpawnSlots);
                    continue;
                }
            }            
        }

        private bool PopulateLoot(LootContainer container)
        {            
            BaseLootContainerProfile lootProfile;

            if (container.ShortPrefabName.Equals(HELI_CRATE))
            {
                if (heliData.GetRandomLootProfile(out lootProfile))
                {
                    PopulateLootContainer(container, lootProfile);
                    return true;
                }
            }
            else if (container.ShortPrefabName.Equals(BRADLEY_CRATE))
            {
                if (bradleyData.GetRandomLootProfile(out lootProfile))
                {
                    PopulateLootContainer(container, lootProfile);
                    return true;
                }
            }
            else
            {
                if (storedData.TryGetLootProfile(container.ShortPrefabName, out lootProfile) && lootProfile.Enabled)
                {                    
                    PopulateLootContainer(container, lootProfile);
                    return true;
                }
            }

            return false;
        }

        private void PopulateLootContainer(LootContainer container, BaseLootContainerProfile lootProfile)
        {
            container.destroyOnEmpty = lootProfile.DestroyOnEmpty;

            lootProfile.PopulateLoot(container.inventory);

            container.CancelInvoke(container.SpawnLoot);

            if (lootProfile.ShouldRefreshContents)
                container.Invoke(container.SpawnLoot, UnityEngine.Random.Range(lootProfile.MinSecondsBetweenRefresh, lootProfile.MaxSecondsBetweenRefresh));
        }

        private bool PopulateLoot(BaseEntity entity, LootableCorpse corpse)
        {
            BaseLootProfile lootProfile;
            if (storedData.TryGetNPCProfile(entity.ShortPrefabName, out lootProfile))
            {
                if (!lootProfile.Enabled)
                    return false;

                lootProfile.PopulateLoot(corpse.containers[0]);
                return true;
            }
            return false;
        }
        #endregion

        #region Functions
        private string ToShortName(string name)
        {
            return name.Split('/').Last().Replace(".prefab", "");
        }

        private LootContainer FindContainer(BasePlayer player)
        {
            RaycastHit raycastHit;
            if (Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 20f))
            {
                LootContainer lootContainer = raycastHit.GetEntity() as LootContainer;
                return lootContainer;
            }
            return null;
        }

        private object WantsToHandleFancyDropLoot() => configData.OverrideFancyDrop ? (object)true : null;
        #endregion

        #region Auto-Updater
        private void AutoUpdateItemLists()
        {
            const string lastDefaultTable = "AlphaLoot/AutoUpdater/do_not_edit_this_file";
            
            ItemList lastItemList;

            if (Interface.Oxide.DataFileSystem.ExistsDatafile(lastDefaultTable))
            {
                lastItemList = Interface.Oxide.DataFileSystem.GetFile(lastDefaultTable).ReadObject<ItemList>();

                if (lastItemList != null)
                {
                    if (lastItemList.protocol == Rust.Protocol.printable)
                    {
                        Debug.Log("[AlphaLoot Auto Updater] - Last item list protocol matches current protocol. No new items added");
                        return;
                    }

                    List<int> newItems = Pool.GetList<int>();

                    ItemManager.itemList.ForEach(x =>
                    {
                        if (!lastItemList.itemIds.Contains(x.itemid))
                            newItems.Add(x.itemid);
                    });

                    if (newItems.Count > 0)
                    {
                        int additions = 0;

                        Debug.Log($"[AlphaLoot Auto Updater] - Found {newItems.Count} new game items. Adding them to your loot table");

                        AddItemsToLootTable(newItems, out additions);

                        if (additions > 0)
                        {
                            Debug.Log($"[AlphaLoot Auto Updater] - Added {additions} new loot definitions to the loot table");
                            SaveData();
                            Interface.Oxide.DataFileSystem.WriteObject<ItemList>(lastDefaultTable, new ItemList() { itemIds = ItemManager.itemDictionary.Keys.ToList(), protocol = Rust.Protocol.printable });
                        }
                    }
                    else Debug.Log("[AlphaLoot Auto Updater] - No new items in game");

                    Pool.FreeList(ref newItems);
                }
            }
            else
            {
                Debug.Log("[AlphaLoot Auto Updater] - Generating item list for auto-updater. Future game updates will automatically add new items to your loot table. You can disable this feature in the config");
                Interface.Oxide.DataFileSystem.WriteObject<ItemList>(lastDefaultTable, new ItemList() { itemIds = ItemManager.itemDictionary.Keys.ToList(), protocol = Rust.Protocol.printable });
            }
        }

        private void AddSpecifiedItemsToLootTable(params string[] args)
        {
            int additions = 0;

            List<int> items = Pool.GetList<int>();

            foreach(string str in args)
            {
                ItemDefinition itemDefinition = ItemManager.FindItemDefinition(str);
                if (itemDefinition != null)
                    items.Add(itemDefinition.itemid);
            }

            if (items.Count > 0)
            {
                Debug.Log($"[AlphaLoot] - Adding {items.Count} specified items to your loot table");

                AddItemsToLootTable(items, out additions);

                if (additions > 0)
                {
                    Debug.Log($"[AlphaLoot] - Successfully added {additions} new loot definitions to the loot table");
                    SaveData();
                }
            }
            else Debug.Log("[AlphaLoot] - Failed to find item definitions for the shortname's supplied");

            Pool.FreeList(ref items);
        }

        private void AddItemsToLootTable(List<int> items, out int additions)
        {
            additions = 0;

            StoredData defaultLootTable = new StoredData();
            StoredData defaultHeliLootTable = new StoredData();
            StoredData defaultBradleyLootTable = new StoredData();

            PopulateContainerDefinitions(ref defaultLootTable, ref defaultHeliLootTable, ref defaultBradleyLootTable);

            foreach (KeyValuePair<string, AdvancedLootContainerProfile> kvp in defaultLootTable.loot_advanced)
            {
                foreach (int itemid in items)
                {
                    string shortname = ItemManager.itemDictionary[itemid].shortname;

                    NewLootItem newLootItem = new NewLootItem();
                    float score = 0;
                    int multiplier = 1;

                    foreach (LootSpawnSlot lootSpawnSlot in kvp.Value.LootSpawnSlots)
                    {
                        FindItemAndCalculateScoreRecursive(lootSpawnSlot.LootDefinition, shortname, ref newLootItem, ref multiplier);
                        score += (lootSpawnSlot.Probability * newLootItem.Score) * lootSpawnSlot.NumberToSpawn;
                    }

                    if (score > 0)
                    {
                        AdvancedLootContainerProfile advancedLootProfile;
                        if (storedData.loot_advanced.TryGetValue(kvp.Key, out advancedLootProfile))
                        {
                            LootSpawnSlot newLootSpawnSlot = new LootSpawnSlot
                            {
                                LootDefinition = new LootSpawn()
                                {
                                    Items = new ItemAmountRanged[] { newLootItem.Item },
                                    SubSpawn = new LootSpawn.Entry[0]
                                },
                                NumberToSpawn = 1,
                                Probability = Mathf.Clamp01(score * multiplier)
                            };

                            int index = advancedLootProfile.LootSpawnSlots.Length;

                            System.Array.Resize(ref advancedLootProfile.LootSpawnSlots, index + 1);

                            advancedLootProfile.LootSpawnSlots[index] = newLootSpawnSlot;

                            additions++;
                            Debug.Log($"[AlphaLoot] - Added {shortname} to advanced loot profile ({kvp.Key}) with a calculated probability of {newLootSpawnSlot.Probability}");
                        }
                        else
                        {
                            SimpleLootContainerProfile simpleLootContainerProfile;
                            if (storedData.loot_simple.TryGetValue(kvp.Key, out simpleLootContainerProfile))
                            {
                                ItemAmountWeighted itemAmountWeighted = new ItemAmountWeighted()
                                {
                                    BlueprintChance = newLootItem.Item.BlueprintChance,
                                    Condition = new ItemAmount.ConditionItem() { MinCondition = newLootItem.Item.Condition.MinCondition, MaxCondition = newLootItem.Item.Condition.MaxCondition },
                                    MaxAmount = newLootItem.Item.MaxAmount,
                                    MinAmount = newLootItem.Item.MinAmount,
                                    Shortname = shortname,
                                    Weight = Mathf.Max(Mathf.RoundToInt(((float)simpleLootContainerProfile.Items.Sum(x => x.Weight) * score) * multiplier), 1)
                                };

                                int index = simpleLootContainerProfile.Items.Length;

                                System.Array.Resize(ref simpleLootContainerProfile.Items, index + 1);

                                simpleLootContainerProfile.Items[index] = itemAmountWeighted;

                                additions++;
                                Debug.Log($"[AlphaLoot] - Added {shortname} to simple loot profile ({kvp.Key}) with a calculated weight of {itemAmountWeighted.Weight}");
                            }
                        }
                        continue;
                    }
                }
            }

            foreach (KeyValuePair<string, AdvancedLootContainerProfile> kvp in defaultHeliLootTable.loot_advanced)
            {
                foreach (int itemid in items)
                {
                    string shortname = ItemManager.itemDictionary[itemid].shortname;

                    NewLootItem newLootItem = new NewLootItem();
                    float score = 0;
                    int multiplier = 1;

                    foreach (LootSpawnSlot lootSpawnSlot in kvp.Value.LootSpawnSlots)
                    {
                        FindItemAndCalculateScoreRecursive(lootSpawnSlot.LootDefinition, shortname, ref newLootItem, ref multiplier);
                        score += (lootSpawnSlot.Probability * newLootItem.Score) * lootSpawnSlot.NumberToSpawn;
                    }

                    if (score > 0)
                    {
                        AdvancedLootContainerProfile advancedLootProfile;
                        if (heliData.loot_advanced.TryGetValue(kvp.Key, out advancedLootProfile))
                        {
                            LootSpawnSlot newLootSpawnSlot = new LootSpawnSlot
                            {
                                LootDefinition = new LootSpawn()
                                {
                                    Items = new ItemAmountRanged[] { newLootItem.Item },
                                    SubSpawn = new LootSpawn.Entry[0]
                                },
                                NumberToSpawn = 1,
                                Probability = Mathf.Clamp01(score * multiplier)
                            };

                            int index = advancedLootProfile.LootSpawnSlots.Length;

                            System.Array.Resize(ref advancedLootProfile.LootSpawnSlots, index + 1);

                            advancedLootProfile.LootSpawnSlots[index] = newLootSpawnSlot;

                            additions++;
                            Debug.Log($"[AlphaLoot] - Added {shortname} to advanced heli loot profile ({kvp.Key}) with a calculated probability of {newLootSpawnSlot.Probability}");
                        }
                        else
                        {
                            SimpleLootContainerProfile simpleLootContainerProfile;
                            if (heliData.loot_simple.TryGetValue(kvp.Key, out simpleLootContainerProfile))
                            {
                                ItemAmountWeighted itemAmountWeighted = new ItemAmountWeighted()
                                {
                                    BlueprintChance = newLootItem.Item.BlueprintChance,
                                    Condition = new ItemAmount.ConditionItem() { MinCondition = newLootItem.Item.Condition.MinCondition, MaxCondition = newLootItem.Item.Condition.MaxCondition },
                                    MaxAmount = newLootItem.Item.MaxAmount,
                                    MinAmount = newLootItem.Item.MinAmount,
                                    Shortname = shortname,
                                    Weight = Mathf.Max(Mathf.RoundToInt(((float)simpleLootContainerProfile.Items.Sum(x => x.Weight) * score) * multiplier), 1)
                                };

                                int index = simpleLootContainerProfile.Items.Length;

                                System.Array.Resize(ref simpleLootContainerProfile.Items, index + 1);

                                simpleLootContainerProfile.Items[index] = itemAmountWeighted;

                                additions++;
                                Debug.Log($"[AlphaLoot] - Added {shortname} to simple heli loot profile ({kvp.Key}) with a calculated weight of {itemAmountWeighted.Weight}");
                            }
                        }
                        continue;
                    }
                }
            }

            foreach (KeyValuePair<string, AdvancedLootContainerProfile> kvp in defaultBradleyLootTable.loot_advanced)
            {
                foreach (int itemid in items)
                {
                    string shortname = ItemManager.itemDictionary[itemid].shortname;

                    NewLootItem newLootItem = new NewLootItem();
                    float score = 0;
                    int multiplier = 1;

                    foreach (LootSpawnSlot lootSpawnSlot in kvp.Value.LootSpawnSlots)
                    {
                        FindItemAndCalculateScoreRecursive(lootSpawnSlot.LootDefinition, shortname, ref newLootItem, ref multiplier);
                        score += (lootSpawnSlot.Probability * newLootItem.Score) * lootSpawnSlot.NumberToSpawn;
                    }

                    if (score > 0)
                    {
                        AdvancedLootContainerProfile advancedLootProfile;
                        if (bradleyData.loot_advanced.TryGetValue(kvp.Key, out advancedLootProfile))
                        {
                            LootSpawnSlot newLootSpawnSlot = new LootSpawnSlot
                            {
                                LootDefinition = new LootSpawn()
                                {
                                    Items = new ItemAmountRanged[] { newLootItem.Item },
                                    SubSpawn = new LootSpawn.Entry[0]
                                },
                                NumberToSpawn = 1,
                                Probability = Mathf.Clamp01(score * multiplier)
                            };

                            int index = advancedLootProfile.LootSpawnSlots.Length;

                            System.Array.Resize(ref advancedLootProfile.LootSpawnSlots, index + 1);

                            advancedLootProfile.LootSpawnSlots[index] = newLootSpawnSlot;

                            additions++;
                            Debug.Log($"[AlphaLoot] - Added {shortname} to advanced bradley loot profile ({kvp.Key}) with a calculated probability of {newLootSpawnSlot.Probability}");
                        }
                        else
                        {
                            SimpleLootContainerProfile simpleLootContainerProfile;
                            if (bradleyData.loot_simple.TryGetValue(kvp.Key, out simpleLootContainerProfile))
                            {
                                ItemAmountWeighted itemAmountWeighted = new ItemAmountWeighted()
                                {
                                    BlueprintChance = newLootItem.Item.BlueprintChance,
                                    Condition = new ItemAmount.ConditionItem() { MinCondition = newLootItem.Item.Condition.MinCondition, MaxCondition = newLootItem.Item.Condition.MaxCondition },
                                    MaxAmount = newLootItem.Item.MaxAmount,
                                    MinAmount = newLootItem.Item.MinAmount,
                                    Shortname = shortname,
                                    Weight = Mathf.Max(Mathf.RoundToInt(((float)simpleLootContainerProfile.Items.Sum(x => x.Weight) * score) * multiplier), 1)
                                };

                                int index = simpleLootContainerProfile.Items.Length;

                                System.Array.Resize(ref simpleLootContainerProfile.Items, index + 1);

                                simpleLootContainerProfile.Items[index] = itemAmountWeighted;

                                additions++;
                                Debug.Log($"[AlphaLoot] - Added {shortname} to simple bradley loot profile ({kvp.Key}) with a calculated weight of {itemAmountWeighted.Weight}");
                            }
                        }
                        continue;
                    }
                }
            }
        }
        
        private void FindItemAndCalculateScoreRecursive(LootSpawn lootSpawn, string shortname, ref NewLootItem newLootItem, ref int multiplier)
        {            
            if (lootSpawn.SubSpawn.Length > 0)
            {
                foreach(LootSpawn.Entry lootSpawnEntry in lootSpawn.SubSpawn)
                {
                    FindItemAndCalculateScoreRecursive(lootSpawnEntry.Category, shortname, ref newLootItem, ref multiplier);

                    if (newLootItem.HasItem)
                    {
                        if (newLootItem.Score == 0)
                            newLootItem.Score = (float)lootSpawnEntry.Weight / (float)lootSpawn.SubSpawn.Sum(x => x.Weight);
                        else newLootItem.Score *= (float)lootSpawnEntry.Weight / (float)lootSpawn.SubSpawn.Sum(x => x.Weight);

                        return;
                    }
                }
            }
            else if (lootSpawn.Items.Length > 0)
            {
                foreach(ItemAmountRanged itemAmountRanged in lootSpawn.Items)
                {
                    if (itemAmountRanged.Shortname == shortname)
                    {
                        if (newLootItem.HasItem)
                            multiplier++;
                        newLootItem.Item = itemAmountRanged;
                    }
                }
            }
        }

        private class NewLootItem
        {
            public ItemAmountRanged Item;
            public float Score;

            public bool HasItem => Item != null;

            public void Clear()
            {
                Item = null;
                Score = 0;
            }
        }

        private class ItemList
        {
            public List<int> itemIds = new List<int>();
            public string protocol;
        }
        #endregion

        #region Components
        private class LootCycler : MonoBehaviour
        {
            private LootContainer lootContainer;

            private void Awake()
            {
                lootContainer = GetComponent<LootContainer>();
                InvokeHandler.InvokeRepeating(this, lootContainer.SpawnLoot, 3f, 3f);
            }
        }
        #endregion

        #region Commands
        [ChatCommand("aloot")]
        private void cmdRepopulateTarget(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
            {
                SendReply(player, "You do not have permission to use this command");
                return;
            }
            
            if (args == null || args.Length == 0)
            {
                SendReply(player, "/aloot repopulate - Repopulate the container you are looking at");
                SendReply(player, "/aloot view - List the contents of the container you are looking at");
                SendReply(player, "/aloot repopulateall - Repopulate every loot container on the map (can take upto 20 seconds)");
                return;
            }

            switch (args[0].ToLower())
            {
                case "repopulate":
                    {
                        LootContainer lootContainer = FindContainer(player);
                        if (lootContainer != null)
                        {
                            lootContainer.CancelInvoke(lootContainer.SpawnLoot);
                            lootContainer.SpawnLoot();

                            SendReply(player, $"Refreshed loot contents for {lootContainer.ShortPrefabName}");
                        }
                        else SendReply(player, "No loot container found");
                    }
                    return;
                case "view":
                    {
                        LootContainer lootContainer = FindContainer(player);
                        if (lootContainer != null)
                        {                            
                            SendReply(player, $"Loot contents for {lootContainer.ShortPrefabName};");
                            SendReply(player, lootContainer.inventory.itemList.Select(x => $"{x.info.displayName.english} x{x.amount}").ToSentence());
                        }
                        else SendReply(player, "No loot container found");
                    }
                    return;
                case "repopulateall":
                    {
                        SendReply(player, "Refreshing all loot containers...");
                        RefreshLootContents();
                    }
                    return;
                default:
                    SendReply(player, "Invalid syntax!");
                    break;
            }            
        }        

        [ConsoleCommand("al.repopulateall")]
        private void ccmdRepopulateAll(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                BasePlayer player = arg.Player();
                if (player != null && !permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            RefreshLootContents(arg);
        }

        [ConsoleCommand("al.additems")]
        private void ccmdAddItemsl(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                BasePlayer player = arg.Player();
                if (player != null && !permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "al.additems <shortname> <opt:shortname> <opt:shortname>... - Add the specified item(s) to your loot table.\nThis finds the containers the items are in from the default loot table, calculates a score and adds it to your existing loot table.\nYou can enter as many shortnames as you like");
                return;
            }

            AddSpecifiedItemsToLootTable(arg.Args);
        }

        [ConsoleCommand("al.search")]
        private void ccmdSearchItem(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                BasePlayer player = arg.Player();
                if (player != null && !permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            string shortname = arg.GetString(0);
            if (string.IsNullOrEmpty(shortname) || !ItemManager.itemDictionaryByName.ContainsKey(shortname))
            {
                SendReply(arg, "You must enter a valid item shortname to search");
                return;
            }

            Hash<string, int> containers = new Hash<string, int>();

            foreach (KeyValuePair<string, AdvancedLootContainerProfile> profile in storedData.loot_advanced)
            {
                int count = 0;
                foreach (LootSpawnSlot lootSpawnSlot in profile.Value.LootSpawnSlots)
                {
                    FindItemCountRecursive(lootSpawnSlot.LootDefinition, shortname, ref count);
                }

                if (count > 0)
                    containers[profile.Key] = count;
            }

            foreach (KeyValuePair<string, AdvancedNPCLootProfile> profile in storedData.npcs_advanced)
            {
                int count = 0;
                foreach (LootSpawnSlot lootSpawnSlot in profile.Value.LootSpawnSlots)
                {
                    FindItemCountRecursive(lootSpawnSlot.LootDefinition, shortname, ref count);
                }

                if (count > 0)
                    containers[profile.Key] = count;
            }

            foreach (KeyValuePair<string, SimpleLootContainerProfile> profile in storedData.loot_simple)
            {
                int count = 0;
                foreach (ItemAmountWeighted itemAmountWeighted in profile.Value.Items)
                {
                    if (itemAmountWeighted.Shortname == shortname)
                        count++;
                }

                if (count > 0)
                    containers[profile.Key] = count;
            }

            foreach (KeyValuePair<string, SimpleNPCLootProfile> profile in storedData.npcs_simple)
            {
                int count = 0;
                foreach (ItemAmountWeighted itemAmountWeighted in profile.Value.Items)
                {
                    if (itemAmountWeighted.Shortname == shortname)
                        count++;
                }

                if (count > 0)
                    containers[profile.Key] = count;
            }

            if (containers.Count == 0)
            {
                SendReply(arg, $"The item {shortname} was not found in any loot profiles");
                return;
            }
            else
            {
                SendReply(arg, $"Found item {shortname} {containers.Sum(x => x.Value)} times in {containers.Count} loot profiles;{containers.Select(x => $"\n{x.Key} (x{x.Value})").ToSentence()}");
                return;
            }
        }

        private void FindItemCountRecursive(LootSpawn lootSpawn, string shortname, ref int count)
        {
            if (lootSpawn.SubSpawn.Length > 0)
            {
                foreach (LootSpawn.Entry lootSpawnEntry in lootSpawn.SubSpawn)                
                    FindItemCountRecursive(lootSpawnEntry.Category, shortname, ref count);                
            }
            else if (lootSpawn.Items.Length > 0)
            {
                foreach (ItemAmountRanged itemAmountRanged in lootSpawn.Items)
                {
                    if (itemAmountRanged.Shortname == shortname)                    
                        count++;                    
                }
            }
        }

        [ConsoleCommand("al.setloottable")]
        private void ccmdChangeConfig(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                BasePlayer player = arg.Player();
                if (player != null && !permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length != 1)
            {
                SendReply(arg, "Invalid arguments supplied! al.setloottable \"file name\"");
                return;
            }

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"AlphaLoot/LootProfiles/{arg.Args[0]}"))
            {
                SendReply(arg, $"Unable to find a loot table with the name {arg.Args[0]}");
                return;
            }

            configData.ProfileName = arg.Args[0];
            SaveConfig();
           
            SendReply(arg, $"Loot table set to: {configData.ProfileName}");

            LoadLootTable();

            RefreshLootContents(arg);
        }

        [ConsoleCommand("al.setheliloottable")]
        private void ccmdChangeHeliConfig(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                BasePlayer player = arg.Player();
                if (player != null && !permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length != 1)
            {
                SendReply(arg, "Invalid arguments supplied! al.setheliloottable \"heli file name\"");
                return;
            }

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"AlphaLoot/LootProfiles/{arg.Args[0]}"))
            {
                SendReply(arg, $"Unable to find a heli loot table with the name {arg.Args[0]}");
                return;
            }

            configData.HeliProfileName = arg.Args[0];
            SaveConfig();

            SendReply(arg, $"Heli Loot table set to: {configData.HeliProfileName}");

            LoadHeliTable();
        }

        [ConsoleCommand("al.setbradleyloottable")]
        private void ccmdChangeBradleyConfig(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                BasePlayer player = arg.Player();
                if (player != null && !permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length != 1)
            {
                SendReply(arg, "Invalid arguments supplied! al.setbradleyloottable \"heli file name\"");
                return;
            }

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"AlphaLoot/LootProfiles/{arg.Args[0]}"))
            {
                SendReply(arg, $"Unable to find a bradley loot table with the name {arg.Args[0]}");
                return;
            }

            configData.BradleyProfileName = arg.Args[0];
            SaveConfig();

            SendReply(arg, $"Bradley Loot table set to: {configData.BradleyProfileName}");

            LoadBradleyTable();
        }

        [ConsoleCommand("al.generatetable")]
        private void ccmdGenerateTable(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                BasePlayer player = arg.Player();
                if (player != null && !permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length < 3)
            {
                SendReply(arg, "al.generatetable <filename> <heli_filename> <bradley_filename> - Generate the default loot table to the specified file");
                return;
            }

            string fileName = arg.GetString(0);
            if (fileName.Equals(configData.ProfileName, System.StringComparison.OrdinalIgnoreCase))
            {
                SendReply(arg, "The filename you entered is the same as the loot table currently being used. Change the filename to something else");
                return;
            }

            string heliFileName = arg.GetString(1);
            if (fileName.Equals(configData.HeliProfileName, System.StringComparison.OrdinalIgnoreCase))
            {
                SendReply(arg, "The heli filename you entered is the same as the heli loot table currently being used. Change the filename to something else");
                return;
            }

            string bradleyFileName = arg.GetString(2);
            if (fileName.Equals(configData.BradleyProfileName, System.StringComparison.OrdinalIgnoreCase))
            {
                SendReply(arg, "The bradley filename you entered is the same as the bradley loot table currently being used. Change the filename to something else");
                return;
            }

            StoredData storedData = new StoredData();
            StoredData heliData = new StoredData();
            StoredData bradleyData = new StoredData();

            PopulateContainerDefinitions(ref storedData, ref heliData, ref bradleyData);

            Interface.Oxide.DataFileSystem.WriteObject<StoredData>($"AlphaLoot/LootProfiles/{fileName}", storedData);
            Interface.Oxide.DataFileSystem.WriteObject<StoredData>($"AlphaLoot/LootProfiles/{heliFileName}", heliData);
            Interface.Oxide.DataFileSystem.WriteObject<StoredData>($"AlphaLoot/LootProfiles/{bradleyFileName}", bradleyData);

            SendReply(arg, $"Generated a default loot table to /oxide/data/AlphaLoot/LootProfiles/ ({fileName}.json, {heliFileName}.json and {bradleyFileName}.json)");
        }

        [ConsoleCommand("al.skins")]
        private void ccmdALSkins(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                BasePlayer player = arg.Player();
                if (player != null && !permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "al.skins add <shortname> <skinid> <opt:weight> - Add a single skin to the random skin list, with a optional argument to specify the weight of this skin");
                SendReply(arg, "al.skins remove <shortname> - Remove all skins for the specified item");
                SendReply(arg, "al.skins remove <shortname> <skinid> - Remove an individual skin");
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "add":
                    {                        
                        string shortname = arg.GetString(1, string.Empty);
                        ulong skinId = arg.GetULong(2, 0UL);
                        int weight = arg.GetInt(3, 1);

                        if (string.IsNullOrEmpty(shortname) || ItemManager.FindItemDefinition(shortname) == null)
                        {
                            SendReply(arg, "You must enter a valid item shortname");
                            return;
                        }
                                                
                        if (!weightedSkinIds.ContainsKey(shortname))
                            weightedSkinIds[shortname] = new HashSet<SkinEntry>();

                        weightedSkinIds[shortname].Add(new SkinEntry(skinId, weight));
                        skinData.WriteObject(weightedSkinIds);

                        SendReply(arg, $"You have added the skin {skinId} for item {shortname} with a weight of {weight}");
                    }
                    return;
                case "remove":
                    {
                        string shortname = arg.GetString(1, string.Empty);
                        if (string.IsNullOrEmpty(shortname) || ItemManager.FindItemDefinition(shortname) == null)
                        {
                            SendReply(arg, "You must enter a valid item shortname");
                            return;
                        }

                        if (arg.Args.Length < 3)
                        {
                            weightedSkinIds.Remove(shortname);
                            skinData.WriteObject(weightedSkinIds);
                            SendReply(arg, $"You have removed all skins for item {shortname}");
                        }
                        else
                        {
                            ulong skinId = arg.GetULong(2, 0UL);
                            
                            HashSet<SkinEntry> list;
                            if (weightedSkinIds.TryGetValue(shortname, out list))
                            {
                                for (int i = list.Count - 1; i >= 0; i--)
                                {
                                    SkinEntry skinEntry = list.ElementAt(i);
                                    if (skinEntry.SkinID == skinId)
                                    {
                                        weightedSkinIds[shortname].Remove(skinEntry);
                                        skinData.WriteObject(weightedSkinIds);
                                        SendReply(arg, $"You have removed the skin {skinId} for item {shortname}");
                                        return;
                                    }
                                }                                
                            }
                            else
                            {
                                SendReply(arg, $"There are no skins saved for item {shortname}");
                                return;
                            }
                        }                        
                    }
                    return;
                default:
                    break;
            }
        }
        #endregion

        #region Config        
        private static ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Auto-update loot tables with new items")]
            public bool AutoUpdate { get; set; }

            [JsonProperty(PropertyName = "Global Loot Multiplier (multiplies all loot amounts by the number specified)")]
            public float GlobalMultiplier { get; set; }

            [JsonProperty(PropertyName = "Apply global and individual loot multipliers to un-stackable items")]
            public bool MultiplyUnstackable { get; set; }

            [JsonProperty(PropertyName = "Loot Table Name")]
            public string ProfileName { get; set; }

            [JsonProperty(PropertyName = "Heli Loot Table Name")]
            public string HeliProfileName { get; set; }

            [JsonProperty(PropertyName = "Bradley Loot Table Name")]
            public string BradleyProfileName { get; set; }

            [JsonProperty(PropertyName = "Amount of crates to drop (Bradley APC - default 3)")]
            public int BradleyCrates { get; set; }

            [JsonProperty(PropertyName = "Amount of crates to drop (Patrol Helicopter - default 4)")]
            public int HelicopterCrates { get; set; }

            [JsonProperty(PropertyName = "Override FancyDrop containers with supply drop profile")]
            public bool OverrideFancyDrop { get; set; }

            [JsonProperty(PropertyName = "Use skins from the SkinBox skin list")]
            public bool UseSkinboxSkins { get; set; }

            [JsonProperty(PropertyName = "Use skins from the approved skin list")]
            public bool UseApprovedSkins { get; set; }
                        
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                AutoUpdate = false,
                GlobalMultiplier = 1f,
                MultiplyUnstackable = false,
                ProfileName = "default_loottable",
                HeliProfileName = "default_heli_loottable",
                BradleyProfileName = "default_bradley_loottable",
                BradleyCrates = 3,
                HelicopterCrates = 4,
                OverrideFancyDrop = false,
                UseSkinboxSkins = false,
                UseApprovedSkins = false,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(3, 0, 1))
            {
                configData.BradleyCrates = 3;
                configData.HelicopterCrates = 4;
            }

            if (configData.Version < new VersionNumber(3, 0, 4))
            {
                configData.UseApprovedSkins = false;
                configData.UseSkinboxSkins = false;
            }

            if (configData.Version < new VersionNumber(3, 0, 5))
            {
                updateContainerCapacities = true;
            }

            if (configData.Version < new VersionNumber(3, 0, 14))
            {
                configData.HeliProfileName = baseConfig.HeliProfileName;
                configData.BradleyProfileName = baseConfig.BradleyProfileName;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private void SaveData()
        {
            data.WriteObject(storedData);
            heli.WriteObject(heliData);
            bradley.WriteObject(bradleyData);
        }

        private void LoadData()
        {
            LoadLootTable();
            LoadHeliTable();
            LoadBradleyTable();
            LoadSkinsData();
        }

        private void LoadLootTable()
        {
            PrintWarning($"Loading Loot Table from {configData.ProfileName}.json!");

            data = Interface.Oxide.DataFileSystem.GetFile($"AlphaLoot/LootProfiles/{configData.ProfileName}");

            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }

            if (!storedData.IsValid)
            {
                PrintWarning("Invalid loot table file loaded, it contains no loot definitions! If this is a fresh install you can ignore this message, otherwise are you trying to load a ALv2.x.x loot table in to v3.x.x?");
                storedData = new StoredData();
            }
        }

        private void LoadHeliTable()
        {
            PrintWarning($"Loading Heli Loot Table from {configData.HeliProfileName}.json!");

            heli = Interface.Oxide.DataFileSystem.GetFile($"AlphaLoot/LootProfiles/{configData.HeliProfileName}");
            try
            {
                heliData = heli.ReadObject<StoredData>();
            }
            catch
            {
                heliData = new StoredData();
            }

            heliData.IsBaseLootTable = false;
            heliData.ProfileName = "heli_crate";
        }

        private void LoadBradleyTable()
        {
            PrintWarning($"Loading Bradley Loot Table from {configData.BradleyProfileName}.json!");

            bradley = Interface.Oxide.DataFileSystem.GetFile($"AlphaLoot/LootProfiles/{configData.BradleyProfileName}");
            try
            {
                bradleyData = bradley.ReadObject<StoredData>();
            }
            catch
            {
                bradleyData = new StoredData();
            }

            bradleyData.IsBaseLootTable = false;
            bradleyData.ProfileName = "bradley_crate";
        }

        private void LoadSkinsData()
        {
            skinData = Interface.Oxide.DataFileSystem.GetFile("AlphaLoot/item_skin_ids");

            try
            {
                weightedSkinIds = skinData.ReadObject<Hash<string, HashSet<SkinEntry>>>();
            }
            catch
            {
                weightedSkinIds = new Hash<string, HashSet<SkinEntry>>();
            }

            if (weightedSkinIds == null)
                weightedSkinIds = new Hash<string, HashSet<SkinEntry>>();
        }

        private void SetCapacityLimits()
        {
            int count = 0;

            foreach (KeyValuePair<string, AdvancedLootContainerProfile> kvp in storedData.loot_advanced)
            {
                if (kvp.Value.MaximumItems == -1)
                {
                    string prefabPath = string.Empty;
                    for (int i = 0; i < GameManifest.Current.entities.Length; i++)
                    {
                        string path = GameManifest.Current.entities[i];

                        if (path.EndsWith($"{kvp.Key}.prefab", System.StringComparison.OrdinalIgnoreCase))
                        {
                            prefabPath = path;
                            break;
                        }
                    }

                    if (!string.IsNullOrEmpty(prefabPath))
                    {
                        LootContainer container = GameManager.server.FindPrefab(prefabPath.ToLower()).GetComponent<LootContainer>();                       
                        kvp.Value.MaximumItems = container.inventorySlots;
                        count++;
                    }
                }
            }

            if (count > 0)
            {
                Puts($"Updated capacity limits for {count} advanced loot profiles");
                SaveData();
            }
        }

        #region Data Structure
        public class BaseLootProfile
        {
            public bool Enabled = true;

            public bool AllowSkinnedItems = true;

            public float LootMultiplier = 1;

            public int MinScrapAmount;
            public int MaxScrapAmount;

            [JsonIgnore]
            private static ItemDefinition _scrapDefinition;

            [JsonIgnore]
            public ItemDefinition ScrapDefinition
            {
                get
                {
                    if (_scrapDefinition == null)
                        _scrapDefinition = ItemManager.FindItemDefinition("scrap");
                    return _scrapDefinition;
                }
            }

            [JsonIgnore]
            private static ItemDefinition _blueprintBase;

            [JsonIgnore]
            public ItemDefinition BlueprintBaseDefinition
            {
                get
                {
                    if (_blueprintBase == null)
                        _blueprintBase = ItemManager.FindItemDefinition("blueprintbase");
                    return _blueprintBase;
                }
            }


            public int GetScrapAmount() => UnityEngine.Random.Range(MinScrapAmount, MaxScrapAmount);

            public virtual void PopulateLoot(ItemContainer container)
            {
                int scrapAmount = Mathf.RoundToInt(GetScrapAmount() * configData.GlobalMultiplier);
                if (scrapAmount > 0)
                {
                    container.capacity = container.itemList.Count + 1;

                    if (container.entityOwner is LootContainer)
                    {
                        (container.entityOwner as LootContainer).scrapAmount = scrapAmount;
                        (container.entityOwner as LootContainer).GenerateScrap();
                    }
                    else ItemManager.Create(ScrapDefinition, scrapAmount).MoveToContainer(container);
                }
                else container.capacity = container.itemList.Count;
            }
        }

        public class BaseLootContainerProfile : BaseLootProfile
        {
            public bool DestroyOnEmpty = true;
            public bool ShouldRefreshContents;
            
            public int MinSecondsBetweenRefresh = 3600;
            public int MaxSecondsBetweenRefresh = 7200;
        }

        public class SimpleNPCLootProfile : BaseLootProfile
        {
            public int MinimumItems;
            public int MaximumItems;

            public ItemAmountWeighted[] Items;

            public SimpleNPCLootProfile() { }

            public SimpleNPCLootProfile(SimpleNPCLootProfile lootContainerProfile)
            {
                AllowSkinnedItems = lootContainerProfile.AllowSkinnedItems;
               
                MinScrapAmount = lootContainerProfile.MinScrapAmount;
                MaxScrapAmount = lootContainerProfile.MaxScrapAmount;

                MinimumItems = lootContainerProfile.MinimumItems;
                MaximumItems = lootContainerProfile.MaximumItems;

                Items = lootContainerProfile.Items;

                Enabled = lootContainerProfile.Enabled;
            }

            public override void PopulateLoot(ItemContainer container)
            {
                int count = UnityEngine.Random.Range(MinimumItems, MaximumItems + 1);

                container.capacity = count;

                List<ItemAmountWeighted> items = Pool.GetList<ItemAmountWeighted>();
                items.AddRange(Items);

                int itemCount = 0;
                while (itemCount < count)
                {
                    int totalWeight = items.Sum((ItemAmountWeighted x) => x.Weight);

                    int random = UnityEngine.Random.Range(0, totalWeight);

                    for (int y = 0; y < items.Count; y++)
                    {
                        ItemAmountWeighted itemAmountWeighted = items[y];
                        ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemAmountWeighted.Shortname);

                        totalWeight -= items[y].Weight;
                        if (random >= totalWeight)
                        {
                            items.Remove(itemAmountWeighted);

                            Item item = null;
                            if (itemAmountWeighted.WantsBlueprint())
                            {
                                ItemDefinition blueprintBaseDef = BlueprintBaseDefinition;
                                if (blueprintBaseDef == null)
                                    continue;

                                item = ItemManager.Create(blueprintBaseDef);
                                item.blueprintTarget = itemAmountWeighted.ItemID;
                            }
                            else
                            {
                                item = ItemManager.CreateByItemID(itemAmountWeighted.ItemID, (int)itemAmountWeighted.GetAmount(LootMultiplier), AllowSkinnedItems ? itemAmountWeighted.RandomSkinID() : 0UL);

                                if (item.hasCondition)
                                    item.condition = itemAmountWeighted.GetConditionFraction() * item.info.condition.max;
                            }
                            if (item != null)
                            {
                                item.OnVirginSpawn();
                                if (!item.MoveToContainer(container, -1, true))
                                    item.Remove(0f);
                            }

                            itemCount++;
                            break;
                        }
                    }

                    if (items.Count == 0)
                        items.AddRange(Items);
                }

                Pool.FreeList(ref items);
                base.PopulateLoot(container);
            }
        }

        public class AdvancedNPCLootProfile : BaseLootProfile
        {       
            public LootSpawnSlot[] LootSpawnSlots;

            public int MaximumItems = -1;

            public AdvancedNPCLootProfile() { }

            public AdvancedNPCLootProfile(LootContainer.LootSpawnSlot[] lootSpawnSlots)
            {                
                LootSpawnSlots = new LootSpawnSlot[lootSpawnSlots?.Length ?? 0];

                for (int i = 0; i < lootSpawnSlots?.Length; i++)
                {
                    LootSpawnSlots[i] = new LootSpawnSlot(lootSpawnSlots[i], true);
                }
            }

            public AdvancedNPCLootProfile(AdvancedNPCLootProfile lootContainerProfile)
            {                
                MinScrapAmount = lootContainerProfile.MinScrapAmount;
                MaxScrapAmount = lootContainerProfile.MaxScrapAmount;

                MaximumItems = lootContainerProfile.MaximumItems;

                LootSpawnSlots = lootContainerProfile.LootSpawnSlots;

                AllowSkinnedItems = lootContainerProfile.AllowSkinnedItems;

                LootMultiplier = lootContainerProfile.LootMultiplier;

                Enabled = lootContainerProfile.Enabled;
            }

            public override void PopulateLoot(ItemContainer container)
            {
                if (LootSpawnSlots != null && LootSpawnSlots.Length != 0)
                {
                    container.capacity = MaximumItems == -1 ? 36 : MaximumItems;
                    for (int i = 0; i < LootSpawnSlots.Length; i++)
                    {
                        LootSpawnSlot lootSpawnSlot = LootSpawnSlots[i];
                        for (int j = 0; j < lootSpawnSlot.NumberToSpawn; j++)
                        {
                            if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.Probability)
                            {
                                lootSpawnSlot.LootDefinition.SpawnIntoContainer(container, this);
                            }
                        }
                    }
                }

                base.PopulateLoot(container);
            }
        }

        public class SimpleLootContainerProfile : BaseLootContainerProfile
        {
            public int MinimumItems;
            public int MaximumItems;

            public ItemAmountWeighted[] Items;

            public SimpleLootContainerProfile() { }

            public SimpleLootContainerProfile(SimpleLootContainerProfile lootContainerProfile)
            {                
                DestroyOnEmpty = lootContainerProfile.DestroyOnEmpty;

                AllowSkinnedItems = lootContainerProfile.AllowSkinnedItems;
                ShouldRefreshContents = lootContainerProfile.ShouldRefreshContents;
                MinSecondsBetweenRefresh = lootContainerProfile.MinSecondsBetweenRefresh;
                MaxSecondsBetweenRefresh = lootContainerProfile.MaxSecondsBetweenRefresh;

                MinScrapAmount = lootContainerProfile.MinScrapAmount;
                MaxScrapAmount = lootContainerProfile.MaxScrapAmount;

                MinimumItems = lootContainerProfile.MinimumItems;
                MaximumItems = lootContainerProfile.MaximumItems;

                Items = lootContainerProfile.Items;

                Enabled = lootContainerProfile.Enabled;
            }

            public override void PopulateLoot(ItemContainer container)
            {
                int count = UnityEngine.Random.Range(MinimumItems, MaximumItems + 1);

                container.capacity = count;

                List<ItemAmountWeighted> items = Pool.GetList<ItemAmountWeighted>();
                items.AddRange(Items);

                int itemCount = 0;
                while (itemCount < count)
                {
                    int totalWeight = items.Sum((ItemAmountWeighted x) => x.Weight);

                    int random = UnityEngine.Random.Range(0, totalWeight);

                    for (int y = 0; y < items.Count; y++)
                    {
                        ItemAmountWeighted itemAmountWeighted = items[y];
                        ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemAmountWeighted.Shortname);

                        totalWeight -= items[y].Weight;
                        if (random >= totalWeight)
                        {
                            items.Remove(itemAmountWeighted);

                            Item item = null;
                            if (itemAmountWeighted.WantsBlueprint())
                            {
                                ItemDefinition blueprintBaseDef = BlueprintBaseDefinition;
                                if (blueprintBaseDef == null)
                                    continue;

                                item = ItemManager.Create(blueprintBaseDef, 1, 0UL);
                                item.blueprintTarget = itemAmountWeighted.ItemID;
                            }
                            else
                            {
                                item = ItemManager.CreateByItemID(itemAmountWeighted.ItemID, (int)itemAmountWeighted.GetAmount(LootMultiplier), AllowSkinnedItems ? itemAmountWeighted.RandomSkinID() : 0UL);

                                if (item.hasCondition)
                                    item.condition = itemAmountWeighted.GetConditionFraction() * item.info.condition.max;
                            }
                            if (item != null)
                            {
                                item.OnVirginSpawn();
                                if (!item.MoveToContainer(container, -1, true))
                                    item.Remove(0f);
                            }

                            itemCount++;
                            break;
                        }
                    }

                    if (items.Count == 0)
                        items.AddRange(Items);
                }

                Pool.FreeList(ref items);
                base.PopulateLoot(container);
            }
        }

        public class AdvancedLootContainerProfile : BaseLootContainerProfile
        {
            public LootSpawnSlot[] LootSpawnSlots;

            public int MaximumItems = -1;

            public AdvancedLootContainerProfile() { }

            public AdvancedLootContainerProfile(LootContainer container)
            {
                bool hasCondition = container.SpawnType == LootContainer.spawnType.ROADSIDE || container.SpawnType == LootContainer.spawnType.TOWN;

                DestroyOnEmpty = container.destroyOnEmpty;
                ShouldRefreshContents = (float.IsInfinity(container.minSecondsBetweenRefresh) || float.IsInfinity(container.maxSecondsBetweenRefresh)) ? false : container.shouldRefreshContents;

                int scrapAmount;
                if (!defaultScrapAmounts.TryGetValue(container.ShortPrefabName, out scrapAmount))
                    scrapAmount = 1;

                MinScrapAmount = MaxScrapAmount = scrapAmount;

                MinSecondsBetweenRefresh = !ShouldRefreshContents ? 0 : Mathf.RoundToInt(container.minSecondsBetweenRefresh);
                MaxSecondsBetweenRefresh = !ShouldRefreshContents ? 0 : Mathf.RoundToInt(container.maxSecondsBetweenRefresh);

                MaximumItems = container.inventorySlots;

                LootSpawnSlots = new LootSpawnSlot[(container.LootSpawnSlots?.Length ?? 0) + 1];

                if (container.LootSpawnSlots?.Length > 0)
                {
                    LootSpawnSlots = new LootSpawnSlot[container.LootSpawnSlots?.Length ?? 0];
                    for (int i = 0; i < container.LootSpawnSlots?.Length; i++)
                    {
                        LootSpawnSlots[i] = new LootSpawnSlot(container.LootSpawnSlots[i], hasCondition);
                    }
                }
                else
                {
                    if (container.lootDefinition != null)
                    {
                        LootSpawnSlots = new LootSpawnSlot[]
                        {
                            new LootSpawnSlot(container.lootDefinition, container.maxDefinitionsToSpawn, hasCondition)
                        };
                    }
                }
            }

            public AdvancedLootContainerProfile(AdvancedLootContainerProfile lootContainerProfile)
            {
                DestroyOnEmpty = lootContainerProfile.DestroyOnEmpty;

                AllowSkinnedItems = lootContainerProfile.AllowSkinnedItems;

                ShouldRefreshContents = lootContainerProfile.ShouldRefreshContents;

                MinSecondsBetweenRefresh = lootContainerProfile.MinSecondsBetweenRefresh;
                MaxSecondsBetweenRefresh = lootContainerProfile.MaxSecondsBetweenRefresh;

                MinScrapAmount = lootContainerProfile.MinScrapAmount;
                MaxScrapAmount = lootContainerProfile.MaxScrapAmount;
                             
                MaximumItems = lootContainerProfile.MaximumItems;

                LootSpawnSlots = lootContainerProfile.LootSpawnSlots;

                Enabled = lootContainerProfile.Enabled;
            }

            public override void PopulateLoot(ItemContainer container)
            {
                if (LootSpawnSlots != null && LootSpawnSlots.Length != 0)
                {
                    container.capacity = MaximumItems == -1 ? 36 : MaximumItems;

                    for (int i = 0; i < LootSpawnSlots.Length; i++)
                    {
                        LootSpawnSlot lootSpawnSlot = LootSpawnSlots[i];
                        for (int j = 0; j < lootSpawnSlot.NumberToSpawn; j++)
                        {
                            if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.Probability)
                            {
                                lootSpawnSlot.LootDefinition.SpawnIntoContainer(container, this);
                            }
                        }
                    }
                }

                base.PopulateLoot(container);
            }
        }

        public class LootSpawnSlot
        {
            public LootSpawn LootDefinition;

            public int NumberToSpawn;

            public float Probability;

            public LootSpawnSlot() { }

            public LootSpawnSlot(global::LootSpawn lootSpawn, int numberToSpawn, bool hasCondition)
            {
                LootDefinition = new LootSpawn(lootSpawn, hasCondition);
                NumberToSpawn = numberToSpawn;
                Probability = 1f;
            }

            public LootSpawnSlot(LootContainer.LootSpawnSlot lootSpawnSlot, bool hasCondition)
            {
                LootDefinition = new LootSpawn(lootSpawnSlot.definition, hasCondition);
                NumberToSpawn = lootSpawnSlot.numberToSpawn;
                Probability = lootSpawnSlot.probability;
            }
        }

        public class LootSpawn
        {
            public ItemAmountRanged[] Items;

            public Entry[] SubSpawn;

            public byte[] Node = new byte[0];

            public LootSpawn() { }

            public LootSpawn(global::LootSpawn lootSpawn, bool hasCondition)
            {
                Items = new ItemAmountRanged[lootSpawn.items?.Length ?? 0];

                for (int i = 0; i < lootSpawn.items?.Length; i++)
                {
                    global::ItemAmountRanged itemAmountRanged = lootSpawn.items[i];

                    Items[i] = new ItemAmountRanged(itemAmountRanged.itemDef, itemAmountRanged.amount, itemAmountRanged.maxAmount, hasCondition);
                }

                SubSpawn = new Entry[lootSpawn.subSpawn?.Length ?? 0];

                for (int i = 0; i < lootSpawn.subSpawn?.Length; i++)
                {
                    global::LootSpawn.Entry subspawn = lootSpawn.subSpawn[i];

                    SubSpawn[i] = new Entry()
                    {
                        Category = new LootSpawn(subspawn.category, hasCondition),
                        Weight = subspawn.weight
                    };                   
                }
            }

            public void SpawnIntoContainer(ItemContainer container, BaseLootProfile lootProfile)
            {
                if (SubSpawn != null && SubSpawn.Length != 0)
                {
                    SubCategoryIntoContainer(container, lootProfile);
                    return;
                }

                if (Items != null)
                {
                    foreach (ItemAmountRanged itemAmountRanged in Items)
                    {
                        if (itemAmountRanged != null)
                        {
                            Item item = null;
                            if (itemAmountRanged.WantsBlueprint())
                            {
                                ItemDefinition blueprintBaseDef = lootProfile.BlueprintBaseDefinition;
                                if (blueprintBaseDef == null)                                
                                    continue;
                                
                                item = ItemManager.Create(blueprintBaseDef, 1, 0UL);
                                item.blueprintTarget = itemAmountRanged.ItemID;
                            }
                            else
                            {
                                item = ItemManager.CreateByItemID(itemAmountRanged.ItemID, (int)itemAmountRanged.GetAmount(lootProfile.LootMultiplier), lootProfile.AllowSkinnedItems ? itemAmountRanged.RandomSkinID() : 0UL);

                                if (item.hasCondition)
                                    item.condition = itemAmountRanged.GetConditionFraction() * item.info.condition.max;
                            }
                            if (item != null)
                            {
                                item.OnVirginSpawn();
                                if (!item.MoveToContainer(container, -1, true))                                
                                    item.Remove(0f);                                   
                            }
                        }
                    }
                }
            }

            private void SubCategoryIntoContainer(ItemContainer container, BaseLootProfile lootProfile)
            {
                int totalWeight = SubSpawn.Sum((LootSpawn.Entry x) => x.Weight);

                int random = UnityEngine.Random.Range(0, totalWeight);

                for (int i = 0; i < SubSpawn.Length; i++)
                {
                    if (SubSpawn[i].Category != null)
                    {
                        totalWeight -= SubSpawn[i].Weight;
                        if (random >= totalWeight)
                        {
                            SubSpawn[i].Category.SpawnIntoContainer(container, lootProfile);
                            return;
                        }
                    }
                }
            }

            public class Entry
            {
                public LootSpawn Category;

                public int Weight;

                public byte[] Node = new byte[0];
            }
        }

        public class ItemAmountWeighted : ItemAmountRanged
        {
            public int Weight = 1;
        }

        public class ItemAmountRanged : ItemAmount
        {
            public float MaxAmount = -1f;

            public ItemAmountRanged() : base() { }

            public ItemAmountRanged(ItemDefinition item = null, float amount = 0f, float maxAmount = -1f, bool hasCondition = false) : base(item, amount, hasCondition)
            {
                this.MaxAmount = Mathf.Max(maxAmount, amount);
            }

            public override float GetAmount(float lootMultiplier)
            {
                ItemDefinition itemDefinition = ItemManager.FindItemDefinition(ItemID);                
                bool isStackable = (itemDefinition.stackable > 1 && !itemDefinition.condition.enabled) || configData.MultiplyUnstackable;

                if (this.MinAmount == this.MaxAmount)
                {
                    if (!isStackable)
                        return Mathf.Clamp(this.MinAmount, 1, int.MaxValue);

                    return Mathf.Clamp((this.MinAmount * lootMultiplier) * configData.GlobalMultiplier, 1, int.MaxValue);
                }

                if (!isStackable)
                    return (int)Mathf.Clamp(UnityEngine.Random.Range(this.MinAmount, this.MaxAmount), 1, int.MaxValue);

                return (int)Mathf.Clamp((UnityEngine.Random.Range(this.MinAmount, this.MaxAmount) * lootMultiplier) * configData.GlobalMultiplier, 1, int.MaxValue);
            }
        }
                
        public class ItemAmount
        {
            public string Shortname;

            public float BlueprintChance;
           
            public float MinAmount;

            public ConditionItem Condition;

            [JsonIgnore]
            private int _itemId = -1;

            [JsonIgnore]
            public int ItemID
            {
                get
                {
                    if (_itemId < 0)
                        _itemId = ItemManager.FindItemDefinition(Shortname).itemid;
                    return _itemId;
                }
            }
            
            public ItemAmount() { }

            public ItemAmount(ItemDefinition item = null, float amount = 0f, bool hasCondition= false)
            {
                Shortname = item.shortname;

                BlueprintChance = item.spawnAsBlueprint ? 1f : 0f;

                MinAmount = amount;

                Condition = new ConditionItem
                {
                    MinCondition = hasCondition && item.condition.enabled ? item.condition.foundCondition.fractionMin : 1f,
                    MaxCondition = hasCondition && item.condition.enabled ? item.condition.foundCondition.fractionMax : 1f
                };
            }

            public virtual float GetAmount(float lootMultiplier)
            {
                ItemDefinition itemDefinition = ItemManager.FindItemDefinition(ItemID);
                bool isStackable = (itemDefinition.stackable > 1 && !itemDefinition.condition.enabled) || configData.MultiplyUnstackable;

                if (!isStackable)
                    return (int)Mathf.Clamp(this.MinAmount, 1, int.MaxValue);

                return (int)Mathf.Clamp((MinAmount * lootMultiplier) * configData.GlobalMultiplier, 1, int.MaxValue);
            }

            public ulong RandomSkinID()
            {                
                HashSet<SkinEntry> hashset;
                if (weightedSkinIds.TryGetValue(Shortname, out hashset) && hashset.Count > 0)
                {
                    int totalWeight = hashset.Sum((SkinEntry x) => x.Weight);

                    int random = UnityEngine.Random.Range(0, totalWeight);

                    foreach (SkinEntry skinEntry in hashset)
                    {
                        totalWeight -= skinEntry.Weight;

                        if (random >= totalWeight)                        
                            return skinEntry.SkinID;                        
                    }

                }

                if (importedSkinIds != null)
                {
                    List<ulong> list;
                    if (importedSkinIds.TryGetValue(Shortname, out list) && list.Count > 0)
                    {
                        return list.GetRandom();
                    }
                }

                return 0UL;           
            }

            public float GetConditionFraction() => UnityEngine.Random.Range(Condition.MinCondition, Condition.MaxCondition);

            public bool WantsBlueprint() => UnityEngine.Random.Range(0.0f, 1.0f) < BlueprintChance;

            public class ConditionItem
            {
                public float MinCondition;

                public float MaxCondition;
            }
        }

        public class SkinEntry
        {
            public int Weight;
            public ulong SkinID;

            public SkinEntry() { }

            public SkinEntry(ulong skinId, int weight = 1)
            {
                this.SkinID = skinId;
                this.Weight = weight;
            }
        }
        #endregion

        private class StoredData
        {
            public Hash<string, SimpleLootContainerProfile> loot_simple = new Hash<string, SimpleLootContainerProfile>();

            public Hash<string, AdvancedLootContainerProfile> loot_advanced = new Hash<string, AdvancedLootContainerProfile>();

            public Hash<string, AdvancedNPCLootProfile> npcs_advanced = new Hash<string, AdvancedNPCLootProfile>();

            public Hash<string, SimpleNPCLootProfile> npcs_simple = new Hash<string, SimpleNPCLootProfile>();

            public bool IsBaseLootTable = true;

            public string ProfileName = string.Empty;
           
            [JsonIgnore]
            public bool IsValid => loot_simple != null && loot_advanced != null && npcs_advanced != null && npcs_simple != null && (loot_advanced.Count > 0 || loot_simple.Count > 0) && (npcs_advanced.Count != 0 || npcs_simple.Count != 0);

            [JsonIgnore]
            public bool HasAnyProfiles => loot_simple != null && loot_advanced != null && npcs_advanced != null && npcs_simple != null && (loot_advanced.Count > 0 || loot_simple.Count > 0 || npcs_advanced.Count > 0 || npcs_simple.Count > 0);

            public void CreateDefaultLootProfile(LootContainer container)
            {                
                string shortPrefabName = container.ShortPrefabName;
                if (string.IsNullOrEmpty(shortPrefabName))                
                    shortPrefabName = container.name;
                
                if (loot_advanced.ContainsKey(shortPrefabName) || loot_simple.ContainsKey(shortPrefabName))
                    return;

                loot_advanced.Add(shortPrefabName, new AdvancedLootContainerProfile(container));
            }

            public void CloneLootProfile(string shortname, BaseLootProfile lootContainerProfile)
            {
                if (lootContainerProfile is AdvancedLootContainerProfile)
                {
                    loot_advanced[shortname] = new AdvancedLootContainerProfile(lootContainerProfile as AdvancedLootContainerProfile);
                }
                else if (lootContainerProfile is SimpleLootContainerProfile)
                {
                    loot_simple[shortname] = new SimpleLootContainerProfile(lootContainerProfile as SimpleLootContainerProfile);
                }
                else if (lootContainerProfile is AdvancedNPCLootProfile)
                {
                    npcs_advanced[shortname] = new AdvancedNPCLootProfile(lootContainerProfile as AdvancedNPCLootProfile);
                }
                else if (lootContainerProfile is SimpleNPCLootProfile)
                {
                    npcs_simple[shortname] = new SimpleNPCLootProfile(lootContainerProfile as SimpleNPCLootProfile);
                }
            }

            public void CreateDefaultLootProfile(string shortPrefabName, LootContainer.LootSpawnSlot[] lootSpawnSlots)
            {                
                if (npcs_advanced.ContainsKey(shortPrefabName) || npcs_simple.ContainsKey(shortPrefabName))
                    return;

                npcs_advanced.Add(shortPrefabName, new AdvancedNPCLootProfile(lootSpawnSlots));
            }

            public bool TryGetLootProfile(string shortname, out BaseLootContainerProfile profile)
            {
                AdvancedLootContainerProfile advancedLootContainerProfile;
                if (loot_advanced.TryGetValue(shortname, out advancedLootContainerProfile))
                {
                    profile = advancedLootContainerProfile;
                    return true;
                }

                SimpleLootContainerProfile simpleLootContainerProfile;
                if (loot_simple.TryGetValue(shortname, out simpleLootContainerProfile))
                {
                    profile = simpleLootContainerProfile;
                    return true;
                }

                profile = null;
                return false;
            }

            public bool TryGetNPCProfile(string shortname, out BaseLootProfile profile)
            {
                AdvancedNPCLootProfile advancedNPCLootProfile;
                if (npcs_advanced.TryGetValue(shortname, out advancedNPCLootProfile))
                {
                    profile = advancedNPCLootProfile;
                    return true;
                }

                SimpleNPCLootProfile simpleNPCLootProfile;
                if (npcs_simple.TryGetValue(shortname, out simpleNPCLootProfile))
                {
                    profile = simpleNPCLootProfile;
                    return true;
                }

                profile = null;
                return false;
            }

            #region Random Profiles
            [JsonIgnore]
            private List<BaseLootContainerProfile> randomList = new List<BaseLootContainerProfile>();

            public bool GetRandomLootProfile(out BaseLootContainerProfile profile)
            {
                if (randomList.Count == 0)
                {
                    randomList.AddRange(loot_simple.Values);
                    randomList.AddRange(loot_advanced.Values);
                }

                RESTART_RANDOM:
                if (randomList.Count == 0)
                {
                    profile = null;
                    return false;
                }

                profile = randomList.GetRandom();                
                randomList.Remove(profile);

                if (!profile.Enabled)
                    goto RESTART_RANDOM;

                return true;
            }
            #endregion

            public void RemoveProfile(string shortname)
            {
                loot_simple.Remove(shortname);
                loot_advanced.Remove(shortname);
                npcs_simple.Remove(shortname);
                npcs_advanced.Remove(shortname);
            }
        }
        #endregion

        private List<string> npcPrefabs = new List<string>
        {
            "assets/prefabs/npc/bandit/guard/bandit_guard.prefab",
            "assets/prefabs/npc/murderer/murderer.prefab",
            "assets/prefabs/npc/scarecrow/scarecrow.prefab",
            "assets/prefabs/npc/scientist/groundpatrolpurple.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_astar_full_any.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_full_any.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_full_lr300.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_full_mp5.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_full_pistol.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_full_shotgun.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_junkpile_pistol.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_turret_any.prefab",
            "assets/prefabs/npc/scientist/htn/scientist_turret_lr300.prefab",
            "assets/prefabs/npc/scientist/scientist.prefab",
            "assets/prefabs/npc/scientist/scientist_gunner.prefab",
            "assets/prefabs/npc/scientist/scientistjunkpile.prefab",
            "assets/prefabs/npc/scientist/scientistpeacekeeper.prefab",
            "assets/rust.ai/agents/npcplayer/humannpc/heavyscientist/heavyscientist.prefab",
            "assets/rust.ai/agents/npcplayer/humannpc/humannpc.prefab",
            "assets/rust.ai/agents/npcplayer/humannpc/scientist/scientistnpc.prefab",
            "assets/rust.ai/agents/npcplayer/npcplayertest.prefab",
        };
    }
}


// --- End of file: AlphaLoot.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoLoot.cs ---
// --- Original Local Path: NoLoot.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Random = UnityEngine.Random;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
  [Info("NoLoot", "Virobeast", "0.0.2", ResourceId = 1488)]
  [Description("This plugin removes all loot from your server.")]
  class NoLoot : RustPlugin
  {
    private bool server_ready = false;
    private List<string> barrels = new List<string>() { "loot-barrel-1.prefab", "loot-barrel-2.prefab", "crate_normal.prefab", "crate_normal_2.prefab", "crate_normal_2_food.prefab", "crate_normal_2_medical.prefab", "loot_trash.prefab", "cargo_plane.prefab", "oil_barrel.prefab", "trash-pile-1.prefab", "loot_barrel_1.prefab", "patrolhelicopter.prefab", "loot_barrel_2.prefab" };

    private bool ProcessBarrel(BaseNetworkable entity)
    {
        if (entity.isActiveAndEnabled && barrels.Contains(entity.LookupShortPrefabName()))
        {
            entity.Kill();
            return true;
        }
        return false;
    }

    void OnServerInitialized()
    {
        LootContainer[] loot = Resources.FindObjectsOfTypeAll<LootContainer>();
        int count = 0;
        foreach (var entity in loot)
        {
            if (ProcessBarrel(entity))
                count++;
        }
        Puts($"Deleted {count} loot entities on server start.");
        server_ready = true;
    }

    void OnEntitySpawned(BaseNetworkable entity)
    {
        if (!server_ready)
            return;
        if(ProcessBarrel(entity))
            return;
    }
  }
}


// --- End of file: NoLoot.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Promocodes.cs ---
// --- Original Local Path: Promocodes.cs ---

using System.Collections.Generic;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Promocodes", "LaserHydra", "2.1.2", ResourceId = 1471)]
    [Description("Set up promocodes which run a command on the player who redeemed a code")]
    class Promocodes : RustPlugin
    {
        static List<Promocode> promocodes = new List<Promocode>();

        #region Classes
        
        class Promocode
        {
            public List<object> availableCodes = new List<object>();
            public List<object> commands = new List<object>();

            public Promocode()
            {
            }
            
            internal Promocode(string command, int generateCodes = 10)
            {
                this.commands.Add(command);

                for (int i = 1; i <= generateCodes; i++)
                    availableCodes.Add(GenerateCode());
            }
            
            internal Promocode(object obj)
            {
                if (obj is Dictionary<string, object>)
                {
                    Dictionary<string, object> dic = obj as Dictionary<string, object>;

                    Console.WriteLine(string.Join(Environment.NewLine, (from kvp in dic select $"{kvp.Key}: {kvp.Value}").ToArray()));

                    availableCodes = dic["availableCodes"] as List<object>;
                    commands = dic["commands"] as List<object>;
                }
                else if (obj is Promocode)
                {
                    Promocode code = (Promocode) obj;

                    this.commands = code.commands;
                    this.availableCodes = code.availableCodes;
                }
            }

            internal static Promocode Get(string code) => promocodes.Find((c) => c.availableCodes.Contains(code));
            
            internal static void Redeem(string code, BasePlayer player)
            {
                Promocode promocode = Get(code);

                foreach(string command in promocode.commands)
                    ConsoleSystem.Run.Server.Normal(command.Replace("{steamid}", player.UserIDString).Replace("{name}", player.displayName));
                
                promocode.availableCodes.Remove(code);
            }

            internal static string GenerateCode()
            {
                var promocode = new List<string>();

                for(int blocks = 1; blocks <= 5; blocks++)
                {
                    string block = string.Empty;

                    for(int chars = 1; chars <= 5; chars++)
                    {
                        char[] charArray = "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz1234567890".ToCharArray();

                        block += charArray[UnityEngine.Random.Range(0, charArray.Count() - 1)];
                    }

                    promocode.Add(block);
                }

                return string.Join("-", promocode.ToArray());
            }
        }

        #endregion

        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
#if !RUST
            throw new NotSupportedException("This plugin or the version of this plugin does not support this game!");
#endif

            LoadConfig();
            LoadMessages();

            promocodes = (from promocode in GetConfig(new List<object>(), "Promocodes") select new Promocode(promocode)).ToList();
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Invalid Code", "The entered code is invalid!"},
                {"Code Redeemed", "You successfully redeemed the code."},
            }, this);
        }
        
        void LoadConfig()
        {
            SetConfig("Promocodes", new List<object> { new Promocode("oxide.usergroup add {steamid} vip") });

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        #endregion

        #region Commands

        [ChatCommand("redeem")]
        void cmdRedeem(BasePlayer player, string cmd, string[] args)
        {
            if(args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /redeem <code>");
                return;
            }

            if(Promocode.Get(args[0]) == null)
            {
                SendChatMessage(player, GetMsg("Invalid Code", player.userID));
                return;
            }

            Promocode.Redeem(args[0], player);
            SendChatMessage(player, GetMsg("Code Redeemed", player.userID));

            Puts($"{player.displayName} has redeemed the code {args[0]}");

            SaveConfig();
        }

        #endregion

        #region General Methods

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        static T TryConvert<S, T>(S source, T converted)
        {
            try
            {
                return (T) Convert.ChangeType(source, typeof(T));
            }
            catch(Exception)
            {
                return default(T);
            }
        }

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Chat Related
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        #endregion
    }
}


// --- End of file: Promocodes.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EasyTeams.cs ---
// --- Original Local Path: EasyTeams.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins {
	[Info("EasyTeams", "Skrallex", "1.1.2")]
    [Description("Easily create minigame/pvp teams")]
    class EasyTeams : RustPlugin {
    	const string configVersion = "3";

    	[PluginReference]
    	static Plugin Kits;

        List<EventSettings> eventSettings = new List<EventSettings>();
    	StoredData data;

    	// Config Options
    	bool UsePermissionsOnly = false;

    	// Permissions
    	const string adminPerm = "easyteams.admin";
    	const string editPerm = "easyteams.edit";
    	const string viewPerm = "easyteams.view";
    	const string startPerm = "easyteams.start";
    	const string stopPerm = "easyteams.stop";
    	const string joinPerm = "easyteams.join";
    	const string joinSpecificPerm = "easyteams.joinSpecific";
    	const string claimPerm = "easyteams.claim";

    	public static Event teamEvent = new Event();
		System.Random rnd = new System.Random();

    	void Loaded() {
            // Load event settings file.
            data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("EasyTeamsData");
            if(data.eventSettings != null) {
                eventSettings = data.eventSettings;
            }

    		// Register permissions.
    		permission.RegisterPermission(adminPerm, this);
    		permission.RegisterPermission(editPerm, this);
    		permission.RegisterPermission(viewPerm, this);
    		permission.RegisterPermission(startPerm, this);
    		permission.RegisterPermission(stopPerm, this);
    		permission.RegisterPermission(joinPerm, this);
    		permission.RegisterPermission(joinSpecificPerm, this);
    		permission.RegisterPermission(claimPerm, this);

    		// Load config and localisations.
    		LoadDefaultMessages();
    		if(!GetConfigVersion().Equals(configVersion)) {
    			LoadDefaultConfig();
    		}
    		LoadConfig();
    	}

    	void Unload() {
    		if(teamEvent.started) {
    			StopEvent(null);
    		}
    	}

    	protected override void LoadDefaultConfig() {
    		Puts("Generating default config file");
    		Config.Clear();
    		Config["ConfigVersion"] = configVersion;
    		Config["UsePermissionsOnly"] = false;
    		SaveConfig();
    	}

    	string GetConfigVersion() {
    		return (string)Config["ConfigVersion"] == null ? "" : (string)Config["ConfigVersion"];
    	}

    	void LoadConfig() {
    		UsePermissionsOnly = (bool)Config["UsePermissionsOnly"] == null ? false :(bool)Config["UsePermissionsOnly"];
    	}

    	void LoadDefaultMessages() {
    		lang.RegisterMessages(new Dictionary<string, string> {
    			{"Prefix", "<color=orange>EasyTeams</color>"},
    			{"NoPermission", "You do not have permission to use this command."},
    			{"NoKits", "The <color=red>Kits</color> plugin is not installed or an invalid version is in use!"},
    			{"NoKitExists", "No kit with that name exists. Try a different name."},
    			{"KitSet", "You have set the kit for team <color=red>{0}</color> to '<color=red>{1}</color>'."},

    			{"SaveSyntax", "Invalid command syntax. Try <color=cyan>/teams_save</color> <color=red>EventName</color>"},
    			{"LoadSyntax", "Invalid command syntax. Try <color=cyan>/teams_load</color> <color=red>EventName</color>, or <color=cyan>/teams_load</color> to view available events."},
    			{"CreateSyntax", "Invalid command syntax. Try <color=cyan>/teams_create</color> <color=red>TeamName</color>"},
    			{"DeleteSyntax", "Invalid command syntax. Try <color=cyan>/teams_delete</color> <color=red>TeamName</color>"},
    			{"AddSyntax", "Invalid command syntax. Try <color=cyan>/teams_add</color> <color=red>TeamName Player1Name Player2Name Player3Name ...</color>"},
    			{"RemoveSyntax", "Invalid command syntax. Try <color=cyan>/teams_remove</color> <color=red>TeamName Player1Name Player2Name Player3Name ...</color>"},
    			{"ViewSyntax", "Invalid command syntax. Try <color=cyan>/teams_view</color> <color=red>{Optional: TeamName}</color>"},
    			{"JoinSyntax", "Invalid command syntax. Try <color=cyan>/teams_join</color> <color=red>TeamName</color> to join a specific team, or <color=cyan>/teams_join</color> to join a random team."},
				{"SpectateSyntax", "Invalid command syntax. Try <color=cyan>/teams_spectate> <color=red>True/False</color>."},
    			{"SetSpawnSyntax", "Invalid command syntax. Try <color=cyan>/teams_setspawn</color> <color=red>TeamName</color> to set the teams spawn point to your position."},
				{"SetKitSyntax", "Invalid command syntax. Try ."},

    			{"TeamAlreadyExists", "That team already exists! Try a different name."},
    			{"NoTeamExists", "There is no team with that name. Try a different name."},
    			{"NoTeams", "There are no teams currently setup. Use <color=cyan>/teams_create</color> <color=red>TeamName</color>"},
    			{"ManyPlayersFound", "More than one player name was found to match <color=red>{0}</color>. Please be more specific."},
    			{"NoPlayersFound", "No players were found matching the name <color=red>{0}</color>. Please try again."},
    			{"PlayerOnOtherTeam", "Player <color=red>{0}</color> is already on team <color=red>{1}</color>! Moving them to team <color=red>{2}</color>."},
    			{"PlayerAlreadyOnTeam", "Player <color=red>{0}</color> is already on that team!"},
    			{"PlayerNotOnAnyTeam", "Player <color=red>{0}</color> is not on any team."},
    			{"PlayerNotOnTeam", "Player <color=red>{0}</color> is not on team <color=red>{1}</color>."},
    			{"CantJoinAnother", "You can't join a different team when an event is started!"},
				{"TeamFull", "The team you're trying to join is already full. Try joining another."},
				{"NoJoinableTeams", "There doesn't appear to be any joinable teams at the moment. Wait for someone to leave or ask the event coordinator."},
    			{"NotInEvent", "You can't leave the event because you're not in it yet!"},
    			{"EventLeft", "You have left the event!"},

    			{"SaveExists", "An EventSettings with that name already exists. Overwriting."},
    			{"NoSaveExists", "Could not find an EventSettings with that name. Try a different name."},
    			{"EventSaved", "Successfully saved the event settings as '<color=red>{0}</color>'."},
    			{"EventLoaded", "Successfully loaded the event settings '<color=red>{0}</color>'."},
				{"EventsReloaded", "Successfully reloaded the event settings."},
    			{"NoEventsToLoad", "There are no saved events to load."},
    			{"ListEventsHeading", "The saved events are:"},
    			{"ListEventsEntry", "\n\t=> '<color=red>{0}</color>' (<color=red>{1}</color> teams)."},

    			{"TeamCreated", "You added team <color=red>{0}</color> as a new team!"},
    			{"TeamDeleted", "You deleted team <color=red>{0}</color>!"},
    			{"PlayerAdded", "You added player <color=red>{0}</color> to team <color=red>{1}</color>."},
    			{"PlayerRemoved", "You removed player <color=red>{0}</color> from team <color=red>{1}</color>!"},
    			{"TeamsCleared", "You have cleared all teams!"},
				{"SpectateSet", "You have set the use of the spectate team to <color=red>{0}</color>."},
    			{"SpawnSet", "You have set the spawn point for team <color=red>{0}</color> to your current position."},
    			{"SpawnsNotSet", "You have not yet setup spawns for team <color=red>{0}</color>!"},

				{"JoinNotAllowed", "You are not allowed to join this event! You must be added manually."},
				{"JIPNotAllowed", "The event has already started and you cannot join in progress."},
				{"JoinSpecificNotAllowed", "You are not allowed to specify a team to join for this event. Try /teams_join to join a random team."},
				{"JIPSpecificNotAllowed", "You are not allowed to specify a team to join after the event has started. Try /teams_join to join a random team."},
				{"NothingToClaim", "There are no event rewards/items for you to claim!"},
				{"EventItemsClaimed", "You have claimed your event rewards/items!"},

    			{"AlreadyStarted", "An event is already underway. Use '/teams_stop' first."},
    			{"NotStarted", "There is no event currently underway. Use '/teams_start' to start one."},
    			{"NotifyPlayer", "An event is starting! You are on team <color=red>{0}</color>. Your team has <color=red>{1}</color> lives remaining."},
    			{"EventEnded", "The event has now ended. Thanks for playing!"},
    			{"EventStarted", "You have started the event! Use <color=cyan>/teams_stop</color> to stop the event."},
    			{"EventStopped", "You have stopped the event!"},
    			{"TeamWon", "Team <color=red>{0}</color> has won the event! They had <color=red>{1}</color> lives remaining."},

    			{"ViewEvent", "Event Settings:\n\t Number of Teams: <color=red>{0}</color>\n\t Event Started: {1}\n\t Spectate Team Enabled: {2}" +
					"\n\t Player Join: {3}\n\t Player Join Specific Team: {4}\n\t Join In Progress: {5}" +
					"\n\t Join Specific Team In Progress: {6}\n\t Auto Balance Teams On Join: {7}\n\t Allow Team Switching: {8}\n\t End When Single Team Remaining: {9}" +
					"\n\t RestartWhenSingleTeamRemaining: {10}\n\t Keep Event Inventory As Reward: {11}\n\t Allow Reward Claiming: {12}\n\t Round Restart Timer: {13}s" +
					"\n\t Number of Top Teams: {14}\n\t Top Team Reward Kits: {15}"},
                {"ViewTeam", "Team Settings:\n\t Name: {0}\n\t Kit: {1}\n\t Lives Remaining: {2}/{3}\n\t Spawn Set: {4}{5}\n\t Joinable: {6}\n\t Max Players: {7}\n\t Players: {8}"},
                {"ViewPlayer", "\n\t\t=> <color=red>{0}</color>"},

                {"HelpText1", ""},
            	{"HelpText2", ""}
    			}, this);
    	}

   