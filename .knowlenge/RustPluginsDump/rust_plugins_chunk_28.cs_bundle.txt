 	void OnPlayerRespawned(BasePlayer player) {
    		if(!teamEvent.started)
    			return;
    		if(player == null)
    			return;
    		if(teamEvent.GetPlayersTeam(player) == null)
    			return;

    		Team team = teamEvent.GetPlayersTeam(player);
    		TeamPlayer tPlayer = teamEvent.GetTeamPlayer(player);
    		tPlayer.SaveItems(tPlayer.eventItems);

    		if(team.teamLives == -1) {
    			tPlayer.MoveToEvent(teamEvent, team, 1);
    			return;
    		}
    		if(team.usedLives < team.teamLives) {
    			team.usedLives++;
    			tPlayer.MoveToEvent(teamEvent, team, 1);
    			return;
    		}
    		if(teamEvent.spectateTeamEnabled) {
    			if(teamEvent.GetTeamByName("spectate") != null) {
    				Team spectate = teamEvent.GetTeamByName("spectate");
    				team.players.Remove(tPlayer);
    				spectate.players.Add(tPlayer);
    				tPlayer.MoveToEvent(teamEvent, spectate, 1);
    				return;
    			}
    		}
    	}

    	void OnEntityTakeDamage(BaseEntity entity, HitInfo info) {
    		if((entity as BasePlayer) == null) {
    			return;
    		}
    		BasePlayer target = entity as BasePlayer;
    		if(teamEvent.GetTeamPlayer(target) == null) {
    			return;
    		}
    		TeamPlayer tPlayer = teamEvent.GetTeamPlayer(target);
    		Team team = teamEvent.GetPlayersTeam(target);
    		if(team.usedLives == team.teamLives && !target.IsSleeping()) {
    			tPlayer.SaveItems(tPlayer.eventItems);
    		}
    	}

    	void OnPlayerDisconnected(BasePlayer player, string reason) {
    		if(teamEvent.GetPlayersTeam(player) == null)
    			return;
    		Team team = teamEvent.GetPlayersTeam(player);
    		RemovePlayer(player, team.name, player);
    	}

    	[ChatCommand("teams")]
    	void chatCmdTeams(BasePlayer player, string cmd, string[] args) {
			if(args.Length < 1) {
				ReplyPlayer(player, "HelpText1");
				ReplyPlayer(player, "HelpText2");
			}
    	}

    	[ChatCommand("teams_save")]
    	void chatCmdTeamsSave(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length != 1) {
    			ReplyPlayer(player, "SaveSyntax");
    			return;
    		}
    		if(teamEvent.teams.Count < 1) {
    			ReplyPlayer(player, "NoTeams");
    			return;
    		}
    		if(GetEventSettingsByName(args[0]) != null) {
    			ReplyPlayer(player, "SaveExists");
    			EventSettings e = GetEventSettingsByName(args[0]);
    			eventSettings.Remove(e);
    		}
    		EventSettings e1 = new EventSettings(teamEvent, args[0]);
    		eventSettings.Add(e1);
    		SaveEventSettings();
    		ReplyFormatted(player, String.Format(Lang("EventSaved"), e1.eventName));
    	}

    	[ChatCommand("teams_load")]
    	void chatCmdTeamsLoad(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length == 0) {
    			ListEvents(player);
    			return;
    		}
    		if(args.Length != 1) {
    			ReplyPlayer(player, "LoadSyntax");
    			return;
    		}
    		if(GetEventSettingsByName(args[0]) == null) {
    			ReplyPlayer(player, "NoSaveExists");
    			return;
    		}
    		Event e = GetEventByName(args[0]);
    		teamEvent = e;
    		ReplyFormatted(player, String.Format(Lang("EventLoaded"), args[0]));
    	}

    	void ListEvents(BasePlayer player) {
    		if(eventSettings.Count < 1) {
    			ReplyPlayer(player, "NoEventsToLoad");
				return;
    		}
    		string reply = Lang("ListEventsHeading");
    		foreach(EventSettings settings in eventSettings) {
    			reply += String.Format(Lang("ListEventsEntry"), settings.eventName, settings.teams.Count);
    		}
    		ReplyFormatted(player, reply);
    	}

		[ChatCommand("teams_reload")]
		void chatCmdTeamsReload(BasePlayer player, string cmd, string[] args) {
			if(!IsAllowed(player, editPerm)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
			Reload(player);
		}

		void Reload(BasePlayer player) {
			data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("EasyTeamsData");
			if(data.eventSettings != null) {
				eventSettings = data.eventSettings;
			}
			ReplyPlayer(player, "EventsReloaded");
		}

    	[ChatCommand("teams_create")]
    	void chatCmdTeamsCreate(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length != 1) {
    			ReplyPlayer(player, "CreateSyntax");
    			return;
    		}
    		CreateTeam(player, args[0]);
    	}

    	void CreateTeam(BasePlayer player, string teamName) {
    		if(teamEvent.GetTeamByName(teamName) != null) {
    			ReplyPlayer(player, "TeamAlreadyExists");
    			return;
    		}
    		Team team = new Team();
    		team.name = teamName;
    		team.teamLives = -1;
    		teamEvent.teams.Add(team);
    		ReplyFormatted(player, String.Format(Lang("TeamCreated"), team.name));
    	}

    	[ChatCommand("teams_delete")]
    	void chatCmdTeamsDelete(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length != 1) {
    			ReplyPlayer(player, "DeleteSyntax");
    			return;
    		}
    		DeleteTeam(player, args[0]);
    	}

    	void DeleteTeam(BasePlayer player, string teamName) {
    		if(teamEvent.GetTeamByName(teamName) == null) {
    			ReplyPlayer(player, "NoTeamExists");
    			return;
    		}
    		Team team = teamEvent.GetTeamByName(teamName);
    		teamEvent.teams.Remove(team);
    		ReplyFormatted(player, String.Format(Lang("TeamDeleted"), team.name));
    	}

    	[ChatCommand("teams_add")]
    	void chatCmdTeamsAdd(BasePlayer player, string cmd, string[] args){
    		List<string> players = new List<string>();
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length < 2) {
    			ReplyPlayer(player, "AddSyntax");
    			return;
    		}
    		for(int i = 1; i < args.Length; i++) {
    			if(GetPlayersByName(args[i]).Count > 1) {
    				ReplyFormatted(player, String.Format(Lang("ManyPlayersFound"), args[i]));
    				return;
    			}
    			if(GetPlayersByName(args[i]).Count == 0) {
    				ReplyFormatted(player, String.Format(Lang("NoPlayersFound"), args[i]));
    				return;
    			}
    			players.Add(args[i]);
    		}
    		AddPlayers(player, args[0], players.ToArray());
    	}

    	void AddPlayers(BasePlayer player, string teamName, string[] players) {
    		foreach(string name in players) {
    			AddPlayer(player, teamName, name);
    		}
    	}

    	void AddPlayer(BasePlayer player, string teamName, string playerName) {
    		if(teamEvent.GetTeamByName(teamName) == null) {
    			ReplyPlayer(player, "NoTeamExists");
    			return;
    		}

    		Team team = teamEvent.GetTeamByName(teamName);
    		BasePlayer target = GetPlayersByName(playerName)[0];
    		if(teamEvent.GetPlayersTeam(target) != null) {
    			Team currentTeam = teamEvent.GetPlayersTeam(target);
    			if(currentTeam == team) {
    				ReplyFormatted(player, String.Format(Lang("PlayerAlreadyOnTeam"), target.displayName));
    				return;
    			}
    			ReplyFormatted(player, String.Format(Lang("PlayerOnOtherTeam"), target.displayName, currentTeam.name, team.name));
    			RemovePlayer(player, currentTeam.name, playerName);
    		}
    		TeamPlayer tPlayer = new TeamPlayer();
    		tPlayer.player = target;
    		team.players.Add(tPlayer);
    		ReplyFormatted(player, String.Format(Lang("PlayerAdded"), target.displayName, team.name));
    		if(teamEvent.started) {
				if(!tPlayer.itemsSaved) {
					tPlayer.MoveToEventAndSave(teamEvent, team);
					return;
				}
    			tPlayer.MoveToEventAndSave(teamEvent, team);
    		}
    	}

    	[ChatCommand("teams_remove")]
    	void chatCmdTeamsRemove(BasePlayer player, string cmd, string[] args) {
    		List<string> players = new List<string>();
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length < 2) {
    			ReplyPlayer(player, "RemoveSyntax");
    			return;
    		}
    		for(int i = 1; i < args.Length; i++) {
    			if(GetPlayersByName(args[i]).Count > 1) {
    				ReplyFormatted(player, String.Format(Lang("ManyPlayersFound"), args[i]));
    				return;
    			}
    			if(GetPlayersByName(args[i]).Count == 0) {
    				ReplyFormatted(player, String.Format(Lang("NoPlayersFound"), args[i]));
    				return;
    			}
    			players.Add(args[i]);
    		}
    		RemovePlayers(player, args[0], players.ToArray());
    	}

    	void RemovePlayers(BasePlayer player, string teamName, string[] players) {
    		foreach(string name in players) {
    			RemovePlayer(player, teamName, name);
    		}
    	}

    	void RemovePlayer(BasePlayer player, string teamName, BasePlayer target) {
    		if(teamEvent.GetTeamByName(teamName) == null) {
    			ReplyPlayer(player, "NoTeamExists");
    			return;
    		}
    		Team team = teamEvent.GetTeamByName(teamName);
    		if(teamEvent.GetPlayersTeam(target) == null) {
    			ReplyPlayer(player, "PlayerNotOnAnyTeam");
    			return;
    		}
    		if(teamEvent.GetPlayersTeam(target) != team) {
    			ReplyFormatted(player, String.Format(Lang("PlayerNotOnTeam"), target.displayName, team.name));
    			return;
    		}
    		TeamPlayer tPlayer = teamEvent.GetTeamPlayer(target);
			if(teamEvent.started) {
				tPlayer.MoveFromEvent(teamEvent);
			}
    		team.players.Remove(tPlayer);
    		ReplyFormatted(player, String.Format(Lang("PlayerRemoved"), target.displayName, team.name));
    	}

    	void RemovePlayer(BasePlayer player, string teamName, string playerName) {
    		BasePlayer target = GetPlayersByName(playerName)[0];
    		RemovePlayer(player, teamName, target);
    	}

    	[ChatCommand("teams_view")]
    	void chatCmdTeamsView(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, viewPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length == 0) {
    			ViewAll(player);
    			return;
    		}
    		if(args.Length == 1) {
    			View(player, args[0]);
    			return;
    		}
    		ReplyPlayer(player, "ViewSyntax");
    	}

    	void ViewAll(BasePlayer player) {
    		if(teamEvent.teams.Count == 0) {
    			ReplyPlayer(player, "NoTeams");
    			return;
    		}
			string topTeamKits = "";
			foreach(string kit in teamEvent.topTeamRewardKits) {
				topTeamKits += kit;
			}
			string reply = String.Format(Lang("ViewEvent"), teamEvent.teams.Count, teamEvent.started, teamEvent.spectateTeamEnabled, teamEvent.allowPlayersJoin,
							teamEvent.allowPlayersJoinSpecificTeam, teamEvent.joinInProgress, teamEvent.joinSpecificTeamInProgress, teamEvent.autoBalanceTeamsOnJoin,
							teamEvent.allowTeamSwitching, teamEvent.endWhenSingleTeamRemaining, teamEvent.restartWhenSingleTeamRemaining, teamEvent.keepEventInventoryAsReward,
							teamEvent.allowRewardClaiming, teamEvent.roundRestartTimer, teamEvent.numberOfTopTeams, topTeamKits);
    		ReplyFormatted(player, reply);
    		foreach(Team team in teamEvent.teams) {
    			View(player, team.name);
    		}
    	}

    	void View(BasePlayer player, string teamName) {
    		if(teamEvent.GetTeamByName(teamName) == null) {
    			ReplyPlayer(player, "NoTeamExists");
    			return;
    		}
    		Team team = teamEvent.GetTeamByName(teamName);
			string spawnPos = "";
			if(team.spawnSet) {
				spawnPos = " (" + Math.Round(team.spawnPos.x, 1) + ", " + Math.Round(team.spawnPos.y, 1) + ", " + Math.Round(team.spawnPos.z, 1) + ")";
			}
    		string reply = String.Format(Lang("ViewTeam"), team.name, team.kitname, team.teamLives - team.usedLives, team.teamLives, team.spawnSet, spawnPos, team.joinable, team.maxPlayers, team.players.Count);

    		foreach(TeamPlayer tPlayer in team.players) {
    			reply += String.Format(Lang("ViewPlayer"), tPlayer.player.displayName);
    		}
    		ReplyFormatted(player, reply);
    	}

    	[ChatCommand("teams_clear")]
    	void chatCmdTeamsClear(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		Clear(player);
    	}

    	void Clear(BasePlayer player) {
    		teamEvent = new Event();
    		ReplyPlayer(player, "TeamsCleared");
    	}

    	[ChatCommand("teams_start")]
    	void chatCmdTeamsStart(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, startPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		StartEvent(player);
    	}

    	void StartEvent(BasePlayer player) {
    		if(teamEvent.started) {
    			ReplyPlayer(player, "AlreadyStarted");
    			return;
    		}
    		if(teamEvent.teams.Count == 0) {
    			ReplyPlayer(player, "NoTeams");
    			return;
    		}
    		foreach(Team team in teamEvent.teams) {
    			if(!team.spawnSet) {
    				ReplyFormatted(player, String.Format(Lang("SpawnsNotSet"), team.name));
    				return;
    			}
    		}
    		foreach(Team team in teamEvent.teams) {
    			int i = 0;
    			foreach(TeamPlayer tPlayer in team.players) {
    				tPlayer.MoveToEventAndSave(teamEvent, team, i);
    				i++;
    			}
    		}
    		teamEvent.started = true;
    		ReplyPlayer(player, "EventStarted");
    	}

		[ChatCommand("teams_end")]
		void chatCmdTeamsEnd(BasePlayer player, string cmd, string[] args) {

		}

    	[ChatCommand("teams_stop")]
    	void chatCmdTeamsStop(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, stopPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		StopEvent(player);
    	}

    	void StopEvent(BasePlayer player) {
    		if(!teamEvent.started) {
    			ReplyPlayer(player, "NotStarted");
    			return;
    		}
    		foreach(Team team in teamEvent.teams) {
    			foreach(TeamPlayer tPlayer in team.players) {
    				tPlayer.MoveFromEvent(teamEvent);
    			}
    		}

    		teamEvent.started = false;
    		ReplyPlayer(player, "EventStopped");
    	}

		[ChatCommand("teams_restart")]
		void chatCmdTeamsRestart(BasePlayer player, string cmd, string[] args) {
			if(!IsAllowed(player, startPerm)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
			RestartEvent(player);
		}

		void RestartEvent(BasePlayer player) {
			if(!teamEvent.started) {
				ReplyPlayer(player, "NotStarted");
				return;
			}
			foreach(Team team in teamEvent.teams) {
				foreach(TeamPlayer tPlayer in team.players) {
					tPlayer.MoveToEvent(teamEvent, team);
				}
			}
			ReplyPlayer(player, "EventRestarted");
		}

    	[ChatCommand("teams_join")]
    	void chatCmdTeamsJoin(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, joinPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
			if(!teamEvent.allowPlayersJoin) {
				ReplyPlayer(player, "JoinNotAllowed");
				return;
			}
			if(teamEvent.started && !teamEvent.joinInProgress) {
				ReplyPlayer(player, "JIPNotAllowed");
				return;
			}
			if(teamEvent.GetPlayersTeam(player) != null && !teamEvent.allowTeamSwitching) {
				ReplyPlayer(player, "CantJoinAnother");
				return;
			}
			if(args.Length > 0) {
				if(!teamEvent.allowPlayersJoinSpecificTeam) {
					ReplyPlayer(player, "JoinSpecificNotAllowed");
					return;
				}
				if(teamEvent.started && !teamEvent.joinSpecificTeamInProgress) {
					ReplyPlayer(player, "JIPSpecificNotAllowed");
					return;
				}
				JoinTeam(player, args[0]);
				return;
			}
			JoinRandomTeam(player);
			return;
    	}

    	void JoinRandomTeam(BasePlayer player) {
    		string teamName = "";
    		int leastPlayers = 1000;

			if(!teamEvent.autoBalanceTeamsOnJoin) {
				int i = rnd.Next(0, teamEvent.teams.Count);
				Puts("i = " + i);
				foreach(Team team in teamEvent.teams) {
					Puts("testing for team " + team.name);
					if(team == teamEvent.teams.ElementAt(i)) {
						if(team.name.Equals("spectate")) {
							i = rnd.Next(0, teamEvent.teams.Count);
							continue;
						}
						if(!team.joinable) {
							i = rnd.Next(0, teamEvent.teams.Count);
							continue;
						}
						if(team.players.Count >= team.maxPlayers && team.maxPlayers != -1) {
							i = rnd.Next(0, teamEvent.teams.Count);
							continue;
						}
						teamName = team.name;
					}
				}
				if(teamName == "") {
					ReplyPlayer(player, "NoJoinableTeams");
					return;
				}
			}
			else {
				foreach(Team team in teamEvent.teams) {
					if(team.name.Equals("spectate")){
						continue;
					}
					if(!team.joinable)
						continue;
					if(team.players.Count >= team.maxPlayers)
						continue;
					if(team.players.Count < leastPlayers) {
						teamName = team.name;
						leastPlayers = team.players.Count;
					}
				}
			}
            JoinTeam(player, teamName);
    	}

    	void JoinTeam(BasePlayer player, string teamName) {
    		if(teamEvent.GetTeamByName(teamName) == null) {
    			ReplyPlayer(player, "NoTeamExists");
    			return;
    		}
			Team team = teamEvent.GetTeamByName(teamName);
			if(team.players.Count >= team.maxPlayers && team.maxPlayers != -1) {
				ReplyPlayer(player, "TeamFull");
				return;
			}
    		AddPlayer(player, teamName, player.displayName);
    	}

    	[ChatCommand("teams_leave")]
    	void chatCmdTeamsLeave(BasePlayer player, string cmd, string[] args) {
    		Leave(player);
    	}

    	void Leave(BasePlayer player) {
    		if(teamEvent.GetTeamPlayer(player) == null) {
    			ReplyPlayer(player, "NotInEvent");
    			return;
    		}
    		TeamPlayer tPlayer = teamEvent.GetTeamPlayer(player);
    		Team team = teamEvent.GetPlayersTeam(player);
			if(teamEvent.started)
    			tPlayer.MoveFromEvent(teamEvent);
    		RemovePlayer(player, team.name, player);
    		ReplyPlayer(player, "EventLeft");
    	}

    	[ChatCommand("teams_claim")]
    	void chatCmdTeamsClaim(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, claimPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		Claim(player);
    	}

    	void Claim(BasePlayer player) {
    		if(teamEvent.GetTeamPlayer(player) == null) {
    			ReplyPlayer(player, "NotInEvent");
    			return;
    		}
    		TeamPlayer tPlayer = teamEvent.GetTeamPlayer(player);
    		if(tPlayer.eventItems.Count == 0) {
    			ReplyPlayer(player, "NothingToClaim");
    			return;
    		}
    		tPlayer.RestoreEventItems();
    		ReplyPlayer(player, "EventItemsClaimed");
    	}

		[ChatCommand("teams_spectate")]
		void chatCmdTeamsSpectate(BasePlayer player, string cmd, string[] args) {
			bool option;
			if(!IsAllowed(player, editPerm)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
			if(args.Length != 1) {
				ReplyPlayer(player, "SpectateSyntax");
				return;
			}
			if(!Boolean.TryParse(args[0], out option)) {
				ReplyPlayer(player, "SpectateSyntax");
				return;
			}
			Boolean.TryParse(args[0], out option);
			Spectate(player, option);
		}

		void Spectate(BasePlayer player, bool enabled) {
			teamEvent.spectateTeamEnabled = enabled;
			ReplyFormatted(player, String.Format(Lang("SpectateSet"), enabled));

			if(enabled) {
				if(teamEvent.GetTeamByName("spectate") == null) {
					CreateTeam(player, "spectate");
				}
				return;
			}
			DeleteTeam(player, "spectate");
		}

    	[ChatCommand("teams_setspawn")]
    	void chatCmdTeamsSetSpawn(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length != 1) {
    			ReplyPlayer(player, "SetSpawnSyntax");
    			return;
    		}
    		SetSpawn(player, args[0]);
    	}

    	void SetSpawn(BasePlayer player, string teamName) {
    		if(teamEvent.GetTeamByName(teamName) == null) {
    			ReplyPlayer(player, "NoTeamExists");
    			return;
    		}
    		Team team = teamEvent.GetTeamByName(teamName);
    		Pos playerPos = new Pos(player.transform.position);
    		team.SetSpawnPos(playerPos);
    		ReplyFormatted(player, String.Format(Lang("SpawnSet"), team.name));
    	}

    	[ChatCommand("teams_setkit")]
    	void chatCmdTeamsSetKit(BasePlayer player, string cmd, string[] args) {
    		if(!IsAllowed(player, editPerm)) {
    			ReplyPlayer(player, "NoPermission");
    			return;
    		}
    		if(args.Length != 2) {
    			ReplyPlayer(player, "SetKitSyntax");
    			return;
    		}
    		SetKit(player, args[0], args[1]);
    	}

    	void SetKit(BasePlayer player, string teamName, string kitName) {
    		if(teamEvent.GetTeamByName(teamName) == null) {
    			ReplyPlayer(player, "NoTeamExists");
    			return;
    		}
    		Team team = teamEvent.GetTeamByName(teamName);
    		object success = Interface.Oxide.CallHook("isKit", kitName);
    		if(!(success is bool)) {
    			ReplyPlayer(player, "NoKits");
    			return;
    		}
    		if(!(bool)success) {
    			ReplyPlayer(player, "NoKitExists");
    			return;
    		}
    		team.kitname = kitName;
    		ReplyFormatted(player, String.Format(Lang("KitSet"), team.name, team.kitname));
    	}

		Event GetTeamEvent() {
			return teamEvent;
		}

    	void ReplyPlayer(BasePlayer player, string langKey) {
    		SendReply(player, Lang("Prefix") + ": " + Lang(langKey));
    	}

        void ReplyFormatted(BasePlayer player, string msg) {
    		SendReply(player, Lang("Prefix") + ": " + msg);
    	}

        string Lang(string key) {
    		return lang.GetMessage(key, this, null);
    	}

    	bool IsAllowed(BasePlayer player, string perm) {
    		if(player.IsAdmin() && !UsePermissionsOnly) return true;
    		if(permission.UserHasPermission(player.UserIDString, adminPerm)) return true;
    		if(permission.UserHasPermission(player.UserIDString, perm)) return true;
    		return false;
    	}

    	List<BasePlayer> GetPlayersByName(string playerName) {
    		List<BasePlayer> foundPlayers = new List<BasePlayer>();
    		foreach(BasePlayer activePlayer in BasePlayer.activePlayerList) {
    			if(activePlayer.displayName.ToLower().Contains(playerName.ToLower()))
    				foundPlayers.Add(activePlayer);
    		}
    		return foundPlayers;
    	}

        EventSettings GetEventSettingsByName(string eventName) {
            foreach(EventSettings e in eventSettings) {
                if(e.eventName.ToLower().Equals(eventName.ToLower()))
                    return e;
            }
            return null;
        }

        Event GetEventByName(string eventName) {
        	if(GetEventSettingsByName(eventName) != null) {
        		EventSettings settings = GetEventSettingsByName(eventName);
        		Event e = new Event(settings);
        		return e;
        	}

            return null;
        }

    	void SaveEventSettings() {
            if(eventSettings != null) {
                data.eventSettings = eventSettings;
            }
            Interface.Oxide.DataFileSystem.WriteObject("EasyTeamsData", data);
    	}

	   	public class Team {
	   		public string name = "";
	   		public string kitname = "";
	   		public int teamLives = -1, usedLives = 0;
			public int maxPlayers = -1;
	   		public Pos spawnPos = new Pos(0.0f, 0.0f, 0.0f);
	   		public bool spawnSet = false;
	   		public bool joinable = true;
	   		public List<TeamPlayer> players = new List<TeamPlayer>();

	   		public void SetSpawnPos(Pos pos) {
	   			this.spawnPos = pos;
	   			this.spawnSet = true;
	   		}
	    }

	    public class TeamPlayer {
	    	public BasePlayer player;
	    	public float health, hydration, calories, bleeding;
	    	public Pos homePos;
	    	public Team team;
			public bool itemsSaved = false;
	    	public List<InvItem> items = new List<InvItem>();
	    	public List<InvItem> kitItems = new List<InvItem>();
	    	public List<InvItem> eventItems = new List<InvItem>();

	    	public void SaveHealth() {
	    		health = player.health;
	    		hydration = player.metabolism.hydration.value;
	    		calories = player.metabolism.calories.value;
	    		bleeding = player.metabolism.bleeding.value;
	    	}

	    	public void SavePos() {
	    		homePos = new Pos(player.transform.position);
	    	}

	    	public void SaveItems(List<InvItem> itemList) {
	    		itemList.Clear();
	    		itemList.AddRange(GetItems(player.inventory.containerWear, "wear"));
	    		itemList.AddRange(GetItems(player.inventory.containerMain, "main"));
	    		itemList.AddRange(GetItems(player.inventory.containerBelt, "belt"));
				if(itemList == items)
					itemsSaved = true;
	    	}

	    	public void RestoreHealth() {
	    		player.InitializeHealth(health, 100);
	    		player.metabolism.hydration.value = hydration;
	    		player.metabolism.calories.value = calories;
	    		player.metabolism.bleeding.value = bleeding;
	    	}

	    	public void RestorePos() {
	    		TeleportTo(homePos);
	    	}

			public void RestoreItems(List<InvItem> itemList, bool strip = true) {
	    		if(strip)
	    			player.inventory.Strip();
            	foreach (var invItem in itemList) {
          			var item = ItemManager.CreateByItemID(invItem.itemId, invItem.amount, invItem.skin);
					item.condition = invItem.condition;
				    var weapon = item.GetHeldEntity() as BaseProjectile;
				    if (weapon != null)
						weapon.primaryMagazine.contents = invItem.ammo;
				    if (invItem.container == "belt")
				        player.inventory.GiveItem(item, player.inventory.containerBelt);
				    if (invItem.container == "main")
				        player.inventory.GiveItem(item, player.inventory.containerMain);
				    if (invItem.container == "wear")
				        player.inventory.GiveItem(item, player.inventory.containerWear);
				    if (invItem.contents == null)
				        continue;
				    foreach (var invItemCont in invItem.contents) {
				        var item1 = ItemManager.CreateByItemID(invItemCont.itemId, invItemCont.amount);
				        if (item1 == null)
				    		continue;
				        item1.condition = invItemCont.condition;
				        item1.MoveToContainer(item.contents);
          			}
            	}
				if(itemList == items)
					itemsSaved = false;
	    	}

	    	public void RestoreEventItems() {
	    		List<InvItem> gainedItems = new List<InvItem>();
	    		foreach(InvItem eventItem in eventItems) {
	    			gainedItems.Add(eventItem);
	    			foreach(InvItem kitItem in kitItems) {
	    				if(eventItem.itemId == kitItem.itemId && eventItem.skin == kitItem.skin) {
	    					if(kitItem.amount >= eventItem.amount) {
	    						kitItem.amount -= eventItem.amount;
	    						eventItem.amount = 0;
	    					}
	    					if(eventItem.amount > 0) {
	    				    	eventItem.amount -= kitItem.amount;
	    				    	kitItem.amount = 0;
	    					}
	    				}
	    			}
	    			if(eventItem.amount <= 0) {
	    				gainedItems.Remove(eventItem);
	    			}
	    		}
	    		RestoreItems(gainedItems, false);
	    		eventItems = new List<InvItem>();
	    	}

	    	public void Strip() {
	    		player.inventory.Strip();
	    	}

	    	public void Heal() {
	    		player.metabolism.hydration.value = 250;
            	player.metabolism.calories.value = 500;
            	player.metabolism.bleeding.value = 0;
            	player.InitializeHealth(100, 100);
	    	}

	    	public void TeleportTo(Pos pos) {
	    		Vector3 vec3Pos = new Vector3(pos.x, pos.y, pos.z);

	    		if (player.net?.connection != null)
                    player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
                StartSleeping();
                player.MovePosition(vec3Pos);

                if (player.net?.connection != null)
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", vec3Pos);
                player.TransformChanged();

                if (player.net?.connection != null)
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                player.UpdateNetworkGroup();
                player.SendNetworkUpdateImmediate(false);

                if (player.net?.connection == null) return;
                try { player.ClearEntityQueue(null); } catch { }
                player.SendFullSnapshot();
	    	}

	    	public void StartSleeping() {
	    		if (player.IsSleeping())
                    return;

                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
                if (!BasePlayer.sleepingPlayerList.Contains(player))
                    BasePlayer.sleepingPlayerList.Add(player);
                player.CancelInvoke("InventoryUpdate");
	    	}

	    	public void MoveToEventAndSave(Event teamEvent, Team playerTeam, int spawnOffset = 1) {
				team = playerTeam;
				SaveHealth();
				SavePos();
				SaveItems(items);
				MoveToEvent(teamEvent, playerTeam, spawnOffset);
	    	}

	    	public void MoveToEvent(Event teamEvent, Team playerTeam, int spawnOffset = 1) {
				Pos offsetSpawn = new Pos(playerTeam.spawnPos.x + spawnOffset * 0.1f, playerTeam.spawnPos.y + spawnOffset * 0.1f, playerTeam.spawnPos.z + spawnOffset * 0.1f);
				TeleportTo(offsetSpawn);
				Strip();
				Heal();
				Interface.Oxide.CallHook("GiveKit", player, playerTeam.kitname);
				SaveItems(kitItems);
	    	}

	    	public void MoveFromEvent(Event teamEvent) {
	    		if(!teamEvent.GetPlayersTeam(player).name.ToLower().Equals("spectate"))
					SaveItems(eventItems);
				Strip();
				RestorePos();
				RestoreHealth();
				RestoreItems(items);
	    	}

	    	private IEnumerable<InvItem> GetItems(ItemContainer container, string containerName) {
                return container.itemList.Select(item => new InvItem {
                    itemId = item.info.itemid,
                    container = containerName,
                    amount = item.amount,
                    ammo = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.contents ?? 0,
                    skin = item.skin,
                    condition = item.condition,
                    contents = item.contents?.itemList.Select(item1 => new InvItem {
                        itemId = item1.info.itemid,
                        amount = item1.amount,
                        condition = item1.condition
                    }).ToArray()
                });
            }
	    }

	    public class InvItem {
	    	public int itemId, amount, ammo;
			public ulong skin;
	    	public string container;
	    	public float condition;
	    	public InvItem[] contents;
	    }

	    public class Event {
			public bool started = false;
			public bool spectateTeamEnabled = false;
			public bool allowPlayersJoin = false;
			public bool allowPlayersJoinSpecificTeam = false;
			public bool joinInProgress = false;
			public bool joinSpecificTeamInProgress = false;
			public bool autoBalanceTeamsOnJoin = false;
			public bool allowTeamSwitching = false;
			public bool endWhenSingleTeamRemaining = false;
			public bool restartWhenSingleTeamRemaining = false;
			public bool keepEventInventoryAsReward = false;
			public bool allowRewardClaiming = false;

			public int roundRestartTimer = 15;
			public int numberOfTopTeams = 3;
			public List<string> topTeamRewardKits = new List<string>();

	    	public List<Team> teams = new List<Team>();
	    	public Event() {
			}

	    	public Event(EventSettings settings) {
				this.spectateTeamEnabled = settings.spectateTeamEnabled;
				this.allowPlayersJoin = settings.allowPlayersJoin;
				this.allowPlayersJoinSpecificTeam = settings.allowPlayersJoinSpecificTeam;
				this.joinInProgress = settings.joinInProgress;
				this.joinSpecificTeamInProgress = settings.joinSpecificTeamInProgress;
				this.autoBalanceTeamsOnJoin = settings.autoBalanceTeamsOnJoin;
				this.allowTeamSwitching = settings.allowTeamSwitching;
				this.endWhenSingleTeamRemaining = settings.endWhenSingleTeamRemaining;
				this.restartWhenSingleTeamRemaining = settings.restartWhenSingleTeamRemaining;
				this.keepEventInventoryAsReward = settings.keepEventInventoryAsReward;
				this.allowRewardClaiming = settings.allowRewardClaiming;

				this.roundRestartTimer = settings.roundRestartTimer;
				this.numberOfTopTeams = settings.numberOfTopTeams;
				this.topTeamRewardKits = settings.topTeamRewardKits;
	    		this.teams = settings.teams;
	    	}

	    	public Team GetTeamByName(string teamName) {
	    		foreach(Team team in teams) {
	    			if(team.name.ToLower().Equals(teamName.ToLower()))
	    				return team;
	    		}
	    		return null;
	    	}

	    	public Team GetPlayersTeam(BasePlayer player) {
	    		foreach(Team team in teams) {
	    			foreach(TeamPlayer tPlayer in team.players) {
	    				if(tPlayer.player == player) {
	    					return team;
	    				}
	    			}
	    		}
	    		return null;
	    	}

	    	public TeamPlayer GetTeamPlayer(BasePlayer player) {
	    		foreach(Team team in teams) {
	    			foreach(TeamPlayer tPlayer in team.players) {
	    				if(tPlayer.player == player){
	    					return tPlayer;
	    				}
	    			}
	    		}
	    		return null;
	    	}
	    }

	    public class EventSettings {
            public string eventName = "";
			public bool spectateTeamEnabled = false;
			public bool allowPlayersJoin = false;
			public bool allowPlayersJoinSpecificTeam = false;
			public bool joinInProgress = false;
			public bool joinSpecificTeamInProgress = false;
			public bool autoBalanceTeamsOnJoin = false;
			public bool allowTeamSwitching = false;
			public bool endWhenSingleTeamRemaining = false;
			public bool restartWhenSingleTeamRemaining = false;
			public bool keepEventInventoryAsReward = false;
			public bool allowRewardClaiming = false;

			public int roundRestartTimer = 15;
			public int numberOfTopTeams = 3;
			public List<string> topTeamRewardKits = new List<string>();

            public List<Team> teams = new List<Team>();

            public EventSettings(Event teamEvent, string eventName) {
            	this.eventName = eventName;
            	this.spectateTeamEnabled = teamEvent.spectateTeamEnabled;
            	this.allowPlayersJoin = teamEvent.allowPlayersJoin;
            	this.allowPlayersJoinSpecificTeam = teamEvent.allowPlayersJoinSpecificTeam;
            	this.joinInProgress = teamEvent.joinInProgress;
				this.joinSpecificTeamInProgress = teamEvent.joinSpecificTeamInProgress;
				this.autoBalanceTeamsOnJoin = teamEvent.autoBalanceTeamsOnJoin;
				this.allowTeamSwitching = teamEvent.allowTeamSwitching;
				this.endWhenSingleTeamRemaining = teamEvent.endWhenSingleTeamRemaining;
				this.restartWhenSingleTeamRemaining = teamEvent.restartWhenSingleTeamRemaining;
				this.keepEventInventoryAsReward = teamEvent.keepEventInventoryAsReward;
				this.allowRewardClaiming = teamEvent.allowRewardClaiming;

				this.roundRestartTimer = teamEvent.roundRestartTimer;
				this.numberOfTopTeams = teamEvent.numberOfTopTeams;
				this.topTeamRewardKits = teamEvent.topTeamRewardKits;

            	foreach(Team team in teamEvent.teams) {
            		Team emptyTeam = team;
            		emptyTeam.players = new List<TeamPlayer>();
            		teams.Add(emptyTeam);
            	}

				if(numberOfTopTeams > topTeamRewardKits.Count) {
					int diff = numberOfTopTeams - topTeamRewardKits.Count;
					for(int i = 0; i < diff; i++) {
						topTeamRewardKits.Add("");
					}
				}
				if(topTeamRewardKits.Count > numberOfTopTeams) {
					int diff = topTeamRewardKits.Count - numberOfTopTeams;
					for(int i = 0; i < diff; i++) {
						topTeamRewardKits.Remove(topTeamRewardKits.Last());
					}
				}
            }

            public EventSettings() {
			}
	    }

	    public class StoredData {
	    	public List<EventSettings> eventSettings = new List<EventSettings>();
	    }

        [System.Serializable]
	    public class Pos {
	    	public float x, y, z;

	    	public Pos(float x, float y, float z) {
	    		this.x = x;
	    		this.y = y;
	    		this.z = z;
	    	}

	    	public Pos(Vector3 vec3) {
	    		this.x = vec3.x;
	    		this.y = vec3.y;
	    		this.z = vec3.z;
	    	}

	    	public Pos() {}
	    }
    }
}


// --- End of file: EasyTeams.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TurretsExtended.cs ---
// --- Original Local Path: TurretsExtended.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Turrets Extended", "supreme", "3.0.3")]
    [Description("Allows players to toggle on/off the turrets/sam sites without the need of electricity")]
    public class TurretsExtended : RustPlugin
    {
        private readonly Vector3 _turretPos = new Vector3(0f, -0.6f, 0.3f);
        private readonly Vector3 _samPos = new Vector3(0f, -0.6f, -0.92f);
        private readonly Vector3 _npcPos = new Vector3(0f, -0.8f, 0.9f);
        private const string SwitchPrefab = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";
        
        private void OnServerInitialized()
        {
            foreach (var turret in UnityEngine.Object.FindObjectsOfType<ContainerIOEntity>())
            {
                if (turret.OwnerID != 0)
                {
                    AddSwitch(turret);
                    AddSwitchN(turret);
                }
            }
        }

        private void Unload()
        {
            foreach (var turret in UnityEngine.Object.FindObjectsOfType<ContainerIOEntity>())
            {
                var sw = turret.GetComponentInChildren<ElectricSwitch>();
                if (turret.OwnerID != 0)
                { 
                    if (sw != null) 
                    { 
                        sw.SetParent(null); 
                        sw.Kill();
                    }
                }
            }
        }

        private void Toggle(ContainerIOEntity entity)
        {
            if (entity is AutoTurret)
            {
                ToggleTurret(entity as AutoTurret);
            }
            else if (entity is SamSite)
            {
                ToggleSam(entity as SamSite);
            }
        }
        
        private void ToggleTurret(AutoTurret turret)
        {
            if (turret.IsOnline())
            {
                turret.SetIsOnline(false);
            }
            else
            {
                turret.SetIsOnline(true);
            }
            turret.SendNetworkUpdateImmediate();
        }

        private void ToggleSam(SamSite sam)
        {
            if (sam.IsPowered())
            {
                sam.UpdateHasPower(0, 1);
            }
            else
            {
                sam.UpdateHasPower(sam.ConsumptionAmount(), 1);
            }
            sam.SendNetworkUpdateImmediate();
        }
        
        private object CanPickupEntity(BasePlayer player, ElectricSwitch entity)
        {
            if (entity.HasParent())
            {
                return false;
            }
            return null;
        }
        
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (go.name != "assets/prefabs/npc/autoturret/autoturret_deployed.prefab" && go.name != "assets/prefabs/npc/sam_site_turret/sam_site_turret_deployed.prefab") return;
            ContainerIOEntity entity = go.GetComponent<ContainerIOEntity>();
            if (entity == null) return;
            NextTick(() => AddSwitch(entity));
        }
        
        void OnEntitySpawned(NPCAutoTurret entity)
        {
            if (entity.OwnerID == 0) return;
            ContainerIOEntity turret = entity.GetComponent<ContainerIOEntity>();
            if (turret == null) return;
            NextTick(() => AddSwitchN(entity));
        }
        
        private object OnSwitchToggle(ElectricSwitch switchz, BasePlayer player)
        {
            var entity = switchz.GetComponentInParent<ContainerIOEntity>();
            if (!switchz.HasParent()) return null;
            if (entity is AutoTurret)
            {
                var turret = switchz.GetComponentInParent<AutoTurret>();
                var isAuthed = turret.IsAuthed(player);
                if (entity == null || !player.IsBuildingAuthed() || !isAuthed)
                {
                    if (_config.gameTip)
                    {
                        player.SendConsoleCommand("gametip.showgametip", Lang("NoAuth", player.UserIDString));
                        timer.In(_config.gameTipTime, () => player.Command("gametip.hidegametip"));
                    }
                    
                    if (_config.chatMessage)
                    {
                        player.ChatMessage(Lang("NoAuthChat", player.UserIDString));
                    }
                    return true;
                }
            }
            if (entity == null || !player.IsBuildingAuthed())
            {
                if (_config.gameTip)
                {
                    player.SendConsoleCommand("gametip.showgametip", Lang("NoAuth", player.UserIDString));
                    timer.In(_config.gameTipTime, () => player.Command("gametip.hidegametip"));
                }

                if (_config.chatMessage)
                {
                    player.ChatMessage(Lang("NoAuthChat", player.UserIDString));
                }
                return true;
            }
            Toggle(entity);
            return null;
        }

        private void AddSwitchN(ContainerIOEntity entity)
        {
            if (entity == null) return;
            Vector3 spawnPos = Vector3.zero;
            if (entity.name.Contains("sentry.scientist"))
            {
                spawnPos = _npcPos;
                ElectricSwitch sw = GameManager.server.CreateEntity(SwitchPrefab, spawnPos) as ElectricSwitch;
                if (sw == null) return;
                sw.Spawn();
                sw.SetParent(entity);
                DestroyGroundWatch(sw);
                sw.SetFlag(BaseEntity.Flags.On, entity.IsOn());
                sw.UpdateHasPower(30, 0);
            }
        }
        
        private void AddSwitch(ContainerIOEntity entity)
        {
            if (entity == null) return;
            Vector3 spawnPos = Vector3.zero;
            if (entity.name.Contains("autoturret_deployed"))
            {
                spawnPos = _turretPos;
                ElectricSwitch sw = GameManager.server.CreateEntity(SwitchPrefab, spawnPos) as ElectricSwitch;
                if (sw == null) return;
                sw.Spawn();
                sw.SetParent(entity);
                DestroyGroundWatch(sw);
                sw.SetFlag(BaseEntity.Flags.On, entity.IsOn());
                sw.UpdateHasPower(30, 0);
            }
            else if (entity is SamSite)
            {
                spawnPos = _samPos;
                ElectricSwitch sw = GameManager.server.CreateEntity(SwitchPrefab, spawnPos, Quaternion.Euler(0, 180, 0)) as ElectricSwitch;
                if (sw == null) return;
                sw.Spawn();
                sw.SetParent(entity);
                DestroyGroundWatch(sw);
                sw.SetFlag(BaseEntity.Flags.On, entity.IsPowered());
                sw.UpdateHasPower(30, 0);
            }
            else
            {
                return;
            }
        }
        
        object OnEntityTakeDamage(ElectricSwitch swtichz, HitInfo info)
        {
            if (swtichz != null)
            {
                var turret = swtichz.GetComponentInParent<AutoTurret>();
                if (turret != null)
                {
                    turret.Hurt(info);
                    return true;
                }
            }
            return null;
        }
        
        private void DestroyGroundWatch(ElectricSwitch entity)
        {
            DestroyOnGroundMissing missing = entity.GetComponent<DestroyOnGroundMissing>();
            if (missing != null)
            {
                GameObject.Destroy(missing);
            }
            
            GroundWatch watch = entity.GetComponent<GroundWatch>();
            if (watch != null)
            {
                GameObject.Destroy(watch);
            }
        }
        
        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Enable Gametip message")]
            public bool gameTip = true;
            
            [JsonProperty(PropertyName = "Gametip message time")]
            public float gameTipTime = 5f;
            
            [JsonProperty(PropertyName = "Enable Chat message")]
            public bool chatMessage = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion
        
        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoAuth"] = "У вас нет прав на строительство или у вас нет прав на турель!",
                ["NoAuthChat"] = "<color=#ce422b>У вас нет прав на строительство или вы не имеете права на турель!</color>"
            }, this);
        }
        
        #endregion
        
        #region Helpers

        string Lang(string key, string id, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: TurretsExtended.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XMenu.cs ---
// --- Original Local Path: XMenu.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
 
namespace Oxide.Plugins
{
    [Info("XMenu", "Monster", "1.0.804")]
    class XMenu : RustPlugin
    {
		public bool eCargoShip; 
		public bool eCargoPlane;
		public bool eBradleyAPC;
		public bool eBaseHelicopter;
		public bool eCH47Helicopter;
		
		public List<BasePlayer> players = new List<BasePlayer>();
		
		#region Reference
		
		[PluginReference] private Plugin ImageLibrary, IQFakeActive, FGS;
		
		#endregion
		
		#region IQFakeActive
		
		int FakeOnline => (int)IQFakeActive?.Call("GetOnline");
		
		void SyncReservedFinish()
        {
            PrintWarning($"{Name} - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");
        }
		
		#endregion
		
		#region Configuration

        private MenuConfig config;
 
        private class MenuConfig
        {		
		    internal class GeneralSetting
			{
                [JsonProperty("Открытое меню после подключения")] public bool Connect;
                [JsonProperty("Отображать информацию других плагинов")] public bool APluginsInfo;
                [JsonProperty("Отображать ивенты")] public bool AEvents;
                [JsonProperty("Обновлять меню [ Обновляется только открытое меню ]")] public bool Reload;
                [JsonProperty("Обновлять информацию других плагинов [ Обновляется только при открытом меню ]")] public bool ReloadPluginsInfo;
                [JsonProperty("Интервал обновления открытого меню")] public float IReload;
                [JsonProperty("Фейк онлайн от плагина - [ Default - 0 | FGS - 1 | IQFakeActive - 2]")] public int FakeOnline;
			}			   

            internal class LogoSetting
			{
                [JsonProperty("Ссылка на картинку логотипа")] public string LogoURL;
                [JsonProperty("Цвет логотипа")] public string LogoColor;
                [JsonProperty("Материал логотипа")] public string LogoMaterial;
                [JsonProperty("Лого - AnchorMin")] public string AnchorMin;
                [JsonProperty("Лого - AnchorMax")] public string AnchorMax;
                [JsonProperty("Лого - OffsetMin")] public string OffsetMin;
                [JsonProperty("Лого - OffsetMax")] public string OffsetMax;                
				[JsonProperty("Лого в меню - AnchorMin")] public string MAnchorMin;
                [JsonProperty("Лого в меню - AnchorMax")] public string MAnchorMax;
                [JsonProperty("Лого в меню - OffsetMin")] public string MOffsetMin;
                [JsonProperty("Лого в меню - OffsetMax")] public string MOffsetMax;
			}	
		    
            internal class MenuSetting
			{
				[JsonProperty("Цвет меню")] public string MenuColor;
				[JsonProperty("Материал меню")] public string MenuMaterial;
				[JsonProperty("Цвет кнопок")] public string ButtonColor;
				[JsonProperty("Цвет текста кнопок")] public string ButtonTextColor;
				[JsonProperty("Размер текста кнопок")] public int ButtonSize;
				[JsonProperty("Закрывать меню после нажатия одной из кнопок")] public bool CloseMenu;
				[JsonProperty("Меню - AnchorMin")] public string MAnchorMin;
                [JsonProperty("Меню - AnchorMax")] public string MAnchorMax;
                [JsonProperty("Меню - OffsetMin")] public string MOffsetMin;
                [JsonProperty("Меню - OffsetMax")] public string MOffsetMax;				
				[JsonProperty("Инфа плагинов - AnchorMin")] public string PAnchorMin;
                [JsonProperty("Инфа плагинов - AnchorMax")] public string PAnchorMax;
                [JsonProperty("Инфа плагинов - OffsetMin")] public string POffsetMin;
                [JsonProperty("Инфа плагинов - OffsetMax")] public string POffsetMax;
			}    

		    internal class EventSetting
			{
				[JsonProperty("Ссылка на картинку ивента")] public string EventURL;
				[JsonProperty("Цвет активного ивента")] public string EventAColor;
				[JsonProperty("Цвет неактивного ивента")] public string EventDColor;
			}	 

            internal class EventsSetting	
			{
				[JsonProperty("Цвет меню ивентов")] public string EMenuColor;
				[JsonProperty("Материал меню ивентов")] public string EMenuMaterial;
				[JsonProperty("Цвет фона иконок ивентов")] public string EBackgroundColor;
				
				[JsonProperty("Настройка иконок ивентов")]
                public Dictionary<string, EventSetting> Events; 
			}            
			 
			internal class PluginsInfoSetting	
			{
                [JsonProperty("Название плагина")] public string PluginName;				
                [JsonProperty("Название метода(API)")] public string HookName;				
                [JsonProperty("Тип параметра хука - [ player | userID ]")] public string Parameter;				

                public PluginsInfoSetting(string pluginname, string hookname, string parameter)
				{
					PluginName = pluginname; HookName = hookname; Parameter = parameter;
				}				
			}			
			
			[JsonProperty("Общие настройки")]
            public GeneralSetting Setting;			
			[JsonProperty("Настройка логотипа")]
            public LogoSetting Logo;				
			[JsonProperty("Настройка меню")]
            public MenuSetting Menu;				
            [JsonProperty("Настройка кнопок [ Текст | Команда ]")] 
            public Dictionary<string, string> Button;            
            [JsonProperty("Настройка дополнительных кнопок [ Команда | Иконка ]")]
            public Dictionary<string, string> ButtonP;            
			[JsonProperty("Настройка ивентов")]
            public EventsSetting Event;				
			[JsonProperty("Настройка информации других плагинов. [ Хуки c типом параметра - player(BasePlayer) | userID(ulong) ]")]
            public List<PluginsInfoSetting> PluginsInfo;		
			
			public static MenuConfig GetNewConfiguration()
            {
                return new MenuConfig
                {
                    Setting = new GeneralSetting
                    {
						Connect = false,
						APluginsInfo = false,
						AEvents = true,
						Reload = false,
						ReloadPluginsInfo = false,
						IReload = 12.5f,
						FakeOnline = 0
                    },
					Logo = new LogoSetting
					{
						LogoURL = "https://i.imgur.com/Hh7W3hz.png",
						LogoColor = "1 1 1 1",
                        LogoMaterial = "assets/icons/greyout.mat",
						AnchorMin = "0 1",
						AnchorMax = "0 1",
						OffsetMin = "10 -78",
						OffsetMax = "80 -8",						
						MAnchorMin = "0 1",
						MAnchorMax = "0 1",
						MOffsetMin = "-35 -65.5",
						MOffsetMax = "35 4.5"
					},
                    Menu = new MenuSetting
                    {
						MenuColor = "1 0.27 0 0.5",
						MenuMaterial = "assets/icons/greyout.mat",
						ButtonColor = "0.217 0.221 0.209 0.75",
						ButtonTextColor = "1 1 1 1",
						ButtonSize = 9,
						CloseMenu = false,
						MAnchorMin = "0 1",
						MAnchorMax = "0 1",
						MOffsetMin = "45 -72.5",
						MOffsetMax = "400 -12.5",						
						PAnchorMin = "0 1",
						PAnchorMax = "0 1",
						POffsetMin = "357.5 -60",
						POffsetMax = "445 0"
                    },
					Button = new Dictionary<string, string>
					{
						["НАГРАДЫ"] = "chat.say /reward",
			            ["КАЛЕНДАРЬ"] = "chat.say /calendar",
			            ["МАГАЗИН"] = "chat.say /s",
			            ["КРАФТ"] = "chat.say /craft",  
			            ["ИНФА"] = "chat.say /info" 
					},					
					ButtonP = new Dictionary<string, string> 
					{
			            ["store"] = "assets/icons/open.png",
			            ["chat.say /s"] = "assets/icons/community_servers.png",
			            ["chat.say /stats"] = "assets/icons/market.png"
					},
					Event = new EventsSetting 
					{
						EMenuColor = "1 0.27 0 0.5",
						EMenuMaterial = "assets/icons/greyout.mat",
						EBackgroundColor = "0.217 0.221 0.209 0.75",
						Events = new Dictionary<string, EventSetting>
						{
							["CargoPlane"] = new EventSetting
							{
								EventURL = "https://i.imgur.com/UctMlPy.png",
								EventAColor = "1 0.5 0.5 1",
								EventDColor = "1 1 1 1"
							},
							["BaseHelicopter"] = new EventSetting
							{
								EventURL = "https://i.imgur.com/BrJrI8Q.png",
								EventAColor = "1 0.5 1 1",
								EventDColor = "1 1 1 1"
							},
				            ["CargoShip"] = new EventSetting
						    {
							    EventURL = "https://i.imgur.com/ff7ZCBI.png",
							    EventAColor = "0.5 0.5 1 1",
							    EventDColor = "1 1 1 1"
						    },
							["CH47Helicopter"] = new EventSetting
							{
						    	EventURL = "https://i.imgur.com/2PkTyzw.png",
						    	EventAColor = "0.5 1 1 1",
						    	EventDColor = "1 1 1 1"
						    },							
							["BradleyAPC"] = new EventSetting
							{
								EventURL = "https://i.imgur.com/Hzu44wb.png",
								EventAColor = "1 1 0.5 1",
								EventDColor = "1 1 1 1"
							}												
						}
					},
					PluginsInfo = new List<PluginsInfoSetting>
					{
						new PluginsInfoSetting("XShop", "API_GetBalance", "player"),
						new PluginsInfoSetting("XLevels", "API_GetLevel", "player")
					}
				};
			}
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<MenuConfig>(); 
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = MenuConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{
			PrintWarning("\n-----------------------------\n" +
			"     Author - Monster\n" +
			"     VK - vk.com/idannopol\n" +
			"     Discord - Monster#4837\n" +
			"     Config - v.2850\n" + 
			"-----------------------------");
			
			ImageLibrary.Call("AddImage", config.Logo.LogoURL, ".LogoIMG");
			foreach (var image in config.Event.Events)
			    ImageLibrary.Call("AddImage", image.Value.EventURL, $".{image.Key}");
			
			foreach (var entity in BaseNetworkable.serverEntities)
			{
				if (entity is CargoShip) 
					eCargoShip = true;				
				if (entity is CargoPlane)
					eCargoPlane = true;				
				if (entity is BradleyAPC)
					eBradleyAPC = true;				
				if (entity is BaseHelicopter)
					eBaseHelicopter = true;				
				if (entity is CH47Helicopter)
					eCH47Helicopter = true;
			}
			
			BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
			
			if (config.Setting.Reload)
			    timer.Every(config.Setting.IReload, () => { 
			        foreach(var i in players)
				    {
					    GUIMenuInfo(i);
						if (config.Setting.AEvents)
					        GUIEvent(i);
						if(config.Setting.APluginsInfo && config.Setting.ReloadPluginsInfo) 
				            GUIPluginsInfo(i);
				    }
			    });
				
			InitializeLang();
		}
		
		private void Unload()
		{
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
			    CuiHelper.DestroyUi(player, ".LogoGUI");
			    CuiHelper.DestroyUi(player, ".MenuGUI");
			}
		}
		
		private void OnPlayerConnected(BasePlayer player)
		{
			if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }
			
			if(config.Setting.Connect)
			{
				GUILogo(player);
				GUIMenu(player);
					
				if (config.Setting.Reload)
					players.Add(player);
			}
			else
			    GUILogo(player);
		}
		
		private void OnPlayerDisconnected(BasePlayer player)
		{
			if (config.Setting.Reload)
			    players.Remove(player);
		}
		
		private void OnEntitySpawned(BaseNetworkable entity)
		{
			if (entity is CargoShip)
				eCargoShip = true;				
			if (entity is CargoPlane)
				eCargoPlane = true;				
			if (entity is BradleyAPC)
				eBradleyAPC = true;				
			if (entity is BaseHelicopter)
				eBaseHelicopter = true;				
			if (entity is CH47Helicopter)
				eCH47Helicopter = true;
		}		
		
		private void OnEntityKill(BaseNetworkable entity)
		{
			if (entity is CargoShip)
				eCargoShip = false;				
			if (entity is CargoPlane)
				eCargoPlane = false;				
			if (entity is BradleyAPC)
				eBradleyAPC = false;				
			if (entity is BaseHelicopter)
				eBaseHelicopter = false;				
			if (entity is CH47Helicopter)
				eCH47Helicopter = false;
		}
		
		#endregion
		
		#region Commands
		
		[ConsoleCommand("ui_menu")]
		void cmdOpenGUI(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			Effect x = new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3());
			
			switch(args.Args[0])
			{
				case "open":
				{
					GUIMenu(player);
					
					if (config.Setting.Reload)
					    players.Add(player);
					break;
				}				 
				case "close":
				{
					if (config.Setting.Reload)
					    players.Remove(player); 
					break;
				}
			}
			
			EffectNetwork.Send(x, player.Connection);
		}
		
		#endregion
		
		#region GUI 
		
		private void GUILogo(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".LogoGUI");
            CuiElementContainer container = new CuiElementContainer();
			
			MenuConfig.LogoSetting logo = config.Logo;
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = logo.AnchorMin, AnchorMax = logo.AnchorMax, OffsetMin = logo.OffsetMin, OffsetMax = logo.OffsetMax },
                Image = { Png = (string) ImageLibrary.Call("GetImage", ".LogoIMG"), Color = logo.LogoColor, Material = logo.LogoMaterial }
            }, "Overlay", ".LogoGUI");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "ui_menu open" },
                Text = { Text = "" }
            }, ".LogoGUI");
			
			CuiHelper.AddUi(player, container);
		}
		
		private void GUIMenu(BasePlayer player)
		{	
			CuiHelper.DestroyUi(player, ".MenuGUI");
            CuiElementContainer container = new CuiElementContainer();
			
			MenuConfig.MenuSetting menu = config.Menu;
			MenuConfig.LogoSetting logo = config.Logo;
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = menu.MAnchorMin, AnchorMax = menu.MAnchorMax, OffsetMin = menu.MOffsetMin, OffsetMax = menu.MOffsetMax },
                Image = { Color = menu.MenuColor, Material = menu.MenuMaterial }
            }, "Overlay", ".MenuGUI");			
			
			container.Add(new CuiPanel
            { 
                RectTransform = { AnchorMin = logo.MAnchorMin, AnchorMax = logo.MAnchorMax, OffsetMin = logo.MOffsetMin, OffsetMax = logo.MOffsetMax },
                Image = { Png = (string) ImageLibrary.Call("GetImage", ".LogoIMG"), Color = logo.LogoColor, Material = logo.LogoMaterial }
            }, ".MenuGUI");	
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "-35 -64.5", OffsetMax = "35 4.5" },
                Button = { Color = "0 0 0 0", Close = ".MenuGUI", Command = "ui_menu close" },
                Text = { Text = "" }
            }, ".MenuGUI");							
			
			container.Add(new CuiPanel  
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "40 -55", OffsetMax = "42.5 -5" },
                Image = { Color = "1 1 1 1" }
            }, ".MenuGUI");				
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "322.5 -55", OffsetMax = "325 -5" },
                Image = { Color = "1 1 1 1" }
            }, ".MenuGUI"); 
			
			int count = config.Button.Count, count1 = config.ButtonP.Count;
			
			foreach(var i in config.Button)
			{
				double offset = -(26 * count--) - (1.25 * count--);
				
				container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offset + 5} -25", OffsetMax = $"{offset + 57} -10" },
                    Button = { Color = menu.ButtonColor, Command = i.Value, Close = menu.CloseMenu ? ".MenuGUI" : "" },
                    Text = { Text = "" }
                }, ".MenuGUI", ".BUTTON");
				
			    container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = lang.GetMessage(i.Key, this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = menu.ButtonSize, Color = menu.ButtonTextColor }
                }, ".BUTTON");
			}
			
			foreach(var i in config.ButtonP)
			{
				double offset = (6.5 * count1--) + (2.5 * count1--); 
				 
				container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"155 {offset - 14.25}", OffsetMax = $"170 {offset + 0.75}" },
                    Button = { Color = "1 1 1 1", Sprite = i.Value, Command = i.Key, Close = menu.CloseMenu ? ".MenuGUI" : "" },
                    Text = { Text = "" }
                }, ".MenuGUI", ".BUTTON");
			}
			
			CuiHelper.AddUi(player, container);
			
			GUIMenuInfo(player);
			if (config.Setting.AEvents)
			    GUIEvent(player);
			if(config.Setting.APluginsInfo)
				GUIPluginsInfo(player);
		}
		
		private void GUIMenuInfo(BasePlayer player)
		{	
			CuiHelper.DestroyUi(player, ".MenuInfoGUI");
            CuiElementContainer container = new CuiElementContainer();
			
			int online = config.Setting.FakeOnline == 1 && IQFakeActive ? FakeOnline : config.Setting.FakeOnline == 2 && FGS ? BasePlayer.activePlayerList.Count + (int)FGS?.CallHook("getFakes") : BasePlayer.activePlayerList.Count;
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "47.5 -40", OffsetMax = "318 -5" },
                Text = { Text = string.Format(lang.GetMessage("TITLE", this, player.UserIDString), online, ConVar.Server.maxplayers, ServerMgr.Instance.connectionQueue.Joining, BasePlayer.sleepingPlayerList.Count, TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm")), Align = TextAnchor.UpperCenter, FontSize = 13, Color = "1 1 1 1" }
            }, ".MenuGUI", ".MenuInfoGUI");
			
			CuiHelper.AddUi(player, container);
		}
		
		private void GUIEvent(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".EventGUI"); 
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "112.25 -90", OffsetMax = "242.75 -62.5" },
                Image = { Color = config.Event.EMenuColor, Material = config.Event.EMenuMaterial }
            }, ".MenuGUI", ".EventGUI");
			
			int count = config.Event.Events.Count;
			
			foreach(var i in config.Event.Events) 
			{
				double offset = -(11.25 * count--) - (1.5 * count--);
				
				container.Add(new CuiPanel 
                { 
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offset} -11.25", OffsetMax = $"{offset + 22.5} 11.25" },
                    Image = { Color = config.Event.EBackgroundColor }
                }, ".EventGUI", $".{i.Key}");
			}  
			
			if(config.Event.Events.ContainsKey("CargoShip"))
			    container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1.75 1.75", OffsetMax = "-1.75 -1.75" },
                    Image = { Png = (string) ImageLibrary.Call("GetImage", ".CargoShip"), Color = eCargoShip ? config.Event.Events["CargoShip"].EventAColor : config.Event.Events["CargoShip"].EventDColor }
                }, ".CargoShip");			
			
			if(config.Event.Events.ContainsKey("CargoPlane"))
			    container.Add(new CuiPanel 
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1.75 1.75", OffsetMax = "-1.75 -1.75" },
                    Image = { Png = (string) ImageLibrary.Call("GetImage", ".CargoPlane"), Color = eCargoPlane ? config.Event.Events["CargoPlane"].EventAColor : config.Event.Events["CargoPlane"].EventDColor }
                }, ".CargoPlane");			
			
			if(config.Event.Events.ContainsKey("BradleyAPC"))
			    container.Add(new CuiPanel
                { 
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1.75 1.75", OffsetMax = "-1.75 -1.75" },
                    Image = { Png = (string) ImageLibrary.Call("GetImage", ".BradleyAPC"), Color = eBradleyAPC ? config.Event.Events["BradleyAPC"].EventAColor : config.Event.Events["BradleyAPC"].EventDColor }
                }, ".BradleyAPC");		 	 	
			
			if(config.Event.Events.ContainsKey("BaseHelicopter"))
			    container.Add(new CuiPanel  
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1.75 1.75", OffsetMax = "-1.75 -1.75" },
                    Image = { Png = (string) ImageLibrary.Call("GetImage", ".BaseHelicopter"), Color = eBaseHelicopter ? config.Event.Events["BaseHelicopter"].EventAColor : config.Event.Events["BaseHelicopter"].EventDColor }
                }, ".BaseHelicopter");				
			
			if(config.Event.Events.ContainsKey("CH47Helicopter"))
			    container.Add(new CuiPanel 
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1.75 1.75", OffsetMax = "-1.75 -1.75" },
                    Image = { Png = (string) ImageLibrary.Call("GetImage", ".CH47Helicopter"), Color = eCH47Helicopter ? config.Event.Events["CH47Helicopter"].EventAColor : config.Event.Events["CH47Helicopter"].EventDColor }
                }, ".CH47Helicopter");	 
			
			CuiHelper.AddUi(player, container); 
		}
		
		private void GUIPluginsInfo(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".PluginsInfoGUI"); 
            CuiElementContainer container = new CuiElementContainer();			
			
			MenuConfig.MenuSetting menu = config.Menu;
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = menu.PAnchorMin, AnchorMax = menu.PAnchorMax, OffsetMin = menu.POffsetMin, OffsetMax = menu.POffsetMax },
                Image = { Color = "0 0 0 0" }
            }, ".MenuGUI", ".PluginsInfoGUI");						

            int y = 0, count = config.PluginsInfo.Count; 

            foreach(var plugininfo in config.PluginsInfo.Where(p => plugins.Find(p.PluginName)))
			{
				container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"0 {-18 - (y * 21)}", OffsetMax = $"0 {0 - (y * 21)}" },
                    Image = { Color = config.Menu.MenuColor, Material = config.Menu.MenuMaterial }
                }, ".PluginsInfoGUI", ".InfoText");
				
				if(plugininfo.Parameter == "player")
				    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Text = { Text = string.Format(lang.GetMessage(plugininfo.PluginName, this, player.UserIDString), plugins.Find(plugininfo.PluginName).CallHook(plugininfo.HookName, player)), Align = TextAnchor.MiddleCenter, FontSize = 11 }
                    }, ".InfoText");
				else if(plugininfo.Parameter == "userID")
					container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Text = { Text = string.Format(lang.GetMessage(plugininfo.PluginName, this, player.UserIDString), plugins.Find(plugininfo.PluginName).CallHook(plugininfo.HookName, player.userID)), Align = TextAnchor.MiddleCenter, FontSize = 11 }
                    }, ".InfoText");
					
				y++;
			}			
			
			CuiHelper.AddUi(player, container);
		}
		
		#endregion
		
		#region Lang
 
        void InitializeLang()
        {
			Dictionary<string, string> llang = new Dictionary<string, string>();		
				
			foreach(var button in config.Button)
				llang.Add(button.Key, button.Key);			
			foreach(var plugininfo in config.PluginsInfo)
				llang.Add(plugininfo.PluginName, "БАЛАНС: {0}₽");
			
			llang.Add("TITLE", "ДОБРО ПОЖАЛОВАТЬ НА МОЙ КРУТОЙ СЕРВЕР\n<size=10>ОНЛАЙН: {0}/{1} | ЗАХОДЯТ: {2} | СЛИПЕРЫ: {3} | ВРЕМЯ: {4}</size>");	
			 
            lang.RegisterMessages(llang, this);
            lang.RegisterMessages(llang, this, "ru");
        }

        #endregion
	}
}

// --- End of file: XMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InstantXP.cs ---
// --- Original Local Path: InstantXP.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("InstantXP", "k1lly0u", "0.1.2", ResourceId = 2017)]
    class InstantXP : RustPlugin
    {
        #region Fields
        IXPData ixpData;
        private DynamicConfigFile data;

        int[] Levels;
        #endregion

        #region Oxide Hooks 
        void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("instantxp_permissions");
            lang.RegisterMessages(Messages, this);
        }
        void OnServerInitialized()
        {
            Levels = Rust.Xp.Config.Levels;
            LoadVariables();
            LoadData();
            foreach (var perm in ixpData.Permissions)
                permission.RegisterPermission(perm.Key, this);
        }
        void OnPlayerInit(BasePlayer player)
        {
            var level = GetLevel(player.userID);
            if (level == 0) return;
            if (player.xp.CurrentLevel < level)
            {
                player.xp.Reset();
                player.xp.Add(Rust.Xp.Definitions.Cheat, Levels[level - 1]);
                SendReply(player, string.Format(LA("levelSet", player.UserIDString), level));
            }
        }
        void OnUserPermissionGranted(string name, string perm)
        {
            if (ixpData.Permissions.ContainsKey(perm))
            {
                var player = BasePlayer.Find(name);
                if (player != null)
                    OnPlayerInit(player);
            }
        }
        #endregion

        #region Functions
        private int GetLevel(ulong playerid)
        {
            int level = configData.DefaultLevel;
            foreach (var entry in ixpData.Permissions)
            {
                if (permission.UserHasPermission(playerid.ToString(), entry.Key))
                {
                    level = entry.Value;
                    break;
                }
            }
            return level;
        }
        #endregion

        #region Chat Commands
        [ChatCommand("ixp")]
        private void cmdRod(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin())
            {
                if (args == null || args.Length == 0)
                {
                    SendMSG(player, LA("addSyn", player.UserIDString));
                    SendMSG(player, LA("editSyn", player.UserIDString));
                    SendMSG(player, LA("remSyn", player.UserIDString));
                    SendMSG(player, LA("listSyn", player.UserIDString));
                    return;
                }
                if (args.Length >= 1)
                {
                    switch (args[0].ToLower())
                    {
                        case "add":
                            if (args.Length == 3)
                            {
                                string perm = args[1].ToLower();
                                if (!perm.StartsWith(Title.ToLower() + "."))
                                    perm = Title.ToLower() + "." + perm;
                                if (!permission.PermissionExists(perm) && !ixpData.Permissions.ContainsKey(perm))
                                {
                                    int level = 0;
                                    if (int.TryParse(args[2], out level))
                                    {
                                        ixpData.Permissions.Add(perm, level);
                                        permission.RegisterPermission(perm, this);
                                        SaveData();
                                        SendMSG(player, string.Format(LA("addPerm", player.UserIDString), perm, level));
                                        return;
                                    }
                                    SendMSG(player, LA("validNum", player.UserIDString));
                                    return;
                                }
                                SendMSG(player, LA("existPerm", player.UserIDString));
                                return;
                            }
                            SendMSG(player, LA("addSyn", player.UserIDString));
                            return;
                        case "edit":
                            if (args.Length == 3)
                            {
                                if (ixpData.Permissions.ContainsKey(args[1].ToLower()))
                                {
                                    int level = 0;
                                    if (int.TryParse(args[2], out level))
                                    {
                                        ixpData.Permissions[args[1].ToLower()] = level;
                                        SaveData();
                                        SendMSG(player, string.Format(LA("editPerm", player.UserIDString), args[1].ToLower(), level));
                                        return;
                                    }
                                    SendMSG(player, LA("validNum", player.UserIDString));
                                    return;
                                }
                                SendMSG(player, string.Format(LA("noExistPerm", player.UserIDString), args[1].ToLower()));
                                return;
                            }
                            SendMSG(player, LA("editSyn", player.UserIDString));
                            return;
                        case "remove":
                            if (args.Length >= 2)
                                if (ixpData.Permissions.ContainsKey(args[1].ToLower()))
                                {
                                    ixpData.Permissions.Remove(args[1].ToLower());
                                    SaveData();
                                    SendMSG(player, string.Format(LA("remPerm", player.UserIDString), args[1].ToLower()));
                                    return;
                                }
                            SendMSG(player, string.Format(LA("noExistPerm", player.UserIDString), args[1].ToLower()));
                            return;
                        case "list":
                            if (ixpData.Permissions.Count > 0)
                            {
                                SendMSG(player, LA("currentPerms", player.UserIDString));
                                foreach (var entry in ixpData.Permissions)
                                    SendMSG(player, $"{entry.Key} -- {entry.Value}");
                                return;
                            }
                            SendMSG(player, LA("noPermsSet", player.UserIDString));
                            return;
                    }
                }
            }
        }
        private void SendMSG(BasePlayer player, string message) => SendReply(player, "<color=orange>" + message + "</color>");
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public int DefaultLevel { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                DefaultLevel = 0
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion 

        #region Data Management
        void SaveData() => data.WriteObject(ixpData);
        void LoadData()
        {
            try
            {
                ixpData = data.ReadObject<IXPData>();
            }
            catch
            {
                ixpData = new IXPData();
            }
        }
        class IXPData
        {
            public Dictionary<string, int> Permissions = new Dictionary<string, int>();
        }
        #endregion

        #region Messaging
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            { "noPermsSet", "There are currently no permissions set up" },
            { "currentPerms", "Current permissions;" },
            { "noExistPerm", "The permission {0} does not exist" },
            { "remPerm", "You have successfully remove the permission {0}" },
            { "editSyn", "/ixp edit <permission> <level> - Edits a existing permission and level" },
            { "validNum", "You must enter a valid level number" },
            { "editPerm", "You have successfully edited the permission {0} with a level of {1}" },
            { "addSyn", "/ixp add <permission> <level> - Adds a new permission and level" },
            { "existPerm", "That permission already exists" },
            { "addPerm", "You have successfully added the permission {0} with a starting level of {1}" },
            { "remSyn", "/ixp remove <permission> - Remove a permission" },
            { "listSyn", "/ixp list - Lists all permissions and assigned level" },
            { "levelSet", "Your level has been automatically raised to {0}" }
        };
        private string LA(string key, string userid = null) => lang.GetMessage(key, this, userid);
        #endregion
    }
}


// --- End of file: InstantXP.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Teleport.cs ---
// --- Original Local Path: Teleport.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("Teleport", "unknown", "1.1.40")]
    class Teleport : RustPlugin
    {
        #region References
        [PluginReference]
        Plugin Clans;
        [PluginReference]
        Plugin Friends;
        [PluginReference]
        Plugin NoEscape;
        [PluginReference]
        Plugin Duel;
        #endregion

        #region Variables
        private TeleportConfig m_Config;
        private Dictionary<int, TeleportObject> m_TeleportToPlayerWaiters;
        private Dictionary<string, PlayerPluginData> m_ActivePlayers;
        private Dictionary<int, HomeTeleportObject> m_TeleportToHomeWaiters;
        #endregion

        #region Configuration
        public enum Settings
        {
            SaveHomeLimit,
            TeleportToHomeLimit,
            TeleportToPlayerLimit,
            WaitToTeleportTime,
            WaitToHomeTeleportTime,
            WaitAfterTeleport,
            WaitAfterTeleportHome
        }
        private class TeleportConfig
        {
            [JsonProperty("Префикс плагина для отображения в чате")]
            public string PluginPrefix { get; set; }

            [JsonProperty("Включить префикс плагина ?")]
            public bool EnablePluginPrefix { get; set; }

            [JsonProperty("Включить вывод информации о привилегиях в консоль ?")]
            public bool EnablePrintPermissionsInfo { get; set; }

            [JsonProperty("Включить GUI в плагине ?")]
            public bool EnableGUI { get; set; }
            
            [JsonProperty("Включить логирование использования команд администраторами ?")]
            public bool EnableAdminCommandsLogging { get; set; }

            [JsonProperty("Файл логирования команд администраторами")]
            public string AdminCommandsLoggingFile { get; set; }

            [JsonProperty("Включить логирование использования команд игроками ?")]
            public bool EnableUsersCommandsLogging { get; set; }

            [JsonProperty("Файл логирования команд игроками")]
            public string UserCommandsLoggingFile { get; set; }

            [JsonProperty("Включить систему домов ?")]
            public bool AllowHomeSystem { get; set; }

            [JsonProperty("Включить систему телепортации ?")]
            public bool AllowTeleportSystem { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта во время блока NoEscape ?")]
            public bool AllowTeleportInEscapeBlock { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта во время рейда ?")]
            public bool AllowTeleportInRaidBlock { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта во время боя ?")]
            public bool AllowTeleportInCombatBlock { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта в воде ?")]
            public bool AllowTeleportInWater { get; set; }

            [JsonProperty("Уровень воды для отмены телепорта")]
            public double CancelTeleportWaterFactor { get; set; }

            [JsonProperty("Разрешить телепортироваться в ванише ?")]
            public bool AllowTeleportInVanish { get; set; }

            [JsonProperty("Разрешить телепорт из РТ ?")]
            public bool AllowTeleportInRT { get; set; }

            [JsonProperty("Дальность от РТ для проверки")]
            public float ToRTDistance { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта во время крафта ?")]
            public bool AllowTeleportInCraft { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта при ваунде ?")]
            public bool AllowTeleportInWounded { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта после смерти ?")]
            public bool AllowTeleportAfterDeath { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта во время действия радиации ?")]
            public bool AllowTeleportInRadiation { get; set; }

            [JsonProperty("Уровень радиации для отмены телепорта")]
            public int CancelTeleportRadiationFactor { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта во время действия кровотечения ?")]
            public bool AllowTeleportInBleeding { get; set; }

            [JsonProperty("Уровень кровотечения для отмены телепорта")]
            public int CancelTeleportBleedingFactor { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта при получении урона ?")]
            public bool AllowTeleportAfterDamage { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта во время охлаждения ?")]
            public bool AllowTeleportInFreezing { get; set; }

            [JsonProperty("Уровень холода для отмены телепорта")]
            public int CancelTeleportFreezeFactor { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта в зоне действия чужого шкафа ?")]
            public bool AllowTeleportInBBZone { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта только друзьям ?")]
            public bool AllowTeleportOnlyFriends { get; set; }

            [JsonProperty("Разрешить использовать систему телепорта только соклановцам ?")]
            public bool AllowTeleportOnlyClan { get; set; }

            [JsonProperty("Разрешить телепорт при получении урона ?")]
            public bool AllowTeleportAfterRCVDamage { get; set; }

            [JsonProperty("Разрешить сохранять дом только на фундаменте ?")]
            public bool AllowSaveHomeOnlyFundament { get; set; }

            [JsonProperty("Создавать спальный мешок после сохранения дома ?")]
            public bool CreateBagAfterHomeSave { get; set; }

            [JsonProperty("Разрешить сохранять дом в зоне действия чужого шкафа ?")]
            public bool AllowSaveHomeOnBB { get; set; }

            [JsonProperty("Разрешить сохранять дом только на фундаменте соклановцев ?")]
            public bool AllowSaveHomeOnClanFundament { get; set; }

            [JsonProperty("Разрешить сохранять дом только на фундаменте друзей ?")]
            public bool AllowSaveHomeOnFriendFundament { get; set; }

            [JsonProperty("Время ожидания телепорта по умолчанию")]
            public int DefaultTimeToTeleport { get; set; }

            [JsonProperty("Время ожидания телепорта домой по умолчанию")]
            public int DefaultTimeToTeleportHome { get; set; }

            [JsonProperty("Время восстановление телепорта по умолчанию")]
            public int DefaultRemainingAfterTeleport { get; set; }

            [JsonProperty("Время восстановления телепорта домой по умолчанию")]
            public int DefaultRemainingAfterHomeTeleport { get; set; }

            [JsonProperty("Количество сохраняемых домов по умолчанию")]
            public int DefaultSaveHomeLimit { get; set; }

            [JsonProperty("Количество телепортов к игроку в сутки ?")]
            public int DefaultTTPOneDay { get; set; }

            [JsonProperty("Количество телепортов домой в сутки ?")]
            public int DefaultTTHOneDay { get; set; }

            [JsonProperty("Время, через которое запрос будет отменен автоматически, если игрок на него не ответил")]
            public int DefaultRequestCancelledTime { get; set; }

            [JsonProperty("Время, через которое лимиты будут обновлены автоматически (По умолчанию = 24 часа)")]
            public int DefaultLimitsUpdated { get; set; }

            [JsonProperty("Название уведомления о телепортации. (По умолчанию: ЗАПРОС:)")]
            public string DefaultHeaderTeleportNotify { get; set; }

            [JsonProperty("Сообщение о запросе на телепорт. (По умолчанию {0} хочет телепортироваться к Вам)")]
            public string DefaultFromTeleportNotify { get; set; }

            [JsonProperty("Включить звуковое уведомление")]
            public bool EnableSoundEffects { get; set; }

            [JsonProperty("Кастомные пути к звуковому файлу, для воспроизведения. Если парааметр: 'Включить звуковое уведомление' включен")]
            public Dictionary<string, string> SoundsFotNotify { get; set; }

            [JsonProperty("Динамическая система привилегий. Указывайте настройки для каждой привилегии. Пример указан.")]
            public Dictionary<string, Dictionary<string, Dictionary<string, int>>> PermissionSettings { get; set; }

            public static TeleportConfig Prototype()
            {
                return new TeleportConfig()
                {
                    PluginPrefix = "[TP]",
                    EnableGUI = true,
                    AllowTeleportAfterRCVDamage = false,
                    DefaultHeaderTeleportNotify = "ЗАПРОС:",
                    DefaultFromTeleportNotify = "{0} хочет телепортироваться к Вам",
                    EnablePrintPermissionsInfo = true,
                    EnablePluginPrefix = true,
                    EnableAdminCommandsLogging = true,
                    AdminCommandsLoggingFile = "Admin_Teleports_log",
                    EnableUsersCommandsLogging = true,
                    UserCommandsLoggingFile = "User_Teleports_log",
                    AllowHomeSystem = true,
                    AllowTeleportInCombatBlock = false,
                    AllowTeleportInEscapeBlock = false,
                    AllowTeleportInRaidBlock = false,
                    AllowTeleportInVanish = true,
                    AllowTeleportInRT = false,
                    ToRTDistance = 150f,
                    CancelTeleportBleedingFactor = 5,
                    CancelTeleportFreezeFactor = 5,
                    CancelTeleportRadiationFactor = 5,
                    CancelTeleportWaterFactor = 0.2,
                    AllowTeleportSystem = true,
                    AllowTeleportInWounded = false,
                    AllowTeleportInWater = false,
                    AllowTeleportInCraft = false,
                    AllowTeleportAfterDeath = false,
                    AllowTeleportAfterDamage = false,
                    AllowTeleportInRadiation = false,
                    AllowTeleportInBleeding = false,
                    AllowTeleportInFreezing = false,
                    AllowTeleportInBBZone = false,
                    AllowTeleportOnlyFriends = false,
                    AllowTeleportOnlyClan = false,
                    AllowSaveHomeOnlyFundament = true,
                    CreateBagAfterHomeSave = true,
                    AllowSaveHomeOnBB = false,
                    AllowSaveHomeOnClanFundament = false,
                    AllowSaveHomeOnFriendFundament = false,
                    DefaultSaveHomeLimit = 3,
                    DefaultTimeToTeleport = 15,
                    DefaultTimeToTeleportHome = 15,
                    DefaultRemainingAfterTeleport = 120,
                    DefaultRemainingAfterHomeTeleport = 120,
                    DefaultTTPOneDay = 30,
                    DefaultTTHOneDay = 15,
                    DefaultRequestCancelledTime = 15,
                    DefaultLimitsUpdated = 86400,
                    EnableSoundEffects = true,
                    SoundsFotNotify = new Dictionary<string, string>()
                    {
                        ["tp_request"] = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab",
                        ["tp_receive"] = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab",
                        ["home_teleport"] = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab",
                    },
                    PermissionSettings = new Dictionary<string, Dictionary<string, Dictionary<string, int>>>()
                    {
                        ["teleport.vip"] = new Dictionary<string, Dictionary<string, int>>()
                        {
                            ["Settings"] = new Dictionary<string, int>()
                            {
                                ["SaveHomeLimit"]          = 3,
                                ["TeleportToHomeLimit"]    = 20,
                                ["TeleportToPlayerLimit"]  = 40,
                                ["WaitToTeleportTime"]     = 10,
                                ["WaitToHomeTeleportTime"] = 10,
                                ["WaitAfterTeleport"]      = 60,
                                ["WaitAfterTeleportHome"]  = 60
                            }
                        },
                        ["teleport.admin"] = new Dictionary<string, Dictionary<string, int>>()
                        {
                            ["Settings"] = new Dictionary<string, int>()
                            {
                                ["SaveHomeLimit"]          = 999,
                                ["TeleportToHomeLimit"]    = 999,
                                ["TeleportToPlayerLimit"]  = 999,
                                ["WaitToTeleportTime"]     = 1,
                                ["WaitToHomeTeleportTime"] = 1,
                                ["WaitAfterTeleport"]      = 1,
                                ["WaitAfterTeleportHome"]  = 1
                            }
                        }
                    }
                };
            }
        }

        protected override void LoadDefaultConfig()
        {
            m_Config = TeleportConfig.Prototype();

            PrintWarning("Creating default a configuration file ...");
            RegisterPermissions();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            m_Config = Config.ReadObject<TeleportConfig>();

            RegisterPermissions();
        }
        protected override void SaveConfig() => Config.WriteObject(m_Config);
        #endregion

        #region Localize
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["error_player_in_bleeding"] = "<color=#ba2c2c>Нельзя использовать телепорт если у вас кровотечение</color>",
                ["error_target_in_bleeding"] = "<color=#ba2c2c>У игрока, которому вы отправляете запрос, кровотечение</color>",
                ["error_player_in_freezing"] = "<color=#4acce2>Нельзя использовать телепорт, когда вы замерзаете</color>",
                ["error_target_in_freezing"] = "<color=#4acce2>Игрок, которому вы отправляете запрос, замерзает</color>",
                ["error_player_in_wounded"] = "<color=#d8e82e>Нельзя использовать телепорт в ваунде</color>",
                ["error_target_in_wounded"] = "<color=#d8e82e>Игрок, которому вы отправляете запрос в ваунде</color>",
                ["error_player_in_water"] = "<color=#0571ba>Нельзя использовать телепорт находясь в воде</color>",
                ["error_target_in_water"] = "<color=#0571ba>Игрок, которому вы отправляете запрос находится в воде</color>",
                ["error_player_in_radiation"] = "<color=#ddf21f>Нельзя использовать телепорт во время действия радиации</color>",
                ["error_target_in_radiation"] = "<color=#ddf21f>Игрок, которому вы отправляете запрос находится под воздействием радиации</color>",
                ["error_player_in_already_teleported"] = "<color=#f11f1f>Вы уже телепортируетесь</color>",
                ["error_target_in_already_teleported"] = "<color=#f11f1f>Игрок, которому вы отправляете запрос уже телепортируется</color>",
                ["error_player_in_bb"] = "<color=#f11f1f>Нельзя использовать телепорт в зоне действия чужого шкафа</color>",
                ["error_target_in_bb"] = "<color=#f11f1f>Игрок, которому вы отправляете запрос находится в зоне действия чужого шкафа</color>",
                ["error_ttp_cooldown"] = "<color=#f0761e>Невозможно отправить запрос. Попробуйте через {0} секунд</color>",
                ["info_ttp_cooldown_reseted"] = "<color=#49b50a>Теперь вы снова можете телепортироватся к другим</color>",
                ["error_tth_cooldown"] = "<color=#f0761e>Невозможно отправить запрос. Попробуйте через {0} секунд</color>",
                ["info_tth_cooldown_reseted"] = "<color=#49b50a>Теперь вы снова можете телепортироватся домой</color>",
                ["error_ttp_only_friend"] = "<color=#ba2c2c>Телепортироваться можно только к друзьям</color>",
                ["error_ttp_only_clan"] = "<color=#ba2c2c>Телепортироваться можно только к члену вашего клана</color>",
                ["error_ttp_incorrect_target"] = "<color=#ba2c2c>Запрашиваемый игрок не найден</color>",
                ["error_ttp_self"] = "<color=#ba2c2c>Серьезно? К самому себе?</color>",
                ["error_ttp_player_already_wait"] = "<color=#ba2c2c>Вы уже ожидаете телепортации</color>",
                ["error_ttp_target_already_wait"] = "<color=#ba2c2c>Ваша цель уже находится в очереди на телепортацию</color>",
                ["info_ttp_request_cancelled"] = "<color=#49b50a>Запрос на телепортацию был отменен</color>",
                ["info_ttp_request_notfound"] = "<color=#ba2c2c>Отсутствуют доступные запросы для совершения этого действия</color>",
                ["info_ttp_request_player_appended"] = "<color=#ffa500ff>Игрок '{0}' принял ваш запрос. Вы будете телепортированы через {1} секунд</color>",
                ["info_ttp_request_target_appended"] = "<color=#ffa500ff>Вы приняли запрос от игрока '{0}'. Он появится возле вас черех {1} секунд</color>",
                ["info_ttp_request_player_finished"] = "<color=#49b50a>Игрок '{0}' успешно телепортировался к вам</color>",
                ["info_ttp_request_target_finished"] = "<color=#49b50a>Вы успешно телепортированы к игроку '{0}'. Осталось телепортов: {1}</color>",
                ["info_ttp_request_player_created"] = "<color=#49b50a>Запрос на телепортацию к игроку '{0}' создан успешно. Ожидайте ответа</color>",
                ["info_ttp_request_target_created"] = "<color=#49b50a>Игрок '{0}' хочет к вам телепортироваться. Чтобы принять введите /tpa и /tpc чтобы отклонить. Он будет автоматически отклонен, если вы не ответите в течении 15 секунд</color>",
                ["whose_from_waiter_already_wait"] = "<color=#ba2c2c>Ктото из участников уже ожидает телепортации. Если это вы, то введите /tpc для отмены запроса</color>",
                ["error_command_sethome_incorrect"] = "<color=#ba2c2c>Неверный синтакисис. Используйте команду следующим образом /sethome [name]</color>",
                ["error_home_already_exists"] = "<color=#ba2c2c>Дом с таким именем уже существует</color>",
                ["error_max_home_limits"] = "<color=#ba2c2c>Вы установили максимальное число домов для себя</color>",
                ["info_ttp_limit_reseted"] = "<color=#49b50a>Лимит использования телепортов к игрокам для Вас обновлен !</color>",
                ["info_tth_limit_reseted"] = "<color=#49b50a>Лимит использования телепортов домой для Вас обновлен !</color>",
                ["error_ttp_unlimited"] = "<color=#ba2c2c>Лимит использований исчерпан. Попробуйте через: {0}ч. {1}м. {2}с.</color>",
                ["error_teleport_system_disabled"] = "<color=#ba2c2c>Система телепортации временно отключена</color>",
                ["error_player_received_damage"] = "<color=#ba2c2c>Вы получили урон</color>",
                ["error_target_received_damage"] = "<color=#ba2c2c>Ваша цель получила урон</color>",
                ["error_player_start_damage"] = "<color=#ba2c2c>Вы вступили в бой</color>",
                ["error_target_start_damage"] = "<color=#ba2c2c>Ваша цель вступила в бой</color>",
                ["error_player_is_death"] = "<color=#ba2c2c>Вы умерли</color>",
                ["error_target_is_death"] = "<color=#ba2c2c>Ваша цель умерла</color>",
                ["error_command_tpr_incorrect"] = "<color=#ba2c2c>Неправильное использование команды. Пример /tpr [nickname]</color>",
                ["error_tth_received_damage"] = "<color=#ba2c2c>Вы получили повреждения</color>",
                ["error_tth_start_damage"] = "<color=#ba2c2c>Вы вступили в бой</color>",
                ["error_tth_player_die"] = "<color=#ba2c2c>Вас убили</color>",
                ["info_home_deleted_by_demolish"] = "<color=#ba2c2c>Блок на котором стоял Ваш дом уничтожен. Дом был удален</color>",
                ["error_rename_other_bags"] = "<color=#ba2c2c>Нельзя переименовывать чужие дома</color>",
                ["error_ttp_cancelled_player_after_wounded"] = "<color=#ba2c2c>Вы получили критические ранения</color>",
                ["error_ttp_cancelled_target_after_wounded"] = "<color=#ba2c2c>Игрок, который к Вам телепортируется получил критические ранения</color>",
                ["error_tth_cancelled_after_wounded"] = "<color=#ba2c2c>Вы получили критические повреждения</color>",
                ["info_home_created"] = "<color=#49b50a>Дом: '{0}' успешно сохранен</color>",
                ["error_sethome_save_only_clan_foundation"] = "<color=#ba2c2c>Сохранять дом разрешено только на фундаменте членов клана</color>",
                ["error_sethome_save_only_friend_foundation"] = "<color=#ba2c2c>Сохранять дом разрешено только на фундаменте друзей</color>",
                ["error_home_system_disabled"] = "<color=#ba2c2c>Система домов временно недоступна. Попробуйте позже</color>",
                ["error_command_sethome_incorrect"] = "<color=#ba2c2c>Неверный синтаксис для команды. Пример: /sethome [homename]</color>",
                ["error_max_home_limits"] = "<color=#ba2c2c>Вы уже сохранили максимальное количество домов</color>",
                ["error_home_already_exists"] = "<color=#ba2c2c>Дом с таким названием уже существует</color>",
                ["error_sethome_only_foundation"] = "<color=#ba2c2c>Сохранять дома разрешено только на фундаменте !</color>",
                ["error_sethome_save_on_bb"] = "<color=#ba2c2c>Нельзя сохранять дом в зоне действия чужого шкафа</color>",
                ["error_command_removehome_incorrect"] = "<color=#ba2c2c>Некорректный синтаксис для команды. Пример: /removehome 1</color>",
                ["error_saved_home_notfound"] = "<color=#ba2c2c>Дом: '{0}' не найден. Проверьте корректность ввода</color>",
                ["error_home_killed_automatic_deleted"] = "<color=#ba2c2c>Этот дом был уничтожен и поэтому он был удален</color>",
                ["error_home_deleted_cancelled_teleport"] = "<color=#ba2c2c>Дом был удален</color>",
                ["info_home_deleted"] = "<color=#49b50a>Дом: '{0}' был успешно удален</color>",
                ["info_command_homelist"] = "<color=#f11f1f>Дом: '{0}'(ID:{1}). Позиция: {2}</color>",
                ["info_command_homelist_home_dexists"] = "<color=#49b50a>У вас нет сохраненных домов. Используйте /sethome [homename]</color>",
                ["error_coomand_tphome_incorrect"] = "<color=#ba2c2c>Неверный синтаксис. Пример: /home [homename]</color>",
                ["error_home_does_not_exists"] = "<color=#ba2c2c>Дома с именем: '{0}' не существует.</color>",
                ["info_home_deleted_other_bb"] = "<color=#ba2c2c>Этот дом Вам больше не принадлежит. Дом удален</color>",
                ["info_tth_request_created"] = "<color=#f11f1f>Запрос принят. Вы будете телепортированы домой через {0} секунд</color>",
                ["info_tth_already_wait"] = "<color=#ba2c2c>В данный момент вы уже ожидаете телепортации домой</color>",
                ["info_tth_request_finished"] = "<color=#49b50a>Вы были возвращены домой. Осталось возвращений: {0}</color>",
                ["info_tth_request_cancelled"] = "<color=#ba2c2c>Телепорт домой был отменен</color>",
                ["info_tth_request_notfound"] = "<color=#ba2c2c>Доступные запросы отсутствуют</color>",
                ["error_tth_unlimited"] = "<color=#ba2c2c>Лимит использований исчерпан. Попробуйте через: {0}ч. {1}м. {2}с.</color>",
                ["error_pickup_registered_home"] = "<color=#ba2c2c>Нельзя подобрать спальный мешок, привязанный к дому. Используйте /removehome [homename]</color>",
                ["error_pickup_other_bag"] = "<color=#ba2c2c>Нельзя подбирать чужие спальные мешки</color>",
                ["error_decline_assign_bed"] = "<color=#ba2c2c>Нельзя дарить спальные мешки привязанные к дому</color>",
                ["info_home_destroyed"] = "<color=#ba2c2c>Один из ваших домов был уничтожен</color>",
                ["error_player_in_rt"] = "<color=#ba2c2c>Нельзя телепортироваться в зоне РТ</color>",
                ["error_target_in_rt"] = "<color=#ba2c2c>Ваша цель находится в зоне РТ</color>",
                ["error_player_in_noescape"] = "<color=#ba2c2c>Вам запрещено сейчас телепортироваться</color>",
                ["error_target_in_noescape"] = "<color=#ba2c2c>Вашей цели запрещено сейчас телепортироваться</color>",
                ["error_player_in_raidblock"] = "<color=#ba2c2c>Запрещено использовать телепорт во время рейда</color>",
                ["error_target_in_raidblocked"] = "<color=#ba2c2c>Ваша цель учавствует в рейде, попробуйте позже</color>",
                ["error_player_in_combatblock"] = "<color=#ba2c2c>В бою запрещено использовать телепорт</color>",
                ["error_target_in_combatblock"] = "<color=#ba2c2c>Ваша цель в бою, попробуйте позже</color>",
                ["info_create_tth_remaining"] = "<color=#ba2c2c>Лимит на использование телепортов домой был полностью израсходован</color>",
                ["info_create_ttp_remaining"] = "<color=#ba2c2c>Лимит телепортов к игрокам был полностью израсходован</color>",
                ["incorrect_command_tp"] = "<color=#ba2c2c>Некорректное использование команды /tp.",
                ["error_player_isnt_admin"] = "<color=#ba2c2c>Для использования этой команды Вы должны обладать правами администратора</color>",
                ["error_parse_coords_failed_self"] = "<color=#ba2c2c>Не удалось распознать введенные координаты. Проверьте корректность ввода</color>",
                ["info_gui_enabled"] = "<color=#49b50a>Вы включили GUI уведомления</color>",
                ["info_gui_disabled"] = "<color=#ba2c2c>Вы отключили GUI уведомления</color>",
                ["info_all_enabled"] = "<color=#49b50a>Теперь все игроки могут отправить Вам запрос на телепортацию</color>",
                ["info_all_disabled"] = "<color=#ba2c2c>Вы недоступны для запроса на телепортацию для всех</color>",
                ["info_clan_enabled"] = "<color=#49b50a>Теперь соклановцы могут отправлять Вам запрос на телепортацию</color>",
                ["info_clan_disabled"] = "<color=#ba2c2c>Вы не доступны для запросов на телепортацию от соклановцев</color>",
                ["info_friend_enabled"] = "<color=#49b50a>Теперь друзья могут отправлять Вам запросы на телепортацию</color>",
                ["info_friend_disabled"] = "<color=#ba2c2c>Вы недоступны для запроса на телепортацию для друзей</color>",
                ["player_disabled_all_teleport"] = "<color=#ba2c2c>Игрок запретил отправлять ему запросы на телепортацию</color>",
                ["player_disabled_clan_teleport"] = "<color=#ba2c2c>Игрок запретил соклановцам телепортироваться к нему</color>",
                ["player_disabled_friend_teleport"] = "<color=#ba2c2c>Игрок запретил друзья телепортироваться к нему</color>",
                ["error_target_in_duel"] = "<color=#ba2c2c>В данный момент ваша цель принимает участие в дуэли. Попробуйте позже</color>",
                ["error_player_in_duel"] = "<color=#ba2c2c>Вы не можете использовать систему телепорта во время дуэли</color>",
            }, this);
        }
        #endregion

        #region Custom Structs
        public enum Remainings
        {
            TeleportToHome,
            TeleportToPlayer,
            NextTTPLimit,
            NextTTHLimit
        }
        private class PlayerPluginData
        {
            public string ID           { get; set; }
            public string Name         { get; set; }
            public int TTPLimit        { get; set; }
            public int TTHLimit        { get; set; }
            public bool GuiEnabled     { get; set; }
            public bool FriendsEnabled { get; set; }
            public bool ClanEnabled    { get; set; }
            public bool AllEnabled     { get; set; }

            public Dictionary<string, HomeObject> Homes   { get; set; }
            public TimerBase NextTeleportRemaining     { get; set; }
            public TimerBase NextHomeTeleportRemaining { get; set; }
            public TimerBase NextTTPLimitRemaining     { get; set; }
            public TimerBase NextTTHLimitRemaining     { get; set; }

            public PlayerPluginData() : this("-1", "-1", -1, -1, new Dictionary<string, HomeObject>(), new TimerBase(), new TimerBase(), new TimerBase(), new TimerBase()) { }
            public PlayerPluginData(string id, string name, int ttpl, int tthl, Dictionary<string, HomeObject> homes, TimerBase nextTR, TimerBase nextHTR, TimerBase nttp, TimerBase ntth)
            {
                ID = id;
                Name = name;
                Homes = homes;
                TTPLimit = ttpl;
                TTHLimit = tthl;
                NextTeleportRemaining = nextTR;
                NextHomeTeleportRemaining = nextHTR;
                NextTTPLimitRemaining = nttp;
                NextTTHLimitRemaining = ntth;
                GuiEnabled = true;
                FriendsEnabled = true;
                ClanEnabled = true;
                AllEnabled = true;
            }

            public void CreateRemaining(Remainings type, PluginTimers timer, int seconds, Action callback)
            {
                if(type == Remainings.TeleportToHome)
                {
                    NextHomeTeleportRemaining.Instantiate(timer, seconds, callback);
                }
                else if (type == Remainings.TeleportToPlayer)
                {
                    NextTeleportRemaining.Instantiate(timer, seconds, callback);
                }
                else if(type == Remainings.NextTTPLimit)
                {
                    NextTTPLimitRemaining.Instantiate(timer, seconds, callback);
                }
                else if(type == Remainings.NextTTHLimit)
                {
                    NextTTHLimitRemaining.Instantiate(timer, seconds, callback);
                }
                else
                {
                    return;
                }
            }
            public void CreateHome(int id, string name, BasePlayer player, int limit, bool createBag)
            {
                if(Homes.Count >= limit)
                {
                    return;
                }

                if(Homes.ContainsKey(name))
                {
                    return;
                }

                Homes.Add(name, new HomeObject(id, name, player.transform.position, player, createBag));
            }
            public void RestoreHome(string name, SleepingBag bag)
            {
                if(Homes.ContainsKey(name))
                {
                    Homes[name].Bag = bag;
                }
            }
            public void RemoveHome(string name)
            {
                if(!Homes.ContainsKey(name))
                {
                    return;
                }

                if (Homes[name].Bag != null)
                {
                    Homes[name].Bag.enabled = false;
                    Homes[name].Bag.Kill();
                    Homes[name].Bag = null;

                    Homes.Remove(name);
                }
            }

            public void PrepareToSave()
            {
                NextHomeTeleportRemaining.Destroy();
                NextTeleportRemaining.Destroy();
                NextTTPLimitRemaining.Destroy();
                NextTTHLimitRemaining.Destroy();

                foreach(var home in Homes)
                {
                    home.Value.Bag = null;
                }
            }
        }

        private class TeleportObject
        {
            public int ID                     { get; set; }
            public int Seconds                { get; set; }
            public bool Accepted              { get; set; }

            public PlayerPluginData Initiator { get; private set; }
            public PlayerPluginData Target    { get; private set; }
            public TimerBase        Remaining { get; private set; }

            public TeleportObject(PlayerPluginData init, PlayerPluginData target, int secs)
            {
                Initiator = init;
                Target    = target;
                Seconds   = secs;
                Remaining = new TimerBase();
            }

            public void Instantiate(PluginTimers timer, Action callback, Action onTick = null)
            {
                Remaining.Instantiate(timer, Seconds, callback, onTick);
            }
        } 
        private class HomeObject
        {
            public int     ID       { get; set; }
            public string  Name     { get; set; }
            public Vector3 Position { get; set; }
            public SleepingBag Bag  { get; set; }

            public HomeObject()
            {
                ID = -1;
                Name = "-1";
                Position = new Vector3();
                Bag = null;
            }
            public HomeObject(int id, string name, Vector3 pos, BasePlayer player, bool createBag)
            {
                ID = id;
                Name = name;
                Position = pos;

                if (createBag) Bag = CreateSleepingBag(player);
            }

            private SleepingBag CreateSleepingBag(BasePlayer player)
            {
                SleepingBag sleepingBag =
                GameManager.server.CreateEntity("assets/prefabs/deployable/sleeping bag/sleepingbag_leather_deployed.prefab", player.transform.position,
                    player.transform.localRotation) as SleepingBag;
                if (sleepingBag == null) return null;
                sleepingBag.transform.Rotate(player.transform.localEulerAngles);
                sleepingBag.deployerUserID = player.userID;
                sleepingBag.niceName = Name;
                sleepingBag.OwnerID = player.userID;
                sleepingBag.Spawn();

                return sleepingBag;
            }
        }
        private class HomeTeleportObject
        {
            public int ID { get; set; }
            public int Seconds { get; set; }
            public TimerBase Remaining { get; set; }
            public PlayerPluginData Owner { get; set; }
            public Vector3 Position { get; set; }

            public HomeTeleportObject(PlayerPluginData owner, int secs, Vector3 pos)
            {
                Owner = owner;
                Seconds = secs;
                Remaining = new TimerBase();
                Position = pos;
            }

            public void Instantiate(PluginTimers timer, Action callback, Action onTick = null)
            {
                Remaining.Instantiate(timer, Seconds, callback, onTick);
            }
        }

        private class TimerBase
        {
            public Timer  Object    { get; set; }
            public int    Remaining { get; set; }
            public bool   IsEnabled { get; set; }

            public TimerBase()
            {
                Remaining = 0;
                IsEnabled = false;
            }

            public void Instantiate(PluginTimers @object, int secs, Action callBackAction, Action onTick = null)
            {
                Object = @object.Repeat(1, secs, () =>
                {
                    secs--;
                    Remaining = secs;

                    if (onTick != null) onTick();

                    if (secs == 0)
                    {
                        IsEnabled = false;
                        callBackAction();
                    }
                    else IsEnabled = true;
                });
            }

            public void Destroy()
            {
                if (Object != null)
                {
                    Object.Destroy();
                    Object = null;
                }

                IsEnabled = false;
            }
        }
        #endregion

        #region Initialization
        public Teleport()
        {
            m_ActivePlayers           = new Dictionary<string, PlayerPluginData>();
            m_TeleportToPlayerWaiters = new Dictionary<int, TeleportObject>();
            m_TeleportToHomeWaiters   = new Dictionary<int, HomeTeleportObject>();
        }
        private void RegisterPermissions()
        {
            foreach(var perm in m_Config.PermissionSettings)
            {
                if(!permission.PermissionExists(perm.Key, this))
                {
                    permission.RegisterPermission(perm.Key, this);

                    if (m_Config.EnablePrintPermissionsInfo)
                    {
                        PrintWarning($"Create new permission: '{perm.Key}' with settings:");

                        foreach (var prefix in perm.Value)
                        {
                            foreach (var settings in prefix.Value)
                            {
                                PrintWarning($"[{settings.Key}] => {settings.Value}");
                            }
                        }
                    }
                }
            }
        }
        #endregion

        #region Hooks
        void Loaded()
        {
            LoadAllPlayers();
        }

        /// <summary>
        /// Происходит при выгрузке плагина
        /// </summary>
        void Unload()
        {
            SaveAllPlayers();
        }

        /// <summary>
        /// Происходит при инициализации игрока
        /// </summary>
        /// <param name="player"></param>
        void OnPlayerInit(BasePlayer player)
        {
            LoadPlayer(player);
        }

        /// <summary>
        /// Происходит при отключении игрока от сервера
        /// </summary>
        /// <param name="player"></param>
        /// <param name="reason"></param>
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if(IsAlreadyWait(player, true) || IsAlreadyWait(player, false))
            {
                CancelTTPRequest(player.UserIDString);
            }

            if(IsWaitTeleportToHome(player))
            {
                CancelTTHRequest(player.UserIDString);
            }

            SavePlayer(player);
        }
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null && info == null)
            {
                return;
            }

            BasePlayer victim = entity?.ToPlayer();
            BasePlayer attacker = info?.InitiatorPlayer;

            if (victim == null)
            {
                return;
            }

            if (attacker == null)
            {
                return;
            }

            if (m_Config.AllowTeleportAfterDamage)
            {
                return;
            }

            if (IsAlreadyWait(victim, true) || IsAlreadyWait(victim, false))
            {
                TeleportObject data = GetTeleportData(GetPlayerFromActive(victim.UserIDString));
                if (data == null)
                {
                    data = GetTeleportData(GetPlayerFromActive(victim.UserIDString), false);
                }

                if(victim.UserIDString == data.Initiator.ID)
                {
                    SendReply(FindPlayer(data.Initiator.ID), GetMessage("error_player_received_damage", this));
                    SendReply(FindPlayer(data.Target.ID), GetMessage("error_target_received_damage", this));
                }
                else
                {
                    SendReply(FindPlayer(data.Initiator.ID), GetMessage("error_target_received_damage", this));
                    SendReply(FindPlayer(data.Target.ID), GetMessage("error_player_received_damage", this));
                }

                CancelTTPRequest(victim.UserIDString);
            }

            if (IsAlreadyWait(attacker, false) || IsAlreadyWait(attacker, true))
            {
                try
                {
                    TeleportObject data = GetTeleportData(GetPlayerFromActive(attacker.UserIDString));
                    if (data == null)
                    {
                        data = GetTeleportData(GetPlayerFromActive(attacker.UserIDString), false);
                    }

                    if(attacker.UserIDString == data.Initiator.ID)
                    {
                        SendReply(FindPlayer(data.Initiator.ID), GetMessage("error_player_start_damage", this));
                        SendReply(FindPlayer(data.Target.ID), GetMessage("error_target_start_damage", this));
                    }
                    else
                    {
                        SendReply(FindPlayer(data.Initiator.ID), GetMessage("error_target_start_damage", this));
                        SendReply(FindPlayer(data.Target.ID), GetMessage("error_player_start_damage", this));
                    }

                    CancelTTPRequest(attacker.UserIDString);
                }
                catch(Exception ex)
                {
                    PrintError(ex.Message);
                }
            }

            if(IsWaitTeleportToHome(victim))
            {
                HomeTeleportObject obj = GetHomeObjectFromWaiters(victim.UserIDString);

                SendReply(victim, GetMessage("error_tth_received_damage", this));

                CancelTTHRequest(victim.UserIDString);
            }

            if(IsWaitTeleportToHome(attacker))
            {
                HomeTeleportObject obj = GetHomeObjectFromWaiters(attacker.UserIDString);

                SendReply(attacker, GetMessage("error_tth_start_damage", this));

                CancelTTHRequest(attacker.UserIDString);
            }
        }
        object OnPlayerDie(BasePlayer player, HitInfo info)
        {
            if (player == null)
            {
                return null;
            }

            if (m_Config.AllowTeleportAfterDeath)
            {
                return null;
            }

            if (IsAlreadyWait(player, false) || IsAlreadyWait(player, true))
            {
                TeleportObject data = GetTeleportData(GetPlayerFromActive(player.UserIDString));
                if(data == null)
                {
                    data = GetTeleportData(GetPlayerFromActive(player.UserIDString), false);
                }

                SendReply(FindPlayer(data.Initiator.ID), GetMessage("error_player_is_death", this));
                SendReply(FindPlayer(data.Target.ID), GetMessage("error_target_is_death", this));

                CancelTTPRequest(player.UserIDString);
            }

            if (IsWaitTeleportToHome(player))
            {
                HomeTeleportObject obj = GetHomeObjectFromWaiters(player.UserIDString);

                SendReply(player, GetMessage("error_tth_player_die", this));

                CancelTTHRequest(player.UserIDString);
            }

            return null;
        }
        void OnEntityKill(BaseNetworkable entity)
        {
            if(entity.ShortPrefabName.Contains("foundation"))
            {
                RaycastHit hit;
                if (Physics.Raycast(entity.transform.position, Vector3.up, out hit))
                {
                    BaseEntity bagEntity = hit.GetEntity();

                    if (bagEntity != null)
                    {
                        if(bagEntity as SleepingBag)
                        {
                            string name = string.Empty;

                            foreach(var player in m_ActivePlayers)
                            {
                                if(bagEntity.OwnerID == FindPlayer(player.Value.ID).userID)
                                {
                                    bagEntity.Kill();

                                    break;
                                }
                            }
                        }
                    }
                }
            }

            return;
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is SleepingBag)
            {
                SleepingBag bagEntity = (SleepingBag)entity;

                string name = string.Empty;

                foreach (var player in m_ActivePlayers)
                {
                    if (bagEntity.OwnerID == FindPlayer(player.Value.ID).userID)
                    {
                        if (player.Value.Homes.Any((x) => x.Value.Position == bagEntity.transform.position))
                        {
                            if (IsWaitTeleportToHome(FindPlayer(player.Value.ID)))
                            {
                                CancelTTHRequest(player.Key);
                            }

                            var finded = player.Value.Homes.Where((x) => x.Value.Position == bagEntity.transform.position)?.First();
                            if (finded == null)
                            {
                                return;
                            }

                            name = finded.Value.Value?.Name;
                            if (name == null)
                            {
                                return;
                            }

                            bagEntity.enabled = false;
                            bagEntity.enableSaving = false;
                            bagEntity.Kill();

                            player.Value.RemoveHome(name);

                            SendReply(FindPlayer(player.Value.ID), GetMessage("info_home_destroyed", this));

                            break;
                        }
                    }
                }
            }
        }
        object CanRenameBed(BasePlayer player, SleepingBag bed, string bedName)
        {
            if(bed.OwnerID != player.userID)
            {
                SendReply(player, GetMessage("error_rename_other_bags", this));

                return player;
            }

            return null;
        }
        bool CanBeWounded(BasePlayer player, HitInfo info)
        {
            if (player == null) return false;
            if (m_Config.AllowTeleportInWounded) return false;

            if(IsAlreadyWait(player, true) || IsAlreadyWait(player, false))
            {
                var data = GetTeleportData(GetPlayerFromActive(player.UserIDString));
                if(data == null)
                {
                    data = GetTeleportData(GetPlayerFromActive(player.UserIDString), false);
                }

                SendReply(player, GetMessage("error_ttp_cancelled_player_after_wounded", this));
                SendReply(FindPlayer(data.Target.ID), GetMessage("error_ttp_cancelled_target_after_wounded", this));

                CancelTTPRequest(player.UserIDString);
            }

            if(IsWaitTeleportToHome(player))
            {
                SendReply(player, GetMessage("error_tth_cancelled_after_wounded", this));

                CancelTTHRequest(player.UserIDString);
            }

            return false;
        }
        bool CanPickupEntity(BasePlayer basePlayer, BaseCombatEntity entity)
        {
            if (basePlayer == null) return true;
            if (entity as SleepingBag)
            {
                if(entity.OwnerID != basePlayer.userID)
                {
                    SendReply(basePlayer, GetMessage("error_pickup_other_bag", this));

                    return false;
                }

                string name = string.Empty;

                foreach (var player in m_ActivePlayers)
                {
                    if (entity.OwnerID == FindPlayer(player.Value.ID).userID)
                    {
                        if (player.Value.Homes.Any((x) => x.Value.Position == entity.transform.position))
                        {
                            var temp = player.Value.Homes.Where((x) => x.Value.Position == entity.transform.position)?.First();
                            if (temp == null)
                            {
                                return false;
                            }
                            name = temp.Value.Value.Name;

                            SendReply(basePlayer, GetMessage("error_pickup_registered_home", this));

                            return false;
                        }
                    }
                }
            }

            return true;
        }
        object CanAssignBed(BasePlayer assigner, SleepingBag bagEntity, ulong targetPlayerId)
        {
            string name = string.Empty;

            foreach (var player in m_ActivePlayers)
            {
                if (bagEntity.OwnerID == FindPlayer(player.Value.ID).userID)
                {
                    if (player.Value.Homes != null)
                    {
                        name = string.Empty;
                        if(player.Value.Homes.Any((x) => x.Value.Position == bagEntity.transform.position))
                        {
                            name = player.Value.Homes.Where((x) => x.Value.Position == bagEntity.transform.position).First().Value.Name;
                        }

                        if (name != string.Empty)
                        {
                            SendReply(assigner, GetMessage("error_decline_assign_bed", this));

                            break;
                        }
                    }
                }
            }

            return null;
        }
        #endregion

        #region Commands
        [ChatCommand("tpr")]
        void CommandChatTPR(BasePlayer player, string command, string[] args)
        {
            if (player == null)
            {
                return;
            }

            if (args.Length != 1)
            {
                SendReply(player, GetMessage("error_command_tpr_incorrect", this));

                return;
            }

            player.SendConsoleCommand($"tp.request {args[0]}", this);
        }

        [ChatCommand("tpa")]
        void CommandChatTPA(BasePlayer player, string command, string[] args)
        {
            if (player == null)
            {
                return;
            }

            player.SendConsoleCommand($"tp.accept", this);
        }

        [ChatCommand("tpc")]
        void CommandChatTPC(BasePlayer player, string command, string[] args)
        {
            if (player == null)
            {
                return;
            }

            player.SendConsoleCommand($"tp.cancel", this);
        }

        [ChatCommand("home")]
        void CommandChatHomeObjective(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length < 1) return;

            switch(args[0])
            {
                case "set":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, lang.GetMessage("error_command_sethome_incorrect", this));

                            return;
                        }
                        else
                        {
                            SetHome(player, args[1]);
                        }

                        break;
                    }

                case "remove":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, GetMessage("error_command_removehome_incorrect", this));

                            return;
                        }
                        else
                        {
                            RemoveHome(player, args[1]);
                        }

                        break;
                    }

                case "list":
                    {
                        ShowHomelist(player);

                        break;
                    }

                default:
                    {
                        TPToHome(player, args[0]);

                        break;
                    }
            }
        }

        void SetHome(BasePlayer player, string homename)
        {
            if (player == null)
            {
                return;
            }
            if (!m_Config.AllowHomeSystem)
            {
                SendReply(player, GetMessage("error_home_system_disabled", this));

                return;
            }

            var data = GetPlayerFromActive(player.UserIDString);
            if (data.Homes.Count >= GetSHLimit(player.UserIDString))
            {
                SendReply(player, lang.GetMessage("error_max_home_limits", this));

                return;
            }
            if (data.Homes.ContainsKey(homename))
            {
                SendReply(player, lang.GetMessage("error_home_already_exists", this));

                return;
            }

            BaseEntity foundation = GetFoundation(player.transform.position);
            if(foundation == null)
            {
                if (m_Config.AllowSaveHomeOnlyFundament)
                {
                    SendReply(player, GetMessage("error_sethome_only_foundation", this));

                    return;
                }
            }
            else
            {
                if(m_Config.AllowSaveHomeOnClanFundament)
                {
                    if (!IsClanMember(player.userID, foundation.OwnerID))
                    {
                        SendReply(player, GetMessage("error_sethome_save_only_clan_foundation", this));

                        return;
                    }
                }

                if (m_Config.AllowSaveHomeOnFriendFundament)
                {
                    if (!IsFriends(player.userID, foundation.OwnerID))
                    {
                        SendReply(player, GetMessage("error_sethome_save_only_friend_foundation", this));

                        return;
                    }
                }

                if (player.userID != foundation.OwnerID)
                {
                    if(!m_Config.AllowSaveHomeOnlyFundament)
                    {
                        SendReply(player, GetMessage("error_sethome_save_only_clan_foundation", this));

                        return;
                    }
                }
                else { }
            }

            if(IsPlayerInBB(player) && !m_Config.AllowSaveHomeOnBB)
            {
                SendReply(player, GetMessage("error_sethome_save_on_bb", this));

                return;
            }

            data.CreateHome(GenerateID(), homename, player, GetSHLimit(player.UserIDString), m_Config.CreateBagAfterHomeSave);
            SendReply(player, string.Format(GetMessage("info_home_created", this), homename));
        }
        void RemoveHome(BasePlayer player, string homename)
        {
            if (player == null) return;
            var data = GetPlayerFromActive(player.UserIDString);
            if(!data.Homes.ContainsKey(homename))
            {
                SendReply(player, string.Format(GetMessage("error_saved_home_notfound", this), homename));

                return;
            }
            if(data.Homes[homename].Bag == null)
            {
                SendReply(player, GetMessage("error_home_killed_automatic_deleted", this));

                data.Homes.Remove(homename);

                return;
            }

            if(IsWaitTeleportToHome(player))
            {
                SendReply(player, GetMessage("error_home_deleted_cancelled_teleport", this));

                CancelTTHRequest(player.UserIDString);
            }

            foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
            {
                if (Vector3.Distance(sleepingBag.transform.position, data.Homes[homename].Position) < 1)
                {
                    sleepingBag.Kill();
                    break;
                }
            }

            data.RemoveHome(homename);
            SendReply(player, string.Format(GetMessage("info_home_deleted", this), homename));
        }
        void ShowHomelist(BasePlayer player)
        {
            if(player == null)
            {
                return;
            }

            if (!m_Config.AllowHomeSystem)
            {
                SendReply(player, GetMessage("error_home_system_disabled", this));

                return;
            }

            var data = GetPlayerFromActive(player.UserIDString);
            if (data == null) return;

            if (data.Homes.Count > 0)
            {
                foreach (var home in data.Homes)
                {
                    SendReply(player, string.Format(GetMessage("info_command_homelist", this), home.Value.Name, home.Value.ID, home.Value.Position));
                }
            }
            else
            {
                SendReply(player, GetMessage("info_command_homelist_home_dexists", this));
            }
        }
        void TPToHome(BasePlayer player, string homename)
        {
            if (player == null) return;
            if (!m_Config.AllowHomeSystem)
            {
                SendReply(player, GetMessage("error_home_system_disabled", this));

                return;
            }

            string checkResult = CheckPlayer(player, true, false, false);
            if (checkResult != "-1")
            {
                SendReply(player, checkResult);

                return;
            }

            if (IsUnlimited(player, true))
            {
                var finded = GetPlayerFromActive(player.UserIDString);
                if (finded != null)
                {
                    SendReply(player, string.Format(GetReadeableSeconds(finded.NextTTHLimitRemaining.Remaining, true)));

                    return;
                }
            }

            if (IsRemaining(player, true))
            {
                SendReply(player, string.Format(GetMessage("error_tth_cooldown", this), GetPlayerFromActive(player.UserIDString).NextHomeTeleportRemaining.Remaining));

                return;
            }

            var data = GetPlayerFromActive(player.UserIDString);
            if(!data.Homes.ContainsKey(homename))
            {
                SendReply(player, string.Format(GetMessage("error_home_does_not_exists", this), homename));

                return;
            }

            if (data.Homes[homename].Bag == null)
            {
                if (m_Config.CreateBagAfterHomeSave)
                {
                    SendReply(player, GetMessage("error_home_killed_automatic_deleted", this));

                    data.Homes.Remove(homename);

                    return;
                }
            }

            if (m_Config.CreateBagAfterHomeSave)
            {
                if (IsBagInBB(data.Homes[homename].Bag, player))
                {
                    if (IsWaitTeleportToHome(player))
                    {
                        SendReply(player, GetMessage("error_home_deleted_cancelled_teleport", this));

                        CancelTTHRequest(player.UserIDString);
                    }

                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, data.Homes[homename].Position) < 1)
                        {
                            sleepingBag.enabled = false;
                            sleepingBag.Kill(BaseNetworkable.DestroyMode.None);
                            sleepingBag.DestroyShared();

                            UnityEngine.Object.Destroy(sleepingBag);

                            break;
                        }
                    }

                    data.RemoveHome(homename);
                    SendReply(player, GetMessage("info_home_deleted_other_bb", this));

                    return;
                }
            }

            CreateTTHRequest(GetPlayerFromActive(player.UserIDString), homename);
        }

        [ChatCommand("homes")]
        void CommandChatAdminHomelist(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!player.IsAdmin)
            {
                SendReply(player, GetMessage("error_player_isnt_admin", this));

                return;
            }
            BasePlayer target = FindPlayer(args[0]);
            if (target == null)
            {
                SendReply(player, GetMessage("error_ttp_incorrect_target", this));

                return;
            }
            var data = GetPlayerFromActive(target.UserIDString);
            if (data == null) return;

            if (data.Homes.Count > 0)
            {
                foreach (var home in data.Homes)
                {
                    SendReply(player, string.Format(GetMessage("info_command_homelist", this), home.Value.Name, home.Value.ID, home.Value.Position));
                }
            }
            else
            {
                SendReply(player, $"У игрока: '{target.displayName}' нет сохраненных домов");
            }
        }

        [ChatCommand("tp")]
        void CommandChatTP_Admin(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if(args.Length < 1)
            {
                SendReply(player, GetMessage("incorrect_command_tp", this));

                return;
            }
            if(!player.IsAdmin)
            {
                SendReply(player, GetMessage("error_player_isnt_admin", this));

                return;
            }
            if(args.Length == 1)
            {
                BasePlayer target = FindPlayer(args[0]);
                if(target == null)
                {
                    SendReply(player, GetMessage("error_ttp_incorrect_target", this));

                    return;
                }
                ClearTeleport(player, target.transform.position);
            }
            if(args.Length == 2)
            {
                BasePlayer victim = FindPlayer(args[0]);
                BasePlayer target = FindPlayer(args[1]);
                if (victim == null || target == null)
                {
                    SendReply(player, GetMessage("error_ttp_incorrect_target", this));

                    return;
                }
                ClearTeleport(victim, target.transform.position);
            }
            if(args.Length == 3)
            {
                float[] coords = new float[3];
                if(!float.TryParse(args[0], out coords[0]) || 
                    !float.TryParse(args[1], out coords[1]) ||
                    !float.TryParse(args[2], out coords[2]))
                {
                    SendReply(player, GetMessage("error_parse_coords_failed_self", this));

                    return;
                }

                ClearTeleport(player, new Vector3(coords[0], coords[1], coords[2]));
            }
            if(args.Length == 4)
            {
                BasePlayer target = FindPlayer(args[0]);
                if(target == null)
                {
                    SendReply(player, GetMessage("error_ttp_incorrect_target", this));

                    return;
                }

                float[] coords = new float[3];
                if (!float.TryParse(args[1], out coords[0]) ||
                    !float.TryParse(args[2], out coords[1]) ||
                    !float.TryParse(args[3], out coords[2]))
                {
                    SendReply(player, GetMessage("error_parse_coords_failed_self", this));

                    return;
                }

                ClearTeleport(target, new Vector3(coords[0], coords[1], coords[2]));
            }

            if (m_Config.EnableAdminCommandsLogging)
            {
                string argsWithSeparator = "/tp ";
                foreach(var arg in args)
                {
                    argsWithSeparator += $"{arg} ";
                }

                LogToFile(m_Config.AdminCommandsLoggingFile, $"Admin: '{player.displayName}(ID: {player.UserIDString})' used a command: '{argsWithSeparator}' in [{DateTime.Now.Day}/{DateTime.Now.Month}/{DateTime.Now.Year}]>>[{DateTime.Now.Hour}:{DateTime.Now.Minute}:{DateTime.Now.Second}]", this);
            }
        }

        [ChatCommand("tpswitch")]
        void CommandChatGuiSwitch(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            PlayerPluginData data = GetPlayerFromActive(player.UserIDString);
            if (data == null) return;
            if (args.Count() < 1) return;

            switch(args[0].ToLower())
            {
                case "gui":
                    {
                        data.GuiEnabled = !data.GuiEnabled;
                        if (data.GuiEnabled)
                        {
                            SendReply(player, GetMessage("info_gui_enabled", this));
                        }
                        else
                        {
                            SendReply(player, GetMessage("info_gui_disabled", this));
                        }

                        break;
                    }

                case "friends":
                    {
                        data.FriendsEnabled = !data.FriendsEnabled;
                        if(data.FriendsEnabled)
                        {
                            SendReply(player, GetMessage("info_friend_enabled", this));
                        }
                        else
                        {
                            SendReply(player, GetMessage("info_friend_disabled", this));
                        }

                        break;
                    }

                case "clan":
                    {
                        data.ClanEnabled = !data.ClanEnabled;
                        if (data.ClanEnabled)
                        {
                            SendReply(player, GetMessage("info_clan_enabled", this));
                        }
                        else
                        {
                            SendReply(player, GetMessage("info_clan_disabled", this));
                        }

                        break;
                    }

                case "all":
                    {
                        data.AllEnabled = !data.AllEnabled;
                        if (data.AllEnabled)
                        {
                            SendReply(player, GetMessage("info_all_enabled", this));
                        }
                        else
                        {
                            SendReply(player, GetMessage("info_all_disabled", this));
                        }

                        break;
                    }
            }
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("tp.request")]
        private void CmdConsoleTPRequest(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg?.Player();

            if (player == null) return;

            if (!m_Config.AllowTeleportSystem)
            {
                SendReply(player, GetMessage("error_teleport_system_disabled", this));

                return;
            }

            string checkResult = CheckPlayer(player, true, false, false);
            if (checkResult != "-1")
            {
                SendReply(player, checkResult);

                return;
            }

            BasePlayer target = FindPlayer(arg.Args[0]);
            if (target == null)
            {
                SendReply(player, GetMessage("error_ttp_incorrect_target", this));

                return;
            }

            if (target == player)
            {
                SendReply(player, GetMessage("error_ttp_self", this));

                return;
            }

            string checkResultTarget = CheckPlayer(target, false, true);
            if (checkResultTarget != "-1")
            {
                SendReply(player, checkResultTarget);

                return;
            }
            PlayerPluginData targetData = GetPlayerFromActive(target.UserIDString);

            if (!targetData.AllEnabled)
            {
                SendReply(player, GetMessage("player_disabled_all_teleport", this));

                return;
            }
            if (m_Config.AllowTeleportOnlyClan)
            {
                if (!IsClanMember(player.userID, target.userID))
                {
                    SendReply(player, GetMessage("error_ttp_only_clan", this));

                    return;
                }
                else
                {
                    if (!targetData.ClanEnabled)
                    {
                        SendReply(player, GetMessage("player_disabled_clan_teleport", this));

                        return;
                    }
                }
            }
            if(m_Config.AllowTeleportOnlyFriends)
            {
                if(!IsFriends(player.userID, target.userID))
                {
                    SendReply(player, GetMessage("error_ttp_only_friend", this));

                    return;
                }
                else
                {
                    if(!targetData.FriendsEnabled)
                    {
                        SendReply(player, GetMessage("player_disabled_friends_teleport", this));

                        return;
                    }
                }
            }

            CreateTTPRequest(GetPlayerFromActive(player.UserIDString), GetPlayerFromActive(target.UserIDString));
        }
        [ConsoleCommand("tp.cancel")]
        private void CmdConsoleTPCancel(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg?.Player();

            if (player == null)
            {
                return;
            }

            DestroyTeleportRequest(player);

            if(IsAlreadyWait(player, true) || IsAlreadyWait(player, false))
                CancelTTPRequest(player.UserIDString);

            if (IsWaitTeleportToHome(player))
                CancelTTHRequest(player.UserIDString);
        }
        [ConsoleCommand("tp.accept")]
        private void CmdConsoleTPAccept(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg?.Player();

            if (player == null)
            {
                return;
            }

            DestroyTeleportRequest(player);

            string checkResult = CheckPlayer(player, true, true);
            if (checkResult != "-1")
            {
                SendReply(player, checkResult);

                return;
            }

            AppendTTPRequest(GetTeleportData(player.UserIDString));
        }
        #endregion

        #region Data
        private void LoadAllPlayers()
        {
            PrintWarning("Load all players from load plugin ...");

            int count = 0;
            foreach(var player in BasePlayer.activePlayerList)
            {
                LoadPlayer(player);
                count++;
            }

            PrintWarning($"Loaded {count} players !");
        }
        private void SaveAllPlayers()
        {
            int count = 0;

            foreach(var player in BasePlayer.activePlayerList)
            {
                if(m_ActivePlayers.ContainsKey(player.UserIDString))
                {
                    SavePlayer(player, true);
                    count++;
                }
                else
                {
                    PrintError($"Player: '{player.displayName}({player.UserIDString})' exists in base active list, but not exists in local active list !");
                }
            }

            PrintWarning($"Save {count} players !");
        }
        private void LoadPlayer(BasePlayer player)
        {
            DynamicConfigFile plDataFile = Interface.Oxide.DataFileSystem.GetFile($"{Title}\\{player.UserIDString}");
            plDataFile.Settings.Converters.Add(Converter);

            PlayerPluginData data = plDataFile.ReadObject<PlayerPluginData>();

            if (data.ID == "-1")
            {
                data = null;
                data = new PlayerPluginData(player.UserIDString, player.displayName, GetTTPLimit(player.UserIDString), GetTTHLimit(player.UserIDString), new Dictionary<string, HomeObject>(), new TimerBase(), new TimerBase(), new TimerBase(), new TimerBase());

                PrintWarning($"Creating new data for player: '{player.displayName}({player.UserIDString})'");
            }

            if (data.Homes.Count > 0)
            {
                foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                {
                    data.RestoreHome(sleepingBag.niceName, sleepingBag);

                    if (!data.Homes.ContainsKey(sleepingBag.niceName))
                    {
                        if(m_Config.CreateBagAfterHomeSave)
                            PrintWarning($"Duplicate sleeping bag for player: {player.displayName}({player.UserIDString})");
                    }
                    else { }
                }
            }
            if (m_ActivePlayers.ContainsKey(player.UserIDString))
            {
                m_ActivePlayers.Remove(player.UserIDString);

                PrintError($"Conflict players in active structure. Old object of player: {player.displayName} has been deleted");
            }
            if (data.NextTeleportRemaining.Remaining > 0)
            {
                data.CreateRemaining(Remainings.TeleportToPlayer, timer, data.NextTeleportRemaining.Remaining, () =>
                {
                    SendReply(player, GetMessage("info_ttp_cooldown_reseted", this));
                });
            }
            if (data.NextHomeTeleportRemaining.Remaining > 0)
            {
                data.CreateRemaining(Remainings.TeleportToHome, timer, data.NextHomeTeleportRemaining.Remaining, () =>
                {
                    SendReply(player, GetMessage("info_tth_cooldown_reseted", this));
                });
            }
            if (data.NextTTPLimitRemaining.Remaining > 0)
            {
                data.CreateRemaining(Remainings.NextTTPLimit, timer, data.NextTTPLimitRemaining.Remaining, () =>
                {
                    data.TTPLimit = GetTTPLimit(data.ID);

                    SendReply(player, GetMessage("info_ttp_limit_reseted", this));
                });
            }
            if (data.NextTTHLimitRemaining.Remaining > 0)
            {
                data.CreateRemaining(Remainings.NextTTHLimit, timer, data.NextTTHLimitRemaining.Remaining, () =>
                {
                    data.TTHLimit = GetTTHLimit(data.ID);

                    SendReply(player, GetMessage("info_tth_limit_reseted", this));
                });
            }
            m_ActivePlayers.Add(player.UserIDString, data);
        }
        private void SavePlayer(BasePlayer player, bool all = false)
        {
            if(m_ActivePlayers.ContainsKey(player.UserIDString))
            {
                m_ActivePlayers[player.UserIDString].PrepareToSave();

                Interface.Oxide.DataFileSystem.WriteObject($"{Title}\\{player.UserIDString}", m_ActivePlayers[player.UserIDString]);

                if(!all)
                {
                    m_ActivePlayers.Remove(player.UserIDString);
                }
            }
        }
        #endregion

        #region Home System Instruments
        private void ShowHomes(BasePlayer target, bool isAdminCheck)
        { 

        }
        private void CreateTTHRequest(PlayerPluginData initiator, string name)
        {
            if(!IsWaitTeleportToHome(FindPlayer(initiator.ID)))
            {
                HomeTeleportObject obj = new HomeTeleportObject(initiator, GetWaitTTHSeconds(initiator.ID), initiator.Homes[name].Position);
                obj.ID = GenerateID();
                m_TeleportToHomeWaiters.Add(obj.ID, obj);

                SendReply(FindPlayer(initiator.ID), string.Format(GetMessage("info_tth_request_created", this), obj.Seconds));

                PlaySound(FindPlayer(initiator.ID), "home_teleport");

                obj.Instantiate(timer, () =>
                {
                    FindPlayer(initiator.ID).StartSleeping();
                    timer.Once(0.1f, () =>
                    {
                        FinishedTTHRequest(obj);
                    });
                }, () =>
                {
                    if (initiator.GuiEnabled && m_Config.EnableGUI)
                        RefreshTeleportTimer(FindPlayer(initiator.ID), obj.Remaining.Remaining, "ДОМОЙ");
                });
            }
            else
            {
                SendReply(FindPlayer(initiator.ID), GetMessage("info_tth_already_wait", this));

                return;
            }
        }
        private void FinishedTTHRequest(HomeTeleportObject obj)
        {
            BasePlayer owner = FindPlayer(obj.Owner.ID);

            CargoShip ship = owner.GetComponentInParent<CargoShip>();
            if(ship != null)
            {
                ship.RemoveChild(owner);
                ship.UpdateNetworkGroup();
                ship.SendNetworkUpdateImmediate();
                owner.SetParent(null);
            }

            var data = GetPlayerFromActive(obj.Owner.ID);
            HomeObject home = data.Homes.Where((x) => x.Value.Position == obj.Position)?.First().Value;

            if (home.Bag == null && m_Config.CreateBagAfterHomeSave)
            {
                SendReply(owner, GetMessage("error_home_killed_automatic_deleted", this));

                data.Homes.Remove(home.Name);

                return;
            }
            
            string result = CheckPlayer(owner, true, false);
            if (result != "-1")
            {
                SendReply(owner, result);

                CancelTTHRequest(owner.UserIDString);

                return;
            }

            DestroyTeleportTimer(owner);
            ClearTeleport(owner, obj.Position);

            GetPlayerFromActive(obj.Owner.ID).CreateRemaining(Remainings.TeleportToHome, timer, GetTTHRemaining(obj.Owner.ID), () =>
            {
                SendReply(owner, GetMessage("info_tth_cooldown_reseted", this));
            });

            if(GetPlayerFromActive(obj.Owner.ID).TTHLimit > 0)
                GetPlayerFromActive(obj.Owner.ID).TTHLimit--;

            if (GetPlayerFromActive(obj.Owner.ID).TTHLimit <= 0)
            {
                SendReply(owner, GetMessage("info_create_tth_remaining", this));

                GetPlayerFromActive(obj.Owner.ID).CreateRemaining(Remainings.NextTTHLimit, timer, m_Config.DefaultLimitsUpdated, () =>
                {
                    GetPlayerFromActive(obj.Owner.ID).TTHLimit = GetTTHLimit(obj.Owner.ID);

                    SendReply(FindPlayer(obj.Owner.ID), GetMessage("info_ttp_limit_reseted", this));
                });
            }

            PlaySound(FindPlayer(obj.Owner.ID), "home_teleport");

            SendReply(owner, string.Format(GetMessage("info_tth_request_finished", this), GetPlayerFromActive(owner.UserIDString).TTHLimit));

            obj.Remaining.Destroy();
            m_TeleportToHomeWaiters.Remove(obj.ID);
        }
        private void CancelTTHRequest(string id)
        {
            if (IsWaitTeleportToHome(FindPlayer(id)))
            {
                var data = GetHomeObjectFromWaiters(id);

                DestroyTeleportTimer(FindPlayer(id));

                data.Remaining.Destroy();
                m_TeleportToHomeWaiters.Remove(data.ID);

                SendReply(FindPlayer(id), GetMessage("info_tth_request_cancelled", this));
            }
            else
            {
                SendReply(FindPlayer(id), GetMessage("info_tth_request_notfound", this));
            }
        }
        private HomeTeleportObject GetHomeObjectFromWaiters(string id)
        {
            if(m_TeleportToHomeWaiters.Any((x) => x.Value.Owner.ID == id))
            {
                return m_TeleportToHomeWaiters.Where((x) => x.Value.Owner.ID == id).First().Value;
            }
            else
            {
                return null;
            }
        }
        private bool IsWaitTeleportToHome(BasePlayer player)
        {
            if(GetHomeObjectFromWaiters(player.UserIDString) != null)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        #endregion

        #region Plugin Instruments
        private static void ClearTeleport(BasePlayer player, Vector3 position)
        {
            if (player.net?.connection != null)
            {
                player.ClientRPCPlayer(null, player, "StartLoading");
            }
            player.StartSleeping();
            player.MovePosition(position);

            if (player.net?.connection != null)
            {
                player.ClientRPCPlayer(null, player, "ForcePositionTo", position);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            }

            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null)
            {
                return;
            }
            player.SendFullSnapshot();
        }
        private string CheckPlayer(BasePlayer player, bool isInitiator, bool target, bool accept = false, bool finished = false)
        {
            if(IsBleeding(player) && !m_Config.AllowTeleportInBleeding)
            {
                if(isInitiator) return GetMessage("error_player_in_bleeding", this);
                else return GetMessage("error_target_in_bleeding", this);
            }
            if(IsFreezing(player) && !m_Config.AllowTeleportInFreezing)
            {
                if(isInitiator) return GetMessage("error_player_in_freezing", this);
                else return GetMessage("error_target_in_freezing", this);
            }
            if(IsWounded(player) && !m_Config.AllowTeleportInWounded)
            {
                if (isInitiator) return GetMessage("error_player_in_wounded", this);
                else return GetMessage("error_target_in_wounded", this);
            }
            if(InWater(player) && !m_Config.AllowTeleportInWater)
            {
                if (isInitiator) return GetMessage("error_player_in_water", this);
                else return GetMessage("error_target_in_water", this);
            }
            if(IsRadiation(player) && !m_Config.AllowTeleportInRadiation)
            {
                if (isInitiator) return GetMessage("error_player_in_radiation", this);
                else return GetMessage("error_target_in_radiation", this);
            }
            if(IsCanTeleported(player) && !m_Config.AllowTeleportInVanish && !finished)
            {
                if (isInitiator) return GetMessage("error_player_is_already_teleported", this);
                else return GetMessage("error_target_is_already_teleported", this);
            }
            if(IsAlreadyWait(player, isInitiator) && !accept && !finished)
            {
                if(isInitiator)
                {
                    return GetMessage("error_ttp_player_already_wait", this);
                }
                else
                {
                    return GetMessage("error_ttp_target_already_wait", this);
                }
            }
            if(IsDuelPlayer(player))
            {
                if (isInitiator) return GetMessage("error_target_in_duel", this);
                else return GetMessage("error_player_in_duel", this);
            }
            if(IsPlayerInBB(player) && !m_Config.AllowTeleportInBBZone)
            {
                if (isInitiator) return GetMessage("error_player_in_bb", this);
                else return GetMessage("error_target_in_bb", this);
            }
            if (IsRT(player) && !m_Config.AllowTeleportInRT)
            {
                if (isInitiator) return GetMessage("error_player_in_rt", this);
                else return GetMessage("error_target_in_rt", this);
            }
            if (IsUnlimited(player))
            {
                var finded = GetPlayerFromActive(player.UserIDString);
                if (finded != null)
                {
                    return string.Format(GetReadeableSeconds(finded.NextTTPLimitRemaining.Remaining, false));
                }
            }
            if (IsRemaining(player) && !target)
            {
                var finded = GetPlayerFromActive(player.UserIDString);
                if (finded != null)
                {
                    return string.Format(GetMessage("error_ttp_cooldown", this), finded.NextTeleportRemaining.Remaining);
                }
            }
            if(IsEscapeBlocked(player) && !m_Config.AllowTeleportInEscapeBlock)
            {
                if (isInitiator) return GetMessage("error_player_in_noescape", this);
                else return GetMessage("error_target_in_noescape", this);
            }
            if((IsRaidBlockedOM(player) || IsRaidBlockedRP(player)) && !m_Config.AllowTeleportInRaidBlock)
            {
                if (isInitiator) return GetMessage("error_player_in_raidblock", this);
                else return GetMessage("error_target_in_raidblocked", this);
            }
            if(IsCombatBlocked(player) && !m_Config.AllowTeleportInCombatBlock)
            {
                if (isInitiator) return GetMessage("error_player_in_combatblock", this);
                else return GetMessage("error_target_in_combatblock", this);
            }

            return "-1";
        }

        private bool IsDuelPlayer(BasePlayer target)
        {
            if (Duel == null) return false;
            return (bool)(Duel?.Call("IsPlayerOnActiveDuel", target));
        }
        private bool IsRT(BasePlayer player)
        {
            MonumentInfo[] monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();

            bool inRT = false;
            foreach(MonumentInfo monument in monuments)
            {
                float distance = Vector3.Distance(player.transform.position, monument.transform.position);
                if(monument.Type == MonumentType.Radtown)
                {
                    if(distance <= m_Config.ToRTDistance)
                    {
                        inRT = true;

                        break;
                    }
                }
            }

            return inRT;
        }
        private bool IsBleeding(BasePlayer player)
        {
            if(player.metabolism.bleeding.value > m_Config.CancelTeleportBleedingFactor)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        private bool IsFreezing(BasePlayer player)
        {
            if(player.metabolism.temperature.value < m_Config.CancelTeleportFreezeFactor)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        private bool IsWounded(BasePlayer player)
        {
            return player.IsWounded();
        }
        private bool InWater(BasePlayer player)
        {
            BaseEntity entity = player.GetEntity();

            if (entity.WaterFactor() > m_Config.CancelTeleportWaterFactor) return true;
            else return false;
        }
        private bool IsRadiation(BasePlayer player)
        {
            if (player.metabolism.radiation_poison.value > m_Config.CancelTeleportRadiationFactor) return true;
            else return false;
        }
        private bool IsCanTeleported(BasePlayer player)
        {
            string ret = (string)Interface.Call("CanTeleport", player);
            return !String.IsNullOrEmpty(ret);
        }
        private bool IsPlayerInBB(BasePlayer player)
        {
            RaycastHit hit;
            if(Physics.Raycast(player.transform.position, Vector3.down, out hit))
            {
                if (hit.GetEntity() != null)
                {
                    if(player.IsBuildingBlocked() && !player.IsBuildingAuthed())
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        private bool IsPlayerInOtherFoundation(BasePlayer player)
        {
            BaseEntity foundation = GetFoundation(player.transform.position);
            if(foundation != null)
            {
                if(foundation.GetComponent<BuildingBlock>() != null)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        private bool IsRemaining(BasePlayer player, bool home = false)
        {
            if (m_ActivePlayers.ContainsKey(player.UserIDString))
            {
                if (!home)
                {
                    if (m_ActivePlayers[player.UserIDString].NextTeleportRemaining.IsEnabled && m_ActivePlayers[player.UserIDString].NextTeleportRemaining.Remaining > 0)
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    if (m_ActivePlayers[player.UserIDString].NextHomeTeleportRemaining.IsEnabled && m_ActivePlayers[player.UserIDString].NextHomeTeleportRemaining.Remaining > 0)
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
            else
            {
                return false;
            }
        }
        private bool IsUnlimited(BasePlayer player, bool home = false)
        {
            if(m_ActivePlayers.ContainsKey(player.UserIDString))
            {
                if(!home)
                {
                    if(m_ActivePlayers[player.UserIDString].NextTTPLimitRemaining.IsEnabled && m_ActivePlayers[player.UserIDString].NextTTPLimitRemaining.Remaining > 0)
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    if (m_ActivePlayers[player.UserIDString].NextTTHLimitRemaining.IsEnabled && m_ActivePlayers[player.UserIDString].NextTTHLimitRemaining.Remaining > 0)
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
            }
            else
            {
                return false;
            }
        }
        private bool IsClanMember(ulong playerID, ulong targetID)
        {
            string playerTag = (string)Clans?.Call("GetClanOf", playerID);
            string targetTag = (string)Clans?.Call("GetClanOf", targetID);
            if (playerTag == null || targetTag == null) return false;

            if (playerTag == targetTag) return true;
            else return false;
        }
        private bool IsFriends(ulong playerID, ulong friendId)
        {
            return (bool)(Friends?.Call("AreFriends", playerID, friendId) ?? false);
        }
        private bool IsRaidBlockedRP(BasePlayer player)
        {
            try
            {
                if (((double)(NoEscape?.Call("ApiGetTime", player.userID) ?? 0)) > 0)
                {
                    return true;
                }
                else return false;
            }
            catch(Exception)
            {
                return false;
            }
        }
        private bool IsRaidBlockedOM(BasePlayer player)
        {
            return (bool)(NoEscape?.Call("IsRaidBlocked", player) ?? false);
        }
        private bool IsEscapeBlocked(BasePlayer player)
        {
            return (bool)(NoEscape?.Call("IsEscapeBlocked", player) ?? false);
        }
        private bool IsCombatBlocked(BasePlayer player)
        {
            return (bool)(NoEscape?.Call("IsCombatBlocked", player) ?? false);
        }
        private bool IsAlreadyWait(BasePlayer player, bool isInitiator)
        {
            if(GetPlayerDataFromWaiters(player.UserIDString, isInitiator) != null)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        private bool IsBagInBB(SleepingBag bag, BasePlayer owner)
        {
            if (bag == null) return true;

            RaycastHit hit;
            if (Physics.Raycast(bag.transform.position, Vector3.down, out hit))
            {
                if (hit.GetEntity() != null)
                {
                    if (
                        owner.IsBuildingBlocked(bag.transform.position, bag.transform.rotation, bag.transform.GetBounds()) 
                        && !owner.IsBuildingAuthed(bag.transform.position, bag.transform.rotation, bag.transform.GetBounds()))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }

        private BasePlayer FindPlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId)
                    return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId)
                    return player;
            }
            return default(BasePlayer);
        }
        private string GetMessage(string key, Plugin caller)
        {
            if (m_Config.EnablePluginPrefix)
            {
                string prefix = $"<color=#ffa500ff>{m_Config.PluginPrefix}</color>: ";

                prefix += lang.GetMessage(key, caller);

                return prefix;
            }
            else
            {
                return lang.GetMessage(key, caller);
            }
        }
        private string GetReadeableSeconds(int seconds, bool isTTH)
        {
            var ts = TimeSpan.FromSeconds(seconds);

            if (!isTTH)
                return string.Format(GetMessage("error_ttp_unlimited", this), ts.Hours, ts.Minutes, ts.Seconds);
            else
                return string.Format(GetMessage("error_tth_unlimited", this), ts.Hours, ts.Minutes, ts.Seconds);
        }
        private BaseEntity GetFoundation(Vector3 pos)
        {
            RaycastHit hit;
            if (Physics.Raycast(new Ray(pos, Vector3.down), out hit, 0.1f))
            {
                var entity = hit.GetEntity();
                if (entity != null && entity.ShortPrefabName.Contains("foundation"))
                    return entity;
            }
            return null;
        }

        private void CreateTTPRequest(PlayerPluginData initiator, PlayerPluginData target)
        {
            if (!IsAlreadyWait(FindPlayer(initiator.ID), true) || !IsAlreadyWait(FindPlayer(target.ID), false))
            {
                TeleportObject obj = new TeleportObject(initiator, target, -1);
                obj.ID = GenerateID();
                m_TeleportToPlayerWaiters.Add(obj.ID, obj);

                SendReply(FindPlayer(initiator.ID), string.Format(GetMessage("info_ttp_request_player_created", this), obj.Target.Name));
                SendReply(FindPlayer(target.ID), string.Format(GetMessage("info_ttp_request_target_created", this), obj.Initiator.Name));

                if(obj.Target.GuiEnabled && m_Config.EnableGUI)
                    ShowTeleportRequest(FindPlayer(target.ID), initiator.Name);

                if(!FindPlayer(initiator.ID).IsAdmin && m_Config.EnableUsersCommandsLogging)
                {
                    LogToFile(m_Config.UserCommandsLoggingFile, $"[LOG] -> {initiator.Name}({initiator.ID}) using the command '/tpr' to {target.Name}({target.ID}).", this);
                }

                if(FindPlayer(initiator.ID).IsAdmin && m_Config.EnableAdminCommandsLogging)
                {
                    LogToFile(m_Config.AdminCommandsLoggingFile, $"[LOG] -> Admin: {initiator.Name}({initiator.ID}) using the command '/tpr' to {target.Name}({target.ID}).", this);
                }

                PlaySound(FindPlayer(target.ID), "tp_receive");
                PlaySound(FindPlayer(initiator.ID), "tp_request");

                timer.Once(15, () =>
                {
                    if(!obj.Accepted)
                    {
                        CancelTTPRequest(obj.Initiator.ID);
                    }
                });
            }
            else
            {
                SendReply(FindPlayer(initiator.ID), GetMessage("whose_from_waiter_already_wait", this));
                SendReply(FindPlayer(target.ID), GetMessage("whose_from_waiter_already_wait", this));
            }
        }
        private void CancelTTPRequest(string id)
        {
            if(IsAlreadyWait(FindPlayer(id), true) || IsAlreadyWait(FindPlayer(id), false))
            {
                var data = GetTeleportData(id);

                BasePlayer initiator = FindPlayer(data.Initiator.ID);
                BasePlayer target = FindPlayer(data.Target.ID);

                DestroyTeleportTimer(initiator);
                DestroyTeleportRequest(FindPlayer(data.Target.ID));

                data.Remaining.Destroy();
                data.Accepted = true;
                m_TeleportToPlayerWaiters.Remove(data.ID);

                SendReply(initiator, GetMessage("info_ttp_request_cancelled", this));
                SendReply(target, GetMessage("info_ttp_request_cancelled", this));
            }
            else
            {
                SendReply(FindPlayer(id), GetMessage("info_ttp_request_notfound", this));
            }
        }
        private void AppendTTPRequest(TeleportObject obj)
        {
            if (obj == null)
            {
                return;
            }

            obj.Seconds = GetWaitTTPSeconds(obj.Initiator.ID);
            obj.Accepted = true;

            BasePlayer initiator = FindPlayer(obj.Initiator.ID);
            BasePlayer target = FindPlayer(obj.Target.ID);
            if (initiator == null || target == null)
            {
                Puts("Initiator or target is null");

                return;
            }

            obj.Instantiate(timer, () =>
            {
                initiator.StartSleeping();
                timer.Once(0.1f, () =>
                {
                    FinishedTTPRequest(obj);
                });
            }, () =>
            {
                if (obj.Initiator.GuiEnabled && m_Config.EnableGUI)
                    RefreshTeleportTimer(FindPlayer(obj.Initiator.ID), obj.Remaining.Remaining);
            });

            PlaySound(initiator, "tp_receive");

            SendReply(initiator, string.Format(GetMessage("info_ttp_request_player_appended", this), obj.Target.Name, obj.Seconds));
            SendReply(target, string.Format(GetMessage("info_ttp_request_target_appended", this), obj.Initiator.Name, obj.Seconds));
        }
        private void FinishedTTPRequest(TeleportObject obj)
        {
            BasePlayer initiator = FindPlayer(obj.Initiator.ID);
            BasePlayer target = FindPlayer(obj.Target.ID);

            string result = CheckPlayer(initiator, true, false, true);
            if(result != "-1")
            {
                SendReply(initiator, result);
                CancelTTPRequest(obj.Initiator.ID);
                return;
            }
            result = CheckPlayer(target, false, true, true);
            if(result != "-1")
            {
                SendReply(initiator, result);
                CancelTTPRequest(obj.Initiator.ID);
                return;
            }
            CargoShip ship = initiator.GetComponentInParent<CargoShip>();
            if (ship != null)
            {
                ship.RemoveChild(initiator);
                ship.UpdateNetworkGroup();
                ship.SendNetworkUpdateImmediate();
                initiator.SetParent(null);
            }

            DestroyTeleportTimer(initiator);
            obj.Remaining.Destroy();

            ClearTeleport(initiator, target.transform.position);

            GetPlayerFromActive(obj.Initiator.ID).CreateRemaining(Remainings.TeleportToPlayer, timer, GetTTPRemaining(obj.Initiator.ID), () =>
            {
                SendReply(initiator, lang.GetMessage("info_ttp_cooldown_reseted", this));
            });

            GetPlayerFromActive(obj.Initiator.ID).TTPLimit--;

            if (GetPlayerFromActive(obj.Initiator.ID).TTPLimit <= 0)
            {
                SendReply(initiator, GetMessage("info_create_ttp_remaining", this));

                GetPlayerFromActive(obj.Initiator.ID).CreateRemaining(Remainings.NextTTPLimit, timer, m_Config.DefaultLimitsUpdated, () =>
                {
                    GetPlayerFromActive(obj.Initiator.ID).TTPLimit = GetTTPLimit(obj.Initiator.ID);

                    SendReply(FindPlayer(obj.Initiator.ID), GetMessage("info_ttp_limit_reseted", this));
                });
            }

            PlaySound(FindPlayer(obj.Target.ID), "tp_request");
            PlaySound(FindPlayer(obj.Initiator.ID), "tp_request");

            SendReply(initiator, string.Format(GetMessage("info_ttp_request_target_finished", this), obj.Target.Name, GetPlayerFromActive(obj.Initiator.ID).TTPLimit));
            SendReply(target, string.Format(GetMessage("info_ttp_request_player_finished", this), obj.Initiator.Name));

            m_TeleportToPlayerWaiters.Remove(obj.ID);
        }
        #endregion

        #region Server 
        private void PlaySound(BasePlayer player, string key)
        {
            if(m_Config.EnableSoundEffects)
            {
                if(m_Config.SoundsFotNotify.ContainsKey(key))
                {
                    Effect x = new Effect(m_Config.SoundsFotNotify[key], player, 0, new Vector3(), new Vector3());
                    EffectNetwork.Send(x, player.Connection);
                }
                else
                {
                    PrintError($"Sound '{key}' not found. Check your config file");
                }
            }
        }
        #endregion

        #region UI
        public class UI
        {
            public static CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor = false, string parent = "Overlay")
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }

            public static void LoadImage(ref CuiElementContainer container, string panel, string url, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    FadeOut = 0.15f,
                    Components =
                    {
                        new CuiRawImageComponent { Url = url, FadeIn = 0.3f },
                        new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }

            public static void CreateInput(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, bool password, int charLimit, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiInputFieldComponent { Text = text, FontSize = size, Align = align, Color = color, Command = command, IsPassword = password, CharsLimit = charLimit},
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }

            public static void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }

            public static void CreateText(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            public static void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                {
                    hexColor = hexColor.TrimStart('#');
                }

                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        private static string TeleportRequestHud = "Teleport_RequstHud";
        private static string TeleportTimerHud = "Teleport_TimerHud";

        public void ShowTeleportRequest(BasePlayer player, string from)
        {
            CuiElementContainer container = new CuiElementContainer()
            {
                {
                    new CuiPanel()
                    {
                        CursorEnabled = true,
                        RectTransform =
                        {
                            AnchorMin = "0.3661458 0.6888888", AnchorMax = "0.6083333 0.9009258", OffsetMax = "0 0"
                        },
                        Image =
                        {
                            Color = UI.Color("#1D1D1DC2", 0.9f), Material = "assets/content/ui/uibackgroundblur.mat"
                        }
                    }, "Overlay", TeleportRequestHud
                },
                {
                    new CuiButton
                    {
                        RectTransform = { AnchorMin = "9.592623E-08 0.6550218", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Text = { Text = m_Config.DefaultHeaderTeleportNotify, Align = TextAnchor.UpperCenter, Font = "robotocondensed-bold.ttf", FontSize = 25 },
                        Button = { Color = UI.Color("#6767679E", 1f), Sprite = "assets/content/ui/ui.background.transparent.radial.psd" }
                    },
                    TeleportRequestHud
                },
                {
                    new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.0322578 0.6200887", AnchorMax = "0.9892477 0.8558964", OffsetMax = "0 0" },
                        Text = { Text = string.Format(m_Config.DefaultFromTeleportNotify, from), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 14 }
                    },
                    TeleportRequestHud
                },
                {
                    new CuiPanel()
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.004301132 0.6593894", AnchorMax = "0.9956988 0.6637558", OffsetMax = "0 0"
                        },
                        Image =
                        {
                            Color = "0 0 0 0",
                        }
                    },
                    TeleportRequestHud
                },
                {
                    new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.1591392 0.3537124", AnchorMax = "0.8516133 0.624455", OffsetMax = "0 0" },
                        Text = { Text = $"ПРИНЯТЬ ?", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 22 }
                    },
                    TeleportRequestHud
                },
                {
                    new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.01935504 0.03056763", AnchorMax = "0.4688173 0.2663756", OffsetMax = "0 0" },
                        Button = { Command = "tp.accept", Color = UI.Color("#588B61FF", 1f), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        Text = { Text = "ДА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                    }, TeleportRequestHud
                },
                {
                    new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5311831 0.03493431", AnchorMax = "0.9827962 0.2663756", OffsetMax = "0 0" },
                        Button = { Command = "tp.cancel", Color = UI.Color("#714949FF", 1f), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        Text = { Text = "НЕТ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                    }, TeleportRequestHud
                }
            };

            CuiHelper.AddUi(player, container);
        }
        public void DestroyTeleportRequest(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, TeleportRequestHud);
        }
        public void RefreshTeleportTimer(BasePlayer player, int secs, string to = "К ИГРОКУ")
        {
            CuiHelper.DestroyUi(player, TeleportTimerHud);
            CuiElementContainer container = new CuiElementContainer()
            {
                {
                    new CuiPanel()
                    {
                        CursorEnabled = false,
                        RectTransform =
                        {
                            AnchorMin = "0.3276041 0.8398149", AnchorMax = "0.659375 0.9296296", OffsetMax = "0 0"
                        },
                        Image =
                        {
                            Color = "0.1944085 0.1944085 0.1944085 0.4464463", Material = "assets/content/ui/uibackgroundblur.mat"
                        }
                    }, "Overlay", TeleportTimerHud
                },
            };
            if(secs < 10)
            {
                container.Add(new CuiLabel()
                {
                    RectTransform = { AnchorMin = "0.0204581 0.08247322", AnchorMax = "0.973006 0.9484544", OffsetMax = "0 0" },
                    Text = { Color = "0.6480626 0.1103811 0.1855408 1", Text = $"<size=30>☢</size> ТЕЛЕПОРТ {to}: 00:0{secs} <size=30>☢</size>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 22 },
                }, TeleportTimerHud);
            }
            else
            {
                container.Add(new CuiLabel()
                {
                    RectTransform = { AnchorMin = "0.0204581 0.08247322", AnchorMax = "0.973006 0.9484544", OffsetMax = "0 0" },
                    Text = { Color = "0.6480626 0.1103811 0.1855408 1", Text = $"<size=30>☢</size> ТЕЛЕПОРТ {to}: 00:{secs} <size=30>☢</size>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 22 },
                }, TeleportTimerHud);
            }
            CuiHelper.AddUi(player, container);
        }
        public void DestroyTeleportTimer(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, TeleportTimerHud);
        }
        #endregion

        #region Collection Instruments
        private PlayerPluginData GetPlayerDataFromWaiters(string id, bool isInitiator)
        {
            if (isInitiator)
            {
                if (m_TeleportToPlayerWaiters.Any((x) => x.Value.Initiator.ID == id))
                {
                    return m_TeleportToPlayerWaiters.Where((x) => x.Value.Initiator.ID == id).First().Value.Initiator;
                }
                else
                {
                    return null;
                }
            }
            else
            {
                if (m_TeleportToPlayerWaiters.Any((x) => x.Value.Target.ID == id))
                {
                    return m_TeleportToPlayerWaiters.Where((x) => x.Value.Target.ID == id).First().Value.Target;
                }
                else
                {
                    return null;
                }
            }
        }
        private PlayerPluginData GetPlayerFromActive(string id)
        {
            if(m_ActivePlayers.ContainsKey(id))
            {
                return m_ActivePlayers[id];
            }
            else
            {
                return null;
            }
        }
        private TeleportObject GetTeleportData(int id)
        {
            if(m_TeleportToPlayerWaiters.ContainsKey(id))
            {
                return m_TeleportToPlayerWaiters[id];
            }
            else
            {
                return null;
            }
        }
        private TeleportObject GetTeleportData(PlayerPluginData obj, bool isInitiator = true)
        {
            if (isInitiator)
            {
                var data = m_TeleportToPlayerWaiters.Any((x) => x.Value.Initiator.ID == obj.ID);
                if (data)
                {
                    return m_TeleportToPlayerWaiters.Where((x) => x.Value.Initiator.ID == obj.ID).First().Value;
                }
                else
                {
                    return null;
                }
            }
            else
            {
                var data = m_TeleportToPlayerWaiters.Any((x) => x.Value.Target.ID == obj.ID);
                if (data)
                {
                    return m_TeleportToPlayerWaiters.Where((x) => x.Value.Target.ID == obj.ID).First().Value;
                }
                else
                {
                    return null;
                }
            }
        }
        private TeleportObject GetTeleportData(string id)
        {
            TeleportObject @object;
            if (GetTeleportData(GetPlayerFromActive(id), true) != null)
            {
                @object = GetTeleportData(GetPlayerFromActive(id), true);
            }
            else
            {
                @object = GetTeleportData(GetPlayerFromActive(id), false);
            }

            return @object;
        }
        private int GenerateID()
        {
            int result = Core.Random.Range(0, 65535);
            if(!m_TeleportToPlayerWaiters.ContainsKey(result))
            {
                return result;
            }
            else
            {
                return GenerateID();
            }
        }
        #endregion

        #region Dynamic Permission Instruments
        public int GetPermissionProperty(string permission, Settings setting)
        {
            if(m_Config.PermissionSettings.ContainsKey(permission))
            {
                if(m_Config.PermissionSettings[permission].ContainsKey("Settings"))
                {
                    if(m_Config.PermissionSettings[permission]["Settings"].ContainsKey(setting.ToString()))
                    {
                        return m_Config.PermissionSettings[permission]["Settings"][setting.ToString()];
                    }
                    else
                    {
                        return -3;
                    }
                }
                else
                {
                    return -2;
                }
            }
            else
            {
                return -1;
            }
        }
        public int GetWaitTTPSeconds(string id)
        {
            int secs = m_Config.DefaultTimeToTeleport;

            foreach (var perm in m_Config.PermissionSettings)
            {
                if (permission.UserHasPermission(id, perm.Key))
                {
                    if(secs > GetPermissionProperty(perm.Key, Settings.WaitToTeleportTime))
                    {
                        secs = GetPermissionProperty(perm.Key, Settings.WaitToTeleportTime);
                    }
                }
            }

            return secs;
        }
        public int GetWaitTTHSeconds(string id)
        {
            int secs = m_Config.DefaultTimeToTeleportHome;

            foreach (var perm in m_Config.PermissionSettings)
            {
                if (permission.UserHasPermission(id, perm.Key))
                {
                    if(secs > GetPermissionProperty(perm.Key, Settings.WaitToHomeTeleportTime))
                    {
                        secs = GetPermissionProperty(perm.Key, Settings.WaitToHomeTeleportTime);
                    }

                    break;
                }
            }

            return secs;
        }
        public int GetTTPRemaining(string id)
        {
            int secs = m_Config.DefaultRemainingAfterTeleport;

            foreach (var perm in m_Config.PermissionSettings)
            {
                if (permission.UserHasPermission(id, perm.Key))
                {
                    if (secs > GetPermissionProperty(perm.Key, Settings.WaitAfterTeleport))
                    {
                        secs = GetPermissionProperty(perm.Key, Settings.WaitAfterTeleport);
                    }

                    break;
                }
            }

            return secs;
        }
        public int GetTTHRemaining(string id)
        {
            int secs = m_Config.DefaultRemainingAfterHomeTeleport;

            foreach(var perm in m_Config.PermissionSettings)
            {
                if(permission.UserHasPermission(id, perm.Key))
                {
                    if (secs > GetPermissionProperty(perm.Key, Settings.WaitAfterTeleportHome))
                    {
                        secs = GetPermissionProperty(perm.Key, Settings.WaitAfterTeleportHome);
                    }

                    break;
                }
            }

            return secs;
        }
        public int GetSHLimit(string id)
        {
            int limit = m_Config.DefaultSaveHomeLimit;

            foreach(var perm in m_Config.PermissionSettings)
            {
                if(permission.UserHasPermission(id, perm.Key))
                {
                    if (limit < GetPermissionProperty(perm.Key, Settings.SaveHomeLimit))
                    {
                        limit = GetPermissionProperty(perm.Key, Settings.SaveHomeLimit);
                    }

                    break;
                }
            }

            return limit;
        }
        public int GetTTHLimit(string id)
        {
            int limit = m_Config.DefaultTTHOneDay;

            foreach (var perm in m_Config.PermissionSettings)
            {
                if (permission.UserHasPermission(id, perm.Key))
                {
                    if (limit < GetPermissionProperty(perm.Key, Settings.TeleportToHomeLimit))
                    {
                        limit = GetPermissionProperty(perm.Key, Settings.TeleportToHomeLimit);
                    }

                    if (limit < 0)
                    {
                        limit = m_Config.DefaultTTHOneDay;
                    }

                    break;
                }
            }

            return limit;
        }
        public int GetTTPLimit(string id)
        {
            int limit = m_Config.DefaultTTPOneDay;

            foreach (var perm in m_Config.PermissionSettings)
            {
                if (permission.UserHasPermission(id, perm.Key))
                {
                    if (limit < GetPermissionProperty(perm.Key, Settings.TeleportToPlayerLimit))
                    {
                        limit = GetPermissionProperty(perm.Key, Settings.TeleportToPlayerLimit);
                    }
                    if (limit < 0)
                    {
                        limit = m_Config.DefaultTTPOneDay;
                    }

                    break;
                }
            }

            return limit;
        }
        #endregion

        #region Converter
        static UnityVector3Converter Converter = new UnityVector3Converter();
        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        #endregion
    }
}


// --- End of file: Teleport.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DoorsControl.cs ---
// --- Original Local Path: DoorsControl.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using System;
using System.Reflection;
using System.Text;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DoorsControl", "RusskiIvan", "1.0.4")]
    [Description("DoorsControl")]
    public class DoorsControl : RustPlugin
    {
        [PluginReference] private Plugin Clans;

        #region Variables

        private StoredData _data;
        private ConfigData _config;

        private readonly FieldInfo _serverInput = typeof(BasePlayer).GetField("serverInput",
            (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

        private readonly Vector3 _eyesAdjust = new Vector3(0f, 1.5f, 0f);
        private bool _dataLoaded;

        private readonly FieldInfo _hasCode = typeof(CodeLock).GetField("hasCode",
            (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

        #endregion

        #region Configuration

        private class ConfigData
        {
            [JsonProperty("Команда для замков")] public string codelockCommand { get; set; }
            [JsonProperty("Команда для дверей ")] public string doorsCommand { get; set; }
            [JsonProperty("Привилегии")] public Permissions permissions { get; set; }
            [JsonProperty("Настройки")] public Settings settings { get; set; }
        }

        private class Permissions
        {
            [JsonProperty("Привилегия для дверей")]
            public string permissionDeployDoor { get; set; }

            [JsonProperty("Привилегия для ящиков")]
            public string permissionDeployBox { get; set; }

            [JsonProperty("Привилегия для шкафов с одеждой")]
            public string permissionDeployLocker { get; set; }

            [JsonProperty("Привилегия для шкафа")] public string permissionDeployCupboard { get; set; }

            [JsonProperty("Привилегия для автозакрытия замка")]
            public string permissionAutoLock { get; set; }

            [JsonProperty("Привилегия для установки замка без замка :)")]
            public string permissionNoLockNeed { get; set; }

            [JsonProperty("Привилегия для автозакрывания двери")]
            public string permissionAutoCloseDoor { get; set; }

            [JsonProperty("Привилегия для умного дома")]
            public string permissionSmartHome { get; set; }
        }

        private class Settings
        {
            [JsonProperty("Автозакрытие замка")] public bool AutoLock { get; set; }

            [JsonProperty("Авто установка на двери")]
            public bool DeployDoor { get; set; }

            [JsonProperty("Авто установка на ящики")]
            public bool DeployBox { get; set; }

            [JsonProperty("Авто установка на шкафы с одеждой")]
            public bool DeployLocker { get; set; }

            [JsonProperty("Авто установка на шкаф")]
            public bool DeployCupboard { get; set; }

            [JsonProperty("Задержка закрытия двери")]
            public float defaultDelay { get; set; }

            [JsonProperty("Автозакрытие дверей")] public bool autoDoor { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                codelockCommand = "code",
                doorsCommand = "ad",
                permissions = new Permissions
                {
                    permissionDeployDoor = Name + ".deploydoor",
                    permissionDeployBox = Name + ".deploybox",
                    permissionDeployLocker = Name + ".deploylocker",
                    permissionDeployCupboard = Name + ".deploycup",
                    permissionAutoLock = Name + ".autolock",
                    permissionNoLockNeed = Name + ".nolockneed",
                    permissionAutoCloseDoor = Name + ".autoclose",
                    permissionSmartHome = Name + ".smarthome",

                },
                settings = new Settings
                {
                    AutoLock = true,
                    DeployDoor = true,
                    DeployBox = true,
                    DeployLocker = true,
                    DeployCupboard = true,
                    autoDoor = true,
                    defaultDelay = 5f
                }
            };
            SaveConfig(config);
            PrintWarning("Creating default a configuration file ...");
        }

        private void LoadConfigVariables() => _config = Config.ReadObject<ConfigData>();
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        #endregion

        #region Oxide
        
        private void Loaded()
        {
            LoadConfigVariables();
            cmd.AddChatCommand(_config.codelockCommand, this, "CodeLockCommand");
            cmd.AddChatCommand(_config.doorsCommand, this, "AutoDoorCommand");
        }

        private void OnServerInitialized()
        {
            if (!_dataLoaded) LoadData();
            RegisterPermissions();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)    
        {
            if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
        }

        private void OnDoorOpened(Door door, BasePlayer player)
        {
            if (door == null || player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor))
            {
                //Puts(permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor).ToString());
                return;
            }
            if (door.GetComponentInChildren<DoorCloser>() != null) return;
            if (_data.DoorsList.Contains(door.net.ID)) return;
            var time = 0f;
            if (_data.PlayerInfo.ContainsKey(player.userID))
            {
                if (!_data.PlayerInfo[player.userID].AutoDoor) return;
                time = _data.PlayerInfo[player.userID].DefaultDelay;
            }
            else
            {
                if (!_config.settings.AutoLock) return;
                time = _config.settings.defaultDelay;
            }

            if (time == 0f) return;
            timer.Once(time, () => CloseDoor(door));

        }

        private void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            if (deployer.GetOwnerPlayer() == null || deployer.GetModDeployable() == null ||
                deployer.GetModDeployable().name == "doorcloser.item" || !entity.HasSlot(BaseEntity.Slot.Lock) ||
                !(entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)) return;
            var owner = deployer.GetOwnerPlayer();
            if (!permission.UserHasPermission(owner.UserIDString, _config.permissions.permissionAutoLock) ||
                !_data.PlayerInfo[owner.userID].AutoLock) return;
            var codelock = entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock;
            if (codelock == null) return;
            codelock.code = Convert.ToString(_data.PlayerInfo[owner.userID].Password != 0
                ? _data.PlayerInfo[owner.userID].Password
                : UnityEngine.Random.Range(1234, 9876));
            _hasCode.SetValue(codelock, true);
            codelock.whitelistPlayers.Add(owner.userID);
            codelock.SetFlag(BaseEntity.Flags.Locked, true);
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab",
                entity.transform.position);
            var code = codelock.code;
            if (owner.net.connection.info.GetBool("global.streamermode")) code = "****";
            SendReply(owner, string.Format(Msg("CodeAuth", owner), code)); //Изменено
        }

        private void OnEntityBuilt(Planner planner, GameObject obj)
        {
            if (planner == null || planner.GetOwnerPlayer() == null ||
                obj.GetComponent<BaseEntity>() == null || obj.GetComponent<BaseEntity>().OwnerID == 0) return;
            var entity = obj.GetComponent<BaseEntity>();
            var player = planner.GetOwnerPlayer();
            if (player == null || !_data.PlayerInfo.ContainsKey(player.userID)) return;
            if (entity is Door && (entity as Door).canTakeLock)
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployDoor) &&
                    _data.PlayerInfo[player.userID].DeployDoor) LockPlacing(player, entity);
            }
            else if (entity is BoxStorage && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployBox) &&
                    _data.PlayerInfo[player.userID].DeployBox) LockPlacing(player, entity);
            }
            else if (entity is Locker && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployLocker) &&
                    _data.PlayerInfo[player.userID].DeployLocker) LockPlacing(player, entity);
            }
            else if (entity is BuildingPrivlidge && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployCupboard) &&
                    _data.PlayerInfo[player.userID].DeployCupboard) LockPlacing(player, entity);
            }
        }

        private void OnNewSave()
        {
            LoadData();
            _data.DoorsList.Clear();
            SaveData();
        }

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        #endregion

        #region Functions
        bool IsClanMember(ulong playerid = 294912, ulong targetID = 0) => (bool)(Clans?.Call("HasFriend", playerid, targetID) ?? false);

        private void CloseDoor(BaseEntity door)
        {
            if (door == null || !door.IsOpen()) return;
            door.SetFlag(BaseEntity.Flags.Open, false);
            door.SendNetworkUpdateImmediate();
        }

        private static BaseEntity DoRay(Vector3 pos, Vector3 aim)
        {
            var hits = Physics.RaycastAll(pos, aim);
            var distance = 3f;
            BaseEntity target = null;
            foreach (var hit in hits)
            {
                if (!(hit.distance < distance)) continue;
                distance = hit.distance;
                target = hit.GetEntity();
            }

            return target;
        }
    
        private void AutoDoorCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor))
            {
                SendReply(player,
                    Msg("NoAccess", player));
                return;
            }

            SetDoor(player);
        }

        private void SetDoor(BasePlayer player)
        {
            var input = _serverInput.GetValue(player) as InputState;
            if (input == null) return;
            var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
            var entity = DoRay(player.transform.position + _eyesAdjust, currentRot);
            var door = entity as Door;
            if (door == null)
            {
                if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
                _data.PlayerInfo[player.userID].AutoDoor = !_data.PlayerInfo[player.userID].AutoDoor;
                SaveData();
                SendReply(player,
                    _data.PlayerInfo[player.userID].AutoDoor
                        ? Msg("AllAutoCloseEnabled", player)
                        : Msg("AllAutoCloseDisabled", player));
                return;
            }

            SwitchDoor(player, door);
        }

        private void SwitchDoor(BasePlayer player, BaseNetworkable door)
        {
            if (door == null || door.net == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor)) return;

            if (_data.DoorsList.Contains(door.net.ID))
            {
                _data.DoorsList.Remove(door.net.ID);
                SendReply(player,
                    Msg("AutoCloseEnabled", player));
            }
            else
            {
                _data.DoorsList.Add(door.net.ID);
                SendReply(player,
                    Msg("AutoCloseDisabled", player));
            }

            SaveData();
        }

        private void RegisterPermissions()
        {
            if (!permission.PermissionExists(_config.permissions.permissionDeployDoor))
                permission.RegisterPermission(_config.permissions.permissionDeployDoor, this);
            if (!permission.PermissionExists(_config.permissions.permissionAutoLock))
                permission.RegisterPermission(_config.permissions.permissionAutoLock, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployBox))
                permission.RegisterPermission(_config.permissions.permissionDeployBox, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployLocker))
                permission.RegisterPermission(_config.permissions.permissionDeployLocker, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployCupboard))
                permission.RegisterPermission(_config.permissions.permissionDeployCupboard, this);
            if (!permission.PermissionExists(_config.permissions.permissionAutoCloseDoor))
                permission.RegisterPermission(_config.permissions.permissionAutoCloseDoor, this);
            if (!permission.PermissionExists(_config.permissions.permissionNoLockNeed))
                permission.RegisterPermission(_config.permissions.permissionNoLockNeed, this);
            if (!permission.PermissionExists(_config.permissions.permissionSmartHome))
                permission.RegisterPermission(_config.permissions.permissionSmartHome, this);
        }

        private void AddNewPlayer(BasePlayer player)
        {
            if (_data.PlayerInfo.ContainsKey(player.userID)) return;

            var info = new PlayerInfo
            {
                AutoLock = _config.settings.AutoLock,
                DeployDoor = _config.settings.DeployDoor,
                DeployBox = _config.settings.DeployBox,
                DeployLocker = _config.settings.DeployLocker,
                DeployCupboard = _config.settings.DeployCupboard,
                AutoDoor = _config.settings.autoDoor,
                DefaultDelay = _config.settings.defaultDelay,
                Password = UnityEngine.Random.Range(1000, 9999)
            };
            _data.PlayerInfo.Add(player.userID, info);
            SaveData();
        }

        private void SetPlayerData(BasePlayer player, int Code, bool AutoLock = true, bool DeployDoor = true,
            bool DeployBox = true, bool DeployLocker = true, bool DeployCupboard = true, bool autoDoor = true,
            float defaultDelay = 5f)
        {
            if (player == null) return;
            if (_data.PlayerInfo.ContainsKey(player.userID)) _data.PlayerInfo.Remove(player.userID);
            var info = new PlayerInfo
            {
                AutoLock = AutoLock,
                DeployDoor = DeployDoor,
                DeployBox = DeployBox,
                DeployLocker = DeployLocker,
                DeployCupboard = DeployCupboard,
                AutoDoor = autoDoor,
                DefaultDelay = defaultDelay,
                Password = Code == 0 ? UnityEngine.Random.Range(1000, 9999) : Code
            };
            _data.PlayerInfo.Add(player.userID, info);
            SaveData();
        }

        private PlayerInfo GetPlayerData(BasePlayer player)
        {
            if (player == null) return null;
            if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
            return _data.PlayerInfo[player.userID];
        }

        private void LockPlacing(BasePlayer player, BaseEntity entity)
        {
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionNoLockNeed) &&
                player.inventory.Take(null, 1159991980, 1) == 0)
            {
                return;
            }

            var codeLock = GameManager.server.CreateEntity("assets/prefabs/locks/keypad/lock.code.prefab",
                new Vector3(), new Quaternion(), true) as CodeLock;
            if (codeLock == null) return;
            codeLock.gameObject.Identity();
            codeLock.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.Lock));
            codeLock.OnDeployed(entity, player);
            codeLock.Spawn();
            entity.SetSlot(BaseEntity.Slot.Lock, codeLock);
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock) ||
                !_data.PlayerInfo[player.userID].AutoLock) return;
            codeLock.code = Convert.ToString(_data.PlayerInfo[player.userID].Password != 0
                ? _data.PlayerInfo[player.userID].Password
                : UnityEngine.Random.Range(1234, 9876));
            _hasCode.SetValue(codeLock, true);
            codeLock.whitelistPlayers.Add(player.userID);
            var clanList = Clans?.Call<List<string>>("GetClanMembers", player.userID);
            if (clanList != null && clanList.Count > 0)
            {
                foreach (var clanuser in clanList)
                {
                    codeLock.whitelistPlayers.Add(ulong.Parse(clanuser));
                } 
            }
            else
            {
                codeLock.whitelistPlayers.Add(player.userID);
            }
            if (RelationshipManager.ServerInstance.FindPlayersTeam(player.userID) != null)
            {
                foreach (var playerID in player.Team.members)
                {
                    codeLock.whitelistPlayers.Add(playerID);

                }
            }
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab",
                entity.transform.position);
            var code = codeLock.code;
            if (player.net.connection.info.GetBool("global.streamermode")) code = "****";
            SendReply(player, string.Format(Msg("CodeAuth", player), code));
        }

        private void CodeLockCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployDoor) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployBox) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployLocker) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployCupboard))
            {
                SendReply(player,
                    Msg("NoAccess", player));
                return;
            }

            if (args.Length == 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine(string.Format(Msg("CommandUsage", player), _config.codelockCommand));
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock))
                    sb.AppendLine(String.Format(Msg("CommandAutolock", player), "auto", _data.PlayerInfo[player.userID].AutoLock
                                      ? "ON"
                                      : "OFF"));
                var pin = Convert.ToString(_data.PlayerInfo[player.userID].Password);
                if (player.net.connection.info.GetBool("global.streamermode")) pin = "****";
                sb.AppendLine(String.Format(Msg("CommandPinCode", player),"pin", _data.PlayerInfo[player.userID].Password > 0
                    ? pin
                    : Msg("CommandPinCodeNotSet", player)));
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }

            switch (args[0].ToLower())
            {
                case "auto":
                    _data.PlayerInfo[player.userID].AutoLock = !_data.PlayerInfo[player.userID].AutoLock;
                        SendReply(player,
                            (_data.PlayerInfo[player.userID].AutoLock
                                ? Msg("AutoLockEnabled", player)
                                : Msg("AutoLockDisabled", player)));//Изменено
                    break;
               case "pin":
                    int pin;
                    if (args.Length != 2) goto case "noaccess";
                    //Puts(int.TryParse(args[1], out pin).ToString());
                    if (int.TryParse(args[1], out pin) == false || int.Parse(args[1]) > 9999 || int.Parse(args[1]) < 1000) goto case "badargument";
                    _data.PlayerInfo[player.userID].Password = pin;
                    SendReply(player, string.Format(Msg("CommandPinCodeSetTo", player), pin));
                    break;
                case "noaccess":
                    SendReply(player, string.Format(Msg("CommandPinCodeHelp", player), _config.codelockCommand));
                    break;
                 case "badargument":
                     SendReply(player, string.Format(Msg("BadFormatPin", player), args[1]));
                    break;
                    
                default:
                    SendReply(player, string.Format(Msg("NotSupported", player), args[0]));
                    break;
            }
        }
        
        #endregion

        #region Data
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new StoredData();
            _dataLoaded = true;
        }
        class StoredData
        {
            public Dictionary<ulong, PlayerInfo> PlayerInfo = new Dictionary<ulong, PlayerInfo>();
            public List<uint> DoorsList = new List<uint>();
        }
        
        class PlayerInfo
        {
            public bool AutoLock;
            public bool DeployDoor;
            public bool DeployBox;
            public bool DeployLocker;
            public bool DeployCupboard;
            public int Password;
            public bool AutoDoor;
            public float DefaultDelay;
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"AllAutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic doors closing for you is enabled</color>"},
                    {"AllAutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic doors closing for you is disabled</color>"},
                    {"BadFormatPin", "<color=#00FFFF></color><color=#FFFFFF> Error syntax pin: <color=#FF0000>{0}</color></color>"},
                    {"AutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic closing of <color=#00FF00>THIS DOOR</color> for all authorized players is enabled</color>"},
                    {"AutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic closing of <color=#FF0000>THIS DOOR</color> for all authorized players is disabled</color>"},
                    {"AutoLockEnabled", "<color=#00FFFF></color><color=#FFFFFF> CodeLock automation (secure and lock) enabled</color>"},
                    {"AutoLockDisabled", "<color=#00FFFF></color><color=#FFFFFF> CodeLock automation disabled</color>"},
                    {"DeployLockDoorEnabled", "<color=#00FFFF></color><color=#FFFFFF> Doors will include codelocks on deploy</color>"},
                    {"DeployLockDoorDisabled", "<color=#00FFFF></color><color=#FFFFFF> Doors will not include codelocks on deploy</color>"},
                    {"DeployLockBoxEnabled", "<color=#00FFFF></color><color=#FFFFFF> Boxes will include codelocks on deploy</color>"},
                    {"DeployLockBoxDisabled", "<color=#00FFFF></color><color=#FFFFFF> Boxes will not include codelocks on deploy</color>"},
                    {"DeployLockLockerEnabled", "<color=#00FFFF></color><color=#FFFFFF> Locker will include codelocks on deploy</color>"},
                    {"DeployLockLockerDisabled", "<color=#00FFFF></color><color=#FFFFFF> Locker will not include codelocks on deploy</color>"},
                    {"DeployLockCupEnabled", "<color=#00FFFF></color><color=#FFFFFF> Cupboards will include codelocks on deploy</color>"},
                    {"DeployLockCupDisabled", "<color=#00FFFF></color><color=#FFFFFF> Cupboards will not include codelocks on deploy</color>"},
                    {"CodeAuth", "<color=#00FFFF></color><color=#FFFFFF> CodeLock secured and locked with <color=#00FF00>{0}</color></color>"},
                    {"NoAccess", "<color=#00FFFF></color><color=#FFFFFF> You are not granted for this feature</color>"},
                    {"NotSupported", "<color=#00FFFF></color><color=#FFFFFF> The specific function <color=#FF0000>{0}</color> is not available</color>"},
                    {"CommandUsage", "<color=#FFFFFF>Command usage: <color=#00FF00>{0}</color></color>"},
                    {"CommandToggle", "<color=#FFFFFF>All switches toggle their setting (on<>off)</color>"},
                    {"CommandAutolock", "<color=#FFFFFF><color=#00FF00>{0}</color> - Autolock feature: <color=#00FF00>{1}</color></color>"}, 
                    {"CommandPinCode", "<color=#FFFFFF><color=#00FF00>{0}</color> - Your current PIN: <color=#00FF00>{1}</color></color>"},
                    {"CommandPinCodeNotSet", "<color=#FFFFFF>Random 8-Digits</color>"},
                    {"CommandPinCodeSetTo", "<color=#00FFFF></color><color=#FFFFFF> Your Pin was succesful set to: <color=#00FF00>{0}</color></color>"},
                    {"CommandPinCodeHelp", "<color=#00FFFF></color><color=#FFFFFF> Set your PIN with <color=#00FF00>/{1} pin 1234</color> (4-Digits)"},
                    {"CommandDeployDoor", "<color=#FFFFFF> Deploy with Door:</color>"}, 
                    {"CommandDeployBox", "<color=#FFFFFF> Deploy with Box:</color>"},
                    {"CommandDeployLocker", "<color=#FFFFFF> Deploy with Locker:</color>"}, 
                    {"CommandDeployCupboard", "<color=#FFFFFF> Deploy with Cupboard:</color>"},
                }, this);
        lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"AllAutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие всех дверей для Вас <color=#00FF00>ВКЛЮЧЕНО</color></color>"},
                    {"AllAutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие всех дверей для Вас <color=#FF0000>ВЫКЛЮЧЕНО</color></color>"},
                    {"BadFormatPin", "<color=#00FFFF></color><color=#FFFFFF> Неправильный формат пароля: <color=#FF0000>{0}</color></color>"},
                    {"AutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие <color=#00FF00>ЭТОЙ ДВЕРИ</color> для всех авторизованных игроков <color=#00FF00>ВКЛЮЧЕНО</color></color>"},
                    {"AutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие <color=#FF0000>ЭТОЙ ДВЕРИ</color> для всех авторизованных игроков <color=#FF0000>ВЫКЛЮЧЕНО</color></color>"},
                    {"AutoLockEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическая установка замка с паролем <color=#00FF00>ВКЛЮЧЕНА</color></color>"},
                    {"AutoLockDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическая установка замка с паролем <color=#FF0000>ВЫКЛЮЧЕНА</color></color>"},
                    {"DeployLockDoorEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на двери</color>"},
                    {"DeployLockDoorDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на двери</color>"},
                    {"DeployLockBoxEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на ящики</color>"},
                    {"DeployLockBoxDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на ящики</color>"},
                    {"DeployLockLockerEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на шкафы с одеждой</color>"},
                    {"DeployLockLockerDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на шкафы с одеждой</color>"},
                    {"DeployLockCupEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на шкафы</color>"},
                    {"DeployLockCupDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на шкафы</color>"},
                    {"CodeAuth", "<color=#00FFFF></color><color=#FFFFFF> Замок установлен! Пароль <color=#00FF00>{0}</color></color>"},
                    {"NoAccess", "<color=#00FFFF></color><color=#FFFFFF> У вас нету привилегии для использования команды</color>"},
                    {"NotSupported", "<color=#00FFFF></color><color=#FFFFFF> Функция <color=#FF0000>{0}</color> недоступна!</color>"},
                    {"CommandUsage", "<color=#FFFFFF>Команда: <color=#00FF00>{0}</color></color>"},
                    {"CommandToggle", "<color=#FFFFFF>Используется переключение <color=#00FF00>ON/OFF</color></color>"},
                    {"CommandAutolock", "<color=#FFFFFF><color=#00FF00>{0}</color> - значение: <color=#00FF00>{1}</color></color>"}, 
                    {"CommandPinCode", "<color=#FFFFFF><color=#00FF00>{0}</color> - Текущий пароль: <color=#00FF00>{1}</color></color>"},    
                    {"CommandPinCodeNotSet", "<color=#FFFFFF>Случайные 8 цифр</color>"},
                    {"CommandPinCodeSetTo", "<color=#00FFFF></color><color=#FFFFFF> Ваш пароль: <color=#00FF00>{0}</color>"},
                    {"CommandPinCodeHelp", "<color=#00FFFF></color><color=#FFFFFF> Установить пароль <color=##00FF00>/{1} pin 1234</color> (4 цифры)</color>"},
                    {"CommandDeployDoor", "<color=#FFFFFF> Установка на двери:</color>"}, 
                    {"CommandDeployBox", "<color=#FFFFFF> Установка на ящики:</color>"},
                    {"CommandDeployLocker", "<color=#FFFFFF> Установка на шкаф с одеждой:</color>"}, 
                    {"CommandDeployCupboard", "<color=#FFFFFF> Установка на шкаф:</color>"},
                }, this, "ru");
        }    
        private string Msg(string key, BasePlayer player = null) =>
            lang.GetMessage(key, this, player.UserIDString);
        #endregion    
        
    }
}

// --- End of file: DoorsControl.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Decay.cs ---
// --- Original Local Path: Decay.cs ---



// --- End of file: Decay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AuthLite.cs ---
// --- Original Local Path: AuthLite.cs ---

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using Network;
using Oxide.Core;
using Oxide.Core.Libraries;
using UnityEngine;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("AuthLite", "DeathGX & ShadowRemove", "0.5")]
    [Description("Automatic id authentication")]
	/*
	this plugin detects no steam players
	*/
    public class AuthLite : RustPlugin
    {
		
		Dictionary<ulong,string> users=new Dictionary<ulong,string>();
		Dictionary<ulong,string> lastSaved=new Dictionary<ulong,string>();
		
		//discord webhook on user approved
		string id = "";
		string token = "";
		
		void Webhook(string msg) {
			if (id=="") return;
			/*webrequest.Enqueue(
				"http://localhost?query=webhook&id="+id+"&token="+token
				+"&msg="+UnityEngine.Networking.UnityWebRequest.EscapeURL(msg), null, (code, response) =>
			{*/
			string[] parameters = new string[]{
				"content="+UnityEngine.Networking.UnityWebRequest.EscapeURL(msg),
				"username=AuthLite"
			};
			
			string body = string.Join("&", parameters);
			
			webrequest.Enqueue("https://discord.com/api/webhooks/"+id+"/"+token, body, (code, response) =>
			{
				if (code != 200 || response == null)
				{
					Puts($"Couldn't get an answer!");
					return;
				}
				Puts($"Webhook answered: {response}");
			}, this, RequestMethod.POST);
		}
        void OnServerInitialized()
        {
			
			
			Rust.Defines.appID = 252490U;
			ConVar.Server.encryption = 1;
			ConVar.App.port = -1;
			//global::EACServer.easyAntiCheat=null;
			//ConVar.Server.secure=false;
            users = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>("AuthLite/Users");
			Debug.Log("[AuthLite] read "+users.Count+" users");
			//server.port=-1;
			
        }
		bool EqualUsers(Dictionary<ulong,string> a, Dictionary<ulong,string> b) {
			if (a.Count!=b.Count) return false;
			foreach( KeyValuePair<ulong, string> u in a )
			{
				if (!b.ContainsKey(u.Key)) return false;
				if (u.Value!=b[u.Key]) return false;
			}
			return true;
		}
		void OnServerSave() 
        {
			if (!EqualUsers(users,lastSaved)) {
				lastSaved = new Dictionary<ulong,string>(users);
				Debug.Log("[AuthLite] write "+users.Count+" users");
				Interface.Oxide.DataFileSystem.WriteObject("AuthLite/Users", users);
			}
        }
		object OnUserApprove(Connection conn) {
            /*
            ulong conn.userid
            byte[] conn.token
            string conn.username
            string conn.ipadress
            global::ConnectionAuth.Reject(connection, "You are not allowed to join ;)", null);
            */
			string[] port=conn.ipaddress.Split(':');
			string ipName=conn.ipaddress.Replace(port[1],conn.username);
			if (users.ContainsKey(conn.userid)) {
				//login
				/*if (users[conn.userid] != ipName) {
					Debug.Log("[AuthLite] User "+conn.username+" Fail to Login");
					return null;//normal auth
				}*/
				
				Debug.Log("[AuthLite] User "+conn.username+" Login");
				
			} else {
				//register
				Debug.Log("[AuthLite] User "+conn.username+" Registered");
				users[conn.userid]=ipName;
			}
			
			global::ConnectionAuth.m_AuthConnection.Add(conn);
			
			ConnectionAuth auth=GameObject.FindObjectOfType<ConnectionAuth>();
			/*
			GameObject[] gos = (GameObject[])GameObject.FindObjectsOfType(GameObject);
            
             for (int i = 0; i < gos.Length; ++i)
             {
                 auth = (typeof(ConnectionAuth)) gos[i].GetComponent(typeof(ConnectionAuth));
                 if (auth!=null) {
                    break;
                 }
             }
			*/
			auth.StartCoroutine(AuthRoutine(conn,auth));
			
            return "Talk shit get hit";//if this value is not null breaks the steam auth
        }
		public static IEnumerator EAC(Connection connection)
		{
			connection.authStatus = string.Empty;
			
			global::EACServer.OnJoinGame(connection);
			while (connection.active && !connection.rejected && connection.authStatus == string.Empty)
			{
				yield return null;
			}
			yield break;
		}
		public static IEnumerator FakeSteam(Connection connection) {
		/*connection.authStatus = "";
			if (!PlatformService.Instance.BeginPlayerSession(connection.userid, connection.token))
		{*/
			
			 MethodInfo authLocal = typeof(EACServer).GetMethod("OnAuthenticatedLocal", BindingFlags.Static | BindingFlags.NonPublic);
			MethodInfo authRemote = typeof(EACServer).GetMethod("OnAuthenticatedRemote", BindingFlags.Static | BindingFlags.NonPublic);
			
					authLocal.Invoke(null, new object[]
					{
						connection
					});
					authRemote.Invoke(null, new object[]
					{
						connection
					});
				//no steam player
			//Debug.Log("[AuthLite]NoSteam Player");
				connection.authStatus = "ok";
				yield return null;
				yield return null;
				yield return null;
				/*connection.rejected = false;
				connection.active = true;
				connection.authLevel = 0U;*/
		//}
			/*global::Auth_Steam.waitingList.Add(connection);
			Stopwatch timeout = Stopwatch.StartNew();
			while (timeout.Elapsed.TotalSeconds < 30.0 && connection.active && !(connection.authStatus != ""))
			{
				yield return null;
			}
			global::Auth_Steam.waitingList.Remove(connection);
			if (!connection.active)
			{
				yield break;
			}
			if (connection.authStatus.Length == 0)
			{
				global::ConnectionAuth.Reject(connection, "Steam Auth Timeout", null);
				PlatformService.Instance.EndPlayerSession(connection.userid);
				yield break;
			}
			if (connection.authStatus == "banned")
			{
				global::ConnectionAuth.Reject(connection, "Auth: " + connection.authStatus, null);
				PlatformService.Instance.EndPlayerSession(connection.userid);
				yield break;
			}
			if (connection.authStatus == "gamebanned")
			{
				global::ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatus, null);
				PlatformService.Instance.EndPlayerSession(connection.userid);
				yield break;
			}
			if (connection.authStatus == "vacbanned")
			{
				global::ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatus, null);
				PlatformService.Instance.EndPlayerSession(connection.userid);
				yield break;
			}*/
			//string text = ConVar.Server.censorplayerlist ? RandomUsernames.Get(connection.userid + (ulong)((long)Random.Range(0, 100000))) : connection.username;
			PlatformService.Instance.UpdatePlayerSession(connection.userid, connection.username);
			yield break;
		}
		public IEnumerator AuthRoutine(Connection connection,ConnectionAuth auth)
		{
			//yield return auth.StartCoroutine(global::Auth_Steam.Run(connection));
			/*if (connection.authStatus != "ok") {
				Debug.Log();
			}*/
			/*Rust.Defines.appID = 252490U;
			yield return auth.StartCoroutine(global::Auth_Steam.Run(connection));
		if (connection.authStatus!="ok")
		{*/
			//no steam player
			Debug.Log("[AuthLite] NoSteam Player");
			yield return auth.StartCoroutine(FakeSteam(connection));
		//}
			
			//yield return auth.StartCoroutine(EAC(connection));
			//yield return auth.StartCoroutine(global::Auth_EAC.Run(connection));
			//yield return auth.StartCoroutine(global::Auth_CentralizedBans.Run(connection));
			/*if (connection.rejected || !connection.active)
			{
				yield break;
			}*/
			/*if (auth.IsAuthed(connection.userid))
			{
				global::ConnectionAuth.Reject(connection, "Ya estas conectado!", null);
				yield break;
			}*/
			yield return null;
			global::ConnectionAuth.m_AuthConnection.Remove(connection);
			
			//approve
			Debug.Log("[AuthLite] Approving...");
			auth.Approve(connection);
			Webhook(connection.username+" Connected from "+ConVar.Server.hostname);
		/*
		//ConnectionQueue cq = ServerMgr.Instance.connectionQueue;
		
		connection.state = Network.Connection.State.InQueue;
		//cq.queue.Add(connection);
		//cq.nextMessageTime = 0f;
		SingletonComponent<global::ServerMgr>.Instance.nextMessageTime = 0f;
		SingletonComponent<global::ServerMgr>.Instance.JoinGame(connection);*/
			yield break;
		}
    }
}

// --- End of file: AuthLite.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SecureAdmin.cs ---
// --- Original Local Path: SecureAdmin.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("SecureAdmin", "OwnProx", 0.2, ResourceId = 13661)]
    [Description("Secure Admins.")]
    public class SecureAdmin : RustPlugin
    {	
	#region VARIBLES
		private Dictionary<ulong, float> Bans = new Dictionary<ulong, float>();
		private System.Timers.Timer timer;
		private DateTime NowTimePlease = new DateTime(2016, 2, 2, 0, 0, 0);
		private List<ulong> IdsToRemove = new List<ulong>();
	#endregion
	#region COMMANDS
		[ChatCommand("spectate")]
		private void SpectateChatCmd(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, "CanSpecTate"))
            {
				if (!player.IsSpectating())
				{
					var target = (args.Length > 0 ? BasePlayer.Find(args[0])?.displayName : string.Empty);
					if (string.IsNullOrEmpty(target) || target == player.displayName)
					{
						PrintToChat(player, "No target has been set");
						return;
					}
					player.Die();
					player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
					player.gameObject.SetLayerRecursive(10);
					player.CancelInvoke("MetabolismUpdate");
					player.CancelInvoke("InventoryUpdate");
					PrintToChat(player, "Started Spectating");
					player.UpdateSpectateTarget(target);
					player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
				}
				else
				{
					player.SetParent(null, 0);
					player.metabolism.Reset();
					player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
					player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
					player.gameObject.SetLayerRecursive(17);
					PrintToChat(player, "Stopped Spectating");
					player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
				}
            } else SendReply(player, "You don't have spectating permissions!");
        }
		
		[ChatCommand("tempban")]
        private void TempBanPlayer(BasePlayer player, string command, string[] args)
		{
			if (permission.UserHasPermission(player.UserIDString, "CanTempBanPlayer"))
            {
				if(args.Length < 2) SendReply(player, "Syntax Error: /tempban <user> <hours>");
				else
				{
					int hour = 0;
					if(int.TryParse(args[1], out hour))
					{
						if(hour > 0 && hour < 13)
						{
							BasePlayer b = BasePlayer.Find(args[0]);							                               
							if(b!=null)
							{
								if(b.net.connection.authLevel > 0 || permission.UserHasPermission(b.UserIDString, "CanBanPlayer") || permission.UserHasPermission(b.UserIDString, "CanTempBanPlayer"))
									SendReply(player, "Cannot ban a member of the Staff!");
								else
								{
									Bans.Add(b.userID, (float)(GetTimestamp() + (3600000f * hour)));
									SendReply(player, b.displayName + " has been banned for " + hour + " hours!");
									Network.Net.sv.Kick(b.net.connection, "You have been banned for " + hour + " hours!");
								}
							}
							else SendReply(player, "Player not found!");
						} else SendReply(player, "You can only ban 1-12 hours");
					} else SendReply(player, "Failed to parse Hour!");
				}
			} else SendReply(player, "You don't have temp ban permissions!");
		}
		
		[ChatCommand("ban")]
        private void BanPlayer(BasePlayer player, string command, string[] args)
		{
			if (permission.UserHasPermission(player.UserIDString, "CanBanPlayer"))
            {
				if(args.Length < 2) SendReply(player, "Syntax Error: /ban <user> <reason>");
				else
				{
					BasePlayer b = BasePlayer.Find(args[0]);							                               
					if(b!=null)
					{
						if(b.net.connection.authLevel > 0 || permission.UserHasPermission(b.UserIDString, "CanBanPlayer"))
							SendReply(player, "Cannot ban a member of the Staff!");
						else
						{
							string Reason = "";
							for(int i = 1; i < args.Length; i++) if(i == args.Length-1) Reason += args[i]; else Reason += args[i] + " ";
							ConsoleSystem.Run.Server.Quiet(string.Format("banid {0} \"{1}\" \"{2}\"", b.UserIDString, player.displayName, Reason),true);
							Network.Net.sv.Kick(b.net.connection, Reason);
						}
					}
					else SendReply(player, "Player not found!");
				}
			} else SendReply(player, "You don't have ban permissions!");
		}
		
		[ChatCommand("kick")]
        private void KickPlayer(BasePlayer player, string command, string[] args)
		{
			if (permission.UserHasPermission(player.UserIDString, "CanKickPlayer"))
            {
				if(args.Length < 2) SendReply(player, "Syntax Error: /kick <user> <reason>");
				else
				{					
					BasePlayer b = BasePlayer.Find(args[0]);
					if(b!=null)
					{
						if(b.net.connection.authLevel > 0 || permission.UserHasPermission(b.UserIDString, "CanBanPlayer") || permission.UserHasPermission(b.UserIDString, "CanTempBanPlayer") || permission.UserHasPermission(b.UserIDString, "CanKickPlayer"))
							SendReply(player, "Cannot kick a member of the Staff!");
						else
						{
							string Reason = "";
							for(int i = 1; i < args.Length; i++) if(i == args.Length-1) Reason += args[i]; else Reason += args[i] + " ";
							SendReply(player, b.displayName + " has been kicked!");
							Network.Net.sv.Kick(b.net.connection, Reason);
						}
					}
					else SendReply(player, "Player not found!");
				}
			} else SendReply(player, "You don't have kick permissions!");
		}
		
		[ChatCommand("say")]
		private void SayPlayer(BasePlayer player, string command, string[] args)
		{
			if (permission.UserHasPermission(player.UserIDString, "CanSayPlayer"))
            {
				if(args.Length < 1) SendReply(player, "Syntax Error: /say <msg>");
				else 
				{
					string Msg = "";
					for(int i = 1; i < args.Length; i++) if(i == args.Length-1) Msg += args[i]; else Msg += args[i] + " ";
					ConsoleSystem.Run.Server.Quiet("say " + Msg,true);
				}
			} else SendReply(player, "You don't have say permissions!");
		}
		
		[ChatCommand("permission")]
        private void EditPlayerPermission(BasePlayer player, string command, string[] args)
		{
			if (player.net.connection.authLevel == 2)
            {
				if(args.Length < 2) SendReply(player, "Syntax Error: /auth <user> <permission>");
				else
				{					
					BasePlayer b = BasePlayer.Find(args[0]);
					if(b!=null)
					{
						switch(args[1])
						{
							case "kick":
								if(HandlePermission(b.displayName, b.UserIDString, "CanKickPlayer")) SendReply(player, b.displayName + " Kick permission added!");
								else SendReply(player, b.displayName + " Kick permission removed!");
							break;
							case "tempban":
								if(HandlePermission(b.displayName, b.UserIDString, "CanTempBanPlayer")) SendReply(player, b.displayName + " Temp ban permission added!");
								else SendReply(player, b.displayName + " Temp ban permission removed!");
							break;
							case "ban":
								if(HandlePermission(b.displayName, b.UserIDString, "CanBanPlayer")) SendReply(player, b.displayName + " Ban permission added!");
								else SendReply(player, b.displayName + " Ban permission removed!");
							break;
							case "spectate":
								if(HandlePermission(b.displayName, b.UserIDString, "CanSpecTate")) SendReply(player, b.displayName + " Spectate permission added!");
								else SendReply(player, b.displayName + " Spectate permission removed!");
							break;
							case "say":
								if(HandlePermission(b.displayName, b.UserIDString, "CanSayPlayer")) SendReply(player, b.displayName + " Say permission added!");
								else SendReply(player, b.displayName + " Say permission removed!");
							break;
						}				
						ConsoleSystem.Run.Server.Quiet("server.writecfg",true);
					}	else SendReply(player, "Player not found!");
				}
			} else SendReply(player, "You are not a admin!");
		}
	#endregion
	#region Hooks
		[HookMethod("OnPlayerInit")]
		private void OnPlayerInit(BasePlayer player)
		{
			float t = 0f;
			if(Bans.TryGetValue(player.userID, out t) && t > GetTimestamp()) Network.Net.sv.Kick(player.net.connection, "You are still banned for " + (int) Math.Round(((t-GetTimestamp()) / 60000), 0) + " minutes.");
		}
		
		[HookMethod("OnRunCommand")]
        private object OnRunCommand(ConsoleSystem.Arg arg)
        {
			if(arg?.connection?.authLevel < 2) return null;
            if (arg?.cmd?.namefull != "global.spectate" || arg.connection == null) return null;
            SpectateChatCmd(arg.connection.player as BasePlayer, null, new[] { arg.GetString(0) });
            return true;
        }
		
		[HookMethod("Loaded")
        private void Loaded()
        {
            permission.RegisterPermission("CanTempBanPlayer", this);
            permission.RegisterPermission("CanBanPlayer", this);
            permission.RegisterPermission("CanKickPlayer", this);
			permission.RegisterPermission("CanSpecTate", this);
			permission.RegisterPermission("CanSayPlayer", this);
			timer = new System.Timers.Timer();
            timer.Interval = 36000000;
            timer.Elapsed += new System.Timers.ElapsedEventHandler(EveryTenHours);
			timer.Start();	
        }
		
		[HookMethod("Unload")]
		private void Unload()
		{
			Bans.Clear();
			timer.Stop();
			timer.Dispose();
		}			
	#endregion
	#region FUNCTIONS
		private double GetTimestamp()
		{
			return System.DateTime.UtcNow.Subtract(NowTimePlease).TotalMilliseconds;
		}
	
		private void EveryTenHours(object sender, System.Timers.ElapsedEventArgs e) //used to clean bans just incase someone never loggs back in
        {
			double time = GetTimestamp();
			foreach(KeyValuePair<ulong, float> p in Bans) if(time > p.Value) IdsToRemove.Add(p.Key);
			foreach(ulong i in IdsToRemove) Bans.Remove(i);
			IdsToRemove.Clear();
		}
	
		private bool HandlePermission(string name, string userID, string Permission)
		{
			if(permission.UserHasPermission(userID, Permission)) 
			{
				ConsoleSystem.Run.Server.Quiet(string.Format("oxide.revoke user {0} {1}", name, Permission),true);
				return false;
			}
			else ConsoleSystem.Run.Server.Quiet(string.Format("oxide.grant user {0} {1}", name, Permission),true);
			return true;
		}
	#endregion		
    }
}

// --- End of file: SecureAdmin.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InstantBarrel.cs ---
// --- Original Local Path: InstantBarrel.cs ---

using System;
using CompanionServer.Handlers;
using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Instant Barrel", "rustmods.ru", "1.1.5")]
    [Description("Makes barrels and road signs 1 hp and instantly spawns loot in player inventory")]
    public class InstantBarrel : RustPlugin
    {
        private const string onPermission = "InstantBarrel.on";

        private readonly string[] lootBarrelsNames = { "loot_barrel_1", "loot_barrel_2", "loot-barrel-1", "loot-barrel-2", "oil_barrel", "roadsign1", "roadsign2", "roadsign3", "roadsign4", "roadsign5", "roadsign6", "roadsign7", "roadsign8", "roadsign9" };

        private void OnServerInitialized() => permission.RegisterPermission(onPermission, this);

        private object OnEntityTakeDamage(LootContainer lootContainer, HitInfo hitInfo)
        {
            if (lootContainer == null || hitInfo == null || hitInfo.ProjectileDistance > config.maxDistance)
                return null;

            if (!config.oneShot && hitInfo.damageTypes.Total() < lootContainer.health) 
                return null;

            var lootContainerName = lootContainer.ShortPrefabName;

            if (lootContainerName == null || !lootBarrelsNames.Contains(lootContainerName))
                return null;

            var player = lootContainer.lastAttacker as BasePlayer ?? hitInfo.InitiatorPlayer;

            if (player == null || !permission.UserHasPermission(player.UserIDString, onPermission))
                return null;

            var itemContainer = lootContainer?.inventory;

            if (itemContainer == null) return null;

            if ((int)Vector2.Distance(player.transform.position, lootContainer.transform.position) > config.maxDistance) return null;

            if (!config.eWeapon && hitInfo.IsProjectile()) return null;

            for (int i = itemContainer.itemList.Count - 1; i >= 0; i--)
                player.GiveItem(itemContainer.itemList[i], BaseEntity.GiveItemReason.PickedUp);

            if (itemContainer.itemList == null || itemContainer.itemList.Count <= 0)
            {
                NextTick(() =>
                {
                    Interface.CallHook("OnEntityDeath", lootContainer, hitInfo);

                    if (config.gibs) lootContainer?.Kill(BaseNetworkable.DestroyMode.Gib);

                    else lootContainer?.Kill();
                });
            }

            return false;
        }

        #region Config
        static Configuration config;
        public class Configuration
        {
            [JsonProperty("Enable farming with weapons")]
            public bool eWeapon = true;

            [JsonProperty("Max farming distance")]
            public float maxDistance = 3f;

            [JsonProperty("Make barrels 1 hit to kill")]
            public bool oneShot = true;

            [JsonProperty("Enable barrel gibs")]
            public bool gibs = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion
    }
}

// --- End of file: InstantBarrel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HelpText.cs ---
// --- Original Local Path: HelpText.cs ---

using System;
using System.Collections.Generic;
using System.Text;

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("HelpText", "Domestos/Calytic", "2.0.1", ResourceId = 676)]
    class HelpText : CovalencePlugin
    {
        private bool UseCustomHelpText;
        private bool AllowHelpTextFromOtherPlugins;
        private List<object> CustomHelpText;

        private void Loaded()
        {
            this.UseCustomHelpText = GetConfig<bool>("Settings", "UseCustomHelpText", false);
            this.AllowHelpTextFromOtherPlugins = GetConfig<bool>("Settings", "AllowHelpTextFromOtherPlugins", true);
            this.CustomHelpText = GetConfig<List<object>>("CustomHelpText", new List<object>() {
                "custom helptext",
                "custom helptext"
            });
        }

        protected override void LoadDefaultConfig()
        {
            Config["UseCustomHelpText"] = false;
            Config["Settings", "AllowHelpTextFromOtherPlugins"] = true;
            Config["Settings", "CustomHelpText"] = CustomHelpText = new List<object>() {
                "custom helptext",
                "custom helptext"
            };

            SaveConfig();
        }

        [Command("help")]
        void cmdHelp(IPlayer player, string command, string[] args)
        {
            if (player == null) return;

            if (UseCustomHelpText)
            {
                StringBuilder sb = new StringBuilder();
                int i = 0;
                foreach (var text in CustomHelpText)
                {
                    sb.AppendLine(text.ToString());
                    i++;

                    if (i % 10 == 0)
                    {
                        player.Reply(sb.ToString());
                        sb.Clear();
                        i = 0;
                    }
                }

                if (i > 0)
                {
                    player.Reply(sb.ToString());
                }
            }

            if (AllowHelpTextFromOtherPlugins)
            {
                var gameObject = player.Character.Object;
                if(gameObject is GameObject) {
				    plugins.CallHook("SendHelpText", (gameObject as GameObject).GetComponent<BasePlayer>());
                }
            }
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private T GetConfig<T>(string name, string name2, T defaultValue)
        {
            if (Config[name, name2] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name, name2], typeof(T));
        }
    }
}

// --- End of file: HelpText.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MarkerTeleporter.cs ---
// --- Original Local Path: MarkerTeleporter.cs ---

using UnityEngine;
using ProtoBuf;
using System.Collections.Generic;
using Oxide.Core.Configuration;
using Oxide.Core;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("MarkerTeleporter", "walkinrey", "1.0.0")]
    class MarkerTeleporter : RustPlugin
    {
        #region References
        DynamicConfigFile data;
        List<string> optionActive = new List<string>();
        string currentStatus;
        #endregion
        #region Hooks
        void OnMapMarkerAdded(BasePlayer player, MapNote note)
        {
            if(optionActive == null || player == null || note == null || !optionActive.Contains(player.userID.ToString()) || !player.IPlayer.HasPermission("markerteleporter.use")) return;
            Vector3 pos = note.worldPosition;
            pos.y = GetCorrectPos(pos);
            player.Teleport(pos);
            SendReply(player, "");
        }
        void Init() 
        {
            permission.RegisterPermission("markerteleporter.use", this); 
            data = Interface.Oxide.DataFileSystem.GetDatafile("MarkerTeleporter"); 
            string stringOptions = (string)data["optionList"]; 
            cmd.AddChatCommand("mt", this, "cmdChat");
            if(stringOptions == null || stringOptions == "") return;
            optionActive = new List<string>(stringOptions.Split(','));
            if(optionActive == null) optionActive = new List<string>();
        }
        #endregion
        #region Helpers
        float GetCorrectPos(Vector3 pos)
        { 
            float y = TerrainMeta.HeightMap.GetHeight(pos); 
            RaycastHit hit; 
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" } )) && !hit.collider.name.Contains("rock_cliff")) 
            {
                return Mathf.Max(hit.point.y, y);
            }
            else
            {
                return y;
            }
        }
        #endregion
        #region Methods
        void cmdChat(BasePlayer player, string command, string[] args)
        {
            if(!player.IPlayer.HasPermission("markerteleporter.use")) return;
            if(args == null || args?.Length == 0) 
            {
                if(optionActive.Contains(player.userID.ToString())) currentStatus = "включен.";
                if(!optionActive.Contains(player.userID.ToString())) currentStatus = "выключен.";
                SendReply(player, "Команды плагина MarkerTeleporter\n/mt - открыть информацию по командам\n/mt off - отключить телепорт по карте\n/mt on - включить телепорт по карте\nВ настоящий момент ваш телепорт по карте: " + currentStatus); 
                return;
            }
            switch(args[0].ToLower())
            {
                case "off":
                    DisactivateFunction(player);
                    break;
                case "on":
                    ActivateFunction(player);
                    break;
            }
        }
        void ActivateFunction(BasePlayer player)
        {
            if(optionActive.Contains(player.userID.ToString())) {SendReply(player, "У вас уже включена функция телепорта!"); return;}
            if(!optionActive.Contains(player.userID.ToString())) optionActive.Add(player.userID.ToString());
            string listAsString = string.Join(",", optionActive.ToArray());
            data["optionList"] = listAsString;
            data.Save();
            SendReply(player, "Вы активировали телепорт по карте используя маркер. Чтобы отключить его, введите /mt off");
        }
        void DisactivateFunction(BasePlayer player)
        {
            if(!optionActive.Contains(player.userID.ToString())) {SendReply(player, "У вас уже отключена функция телепорта!"); return;}
            if(optionActive.Contains(player.userID.ToString())) {optionActive.Remove(player.userID.ToString());}
            string listAsString = string.Join(",", optionActive.ToArray());
            data["optionList"] = listAsString;
            data.Save();
            SendReply(player, "Вы отключили телепорт по карте используя маркер. Чтобы включить его, введите /mt on");
        }
        #endregion
    }
}

// --- End of file: MarkerTeleporter.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Help.cs ---
// --- Original Local Path: Help.cs ---

﻿using System;
using System.Linq;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System.Globalization;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Help", "Chibubrik", "2.0.0")]
    class Help : RustPlugin
    {
        #region Variables
        private string Layer = "UI_Help";
        #endregion

        #region Class
        public Dictionary<string, HelpList> help = new Dictionary<string, HelpList>();
        public class HelpList
        {
            [JsonProperty("Название кнопки")] public string NameUI;
            [JsonProperty("Команда")] public string Command;
            [JsonProperty("Цвет кнопки")] public string ButtonColor;
            [JsonProperty("Размер текста")] public int Sizes;
            [JsonProperty("Список")] public List<Messages> MessagesList = new List<Messages>();
        }

        public class Messages
        {
            [JsonProperty("Текст")] public string Message;
        }
        #endregion

        #region Command
        [ChatCommand("help")]
        void cmdHelp(BasePlayer player, string command, string[] args) => HelpUI(player);

        [ConsoleCommand("help")]
        void cmdConsoleHelp(ConsoleSystem.Arg args)
        {
            string name = args.FullString.Split('+')[0];
            var player = args.Player();
            if (name.ToLower().Contains("/"))
            {
                CuiHelper.DestroyUi(player, Layer);
                player.Command($"chat.say {name}");
            }
            else
            {
                HelpUI(args.Player(), true, name);
            }
        }

        [ConsoleCommand("next.page")]
        void cmdNewxt(ConsoleSystem.Arg args)
        {
            var name = args.Args[0];
            var amount = int.Parse(args.Args[1]);
            HelpUI(args.Player(), true, name, amount);
        }
        #endregion

        #region UI
        private void HelpUI(BasePlayer player, bool section = false, string name = "", int numbr = 0)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            Dictionary<string, string> List = new Dictionary<string, string>();
            float gap = -0.0f;
            float width = 0.1584f;
            float height = 0.2f;
            float startxBox = 0.341f;
            float startyBox = 0.522f - height;
            float xmin = startxBox;
            float ymin = startyBox;
            int current = 1;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.8", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.5f },
                FadeOut = 0.4f
            }, "Overlay", Layer);

            if (!section)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.3 0.59", AnchorMax = $"0.7 0.67", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = "Вы новый игрок в Rust?", Font = "robotocondensed-bold.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter, FadeIn = 0.5f }
                }, Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.3 0.54", AnchorMax = $"0.7 0.585", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = "Мы понимаем, что нас посетят много новых игроков\nЕсли это относится и к вам, нажмите на одну из двух кнопок!", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = HexToCuiColor("#FFFFFF5A"), FadeIn = 0.5f },
                }, Layer);
            }

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            if (section)
            {
                foreach (var message in help[name].MessagesList)
                {
                    if (List.ContainsKey(message.Message))
                    {
                        Puts($"В разделе {name} найдены дублирующиеся сообщения, они убраны с показа");
                        continue;
                    }
                    List.Add(message.Message, "");
                    if (List.Count == 0)
                    {
                        PrintWarning($"У раздела [{help[name].NameUI}] нету сообщений, раздел отключен!");
                        return;
                    }

                }
                container.Add(new CuiPanel()
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0", FadeIn = 0.5f },
                    FadeOut = 0.4f,
                }, Layer, $"{name}");

                foreach (var Messages in List)
                {
                    if (numbr > 0)
                    {
                        var List1 = List.Skip(numbr);
                        foreach (var nubm2 in List1)
                        {
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Button = { Color = "0 0 0 0", Close = Layer },
                                Text = { Text = nubm2.Key, Font = "robotocondensed-regular.ttf", FontSize = help[name].Sizes, Align = TextAnchor.MiddleCenter, Color = HexToCuiColor("#FFFFFF5A"), FadeIn = 0.5f }
                            }, $"{name}");
                            if (List1.Count() > 1)
                            {
                                container.Add(new CuiButton
                                {
                                    RectTransform = { AnchorMin = "0.94 0.46", AnchorMax = "0.99 0.54", OffsetMax = "0 0" },
                                    Button = { Color = "0 0 0 0", Command = $"next.page {name} {numbr + 1}", FadeIn = 0.5f },
                                    Text = { Text = ">", Font = "robotocondensed-bold.ttf", FontSize = 45, Align = TextAnchor.MiddleCenter, Color = HexToCuiColor("#FFFFFF5A"), FadeIn = 0.5f }
                                }, Layer, $"{name}");
                                break;
                            }

                        }
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.01 0.46", AnchorMax = "0.06 0.54", OffsetMax = "0 0" },
                            Button = { Color = "0 0 0 0", Command = $"next.page {name} {numbr - 1}", FadeIn = 0.5f },
                            Text = { Text = "<", Font = "robotocondensed-bold.ttf", FontSize = 45, Align = TextAnchor.MiddleCenter, Color = HexToCuiColor("#FFFFFF5A"), FadeIn = 0.5f }
                        }, Layer, $"{name}");
                        CuiHelper.AddUi(player, container);
                        return;
                    }
                    else
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { Color = "0 0 0 0", Close = Layer },
                            Text = { Text = Messages.Key, Font = "robotocondensed-regular.ttf", FontSize = help[name].Sizes, Align = TextAnchor.MiddleCenter, Color = HexToCuiColor("#FFFFFF5A"), FadeIn = 0.5f }
                        }, $"{name}");

                        if (List.Count > 1)
                        {
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0.94 0.46", AnchorMax = "0.99 0.54", OffsetMax = "0 0" },
                                Button = { Color = "0 0 0 0", Command = $"next.page {name} {+1}", FadeIn = 0.5f },
                                Text = { Text = ">", Font = "robotocondensed-bold.ttf", FontSize = 45, Align = TextAnchor.MiddleCenter, Color = HexToCuiColor("#FFFFFF5A"), FadeIn = 0.5f }
                            }, Layer, $"{name}");
                            break;
                        }
                    }
                }
                CuiHelper.AddUi(player, container);
                return;
            }

            foreach (var check in help)
            {
                container.Add(new CuiButton()
                {
                    Button = { Command = $"help {help[check.Key].Command}", Color = help[check.Key].ButtonColor, Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.5f },
                    RectTransform = {
                        AnchorMin = xmin + " " + ymin,
                        AnchorMax = (xmin + width) + " " + (ymin + height *1),
                        OffsetMax = "-25 -1",
                        OffsetMin = "25 10",
                    },
                    Text = { Text = $"{help[check.Key].NameUI}", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 55 }
                }, Layer, $"{help[check.Key].NameUI}");
                xmin += width + gap;

                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height + gap;
                }

                if (current > 2)
                {
                    break;
                }
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Oxide
        private void OnServerInitialized()
        {
            LoadData();
            CheckData();
            if (EnabledLogin)
            {
                BasePlayer.activePlayerList.ForEach(OnPlayerInit);
            }
        }

        private bool EnabledLogin = true;
        void OnPlayerInit(BasePlayer player)
        {
            if (EnabledLogin)
            {
                if (player.IsReceivingSnapshot)
                {
                    NextTick(() =>
                    {
                        OnPlayerInit(player);
                        return;
                    });
                }
                HelpUI(player);
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
        }

        private void CheckData()
        {
            foreach (var check in help)
            {
                if (string.IsNullOrEmpty(help[check.Key].Command))
                {
                    PrintError($"У кнопки {check.Key} не установлена команда!");
                    continue;
                }

                foreach (var Messages in help[check.Key].MessagesList)
                {
                    if (string.IsNullOrEmpty(Messages.Message))
                    {
                        PrintError($"В разделе {check.Key} не созданы сообщения!");
                    }
                }
            }
        }
        #endregion

        #region Data
        private void LoadData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Help/Text"))
            {
                help = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, HelpList>>("Help/Text");
            }
            else
            {
                help.Add("yes", new HelpList()
                {
                    NameUI = "Да",
                    Command = "yes",
                    ButtonColor = "0.16 0.71 0.39 1",
                    Sizes = 18,
                    MessagesList = new List<Messages>
                    {
                       new Messages
                       {
                           Message = "<b><size=22>С чего начать?</size></b>\nПервым делом Вам понадобится орудие для добычи дерева и камня, и к примеру лук для защиты. Изучите меню <b>''TAB''</b> с\nинвентарем. По мере добычи ресурсов в меню крафта <b>''Q''</b> Вы увидите разблокированные предметы для создания.\nРазбивая бочки Вам будут выпадать компоненты (используются для крафта) и скрап, который также можно потратить на\nИзучение предметов. Чем больше у вас рецептов - тем больше возможностей.\n\n<b><size=22>Что здесь делать?</size></b>\nМир открыт перед Вами, что делать - решаете Вы. Добыча ресурсов, крафт и коммуникация с другими обитателями\nпомогут вам выжить и обзавестись крепкими стенами.\n\n<b><size=22>Как построить дом?</size></b>\nДля строительства Вам понадобится план постройки, киянка и первоначальные ресурсы (дерево и камень). Для первого\nобустройства жилища вы можете получить набор <b>''Обустройство дома''</b>.(/kit). Не забудьте про <b>шкаф</b>!\n\n<b><size=22>Где мне найти сожителя?</size></b>\nВыжить в одиночку очень тяжело. Обзавестись знакомыми можно на ближайшем морском пляже, если вас не зарубят\nкамнем при первом диалоге, то у вас есть шансы! (<b>''V'' - голосовой чат</b>)\nТакже напарника можно найти в обсуждении нашей группы: <b>ГРУППА</b>\n\n<b><size=22>Куда мне обратиться за помощью?</size></b>\nДля получения помощи Вы можете обратиться в группе в вк сервера или ввести команду: <b>/menu</b> в чат.\nГруппа: <b>группа</b>\n\n<b><size=22>Приятной игры на проекте проект</size></b>"
                       },
                       new Messages
                       {
                           Message = ""
                       }
                    }
                });
                help.Add("no", new HelpList()
                {
                    NameUI = "Нет",
                    Command = "no",
                    ButtonColor = "0.72 0.24 0.24 1",
                    Sizes = 18,
                    MessagesList = new List<Messages>
                    {
                       new Messages
                       {
                           Message = "<b><size=22>Добро пожаловать на Проект, друг.</size></b>\n\n<b><size=22>ОСНОВНЫЕ КОМАНДЫ</size></b>\n/kit - открыть меню доступных наборов.\n/report ''ник игрока'' - совершить донос на нечестного работягу.\n/skin - текстильная мастерская.\n\n<b><size=22>ТЕЛЕПОРТАЦИЯ</size></b>\n/tpr ''ник игрока'' - отправить запрос на телепортацию к игроку.\n/tpa(/tpc) - принять/отклонить запрос на телепортацию.\n/sethome(/removehome) ''название'' - создать/удалить точку спавна.\n/home list - открыть список своих жилищ.\n/home ''название'' - телепортация на хату с указанным названием.\n\n<b><size=22>КООПЕРАТИВ</size></b>\n/team add ''имя игрока''\n/team tag ''название''\n\n<b><size=22>Подробнее на САЙТ.RU</size></b>"
                       },
                       new Messages
                       {
                           Message = ""
                       }
                    }
                });
                Interface.Oxide.DataFileSystem.WriteObject("Help/Text", help);
            }
        }
        #endregion

        #region Helpers
        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}

// --- End of file: Help.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ClansTop.cs ---
// --- Original Local Path: ClansTop.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Clans Top", "Mevent", "1.0.1")]
	public class ClansTop : RustPlugin
	{
		#region Fields

		[PluginReference] private Plugin
			Clans = null;

		private static ClansTop _instance;

		private const string Layer = "UI.TopClans";

		private string _topJson;

		#endregion

		#region Config

		private Configuration _config;

		private class Configuration
		{
			[JsonProperty(PropertyName = "Interface Settings")]
			public InterfaceSettings UI = new InterfaceSettings
			{
				DisplayType = "Overlay",
				MaxClansOnString = 3,
				Colors = new List<IColor>
				{
					new IColor("#FF6060"),
					new IColor("#4B68FF"),
					new IColor("#FFD01B")
				},
				BackgroundColor = new IColor("#000000", 80),
				BottomIndent = 0f,
				SideIndent = 0f,
				Width = 80,
				Height = 17.5f,
				Margin = 15,
				NumberSize = 12,
				TextSize = 12,
				TextAlign = TextAnchor.MiddleCenter,
				ShowScore = false,
				ScoreFormat = " ({0})",
				ValueAbbreviation = true
			};
		}

		private class InterfaceSettings
		{
			[JsonProperty(PropertyName = "Display type (Overlay/Hud)")]
			public string DisplayType;

			[JsonProperty(PropertyName = "Max clans on string")]
			public int MaxClansOnString;

			[JsonProperty(PropertyName = "Colors", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<IColor> Colors = new List<IColor>();

			[JsonProperty(PropertyName = "Background Color")]
			public IColor BackgroundColor;

			[JsonProperty(PropertyName = "Bottom Indent")]
			public float BottomIndent;

			[JsonProperty(PropertyName = "Side Indent")]
			public float SideIndent;

			[JsonProperty(PropertyName = "Width")] public float Width;

			[JsonProperty(PropertyName = "Height")]
			public float Height;

			[JsonProperty(PropertyName = "Margin")]
			public float Margin;

			[JsonProperty(PropertyName = "Number Text Size")]
			public int NumberSize;

			[JsonProperty(PropertyName = "Text Size")]
			public int TextSize;

			[JsonProperty(PropertyName = "TextAlign")] [JsonConverter(typeof(StringEnumConverter))]
			public TextAnchor TextAlign;

			[JsonProperty(PropertyName = "Show Score")]
			public bool ShowScore;

			[JsonProperty(PropertyName = "Score Format")]
			public string ScoreFormat;

			[JsonProperty(PropertyName = "Use value abbreviation?")]
			public bool ValueAbbreviation;

			public string GetScore(string clanTag)
			{
				return string.Format(ScoreFormat, _instance.GetValue(_instance.CLANS_GetClanScore(clanTag)));
			}
		}

		private class IColor
		{
			[JsonProperty(PropertyName = "HEX")] public string Hex;

			[JsonProperty(PropertyName = "Opacity (0 - 100)")]
			public readonly float Alpha;

			[JsonIgnore] private string _color;

			[JsonIgnore]
			public string Get
			{
				get
				{
					if (string.IsNullOrEmpty(_color))
						_color = GetColor();

					return _color;
				}
			}

			private string GetColor()
			{
				if (string.IsNullOrEmpty(Hex)) Hex = "#FFFFFF";

				var str = Hex.Trim('#');
				if (str.Length != 6) throw new Exception(Hex);
				var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
				var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
				var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

				return $"{(double) r / 255} {(double) g / 255} {(double) b / 255} {Alpha / 100}";
			}

			public IColor()
			{
			}

			public IColor(string hex, float alpha = 100)
			{
				Hex = hex;
				Alpha = alpha;
			}
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null) throw new Exception();
				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(_config);
		}

		protected override void LoadDefaultConfig()
		{
			_config = new Configuration();
		}

		#endregion

		#region Hooks

		private void OnServerInitialized()
		{
			_instance = this;

			foreach (var player in BasePlayer.activePlayerList)
				OnPlayerConnected(player);
		}

		private void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, Layer);

			_instance = null;
		}

		private void OnPlayerConnected(BasePlayer player)
		{
			StartUpdate(player);
		}

		private void OnClanTopUpdated()
		{
			NextTick(StartUpdate);
		}

		#endregion

		#region Interface

		private void UpdateUI(string json)
		{
			foreach (var player in BasePlayer.activePlayerList)
				UpdateUI(player, json);
		}

		private void UpdateUI(BasePlayer player, string json)
		{
			if (string.IsNullOrEmpty(json)) return;

			CuiHelper.DestroyUi(player, Layer);

			CuiHelper.AddUi(player, json);
		}

		private string GenerateTopUI(IReadOnlyDictionary<int, string> clans)
		{
			var container = new CuiElementContainer();

			if (clans.Count > 0)
			{
				#region Background

				container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0.5 0", AnchorMax = "0.5 0",
						OffsetMin = $"{_config.UI.SideIndent} {_config.UI.BottomIndent}",
						OffsetMax = $"{_config.UI.SideIndent} {_config.UI.BottomIndent + _config.UI.Height}"
					},
					Image = {Color = "0 0 0 0"}
				}, _config.UI.DisplayType, Layer);

				#endregion

				var count = Mathf.Min(_config.UI.MaxClansOnString, clans.Count);

				var xSwitch = -((count * _config.UI.Width +
				                 (count - 1) * _config.UI.Margin) / 2f);

				for (var i = 1; i <= count; i++)
				{
					string clanTag;
					if (clans.TryGetValue(i, out clanTag) == false) continue;

					container.Add(new CuiPanel
					{
						RectTransform =
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = $"{xSwitch} 0",
							OffsetMax = $"{xSwitch + _config.UI.Width} 0"
						},
						Image =
						{
							Color = "0 0 0 0"
						}
					}, Layer, Layer + $".Top.{i}");

					#region Number

					container.Add(new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0 0", AnchorMax = "0 1",
							OffsetMin = "0 0",
							OffsetMax = $"{_config.UI.NumberSize} 0"
						},
						Text =
						{
							Text = $"{i}",
							Align = TextAnchor.MiddleLeft,
							Font = "robotocondensed-bold.ttf",
							FontSize = _config.UI.NumberSize,
							Color = "1 1 1 1"
						}
					}, Layer + $".Top.{i}");

					#endregion

					#region Panel

					container.Add(new CuiPanel
					{
						RectTransform =
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = $"{_config.UI.NumberSize} 0",
							OffsetMax = "0 0"
						},
						Image =
						{
							Color = _config.UI.BackgroundColor.Get
						}
					}, Layer + $".Top.{i}", Layer + $".Top.{i}.Panel");

					#region Line

					if (i - 1 < _config.UI.Colors.Count)
						container.Add(new CuiPanel
						{
							RectTransform =
							{
								AnchorMin = "0 0", AnchorMax = "1 0",
								OffsetMin = "0 0",
								OffsetMax = "0 1.5"
							},
							Image =
							{
								Color = _config.UI.Colors[i - 1].Get
							}
						}, Layer + $".Top.{i}.Panel");

					#endregion

					#region Name

					container.Add(new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "0 0",
							OffsetMax = "0 0"
						},
						Text =
						{
							Text =
								_config.UI.ShowScore ? $"{clanTag}{_config.UI.GetScore(clanTag)}" : $"{clanTag}",
							Align = _config.UI.TextAlign,
							Font = "robotocondensed-regular.ttf",
							FontSize = _config.UI.TextSize
						}
					}, Layer + $".Top.{i}.Panel");

					#endregion

					#endregion

					xSwitch += _config.UI.Width + _config.UI.Margin;
				}
			}

			var json = CuiHelper.ToJson(container);
			return json;
		}

		#endregion

		#region Utils

		private string GetValue(float value)
		{
			if (!_config.UI.ValueAbbreviation)
				return Mathf.Round(value).ToString(CultureInfo.InvariantCulture);

			var t = string.Empty;
			while (value > 1000)
			{
				t += "K";
				value /= 1000;
			}

			return Mathf.Round(value) + t;
		}

		private Dictionary<int, string> CLANS_GetTopClans()
		{
			return Clans?.Call<Dictionary<int, string>>("GetTopClans") ?? new Dictionary<int, string>();
		}

		private float CLANS_GetClanScore(string clanTag)
		{
			return Convert.ToSingle(Clans?.Call("GetClanScores", clanTag));
		}

		private void StartUpdate()
		{
			UpdateTopJson();

			UpdateUI(_topJson);
		}

		private void StartUpdate(BasePlayer player)
		{
			if (string.IsNullOrEmpty(_topJson))
				UpdateTopJson();

			UpdateUI(player, _topJson);
		}

		private void UpdateTopJson()
		{
			_topJson = GenerateTopUI(CLANS_GetTopClans());
		}

		#endregion
	}
}

// --- End of file: ClansTop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XFireGloves.cs ---
// --- Original Local Path: XFireGloves.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XFireGloves", "Monster", "1.0.11")]
	class XFireGloves : RustPlugin
	{
        #region Configuration

        private GlovesConfig config;

        private class GlovesConfig
        {					
			internal class SettingSetting
			{
				[JsonProperty("Использовать разрешение на шанс найти перчатки в ящиках: xfiregloves.glovesloot")] 
                public bool Permission;
			}
			
			internal class GlovesSetting
			{
				[JsonProperty("SkinID огненных перчаток")]
                public ulong SkinIDGloves;
				[JsonProperty("Имя огненных перчаток")]
                public string NameGloves;
				[JsonProperty("Рейты добываемых ресурсов в перчатках")]
                public float GatherValue;                
				[JsonProperty("Рейты подбираемых ресурсов в перчатках")]
                public float PickupValue;
				[JsonProperty("Кол-во радиации при подборе ресурсов")]
                public float RadiationPickupValue;					
				[JsonProperty("Кол-во радиации при бонусной добыче")]
                public float RadiationBonusValue;
				[JsonProperty("Список ресурсов после переработки")]
                public Dictionary<string, int> ItemList;
				
				[JsonProperty("Включить переплавку дерева")]
                public bool SmeltWood;		
			    [JsonProperty("Включить переплавку добываемых ресурсов")]
                public bool SmeltGather;			
			    [JsonProperty("Включить переплавку подбираемых ресурсов")] 
                public bool SmeltPickup;			    
				[JsonProperty("Включить рейты добываемых ресурсов")] 
                public bool GatherGloves;			    
				[JsonProperty("Включить рейты подбираемых ресурсов")] 
                public bool PickupGloves;				    
				[JsonProperty("Включить кастомные предметы после переработке огненных перчаток")] 
                public bool RecyclerGloves;					
				[JsonProperty("Включить выпадение перчаток из ящиков с определенным шансом")] 
                public bool CrateGloves;				
				[JsonProperty("Включить накопление радиации при подборе ресурсов.")] 
                public bool RadiationPickup;				
				[JsonProperty("Включить накопление радиации при бонусной добыче.")] 
                public bool RadiationBonus;
				
				[JsonProperty("Настройка шанса выпадения из ящиков и бочек. Имя ящика/бочки | Шанс выпадения: 1.0 - 100%")]
                public Dictionary<string, float> Crate;	
				
				public GlovesSetting(ulong s, string n, float gv, float pv, float rpv, float rbv, Dictionary<string, int> il, bool sw, bool sg, bool sp, bool gg, bool pg, bool rg, bool cg, bool rp, bool rb, Dictionary<string, float> c)
				{
					SkinIDGloves = s; NameGloves = n; GatherValue = gv; PickupValue = pv; RadiationPickupValue = rpv; RadiationBonusValue = rbv; ItemList = il; SmeltWood = sw; SmeltGather = sg; SmeltPickup = sp; GatherGloves = gg; PickupGloves = pg; RecyclerGloves = rg; CrateGloves = cg; RadiationPickup = rp; RadiationBonus = rb; Crate = c;
				}
			}
            
			[JsonProperty("Общее")]
            public SettingSetting Setting = new SettingSetting();			
			[JsonProperty("Список огненных перчаток")]
            public List<GlovesSetting> Gloves = new List<GlovesSetting>();				
			
			public static GlovesConfig GetNewConfiguration()
            {
                return new GlovesConfig
                {
					Setting = new SettingSetting
					{
						Permission = true
					},
					Gloves = new List<GlovesSetting>
					{
						new GlovesSetting(1742796979, "Огненные перчатки", 1.0f, 1.0f, 0.0f, 0.0f, new Dictionary<string, int>{ ["cloth"] = 100, ["leather"] = 100 }, true, true, true, true, true, true, true, true, true, new Dictionary<string, float>{ ["crate_tools"] = 50.0f, ["crate_normal_2"] = 50.0f }),
						new GlovesSetting(841106268, "Огненные перчатки", 1.0f, 1.0f, 0.0f, 0.0f, new Dictionary<string, int>{ ["cloth"] = 100, ["leather"] = 100 }, false, true, true, true, true, true, true, true, true, new Dictionary<string, float>{ ["crate_tools"] = 50.0f, ["crate_normal_2"] = 50.0f })
					}
				};
			}
        }

        protected override void LoadDefaultConfig()
        {
            config = GlovesConfig.GetNewConfiguration();

            PrintWarning("Создание начальной конфигурации плагина!!!");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<GlovesConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion	

        #region Commands
		
		[ConsoleCommand("gl_give")]
        void GlovesGive(ConsoleSystem.Arg args)
        {
			if (args.Player() != null) return;
			
			BasePlayer player = BasePlayer.FindByID(ulong.Parse(args.Args[0]));
			int number = int.Parse(args.Args[1]);
			
			if (player == null) return;
			
            Item item = ItemManager.CreateByName("burlap.gloves", 1, config.Gloves[number].SkinIDGloves);
            item.name = config.Gloves[number].NameGloves;
		    player.GiveItem(item);
        }

        #endregion		
		
		#region SmeltingGloves
		
		void OnServerInitialized()
        {
			PrintWarning("\n-----------------------------\n" +
			"     Author - Monster\n" +
			"     VK - vk.com/idannopol\n" +
			"     Discord - Monster#4837\n" +
			"     Config - v.998\n" +
			"-----------------------------");
			
			permission.RegisterPermission("xfiregloves.glovesloot", this);
			
            Smelt();
        }
		
        private Dictionary<ItemDefinition, ItemDefinition> Smelting;
        public List<string> SmeltingItemList = new List<string>
        {
            "chicken.raw",
            "humanmeat.raw",
            "bearmeat",
            "deermeat.raw",
            "meat.boar",
            "wolfmeat.raw",
			"horsemeat.raw",
            "hq.metal.ore",
            "metal.ore",
            "sulfur.ore"
        };
		
		void Smelt()
		{
			Smelting = ItemManager.GetItemDefinitions().Where(i => SmeltingItemList.Contains(i.shortname)).ToDictionary(i => i, i => i.GetComponent<ItemModCookable>()?.becomeOnCooked);
            Smelting.Add(ItemManager.FindItemDefinition("wood"), ItemManager.FindItemDefinition("charcoal"));
		}
		
		#endregion
		
		#region GlovesGather
		
		void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
			var player = entity.ToPlayer();
			if (player == null) return;
			
			for (int i = 0; i < config.Gloves.Count; i++)
			{
				foreach (var gloves in player.inventory.containerWear.itemList)
				{
					if (gloves.skin == config.Gloves[i].SkinIDGloves)
					{
						if (config.Gloves[i].GatherGloves) item.amount = (int)(item.amount * config.Gloves[i].GatherValue);
						if (config.Gloves[i].RadiationBonus) player.metabolism.radiation_poison.value += config.Gloves[i].RadiationBonusValue;
						
						if (item.info.shortname == "wood" && config.Gloves[i].SmeltWood == false) continue;
						else if (Smelting.ContainsKey(item.info) && config.Gloves[i].SmeltGather) item.info = Smelting[item.info];
					}
				}
			}
		}
		
		void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
		{
			if (player == null) return;
			
			for (int i = 0; i < config.Gloves.Count; i++)
			{
				foreach (var gloves in player.inventory.containerWear.itemList)
				{
					if (gloves.skin == config.Gloves[i].SkinIDGloves)
					{
						if (config.Gloves[i].GatherGloves) item.amount = (int)(item.amount * config.Gloves[i].GatherValue);
						if (config.Gloves[i].RadiationBonus) player.metabolism.radiation_poison.value += config.Gloves[i].RadiationBonusValue;
						
						if (item.info.shortname == "wood" && config.Gloves[i].SmeltWood == false) continue;
						else if (Smelting.ContainsKey(item.info) && config.Gloves[i].SmeltGather) item.info = Smelting[item.info];
					}
				}
			}
		}
		
		void OnCollectiblePickup(Item item, BasePlayer player)
		{
			if (player == null) return;
			
			for (int i = 0; i < config.Gloves.Count; i++)
			{
				foreach (var gloves in player.inventory.containerWear.itemList)
				{
					if (gloves.skin == config.Gloves[i].SkinIDGloves)
					{
						if (config.Gloves[i].PickupGloves) item.amount = (int)(item.amount * config.Gloves[i].PickupValue);
						if (config.Gloves[i].RadiationPickup) player.metabolism.radiation_poison.value += config.Gloves[i].RadiationPickupValue;
						
						if (item.info.shortname == "wood" && config.Gloves[i].SmeltWood == false) continue;
						else if (Smelting.ContainsKey(item.info) && config.Gloves[i].SmeltPickup) item.info = Smelting[item.info];
					}
				}
			}
		}
		
		#endregion
		
		#region Recycling
		
		object OnRecycleItem(Recycler recycler, Item item)
        {
			for (int i = 0; i < config.Gloves.Count; i++)
			{
				if (item.info.shortname.Equals("burlap.gloves") && item.skin.Equals(config.Gloves[i].SkinIDGloves))
				{
					foreach (var items in config.Gloves[i].ItemList)
                    {
                        Item itemc = ItemManager.CreateByName(items.Key, items.Value);
                        recycler.MoveItemToOutput(itemc);
                    }
				
                    item.RemoveFromWorld(); 
				    item.RemoveFromContainer();
				
                    return false;
				}
			}
			
			return null;
        }
		
		#endregion
		
		#region SpawnGloves
		
		void OnLootEntity(BasePlayer player, BaseEntity entity)
		{
			if (config.Setting.Permission)
			{
				if (!permission.UserHasPermission(player.UserIDString, "xfiregloves.glovesloot")) return;
			}
			
			if (!(entity is LootContainer) || player == null || entity.OwnerID != 0) return;
			
		    var inventory = entity.GetComponent<LootContainer>().inventory;
			var lootcontainer = entity.GetComponent<LootContainer>();
			
			for (int i = 0; i < config.Gloves.Count; i++)
			{
				foreach(var crate in config.Gloves[i].Crate)
				{
					if (crate.Key == lootcontainer.ShortPrefabName)
					{
						if (UnityEngine.Random.Range(0, 100) <= crate.Value)
						{
							Item item = ItemManager.CreateByName("burlap.gloves", 1, config.Gloves[i].SkinIDGloves);
                            item.name = config.Gloves[i].NameGloves;
							
                            item.MoveToContainer(inventory);
							
							entity.OwnerID = player.userID;
						}
					}
				}
			}
		}
		
		#endregion
	}
}

// --- End of file: XFireGloves.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Authentication.cs ---
// --- Original Local Path: Authentication.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Authentication", "JosÃ© Paulo (FaD)", 1.1)]
    [Description("Players must enter a password after they wake up or else they'll be kicked.")]
    public class Authentication : RustPlugin
    {
		public class Request
		{
			public string m_steamID;
			public BasePlayer m_basePlayer;
			public bool m_authenticated;
			public int m_retries;
			public Timer m_countdown;
			
			public Request(string steamID, BasePlayer basePlayer)
			{
				m_steamID = steamID;
				m_basePlayer = basePlayer;
				m_authenticated = false;
				m_retries = 0;
			}
				
		}
		/*----------------*/
		/*Plugin Variables*/
		/*----------------*/
		
		static List<Request> requests = new List<Request>();
		
		/*----------------*/
		/*Plugin Functions*/
		/*----------------*/
		
		/*Message Functions*/
		private void write(string message)
		{
			PrintToChat("<color=lightblue>[AUTH]</color> " + message);
		}
		
		private void write(BasePlayer player, string message)
		{
			PrintToChat(player, "<color=lightblue>[AUTH]</color> " + message);
		}
		
		/*Auth Functions*/
		private bool isEnabled()
		{
			return Convert.ToBoolean(Config["ENABLED"]);
		}
		
		private void requestAuth(Request request)
		{
			//Find and replace "{TIMEOUT}" to the timeout set in the config file
			string message = Convert.ToString(Config["PASSWORD_REQUEST"]).Replace("{TIMEOUT}",Convert.ToString(Config["TIMEOUT"]));
			
			request.m_countdown = timer.Once(Convert.ToInt32(Config["TIMEOUT"]), () => request.m_basePlayer.Kick(Convert.ToString(Config["AUTHENTICATION_TIMED_OUT"])));
			
			write(request.m_basePlayer, message);
		}
		
		/*Chat Commands*/
		[ChatCommand("auth")]
		private void cmdAuth(BasePlayer player, string cmd, string[] args)
		{
			Request request = requests.Find(element => element.m_steamID == player.UserIDString);
			
			//Shouldn't happen.
			if(request == null) return;
			
			if(!request.m_authenticated) //Limit available commands if player is not authed yet
			{		
				switch(args.Length)
				{
					case 0:
						write(player, Convert.ToString(Config["SYNTAX_ERROR"]));
						break;
					case 1:
						if(args[0] == Convert.ToString(Config["PASSWORD"]))
						{
							request.m_countdown.Destroy();
							request.m_authenticated = true;
							write(player, Convert.ToString(Config["AUTHENTICATION_SUCCESSFUL"]));
						}
						else
						{
							int max_retries = Convert.ToInt32(Config["RETRIES"]);
							
							request.m_retries++;
							
							if(max_retries > 0)
							{
								if(request.m_retries == max_retries)
								{
									request.m_basePlayer.Kick(Convert.ToString(Config["AUTHENTICATION_TIMED_OUT"]));
								}
								else
								{
									write(player, "Incorrect password. You have " + (max_retries - request.m_retries) + " retries left.");
								}
							}
							else
							{
								write(player, "Incorrect password. Please try again.");
							}
						}
						break;
				}
			}
			else if(/* request.m_authenticated && */permission.UserHasPermission(request.m_steamID, "authentication.edit"))
			{
				switch(args.Length)
				{
					case 0:
						write(player, Convert.ToString(Config["SYNTAX_ERROR"]));
						break;
					case 1:
						if(args[0] == "password")// /auth password
						{
							write(player, "Password: " + Convert.ToString(Config["PASSWORD"]));
						}
						else if(args[0] == "toggle")// /auth toggle
						{
							Config["ENABLED"] = !isEnabled();
							SaveConfig();
							write(player, "Authentication is now " + ((isEnabled()) ? "enabled" : "disabled") + ".");
						}
						else if(args[0] == "status")// /auth status
						{
							write(player, "Authentication is " + ((isEnabled()) ? "enabled" : "disabled") + ".");
						}
						else if(args[0] == "timeout")
						{
							write(player, "Timeout: " + Convert.ToString(Config["TIMEOUT"]) + " seconds.");
						}
						else if(args[0] == "help")// /auth help
						{
							write(player, 
							"Available commands:\n"
							+ "Syntax: /auth command [required] (optional)'\n"
							+ "<color=silver>/auth [password]</color> - Authenticates players;\n"
							+ "<color=silver>/auth password</color> - Shows password;\n"
							+ "<color=silver>/auth password [new password]</color> - Sets a new password;\n"
							+ "<color=silver>/auth timeout</color> - Shows timeout;\n"
							+ "<color=silver>/auth timeout [new timeout]</color> - Sets a new timeout;\n"
							+ "<color=silver>/auth toggle (on/off)</color> - Toggles Authentication on/off;");
						}
						else if(args[0] == "retries")// /auth retries
						{
							write(player, "Retries: " + Convert.ToString(Config["RETRIES"]));
						}
						break;
					case 2:
						if(args[0] == "password")// /auth password [new password]
						{
							if(args[1] != "password" && args[1] != "help" && args[1] != "toggle" && args[1] != "status" && args[1] != "timeout")
							{
								Config["PASSWORD"] = args[1];
								SaveConfig();
								write(player, "New password: " + Convert.ToString(Config["PASSWORD"]));
							}
						}
						else if(args[0] == "toggle")// /auth toggle (on/off)
						{
							if(args[1] == "on")
							{
								if(!isEnabled())
								{
									Config["ENABLED"] = true;
									SaveConfig();
									write(player, "Authentication is now enabled.");
								}
								else
								{
									write(player, "Authentication is already enabled.");
								}
							}
							else if(args[1] == "off")
							{
								if(isEnabled())
								{
									Config["ENABLED"] = false;
									SaveConfig();
									write(player, "Authentication is now disabled.");
								}
								else
								{
									write(player, "Authentication is already disabled.");
								}
							}
							else
							{
								write(player, "Correct syntax: /auth toggle (on/off)");
							}
						}
						else if(args[0] == "timeout")// /auth timeout [new timeout]
						{
							int converted;
							
							try
							{
								converted = Convert.ToInt32(args[1]);
							}
							catch(FormatException e)
							{
								write(player, "Could not convert " + args[1] + " to an integer.");
								break;
							}
							
							if(converted > 0)
							{	
								Config["TIMEOUT"] = converted;
								SaveConfig();
								write(player, "New timeout: " + Convert.ToString(Config["TIMEOUT"]) + " seconds.");
							}
							else
							{
								write(player, "Timeout must be greater than 0 seconds.");
							}
							
						}
						else if(args[0] == "retries")// /auth retries [new retries]
						{
							int converted;
							
							try
							{
								converted = Convert.ToInt32(args[1]);
							}
							catch(FormatException e)
							{
								write(player, "Could not convert " + args[1] + " to an integer.");
								break;
							}
							
							if(converted >= 0)
							{	
								Config["RETRIES"] = converted;
								SaveConfig();
								write(player, "New retries: " + Convert.ToString(Config["RETRIES"]));
							}
							else
							{
								write(player, "Retries must be a positive integer.");
							}
						}
						break;
				}
			}
		}
		
		/*Console Commands*/
		[ConsoleCommand("global.auth")]
        void ccmdAuth(ConsoleSystem.Arg arg)
        {
			var args = arg.Args;
			
			if(args == null)
			{
				Puts("Correct syntax: auth [command] (arguments)");
				return;
			}
            
			switch(args.Length)
			{
				case 1:
					if(args[0] == "password")// /auth password
					{
						Puts("Password: " + Convert.ToString(Config["PASSWORD"]));
					}
					else if(args[0] == "toggle")// /auth toggle
					{
						Config["ENABLED"] = !isEnabled();
						SaveConfig();
						Puts("Authentication is now " + ((isEnabled()) ? "enabled" : "disabled") + ".");
					}
					else if(args[0] == "status")// /auth status
					{
						Puts("Authentication is " + ((isEnabled()) ? "enabled" : "disabled") + ".");
					}
					else if(args[0] == "timeout")
					{
						Puts("Timeout: " + Convert.ToString(Config["TIMEOUT"]) + " seconds.");
					}
					else if(args[0] == "help")// /auth help
					{
						Puts("Available commands:\n"
						+ "Syntax: auth command [required] (optional)'\n"
						+ "auth password- Shows password;\n"
						+ "auth password [new password] - Sets a new password;\n"
						+ "auth timeout - Shows timeout;\n"
						+ "auth timeout [new timeout] - Sets a new timeout;\n"
						+ "auth toggle (on/off) - Toggles Authentication on/off;");
					}
					else if(args[0] == "retries")// /auth retries
					{
						Puts("Retries: " + Convert.ToString(Config["RETRIES"]));
					}
					break;
				case 2:
					if(args[0] == "password")// /auth password [new password]
					{
						if(args[1] != "password" && args[1] != "help" && args[1] != "toggle" && args[1] != "status" && args[1] != "timeout")
						{
							Config["PASSWORD"] = args[1];
							SaveConfig();
							Puts("New password: " + Convert.ToString(Config["PASSWORD"]));
						}
					}
					else if(args[0] == "toggle")// /auth toggle (on/off)
					{
						if(args[1] == "on")
						{
							if(!isEnabled())
							{
								Config["ENABLED"] = true;
								SaveConfig();
								Puts("Authentication is now enabled.");
							}
							else
							{
								Puts("Authentication is already enabled.");
							}
						}
						else if(args[1] == "off")
						{
							if(isEnabled())
							{
								Config["ENABLED"] = false;
								SaveConfig();
								Puts("Authentication is now disabled.");
							}
							else
							{
								Puts("Authentication is already disabled.");
							}
						}
						else
						{
							Puts("Correct syntax: /auth toggle (on/off)");
						}
					}
					else if(args[0] == "timeout")// /auth timeout [new timeout]
					{
						int converted;
						
						try
						{
							converted = Convert.ToInt32(args[1]);
						}
						catch(FormatException e)
						{
							Puts("Could not convert " + args[1] + " to an integer.");
							break;
						}
						
						if(converted > 0)
						{	
							Config["TIMEOUT"] = converted;
							SaveConfig();
							Puts("New timeout: " + Convert.ToString(Config["TIMEOUT"]) + " seconds.");
						}
						else
						{
							Puts("Timeout must be greater than 0 seconds.");
						}
						
					}
					else if(args[0] == "retries")// /auth retries [new retries]
					{
						int converted;
						
						try
						{
							converted = Convert.ToInt32(args[1]);
						}
						catch(FormatException e)
						{
							Puts("Could not convert " + args[1] + " to an integer.");
							break;
						}
						
						if(converted >= 0)
						{	
							Config["RETRIES"] = converted;
							SaveConfig();
							Puts("New retries: " + Convert.ToString(Config["RETRIES"]));
						}
						else
						{
							Puts("Retries must be a positive integer.");
						}
					}
					break;
			}
		}
		
		/*------------*/
		/*Plugin Hooks*/
		/*------------*/
		
		void Init()
		{
			permission.RegisterPermission("authentication.edit", this);
			LoadDefaultConfig();
		}
		
		//Refreshes the request list when the plugin is reloaded
		void Loaded()
		{
			LoadDefaultConfig();
			
			List<BasePlayer> online = BasePlayer.activePlayerList as List<BasePlayer>;
			foreach(BasePlayer player in online)
			{
				Request request = new Request(player.UserIDString, player);
				request.m_authenticated = true;
				requests.Add(request);
			}
		}
		
		void OnPlayerSleepEnded(BasePlayer player)
		{
			Request request = new Request(player.UserIDString, player);
			
			if(!requests.Exists(element => element.m_steamID == request.m_steamID))
			{
				//Authenticate everyone if the plugin is disabled
				request.m_authenticated = !isEnabled();
				requests.Add(request);
				//And don't send the request
				if(isEnabled()) timer.Once(1, () => requestAuth(request));
			}
			
		}
		
		void OnPlayerDisconnected(BasePlayer player)
		{
			Request request = requests.Find(element => element.m_steamID == player.UserIDString);
			requests.RemoveAt(requests.IndexOf(request));
		}
		
		object OnPlayerChat(ConsoleSystem.Arg arg)
		{
			string hidden = "";
			for(int i = 0; i < Convert.ToString(Config["PASSWORD"]).Length; i++) hidden += "*";
			string original = arg.GetString(0, "text");
			string replaced = original.Replace(Convert.ToString(Config["PASSWORD"]), hidden);
			
			BasePlayer player = arg.connection.player as BasePlayer;
			
			Request request = requests.Find(element => element.m_steamID == player.UserIDString);
			
			if(!request.m_authenticated && Convert.ToBoolean(Config["PREVENT_CHAT"]))
			{
				write(player, "You cannot chat before authentication.");
				return false;
			}
			
			if(original != replaced && Convert.ToBoolean(Config["PREVENT_CHAT_PASSWORD"]))
			{
				rust.BroadcastChat("<color=#5af>" + player.displayName + "</color>", replaced, player.UserIDString);
				return false;
			}
			
			return null;
			
		}
		
		protected override void LoadDefaultConfig()
		{
			Config["ENABLED"] = Config["ENABLED"] ?? true;
			Config["TIMEOUT"] = Config["TIMEOUT"] ?? 30;
			Config["PASSWORD"] = Config["PASSWORD"] ?? "changeme";
			Config["PASSWORD_REQUEST"] = Config["PASSWORD_REQUEST"] ?? "Type /auth [password] in the following {TIMEOUT} seconds to authenticate or you'll be kicked.";
			Config["RETRIES"] = Config["RETRIES"] ?? 0;
			Config["PREVENT_CHAT"] = Config["PREVENT_CHAT"] ?? true;
			Config["PREVENT_CHAT_PASSWORD"] = Config["PREVENT_CHAT_PASSWORD"] ?? false;
			Config["SYNTAX_ERROR"] = Config["SYNTAX_ERROR"] ?? "Correct syntax: /auth [password/command] (arguments)";
			Config["AUTHENTICATION_TIMED_OUT"] = Config["AUTHENTICATION_TIMED_OUT"] ?? "You took too long to authenticate or exceeded the maximum amout of retries.";
			Config["AUTHENTICATION_SUCCESSFUL"] = Config["AUTHENTICATION_SUCCESSFUL"] ?? "Authentication successful.";
				
			SaveConfig();	
		}
		
    }
}

// --- End of file: Authentication.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiChatFlood.cs ---
// --- Original Local Path: AntiChatFlood.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core.Plugins;
using System.Reflection;
using Oxide.Core;
using System.Data;
using Rust;

namespace Oxide.Plugins
{
    [Info("AntiChatFlood", "DylanSMR", "1.0.1")]
    [Description("Data test stuff.")]

    class AntiChatFlood : RustPlugin
    {
        [PluginReference]
        Plugin BetterChat;              
        
        private bool Changed;
        
        //////////
        //Config//
        //////////
 
        static bool WarningEnabled = true;
        static int WaitTillMsg = 5;
        static int MaxWarnings = 3;
        static bool AdminBypass = true;
        public int AuthToBypass = 1;
        
        static bool DisableBetterChat = false; 
 
        void OnServerInitialized()
        {
            LoadVariables();
        } 
 
        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
 
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        
        private void LoadConfigVariables()
        {
            CheckCfg("Time untill a player can chat again.", ref WaitTillMsg);
            CheckCfg("If the warning system is enabled", ref WarningEnabled);
            CheckCfg("How many warnings untill a player is kicked.", ref MaxWarnings);
            CheckCfg("If the plugin disables betterchat when this loades", ref DisableBetterChat);
        }
        
        void Loaded() 
        {    
			lang.RegisterMessages(new Dictionary<string,string>{
				["ACF_WAIT"] = "<color='#DD0000'>You are typing to fast - Please wait {0} seconds.</color>",
                ["ACF_WARNING"] = "<color='#DD0000'>You now have a current total of {0} warnings.</color>",
                ["ACF_ADDED"] = "{0} was added to the data file.",
                ["ACF_REMOVED"] = "{0} was removed from the (temp)data file.",
                ["ACF_KICKING"] = "Kicking {0} for reaching the warning limit of {1}.",
                ["ACF_REASON"] = "You were kicked as you reached the max limit of warnings.",
                ["ACF_HELP"] = "<color='#DD0000'>Help Commands: </cwarning> to check your warnings></color>",
                ["ACF_ADMINHELP"] = "<color='DD0000'>Admin Help Commands: </awipe (target)> to wipe a players warnings | </awipeall> to wipe all player warnings.</color>",
                ["ACF_WIPEDALL"] = "<color='#DD0000'>All players warning wiped to 0, each database file was erased.</color>",
                ["ACF_WIPEDAT"] = "{0} wiped {1}'s warnings!!!",
                ["ACF_WIPEDP"] = "<color='#DD0000'>You have wiped {0}'s warnings</color>",
                ["ACF_WIPEDY"] = "<color='DD0000'>{0} has wiped your warnings</color>",
                ["ACF_WARNINGS"] = "<color='DD0000'>You have a current total of {0} warnings and need {1} more warning to be kicked</color>",
                
			}, this);
            
            if(BetterChat != null)
            {
                if(!DisableBetterChat)
                {
                    rust.RunServerCommand("oxide.unload AntiChatFlood");
                    PrintWarning("PLUGIN UNLOADED DUE TO BETTERCHAT EXISTING!!!");  
                }
                else
                {
                    rust.RunServerCommand("oxide.unload BetterChat");
                    PrintWarning("BETTERCHAT UNLOADED!!!");
                }
            }             		
        }         

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }        
        
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        
        ///////////////////////////////
        //TEMP DATA-DO NOT EDIT BELOW//
        ///////////////////////////////
        

        List<ulong> playerWait = new List<ulong>();        
        private Dictionary<ulong, PlayerWarnings> pWarn = new Dictionary<ulong, PlayerWarnings>(); 

        class PlayerWarnings 
        {
            public string Name;
            public float CurrentWarnings;
        }
                 
        ////////////////////
        //Plugin Functions//
        ////////////////////
        
        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                pWarn.Remove(player.userID);
            }
        }
        
        void Init()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                pWarn.Add(player.userID, new PlayerWarnings()); 
            }
        }
        
        private string GetMessage(string name, string sid = null) {
			return lang.GetMessage(name, this, sid);
		}
        
        void OnPlayerInit(BasePlayer player)
        {
            SetVars(player);
        }
        
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            pWarn.Remove(player.userID);
            PrintWarning(String.Format(lang.GetMessage("ACF_REMOVED", this), player.displayName));
        }
        
        void SetVars(BasePlayer player) // Now lets add some data to the dictionary
        {
            if (!pWarn.ContainsKey(player.userID)) 
                pWarn.Add(player.userID, new PlayerWarnings()); 
            pWarn[player.userID].Name = player.displayName;
            pWarn[player.userID].CurrentWarnings = 0;
            
            PrintWarning(String.Format(lang.GetMessage("ACF_ADDED", this), player.displayName));
        }
        
        void KickPlayer(BasePlayer player)
        {  
            BasePlayer target = player;
            Network.Net.sv.Kick(target.net.connection, String.Format(lang.GetMessage("ACF_REASON", this)));      
        }
        
        private object FindPlayer(string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (steamid != 0L)
                    if (p.userID == steamid)
                    {
                        foundPlayers.Clear();
                        foundPlayers.Add(p);
                        return foundPlayers;
                    }
                string lowername = p.displayName.ToLower();
                if (lowername.Contains(lowerarg))
                {
                    foundPlayers.Add(p);
                }
            }
            if (foundPlayers.Count == 0) return lang.GetMessage("noPlayers", this);
            if (foundPlayers.Count > 1) return lang.GetMessage("multiPlayers", this);

            return foundPlayers[0];
        }
        
        void WipeAllStats()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
            {
                pWarn[player.userID].CurrentWarnings = 0;
                SetVars(player);
                PrintWarning(String.Format(lang.GetMessage("ACF_WIPEDALL", this)));
                SendReply(player, String.Format(lang.GetMessage("ACF_WIPEDALL", this)));
            }  
        }
        /////////////////
        //Chat Handlers//
        /////////////////
       
        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            
			BasePlayer player = (BasePlayer)arg.connection.player;	
    		BasePlayer target = (BasePlayer)arg.connection.player;          
            if(player.net.connection.authLevel >= AuthToBypass && AdminBypass == true)
            {
                return null;
            }
            if(BetterChat != null)
            {
                return BetterChat;    
            }            
            if(playerWait.Contains(player.userID))
            {
                SendReply(player, String.Format(lang.GetMessage("ACF_WAIT", this), WaitTillMsg));
                if (WarningEnabled = true)
                {
                    if (pWarn.ContainsKey(player.userID))  
                    {
                        if (pWarn[player.userID].CurrentWarnings <= MaxWarnings)
                        {
                            pWarn[player.userID].CurrentWarnings++;
                            SendReply(player, String.Format(lang.GetMessage("ACF_WARNING", this), pWarn[player.userID].CurrentWarnings));
                        }
                        else
                        {
                            pWarn[player.userID].CurrentWarnings = 0;
                            PrintWarning(String.Format(lang.GetMessage("ACF_KICKING", this), player.displayName, MaxWarnings));  
                            timer.Once(2, () =>
                            {
                                KickPlayer(player);
                            });
                        }
                    }
                    else
                    {
                        SetVars(player);
                        timer.Once(2, () =>
                        {
                            if (pWarn[player.userID].CurrentWarnings <= MaxWarnings)
                            {
                                pWarn[player.userID].CurrentWarnings++;
                                SendReply(player, String.Format(lang.GetMessage("ACF_WARNING", this), pWarn[player.userID].CurrentWarnings));
                            }      
                            else
                            {
                                KickPlayer(player);
                            }
                        });
                    }
                }
            }
            else
            {
                playerWait.Add(player.userID);  
                timer.Once(WaitTillMsg, () => playerWait.Remove(player.userID));
                return null;
            }
            return true;
        }
        
        
        /////////////////
        //Chat Commands//
        /////////////////
        
        [ChatCommand("chelp")]
        void help(BasePlayer player)
        {
            if (player.net.connection.authLevel > 1)
            {
                SendReply(player, String.Format(lang.GetMessage("ACF_ADMINHELP", this)));
            }
            else
            {
                SendReply(player, String.Format(lang.GetMessage("ACF_HELP", this)));
            }
        }
        
        [ChatCommand("cwipeall")]
        void AWipeAll(BasePlayer player)
        {
            if (player.net.connection.authLevel > 1)
            {
                WipeAllStats();
            }                      
        }
        
        [ChatCommand("cwipe")]
        void playerwipe(BasePlayer player, string command, string[] args)     
        {
            if (args.Length == 1)
            {
                if(player.net.connection.authLevel > 1)
                {
                    object addPlayer = FindPlayer(args[0]);             
                    BasePlayer target = (BasePlayer)addPlayer;         
                    pWarn[target.userID].CurrentWarnings = 0;
                
                    PrintWarning(String.Format(lang.GetMessage("ACF_WIPEDAT", this), player.displayName, target));
                    SendReply(player, String.Format(lang.GetMessage("ACF_WIPEDP", this), target.displayName));
                    SendReply(target, String.Format(lang.GetMessage("ACF_WIPEDY", this), player.displayName));
                
                    SetVars(target);
                }
            }
            else
            {
                if (player.net.connection.authLevel > 1)
                {
                    SendReply(player, String.Format(lang.GetMessage("ACF_ADMINHELP", this)));
                }
                else
                {
                    SendReply(player, String.Format(lang.GetMessage("ACF_HELP", this)));
                }
            }
        }    
        
        [ChatCommand("cwarning")]  
        void CheckWarnings(BasePlayer player)
        {
            if (pWarn.ContainsKey(player.userID)) 
            {
                var TillKick = MaxWarnings + 1 - pWarn[player.userID].CurrentWarnings;
                SendReply(player, String.Format(lang.GetMessage("ACF_WARNINGS", this), pWarn[player.userID].CurrentWarnings, TillKick ));
            }
            else
            {
                SetVars(player);
            }
        }
    }
}

// --- End of file: AntiChatFlood.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VehicleManager.cs ---
// --- Original Local Path: VehicleManager.cs ---

using Oxide.Core;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using Network;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
	[Info("Vehicle Manager", "WOLF-TOR", "1.0.0")]
	class VehicleManager : RustPlugin
	{
		#region Variables
		private static Configuration _config;
		public static VehicleManager _instance;
		#endregion

		#region Configuration
		public class Configuration
		{
			[JsonProperty("Разрешить подъем транспорта киянкой")]
			public bool allowPickupVehicle;

			[JsonProperty("shortname объекта который держит игрок при установке транспорта")]
			public string vehicleShortPrefabName;

			[JsonProperty("Список транспорта")]
			public List<VehicleInfo> vehicles;
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				this.SaveConfig();
			}
			catch
			{
				PrintError("Error reading config, please check!");
			}
		}

		protected override void LoadDefaultConfig()
		{
			_config = new Configuration();

			_config.allowPickupVehicle = true;
			_config.vehicleShortPrefabName = "box.wooden.large";
			_config.vehicles = new List<VehicleInfo>()
			{
				new VehicleInfo("boat", "assets/content/vehicles/boats/rowboat/rowboat.prefab", 2189173904, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("rhib", "assets/content/vehicles/boats/rhib/rhib.prefab", 2189175322, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("minicopter", "assets/content/vehicles/minicopter/minicopter.entity.prefab", 2189176096, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("balloon", "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab", 2189176712, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("sedan", "assets/content/vehicles/sedan_a/sedantest.entity.prefab", 2189177307, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("horse", "assets/rust.ai/nextai/testridablehorse.prefab", 2189177940, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("ch47", "assets/prefabs/npc/ch47/ch47.entity.prefab", 2189180720, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("scraptransportheli", "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab", 2189181296, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("2module_car", "assets/content/vehicles/modularcar/2module_car_spawned.entity.prefab", 2162472804, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("3module_car", "assets/content/vehicles/modularcar/3module_car_spawned.entity.prefab", 2162478030, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab"),
				new VehicleInfo("4module_car", "assets/content/vehicles/modularcar/4module_car_spawned.entity.prefab", 2162478376, "assets/bundled/prefabs/fx/build/promote_TopTier.prefab")
			};
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(_config);
		}
		#endregion

		#region VehicleInfo Class
		public class VehicleInfo
		{
			[JsonProperty("Короткое имя транспорта")]
			public string shortname;

			[JsonProperty("prefab транспорта")]
			public string prefab;

			[JsonProperty("skinID транспорта")]
			public ulong skinID;

			[JsonProperty("Effect который проигрывается при установке транспорта")]
			public string placementEffect;

			public VehicleInfo(string shortname, string prefab, ulong skinID, string placementEffect = null)
			{
				this.shortname			= shortname;
				this.prefab				= prefab;
				this.skinID				= skinID;
				this.placementEffect	= placementEffect;
			}

			public string Give(BasePlayer player, string shortname, string text = null)
			{
				Item item = ItemManager.CreateByName(shortname, 1, this.skinID);
				if (item != null)
				{
					item.name = _instance._(player, this.shortname);

					if (!string.IsNullOrEmpty(text))
						item.text = text;

					player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
					return item.name;
				}

				return null;
			}

			public BaseEntity Spawn(Vector3 position, Quaternion rotation, BasePlayer player, Item ownerItem)
			{
				BaseEntity entity = GameManager.server.CreateEntity(this.prefab, position, rotation) as BaseEntity;

				if (entity != null)
				{
					entity.transform.Rotate(0, 90, 0);

					Interface.Oxide.CallHook("OnSpawnVehicle", player, entity, ownerItem);

					entity.Spawn();

					return entity;
				}

				return null;
			}

			public static VehicleInfo FindByShortname(string shortname)
			{
				if (shortname == null)
					return null;

				List<VehicleInfo> _vehicle = _config.vehicles.Where(v => v.shortname.Contains(shortname)).ToList();
				if (_vehicle != null && _vehicle.Count > 0)
					return _vehicle.First();

				return null;
			}

			public static VehicleInfo FindByPrefab(string prefab)
			{
				if (prefab == null)
					return null;

				List<VehicleInfo> _vehicle = _config.vehicles.Where(v => v.prefab == prefab).ToList();
				if (_vehicle != null && _vehicle.Count > 0)
					return _vehicle.First();

				return null;
			}

			public static VehicleInfo FindBySkinID(ulong skinID)
			{
				if (skinID == 0 || skinID == null)
					return null;

				List<VehicleInfo> _vehicle = _config.vehicles.Where(v => v.skinID == skinID).ToList();
				if (_vehicle != null && _vehicle.Count > 0)
					return _vehicle.First();

				return null;
			}

			public static List<string> ShortNameList() // Я хлебушек, мне так можно
			{
				List<string> _vehicles = new List<string>();
				foreach (VehicleInfo _vehicle in _config.vehicles)
					_vehicles.Add(_vehicle.shortname);

				return _vehicles;
			}
		}
		#endregion

		#region Language
		private void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["rhib"] = "RHIB",
				["minicopter"] = "MiniCopter",
				["boat"] = "Boat",
				["balloon"] = "Air balloon",
				["sedan"] = "Car",
				["horse"] = "Horse",
				["scraptransportheli"] = "Transport Helicopter",
				["ch47"] = "Chinook",
				["2module_car"] = "Small chassis",
				["3module_car"] = "Medium chassis",
				["4module_car"] = "Large chassis",

				["ConsoleSyntax"] = "Syntax: vehicle.give <steamid|username> <{0}> [shortname] [comment]",
				["PlayerNotFound"] = "Player '{0}' not found!",
				["VehicleNotFound"] = "Vehicle '{0}' not found!",
				["ShortnameNotFound"] = "Item shortname '{0}' not found!",
				["SuccessfullyGive"] = "Transport '{0}' successfully give to '{1}'",
			}, this);

			lang.RegisterMessages(new Dictionary<string, string>
			{
				["rhib"] = "Военный катер",
				["minicopter"] = "MiniCopter",
				["boat"] = "Лодка",
				["balloon"] = "Воздушный шар",
				["sedan"] = "Автомобиль",
				["horse"] = "Лошадь",
				["scraptransportheli"] = "Транспортный вертолет",
				["ch47"] = "Чинук",
				["2module_car"] = "Маленькое шасси",
				["3module_car"] = "Среднее шасси",
				["4module_car"] = "Большое шасси",

				["ConsoleSyntax"] = "Синтаксис: vehicle.give <steamid|username> <{0}> [shortname] [comment]",
				["PlayerNotFound"] = "Игрок с никнеймом '{0}' не найден!",
				["VehicleNotFound"] = "Транспорт с названием '{0}' не найден!",
				["ShortnameNotFound"] = "Item с shortname '{0}' не найден!",
				["SuccessfullyGive"] = "Транспорт '{0}' успешно выдан игроку '{1}'",
			}, this, "ru");
		}

		private string _(BasePlayer player, string key, params object[] args)
		{
			return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
		}
		#endregion

		#region Init
		private void OnServerInitialized()
		{
			_instance = this;

			foreach (BasePlayer player in BasePlayer.activePlayerList)
				foreach (Item item in player.inventory.AllItems())
					this.ChangeVehicleName(item, player);
		}

		private void Unload()
		{
			_instance = null;
			_config   = null;
		}
		#endregion

		#region OxideHooks
		private void OnPlayerConnected(BasePlayer player) 
		{
			player.inventory.AllItems().ToList().ForEach(it => this.ChangeVehicleName(it, player));
		}

		private void OnItemAddedToContainer(ItemContainer container, Item item) 
		{
			if (container == null || item == null || container.playerOwner == null)
				return;

			this.ChangeVehicleName(item, container.playerOwner);
		}

		private object OnNpcGiveSoldItem(NPCVendingMachine vending, Item soldItem, BasePlayer buyer) 
		{
			if (soldItem.skin > 0)
			{
				VehicleInfo vehicle = VehicleInfo.FindBySkinID(soldItem.skin);
				if (vehicle != null)
				{
					vehicle.Give(buyer, _config.vehicleShortPrefabName, "npcvending");
					return true;
				}
			}

			return null;
		}

		private object CanBuild(Planner plan, Construction construction, Construction.Target target) 
		{
			if (construction.fullName.Contains(_config.vehicleShortPrefabName))
			{
				Item ownerItem = plan.GetItem();
				if (ownerItem != null && ownerItem.info.shortname == _config.vehicleShortPrefabName)
				{
					VehicleInfo vehicle = VehicleInfo.FindBySkinID(ownerItem.skin);
					if (vehicle == null)
						return null;

					if (Interface.Oxide.CallHook("CanSpawnVehicle", target.player, ownerItem, plan, construction, target) != null)
						return true;

					BaseEntity baseEntity = construction.CreateConstruction(target, true);
					BaseEntity entity = vehicle.Spawn(baseEntity.transform.position, baseEntity.transform.rotation, target.player, ownerItem);
					entity.skinID = ownerItem.skin;

					NextTick(() =>
					{
						Interface.Oxide.CallHook("OnDoSpawnVehicle", target.player, entity, ownerItem);

						plan.PayForPlacement(target.player, construction);

						baseEntity.Kill();
					});

					if (!string.IsNullOrEmpty(vehicle.placementEffect))
						Effect.server.Run(vehicle.placementEffect, entity, 0u, Vector3.zero, Vector3.zero, null, false);

					return true;
				}
			}

			return null;
		}

		private object OnHammerHit(BasePlayer player, HitInfo info) 
		{
			if (!_config.allowPickupVehicle || player == null || info == null || info?.HitEntity == null) 
				return null;

			if (info.HitEntity is BaseVehicle && player.serverInput.IsDown(BUTTON.FIRE_SECONDARY))
			{
				VehicleInfo vehicle = VehicleInfo.FindBySkinID(info.HitEntity.skinID);
				if (vehicle == null)
				{
					vehicle = VehicleInfo.FindByPrefab(info.HitEntity.PrefabName);
					if (vehicle == null)
						return null;
				}

				if (Interface.Oxide.CallHook("CanPickupVehicle", player, info.HitEntity) != null)
					return true;

				string text = (string)Interface.Oxide.CallHook("OnPickupVehicle", player, info.HitEntity);
				vehicle.Give(player, _config.vehicleShortPrefabName, (string.IsNullOrEmpty(text) ? "pickup" : text));

				NextTick(() =>
				{
					info.HitEntity.Kill();
				});

				return false;
			}

			return null;
		}

		private object OnItemCustomName(int itemID, ulong skinID, string language = "ru") 
		{
			if (itemID == -932201673 && skinID == 0 && language == "ru")
			{
				return "Металлолом";
			}

			VehicleInfo vehicle = VehicleInfo.FindBySkinID(skinID);
			if (vehicle == null)
				return null;

			Dictionary<string, string>  messages = lang.GetMessages(language, this);
			if (!messages.ContainsKey(vehicle.shortname))
				return null;

			return messages[vehicle.shortname];
		}

		private void OnPlayerSetInfo(Connection connection, string key, string val)
		{
			if (key == "global.language")
			{
				NextTick(() =>
				{
					BasePlayer player = Player.FindById(connection.userid);
					if (player != null)
					{
						this.OnPlayerConnected(player);
					}
				});
			}
		}
		#endregion

		#region Console Hooks
		[ConsoleCommand("vehicle.give")]
		void ConsoleCommand_vehicleshop_give(ConsoleSystem.Arg arg)
		{
			BasePlayer p = arg?.Player() ?? null; 
			if (p != null && !p.IsAdmin) 
				return;

			if (!arg.HasArgs(2))
			{
				SendReply(arg, _(p, "ConsoleSyntax", string.Join("|",  VehicleInfo.ShortNameList())));
				return;
			}

			BasePlayer player = BasePlayer.Find(arg.GetString(0));
			if (player == null)
			{
				SendReply(arg, _(p, "PlayerNotFound", arg.GetString(0)));
				return;
			}

			VehicleInfo vehicle = VehicleInfo.FindByShortname(arg.GetString(1));
			if (vehicle == null)
			{
				SendReply(arg, _(p, "VehicleNotFound", arg.GetString(1)));
				SendReply(arg, _(p, "ConsoleSyntax", string.Join("|",  VehicleInfo.ShortNameList())));
				return;
			}

			string shortname = _config.vehicleShortPrefabName;
			if (arg.HasArgs(3) && arg.GetString(2) != "default")
			{
				ItemDefinition info = ItemManager.FindItemDefinition(arg.GetString(2));
				if (info == null) 
				{
					SendReply(arg, _(p, "ShortnameNotFound", arg.GetString(2)));
					return;
				}

				shortname = info.shortname;
			}

			SendReply(arg, _(p, "SuccessfullyGive", vehicle.Give(player, shortname, arg.GetString(3, "console")), player.displayName));
		}
		#endregion

		#region Helpers
		private void ChangeVehicleName(Item item, BasePlayer player) 
		{
			if (item == null || player == null || item?.info == null || item.info.shortname != _config.vehicleShortPrefabName || item.skin == 0)
				return;

			VehicleInfo vehicle = VehicleInfo.FindBySkinID(item.skin);
			if (vehicle == null)
				return;

			item.name = _(player, vehicle.shortname);
			player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
		}
		#endregion
	}
}

// --- End of file: VehicleManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ConsoleMessage.cs ---
// --- Original Local Path: ConsoleMessage.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins {
    [Info("ConsoleMessages", "Skrallex", "1.0.0")]
    [Description("Send messages to players with a console command")]
    class ConsoleMessage : RustPlugin {

        void Loaded() {
            LoadDefaultMessages();
        }

        void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                {"NoPermission", "You do not have permission to use this command."},
                {"SaySyntax", "Syntax: cm.say PlayerName Message"},
                {"ManyPlayersFound", "Multiple players found with that name, please be more specific."},
                {"NoPlayersFound", "No players found with that name, please try another."}
            }, this);
        }

        [ConsoleCommand("cm.say")]
        void CMSay(ConsoleSystem.Arg args) {
            if(args.Player() != null && !args.Player().IsAdmin()) {
                args.ReplyWith(Lang("NoPermission"));
                return;
            }
            if(!args.HasArgs(2)) {
                args.ReplyWith(Lang("SaySyntax"));
                return;
            }

            if(GetPlayersByName(args.GetString(0)).Count > 1) {
                args.ReplyWith(Lang("ManyPlayersFound"));
                return;
            }
            if(GetPlayersByName(args.GetString(0)).Count == 0) {
                args.ReplyWith(Lang("NoPlayersFound"));
                return;
            }
            BasePlayer target = GetPlayersByName(args.GetString(0))[0];

            SendReply(target, args.GetString(1));
        }

        List<BasePlayer> GetPlayersByName(string playerName) {
            List<BasePlayer> foundPlayers = new List<BasePlayer>();
            foreach(BasePlayer activePlayer in BasePlayer.activePlayerList) {
                if(activePlayer.displayName.ToLower().Contains(playerName.ToLower()))
                    foundPlayers.Add(activePlayer);
            }
            return foundPlayers;
        }

        string Lang(string key) {
            return lang.GetMessage(key, this, null);
        }
    }
}


// --- End of file: ConsoleMessage.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerRankings.cs ---
// --- Original Local Path: PlayerRankings.cs ---

// Requires: ConnectionDB
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("PlayerRankings", "Ankawi", "2.0.2")]
    [Description("Gives players ranks based on playtime on a server")]
    class PlayerRankings : RustPlugin
    {
        [PluginReference]
        Plugin ConnectionDB;

        [PluginReference]
        Plugin BetterChat;

        #region Plugin Related

        void Loaded()
        {
            if (!ConnectionDB)
                PrintWarning("You need to have ConnectionDB installed for this plugin to work. Get it here: http://oxidemod.org/plugins/1459/");

            if (!BetterChat)
                PrintWarning("Its recommended to have BetterChat installed, to grant titles for playtime. Get it here: http://oxidemod.org/plugins/979/");

            LoadConfig();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                UpdateGroups(player);

            timer.Repeat(15, 0, () =>
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    UpdateGroups(player);
            });

            foreach (var rank in Config)
            {
                if (rank.Key == "Settings")
                    continue;

                if (Config[rank.Key, "Oxide Group"] == null)
                {
                    PrintWarning(rank.Key + " does not have an Oxide Group specified");
                    continue;
                }

                if (!GroupExists(Config[rank.Key, "Oxide Group"].ToString()))
                    CreateGroup(Config[rank.Key, "Oxide Group"].ToString());
            }
        }

        #endregion

        #region Helpers

        bool IsUserInGroup(BasePlayer player, string group)
        {
            return permission.GetUserGroups(player?.UserIDString).Contains(group.ToLower());
        }

        void AddUserToGroup(BasePlayer player, string group) => permission.AddUserGroup(player.UserIDString, group);

        void RemoveUserFromGroup(BasePlayer player, string group) => permission.RemoveUserGroup(player.UserIDString, group);

        void CreateGroup(string group) => permission.CreateGroup(group, string.Empty, 0);

        bool GroupExists(string group) => permission.GroupExists(group);

        #endregion

        #region Configuration

        new void LoadConfig()
        {
            SetConfig("Regular", "Oxide Group", "Regular");
            SetConfig("Regular", "Playtime", 10D);

            SetConfig("Pro", "Oxide Group", "Pro");
            SetConfig("Pro", "Playtime", 25D);

            SetConfig("Settings", "Ignore Admins", false);

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file...");
        }

        ////////////////////////////////////////
        ///  Config Setup - by LaserHydra
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        #endregion

        #region Commands

        [ChatCommand("ranks")]
        private void RanksCommand(BasePlayer player, string command, string[] args)
        {
            foreach (var rank in Config)
            {
                if (rank.Key == "Settings")
                    continue;

                PrintToChat(player, $"<color=red>Rank</color>: {rank.Key}" + "\n<color=lime>Playtime Required:</color> " + Convert.ToString(Config[rank.Key, "Playtime"]) + " hours");
            }

            PrintToChat(player, $"<color=red>Your Playtime</color>: " + Math.Round(GetPlayTime(player), 2) + " hours");
        }

        #endregion

        #region Subject Related

        void UpdateGroups(BasePlayer player)
        {
            if (player.net.connection.authLevel != 0 && (bool)Config["Settings", "Ignore Admins"]) return;
            if (!ConnectionDB) return;

            double playTime = GetPlayTime(player);

            Dictionary<string, object> newRank = new Dictionary<string, object>{
                {"Oxide Group", ""},
                {"Playtime", 0.0},
                {"Name", "none"}
            };

            foreach (KeyValuePair<string, object> rank in Config)
            {
                if (rank.Key == "Settings")
                    continue;

                double time = Convert.ToDouble(Config[rank.Key, "Playtime"]);

                if (playTime >= time && time > Convert.ToDouble(newRank["Playtime"]))
                {
                    newRank = rank.Value as Dictionary<string, object>;
                    newRank["Name"] = rank.Key;
                }
            }

            if (!IsUserInGroup(player, (string)newRank["Oxide Group"]) && GroupExists((string)newRank["Oxide Group"]))
            {
                SendReply(player, $"<color=red>PlayerRankings</color>: You have been ranked up to {newRank["Name"] as string}");
                Puts($"{player.displayName} has been ranked up to {newRank["Name"] as string}");

                AddUserToGroup(player, (string)newRank["Oxide Group"]);

                RevokeLower(player, Convert.ToDouble(newRank["Playtime"]));
            }
        }

        void RevokeLower(BasePlayer player, double time)
        {
            foreach (var rank in Config)
            {
                if (rank.Key == "Settings")
                    continue;
                if (time > Convert.ToDouble(Config[rank.Key, "Playtime"]) && IsUserInGroup(player, (string)Config[rank.Key, "Oxide Group"]))
                    RemoveUserFromGroup(player, (string)Config[rank.Key, "Oxide Group"]);
            }
        }

        double GetPlayTime(BasePlayer player) => Convert.ToDouble(ConnectionDB.Call("SecondsPlayed", player)) / 60 / 60;

        #endregion
    }
}

// --- End of file: PlayerRankings.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoBarrels.cs ---
// --- Original Local Path: NoBarrels.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using Random = UnityEngine.Random;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
  [Info("NoBarrels", "Kyrah Abattoir", "0.1", ResourceId = 1872)]
  [Description("This plugin removes all non-oil barrels on the server.")]
  class NoBarrels : RustPlugin
  {
    private bool server_ready = false;
    private List<string> barrels = new List<string>() { "loot-barrel-1.prefab", "loot-barrel-2.prefab" };

    private bool ProcessBarrel(BaseNetworkable entity)
    {
        if (entity.isActiveAndEnabled && barrels.Contains(entity.LookupShortPrefabName()))
        {
            entity.Kill();
            return true;
        }
        return false;
    }

    void OnServerInitialized()
    {
        LootContainer[] loot = Resources.FindObjectsOfTypeAll<LootContainer>();
        int count = 0;
        foreach (var entity in loot)
        {
            if (ProcessBarrel(entity))
                count++;
        }
        Puts($"Deleted {count} barrels on server start.");
        server_ready = true;
    }

    void OnEntitySpawned(BaseNetworkable entity)
    {
        if (!server_ready)
            return;
        if(ProcessBarrel(entity))
            Puts($"Deleted {entity.LookupShortPrefabName()}");
    }
  }
}


// --- End of file: NoBarrels.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuriedTreasure.cs ---
// --- Original Local Path: BuriedTreasure.cs ---

using System;
using Rust;
using Oxide.Core;
using Newtonsoft.Json;
using Oxide.Core.Configuration;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("BuriedTreasure", "Colon Blow", "1.0.11")]
	[Description("Treasure on your server")]
    class BuriedTreasure : RustPlugin
    {

        // Added Randomizer to Custom Loot tables.
        // Changed from Item id to shortname in config.

        #region Load

        [PluginReference] Plugin ServerRewards;
        [PluginReference] Plugin Economics;

        void Loaded()
        {
            permission.RegisterPermission("buriedtreasure.admin", this);
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public GlobalSettings globalSettings { get; set; }

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Gold - Enable gold to be sold for Server Reward Points ? ")] public bool UseServerRewards { get; set; }
                [JsonProperty(PropertyName = "Gold - Enable gold to be sold for Economics Bucks ? ")] public bool UseEconomics { get; set; }
                [JsonProperty(PropertyName = "Gold - Player will get this many Server Reward Points when selling 1 gold : ")] public int ServerRewardsGoldExhcange { get; set; }
                [JsonProperty(PropertyName = "Gold - Player will get this many Economics Bucks when selling 1 gold : ")] public int EconomicsGoldExchange { get; set; }

                [JsonProperty(PropertyName = "AutoLoot - Automatically turn in gold coins for rewards when looting ? ")] public bool EnableAutoGoldRewardOnLoot { get; set; }
                [JsonProperty(PropertyName = "AutoLoot - Automatically mark treasure maps when they are looted ? ")] public bool EnableAutoReadMapOnLoot { get; set; }

                [JsonProperty(PropertyName = "Standard Loot - Enable chance for random treasure map in standard loot crates ? ")] public bool EnableMapsInStandardLoot { get; set; }
                [JsonProperty(PropertyName = "Standard Loot - Enable chance for gold to spawn in standard loot crates ? ")] public bool EnableGoldInStandardLoot { get; set; }
                [JsonProperty(PropertyName = "Standard Loot - Random Treasure Map chance (if enabled) : ")] public int StandardLootAddMapChance { get; set; }
                [JsonProperty(PropertyName = "Standard Loot - Gold spawn chance (if enabled) : ")] public int StandardLootAddGoldChance { get; set; }

                [JsonProperty(PropertyName = "Treasure - Spawn - Only spawn Treasure up to this far from players current postion : ")] public float LocalTreasureMaxDistance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Spawn - Use whole map (instead of distance from player) to get random spawn point ? ")] public bool UseWholeMapSpawn { get; set; }
                [JsonProperty(PropertyName = "Treasure - Spawn - When whole map size is used, reduce spawn area by this much offset (closer to land) : ")] public float WholeMapOffset { get; set; }
                [JsonProperty(PropertyName = "Treasure - Despawn - Approx Seconds the Treasure Marker and Location will despawn if not found : ")] public float DespawnTime { get; set; }
                [JsonProperty(PropertyName = "Treasure - Despawn - Approx Seconds the Spawned Chest will despawn if not looted : ")] public float TreasureDespawnTime { get; set; }
                [JsonProperty(PropertyName = "Treasure - Location - When player gets within this distance, treasure will spawn nearby : ")] public float LootDetectionRadius { get; set; }

                [JsonProperty(PropertyName = "Treasure - Chance - to add a Random Map to Treasure Chest : ")] public int AddMapChance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Chance - to add a Gold to Treasure Chest : ")] public int AddGoldChance { get; set; }

                [JsonProperty(PropertyName = "Treasure - Chance - When a random map is added to chest or spawned, chance it will be a Basic Map: ")] public int BasicMapChance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Chance - When a random map is added to chest or spawned, chance it will be a UnCommon Map: ")] public int UnCommonMapChance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Chance - When a random map is added to chest or spawned, chance it will be a Rare Map: ")] public int RareMapChance { get; set; }
                [JsonProperty(PropertyName = "Treasure - Chance - When a random map is added to chest or spawned, chance it will be a Elite Map: ")] public int EliteMapChance { get; set; }

                [JsonProperty(PropertyName = "Map Marker - Prefab - Treasure Chest Map marker prefab (default explosion marker) : ")] public string MapMarkerPrefab { get; set; }
                [JsonProperty(PropertyName = "Treasure - Prefab - Basic Treasure Chest prefab : ")] public string BasicTreasurePrefab { get; set; }
                [JsonProperty(PropertyName = "Treasure - Prefab - UnCommon Treasure Chest prefab : ")] public string UnCommonTreasurePrefab { get; set; }
                [JsonProperty(PropertyName = "Treasure - Prefab - Rare Treasure Chest prefab : ")] public string RareTreasurePrefab { get; set; }
                [JsonProperty(PropertyName = "Treasure - Prefab - Elite Treasure Chest prefab : ")] public string EliteTreasurePrefab { get; set; }

                [JsonProperty(PropertyName = "Text - Basic Map name when inspecting map in inventory")] public string BasicMapTitle { get; set; }
                [JsonProperty(PropertyName = "Text - Uncommon Map name when inspecting map in inventory")] public string UncommonMapTitle { get; set; }
                [JsonProperty(PropertyName = "Text - Rare Map name when inspecting map in inventory")] public string RareMapTitle { get; set; }
                [JsonProperty(PropertyName = "Text - Elite Map name when inspecting map in inventory")] public string EliteMapTitle { get; set; }
                [JsonProperty(PropertyName = "Text - Notes to player when inspecting map in inventory")] public string MapInfomation { get; set; }

                [JsonProperty(PropertyName = "Loot Table - Only Use Loot Table Items ? ")] public bool UseOnlyLootTable { get; set; }
                [JsonProperty(PropertyName = "Loot Table - Basic Treasure Chest (shortname, max qty) ")] public Dictionary<string, int> BasicLootTable { get; set; }
                [JsonProperty(PropertyName = "Loot Table - UnCommon Treasure Chest (shortname, max qty) ")] public Dictionary<string, int> UnCommonLootTable { get; set; }
                [JsonProperty(PropertyName = "Loot Table - Rare Treasure Chest (shortname, max qty) ")] public Dictionary<string, int> RareLootTable { get; set; }
                [JsonProperty(PropertyName = "Loot Table - Elite Treasure Chest (shortname, max qty) ")] public Dictionary<string, int> EliteLootTable { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                globalSettings = new PluginConfig.GlobalSettings
                {
                    UseServerRewards = true,
                    UseEconomics = true,
                    ServerRewardsGoldExhcange = 100,
                    EconomicsGoldExchange = 100,
                    EnableMapsInStandardLoot = false,
                    EnableGoldInStandardLoot = false,
                    EnableAutoGoldRewardOnLoot = false,
                    EnableAutoReadMapOnLoot = false,
                    StandardLootAddMapChance = 1,
                    StandardLootAddGoldChance = 1,
                    LocalTreasureMaxDistance = 100,
                    UseWholeMapSpawn = false,
                    WholeMapOffset = 500f,
                    DespawnTime = 3600f,
                    TreasureDespawnTime = 3600f,
                    LootDetectionRadius = 8f,
                    AddMapChance = 5,
                    AddGoldChance = 5,
                    BasicMapChance = 50,
                    UnCommonMapChance = 30,
                    RareMapChance = 15,
                    EliteMapChance = 5,
                    MapMarkerPrefab = "assets/prefabs/tools/map/cratemarker.prefab",
                    BasicTreasurePrefab = "assets/bundled/prefabs/radtown/crate_basic.prefab",
                    UnCommonTreasurePrefab = "assets/bundled/prefabs/radtown/crate_normal.prefab",
                    RareTreasurePrefab = "assets/bundled/prefabs/radtown/crate_normal_2.prefab",
                    EliteTreasurePrefab = "assets/bundled/prefabs/radtown/crate_elite.prefab",

                    BasicMapTitle = "Basic Map",
                    UncommonMapTitle = "Uncommon Map",
                    RareMapTitle = "Rare Map",
                    EliteMapTitle = "Elite Map",

                    MapInfomation = "Place map in Quick Slot, then right click on it to mark location.",

                    UseOnlyLootTable = false,
                    BasicLootTable = new Dictionary<string, int>() { { "tool.binoculars", 3 }, { "seed.hemp", 25 } },
                    UnCommonLootTable = new Dictionary<string, int>() { { "tool.binoculars", 3 }, { "seed.hemp", 25 } },
                    RareLootTable = new Dictionary<string, int>() { { "tool.binoculars", 3 }, { "seed.hemp", 25 }, { "hoodie", 1 } },
                    EliteLootTable = new Dictionary<string, int>() { { "tool.binoculars", 3 }, { "seed.hemp", 25 }, { "hoodie", 1 } }
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Commands

        [ConsoleCommand("buymap")]
        void cmdConsoleBuyMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("buyuncommonmap")]
        void cmdConsoleBuyUnCommonMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveUnCommonTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveUnCommonTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("buyraremap")]
        void cmdConsoleBuyRareMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveRareTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveRareTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("givegold")]
        void cmdConsoleGiveGold(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveGold(player);
                return;
            }
        }

        [ConsoleCommand("buyelitemap")]
        void cmdConsoleBuyEliteMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveEliteTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveEliteTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ConsoleCommand("buyrandommap")]
        void cmdConsoleBuyRandomMap(ConsoleSystem.Arg arg)
        {
            var player = arg.Player() ?? null;
            if (player != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, "buriedtreasure.admin")) return;
                GiveRandomTreasureMap(player);
                return;
            }
            if (arg.Args.Length > 0)
            {
                ulong id = Convert.ToUInt64(arg.Args[0]);
                GiveRandomTreasureMap(BasePlayer.FindByID(id));
            }
        }

        [ChatCommand("markmap")]
        void cmdMarkMap(BasePlayer player, string command, string[] args)
        {
            if (!HoldingMap(player, player.GetActiveItem()))
            {
                SendReply(player, "You are not holding a Treasure Map !!");
            }
        }

        [ChatCommand("treasurehelp")]
        void cmdTreasureHelp(BasePlayer player, string command, string[] args)
        {
            string help1 = "/markmap - while holding a treasure map, will mark the location on ingame map.";
            string help2 = "/sellgold - while holding gold, will sell gold for RP or Economics Bucks.";
            string help3 = "Note: You do have to be holding map or gold to use the commands.";

            SendReply(player, " Treasure Map Commands : \n " + help1 + " \n " + help2 + " \n " + help3);
        }

        [ChatCommand("sellgold")]
        void cmdSellGold(BasePlayer player, string command, string[] args)
        {
            SellGold(player);
        }

        #endregion

        #region Hooks

        object CanStackItem(Item item, Item targetItem)
        {
            if (item == null || targetItem == null) return null;
            if (item.skin == 1376561963) return false;
            if (item.skin == 1389950043) return false;
            if (item.skin == 1390209788) return false;
            if (item.skin == 1390210901) return false;
            if (item.skin == 1390211736) return false;
            return null;
        }

        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player == null || input == null) return;
            if (input.IsDown(BUTTON.FIRE_SECONDARY))
            {
                if (!HoldingMap(player))
                    SellGold(player);
            }
        }

        void CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot)
        {
            if (item == null || playerLoot == null || targetContainer == null || targetSlot == null) return;

            var thplayer = playerLoot.GetComponentInParent<BasePlayer>() as BasePlayer;
            if (thplayer == null) return;
            if (config.globalSettings.EnableAutoGoldRewardOnLoot && item.skin == 1376561963) { SellGold(thplayer, item); return; }
            if (config.globalSettings.EnableAutoReadMapOnLoot && HoldingMap(thplayer, item)) return;

            if (targetSlot != -1) return;

            var container = playerLoot.FindContainer(targetContainer) ?? null;
            if (container == null || container != playerLoot.containerMain) return;

            if (HoldingMap(thplayer, item)) return;
            SellGold(thplayer, item);
        }

        bool HoldingMap(BasePlayer player, Item item = null)
        {
            Item activeItem;
            if (item != null) activeItem = item;
            else activeItem = player.GetActiveItem();

            if (activeItem != null)
            {
                if (activeItem.skin == 1389950043)
                {
                    activeItem.Remove(0f);
                    BuryTheTreasure(player, 1);
                    return true;
                }
                if (activeItem.skin == 1390209788)
                {
                    activeItem.Remove(0f);
                    BuryTheTreasure(player, 2);
                    return true;
                }
                if (activeItem.skin == 1390210901)
                {
                    activeItem.Remove(0f);
                    BuryTheTreasure(player, 3);
                    return true;
                }
                if (activeItem.skin == 1390211736)
                {
                    activeItem.Remove(0f);
                    BuryTheTreasure(player, 4);
                    return true;
                }
            }
            return false;
        }

        void GiveTreasureMap(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1389950043);
            item.name = config.globalSettings.BasicMapTitle;
            item.text = config.globalSettings.MapInfomation;
            player.inventory.GiveItem(item);
        }

        void GiveUnCommonTreasureMap(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1390209788);
            item.name = config.globalSettings.UncommonMapTitle;
            item.text = config.globalSettings.MapInfomation;
            player.inventory.GiveItem(item);
        }

        void GiveRareTreasureMap(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1390210901);
            item.name = config.globalSettings.RareMapTitle;
            item.text = config.globalSettings.MapInfomation;
            player.inventory.GiveItem(item);
        }

        void GiveEliteTreasureMap(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1390211736);
            item.name = config.globalSettings.EliteMapTitle;
            item.text = config.globalSettings.MapInfomation;
            player.inventory.GiveItem(item);
        }

        void GiveRandomTreasureMap(BasePlayer player)
        {
            ulong skinid = 1389950043;
            var randomroll = UnityEngine.Random.Range(0, (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance));
            if (randomroll >= 0 && randomroll <= config.globalSettings.BasicMapChance) skinid = 1389950043;
            if (randomroll >= (config.globalSettings.BasicMapChance + 1) && randomroll <= (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance)) skinid = 1390209788;
            if (randomroll >= (config.globalSettings.UnCommonMapChance + 1) && randomroll <= (config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance)) skinid = 1390210901;
            if (randomroll >= (config.globalSettings.RareMapChance + 1) && randomroll <= (config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance)) skinid = 1390211736;
            var item = ItemManager.CreateByItemID(1414245162, 1, skinid);
            player.inventory.GiveItem(item);
        }

        void GiveContainerRandomTreasureMap(LootContainer container)
        {
            ulong skinid = 1389950043;
            var randomroll = UnityEngine.Random.Range(0, (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance));
            if (randomroll >= 0 && randomroll <= config.globalSettings.BasicMapChance) skinid = 1389950043;
            if (randomroll >= (config.globalSettings.BasicMapChance + 1) && randomroll <= (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance)) skinid = 1390209788;
            if (randomroll >= (config.globalSettings.UnCommonMapChance + 1) && randomroll <= (config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance)) skinid = 1390210901;
            if (randomroll >= (config.globalSettings.RareMapChance + 1) && randomroll <= (config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance)) skinid = 1390211736;

            ItemContainer component1 = container.GetComponent<StorageContainer>().inventory;
            Item item = ItemManager.CreateByItemID(1414245162, 1, skinid);
            component1.itemList.Add(item);
            item.parent = component1;
            item.MarkDirty();
        }

        void GiveGold(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(1414245162, 1, 1376561963);
            player.inventory.GiveItem(item);
        }

        void GiveContainerGold(LootContainer container)
        {
            ItemContainer component1 = container.GetComponent<StorageContainer>().inventory;
            Item item = ItemManager.CreateByItemID(1414245162, 1, 1376561963);
            component1.itemList.Add(item);
            item.parent = component1;
            item.MarkDirty();
        }

        void SellGold(BasePlayer player, Item item = null)
        {
            Item activeItem = new Item();
            if (item != null) activeItem = item;
            else activeItem = player.GetActiveItem();

            if (activeItem != null)
            {
                if (activeItem.skin == 1376561963)
                {
                    if (config.globalSettings.UseServerRewards && ServerRewards != null)
                    {
                        ServerRewards?.Call("AddPoints", new object[] { player.userID, config.globalSettings.ServerRewardsGoldExhcange });
                        SendReply(player, "You Just sold your gold for " + config.globalSettings.ServerRewardsGoldExhcange.ToString() + " Rewards Points !!!");
                    }
                    if (config.globalSettings.UseEconomics && Economics != null)
                    {
                        Economics?.Call("Deposit", new object[] { player.userID, config.globalSettings.EconomicsGoldExchange });
                        SendReply(player, "You Just sold your gold for " + config.globalSettings.EconomicsGoldExchange.ToString() + " Economic Bucks !!!");
                    }
                    activeItem.Remove(0f);
                    return;
                }
            }
        }

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, UnityEngine.LayerMask.GetMask("World", "Construction", "Default")))
                return Mathf.Max(hit.point.y, y);

            return y;
        }

        Vector3 GetSpawnLocation(BasePlayer player)
        {
            Vector3 targetPos = new Vector3();
            RaycastHit hitInfo;
            Vector3 randomizer = new Vector3(UnityEngine.Random.Range(-config.globalSettings.LocalTreasureMaxDistance, config.globalSettings.LocalTreasureMaxDistance), 0f, UnityEngine.Random.Range(-config.globalSettings.LocalTreasureMaxDistance, config.globalSettings.LocalTreasureMaxDistance));
            Vector3 newp = (player.transform.position + randomizer);
            var groundy = GetGroundPosition(newp);
            targetPos = new Vector3(newp.x, groundy, newp.z);
            return targetPos;
        }

        Vector3 FindGlobalSpawnPoint()
        {
            Vector3 spawnpoint = new Vector3();
            float mapoffset = config.globalSettings.WholeMapOffset;
            float mapsize = ((ConVar.Server.worldsize) / 2) - mapoffset;
            Vector3 randomizer = new Vector3(UnityEngine.Random.Range(-mapsize, mapsize), 0f, UnityEngine.Random.Range(-mapsize, mapsize));
            Vector3 newp = randomizer;
            var groundy = GetGroundPosition(newp);
            spawnpoint = new Vector3(randomizer.x, groundy, randomizer.z);
            return spawnpoint;
        }

        void BuryTheTreasure(BasePlayer player, int maprarity = 1)
        {
            Vector3 position = GetSpawnLocation(player);
            if (config.globalSettings.UseWholeMapSpawn) position = FindGlobalSpawnPoint();
            GameObject newTreasure = new GameObject();
            newTreasure.transform.position = position;
            var stash = newTreasure.gameObject.AddComponent<BaseEntity>();
            stash.OwnerID = player.userID;
            var addmarker = stash.gameObject.AddComponent<TreasureMarker>();
            addmarker.rarity = maprarity;
            SendReply(player, "Treasure is now marked on ingame map at grid : " + GetGridLocation(position));
        }

        void OnLootSpawn(LootContainer container)
        {
            var getobj = container.GetComponentInParent<BaseEntity>() ?? null;
            if (getobj != null && getobj.skinID == 111) return;
            if (config.globalSettings.EnableMapsInStandardLoot)
            {
                int randomlootroll = UnityEngine.Random.Range(0, 100);
                if (randomlootroll <= config.globalSettings.StandardLootAddMapChance) GiveContainerRandomTreasureMap(container);
            }
            if (config.globalSettings.EnableGoldInStandardLoot)
            {
                int randomgoldlootroll = UnityEngine.Random.Range(0, 100);
                if (randomgoldlootroll <= config.globalSettings.StandardLootAddGoldChance) GiveContainerGold(container);
            }
        }

        string GetGridLocation(Vector3 position)
        {
            Vector2 offsetPos = new Vector2((World.Size / 2 - 6) + position.x, (World.Size / 2 - 56) - position.z);
            string gridstring = $"{Convert.ToChar(65 + (int)offsetPos.x / 146)}{(int)(offsetPos.y / 146)}";
            return gridstring;
        }

        void Unload()
        {
            DestroyAll<TreasureMarker>();
        }

        static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region TreasureMarker 

        object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            if (entity is MapMarker && entity.name == "Treasure Marker")
            {
                MapMarker getMarker = entity.GetComponent<MapMarker>();
                if (getMarker)
                {
                    if (target.userID == getMarker.OwnerID) return null;
                    else return false;
                }
            }
            return null;
        }

        class TreasureMarker : BaseEntity
        {
            BaseEntity lootbox;
            BaseEntity treasurechest;
            MapMarker mapmarker;
            SphereCollider sphereCollider;
            public ulong playerid;
            BuriedTreasure instance;
            public int rarity;
            string prefabtreasure;
            Dictionary<string, int> loottable;
            bool isvisible;
            bool didspawnchest;
            float despawncounter;
            float detectionradius;

            void Awake()
            {
                instance = new BuriedTreasure();
                lootbox = GetComponentInParent<BaseEntity>();
                playerid = lootbox.OwnerID;
                rarity = 1;
                despawncounter = 0f;
                isvisible = false;
                didspawnchest = false;
                detectionradius = config.globalSettings.LootDetectionRadius;
                string prefabmarker = config.globalSettings.MapMarkerPrefab;

                mapmarker = GameManager.server.CreateEntity(prefabmarker, lootbox.transform.position, Quaternion.identity, true) as MapMarker;
                mapmarker.OwnerID = lootbox.OwnerID;
                mapmarker.name = "Treasure Marker";
                mapmarker.Spawn();

                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = detectionradius;
            }

            private void OnTriggerEnter(Collider col)
            {
                if (didspawnchest) return;
                var target = col.GetComponentInParent<BasePlayer>();
                if (target != null)
                {
                    if (target.userID == lootbox.OwnerID)
                    {
                        SpawnTreasureChest();
                        didspawnchest = true;
                        instance.SendReply(target, "The Treasure is very close !!!!");
                    }
                }
            }

            void SpawnTreasureChest()
            {
                if (rarity == 1) prefabtreasure = config.globalSettings.BasicTreasurePrefab;
                if (rarity == 2) prefabtreasure = config.globalSettings.UnCommonTreasurePrefab;
                if (rarity == 3) prefabtreasure = config.globalSettings.RareTreasurePrefab;
                if (rarity == 4) prefabtreasure = config.globalSettings.EliteTreasurePrefab;
                treasurechest = GameManager.server.CreateEntity(prefabtreasure, lootbox.transform.position, Quaternion.identity, true);
                treasurechest.skinID = 111;
                treasurechest.OwnerID = lootbox.OwnerID;
                treasurechest.Spawn();
                treasurechest.gameObject.AddComponent<TreasureDespawner>();

                ItemContainer storageCont = treasurechest.GetComponent<StorageContainer>().inventory;
                storageCont.capacity = 36;
                if (config.globalSettings.UseOnlyLootTable) storageCont.Clear();

                AddLootTableItems(treasurechest);
                CheckForExtras(treasurechest);
                CheckSpawnVisibility(treasurechest);

                lootbox.Invoke("KillMessage", 0.2f);
            }

            void AddLootTableItems(BaseEntity treasurebox)
            {
                if (rarity == 1) loottable = config.globalSettings.BasicLootTable;
                if (rarity == 2) loottable = config.globalSettings.UnCommonLootTable;
                if (rarity == 3) loottable = config.globalSettings.RareLootTable;
                if (rarity == 4) loottable = config.globalSettings.EliteLootTable;

                foreach (KeyValuePair<string, int> lootlist in loottable)
                {
                    int itemqty = lootlist.Value;
                    string itemname = lootlist.Key;

                    Item foundItem = ItemManager.CreateByPartialName(itemname, 1);
                    if (foundItem != null)
                    {
                        var doSpawn = UnityEngine.Random.Range(1, 3);
                        if (doSpawn == 1) AddCustomLoot(treasurebox, itemqty, foundItem.info.itemid);
                    }
                }
            }
//Black Jack
            void AddCustomLoot(BaseEntity treasurebox, int qauntity, int itemid)
            {
                if (qauntity <= 0) qauntity = 1;
                ItemContainer component1 = treasurebox.GetComponent<StorageContainer>().inventory;
                Item item = ItemManager.CreateByItemID(itemid, UnityEngine.Random.Range(1, qauntity + 1), 0);
                component1.itemList.Add(item);
                item.parent = component1;
                item.MarkDirty();
            }

            void CheckSpawnVisibility(BaseEntity entitybox)
            {
                if (isvisible) return;
                if (entitybox.IsOutside()) { isvisible = true; return; }
                entitybox.transform.position = entitybox.transform.position + new Vector3(0f, 0.2f, 0f);
                entitybox.transform.hasChanged = true;
                entitybox.SendNetworkUpdateImmediate();
                CheckSpawnVisibility(entitybox);
            }

            void CheckForExtras(BaseEntity entitybox)
            {
                int randommaproll = UnityEngine.Random.Range(0, 100);
                if (rarity == 2) randommaproll = randommaproll - 2;
                if (rarity == 3) randommaproll = randommaproll - 4;
                if (rarity == 4) randommaproll = randommaproll - 6;
                if (randommaproll > 100) randommaproll = 100;
                if (randommaproll < 0) randommaproll = 0;
                if (randommaproll <= config.globalSettings.AddMapChance) AddRandomMap(entitybox);

                AddRandomGold(entitybox);
            }

            void AddRandomGold(BaseEntity entitybox)
            {
                int randomgoldroll = UnityEngine.Random.Range(0, 100);
                if (rarity == 2) randomgoldroll = randomgoldroll - 2;
                if (rarity == 3) randomgoldroll = randomgoldroll - 4;
                if (rarity == 4) randomgoldroll = randomgoldroll - 6;
                if (randomgoldroll > 100) randomgoldroll = 100;
                if (randomgoldroll < 0) randomgoldroll = 0;
                if (randomgoldroll <= config.globalSettings.AddGoldChance)
                {
                    ItemContainer component1 = entitybox.GetComponent<StorageContainer>().inventory;
                    Item item = ItemManager.CreateByItemID(1414245162, 1, 1376561963);
                    component1.itemList.Add(item);
                    item.parent = component1;
                    item.MarkDirty();
                }
            }

            void AddRandomMap(BaseEntity entitybox)
            {
                ulong skinid = 1389950043;
                var randomroll = UnityEngine.Random.Range(0, (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance));
                if (randomroll >= 0 && randomroll <= config.globalSettings.BasicMapChance) skinid = 1389950043;
                if (randomroll >= (config.globalSettings.BasicMapChance + 1) && randomroll <= (config.globalSettings.BasicMapChance + config.globalSettings.UnCommonMapChance)) skinid = 1390209788;
                if (randomroll >= (config.globalSettings.UnCommonMapChance + 1) && randomroll <= (config.globalSettings.UnCommonMapChance + config.globalSettings.RareMapChance)) skinid = 1390210901;
                if (randomroll >= (config.globalSettings.RareMapChance + 1) && randomroll <= (config.globalSettings.RareMapChance + config.globalSettings.EliteMapChance)) skinid = 1390211736;
                ItemContainer component1 = entitybox.GetComponent<StorageContainer>().inventory;
                Item item = ItemManager.CreateByItemID(1414245162, 1, skinid);
                component1.itemList.Add(item);
                item.parent = component1;
                item.MarkDirty();
            }

            void FixedUpdate()
            {
                if (despawncounter >= (config.globalSettings.DespawnTime * 15) && lootbox != null) { lootbox.Invoke("KillMessage", 0.1f); return; }
                despawncounter = despawncounter + 1f;
            }

            void OnDestroy()
            {
                if (mapmarker != null) mapmarker.Invoke("KillMessage", 0.1f);
                if (lootbox != null) lootbox.Invoke("KillMessage", 0.1f);
            }
        }

        #endregion

        #region TreasureDespawner 

        class TreasureDespawner : BaseEntity
        {
            BaseEntity treasure;
            BuriedTreasure instance;
            float despawncounter;

            void Awake()
            {
                instance = new BuriedTreasure();
                treasure = GetComponentInParent<BaseEntity>();
                despawncounter = 0f;
            }

            void FixedUpdate()
            {
                if (despawncounter >= (config.globalSettings.TreasureDespawnTime * 15) && treasure != null) { treasure.Invoke("KillMessage", 0.1f); return; }
                despawncounter = despawncounter + 1f;
            }

            void OnDestroy()
            {
                if (treasure != null) treasure.Invoke("KillMessage", 0.1f);
            }
        }

        #endregion
    }
}

// --- End of file: BuriedTreasure.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Leaderboard.cs ---
// --- Original Local Path: Leaderboard.cs ---

using System.Collections.Generic;
using System.Linq;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Leaderboard", "Sempai#3239", "1.0.0")]
    class Leaderboard : RustPlugin
    {
        #region Вар
        string Layer = "Leaderboard_UI";

        Dictionary<ulong, DataBase> DB = new Dictionary<ulong, DataBase>();
        #endregion

        #region Класс
        public class DataBase
        {
            public string DisplayName;
            public bool IsConnected;
            public int Kills;
            public int Deaths;
            public int Hs;
            public int Hits;
        }
        #endregion

        #region Хуки
        void OnServerInitialized()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Leaderboard/PlayerList"))
                DB = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, DataBase>>("Leaderboard/PlayerList");

            foreach (var check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (!DB.ContainsKey(player.userID))
                DB.Add(player.userID, new DataBase());

            DB[player.userID].DisplayName = player.displayName;
            DB[player.userID].IsConnected = true;
        }

        void OnPlayerDisconnected(BasePlayer player) 
        {
            DB[player.userID].IsConnected = false;
            SaveDataBase();
        }
        
        void Unload()
        {
            SaveDataBase();
        }

        void SaveDataBase() 
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("Leaderboard/PlayerList", DB); 
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (info == null || player == null || player.IsNpc || info.InitiatorPlayer == null || info.InitiatorPlayer.IsNpc) return;
            
            if (info.InitiatorPlayer != null)
            {
                var killer = info.InitiatorPlayer;

                if (killer != player) 
                { 
                    if (DB.ContainsKey(killer.userID))
                    {
                        DB[killer.userID].Kills++;
                    }
                }
                if (DB.ContainsKey(player.userID))
                {
                    DB[player.userID].Deaths++;
                }
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BasePlayer)
            {
                var attacker = info.InitiatorPlayer;  
                
                if (attacker != null)
                {
                    if (!attacker.IsNpc)
                    {
                        if (info.isHeadshot)
                        {
                            DB[attacker.userID].Hs++;
                        }
                        DB[attacker.userID].Hits++;
                    }
                }
            }
            
        }
        #endregion

        #region Команда
        [ConsoleCommand("stats")]
        void ConsoleStats(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            Leader(player, int.Parse(args.Args[0]));
        }
        #endregion

        #region Интерфейс
        void LeaderboardUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.284 0", AnchorMax = "0.952 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.6" },
            }, "Menu", Layer);
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.032 0.893", AnchorMax = $"0.347 0.954", OffsetMax = "0 0" },
                Image = { Color = "0.86 0.55 0.35 1" }
            }, Layer, "Title");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"LEADERBOARDS", Align = TextAnchor.MiddleCenter, FontSize = 25, Font = "robotocondensed-bold.ttf" }
            }, "Title");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.36 0.893", AnchorMax = $"0.97 0.954", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer, "Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = "Leaderboards updated when opening", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Description");

            CuiHelper.AddUi(player, container);
            Leader(player);
        }

        void Leader(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, "Lead");
            var container = new CuiElementContainer();
                        
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" },
            }, Layer, "Lead");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.85 0.03", AnchorMax = $"0.97 0.09", OffsetMax = "0 0" },
                Button = { Color = "0.86 0.55 0.35 1", Command = DB.Count() > (page + 1) * 15 ? $"stats {page + 1}" : "" },
                Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Lead");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.72 0.03", AnchorMax = $"0.84 0.09", OffsetMax = "0 0" },
                Button = { Color = "0.86 0.55 0.35 1", Command = page >= 1 ? $"stats {page - 1}" : "" },
                Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Lead");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.03 0.11", AnchorMax = $"0.97 0.19", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.2" }
            }, "Lead", "Stats");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.03 0.81", AnchorMax = $"0.97 0.85", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.5" },
                Text = { Text = $"        #                          Player Name                         Kills                          Deaths                          KDR                          HeadShots                          Hits                         Online", Color = "1 1 1 1", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, "Lead");

            float width = 0.945f, height = 0.04f, startxBox = 0.028f, startyBox = 0.805f - height, xmin = startxBox, ymin = startyBox, z = 0;
            var target = from targets in DB orderby targets.Value.Kills descending select targets;
            foreach (var check in target.Skip(page * 15).Take(15))
            {
                z++;
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "2 1", OffsetMax = "-2 -1" },
                    Image = { Color = "0 0 0 0.5" }
                 }, "Lead", "PlayerTop");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"0.8 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0" }
                }, "PlayerTop");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.06 1", OffsetMax = "0 0" },
                    Text = { Text = $"{z + page * 15}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "PlayerTop");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.07 0", AnchorMax = $"0.25 1", OffsetMax = "0 0" },
                    Text = { Text = $"{check.Value.DisplayName}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "PlayerTop");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.26 0", AnchorMax = $"0.32 1", OffsetMax = "0 0" },
                    Text = { Text = $"{check.Value.Kills}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "PlayerTop");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.38 0", AnchorMax = $"0.44 1", OffsetMax = "0 0" },
                    Text = { Text = $"{check.Value.Deaths}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "PlayerTop");

                var kdr = check.Value.Deaths == 0 ? check.Value.Kills : (float)Math.Round(((float)check.Value.Kills) / check.Value.Deaths, 1);
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.5 0", AnchorMax = $"0.56 1", OffsetMax = "0 0" },
                    Text = { Text = $"{kdr}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "PlayerTop");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.63 0", AnchorMax = $"0.69 1", OffsetMax = "0 0" },
                    Text = { Text = $"{check.Value.Hs}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "PlayerTop");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.76 0", AnchorMax = $"0.82 1", OffsetMax = "0 0" },
                    Text = { Text = $"{check.Value.Hits}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "PlayerTop");

                var online = check.Value.IsConnected == true ? "online" : "offline";
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.87 0", AnchorMax = $"0.94 1", OffsetMax = "0 0" },
                    Text = { Text = $"{online}", Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "PlayerTop");

                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.08 1", OffsetMax = "0 0" },
                Text = { Text = "YOUR\nSTATS", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "Stats");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.08 0.1", AnchorMax = $"0.25 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, "Stats", "Kill");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"Kills: {DB[player.userID].Kills}", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "Kill");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.26 0.1", AnchorMax = $"0.43 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, "Stats", "Death");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"Death: {DB[player.userID].Deaths}", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "Death");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.44 0.1", AnchorMax = $"0.61 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, "Stats", "Kdr");
            
            var kd = DB[player.userID].Deaths == 0 ? DB[player.userID].Kills : (float)Math.Round(((float)DB[player.userID].Kills) / DB[player.userID].Deaths, 1);
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"Kdr: {kd}", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "Kdr");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.62 0.1", AnchorMax = $"0.79 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, "Stats", "Hs");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"HeadShots: {DB[player.userID].Hs}", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "Hs");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.8 0.1", AnchorMax = $"0.97 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, "Stats", "Hits");
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"Hits: {DB[player.userID].Hits}", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "Hits");

            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}

// --- End of file: Leaderboard.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InventoryViewer.cs ---
// --- Original Local Path: InventoryViewer.cs ---


using System;
using System.Collections.Generic;
using System.Reflection;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Inventory Viewer", "Mughisi", "2.0.2", ResourceId = 871)]
    public class InventoryViewer : RustPlugin
    {

        private string prefix = "Inspector";

        private string prefixColor = "#008000ff";

        private const string Permission = "inventoryviewer.allowed";

        private static InventoryViewer instance;

        private readonly Dictionary<BasePlayer, List<BasePlayer>> activeMatches = new Dictionary<BasePlayer, List<BasePlayer>>();

        public class Inspector : MonoBehaviour
        {
            private BasePlayer player;

            private BasePlayer target;

            private LootableCorpse view;

            private int ticks;

            private readonly MethodInfo markDirty = typeof(PlayerLoot).GetMethod("MarkDirty", BindingFlags.NonPublic | BindingFlags.Instance);

            private readonly FieldInfo positionChecks = typeof(PlayerLoot).GetField("PositionChecks", BindingFlags.NonPublic | BindingFlags.Instance);

            public void StartInspecting(BasePlayer p, BasePlayer t)
            {
                player = p;
                target = t;

                var corpse = GameManager.server.CreateEntity("assets/prefabs/player/player_corpse.prefab") as BaseCorpse;
                if (corpse == null) return;
                corpse.parentEnt = null;
                corpse.transform.position = new Vector3(player.transform.position.x, -100, player.transform.position.z);
                corpse.CancelInvoke("RemoveCorpse");

                view = corpse as LootableCorpse;

                if (view == null) return;

                var source = new[] { target.inventory.containerMain, target.inventory.containerWear, target.inventory.containerBelt };
                view.containers = new ItemContainer[source.Length];
                for (var i = 0; i < source.Length; i++)
                {
                    view.containers[i] = source[i];
                    view.containers[i].playerOwner = target;
                }

                view.playerName = $"Inspecting {target.displayName}";
                view.playerSteamID = 0;
                view.enableSaving = false;
                view.Spawn();
                view.GetComponentInChildren<Rigidbody>().useGravity = false;

                BeginLooting();

                InvokeRepeating("Inspect", 0f, 0.1f);
            }

            private void Inspect()
            {
                ticks++;
                if (!player.inventory.loot.IsLooting()) BeginLooting();
                if (target.IsDead())
                {
                    instance.SendChatMessage(player, instance.GetTranslation("TargetDied", player.UserIDString));
                    StopInspecting();
                }
                if (!player.isConnected) return;
                player.inventory.loot.SendImmediate();
                player.SendNetworkUpdate();
            }

            public void StopInspecting()
            {
                if (ticks < 5 && !target.IsDead()) return;
                CancelInvoke("Inspect");
                StopLooting();
                for (var i = 0; i < view.containers.Length; i++) view.containers[i] = new ItemContainer();
                view.Kill();
                Remove();
            }

            private void BeginLooting()
            {
                if (target.IsDead()) return;
                player.inventory.loot.Clear();
                positionChecks.SetValue(player.inventory.loot, false);
                player.inventory.loot.entitySource = view;
                player.inventory.loot.itemSource = null;
                markDirty.Invoke(player.inventory.loot, null);

                view.SetFlag(BaseEntity.Flags.Open, true);

                foreach (var container in view.containers)
                    player.inventory.loot.containers.Add(container);

                player.inventory.loot.SendImmediate();
                view.ClientRPCPlayer(null, player, "RPC_ClientLootCorpse");
                player.SendNetworkUpdate();

                ticks = 0;
            }

            private void StopLooting()
            {
                markDirty.Invoke(player.inventory.loot, null);

                if (player.inventory.loot.entitySource)
                    player.inventory.loot.entitySource.SendMessage("PlayerStoppedLooting", player, SendMessageOptions.DontRequireReceiver);

                foreach (var container in player.inventory.loot.containers)
                    if (container != null)
                        container.onDirty -= (Action)Delegate.CreateDelegate(typeof(Action), player.inventory.loot, "MarkDirty");

                player.inventory.loot.containers.Clear();
                player.inventory.loot.entitySource = null;
                player.inventory.loot.itemSource = null;
            }

            public void Remove()
            {
                Destroy(this);
            }
        }

        private void Loaded()
        {
            instance = this;
            LoadConfigValues();
            LoadDefaultMessages();
            permission.RegisterPermission(Permission, this);
        }

        protected override void LoadDefaultConfig() => Puts("New configuration file generated.");

        private void LoadConfigValues()
        {
            prefix = GetConfig("Prefix", prefix);
            prefixColor = GetConfig("PrefixColor", prefixColor);
        }

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "NotAllowed", "You are not allowed to use this command." },
                { "NoPlayersFound", "Couldn't find any players matching that name." },
                { "MultiplePlayersFound", "Multiple players found with that name, please select one of these players by using '/viewinv list <number>':" },
                { "InvalidSelection", "Invalid number, use the number in front of the player's name. Use '/viewinv list' to check the list of players again." },
                { "InvalidArguments", "Invalid argument(s) supplied! Use '/viewinv <name>' or '/viewinv list <number>'." },
                { "NoListAvailable", "You do not have a players list available, use '/viewinv <name>' instead." },
                { "TargetDied", "The player you were looting died." }
            }, this);
        }

        private void Unload()
        {
            var inspectors = UnityEngine.Object.FindObjectsOfType<Inspector>();
            foreach (var inspector in inspectors)
                inspector.StopInspecting();
        }

        private void OnPlayerLootEnd(PlayerLoot looter)
        {
            looter.GetComponentInParent<BasePlayer>()?.GetComponent<Inspector>()?.StopInspecting();
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var view = entity as LootableCorpse;
            if (view == null) return;
            if (!view.playerName.StartsWith("Inspecting")) return;
            info.damageTypes.ScaleAll(0f);
        }

        [ChatCommand("viewinv")]
        private void ViewInventoryCommand(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player.UserIDString))
            {
                SendChatMessage(player, GetTranslation("NotAllowed", player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                SendChatMessage(player, GetTranslation("InvalidArguments", player.UserIDString));
                return;
            }

            if (args[0] == "list")
            {
                int num;
                if (args.Length == 1) ShowMatches(player);
                else if (int.TryParse(args[1], out num)) ShowMatch(player, num);
            }
            else
            {
                var name = string.Join(" ", args);
                var players = FindPlayersByNameOrId(name);

                switch (players.Count)
                {
                    case 0:
                        SendChatMessage(player, GetTranslation("NoPlayersFound", player.UserIDString));
                        break;
                    case 1:
                        ViewInventory(player, players[0]);
                        break;
                    default:
                        SendChatMessage(player, GetTranslation("MultiplePlayersFound", player.UserIDString));
                        if (!activeMatches.ContainsKey(player)) activeMatches.Add(player, null);
                        activeMatches[player] = players;
                        ShowMatches(player);
                        break;

                }
            }
        }

        private void ViewInventory(BasePlayer player, BasePlayer target)
        {
            var inspector = player.gameObject.GetComponent<Inspector>();
            inspector?.StopInspecting();
            inspector = player.gameObject.AddComponent<Inspector>();
            inspector.StartInspecting(player, target);
        }

        private List<BasePlayer> FindPlayersByNameOrId(string nameOrId)
        {
            var matches = new List<BasePlayer>();

            foreach (var ply in BasePlayer.activePlayerList)
            {
                if (ply.displayName.ToLower().Contains(nameOrId.ToLower()) || ply.UserIDString == nameOrId)
                    matches.Add(ply);
            }

            foreach (var ply in BasePlayer.sleepingPlayerList)
            {
                if (ply.displayName.ToLower().Contains(nameOrId.ToLower()) || ply.UserIDString == nameOrId)
                    matches.Add(ply);
            }

            return matches;
        }

        private void ShowMatches(BasePlayer player)
        {
            if (!activeMatches.ContainsKey(player) || activeMatches[player] == null)
            {
                SendChatMessage(player, GetTranslation("NoListAvailable", player.UserIDString));
                return;
            }

            for (var i = 0; i < activeMatches[player].Count; i++)
                SendReply(player, $"{i + 1}. {activeMatches[player][i].displayName}");
        }

        private void ShowMatch(BasePlayer player, int num)
        {
            if (!activeMatches.ContainsKey(player) || activeMatches[player] == null)
            {
                SendChatMessage(player, GetTranslation("NoListAvailable", player.UserIDString));
                return;
            }

            if (num > activeMatches[player].Count)
            {
                SendChatMessage(player, GetTranslation("InvalidSelection", player.UserIDString));
                ShowMatches(player);
                return;
            }

            ViewInventory(player, activeMatches[player][num - 1]);
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) Config[name] = defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private string GetTranslation(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        private bool IsAllowed(string id)
        {
            return permission.UserHasPermission(id, Permission);
        }

        private void SendChatMessage(BasePlayer player, string message, string arguments = null)
        {
            PrintToChat(player, $"<color={prefixColor}>{prefix}</color>: {message}");
        }

    }
}


// --- End of file: InventoryViewer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlockBlockElevators.cs ---
// --- Original Local Path: BlockBlockElevators.cs ---

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("BlockBlockElevators", "Reneb", "1.0.1")]
    class BlockBlockElevators : RustPlugin
    {

        BuildingBlock cachedBlock;
        TriggerBase cachedTrigger;
        BasePlayer cachedPlayer;
        int playerMask;
        int blockLayer;
        int triggerLayer;

        bool hasStarted = false;

        void OnServerInitialized()
        {
            hasStarted = true;
            playerMask = LayerMask.GetMask(new string[] { "Player (Server)" });
            triggerLayer = UnityEngine.LayerMask.NameToLayer("Trigger");
            blockLayer = UnityEngine.LayerMask.NameToLayer("Construction");
        }

        void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            cachedBlock = gameObject.GetComponent<BuildingBlock>();
            if (cachedBlock == null) return;
            if (cachedBlock.blockDefinition == null) return;
            if (cachedBlock.blockDefinition.fullName != "build/block.halfheight") return;
            cachedBlock.GetComponentInChildren<MeshCollider>().gameObject.AddComponent<TriggerBase>();
            cachedBlock.GetComponentInChildren<TriggerBase>().gameObject.layer = triggerLayer;
            cachedBlock.GetComponentInChildren<TriggerBase>().interestLayers = playerMask;
            timer.Once(0.1f, () => ResetBlock(cachedBlock) );

        }
        void ResetBlock(BuildingBlock block)
        {
            if (block == null) return;
            block.constructionCollision.UpdateLayer(false);
            GameObject.Destroy(block.GetComponentInChildren<TriggerBase>());
        }
        void OnEntityEnter(TriggerBase triggerbase, BaseEntity entity)
        {
            if (!hasStarted) return;
            cachedBlock = triggerbase.GetComponentInParent<BuildingBlock>();
            if (cachedBlock == null) return;
            if (cachedBlock.blockDefinition.fullName != "build/block.halfheight") return;
            cachedPlayer = entity.GetComponent<BasePlayer>();
            if (cachedPlayer == null) return;
            cachedBlock.Kill(BaseNetworkable.DestroyMode.Gib);
            cachedPlayer.SendConsoleCommand("chat.add", new object[] { "0", string.Format("<color=orange>{0}:</color> {1}", "Warning", "You are not allowed to build blocks over you"), 1.0 });
        }
    }
}


// --- End of file: BlockBlockElevators.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Kits3.cs ---
// --- Original Local Path: Kits3.cs ---

// #define TESTING

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Reflection;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins.KitsExtensionMethods;
using UnityEngine;
using UnityEngine.UI;
using Random = UnityEngine.Random;

#if CARBON
using Carbon.Base;
using Carbon.Modules;
#endif

namespace Oxide.Plugins
{
	[Info("Kits", "https://discord.gg/TrJ7jnS233", "2.0.7")]
	public class Kits : RustPlugin
	{
		#region Fields

		[PluginReference] private Plugin
			ImageLibrary = null,
			ServerPanel = null,
			CopyPaste = null,
			Notify = null,
			UINotify = null,
			NoEscape = null;

		private static Kits _instance;

		private const string
			PERM_ADMIN = "Kits.admin",
			
			Layer = "UI.Kits",
			InfoLayer = "UI.Kits.Info",
			EditingLayer = "UI.Kits.Editing",
			ModalLayer = "UI.Kits.Modal";

		private bool _enabledImageLibrary;

#if CARBON
        private ImageDatabaseModule imageDatabase;
#endif
		
		private const bool LangRu = false;
		
		private readonly Dictionary<ulong, Dictionary<string, object>> _kitEditing = new();

		private readonly Dictionary<ulong, Dictionary<string, object>> _itemEditing = new();

		private readonly Dictionary<string, List<(int itemID, string shortName)>> _itemsCategories = new();

		private readonly HashSet<ulong> _playersToRemoveFromUpdate = new();

		private (bool spStatus, int categoryID) _serverPanelCategory = (false, -1); // key - use serverPanel, value - category id
        
		private int _lastKitID;

		#endregion

		#region Config

		private Configuration _config;

		private class Configuration
		{
			[JsonProperty(PropertyName = LangRu ? "Автовайп" : "Automatic wipe on wipe")]
			public bool AutoWipe = false;

			[JsonProperty(PropertyName =
				LangRu
					? "Сохранять выданные наборы (с помощью команды kits.givekit) при вайпе?"
					: "Save given kits (via the kits.givekit command) on wipe?")]
			public bool SaveGivenKitsOnWipe = false;

			[JsonProperty(PropertyName = LangRu ? "Стандартный Цвет Набора" : "Default Kit Color")]
			public string KitColor = "#A0A935";

			[JsonProperty(PropertyName = LangRu ? "Работать с Notify?" : "Work with Notify?")]
			public bool UseNotify = true;

			[JsonProperty(PropertyName =
				LangRu ? "Работать с NoEscape? (Raid/Combat block)" : "Use NoEscape? (Raid/Combat block)")]
			public bool UseNoEscape = false;

			[JsonProperty(PropertyName = LangRu ? "Использовать блокировку рейда?" : "Use Raid Blocked?")]
			public bool UseRaidBlock = true;

			[JsonProperty(PropertyName = LangRu ? "Использовать блокировку комбата?" : "Use Combat Blocked?")]
			public bool UseCombatBlock = true;

			[JsonProperty(PropertyName =
				LangRu ? "Могут ли администраторы редактировать предметы? (по флаг)" : "Can admins edit? (by flag)")]
			public bool FlagAdmin = true;

			[JsonProperty(PropertyName = LangRu ? "Whitelist для NoEscape" : "Whitelist for NoEscape",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<string> NoEscapeWhiteList = new()
			{
				"kit name 1",
				"kit name 2"
			};

			[JsonProperty(PropertyName = LangRu ? "Команды" : "Commands",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public string[] Commands = {"kit", "kits"};

			[JsonProperty(PropertyName = "Economy")]
			public EconomyConf Economy = new()
			{
				Type = EconomyConf.EconomyType.Plugin,
				AddHook = "Deposit",
				BalanceHook = "Balance",
				RemoveHook = "Withdraw",
				Plug = "Economics",
				ShortName = "scrap",
				DisplayName = string.Empty,
				Skin = 0
			};

			[JsonProperty(PropertyName = LangRu ? "Настройки Редкости" : "Rarity Settings",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<RarityColor> RarityColors = new()
			{
				new RarityColor(40, "#A0A935")
			};

			[JsonProperty(PropertyName = LangRu ? "Авто наборы" : "Auto Kits",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<string> AutoKits = new()
			{
				"autokit", "autokit_vip", "autokit_premium"
			};

			[JsonProperty(PropertyName = LangRu ? "Получение автонабора 1 раз?" : "Getting an auto kit 1 time?")]
			public bool OnceAutoKit = false;

			[JsonProperty(PropertyName =
				LangRu ? "Разрешить включать/выключать автокиты?" : "Allow to enable/disable autokit?")]
			public bool UseChangeAutoKit = false;

			[JsonProperty(PropertyName =
				LangRu ? "Разрешение для включения/выключения автокитов" : "Permission to enable/disable autokit")]
			public string ChangeAutoKitPermission = "kits.changeautokit";

			[JsonProperty(PropertyName = LangRu ? "Игнорировать проверку автокита?" : "Ignore auto-kit checking?")]
			public bool IgnoreAutoKitChecking = true;

			[JsonProperty(PropertyName =
				LangRu
					? "Обновлять меню наборов во время операций с разрешениями?"
					: "Update the kits menu during permissions operations?")]
			public bool OnPermissionsUpdate = false;

			[JsonProperty(PropertyName = "Logs")] public LogInfo Logs = new()
			{
				Console = true,
				File = true
			};

			[JsonProperty(PropertyName =
				LangRu ? "Показывать оповещение об отсутвии прав?" : "Show No Permission Description?")]
			public bool ShowNoPermDescription = true;

			[JsonProperty(PropertyName = LangRu ? "Показывать все наборы?" : "Show All Kits?")]
			public bool ShowAllKits = false;

			[JsonProperty(PropertyName =
				LangRu
					? "Показывать набор, когда закончилось количество использований?"
					: "Show the kit when the number of uses is up?")]
			public bool ShowUsesEnd = false;

			[JsonProperty(PropertyName = "CopyPaste Parameters",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<string> CopyPasteParameters = new()
			{
				"deployables", "true", "inventories", "true"
			};

			[JsonProperty(PropertyName = LangRu ? "Блокировка в Building Block?" : "Block in Building Block?")]
			public bool BlockBuilding = false;

			[JsonProperty(PropertyName = LangRu ? "NPC Наборы" : "NPC Kits",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public Dictionary<string, NpcKitsData> NpcKits = new()
			{
				["1234567"] = new NpcKitsData
				{
					Description = "Free Kits",
					Kits = new List<string>
					{
						"kit_one",
						"kit_two"
					}
				},
				["7654321"] = new NpcKitsData
				{
					Description = "VIPs Kits",
					Kits = new List<string>
					{
						"kit_three",
						"kit_four"
					}
				}
			};

			[JsonProperty(PropertyName = LangRu ? "Описание" : "Description")]
			public MenuDescription Description = new()
			{
				AnchorMin = "0 0", AnchorMax = "1 0",
				OffsetMin = "0 -55", OffsetMax = "0 -5",
				Enabled = true,
				Color = new IColor("#0E0E10", 100),
				FontSize = 18,
				Font = "robotocondensed-bold.ttf",
				Align = TextAnchor.MiddleCenter,
				TextColor = new IColor("#FFFFFF", 100),
				Description = string.Empty
			};

			[JsonProperty(PropertyName = LangRu ? "Информация о наборе" : "Info Kit Description")]
			public DescriptionSettings InfoKitDescription = new()
			{
				AnchorMin = "0.5 1", AnchorMax = "0.5 1",
				OffsetMin = "-125 -55", OffsetMax = "125 -5",
				Enabled = true,
				Color = new IColor("#0E0E10", 100),
				FontSize = 18,
				Font = "robotocondensed-bold.ttf",
				Align = TextAnchor.MiddleCenter,
				TextColor = new IColor("#FFFFFF", 100)
			};

			[JsonProperty(PropertyName = LangRu ? "Интерфейс" : "Interface")]
			public UserInterface UI = UserInterface.GenerateFullscreenTemplateOldStyle();
			
			[JsonProperty(PropertyName = LangRu ? "Интерфейс для меню" : "Menu UI")]
			public UserInterface MenuUI = UserInterface.GenerateMenuTemplateRustV1();
			
			[JsonProperty(PropertyName = LangRu ? "Пользовательские названия для наборов" : "Custom Title for Kits")]
			public CustomTitles CustomTitles = new()
			{
				Enabled = false,
				KitTitles = new Dictionary<string, CustomTitles.KitTitle>
				{
					["custom_kit"] = new()
					{
						Enabled = false,
						Titles = new Dictionary<string, CustomTitles.TitleConf>
						{
							["NoPermissionDescription"] = new()
							{
								Enabled = false,
								Messages = new Dictionary<string, string>
								{
									["en"] = "You don't have permission to get this kit",
									["fr"] = "Vous n'avez pas l'autorisation d'obtenir ce kit"
								}
							},
							["KitAvailable"] = new()
							{
								Enabled = false,
								Messages = new Dictionary<string, string>
								{
									["en"] = "KIT AVAILABLE\nTO RECEIVE",
									["fr"] = "KIT DISPONIBLE\nPOUR RECEVOIR"
								}
							}
						}
					},
					["second_custom_kit"] = new()
					{
						Enabled = false,
						Titles = new Dictionary<string, CustomTitles.TitleConf>
						{
							["NoPermissionDescription"] = new()
							{
								Enabled = false,
								Messages = new Dictionary<string, string>
								{
									["en"] = "You don't have permission to get this kit",
									["fr"] = "Vous n'avez pas l'autorisation d'obtenir ce kit"
								}
							},
							["KitAvailable"] = new()
							{
								Enabled = false,
								Messages = new Dictionary<string, string>
								{
									["en"] = "KIT AVAILABLE\nTO RECEIVE",
									["fr"] = "KIT DISPONIBLE\nPOUR RECEVOIR"
								}
							}
						}
					}
				}
			};

			[JsonProperty(PropertyName = LangRu ? "Наборы, скрытые в интерфейсе" : "Kits hidden in the interface",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public string[] KitsHidden =
			{
				"Enter the name of the kit here",
				"Example of a string for the second kit"
			};

			public VersionNumber Version;
		}

		private class LogoConf : InterfacePosition
		{
			[JsonProperty(PropertyName = LangRu ? "Включено" : "Enabled")]
			public bool Enabled;

			[JsonProperty(PropertyName = LangRu ? "Изображение" : "Image")]
			public string Image;
		}

		private class CustomTitles
		{
			[JsonProperty(PropertyName = LangRu ? "Включено" : "Enabled")]
			public bool Enabled;

			[JsonProperty(
				PropertyName = LangRu
					? "Названия наборов (название набора – настройки)"
					: "Kit Titles (kit name – settings)",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public Dictionary<string, KitTitle> KitTitles = new();

			public class TitleConf
			{
				[JsonProperty(PropertyName = LangRu ? "Включено" : "Enabled")]
				public bool Enabled;

				[JsonProperty(PropertyName = LangRu ? "Текст (язык - текст)" : "Text (language - text)",
					ObjectCreationHandling = ObjectCreationHandling.Replace)]
				public Dictionary<string, string> Messages = new();

				public string GetMessage(BasePlayer player = null)
				{
					if (Messages.Count == 0)
						throw new Exception("The use of custom titles is enabled, but there are no messages!");

					var userLang = "en";
					if (player != null) userLang = _instance.lang.GetLanguage(player.UserIDString);

					return Messages.TryGetValue(userLang, out var message) ? message :
						Messages.TryGetValue("en", out message) ? message : Messages.ElementAt(0).Value;
				}
			}

			public class KitTitle
			{
				[JsonProperty(PropertyName = LangRu ? "Включено" : "Enabled")]
				public bool Enabled;

				[JsonProperty(PropertyName = LangRu ? "Название (ключ – настройки)" : "Titles (key – settings)",
					ObjectCreationHandling = ObjectCreationHandling.Replace)]
				public Dictionary<string, TitleConf> Titles = new();
			}
		}

		private class EconomyConf
		{
			#region Fields

			[JsonProperty(PropertyName = "Type (Plugin/Item)")] [JsonConverter(typeof(StringEnumConverter))]
			public EconomyType Type;

			[JsonProperty(PropertyName = "Plugin name")]
			public string Plug;

			[JsonProperty(PropertyName = "Balance add hook")]
			public string AddHook;

			[JsonProperty(PropertyName = "Balance remove hook")]
			public string RemoveHook;

			[JsonProperty(PropertyName = "Balance show hook")]
			public string BalanceHook;

			[JsonProperty(PropertyName = "ShortName")]
			public string ShortName;

			[JsonProperty(PropertyName = "Display Name (empty - default)")]
			public string DisplayName;

			[JsonProperty(PropertyName = "Skin")] public ulong Skin;

			#endregion

			#region Public Methods

			public double ShowBalance(BasePlayer player)
			{
				switch (Type)
				{
					case EconomyType.Plugin:
					{
						var plugin = _instance?.plugins?.Find(Plug);
						if (plugin == null) return 0;

						return Math.Round(Convert.ToDouble(plugin.Call(BalanceHook, player.UserIDString)));
					}
					case EconomyType.Item:
					{
						return PlayerItemsCount(player, ShortName, Skin);
					}
					default:
						return 0;
				}
			}

			public void AddBalance(BasePlayer player, double amount)
			{
				switch (Type)
				{
					case EconomyType.Plugin:
					{
						var plugin = _instance?.plugins?.Find(Plug);
						if (plugin == null) return;

						switch (Plug)
						{
							case "BankSystem":
							case "ServerRewards":
							case "IQEconomic":
								plugin.Call(AddHook, player.UserIDString, (int) amount);
								break;
							default:
								plugin.Call(AddHook, player.UserIDString, amount);
								break;
						}

						break;
					}
					case EconomyType.Item:
					{
						var am = (int) amount;

						var item = ToItem(am);
						if (item == null) return;

						player.GiveItem(item);
						break;
					}
				}
			}

			public bool RemoveBalance(BasePlayer player, double amount)
			{
				switch (Type)
				{
					case EconomyType.Plugin:
					{
						if (ShowBalance(player) < amount) return false;

						var plugin = _instance?.plugins.Find(Plug);
						if (plugin == null) return false;

						switch (Plug)
						{
							case "BankSystem":
							case "ServerRewards":
							case "IQEconomic":
								plugin.Call(RemoveHook, player.UserIDString, (int) amount);
								break;
							default:
								plugin.Call(RemoveHook, player.UserIDString, amount);
								break;
						}

						return true;
					}
					case EconomyType.Item:
					{
						var playerItems = Pool.Get<List<Item>>();
						player.inventory.GetAllItems(playerItems);
					
						var am = (int) amount;

						if (ItemCount(playerItems, ShortName, Skin) < am)
						{
							Pool.Free(ref playerItems);
							return false;
						}

						Take(playerItems, ShortName, Skin, am);
						Pool.Free(ref playerItems);
						return true;
					}
					default:
						return false;
				}
			}

			#endregion

			#region Private Methods

			private int PlayerItemsCount(BasePlayer player, string shortname, ulong skin)
			{
				var items = Pool.Get<List<Item>>();
				player.inventory.GetAllItems(items);
			
				var result = ItemCount(items, shortname, skin);
			
				Pool.Free(ref items);
				return result;
			}

			private int ItemCount(List<Item> items, string shortname, ulong skin)
			{
				return items.FindAll(item =>
						item.info.shortname == shortname && !item.isBroken && (skin == 0 || item.skin == skin))
					.Sum(item => item.amount);
			}

			private static void Take(List<Item> itemList, string shortname, ulong skinId, int iAmount)
			{
				if (iAmount == 0) return;

				var list = Pool.Get<List<Item>>();

				var num1 = 0;
				foreach (var item in itemList)
				{
					if (item.info.shortname != shortname ||
					    (skinId != 0 && item.skin != skinId) || item.isBroken) continue;

					var num2 = iAmount - num1;
					if (num2 <= 0) continue;
					if (item.amount > num2)
					{
						item.MarkDirty();
						item.amount -= num2;
						break;
					}

					if (item.amount <= num2)
					{
						num1 += item.amount;
						list.Add(item);
					}

					if (num1 == iAmount)
						break;
				}

				foreach (var obj in list)
					obj.RemoveFromContainer();

				Pool.FreeUnmanaged(ref list);
			}

			private Item ToItem(int amount)
			{
				var item = ItemManager.CreateByName(ShortName, amount, Skin);
				if (item == null)
				{
					Debug.LogError($"Error creating item with ShortName: '{ShortName}'");
					return null;
				}

				if (!string.IsNullOrEmpty(DisplayName)) item.name = DisplayName;

				return item;
			}

			#endregion

			#region Classes

			public enum EconomyType
			{
				Plugin,
				Item
			}

			#endregion
		}

		private enum InterfaceStyle
		{
			OldStyle,
			NewRust
		}
		
		private class UserInterface
		{
			#region Fields

			[JsonProperty(PropertyName = LangRu ? "Стиль" : "Style")]
			[JsonConverter(typeof(StringEnumConverter))]
			public InterfaceStyle Style;
			
			[JsonProperty(PropertyName = LangRu ? "Высота" : "Height")]
			public float Height;

			[JsonProperty(PropertyName = LangRu ? "Ширина" : "Width")]
			public float Width;

			[JsonProperty(PropertyName = LangRu ? "Высота набора" : "Kit Height")]
			public float KitHeight;

			[JsonProperty(PropertyName = LangRu ? "Ширина набора" : "Kit Width")]
			public float KitWidth;

			[JsonProperty(PropertyName = LangRu ? "Отступ" : "Margin")]
			public float Margin;

			[JsonProperty(PropertyName = LangRu ? "Кол-во наборов на строке" : "Kits On String")]
			public int KitsOnString;

			[JsonProperty(PropertyName = LangRu ? "Кол-во строк" : "Strings")]
			public int Strings;

			[JsonProperty(PropertyName = LangRu ? "Отступ по слева" : "Left Indent")]
			public float LeftIndent;

			[JsonProperty(PropertyName = LangRu ? "Отступ по вертикали" : "Y Indent")]
			public float YIndent;

			[JsonProperty(PropertyName = LangRu ? "Настройки доступности набора" : "Kit Available Settings")]
			public InterfacePosition KitAvailable;

			[JsonProperty(PropertyName = LangRu ? "Настройки количества набора" : "Kit Amount Settings")]
			public KitAmountSettings KitAmount;

			[JsonProperty(PropertyName = LangRu ? "Настройки КД набора" : "Kit Cooldown Settings")]
			public InterfacePosition KitCooldown;

			[JsonProperty(PropertyName = LangRu ? "Настройки продажи" : "Kit Sale Settings")]
			public InterfacePosition KitSale;

			[JsonProperty(PropertyName =
				LangRu ? "Настройка КД набора (с количеством)" : "Kit Cooldown Settings (with amount)")]
			public InterfacePosition KitAmountCooldown;

			[JsonProperty(PropertyName = LangRu ? "Настройки отсутствия прав" : "No Permission Settings")]
			public InterfacePosition NoPermission;

			[JsonProperty(PropertyName =
				LangRu ? "Закрывать интерфейс после получения набора?" : "Close the interface after receiving a kit?")]
			public bool CloseAfterReceive;

			[JsonProperty(PropertyName = LangRu ? "Настройки логотипа" : "Logo Settings")]
			public LogoConf Logo;

			[JsonProperty(PropertyName = LangRu ? "Настройки заголовка" : "Header Settings")]
			public KitsPanelHeaderUI HeaderPanel;

			[JsonProperty(PropertyName = LangRu ? "Настройки панели китов" : "Kits Panel Settings")]
			public KitsPanelContentUI ContentPanel;

			[JsonProperty(PropertyName = LangRu ? "Настройки кита" : "Kit Settings")]
			public KitsPanelKitUI KitPanel;

			[JsonProperty(PropertyName = LangRu ? "Цвет 1" : "Color 1")]
			public IColor ColorOne;

			[JsonProperty(PropertyName = LangRu ? "Цвет 2" : "Color 2")]
			public IColor ColorTwo;

			[JsonProperty(PropertyName = LangRu ? "Цвет 3" : "Color 3")]
			public IColor ColorThree;

			[JsonProperty(PropertyName = LangRu ? "Цвет 4" : "Color 4")]
			public IColor ColorFour;

			[JsonProperty(PropertyName = LangRu ? "Цвет 5" : "Color 5")]
			public IColor ColorFive;

			[JsonProperty(PropertyName = LangRu ? "Цвет 6" : "Color 6")]
			public IColor ColorSix;

			[JsonProperty(PropertyName = LangRu ? "Цвет 7" : "Color 7")]
			public IColor ColorSeven;

			[JsonProperty(PropertyName = LangRu ? "Цвет Red" : "Color Red")]
			public IColor ColorRed;

			[JsonProperty(PropertyName = LangRu ? "Цвет White" : "Color White")]
			public IColor ColorWhite;

			[JsonProperty(PropertyName = LangRu ? "Цвет фона" : "Background Color")]
			public IColor ColorBackground;

			#endregion

			#region Classes

			public class KitsPanelHeaderUI
			{
				[JsonProperty(PropertyName = "Background")]
				public ImageSettings Background = new();
				
				[JsonProperty(PropertyName = "Title")]
				public TextSettings Title = new();
				
				[JsonProperty(PropertyName = "Show Line?")]
				public bool ShowLine;
                
				[JsonProperty(PropertyName = "Line")]
				public ImageSettings Line = new();

				[JsonProperty(PropertyName = "Close Button")]
				public ButtonSettings ButtonClose = new();
			}

			public class KitsPanelContentUI
			{
				[JsonProperty(PropertyName = "Background")]
				public ImageSettings Background = new();
				
				[JsonProperty(PropertyName = "Button Back")]
				public ButtonSettings ButtonBack = new();
				
				[JsonProperty(PropertyName = "Button Next")]
				public ButtonSettings ButtonNext = new();
				
				[JsonProperty(PropertyName = "Button Create Kit")]
				public ButtonSettings ButtonCreateKit = new();

				[JsonProperty(PropertyName = "Show All Kits Checkbox")]
				public CheckBoxSettings CheckboxShowAllKits = new();
			}
            
            public class KitsPanelKitUI
            {
                [JsonProperty(PropertyName = "Background")]
				public ImageSettings Background = new();
				
				[JsonProperty(PropertyName = "Show Name?")]
				public bool ShowName;

				[JsonProperty(PropertyName = "Kit Name")]
				public TextSettings KitName = new();
			
				[JsonProperty(PropertyName = "Show Number?")]
                public bool ShowNumber;
                
				[JsonProperty(PropertyName = "Kit Number")]
				public TextSettings KitNumber = new();
				
				[JsonProperty(PropertyName = "Kit Image")]
				public InterfacePosition KitImage = new();
				
				[JsonProperty(PropertyName = "Kit Button Take")]
				public ButtonSettings KitButtonTake = new();
				
				[JsonProperty(PropertyName = "Kit Button Take (when show info)")]
				public ButtonSettings KitButtonTakeWhenShowInfo = new();
				
				[JsonProperty(PropertyName = "Kit Button Info")]
				public ButtonSettings KitButtonInfo = new();
				
				[JsonProperty(PropertyName = "Show Line?")]
				public bool ShowLine;
                
				[JsonProperty(PropertyName = "Kit Line")]
				public InterfacePosition KitLine = new();
            }

			#endregion

			#region Templates

			public static UserInterface GenerateFullscreenTemplateOldStyle()
			{
				return new UserInterface()
				{
					Style = InterfaceStyle.OldStyle,
					Height = 455,
					Width = 640,
					KitHeight = 165,
					KitWidth = 135f,
					Margin = 10f,
					KitsOnString = 4,
					Strings = 2,
					LeftIndent = 35,
					YIndent = -50f,
					KitAvailable = new InterfacePosition
					{
						AnchorMin = "0 1",
						AnchorMax = "1 1",
						OffsetMin = "0 -100",
						OffsetMax = "0 -75"
					},
					KitAmount = new KitAmountSettings
					{
						AnchorMin = "0.5 1",
						AnchorMax = "0.5 1",
						OffsetMin = "-125",
						OffsetMax = "-120",
						Width = 115
					},
					KitCooldown = new InterfacePosition
					{
						AnchorMin = "0.5 1",
						AnchorMax = "0.5 1",
						OffsetMin = "-32.5 -125",
						OffsetMax = "32.5 -105"
					},
					KitSale = new InterfacePosition
					{
						AnchorMin = "0.5 1",
						AnchorMax = "0.5 1",
						OffsetMin = "-32.5 -115",
						OffsetMax = "32.5 -95"
					},
					KitAmountCooldown = new InterfacePosition
					{
						AnchorMin = "0 1",
						AnchorMax = "1 1",
						OffsetMin = "0 -120",
						OffsetMax = "0 -95"
					},
					NoPermission = new InterfacePosition
					{
						AnchorMin = "0 1",
						AnchorMax = "1 1",
						OffsetMin = "0 -100",
						OffsetMax = "0 -75"
					},
					CloseAfterReceive = true,
					Logo = new LogoConf
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "10 -20",
						OffsetMax = "50 20",
						Enabled = false,
						Image = string.Empty
					},
					HeaderPanel = new KitsPanelHeaderUI()
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 1",
							AnchorMax = "1 1",
							OffsetMin = "0 -50",
							OffsetMax = "0 0",
                            Color = new IColor("#161617", 100),
						},
						Title = new TextSettings()
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "10 0",
							OffsetMax = "0 0",
							Align = TextAnchor.MiddleLeft,
							IsBold = true,
							FontSize = 14,
							Color = IColor.CreateWhite()
						},
						ButtonClose = new ButtonSettings
						{
							AnchorMin = "1 1", AnchorMax = "1 1",
							OffsetMin = "-35 -37.5",
							OffsetMax = "-10 -12.5",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 10,
							Color = IColor.CreateWhite(),
							ButtonColor = new IColor("#4B68FF", 100),
						}
					},
					ContentPanel = new KitsPanelContentUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 0",
							AnchorMax = "1 1",
							OffsetMin = "0 0",
							OffsetMax = "0 -50",
							Color = IColor.CreateTransparent()
						},
						ButtonBack = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1",
							OffsetMin = "-132.5 -32.5",
							OffsetMax = "-72.5 -10",
							Align = TextAnchor.MiddleCenter,
							IsBold = false,
							FontSize = 10,
							Color = new IColor("#FFFFFF", 100),
							ButtonColor = new IColor("#161617", 100),
						},
						ButtonNext = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1",
							OffsetMin = "-70 -32.5",
							OffsetMax = "-10 -10",
							Align = TextAnchor.MiddleCenter,
							IsBold = false,
							FontSize = 10,
							Color = new IColor("#FFFFFF", 100),
							ButtonColor = new IColor("#4B68FF", 100),
						},
						ButtonCreateKit = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1",
							OffsetMin = "-237.5 -32.5",
							OffsetMax = "-142.5 -10",
							Align = TextAnchor.MiddleCenter,
							IsBold = false,
							FontSize = 10,
							Color = new IColor("#FFFFFF", 100),
							ButtonColor = new IColor("#4B68FF", 100),
						},
						CheckboxShowAllKits = new CheckBoxSettings()
						{
							Background = new ImageSettings
							{
								AnchorMin = "0 1", 
								AnchorMax = "0 1",
								OffsetMin = "35 -25",
								OffsetMax = "45 -15",
								Color = IColor.CreateTransparent()
							},
							CheckboxButton = new ButtonSettings
							{
								AnchorMin = "0 0.5", AnchorMax = "0 0.5",
								OffsetMin = "5 -7", OffsetMax = "19 7",
								Align = TextAnchor.MiddleCenter,
								IsBold = true,
								FontSize = 10,
								Color = IColor.CreateWhite(),
								ButtonColor = IColor.CreateTransparent(),
							},
							CheckboxColor = new IColor("#4B68FF", 100),
							CheckboxSize = 2f,
							Title = new TextSettings
							{
								AnchorMin = "1 0",
								AnchorMax = "1 1",
								OffsetMin = "4 -4",
								OffsetMax = "104 4",
								IsBold = true, FontSize = 10, Align = TextAnchor.MiddleLeft,
								Color = IColor.CreateWhite()
							}
						},
					},
					KitPanel = new KitsPanelKitUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 0",
							AnchorMax = "1 1",
							OffsetMin = "0 30",
							OffsetMax = "0 0",
							Color = new IColor("#161617", 100)
						},
						ShowName = true,
						KitName = new TextSettings()
						{
							AnchorMin = "0.5 1",
							AnchorMax = "0.5 1",
							OffsetMin = "-45 -75",
							OffsetMax = "45 0",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 16,
							Color = IColor.CreateWhite(),
						},
						ShowNumber = true,
						KitNumber = new TextSettings()
						{
							AnchorMin = "0.5 1", 
							AnchorMax = "0.5 1",
							OffsetMin = "-45 -75",
							OffsetMax = "45 0",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 60,
							Color = new IColor("#303030", 100),
						},
						KitImage = new InterfacePosition
						{
							AnchorMin = "0.5 1",
							AnchorMax = "0.5 1",
							OffsetMin = "-32 -75",
							OffsetMax = "32 -11"
						},
						KitButtonTake = new ButtonSettings
						{
							AnchorMin = "0 1", AnchorMax = "1 1",
							OffsetMin = "0 -165",
							OffsetMax = "0 -140",
							Align = TextAnchor.MiddleCenter,
							IsBold = false,
							FontSize = 10,
							Color = IColor.CreateWhite(),
							ButtonColor = new IColor("#161617", 100),
						},
						KitButtonTakeWhenShowInfo = new ButtonSettings
						{
							AnchorMin = "0 1", AnchorMax = "0 1",
							OffsetMin = "0 -165",
							OffsetMax = "105 -140",
							Align = TextAnchor.MiddleCenter,
							IsBold = false,
							FontSize = 10,
							Color = IColor.CreateWhite(),
							ButtonColor = new IColor("#161617", 100),
						},
						KitButtonInfo = new ButtonSettings
						{
							AnchorMin = "1 1", AnchorMax = "1 1",
							OffsetMin = "-25 -165",
							OffsetMax = "0 -140",
							Align = TextAnchor.MiddleCenter,
							IsBold = false,
							FontSize = 10,
							Color = IColor.CreateWhite(),
							ButtonColor = new IColor("#161617", 100),
						},
						ShowLine = true,
						KitLine = new InterfacePosition
						{
							AnchorMin = "0 0", AnchorMax = "1 0",
							OffsetMin = "0 0", OffsetMax = "0 2"
						}
					},
					ColorOne = new IColor("#161617", 100),
					ColorTwo = new IColor("#0E0E10", 100),
					ColorThree = new IColor("#4B68FF", 100),
					ColorFour = new IColor("#303030", 100),
					ColorFive = new IColor("#0E0E10", 98),
					ColorSix = new IColor("#161617", 80),
					ColorSeven = new IColor("#4B68FF", 50),
					ColorRed = new IColor("#FF4B4B", 100),
					ColorWhite = new IColor("#FFFFFF", 100),
					ColorBackground = new IColor("#0E0E10", 100),
				};
			}

			public static UserInterface GenerateMenuTemplateRustV1()
			{
				return new UserInterface()
				{
					Style = InterfaceStyle.NewRust,
					Height = 455,
					Width = 640,
					KitHeight = 238,
					KitWidth = 160,
					Margin = 16,
					KitsOnString = 7,
					Strings = 2,
					LeftIndent = 0,
					YIndent = 0,
					KitAvailable = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"
					},
					KitAmount = new KitAmountSettings
					{
						AnchorMin = "0.5 0",
						AnchorMax = "0.5 0",
						OffsetMin = "0",
						OffsetMax = "4",
						Width = 140
					},
					KitCooldown = new InterfacePosition
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 0.5",
						OffsetMin = "0 -10",
						OffsetMax = "0 20"
					},
					KitSale = new InterfacePosition
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 0.5",
						OffsetMin = "0 -10",
						OffsetMax = "0 20"
					},
					KitAmountCooldown = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", 
						OffsetMin = "0 4", OffsetMax = "0 0"
					},
					NoPermission = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"
					},
					CloseAfterReceive = true,
					Logo = new LogoConf
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "10 -20",
						OffsetMax = "50 20",
						Enabled = false,
						Image = string.Empty
					},
					HeaderPanel = new KitsPanelHeaderUI()
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 1", AnchorMax = "1 1", 
							OffsetMin = "40 -50", OffsetMax = "-40 0",
							Color = IColor.CreateTransparent()
						},
						Title = new TextSettings()
						{
							AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -50", OffsetMax = "-5 0",
							IsBold = true,
							FontSize = 0,
							Align = TextAnchor.UpperLeft,
							Color = IColor.CreateTransparent()
						},
						ShowLine = false,
						Line = new(),
						ButtonClose = new(),
					},
					ContentPanel = new KitsPanelContentUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 0.5", AnchorMax = "1 0.5",
							OffsetMin = "32 -250", OffsetMax = "-32 250",
							Color = IColor.CreateTransparent()
						},
						ButtonBack = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-65 6", OffsetMax = "-35 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 12,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#38393F", 100)
						},
						ButtonNext = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-30 6", OffsetMax = "0 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 12,
							Color = new IColor("#FFFFFF", 100),
							ButtonColor = new IColor("#D74933", 100)
						},
						ButtonCreateKit = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-160 6", OffsetMax = "-70 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 14,
							Color = new IColor("#71B8ED", 100),
							ButtonColor = new IColor("#71B8ED", 20),
						},
						CheckboxShowAllKits = new CheckBoxSettings()
						{
							Background = new ImageSettings
							{
								AnchorMin = "0 1", 
								AnchorMax = "0 1",
								OffsetMin = "0 10", 
								OffsetMax = "22 32",
								Color = IColor.CreateTransparent()
							},
							CheckboxButton = new ButtonSettings
							{
								AnchorMin = "0 0.5", AnchorMax = "0 0.5",
								OffsetMin = "5 -7", OffsetMax = "19 7",
								Align = TextAnchor.MiddleCenter,
								IsBold = true,
								FontSize = 10,
								Color = IColor.CreateWhite(),
								ButtonColor = IColor.CreateTransparent(),
							},
							CheckboxColor = new IColor("#38393F"),
							CheckboxSize = 3f,
							Title = new TextSettings
							{
								AnchorMin = "1 0",
								AnchorMax = "1 1",
								OffsetMin = "4 -4",
								OffsetMax = "104 4",
								IsBold = true, FontSize = 10, Align = TextAnchor.MiddleLeft,
								Color = IColor.CreateWhite()
							}
						},
					},
					
					KitPanel = new KitsPanelKitUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "0 0", OffsetMax = "0 0",
							Color = new IColor("#38393F", 40),
						},
						ShowName = true,
						KitName = new TextSettings()
						{
							AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "10 -35", OffsetMax = "-10 -5",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 18,
							Color = new IColor("#E2DBD3", 100),
						},
						ShowNumber = true,
						KitNumber = new TextSettings()
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-60 -155", OffsetMax = "60 -35",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 60,
							Color = new IColor("#E2DBD3", 20),
						},
						KitImage = new InterfacePosition
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-60 -155", OffsetMax = "60 -35"
						},
						KitButtonTake = new ButtonSettings
						{
							AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-70 10", OffsetMax = "70 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#D74933", 100),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
						KitButtonTakeWhenShowInfo = new ButtonSettings
						{
							AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-70 10", OffsetMax = "40 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#D74933", 100),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
						KitButtonInfo = new ButtonSettings
						{
							AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "125 10", OffsetMax = "-10 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#F19F39", 60),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
					},
					ColorOne = new IColor("#E2DBD3", 100),
					ColorTwo = new IColor("#D74933", 100),
					ColorThree = new IColor("#8B8B8B", 15),
					ColorFour = new IColor("#38393F", 50),
					ColorFive = new IColor("#E2DBD3", 20),
					ColorSix = new IColor("#F19F39", 60),
					ColorSeven = new IColor("#CF432D", 90),
					ColorRed = new IColor("#FF4B4B", 100),
					ColorWhite = new IColor("#FFFFFF", 100),
					ColorBackground = new IColor("#000000", 0),
				};
			}

			public static UserInterface GenerateMenuTemplateRustV2()
			{
				return new UserInterface()
				{
					Style = InterfaceStyle.NewRust,
					Height = 455,
					Width = 640,
					KitHeight = 238,
					KitWidth = 160,
					Margin = 16,
					KitsOnString = 5,
					Strings = 2,
					LeftIndent = 0,
					YIndent = 0,
					KitAvailable = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"
					},
					KitAmount = new KitAmountSettings
					{
						AnchorMin = "0.5 0",
						AnchorMax = "0.5 0",
						OffsetMin = "0",
						OffsetMax = "4",
						Width = 140
					},
					KitCooldown = new InterfacePosition
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 0.5",
						OffsetMin = "0 -10",
						OffsetMax = "0 20"
					},
					KitSale = new InterfacePosition
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 0.5",
						OffsetMin = "0 -10",
						OffsetMax = "0 20"
					},
					KitAmountCooldown = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", 
						OffsetMin = "0 4", OffsetMax = "0 0"
					},
					NoPermission = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"
					},
					CloseAfterReceive = true,
					Logo = new LogoConf
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "10 -20",
						OffsetMax = "50 20",
						Enabled = false,
						Image = string.Empty
					},
					HeaderPanel = new KitsPanelHeaderUI()
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 1", AnchorMax = "1 1", 
							OffsetMin = "40 -70", OffsetMax = "-40 -20",
							Color = IColor.CreateTransparent()
						},
						Title = new TextSettings()
						{
							AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -50", OffsetMax = "-5 0",
							IsBold = true,
							FontSize = 32,
							Align = TextAnchor.UpperLeft,
							Color = new IColor("#CF432D", 90),
						},
						ShowLine = true,
						Line = new ImageSettings
						{
							AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -51", OffsetMax = "-42 -49",
							Color = new IColor("#373737", 50)
                        },
						ButtonClose = new ButtonSettings
						{
							AnchorMin = "1 1", AnchorMax = "1 1",
							OffsetMin = "-35 -37.5",
							OffsetMax = "-10 -12.5",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 10,
							Color = IColor.CreateWhite(),
							ButtonColor = new IColor("#4B68FF", 100),
						}
					},
					ContentPanel = new KitsPanelContentUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 0.5", AnchorMax = "1 0.5",
							OffsetMin = "40 -290", OffsetMax = "-40 200",
							Color = IColor.CreateTransparent()
						},
						ButtonBack = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-87 6", OffsetMax = "-57 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 12,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#38393F", 100)
						},
						ButtonNext = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-52 6", OffsetMax = "-22 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 12,
							Color = new IColor("#FFFFFF", 100),
							ButtonColor = new IColor("#D74933", 100)
						},
						ButtonCreateKit = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-182 6", OffsetMax = "-92 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 14,
							Color = new IColor("#71B8ED", 100),
							ButtonColor = new IColor("#71B8ED", 20),
						},
						CheckboxShowAllKits = new CheckBoxSettings()
						{
							Background = new ImageSettings
							{
								AnchorMin = "0 1", 
								AnchorMax = "0 1",
								OffsetMin = "0 10", 
								OffsetMax = "22 32",
								Color = IColor.CreateTransparent()
							},
							CheckboxButton = new ButtonSettings
							{
								AnchorMin = "0 0.5", AnchorMax = "0 0.5",
								OffsetMin = "5 -7", OffsetMax = "19 7",
								Align = TextAnchor.MiddleCenter,
								IsBold = true,
								FontSize = 10,
								Color = IColor.CreateWhite(),
								ButtonColor = IColor.CreateTransparent(),
							},
							CheckboxColor = new IColor("#38393F"),
							CheckboxSize = 3f,
							Title = new TextSettings
							{
								AnchorMin = "1 0",
								AnchorMax = "1 1",
								OffsetMin = "4 -4",
								OffsetMax = "104 4",
								IsBold = true, FontSize = 10, Align = TextAnchor.MiddleLeft,
								Color = IColor.CreateWhite()
							}
						},
					},
					
					KitPanel = new KitsPanelKitUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "0 0", OffsetMax = "0 0",
							Color = new IColor("#38393F", 40),
						},
						ShowName = true,
						KitName = new TextSettings()
						{
							AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "10 -35", OffsetMax = "-10 -5",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 18,
							Color = new IColor("#E2DBD3", 100),
						},
						ShowNumber = true,
						KitNumber = new TextSettings()
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-60 -155", OffsetMax = "60 -35",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 60,
							Color = new IColor("#E2DBD3", 20),
						},
						KitImage = new InterfacePosition
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-60 -155", OffsetMax = "60 -35"
						},
						KitButtonTake = new ButtonSettings
						{
							AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-70 10", OffsetMax = "70 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#D74933", 100),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
						KitButtonTakeWhenShowInfo = new ButtonSettings
						{
							AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-70 10", OffsetMax = "40 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#D74933", 100),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
						KitButtonInfo = new ButtonSettings
						{
							AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "125 10", OffsetMax = "-10 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#F19F39", 60),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
					},
					ColorOne = new IColor("#E2DBD3", 100),
					ColorTwo = new IColor("#D74933", 100),
					ColorThree = new IColor("#8B8B8B", 15),
					ColorFour = new IColor("#38393F", 50),
					ColorFive = new IColor("#E2DBD3", 20),
					ColorSix = new IColor("#F19F39", 60),
					ColorSeven = new IColor("#CF432D", 90),
					ColorRed = new IColor("#FF4B4B", 100),
					ColorWhite = new IColor("#FFFFFF", 100),
					ColorBackground = new IColor("#000000", 0),
				};
			}

			public static UserInterface GenerateFullscreenTemplateRust()
			{
				return new UserInterface()
				{
					Style = InterfaceStyle.NewRust,
					Height = 455,
					Width = 688,
					KitHeight = 238,
					KitWidth = 160,
					Margin = 16,
					KitsOnString = 4,
					Strings = 2,
					LeftIndent = 0,
					YIndent = 0,
					KitAvailable = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"
					},
					KitAmount = new KitAmountSettings
					{
						AnchorMin = "0.5 0",
						AnchorMax = "0.5 0",
						OffsetMin = "0",
						OffsetMax = "4",
						Width = 140
					},
					KitCooldown = new InterfacePosition
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 0.5",
						OffsetMin = "0 -10",
						OffsetMax = "0 20"
					},
					KitSale = new InterfacePosition
					{
						AnchorMin = "0 0.5",
						AnchorMax = "1 0.5",
						OffsetMin = "0 -10",
						OffsetMax = "0 20"
					},
					KitAmountCooldown = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", 
						OffsetMin = "0 4", OffsetMax = "0 0"
					},
					NoPermission = new InterfacePosition
					{
						AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"
					},
					CloseAfterReceive = true,
					Logo = new LogoConf
					{
						AnchorMin = "0 0.5",
						AnchorMax = "0 0.5",
						OffsetMin = "10 -20",
						OffsetMax = "50 20",
						Enabled = false,
						Image = string.Empty
					},
					HeaderPanel = new KitsPanelHeaderUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 1", AnchorMax = "1 1", 
							OffsetMin = "0 0", OffsetMax = "0 50",
							Color =new IColor("#38393F", 40),
							Material = "assets/content/ui/namefontmaterial.mat"
						},
						Title = new TextSettings()
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "20 0", OffsetMax = "0 0",
							Align = TextAnchor.MiddleLeft,
							IsBold = true,
							FontSize = 18,
							Color = new IColor("#E2DBD3")
						},
						ButtonClose = new ButtonSettings
						{
							AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-35 -15", OffsetMax = "-5 15",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 10,
							ImageColor = new IColor("#E2DBD3"),
							ButtonColor = new IColor("#D74933"),
							UseCustomPositionImage = true,
							ImagePosition = new InterfacePosition
							{
								AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-9 -9", OffsetMax = "9 9"
							},
							Image = "assets/icons/close.png",
							Material = "assets/content/ui/namefontmaterial.mat",
						}
					},
					ContentPanel = new KitsPanelContentUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 0",
							AnchorMax = "1 1",
							OffsetMin = "0 0",
							OffsetMax = "0 -50",
							Color = IColor.CreateTransparent()
						},
						ButtonBack = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1",
							OffsetMin = "-65 6", 
							OffsetMax = "-35 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 12,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#38393F", 100),
							Material = "assets/content/ui/namefontmaterial.mat"
						},
						ButtonNext = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1", 
							OffsetMin = "-30 6", 
							OffsetMax = "-0 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 12,
							Color = new IColor("#FFFFFF", 100),
							ButtonColor = new IColor("#D74933", 100),
							Material = "assets/content/ui/namefontmaterial.mat"
						},
						ButtonCreateKit = new ButtonSettings()
						{
							AnchorMin = "1 1", AnchorMax = "1 1", 
							OffsetMin = "-160 6", OffsetMax = "-70 36",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 14,
							Color = new IColor("#71B8ED", 100),
							ButtonColor = new IColor("#71B8ED", 5),
							Material = "assets/content/ui/namefontmaterial.mat"
						},
						CheckboxShowAllKits = new CheckBoxSettings()
						{
							Background = new ImageSettings
							{
								AnchorMin = "0 1", 
								AnchorMax = "0 1",
								OffsetMin = "0 10", 
								OffsetMax = "22 32",
								Color = IColor.CreateTransparent()
							},
							CheckboxButton = new ButtonSettings
							{
								AnchorMin = "0 0.5", AnchorMax = "0 0.5",
								OffsetMin = "5 -7", OffsetMax = "19 7",
								Align = TextAnchor.MiddleCenter,
								IsBold = true,
								FontSize = 10,
								Color = IColor.CreateWhite(),
								ButtonColor = IColor.CreateTransparent(),
							},
							CheckboxColor = new IColor("#38393F"),
							CheckboxSize = 3f,
							Title = new TextSettings
							{
								AnchorMin = "1 0",
								AnchorMax = "1 1",
								OffsetMin = "4 -4",
								OffsetMax = "104 4",
								IsBold = true, FontSize = 10, Align = TextAnchor.MiddleLeft,
								Color = IColor.CreateWhite()
							}
						},
					},
					KitPanel = new KitsPanelKitUI
					{
						Background = new ImageSettings
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "0 0", OffsetMax = "0 0",
							Color = new IColor("#38393F", 40),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
						ShowName = true,
						KitName = new TextSettings()
						{
							AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "10 -35", OffsetMax = "-10 -5",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 18,
							Color = new IColor("#E2DBD3", 100),
						},
						ShowNumber = true,
						KitNumber = new TextSettings()
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-60 -155", OffsetMax = "60 -35",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 60,
							Color = new IColor("#E2DBD3", 20),
						},
						KitImage = new InterfacePosition
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-60 -155", OffsetMax = "60 -35",
						},
						KitButtonTake = new ButtonSettings
						{
							AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-70 10", OffsetMax = "70 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#D74933", 100),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
						KitButtonTakeWhenShowInfo = new ButtonSettings
						{
							AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-70 10", OffsetMax = "40 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#D74933", 100),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
						KitButtonInfo = new ButtonSettings
						{
							AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "125 10", OffsetMax = "-10 38",
							Align = TextAnchor.MiddleCenter,
							IsBold = true,
							FontSize = 13,
							Color = new IColor("#E2DBD3", 100),
							ButtonColor = new IColor("#F19F39", 60),
							Material = "assets/content/ui/namefontmaterial.mat",
							Sprite = "assets/content/ui/UI.Background.Tile.psd"
						},
					},
					ColorOne = new IColor("#E2DBD3", 100),
					ColorTwo = new IColor("#D74933", 100),
					ColorThree = new IColor("#8B8B8B", 15),
					ColorFour = new IColor("#38393F", 50),
					ColorFive = new IColor("#E2DBD3", 20),
					ColorSix = new IColor("#F19F39", 60),
					ColorSeven = new IColor("#CF432D", 90),
					ColorRed = new IColor("#FF4B4B", 100),
					ColorWhite = new IColor("#FFFFFF", 100),
					ColorBackground = new IColor("#000000", 0),
				};
			}

			#endregion
		}

		private class KitAmountSettings : InterfacePosition
		{
			[JsonProperty(PropertyName = LangRu ? "Ширина" : "Width")]
			public float Width;
		}

		private class NpcKitsData
		{
			[JsonProperty(PropertyName = LangRu ? "Описание" : "Description")]
			public string Description;

			[JsonProperty(PropertyName = LangRu ? "Наборы" : "Kits",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<string> Kits = new();
		}

		#region UI Configuration

		public enum ScrollType
		{
			Horizontal,
			Vertical
		}

		public class ScrollViewUI
		{
			#region Fields

			[JsonProperty(PropertyName = "Scroll Type")] [JsonConverter(typeof(StringEnumConverter))]
			public ScrollType ScrollType;

			[JsonProperty(PropertyName = "Movement Type")] [JsonConverter(typeof(StringEnumConverter))]
			public ScrollRect.MovementType MovementType;

			[JsonProperty(PropertyName = "Elasticity")]
			public float Elasticity;

			[JsonProperty(PropertyName = "Deceleration Rate")]
			public float DecelerationRate;

			[JsonProperty(PropertyName = "Scroll Sensitivity")]
			public float ScrollSensitivity;

			[JsonProperty(PropertyName = "Minimal Height")]
			public float MinHeight;

			[JsonProperty(PropertyName = "Additional Height")]
			public float AdditionalHeight;

			[JsonProperty(PropertyName = "Scrollbar Settings")]
			public ScrollBarSettings Scrollbar = new();

			#endregion

			#region Public Methods

			public CuiScrollViewComponent GetScrollView(float totalWidth)
			{
				return GetScrollView(CalculateContentRectTransform(totalWidth));
			}
			
			public CuiScrollViewComponent GetScrollView(CuiRectTransform contentTransform)
			{
				var cuiScrollView = new CuiScrollViewComponent
				{
					MovementType = MovementType,
					Elasticity = Elasticity,
					DecelerationRate = DecelerationRate,
					ScrollSensitivity = ScrollSensitivity,
					ContentTransform = contentTransform,
					Inertia = true
				};

				switch (ScrollType)
				{
					case ScrollType.Vertical:
					{
						cuiScrollView.Vertical = true;
						cuiScrollView.Horizontal = false;

						cuiScrollView.VerticalScrollbar = Scrollbar.Get();
						break;
					}

					case ScrollType.Horizontal:
					{
						cuiScrollView.Horizontal = true;
						cuiScrollView.Vertical = false;

						cuiScrollView.HorizontalScrollbar = Scrollbar.Get();
						break;
					}
				}

				return cuiScrollView;
			}

			public CuiRectTransform CalculateContentRectTransform(float totalWidth)
			{
				CuiRectTransform contentRect;
				if (ScrollType == ScrollType.Horizontal)
				{
					contentRect = new CuiRectTransform()
					{
						AnchorMin = "0 0", AnchorMax = "0 1",
						OffsetMin = "0 0",
						OffsetMax = $"{totalWidth} 0"
					};
				}
				else
				{
					contentRect = new CuiRectTransform()
					{
						AnchorMin = "0 1", AnchorMax = "1 1",
						OffsetMin = $"0 -{totalWidth}",
						OffsetMax = "0 0"
					};
				}

				return contentRect;
			}
			
			#endregion

			#region Classes

			public class ScrollBarSettings
			{
				#region Fields

				[JsonProperty(PropertyName = "Invert")]
				public bool Invert;

				[JsonProperty(PropertyName = "Auto Hide")]
				public bool AutoHide;

				[JsonProperty(PropertyName = "Handle Sprite")]
				public string HandleSprite = string.Empty;

				[JsonProperty(PropertyName = "Size")] public float Size;

				[JsonProperty(PropertyName = "Handle Color")]
				public IColor HandleColor = IColor.CreateWhite();

				[JsonProperty(PropertyName = "Highlight Color")]
				public IColor HighlightColor = IColor.CreateWhite();

				[JsonProperty(PropertyName = "Pressed Color")]
				public IColor PressedColor = IColor.CreateWhite();

				[JsonProperty(PropertyName = "Track Sprite")]
				public string TrackSprite = string.Empty;

				[JsonProperty(PropertyName = "Track Color")]
				public IColor TrackColor = IColor.CreateWhite();

				#endregion

				#region Public Methods

				public CuiScrollbar Get()
				{
					var cuiScrollbar = new CuiScrollbar()
					{
						Size = Size
					};

					if (Invert) cuiScrollbar.Invert = Invert;
					if (AutoHide) cuiScrollbar.AutoHide = AutoHide;
					if (!string.IsNullOrEmpty(HandleSprite)) cuiScrollbar.HandleSprite = HandleSprite;
					if (!string.IsNullOrEmpty(TrackSprite)) cuiScrollbar.TrackSprite = TrackSprite;

					if (HandleColor != null) cuiScrollbar.HandleColor = HandleColor.Get();
					if (HighlightColor != null) cuiScrollbar.HighlightColor = HighlightColor.Get();
					if (PressedColor != null) cuiScrollbar.PressedColor = PressedColor.Get();
					if (TrackColor != null) cuiScrollbar.TrackColor = TrackColor.Get();
					
					return cuiScrollbar;
				}

				#endregion
			}

			#endregion
		}

		public class CheckBoxSettings
		{
			[JsonProperty(PropertyName = "Background")]
			public ImageSettings Background;

			[JsonProperty(PropertyName = "Checkbox")]
			public ButtonSettings CheckboxButton;

			[JsonProperty(PropertyName = "Checkbox Size")]
			public float CheckboxSize;

			[JsonProperty(PropertyName = "Checkbox Color")]
			public IColor CheckboxColor;

			[JsonProperty(PropertyName = "Title")]
			public TextSettings Title;
		}

		public class ImageSettings : InterfacePosition
		{
			#region Fields
			[JsonProperty(PropertyName = "Sprite")]
			public string Sprite = string.Empty;

			[JsonProperty(PropertyName = "Material")]
			public string Material = string.Empty;

			[JsonProperty(PropertyName = "Image")]
			public string Image = string.Empty;

			[JsonProperty(PropertyName = "Color")]
			public IColor Color = IColor.CreateTransparent();

			[JsonProperty(PropertyName = "Cursor Enabled")]
			public bool CursorEnabled = false;

			[JsonProperty(PropertyName = "Keyboard Enabled")]
			public bool KeyboardEnabled = false;
			#endregion

			#region Private Methods

			[JsonIgnore] private ICuiComponent _imageComponent;
			
			public ICuiComponent GetImageComponent()
			{
				if (_imageComponent != null) return _imageComponent;
				
				if (!string.IsNullOrEmpty(Image))
				{
					var rawImage = new CuiRawImageComponent
					{
						Png = _instance.GetImage(Image),
						Color = Color.Get()
					};

					if (!string.IsNullOrEmpty(Sprite))
						rawImage.Sprite = Sprite;

					if (!string.IsNullOrEmpty(Material))
						rawImage.Material = Material;

					_imageComponent = rawImage;
				}
				else
				{
					var image = new CuiImageComponent
					{
						Color = Color.Get(),
					};

					if (!string.IsNullOrEmpty(Sprite))
						image.Sprite = Sprite;

					if (!string.IsNullOrEmpty(Material))
						image.Material = Material;

					_imageComponent = image;
				}

				return _imageComponent;
			}

			#endregion
			
			#region Public Methods
			
			public bool TryGetImageURL(out string url)
			{
				if (!string.IsNullOrWhiteSpace(Image) && Image.IsURL())
				{
					url = Image;
					return true;
				}

				url = null;
				return false;
			}

			public CuiElement GetImage(string parent,
				string name = null,
				string destroyUI = null)
			{
				if (string.IsNullOrEmpty(name))
					name = CuiHelper.GetGuid();

				var element = new CuiElement
				{
					Name = name,
					Parent = parent,
					DestroyUi = destroyUI,
					Components =
					{
						GetImageComponent(),
						GetRectTransform()
					}
				};

				if (CursorEnabled)
					element.Components.Add(new CuiNeedsCursorComponent());
				
				if (KeyboardEnabled)
					element.Components.Add(new CuiNeedsKeyboardComponent());
				
				return element;
			}

			#endregion

			#region Constructors

			public ImageSettings(){}
			
			public ImageSettings(string imageURL, IColor color, InterfacePosition position) : base(position)
			{
				Image = imageURL;
				Color = color;
			}

			#endregion
		}

		public class ButtonSettings : TextSettings
		{
			#region Fields
			[JsonProperty(PropertyName = "Button Color")]
			public IColor ButtonColor = IColor.CreateWhite();

			[JsonProperty(PropertyName = "Sprite")]
			public string Sprite = string.Empty;

			[JsonProperty(PropertyName = "Material")]
			public string Material = string.Empty;

			[JsonProperty(PropertyName = "Image")]
			public string Image = string.Empty;

			[JsonProperty(PropertyName = "Image Color")]
			public IColor ImageColor = IColor.CreateWhite();

			[JsonProperty(PropertyName = "Use custom image position settings?")]
			public bool UseCustomPositionImage = false;

			[JsonProperty(PropertyName = "Custom image position settings")]
			public InterfacePosition ImagePosition = CreateFullStretch();
			#endregion

			#region Public Methods

			public bool TryGetImageURL(out string url)
			{
				if (!string.IsNullOrWhiteSpace(Image) && Image.IsURL())
				{
					url = Image;
					return true;
				}

				url = null;
				return false;
			}
			
			public List<CuiElement> GetButton(
				string msg,
				string cmd,
				string parent,
				string name = null,
				string destroyUI = null,
				string close = null)
			{
				if (string.IsNullOrEmpty(name))
					name = CuiHelper.GetGuid();

				var list = new List<CuiElement>();

				var btn = new CuiButtonComponent
				{
					Color = ButtonColor.Get()
				};

				if (!string.IsNullOrEmpty(cmd))
					btn.Command = cmd;

				if (!string.IsNullOrEmpty(close))
					btn.Close = close;

				if (!string.IsNullOrEmpty(Sprite))
					btn.Sprite = Sprite;

				if (!string.IsNullOrEmpty(Material))
					btn.Material = Material;

				list.Add(new CuiElement
				{
					Name = name,
					Parent = parent,
					DestroyUi = destroyUI,
					Components =
					{
						btn,
						GetRectTransform()
					}
				});
                
				if (!string.IsNullOrEmpty(Image))
				{
					list.Add(new CuiElement
					{
						Parent = name,
						Components =
						{
							(Image.StartsWith("assets/")
								? new CuiImageComponent {Color = ImageColor.Get(), Sprite = Image}
								: new CuiRawImageComponent {Color = ImageColor.Get(), Png = _instance.GetImage(Image)}),
								
							UseCustomPositionImage && ImagePosition != null ? ImagePosition?.GetRectTransform() : new CuiRectTransformComponent()
						}
					});
				}
				else
				{
					if (!string.IsNullOrEmpty(msg))
						list.Add(new CuiElement
						{
							Parent = name,
							Components =
							{
								GetTextComponent(msg),
								new CuiRectTransformComponent()
							}
						});
				}
                
				return list;
			}

			#endregion
		}

		public class TextSettings : InterfacePosition
		{
			#region Fields
			[JsonProperty(PropertyName = "Font Size")]
			public int FontSize = 12;

			[JsonProperty(PropertyName = "Is Bold?")]
			public bool IsBold = false;

			[JsonProperty(PropertyName = "Align")]
			[JsonConverter(typeof(StringEnumConverter))]
			public TextAnchor Align = TextAnchor.UpperLeft;

			[JsonProperty(PropertyName = "Color")] public IColor Color = IColor.CreateWhite();
			#endregion Fields

			#region Public Methods

			public CuiTextComponent GetTextComponent(string msg)
			{
				return new CuiTextComponent
				{
					Text = msg ?? string.Empty,
					FontSize = FontSize,
					Font = IsBold ? "robotocondensed-bold.ttf" : "robotocondensed-regular.ttf",
					Align = Align,
					Color = Color.Get()
				};
			}

			public CuiElement GetText(string msg,
				string parent,
				string name = null,
				string destroyUI = null)
			{
				if (string.IsNullOrEmpty(name))
					name = CuiHelper.GetGuid();

				return new CuiElement
				{
					Name = name,
					Parent = parent,
					DestroyUi = destroyUI,
					Components =
					{
						GetTextComponent(msg),
						GetRectTransform()
					}
				};
			}

			#endregion
		}

		public class InterfacePosition
		{
			#region Fields

			[JsonProperty(PropertyName = "AnchorMin")]
			public string AnchorMin = "0 0";

			[JsonProperty(PropertyName = "AnchorMax")]
			public string AnchorMax = "1 1";

			[JsonProperty(PropertyName = "OffsetMin")]
			public string OffsetMin = "0 0";

			[JsonProperty(PropertyName = "OffsetMax")]
			public string OffsetMax = "0 0";

			#endregion

			#region Cache

			[JsonIgnore] private CuiRectTransformComponent _position;

			#endregion

			#region Public Methods

			public CuiRectTransformComponent GetRectTransform()
			{
				if (_position != null) return _position;
				
				var rect = new CuiRectTransformComponent();

				if (!string.IsNullOrEmpty(AnchorMin))
					rect.AnchorMin = AnchorMin;

				if (!string.IsNullOrEmpty(AnchorMax))
					rect.AnchorMax = AnchorMax;

				if (!string.IsNullOrEmpty(OffsetMin))
					rect.OffsetMin = OffsetMin;

				if (!string.IsNullOrEmpty(OffsetMax))
					rect.OffsetMax = OffsetMax;

				_position = rect;

				return _position;
			}

			#endregion

			#region Constructors
			
			public InterfacePosition(){}

			public InterfacePosition(InterfacePosition other)
			{
				AnchorMin = other.AnchorMin;
				AnchorMax = other.AnchorMin;
				OffsetMin = other.AnchorMin;
				OffsetMax = other.AnchorMin;
			}
			
			public static InterfacePosition CreatePosition(float aMinX, float aMinY, float aMaxX, float aMaxY,
				float oMinX, float oMinY, float oMaxX, float oMaxY)
			{
				return new InterfacePosition
				{
					AnchorMin = $"{aMinX} {aMinY}",
					AnchorMax = $"{aMaxX} {aMaxY}",
					OffsetMin = $"{oMinX} {oMinY}",
					OffsetMax = $"{oMaxX} {oMaxY}"
				};
			}

			public static InterfacePosition CreatePosition(
				string anchorMin = "0 0",
				string anchorMax = "1 1",
				string offsetMin = "0 0",
				string offsetMax = "0 0")
			{
				return new InterfacePosition
				{
					AnchorMin = anchorMin,
					AnchorMax = anchorMax,
					OffsetMin = offsetMin,
					OffsetMax = offsetMax,
				};
			}

			public static InterfacePosition CreatePosition(CuiRectTransform rectTransform)
			{
				return new InterfacePosition
				{
					AnchorMin = rectTransform.AnchorMin,
					AnchorMax = rectTransform.AnchorMax,
					OffsetMin = rectTransform.OffsetMin,
					OffsetMax = rectTransform.OffsetMax,
				};
			}

			public static InterfacePosition CreateFullStretch()
			{
				return new InterfacePosition
				{
					AnchorMin = "0 0",
					AnchorMax = "1 1",
					OffsetMin = "0 0",
					OffsetMax = "0 0",
				};
			}
            
			public static InterfacePosition CreateCenter()
			{
				return new InterfacePosition
				{
					AnchorMin = "0.5 0.5",
					AnchorMax = "0.5 0.5",
					OffsetMin = "0 0",
					OffsetMax = "0 0",
				};
			}
            
			#endregion Constructors
		}

		private class DescriptionSettings : InterfacePosition
		{
			#region Fields

			[JsonProperty(PropertyName = LangRu ? "Включено" : "Enabled")]
			public bool Enabled;

			[JsonProperty(PropertyName = LangRu ? "Цвет фона" : "Background Color")]
			public IColor Color;

			[JsonProperty(PropertyName = "Font Size")]
			public int FontSize;

			[JsonProperty(PropertyName = "Font")] public string Font;

			[JsonProperty(PropertyName = "Align")] [JsonConverter(typeof(StringEnumConverter))]
			public TextAnchor Align;

			[JsonProperty(PropertyName = "Text Color")]
			public IColor TextColor;

			#endregion

			#region Public Methods

			public void Get(ref CuiElementContainer container, string parent, string name = null,
				string description = null)
			{
				if (!Enabled || string.IsNullOrEmpty(description)) return;

				if (string.IsNullOrEmpty(name))
					name = CuiHelper.GetGuid();

				container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = AnchorMin, AnchorMax = AnchorMax,
						OffsetMin = OffsetMin, OffsetMax = OffsetMax
					},
					Image = {Color = Color.Get()}
				}, parent, name);

				container.Add(new CuiLabel
				{
					RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
					Text =
					{
						Text = $"{description}",
						Align = Align,
						Font = Font,
						FontSize = FontSize,
						Color = TextColor.Get()
					}
				}, name);
			}

			#endregion
		}

		private class MenuDescription : DescriptionSettings
		{
			[JsonProperty(PropertyName = LangRu ? "Описание" : "Description")]
			public string Description;
		}

		public class IColor
		{
			#region Fields

			[JsonProperty(PropertyName = "HEX")] public string HEX;

			[JsonProperty(PropertyName = LangRu ? "Непрозрачность (0 - 100)" : "Opacity (0 - 100)")]
			public float Alpha;

			#endregion

			#region Public Methods

			[JsonIgnore] private string _cachedResult;

			[JsonIgnore] private bool _isCached;

			public string Get()
			{
				if (_isCached)
					return _cachedResult;

				if (string.IsNullOrEmpty(HEX)) HEX = "#FFFFFF";

				var str = HEX.Trim('#');
				if (str.Length != 6)
					throw new Exception(HEX);

				var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
				var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
				var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

				_cachedResult = $"{(double) r / 255} {(double) g / 255} {(double) b / 255} {Alpha / 100}";
				_isCached = true;

				return _cachedResult;
			}

			#endregion

			#region Constructors

			public IColor()
			{
			}

			public IColor(string hex, float alpha = 100)
			{
				HEX = hex;
				Alpha = alpha;
			}

			public static IColor Create(string hex, float alpha = 100)
			{
				return new IColor(hex, alpha);
			}

			public static IColor CreateTransparent()
			{
				return new IColor("#000000", 0);
			}

			public static IColor CreateWhite()
			{
				return new IColor("#FFFFFF", 100);
			}

			public static IColor CreateBlack()
			{
				return new IColor("#000000", 100);
			}
			
			#endregion
		}

		#endregion
		
		private class LogInfo
		{
			[JsonProperty(PropertyName = "To Console")]
			public bool Console;

			[JsonProperty(PropertyName = "To File")]
			public bool File;
		}

		private class RarityColor
		{
			[JsonProperty(PropertyName = LangRu ? "Шанс" : "Chance")]
			public int Chance;

			[JsonProperty(PropertyName = LangRu ? "Цвет" : "Color")]
			public string Color;

			public RarityColor(int chance, string color)
			{
				Chance = chance;
				Color = color;
			}
		}

		protected override void LoadConfig()
		{
            base.LoadConfig();
            try
            {
	            _config = Config.ReadObject<Configuration>();
	            if (_config == null) throw new Exception();

	            if (_config.Version < Version)
		            UpdateConfigValues();

	            SaveConfig();
            }
            catch
            {
	            PrintError("Your configuration file contains an error. Using default configuration values.");
	            LoadDefaultConfig();
            }
		}

		protected override void SaveConfig()
		{
			Config.WriteObject(_config);
		}

		protected override void LoadDefaultConfig()
		{
			_config = new Configuration();
		}

		private void UpdateConfigValues()
		{
			PrintWarning("Config update detected! Updating config values...");

			var baseConfig = new Configuration();

			if (_config.Version != default)
			{
				if (_config.Version < new VersionNumber(1, 0, 25))
					_config.UI.KitSale = baseConfig.UI.KitSale;

				if (_config.Version < new VersionNumber(1, 2, 0)) StartConvertOldData();

				if (_config.Version < new VersionNumber(1, 2, 13))
				{
					_config.UI.ColorOne = new IColor(Config["Color 1"].ToString(), 100);
					_config.UI.ColorTwo = new IColor(Config["Color 2"].ToString(), 100);
					_config.UI.ColorThree = new IColor(Config["Color 3"].ToString(), 100);
					_config.UI.ColorFour = new IColor(Config["Color 4"].ToString(), 100);
					_config.UI.ColorRed = new IColor(Config["Color Red"].ToString(), 100);
					_config.UI.ColorWhite = new IColor(Config["Color White"].ToString(), 100);
				}
			}

			_config.Version = Version;
			PrintWarning("Config update completed!");
		}

		#endregion

		#region Data

		#region Disabled Auto Kits
        
		private List<ulong> _disablesAutoKits = new();

		private void LoadDisabledAutoKits()
		{
			if (!_config.UseChangeAutoKit) return;
			
			try
			{ 
				_disablesAutoKits = Interface.Oxide.DataFileSystem.ReadObject<List<ulong>>($"{Name}/DisabledAutoKits");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			_disablesAutoKits ??= new List<ulong>();
		}

		private void SaveDisabledAutoKits()
		{
			if (!_config.UseChangeAutoKit) return;

			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/DisabledAutoKits", _disablesAutoKits);
		}

		#endregion

		#region Kits
		
		private PluginData _data;

		private void LoadKits()
		{
			try
			{
				_data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>($"{Name}/Kits");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			_data ??= new PluginData();
		}

		private void SaveKits()
		{
			Interface.Oxide.DataFileSystem.WriteObject($"{Name}/Kits", _data);
		}
		
		#region Classes

		private class PluginData
		{
			[JsonProperty(PropertyName = "Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<Kit> Kits = new();
		}

		private class Kit
		{
			#region Fields

			[JsonIgnore] public int ID;

			[JsonProperty(PropertyName = "Name")] public string Name;

			[JsonProperty(PropertyName = "Display Name")]
			public string DisplayName;

			[JsonProperty(PropertyName = "Color")] public string Color;

			[JsonProperty(PropertyName = "Permission")]
			public string Permission;

			[JsonProperty(PropertyName = "Description")]
			public string Description;

			[JsonProperty(PropertyName = "Image")] public string Image;

			[JsonProperty(PropertyName = "Hide")] public bool Hide;

			[JsonProperty(PropertyName = "ShowInfo")] [DefaultValue(true)]
			public bool ShowInfo;

			[JsonProperty(PropertyName = "Amount")]
			public int Amount;

			[JsonProperty(PropertyName = "Cooldown")]
			public double Cooldown;

			[JsonProperty(PropertyName = "Wipe Block")]
			public double CooldownAfterWipe;

			[JsonProperty(PropertyName = "Use Building")]
			public bool UseBuilding;

			[JsonProperty(PropertyName = "Building")]
			public string Building;

			[JsonProperty(PropertyName = "Enable sale")]
			public bool Sale;

			[JsonProperty(PropertyName = "Selling price")]
			public int Price;

			[JsonProperty(PropertyName = "Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<KitItem> Items;

			[JsonProperty(PropertyName = "Use commands on receiving?")]
			public bool UseCommandsOnReceiving;

			[JsonProperty(PropertyName = "Commands on receiving (via '|')",
				ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public string CommandsOnReceiving;

			[JsonProperty(PropertyName = "Use slot for backpack?")]
			public bool UseSlotForBackpack;

			#endregion

			#region Public Methods

			public void Get(BasePlayer player)
			{
				Items?.ForEach(item => item?.Get(player));

				UseCommands(player);
			}

			public void UseCommands(BasePlayer player)
			{
				if (UseCommandsOnReceiving && !string.IsNullOrWhiteSpace(CommandsOnReceiving))
				{
					var command = CommandsOnReceiving.Replace("\n", "|")
						.Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase)
						.Replace("%username%", player.displayName, StringComparison.OrdinalIgnoreCase);

					foreach (var check in command.Split('|'))
						_instance?.Server.Command(check);
				}
			}

			#region Moving

			public void MoveRight()
			{
				var index = _instance._data.Kits.LastIndexOf(this);
				if (index >= 0 && index < _instance._data.Kits.Count - 1) 
					(_instance._data.Kits[index], _instance._data.Kits[index + 1]) = (_instance._data.Kits[index + 1], _instance._data.Kits[index]); // Swap
			}

			public void MoveLeft()
			{
				var index = _instance._data.Kits.LastIndexOf(this);
				if (index > 0 && index < _instance._data.Kits.Count)
					(_instance._data.Kits[index], _instance._data.Kits[index - 1]) =
						(_instance._data.Kits[index - 1], _instance._data.Kits[index]); // Swap
			}

			#endregion
	
			#endregion

			#region Cache

			[JsonIgnore] public Dictionary<int, KitItem> dictMainItems = new();

			[JsonIgnore] public Dictionary<int, KitItem> dictBeltItems = new();

			[JsonIgnore] public Dictionary<int, KitItem> dictWearItems = new();

			[JsonIgnore] public int beltCount;

			[JsonIgnore] public int wearCount;

			[JsonIgnore] public int mainCount;

			public void Update()
			{
				LoadContainers();

				GenerateJObject();
			}

			private void LoadContainers()
			{
				dictWearItems.Clear();
				dictBeltItems.Clear();
				dictMainItems.Clear();

				beltCount = 0;
				wearCount = 0;
				mainCount = 0;

				Items.ForEach(item =>
				{
					switch (item.Container)
					{
						case "wear":
							dictWearItems[item.Position] = item;

							wearCount++;
							break;
						case "belt":
							dictBeltItems[item.Position] = item;

							beltCount++;
							break;
						case "main":
							dictMainItems[item.Position] = item;

							mainCount++;
							break;
					}
				});
			}

			public KitItem GetItemByContainerAndPosition(string container, int position)
			{
				KitItem item;
				switch (container)
				{
					case "wear":
					{
						return dictWearItems.TryGetValue(position, out item) ? item : null;
					}
					case "belt":
					{
						return dictBeltItems.TryGetValue(position, out item) ? item : null;
					}
					default:
					{
						return dictMainItems.TryGetValue(position, out item) ? item : null;
					}
				}
			}

			#endregion

			#region JObject

			[JsonIgnore] private JObject _jObject;

			[JsonIgnore]
			internal JObject ToJObject
			{
				get
				{
					if (_jObject == null) GenerateJObject();

					return _jObject;
				}
			}

			private void GenerateJObject()
			{
				_jObject = new JObject
				{
					["Name"] = DisplayName,
					["Description"] = Description,
					["RequiredPermission"] = Permission,
					["MaximumUses"] = Amount,
					["Cost"] = Price,
					["IsHidden"] = Hide,
					["CopyPasteFile"] = Building,
					["KitImage"] = Image,
					["MainItems"] = new JArray(),
					["WearItems"] = new JArray(),
					["BeltItems"] = new JArray()
				};

				foreach (var kitItem in dictMainItems.Values)
					(_jObject["MainItems"] as JArray)?.Add(kitItem.ToJObject);

				foreach (var kitItem in dictWearItems.Values)
					(_jObject["WearItems"] as JArray)?.Add(kitItem.ToJObject);

				foreach (var kitItem in dictBeltItems.Values)
					(_jObject["BeltItems"] as JArray)?.Add(kitItem.ToJObject);
			}

			#endregion
		}

		private enum KitItemType
		{
			Item,
			Command
		}

		private class KitItem
		{
			[JsonProperty(PropertyName = "Type")] [JsonConverter(typeof(StringEnumConverter))]
			public KitItemType Type;

			[JsonProperty(PropertyName = "Command")]
			public string Command;

			[JsonProperty(PropertyName = "ShortName")]
			public string ShortName;

			[JsonProperty(PropertyName = "DisplayName")]
			public string DisplayName;

			[JsonProperty(PropertyName = "Amount")]
			public int Amount;

			[JsonProperty(PropertyName = "Blueprint")]
			public int Blueprint;

			[JsonProperty(PropertyName = "SkinID")]
			public ulong SkinID;

			[JsonProperty(PropertyName = "Container")]
			public string Container;

			[JsonProperty(PropertyName = "Condition")]
			public float Condition;

			[JsonProperty(PropertyName = "Chance")]
			public int Chance;

			[JsonProperty(PropertyName = "Position", DefaultValueHandling = DefaultValueHandling.Populate)]
			[DefaultValue(-1)]
			public int Position;

			[JsonProperty(PropertyName = "Image")] public string Image = string.Empty;

			[JsonProperty(PropertyName = "Weapon")]
			public Weapon Weapon;

			[JsonProperty(PropertyName = "Content", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public List<ItemContent> Content;

			[JsonProperty(PropertyName = "Text")] public string Text;

			public void Get(BasePlayer player)
			{
				if (Chance < 100 && Random.Range(0, 100) > Chance) return;

				switch (Type)
				{
					case KitItemType.Item:
						GiveItem(player, BuildItem(),
							Container switch
							{
								"belt" => player.inventory.containerBelt,
								"wear" => player.inventory.containerWear,
								_ => player.inventory.containerMain
							});
						break;

					case KitItemType.Command:
						ToCommand(player);
						break;
				}
			}

			private void ToCommand(BasePlayer player)
			{
				var command = Command.Replace("\n", "|")
					.Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace("%username%",
						player.displayName, StringComparison.OrdinalIgnoreCase);

				foreach (var check in command.Split('|')) _instance?.Server.Command(check);
			}

			private static void GiveItem(BasePlayer player, Item item, ItemContainer cont = null)
			{
				if (item == null) return;
				var playerInventory = player.inventory;

				var moved = item.MoveToContainer(cont, item.position) || item.MoveToContainer(cont) ||
				            item.MoveToContainer(playerInventory.containerMain);
				if (!moved)
				{
					if (cont == playerInventory.containerBelt)
						moved = item.MoveToContainer(playerInventory.containerWear);
					if (cont == playerInventory.containerWear)
						moved = item.MoveToContainer(playerInventory.containerBelt);
				}

				if (!moved)
					item.Drop(player.GetCenter(), player.GetDropVelocity());
			}

			[JsonIgnore] private ItemDefinition _itemDefinition;

			[JsonIgnore]
			public ItemDefinition ItemDefinition
			{
				get
				{
					if (_itemDefinition == null) _itemDefinition = ItemManager.FindItemDefinition(ShortName);

					return _itemDefinition;
				}
			}

			public Item BuildItem()
			{
				var item = ItemManager.Create(ItemDefinition, Mathf.Max(Amount, 1), SkinID);
				item.condition = Condition;

				item.position = Position;

				if (Blueprint != 0)
					item.blueprintTarget = Blueprint;

				if (!string.IsNullOrEmpty(DisplayName))
					item.name = DisplayName;

				if (!string.IsNullOrEmpty(Text))
					item.text = Text;

				if (Weapon != null)
				{
					var heldEntity = item.GetHeldEntity();
					if (heldEntity != null)
					{
						heldEntity.skinID = SkinID;

						var baseProjectile = heldEntity as BaseProjectile;
						if (baseProjectile != null && !string.IsNullOrEmpty(Weapon.ammoType))
						{
							baseProjectile.primaryMagazine.contents = Weapon.ammoAmount;
							baseProjectile.primaryMagazine.ammoType =
								ItemManager.FindItemDefinition(Weapon.ammoType);
						}

						heldEntity.SendNetworkUpdate();
					}
				}

				Content?.ForEach(cont =>
				{
					var newCont = ItemManager.CreateByName(cont.ShortName, cont.Amount);
					newCont.condition = cont.Condition;
					newCont.MoveToContainer(item.contents);
				});

				return item;
			}

			public static KitItem FromOld(ItemData item, string container)
			{
				var newItem = new KitItem
				{
					Content =
						item.Contents?.Select(x =>
								new ItemContent {ShortName = x.Shortname, Condition = x.Condition, Amount = x.Amount})
							.ToList() ?? new List<ItemContent>(),
					Weapon = new Weapon {ammoAmount = item.Ammo, ammoType = item.Ammotype},
					Container = container,
					SkinID = item.Skin,
					Command = string.Empty,
					Chance = 100,
					Blueprint = string.IsNullOrEmpty(item.BlueprintShortname) ? 0 : 1,
					Condition = item.Condition,
					Amount = item.Amount,
					ShortName = item.Shortname,
					Type = KitItemType.Item,
					Position = item.Position,
					Image = string.Empty,
				};

				return newItem;
			}

			[JsonIgnore] private int _itemId = -1;

			[JsonIgnore]
			public int itemId
			{
				get
				{
					if (_itemId == -1)
						UpdateItemID();
					return _itemId;
				}
			}

			[JsonIgnore] private ICuiComponent _image;

			public CuiElement GetImage(string aMin, string aMax, string oMin, string oMax, string parent,
				string name = null)
			{
				if (_image == null)
					GenerateNewImage();

				return new CuiElement
				{
					Name = string.IsNullOrEmpty(name) ? CuiHelper.GetGuid() : name,
					Parent = parent,
					Components =
					{
						_image,
						new CuiRectTransformComponent
						{
							AnchorMin = aMin, AnchorMax = aMax,
							OffsetMin = oMin, OffsetMax = oMax
						}
					}
				};
			}

			private void GenerateNewImage()
			{
				if (_instance._enabledImageLibrary && !string.IsNullOrEmpty(Image))
					_image = new CuiRawImageComponent
					{
						Png = _instance.GetImage(Image)
					};
				else
					_image = new CuiImageComponent
					{
						ItemId = itemId,
						SkinId = SkinID
					};
			}

			private void UpdateItemID()
			{
				_itemId = ItemManager.FindItemDefinition(ShortName)?.itemid ?? -1;
			}

			public void Update()
			{
				UpdateItemID();

				GenerateNewImage();

				GenerateJObject();
			}

			#region JObject

			[JsonIgnore] private JObject _jObject;

			[JsonIgnore]
			public JObject ToJObject
			{
				get
				{
					if (_jObject == null) GenerateJObject();

					return _jObject;
				}
			}

			private void GenerateJObject()
			{
				_jObject = new JObject
				{
					["Shortname"] = ShortName,
					["DisplayName"] = DisplayName,
					["SkinID"] = SkinID,
					["Amount"] = Amount,
					["Condition"] = Condition,
					["MaxCondition"] = Condition,
					["IsBlueprint"] = Blueprint != 0,
					["Ammo"] = Weapon?.ammoAmount,
					["AmmoType"] = Weapon?.ammoType,
					["Text"] = Text,
					["Contents"] = new JArray()
				};

				Content?.ForEach(x =>
				{
					(_jObject["Contents"] as JArray)?.Add(new JObject
					{
						["Shortname"] = x.ShortName,
						["DisplayName"] = string.Empty,
						["SkinID"] = 0,
						["Amount"] = x.Amount,
						["Condition"] = x.Condition,
						["MaxCondition"] = x.Condition,
						["IsBlueprint"] = false,
						["Ammo"] = 0,
						["AmmoType"] = string.Empty,
						["Text"] = string.Empty,
						["Contents"] = new JArray()
					});
				});
			}

			#endregion
		}

		private class Weapon
		{
			public string ammoType;

			public int ammoAmount;
		}

		private class ItemContent
		{
			public string ShortName;

			public float Condition;

			public int Amount;
		}

		#endregion
		
		#endregion

		#region Global

		private void LoadData()
		{
			LoadKits();
			
			LoadDisabledAutoKits();
		}

		#endregion

		#endregion

		#region Hooks

		private void Init()
		{
			_instance = this;

			LoadData();

			if (!_config.OnPermissionsUpdate)
			{
				Unsubscribe(nameof(OnUserPermissionGranted));
				Unsubscribe(nameof(OnUserPermissionRevoked));
			}
		}

		private void OnServerInitialized()
		{
			LoadImages();
			
			LoadServerPanel();

			CacheKits();

			FixItemsPositions();

			FillCategories();

			RegisterPermissions();

			RegisterCommands();

			timer.Every(1, UpdatePlayerCooldownsHandler);
		}

		private void Unload()
		{
			if (_wipePlayers != null)
				ServerMgr.Instance.StopCoroutine(_wipePlayers);

			foreach (var player in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(player, Layer);
				CuiHelper.DestroyUi(player, InfoLayer);
				CuiHelper.DestroyUi(player, EditingLayer);
				CuiHelper.DestroyUi(player, ModalLayer);

				PlayerData.SaveAndUnload(player.UserIDString);
			}

			_instance = null;
		}

		#region Wipe

		private void OnNewSave(string filename)
		{
			if (!_config.AutoWipe) return;

			DoWipePlayers();
		}

		#endregion

		#region Server Panel

		private void OnServerPanelCategoryPage(BasePlayer player, int category, int page)
		{
			RemoveOpenedKits(player);
		}

		private void OnServerPanelClosed(BasePlayer player)
		{
			RemoveOpenedKits(player);
		}

		private void OnReceiveCategoryInfo(int categoryID)
		{
			_serverPanelCategory.categoryID = categoryID;
		}
		
		#endregion
		
		private void OnPlayerRespawned(BasePlayer player)
		{
			if (player == null || (_config.UseChangeAutoKit && _disablesAutoKits.Contains(player.userID))) return;

			var kits = GetAutoKits(player);
			if (kits.Count == 0)
				return;

			player.inventory.Strip();

			if (_config.OnceAutoKit)
			{
				var lastKit = kits.LastOrDefault();
				if (lastKit != null) ProcessAutoKit(player, lastKit);
			}
			else
			{
				kits.ForEach(kit => ProcessAutoKit(player, kit));
			}
		}

		private void OnPlayerDisconnected(BasePlayer player)
		{
			RemoveOpenedKits(player);
			_kitEditing.Remove(player.userID);
			_itemEditing.Remove(player.userID);

			PlayerData.SaveAndUnload(player.UserIDString);
		}

		private void OnPlayerDeath(BasePlayer player, HitInfo info)
		{
			if (player == null) return;

			CuiHelper.DestroyUi(player, Layer);

			OnPlayerDisconnected(player);
		}

		private void OnUseNPC(BasePlayer npc, BasePlayer player)
		{
			if (npc == null || player == null || !_config.NpcKits.ContainsKey(npc.UserIDString)) return;

			SetOpenedKits(player, npc.userID);
			
			MainUi(player, first: true);
		}

		#region Image Library

		private void OnPluginLoaded(Plugin plugin)
		{
			switch (plugin.Name)
			{
				case nameof(ImageLibrary):
					timer.In(1, LoadImages);
					break;
				case nameof(ServerPanel):
					timer.In(1, LoadServerPanel);
					break;
			}
		}

		private void OnPluginUnloaded(Plugin plugin)
		{
			switch (plugin.Name)
			{
				case nameof(ImageLibrary):
					_enabledImageLibrary = false;
					break;
				case nameof(ServerPanel):
					_serverPanelCategory.spStatus = false;
					break;
			}
		}

		#endregion

		#region Permissions

		private void OnUserPermissionGranted(string id, string permName)
		{
			UpdateOpenedUI(id, permName);
		}

		private void OnUserPermissionRevoked(string id, string permName)
		{
			UpdateOpenedUI(id, permName);
		}

		#endregion

		#endregion

		#region Commands

		private void CmdOpenKits(IPlayer cov, string command, string[] args)
		{
			var player = cov?.Object as BasePlayer;
			if (player == null) return;

			if (_enabledImageLibrary == false)
			{
				SendNotify(player, NoILError, 1);

				BroadcastILNotInstalled();
				return;
			}

			if (args.Length == 0)
			{
				if (_serverPanelCategory.spStatus &&  _serverPanelCategory.categoryID != -1)
				{
					ServerPanel?.Call("API_OnServerPanelOpenCategoryByID", player, _serverPanelCategory.categoryID);
				}
				else
				{
					TryCreateOpenedKits(player, out _);
				
					MainUi(player, first: true);
				}
				return;
			}

			switch (args[0])
			{
				case "help":
				{
					Reply(player, KitsHelp, command);
					break;
				}

				case "list":
				{
					Reply(player, KitsList,
						string.Join(", ", GetAvailableKitList(player).Select(x => $"'{x.DisplayName}'")));
					break;
				}

				case "remove":
				{
					if (!IsAdmin(player)) return;

					var name = string.Join(" ", args.Skip(1));
					if (string.IsNullOrEmpty(name))
					{
						SendNotify(player, KitNotFound, 1, name);
						return;
					}

					var kit = GetAvailableKitList(player)?.Find(x => x.DisplayName == name);
					if (kit == null)
					{
						SendNotify(player, KitNotFound, 1, name);
						return;
					}
					
					DoRemoveKit(kit);
                    
					SendNotify(player, KitRemoved, 0, name);
					break;
				}

				case "autokit":
				{
					if (!_config.UseChangeAutoKit) return;

					if (!string.IsNullOrEmpty(_config.ChangeAutoKitPermission) &&
					    !cov.HasPermission(_config.ChangeAutoKitPermission))
					{
						ErrorUi(player, Msg(player, NoPermission));
						return;
					}

					bool enabled;
					if (_disablesAutoKits.Contains(player.userID))
					{
						_disablesAutoKits.Remove(player.userID);

						enabled = true;
					}
					else
					{
						_disablesAutoKits.Add(player.userID);

						enabled = false;
					}

					if (enabled)
						SendNotify(player, ChangeAutoKitOn, 0);
					else
						SendNotify(player, ChangeAutoKitOff, 1);

					SaveDisabledAutoKits();
					break;
				}

				default:
				{
					var name = string.Join(" ", args);
					if (string.IsNullOrEmpty(name))
					{
						SendNotify(player, KitNotFound, 1, name);
						return;
					}

					var kit = GetAvailableKitList(player, checkAmount: false)
						.Find(x => string.Equals(x.Name, name, StringComparison.InvariantCultureIgnoreCase) ||
						           string.Equals(x.DisplayName, name, StringComparison.InvariantCultureIgnoreCase));
					if (kit == null)
					{
						SendNotify(player, KitNotFound, 1, name);
						return;
					}

					GiveKitToPlayer(player, kit, chat: true);
					break;
				}
			}
		}

		[ConsoleCommand("UI_Kits")]
		private void CmdKitsConsole(ConsoleSystem.Arg arg)
		{
			var player = arg?.Player();
			if (player == null || !arg.HasArgs()) return;
			
			switch (arg.Args[0])
			{
				case "close":
				{
					RemoveOpenedKits(player);

					StopEditing(player);
					break;
				}

				case "stopedit":
				{
					StopEditing(player);
					break;
				}

				case "main":
				{
					var openedKits = GetOpenedKits(player);
					switch (arg.GetString(1))
					{
						case "page":
						{
							var newPage = arg.GetInt(2);
							openedKits.OnChangeCurrentPage(newPage);
							
							UpdateUI(player, container =>
							{
								MainKitsContentUI(player, container);
							});
							break;
						}

						case "show_all":
						{
							var newShowAll = arg.GetBool(2);
							openedKits.OnChangeShowAll(newShowAll);
							
							UpdateUI(player, container =>
							{
								MainKitsContentUI(player, container);
							});
							break;
						}
					}
					break;
				}

				case "infokit":
				{
					if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out var kitId)) return;

					var kit = FindKitByID(kitId);
					if (kit == null) return;

					StopEditing(player);

					InfoKitUi(player, kit);
					break;
				}

				case "givekit":
				{
					if (!arg.HasArgs(2) ||
					    !int.TryParse(arg.Args[1], out var kitId)) return;
					
					var kit = FindKitByID(kitId);
					if (kit == null) return;

					GiveKitToPlayer(player, kit);
					break;
				}

				case "editkit":
				{
					if (!IsAdmin(player)) return;
					
					if (!arg.HasArgs(2) || !bool.TryParse(arg.Args[1], out var creating)) return;

					var kitId = -1;
					if (arg.HasArgs(3))
						int.TryParse(arg.Args[2], out kitId);

					if (arg.HasArgs(4) && (!arg.HasArgs(5) || string.IsNullOrEmpty(arg.Args[4])))
						return;

					if (arg.HasArgs(5))
					{
						var key = arg.Args[3];
						var value = arg.Args[4];

						if (_kitEditing.ContainsKey(player.userID) && _kitEditing[player.userID].ContainsKey(key))
						{
							object newValue = null;

							switch (key)
							{
								case "UseSlotForBackpack":
								case "UseCommandsOnReceiving":
								case "ShowInfo":
								case "Hide":
								case "AutoKit":
								case "Sale":
								{
									if (value == "delete")
										newValue = default(bool);
									else if (bool.TryParse(value, out var result)) newValue = result;
									break;
								}
								case "Amount":
								case "Price":
								{
									if (value == "delete")
										newValue = default(int);
									else if (int.TryParse(value, out var result))
										newValue = result;
									break;
								}
								case "Cooldown":
								case "CooldownAfterWipe":
								{
									if (value == "delete")
										newValue = default(double);
									else if (double.TryParse(value, out var result))
										newValue = result;
									break;
								}
								case "CommandsOnReceiving":
								case "Description":
								case "DisplayName":
								{
									newValue = value == "delete" ? string.Empty : string.Join(" ", arg.Args.Skip(4));
									break;
								}
								default:
								{
									newValue = value == "delete" ? string.Empty : value;
									break;
								}
							}

							if (_kitEditing[player.userID][key] != null &&
							    _kitEditing[player.userID][key].Equals(newValue))
								return;

							_kitEditing[player.userID][key] = newValue;
						}
					}

					EditingKitUi(player, creating, kitId);
					break;
				}

				case "edit_kit_position":
				{
					if (!IsAdmin(player) || !arg.HasArgs(3)) return;

					var kitID = arg.GetInt(1);
					var moveType = arg.GetString(2);

					var kit = FindKitByID(kitID);
					if (kit == null) return;

					switch (moveType)
					{
						case "right":
							kit.MoveRight();
							break;
						case "left":
							kit.MoveLeft();
							break;
						default:
							PrintError("Unknown move type: {0}", moveType);
							return;
					}

					CacheKits();
					
					SaveKits();
					
					GetOpenedKits(player)?.UpdateKits();

					UpdateUI(player, container =>
					{
						MainKitsContentUI(player, container);
					});
					break;
				}

				case "takeitem":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(6) ||
					    !_itemEditing.ContainsKey(player.userID) ||
					    !int.TryParse(arg.Args[1], out var page) ||
					    !int.TryParse(arg.Args[3], out var kitId) ||
					    !int.TryParse(arg.Args[4], out var slot))
						return;

					var container = arg.Args[2];

					_itemEditing[player.userID]["ShortName"] = arg.Args[5];
					_itemEditing[player.userID]["SkinID"] = 0UL;

					EditingItemUi(player, kitId, slot, container);
					break;
				}

				case "selectitem":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(4) ||
					    !_itemEditing.ContainsKey(player.userID) ||
					    !int.TryParse(arg.Args[2], out var kitId) ||
					    !int.TryParse(arg.Args[3], out var slot))
						return;

					var container = arg.Args[1];

					var selectedCategory = string.Empty;
					if (arg.HasArgs(5))
						selectedCategory = arg.Args[4];

					var page = 0;
					if (arg.HasArgs(6))
						int.TryParse(arg.Args[5], out page);

					var input = string.Empty;
					if (arg.HasArgs(7))
						input = string.Join(" ", arg.Args.Skip(6));

					SelectItem(player, kitId, slot, container, selectedCategory, page, input);
					break;
				}

				case "startedititem":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(4) ||
					    !int.TryParse(arg.Args[2], out var kitId) ||
					    !int.TryParse(arg.Args[3], out var slot)) return;

					var container = arg.Args[1];

					EditingItemUi(player, kitId, slot, container, true);
					break;
				}

				case "edititem":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(6) ||
					    !int.TryParse(arg.Args[2], out var kitId) ||
					    !int.TryParse(arg.Args[3], out var slot)) return;

					var container = arg.Args[1];

					var key = arg.Args[4];
					var value = arg.Args[5];

					if (_itemEditing.ContainsKey(player.userID) && _itemEditing[player.userID].ContainsKey(key))
					{
						object newValue = null;

						switch (key)
						{
							case "Type":
							{
								if (value == "delete")
									newValue = default(KitItemType);
								else if (Enum.TryParse(value, out KitItemType type))
									newValue = type;
								break;
							}
							case "Command":
							{
								newValue = value == "delete" ? string.Empty : string.Join(" ", arg.Args.Skip(5));
								break;
							}
							case "DisplayName":
							{
								newValue = value == "delete" ? string.Empty : string.Join(" ", arg.Args.Skip(5));
								break;
							}
							case "ShortName":
							{
								if (value == "delete")
								{
									newValue = string.Empty;
								}
								else
								{
									newValue = value;
									_itemEditing[player.userID]["SkinID"] = 0UL;
								}

								break;
							}
							case "SkinID":
							{
								if (value == "delete")
									newValue = default(ulong);
								else if (ulong.TryParse(value, out var result))
									newValue = result;
								break;
							}
							case "Amount":
							case "Blueprint":
							case "Chance":
							{
								if (value == "delete")
									newValue = default(int);
								else if (int.TryParse(value, out var result))
									newValue = result;
								break;
							}
						}

						if (_itemEditing[player.userID][key]?.Equals(newValue) == true)
							return;

						_itemEditing[player.userID][key] = newValue;
					}

					EditingItemUi(player, kitId, slot, container);
					break;
				}

				case "saveitem":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(4) ||
					    !int.TryParse(arg.Args[1], out var kitId) ||
					    !int.TryParse(arg.Args[2], out var slot)) return;

					var container = arg.Args[3];
					if (string.IsNullOrEmpty(container)) return;

					var editing = _itemEditing[player.userID];
					if (editing == null) return;

					var kit = FindKitByID(kitId);
					if (kit == null) return;

					var item = kit.GetItemByContainerAndPosition(container, slot);
					var hasItem = item != null;
					var newItem = item == null || editing["ShortName"].ToString() != item.ShortName;

					item ??= new KitItem();

					item.Type = (KitItemType) editing["Type"];
					item.Command = editing["Command"].ToString();
					item.Container = editing["Container"].ToString();
					item.ShortName = editing["ShortName"].ToString();
					item.DisplayName = editing["DisplayName"].ToString();
					item.Amount = (int) editing["Amount"];
					item.Blueprint = (int) editing["Blueprint"];
					item.Chance = (int) editing["Chance"];
					item.SkinID = (ulong) editing["SkinID"];
					item.Position = (int) editing["Position"];

					if (newItem)
					{
						var info = ItemManager.FindItemDefinition(item.ShortName);
						if (info != null) 
							item.Condition = info.condition.max;
					}

					if (!hasItem) kit.Items.Add(item);

					item.Update();

					kit.Update();

					StopEditing(player);

					SaveKits();

					InfoKitUi(player, kit);
					break;
				}

				case "removeitem":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(4) ||
					    !int.TryParse(arg.Args[1], out var kitId) ||
					    !int.TryParse(arg.Args[2], out var slot)) return;

					var editing = _itemEditing[player.userID];
					if (editing == null) return;

					var kit = FindKitByID(kitId);
					if (kit == null) return;

					var item = kit.GetItemByContainerAndPosition(arg.Args[3], slot);
					if (item != null)
						kit.Items.Remove(item);

					kit.Update();

					StopEditing(player);

					SaveKits();

					InfoKitUi(player, kit);
					break;
				}

				case "savekit":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(3) ||
					    !bool.TryParse(arg.Args[1], out var creating) ||
					    !int.TryParse(arg.Args[2], out var kitId)) return;

					var editing = _kitEditing[player.userID];
					if (editing == null) return;

					Kit kit;
					if (creating)
					{
						kit = new Kit
						{
							ID = ++_lastKitID,
							Name = Convert.ToString(editing["Name"]),
							DisplayName = Convert.ToString(editing["DisplayName"]),
							Description = Convert.ToString(editing["Description"]),
							Color = Convert.ToString(editing["Color"]),
							Permission = Convert.ToString(editing["Permission"]),
							Image = Convert.ToString(editing["Image"]),
							Hide = Convert.ToBoolean(editing["Hide"]),
							ShowInfo = Convert.ToBoolean(editing["ShowInfo"]),
							Amount = Convert.ToInt32(editing["Amount"]),
							Cooldown = Convert.ToDouble(editing["Cooldown"]),
							CooldownAfterWipe = Convert.ToDouble(editing["CooldownAfterWipe"]),
							Sale = Convert.ToBoolean(editing["Sale"]),
							Price = Convert.ToInt32(editing["Price"]),
							Items = new List<KitItem>(),
							UseCommandsOnReceiving = Convert.ToBoolean(editing["UseCommandsOnReceiving"]),
							CommandsOnReceiving = Convert.ToString(editing["CommandsOnReceiving"]),
							UseSlotForBackpack = Convert.ToBoolean(editing["UseSlotForBackpack"])
						};

						_data.Kits.Add(kit);

						var kitIndex = _data.Kits.IndexOf(kit);

						_kitByName[kit.Name] = kitIndex;
						_kitByID[kit.ID] = kitIndex;
					}
					else
					{
						kit = FindKitByID(kitId);
						if (kit == null) return;

						var oldName = kit.Name;

						kit.Name = Convert.ToString(editing["Name"]);
						kit.DisplayName = Convert.ToString(editing["DisplayName"]);
						kit.Description = Convert.ToString(editing["Description"]);
						kit.Color = Convert.ToString(editing["Color"]);
						kit.Permission = Convert.ToString(editing["Permission"]);
						kit.Image = Convert.ToString(editing["Image"]);
						kit.Hide = Convert.ToBoolean(editing["Hide"]);
						kit.ShowInfo = Convert.ToBoolean(editing["ShowInfo"]);
						kit.Amount = Convert.ToInt32(editing["Amount"]);
						kit.Cooldown = Convert.ToDouble(editing["Cooldown"]);
						kit.CooldownAfterWipe = Convert.ToDouble(editing["CooldownAfterWipe"]);
						kit.Sale = Convert.ToBoolean(editing["Sale"]);
						kit.Price = Convert.ToInt32(editing["Price"]);
						kit.UseCommandsOnReceiving = Convert.ToBoolean(editing["UseCommandsOnReceiving"]);
						kit.CommandsOnReceiving = Convert.ToString(editing["CommandsOnReceiving"]);
						kit.UseSlotForBackpack = Convert.ToBoolean(editing["UseSlotForBackpack"]);

						if (oldName != kit.Name)
						{
							_kitByName.Remove(oldName);

							_kitByName[kit.Name] = _data.Kits.IndexOf(kit);
						}
					}

					var autoKit = Convert.ToBoolean(editing["AutoKit"]);
					if (autoKit)
					{
						if (!_config.AutoKits.Contains(kit.Name))
						{
							_config.AutoKits.Add(kit.Name);
							SaveConfig();
						}
					}
					else
					{
						_config.AutoKits.Remove(kit.Name);
						SaveConfig();
					}

					StopEditing(player);

					var perm = kit.Permission.ToLower();
					if (!string.IsNullOrEmpty(perm) && !permission.PermissionExists(perm))
						permission.RegisterPermission(perm, this);

					if (!string.IsNullOrEmpty(kit.Image))
						ImageLibrary?.Call("AddImage", kit.Image, kit.Image);

					SaveKits();
					
					GetOpenedKits(player)?.UpdateKits();

					UpdateUI(player, container =>
					{
						MainKitsContentUI(player, container);
					});
					break;
				}

				case "removekit":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(2) ||
					    !int.TryParse(arg.Args[1], out var kitId)) return;

					var kit = FindKitByID(kitId);
					if (kit == null) return;

					DoRemoveKit(kit);
					
					UpdateUI(player, container =>
					{
						MainKitsContentUI(player, container);
					});
					break;
				}

				case "frominv":
				{
					if (!IsAdmin(player)) return;

					if (!arg.HasArgs(2) ||
					    !int.TryParse(arg.Args[1], out var kitId)) return;

					var kit = FindKitByID(kitId);
					if (kit == null) return;

					var kitItems = GetPlayerItems(player);
					if (kitItems == null) return;

					kit.Items = kitItems;

					kit.Update();

					SaveKits();

					InfoKitUi(player, kit);
					break;
				}
			}
		}

		[ConsoleCommand("kits.reset")]
		private void CmdKitsReset(ConsoleSystem.Arg arg)
		{
			if (!(arg.IsServerside || arg.IsAdmin)) return;

			switch (arg.GetString(0))
			{
				case "data":
				{
					var targetID = arg.GetString(1);
					if (string.IsNullOrEmpty(targetID))
					{
						SendReply(arg, "Error syntax! Use: /kits.reset data [<targetID>/all]");
						return;
					}
					
					switch (targetID)
					{
						case "all":
						{
							SendReply(arg, "Resetting all players data...");
							
							DoWipePlayers(count => SendReply(arg, $"{count} players data successfully reset!"));
							break;
						}

						default:
						{
							var targetPlayer = covalence.Players.FindPlayerById(targetID);
							if (targetPlayer == null)
							{
								SendReply(arg, "Player not found!");
								return;
							}
							
							PlayerData.DoWipe(targetID, isWipe: false);
							
							SendReply(arg, $"The data of the player with SteamID {targetID} has been successfully reset!");
							break;
						}
					}
					
					break;
				}

				case "kits":
				{
					_data.Kits.Clear();

					SaveKits();

					SendReply(arg, "You successfully reset all kits!");
					break;
				}

				default:
				{
					SendReply(arg, "Error syntax! Use: /kits.reset [data/kits]");
					break;
				}
			}
		}

		[ConsoleCommand("kits.give")]
		private void CmdKitsGive(ConsoleSystem.Arg arg)
		{
			if (!(arg.IsServerside || arg.IsAdmin)) return;

			if (!arg.HasArgs(2))
			{
				SendReply(arg, $"Error syntax! Use: {arg.cmd.FullName} [name/steamid] [kitname]");
				return;
			}

			var nameOrSteamID = arg.Args[0];
			var target = BasePlayer.Find(nameOrSteamID);
			if (target == null && !nameOrSteamID.IsSteamId())
			{
				SendReply(arg, $"Player '{nameOrSteamID}' not found!");
				return;
			}

			var kitName = arg.Args[1];
			var kit = FindKitByName(kitName);
			if (kit == null)
			{
				SendReply(arg, $"Kit '{kitName}' not found!");
				return;
			}

			kit.Items.ForEach(item => item.Get(target));

			SendReply(arg, $"Player '{nameOrSteamID}' successfully received a kit '{kitName}'");

			Interface.CallHook("OnKitRedeemed", target, kit.Name);
			
			PlayerData.Save(target.UserIDString);

			Log(target, kit.Name);
		}

		[ConsoleCommand("kits.givekit")]
		private void CmdKitsGiveKit(ConsoleSystem.Arg arg)
		{
			if (!(arg.IsServerside || arg.IsAdmin)) return;

			if (!arg.HasArgs(2))
			{
				SendReply(arg, $"Error syntax! Use: {arg.cmd.FullName} [name/steamid] [kitname] [amount]");
				return;
			}

			var steamIdOrName = arg.Args[0];

			var target = BasePlayer.FindAwakeOrSleeping(steamIdOrName);
			if (target == null && !steamIdOrName.IsSteamId())
			{
				SendReply(arg, $"Player '{steamIdOrName}' not found!");
				return;
			}

			var kit = FindKitByName(arg.Args[1]);
			if (kit == null)
			{
				SendReply(arg, $"Kit '{arg.Args[1]}' not found!");
				return;
			}

			var amount = 1;
			if (arg.HasArgs(3))
				int.TryParse(arg.Args[2], out amount);

			var playerData = PlayerData.GetOrCreateKitData(steamIdOrName, kit.Name);
			if (playerData == null) return;

			playerData.HasAmount += amount;

			SendReply(arg, $"Player '{steamIdOrName}' successfully received a kit '{arg.Args[1]}' ({amount} pcs)");

			Log(target, kit.Name);
		}

		[ConsoleCommand("kits.template")]
		private void CmdKitsSetTemplate(ConsoleSystem.Arg arg)
		{
			if (!arg.IsServerside) return;
			
			var format = arg.GetString(0);
			var style = arg.GetString(1);
			
			if (!arg.HasArgs(2) || format != "fullscreen" && format!= "inmenu" || style!= "old_style" && style!= "new_rust")
			{
				SendReply(arg, $"Error syntax! Use: {arg.cmd.FullName} [fullscreen/inmenu] [old_style/new_rust] [target_template]");
				return;
			}

			UserInterface targetTemplate = null;
			switch (format)
			{
				case "fullscreen":
					switch (style)
					{
						case "old_style":
						{
							targetTemplate = UserInterface.GenerateFullscreenTemplateOldStyle();
							break;
						}
					
						case "new_rust":
						{
							targetTemplate = UserInterface.GenerateFullscreenTemplateRust();
							break;
						}
					}

					break;
				case "inmenu":
					switch (style)
					{
						case "old_style":
						{
							SendReply(arg, "Unfortunately this is not working yet");
							return;
						}
					
						case "new_rust":
						{
							switch (arg.GetString(2))
							{
								case "1":
								{
									targetTemplate = UserInterface.GenerateMenuTemplateRustV1();
									break;
								}

								case "2":
								{
									targetTemplate = UserInterface.GenerateMenuTemplateRustV2();
									break;
								}

								default:
								{
									SendReply(arg, $"Error syntax! Use: {arg.cmd.FullName} [fullscreen/inmenu] [old_style/new_rust] [1/2]");
									return;
								}
							}
							break;
						}
					}

					break;
				default:
				{
					SendReply(arg, $"Error syntax! Use: {arg.cmd.FullName} [fullscreen/inmenu] [old_style/new_rust]");
					return;
				}
			}

			if (targetTemplate == null)
			{
				SendReply(arg, $"Error syntax! Use: {arg.cmd.FullName} [fullscreen/inmenu] [old_style/new_rust]");
				return;
			}

			if (format == "fullscreen")
				_config.UI = targetTemplate;
			else
				_config.MenuUI = targetTemplate;
			
			SaveConfig();

			SendReply(arg, $"'{format}'  UI successfully set to '{style}'!");
		}

		#endregion

		#region Interface

		#region Main UI

		private const ulong DEFAULT_MAIN_TARGET_ID = 0;
		private const int DEFAULT_MAIN_PAGE = 0;
		private const bool DEFAULT_MAIN_SHOW_ALL = false;

		private void MainUi(BasePlayer player,
			bool first = false)
		{
			var container = new CuiElementContainer();

			#region Background

			if (first) MainKitsBackground(player, container);

			#endregion

			#region Main

			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0 0", AnchorMax = "1 1"
				},
				Image =
				{
					Color = "0 0 0 0"
				}
			}, Layer + ".Background", Layer + ".Main", Layer + ".Main");

			MainKitsHeader(player, container);

			MainKitsContentUI(player, container);
			
			MainKitsDescriptionUI(player, ref container);

			#endregion

			CuiHelper.AddUi(player, container);
		}

		private void MainKitsDescriptionUI(BasePlayer player, ref CuiElementContainer container)
		{
			var openedKits = GetOpenedKits(player);
			var targetUI = openedKits.useMainUI ? _config.UI : _config.MenuUI;
			
			var description = openedKits.npcID == 0
				? _config.Description.Description
				: _config.NpcKits.TryGetValue(openedKits.npcID.ToString(), out var npcKit)
					? npcKit.Description
					: string.Empty;

			switch (targetUI.Style)
			{
				default:
				{
					_config.Description.Get(ref container, Layer + ".Main", null, description);
					break;
				}
			}
		}

		private void MainKitsContentUI(BasePlayer player,
			CuiElementContainer container)
		{
			var openedKits = GetOpenedKits(player);
			var targetUI = openedKits.useMainUI ? _config.UI : _config.MenuUI;

			container.Add(
				targetUI.ContentPanel.Background.GetImage(Layer + ".Main", Layer + ".Content", Layer + ".Content"));

			#region Buttons

			container.AddRange(
				targetUI.ContentPanel.ButtonBack.GetButton("<", openedKits.currentPage != 0
						? $"UI_Kits main page {openedKits.currentPage - 1}"
						: "", 
					Layer + ".Content"));
			
			container.AddRange(
				targetUI.ContentPanel.ButtonNext.GetButton(">", openedKits.availableKits.Count >
				                                                (openedKits.currentPage + 1) * openedKits.GetTotalKitsAmount()
						? $"UI_Kits main page {openedKits.currentPage + 1}"
						: "", 
					Layer + ".Content"));
			
			if (IsAdmin(player))
			{
				#region Check Show All

				container.Add(targetUI.ContentPanel.CheckboxShowAllKits.Background.GetImage(Layer + ".Content", Layer + ".Content" + ".Admin.Show.All", Layer + ".Content" + ".Admin.Show.All"));
				
				container.AddRange(targetUI.ContentPanel.CheckboxShowAllKits.CheckboxButton.GetButton(openedKits.showAll ? "✔" : string.Empty, $"UI_Kits main show_all {!openedKits.showAll}", Layer + ".Content" + ".Admin.Show.All", Layer + ".Content" + ".Admin.Show.All.Check", Layer + ".Content" + ".Admin.Show.All.Check"));
				
				CreateOutLine(ref container, Layer + ".Content" + ".Admin.Show.All.Check", targetUI.ContentPanel.CheckboxShowAllKits.CheckboxColor.Get(), targetUI.ContentPanel.CheckboxShowAllKits.CheckboxSize);

				container.Add(targetUI.ContentPanel.CheckboxShowAllKits.Title.GetText(Msg(player, ShowAll),Layer + ".Content" + ".Admin.Show.All.Check"));
				
				#endregion Check Show All

				container.AddRange(
					targetUI.ContentPanel.ButtonCreateKit.GetButton(Msg(player, CreateKit), "UI_Kits editkit True", Layer + ".Content"));
			}

			#endregion
			
			#region No Items

			if (openedKits.availableKits.Count == 0)
				switch (targetUI.Style)
				{
					case InterfaceStyle.NewRust:
					{
						container.Add(new CuiLabel
						{
							RectTransform =
							{
								AnchorMin = "0 0", AnchorMax = "1 1",
								OffsetMin = "0 25", OffsetMax = "0 -85"
							},
							Text =
							{
								Text = Msg(player, NotAvailableKits),
								Align = TextAnchor.MiddleCenter,
								Font = "robotocondensed-bold.ttf",
								FontSize = 20,
								Color = "1 1 1 0.45"
							}
						}, Layer + ".Content");
						return;
					}

					default:
					{
						container.Add(new CuiLabel
						{
							RectTransform =
							{
								AnchorMin = "0 0", AnchorMax = "1 1",
								OffsetMin = "0 25", OffsetMax = "0 -85"
							},
							Text =
							{
								Text = Msg(player, NotAvailableKits),
								Align = TextAnchor.MiddleCenter,
								Font = "robotocondensed-bold.ttf",
								FontSize = 20,
								Color = "1 1 1 0.45"
							}
						}, Layer + ".Content");
						return;
					}
				}

			#endregion No Items

			#region Kit List

			var totalAmount = openedKits.GetTotalKitsAmount();

			var isAdmin = IsAdmin(player);

			ShowGridUI(container, 0,
				openedKits.kitsToUpdate.Count,
				targetUI.KitsOnString,
				targetUI.Margin,
				targetUI.Margin,
				targetUI.KitWidth,
				targetUI.KitHeight,
				targetUI.LeftIndent,
				targetUI.YIndent,
				0, 0, 1, 1, "0 0 0 0", Layer + ".Content",
				index => Layer + $".Kit.{openedKits.kitsToUpdate[index].ID}.Main",
				index => Layer + $".Kit.{openedKits.kitsToUpdate[index].ID}.Main",
				index => KitUI(player, container, openedKits.kitsToUpdate[index], openedKits.currentPage, totalAmount,
					index, isAdmin, openedKits.showAll));

			#endregion Kit List
		}

		private void KitUI(BasePlayer player,
			CuiElementContainer container,
			Kit kit,
			int currentPage,
			int totalAmount,
			int kitIndex,
			bool isAdmin,
			bool kitsShowAll)
		{
			var openedKits = GetOpenedKits(player);
			var targetUI = openedKits.useMainUI ? _config.UI : _config.MenuUI;

			container.Add(targetUI.KitPanel.Background.GetImage(Layer + $".Kit.{kit.ID}.Main", 
				Layer + $".Kit.{kit.ID}.Main.Background",
				Layer + $".Kit.{kit.ID}.Main.Background"));

			#region Number

			if (targetUI.KitPanel.ShowNumber)
			{
				var number = currentPage * totalAmount + kitIndex + 1;

				container.Add(targetUI.KitPanel.KitNumber.GetText($"#{number}", Layer + $".Kit.{kit.ID}.Main.Background"));
			}

			#endregion
			
			#region Image

			if (_enabledImageLibrary && !string.IsNullOrEmpty(kit.Image))
				container.Add(new CuiElement
				{
					Parent = Layer + $".Kit.{kit.ID}.Main.Background",
					Components =
					{
						new CuiRawImageComponent {Png = GetImage(kit.Image)},
						new CuiRectTransformComponent
						{
							AnchorMin = targetUI.KitPanel.KitImage.AnchorMin,
							AnchorMax = targetUI.KitPanel.KitImage.AnchorMax,
							OffsetMin = targetUI.KitPanel.KitImage.OffsetMin,
							OffsetMax = targetUI.KitPanel.KitImage.OffsetMax
						}
					}
				});

			#endregion
			
			#region Line
			
			if (targetUI.KitPanel.ShowLine)
				container.Add(new CuiPanel
					{
						RectTransform =
						{
							AnchorMin = targetUI.KitPanel.KitLine.AnchorMin,
							AnchorMax = targetUI.KitPanel.KitLine.AnchorMax,
							OffsetMin = targetUI.KitPanel.KitLine.OffsetMin,
							OffsetMax = targetUI.KitPanel.KitLine.OffsetMax
						},
						Image = {Color = HexToCuiColor(kit.Color)}
					}, Layer + $".Kit.{kit.ID}.Main.Background");

			#endregion

			#region Name

			if (targetUI.KitPanel.ShowName) container.Add(targetUI.KitPanel.KitName.GetText(kit.DisplayName ?? string.Empty, Layer + $".Kit.{kit.ID}.Main.Background"));

			#endregion
			
			#region Button.Take

			container.AddRange(
				(isAdmin && kitsShowAll || kit.ShowInfo
					? targetUI.KitPanel.KitButtonTakeWhenShowInfo
					: targetUI.KitPanel.KitButtonTake).GetButton(Msg(player, KitTake), $"UI_Kits givekit {kit.ID}",
					Layer + $".Kit.{kit.ID}.Main.Background"));
			
			#endregion
			
			#region Button.Info

			if (isAdmin && kitsShowAll || kit.ShowInfo)
				container.AddRange(targetUI.KitPanel.KitButtonInfo.
					GetButton( Msg(player, KitInfo), $"UI_Kits infokit {kit.ID}",
						Layer + $".Kit.{kit.ID}.Main.Background"));
			
			#endregion

			#region Move Buttons

			if (isAdmin && kitsShowAll)
			{
				AddMoveButton(container, Layer + $".Kit.{kit.ID}.Main.Background", "left", -20,
					$"UI_Kits edit_kit_position {kit.ID} left");

				AddMoveButton(container, Layer + $".Kit.{kit.ID}.Main.Background", "right", -2,
					$"UI_Kits edit_kit_position {kit.ID} right");
			}

			#endregion

			RefreshKitUi(ref container, player, kit);
		}

		private void MainKitsHeader(BasePlayer player, CuiElementContainer container)
		{
			var openedKits = GetOpenedKits(player);
			var targetUI = openedKits.useMainUI ? _config.UI : _config.MenuUI;

			container.Add(targetUI.HeaderPanel.Background.GetImage(Layer + ".Main", Layer + ".Header", Layer + ".Header"));
			container.Add(targetUI.HeaderPanel.Title.GetText(Msg(player, MainTitle),  Layer + ".Header"));
			
			if (targetUI.HeaderPanel.ShowLine) container.Add(targetUI.HeaderPanel.Line.GetImage(Layer + ".Header"));
			
			if (openedKits.useMainUI)
				container.AddRange(targetUI.HeaderPanel.ButtonClose.GetButton(Msg(player, Close), "UI_Kits close", Layer + ".Header", close: Layer));
		}

		private void MainKitsBackground(BasePlayer player, CuiElementContainer container)
		{
			var openedKits = GetOpenedKits(player);
			var targetUI = openedKits.useMainUI ? _config.UI : _config.MenuUI;

			container.Add(new CuiPanel
			{
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
				Image =
				{
					Color = "0 0 0 0.9",
					Material = "assets/content/ui/uibackgroundblur.mat"
				},
				CursorEnabled = true
			}, "Overlay", Layer, Layer);

			container.Add(new CuiButton
			{
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
				Text = {Text = ""},
				Button =
				{
					Color = "0 0 0 0",
					Close = Layer,
					Command = "UI_Kits close"
				}
			}, Layer);
			
			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
					OffsetMin = $"-{_config.UI.Width / 2f} -{_config.UI.Height / 2f}",
					OffsetMax = $"{_config.UI.Width / 2f} {_config.UI.Height / 2f}"
				},
				Image =
				{
					Color = targetUI.ColorBackground.Get()
				}
			}, Layer, Layer + ".Background", Layer + ".Background");
		}
		
		#endregion

		#region Kit Info UI

		private void InfoKitUi(BasePlayer player, Kit kit)
		{
			var openedKits = GetOpenedKits(player);
			var targetUI = openedKits.useMainUI ? _config.UI : _config.MenuUI;

			var container = new CuiElementContainer();

			switch (targetUI.Style)
			{
				case InterfaceStyle.NewRust:
				{
					#region Fields
					
					var Size = 70f;
					var Margin = 10f;

					var amountOnString = 6;

					#endregion
					
					#region Background

					container.Add(new CuiPanel
					{
						RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
						Image =
						{
							Color = HexToCuiColor("#000000", 90),
							Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",
						},
						CursorEnabled = true
					}, "Overlay", InfoLayer, InfoLayer);

					#endregion

					#region Header

					container.Add(new CuiElement
					{
						Parent = InfoLayer,
						Components = {
							new CuiTextComponent
							{
								Text = Msg(player, UI_MeventRust_InfoKit_Title), 
								Font = "robotocondensed-bold.ttf",
								FontSize = 24,
								Align = TextAnchor.MiddleLeft, 
								Color = HexToCuiColor("#E8DDD5")
							},
							new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-250 225", OffsetMax = "220 265" }
						}
					});

					if (IsAdmin(player))
					{
						container.Add(new CuiButton()
						{
							Text = { Text = Msg(player, Edit), Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = HexToCuiColor("#71B8ED") },
							Button =
							{
								Command = $"UI_Kits editkit {false} {kit.ID}",
								Color = HexToCuiColor("#71B8ED", 10), 
								Material = "assets/content/ui/namefontmaterial.mat",
								Sprite = "assets/content/ui/UI.Background.Tile.psd"
							},
							RectTransform ={ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "70 230", OffsetMax = "185 260" }
						},InfoLayer);
					}

					#region Button.Close
					
					var buttonClose = container.Add(new CuiButton()
					{
						Text = { Text = string.Empty },
						Button =
						{
							Color = targetUI.ColorTwo.Get(), 
							Material = "assets/content/ui/namefontmaterial.mat",
							Command = "UI_Kits stopedit",
							Close = InfoLayer
						},
						RectTransform ={ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "190 230", OffsetMax = "220 260" }
					},InfoLayer);
					
					#region Button.Close Icon
					container.Add(new CuiElement
					{
						Parent = buttonClose,
						Components = {
							new CuiImageComponent { Color = targetUI.ColorOne.Get(), Sprite = "assets/icons/close.png" },
							new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-8 -8", OffsetMax = "8 8" }
						}
					});

					#endregion Button.Close Icon
					
					#endregion Button.Close
					
					#endregion

					#region Items

					#region Main Container

					var itemContainer = "main";
					
					container.Add(new CuiPanel
						{
							Image = {Color = "0 0 0 0"},
							RectTransform =
							{
								AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-250 -85", OffsetMax = "220 225"
							}
						}, InfoLayer, InfoLayer + $".Container.{itemContainer}.Section", InfoLayer + $".Container.{itemContainer}.Section");

					ShowGridUI(container, 0,
						amountOnString * 4,
						amountOnString,
						Margin,
						Margin,
						Size,
						Size,
						0,
						0,
						0, 0, 1, 1, "0 0 0 0", InfoLayer + $".Container.{itemContainer}.Section",
						slot => InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}",
						slot => InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}",
						slot => InfoKitItemUI(player, kit, container, slot, itemContainer));

					#endregion

					#region Wear Container

					itemContainer = "wear";
					amountOnString = 7;
					
					container.Add(new CuiPanel
						{
							Image = {Color = "0 0 0 0"},
							RectTransform =
							{
								AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-275 -175", OffsetMax = "275 -105"
							}
						}, InfoLayer, InfoLayer + $".Container.{itemContainer}.Section", InfoLayer + $".Container.{itemContainer}.Section");

					ShowGridUI(container, 
						0,
						amountOnString,
						amountOnString,
						Margin,
						Margin,
						Size,
						Size,
						0f,
						0,
						0, 0, 1, 1, "0 0 0 0", 
						InfoLayer + $".Container.{itemContainer}.Section",
						slot => InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}",
						slot => InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}",
						slot => InfoKitItemUI(player, kit, container, slot, itemContainer));

					#endregion
					
					#region Belt Container

					itemContainer = "belt";
					amountOnString = 6;
					
					container.Add(new CuiPanel
						{
							Image = {Color = "0 0 0 0"},
							RectTransform =
							{
								AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-235 -265", OffsetMax = "235 -195"
							}
						}, InfoLayer, InfoLayer + $".Container.{itemContainer}.Section", InfoLayer + $".Container.{itemContainer}.Section");

					ShowGridUI(container, 0,
						amountOnString,
						amountOnString,
						Margin,
						Margin,
						Size,
						Size,
						0f,
						0,
						0, 0, 1, 1, "0 0 0 0", InfoLayer + $".Container.{itemContainer}.Section",
						slot => InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}",
						slot => InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}",
						slot => InfoKitItemUI(player, kit, container, slot, itemContainer));

					#endregion

					#endregion
					break;
				}

				default:
				{
					#region Fields

					var Size = 70f;
					var Margin = 5f;

					var ySwitch = -125f;
					var amountOnString = 6;
					var constSwitch = -(amountOnString * Size + (amountOnString - 1) * Margin) / 2f;

					var total = 0;

					#endregion

					#region Background

					container.Add(new CuiPanel
					{
						RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
						Image =
						{
							Color = targetUI.ColorFive.Get(),
							Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",

						}
					}, "Overlay", InfoLayer, InfoLayer);

					#endregion

					#region Header

					container.Add(new CuiButton
					{
						RectTransform =
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1",
							OffsetMin = "112.5 -140", OffsetMax = "222.5 -115"
						},
						Text =
						{
							Text = Msg(player, ComeBack),
							Align = TextAnchor.MiddleCenter,
							Font = "robotocondensed-regular.ttf",
							FontSize = 10,
							Color = "1 1 1 1"
						},
						Button =
						{
							Color = targetUI.ColorThree.Get(),
							Command = "UI_Kits stopedit",
							Close = InfoLayer
						}
					}, InfoLayer);

					#region Change Button

					if (IsAdmin(player))
					{
						container.Add(new CuiPanel
						{
							RectTransform =
							{
								AnchorMin = "0.5 1", AnchorMax = "0.5 1",
								OffsetMin = "-12.5 -140", OffsetMax = "102.5 -115"
							},
							Image = {Color = "0 0 0 0"}
						}, InfoLayer, InfoLayer + ".Btn.Change");

						CreateOutLine(ref container, InfoLayer + ".Btn.Change", targetUI.ColorThree.Get(), 1);

						container.Add(new CuiButton
						{
							RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
							Text =
							{
								Text = Msg(player, Edit),
								Align = TextAnchor.MiddleCenter,
								Font = "robotocondensed-regular.ttf",
								FontSize = 10,
								Color = "1 1 1 1"
							},
							Button =
							{
								Color = "0 0 0 0",
								Command = $"UI_Kits editkit {false} {kit.ID}",
								Close = InfoLayer
							}
						}, InfoLayer + ".Btn.Change");
					}

					#endregion

					#endregion

					#region Main

					container.Add(new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1",
							OffsetMin = $"{constSwitch} {ySwitch - 15f}", OffsetMax = $"0 {ySwitch}"
						},
						Text =
						{
							Text = Msg(player, ContainerMain),
							Align = TextAnchor.MiddleLeft,
							Font = "robotocondensed-regular.ttf",
							FontSize = 12,
							Color = "1 1 1 1"
						}
					}, InfoLayer);

					ySwitch -= 20f;

					var xSwitch = constSwitch;

					for (var slot = 0; slot < amountOnString * 4; slot++)
					{
						var kitItem = kit.GetItemByContainerAndPosition("main", slot);

						InfoItemUi(ref container, player,
							slot,
							$"{xSwitch} {ySwitch - Size}",
							$"{xSwitch + Size} {ySwitch}",
							kit,
							kitItem,
							total,
							"main");

						if ((slot + 1) % amountOnString == 0)
						{
							xSwitch = constSwitch;
							ySwitch = ySwitch - Size - Margin;
						}
						else
						{
							xSwitch += Size + Margin;
						}

						total++;
					}

					#endregion

					#region Wear

					ySwitch -= 5f;

					amountOnString = 7;

					constSwitch = -(amountOnString * Size + (amountOnString - 1) * Margin) / 2f;

					if (kit.UseSlotForBackpack) amountOnString++;
					// constSwitch -= Size + Margin * 3;
					xSwitch = constSwitch;

					container.Add(new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1",
							OffsetMin = $"{constSwitch} {ySwitch - 15f}", OffsetMax = $"0 {ySwitch}"
						},
						Text =
						{
							Text = Msg(player, ContainerWear),
							Align = TextAnchor.MiddleLeft,
							Font = "robotocondensed-regular.ttf",
							FontSize = 12,
							Color = "1 1 1 1"
						}
					}, InfoLayer);

					ySwitch -= 20f;

					for (var slot = 0; slot < amountOnString; slot++)
					{
						var kitItem = kit.GetItemByContainerAndPosition("wear", slot);

						InfoItemUi(ref container, player,
							slot,
							$"{xSwitch} {ySwitch - Size}",
							$"{xSwitch + Size} {ySwitch}",
							kit,
							kitItem,
							total,
							"wear");

						if ((slot + 1) % amountOnString == 0)
						{
							xSwitch = constSwitch;
							ySwitch = ySwitch - Size - Margin;
						}
						else
						{
							if (slot == ItemContainer.BackpackSlotIndex - 1)
								xSwitch += Size + Margin * 3;
							else
								xSwitch += Size + Margin;
						}

						total++;
					}

					#endregion

					#region Belt

					ySwitch -= 5f;

					amountOnString = 6;

					constSwitch = -(amountOnString * Size + (amountOnString - 1) * Margin) / 2f;

					xSwitch = constSwitch;

					container.Add(new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1",
							OffsetMin = $"{constSwitch} {ySwitch - 15f}", OffsetMax = $"0 {ySwitch}"
						},
						Text =
						{
							Text = Msg(player, ContainerBelt),
							Align = TextAnchor.MiddleLeft,
							Font = "robotocondensed-regular.ttf",
							FontSize = 12,
							Color = "1 1 1 1"
						}
					}, InfoLayer);

					ySwitch -= 20f;

					for (var slot = 0; slot < amountOnString; slot++)
					{
						var kitItem = kit.GetItemByContainerAndPosition("belt", slot);

						InfoItemUi(ref container, player,
							slot,
							$"{xSwitch} {ySwitch - Size}",
							$"{xSwitch + Size} {ySwitch}",
							kit,
							kitItem,
							total,
							"belt");

						if ((slot + 1) % amountOnString == 0)
						{
							xSwitch = constSwitch;
							ySwitch = ySwitch - Size - Margin;
						}
						else
						{
							xSwitch += Size + Margin;
						}

						total++;
					}

					#endregion

					#region Description

					_config.InfoKitDescription.Get(ref container, InfoLayer, null, kit.Description);

					#endregion

					break;
				}
			}
			
			CuiHelper.AddUi(player, container);
		}

		private void InfoKitItemUI(BasePlayer player, Kit kit, CuiElementContainer container, int slot, string itemContainer)
		{
			var targetUI = GetOpenedKits(player).useMainUI ? _config.UI : _config.MenuUI;
			
			container.Add(new CuiPanel()
				{
					RectTransform =
					{
						AnchorMin = "0 0", AnchorMax = "1 1"
					},
					Image =
					{
						Color = targetUI.ColorThree.Get(),
						Material = "assets/content/ui/namefontmaterial.mat",
						Sprite = "assets/content/ui/UI.Background.Tile.psd"
					}
				}, 
				InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}",
				InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}.Panel",
				InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}.Panel");

			var kitItem = kit.GetItemByContainerAndPosition(itemContainer, slot);
			if (kitItem != null)
			{
				container.Add(kitItem.GetImage("0 0", "1 1", "10 10", "-10 -10",
					InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}.Panel"));

				container.Add(new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "2.5 3.5", OffsetMax = "-2.5 -2.5"
						},
						Text =
						{
							Text = $"x{kitItem.Amount}",
							Align = TextAnchor.LowerRight,
							Font = "robotocondensed-regular.ttf",
							FontSize = 10,
							Color = "1 1 1 1"
						}
					}, InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}.Panel");

				var color = _config.RarityColors.Find(x => x.Chance == kitItem.Chance);
				if (color != null)
				{
					container.Add(new CuiPanel
						{
							RectTransform =
							{
								AnchorMin = "0 0", AnchorMax = "1 0",
								OffsetMin = "0 0", OffsetMax = "0 2"
							},
							Image =
							{
								Color = HexToCuiColor(color.Color)
							}
						}, InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}.Panel");

					container.Add(new CuiLabel
						{
							RectTransform =
							{
								AnchorMin = "0 0", AnchorMax = "1 1",
								OffsetMin = "2.5 2.5", OffsetMax = "-2.5 -2.5"
							},
							Text =
							{
								Text = $"{kitItem.Chance}%",
								Align = TextAnchor.UpperLeft,
								Font = "robotocondensed-regular.ttf",
								FontSize = 10,
								Color = "1 1 1 1"
							}
						}, InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}.Panel");
				}

				if (IsAdmin(player))
					container.Add(new CuiButton
						{
							RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
							Text = {Text = ""},
							Button =
							{
								Color = "0 0 0 0",
								Command =
									$"UI_Kits startedititem {itemContainer} {kit.ID} {slot}",
								Close = InfoLayer
							}
						}, InfoLayer + $".Container.{itemContainer}.Section.Item.{slot}.Panel");
			}
		}
		
		#endregion Kit Info UI
		
		#region Editing UI

		private const float
			Kit_Editing_Height = 40f,
			Kit_Editing_Width = 225f,
			Kit_Editing_Margin_X = 35f,
			Kit_Editing_Margin_Y = 10f;

		private void EditingKitUi(BasePlayer player, bool creating, int kitId = -1)
		{
			#region Dictionary

			if (!_kitEditing.ContainsKey(player.userID))
			{
				if (kitId != -1)
				{
					var kit = FindKitByID(kitId);
					if (kit == null) return;

					_kitEditing.Add(player.userID, new Dictionary<string, object>
					{
						["Name"] = kit.Name,
						["DisplayName"] = kit.DisplayName,
						["Color"] = kit.Color,
						["Permission"] = kit.Permission,
						["Description"] = kit.Description,
						["Image"] = kit.Image,
						["Hide"] = kit.Hide,
						["ShowInfo"] = kit.ShowInfo,
						["Amount"] = kit.Amount,
						["Cooldown"] = kit.Cooldown,
						["CooldownAfterWipe"] = kit.CooldownAfterWipe,
						["Sale"] = kit.Sale,
						["Price"] = kit.Price,
						["AutoKit"] = _config.AutoKits.Contains(kit.Name),
						["UseCommandsOnReceiving"] = kit.UseCommandsOnReceiving,
						["CommandsOnReceiving"] = kit.CommandsOnReceiving,
						["UseSlotForBackpack"] = kit.UseSlotForBackpack
					});
				}
				else
				{
					_kitEditing.Add(player.userID, new Dictionary<string, object>
					{
						["Name"] = CuiHelper.GetGuid(),
						["DisplayName"] = "My Kit",
						["Color"] = _config.KitColor,
						["Permission"] = $"{Name}.default",
						["Description"] = string.Empty,
						["Image"] = string.Empty,
						["Hide"] = true,
						["ShowInfo"] = true,
						["Amount"] = 0,
						["Cooldown"] = 0.0,
						["CooldownAfterWipe"] = 0.0,
						["Sale"] = false,
						["Price"] = 0,
						["AutoKit"] = false,
						["UseCommandsOnReceiving"] = false,
						["CommandsOnReceiving"] = string.Empty,
						["UseSlotForBackpack"] = true
					});
				}
			}

			#endregion

			var container = new CuiElementContainer();

			var totalHeight = Mathf.RoundToInt(Mathf.Max(_kitEditing[player.userID].Count / 2, 1) *
				(Kit_Editing_Height + Kit_Editing_Margin_Y) + 150f);

			#region Main

			container.Add(new CuiPanel
			{
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
				Image =
				{
					Color = HexToCuiColor("#161617", 80)
				}
			}, "Overlay", EditingLayer, EditingLayer);

			container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0.5 0.5",
						AnchorMax = "0.5 0.5",
						OffsetMin = $"-260 -{totalHeight / 2f}",
						OffsetMax = $"260 {totalHeight / 2f}"
					},
					Image =
					{
						Color = HexToCuiColor("#0E0E10")
					}
				}, EditingLayer, $"{EditingLayer}.Main", $"{EditingLayer}.Main");

			#endregion

			#region Header

			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0 1", AnchorMax = "1 1",
					OffsetMin = "0 -50",
					OffsetMax = "0 0"
				},
				Image = {Color = HexToCuiColor("#161617")}
			}, EditingLayer + ".Main", EditingLayer + ".Header");

			container.Add(new CuiLabel
			{
				RectTransform =
				{
					AnchorMin = "0 0", AnchorMax = "1 1",
					OffsetMin = "10 0",
					OffsetMax = "0 0"
				},
				Text =
				{
					Text = Msg(player, CreateOrEditKit),
					Align = TextAnchor.MiddleLeft,
					Font = "robotocondensed-bold.ttf",
					FontSize = 14,
					Color = HexToCuiColor("#FFFFFF")
				}
			}, EditingLayer + ".Header");

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "1 1", AnchorMax = "1 1",
					OffsetMin = "-35 -37.5",
					OffsetMax = "-10 -12.5"
				},
				Text =
				{
					Text = Msg(player, Close),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-bold.ttf",
					FontSize = 10,
					Color = HexToCuiColor("#FFFFFF")
				},
				Button =
				{
					Close = EditingLayer,
					Color = HexToCuiColor("#4B68FF"),
					Command = "UI_Kits stopedit"
				}
			}, EditingLayer + ".Header");

			#endregion

			#region Fields

			var ySwitch = -60f;

			var i = 1;
			foreach (var (param, value) in _kitEditing[player.userID])
			{
				var xSwitch = i % 2 == 0 ? Kit_Editing_Margin_X / 2f : -Kit_Editing_Width - Kit_Editing_Margin_X / 2f;

				var title = param.GetFieldTitle<Kit>();

				if (value is bool boolValue)
					EditBoolFieldUi(player, ref container, EditingLayer + ".Main", EditingLayer + $".Editing.{i}",
						$"{xSwitch} {ySwitch - Kit_Editing_Height}",
						$"{xSwitch + Kit_Editing_Width} {ySwitch}",
						$"UI_Kits editkit {creating} {kitId} {param} ",
						title,
						boolValue);
				else
					EditFieldUi(player, ref container, EditingLayer + ".Main", EditingLayer + $".Editing.{i}",
						$"{xSwitch} {ySwitch - Kit_Editing_Height}",
						$"{xSwitch + Kit_Editing_Width} {ySwitch}",
						$"UI_Kits editkit {creating} {kitId} {param} ",
						title,
						value);

				if (i % 2 == 0) ySwitch = ySwitch - Kit_Editing_Height - Kit_Editing_Margin_Y;

				i++;
			}

			#endregion

			#region Buttons

			#region Save Kit

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "0 0", AnchorMax = "0 0",
					OffsetMin = "15 10",
					OffsetMax = "115 35"
				},
				Text =
				{
					Text = Msg(player, SaveKit),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = HexToCuiColor("#4B68FF"),
					Command = $"UI_Kits savekit {creating} {kitId}",
					Close = EditingLayer
				}
			}, EditingLayer + ".Main");

			#endregion

			#region Add From Inventory

			if (!creating)
				container.Add(new CuiButton
				{
					RectTransform =
					{
						AnchorMin = "0.5 0", AnchorMax = "0.5 0",
						OffsetMin = "-100 10",
						OffsetMax = "100 35"
					},
					Text =
					{
						Text = Msg(player, CopyItems),
						Align = TextAnchor.MiddleCenter,
						Font = "robotocondensed-regular.ttf",
						FontSize = 10,
						Color = "1 1 1 1"
					},
					Button =
					{
						Color = HexToCuiColor("#50965F"),
						Command = $"UI_Kits frominv {kitId}",
						Close = EditingLayer
					}
				}, EditingLayer + ".Main");

			#endregion

			#region Remove Kit

			if (!creating)
				container.Add(new CuiButton
				{
					RectTransform =
					{
						AnchorMin = "1 0", AnchorMax = "1 0",
						OffsetMin = "-115 10",
						OffsetMax = "-15 35"
					},
					Text =
					{
						Text = Msg(player, RemoveKit),
						Align = TextAnchor.MiddleCenter,
						Font = "robotocondensed-regular.ttf",
						FontSize = 10,
						Color = "1 1 1 1"
					},
					Button =
					{
						Color = HexToCuiColor("#FF4B4B"),
						Command = $"UI_Kits removekit {kitId}",
						Close = EditingLayer
					}
				}, EditingLayer + ".Main");

			#endregion

			#endregion

			CuiHelper.AddUi(player, container);
		}

		private void EditingItemUi(BasePlayer player, int kitId, int slot, string itemContainer,
			bool First = false)
		{
			var container = new CuiElementContainer();

			#region Dictionary

			if (!_itemEditing.ContainsKey(player.userID))
			{
				var kit = FindKitByID(kitId);
				if (kit == null) return;

				var item = kit.GetItemByContainerAndPosition(itemContainer, slot);
				if (item != null)
					_itemEditing.Add(player.userID, new Dictionary<string, object>
					{
						["Type"] = item.Type,
						["Command"] = item.Command,
						["Container"] = item.Container,
						["ShortName"] = item.ShortName,
						["DisplayName"] = item.DisplayName,
						["Amount"] = item.Amount,
						["Blueprint"] = item.Blueprint,
						["SkinID"] = item.SkinID,
						["Chance"] = item.Chance,
						["Position"] = item.Position
					});
				else
					_itemEditing.Add(player.userID, new Dictionary<string, object>
					{
						["Type"] = KitItemType.Item,
						["Container"] = itemContainer,
						["Command"] = string.Empty,
						["ShortName"] = string.Empty,
						["DisplayName"] = string.Empty,
						["Amount"] = 1,
						["Blueprint"] = 0,
						["SkinID"] = 0UL,
						["Chance"] = 100,
						["Position"] = slot
					});
			}

			#endregion

			var edit = _itemEditing[player.userID];

			#region Background

			if (First)
				container.Add(new CuiPanel
				{
					RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
					Image = {Color = HexToCuiColor("#161617", 80)},
					CursorEnabled = true
				}, "Overlay", EditingLayer, EditingLayer);

			#endregion

			#region Main

			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
					OffsetMin = "-260 -240",
					OffsetMax = "260 250"
				},
				Image =
				{
					Color = HexToCuiColor("#0E0E10")
				}
			}, EditingLayer, EditingLayer + ".Main", EditingLayer + ".Main");

			#region Header

			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0 1", AnchorMax = "1 1",
					OffsetMin = "0 -50",
					OffsetMax = "0 0"
				},
				Image = {Color = HexToCuiColor("#161617")}
			}, EditingLayer + ".Main", EditingLayer + ".Header");

			container.Add(new CuiLabel
			{
				RectTransform =
				{
					AnchorMin = "0 0", AnchorMax = "1 1",
					OffsetMin = "10 0",
					OffsetMax = "0 0"
				},
				Text =
				{
					Text = Msg(player, EditingTitle),
					Align = TextAnchor.MiddleLeft,
					Font = "robotocondensed-bold.ttf",
					FontSize = 14,
					Color = HexToCuiColor("#FFFFFF")
				}
			}, EditingLayer + ".Header");

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "1 1", AnchorMax = "1 1",
					OffsetMin = "-35 -37.5",
					OffsetMax = "-10 -12.5"
				},
				Text =
				{
					Text = Msg(player, Close),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-bold.ttf",
					FontSize = 10,
					Color = HexToCuiColor("#FFFFFF")
				},
				Button =
				{
					Close = EditingLayer,
					Color = HexToCuiColor("#4B68FF"),
					Command = $"UI_Kits infokit {kitId}"
				}
			}, EditingLayer + ".Header");

			#endregion

			#region Type

			var type = edit["Type"] as KitItemType? ?? KitItemType.Item;

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "0.5 1", AnchorMax = "0.5 1",
					OffsetMin = "10 -110",
					OffsetMax = "115 -80"
				},
				Text =
				{
					Text = Msg(player, ItemName),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = type == KitItemType.Item ? HexToCuiColor("#4B68FF") : HexToCuiColor("#4B68FF", 50),
					Command = $"UI_Kits edititem {itemContainer} {kitId} {slot} Type {KitItemType.Item}"
				}
			}, EditingLayer + ".Main");

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "0.5 1", AnchorMax = "0.5 1",
					OffsetMin = "135 -110",
					OffsetMax = "240 -80"
				},
				Text =
				{
					Text = Msg(player, CmdName),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = type == KitItemType.Command ? HexToCuiColor("#4B68FF") : HexToCuiColor("#4B68FF", 50),
					Command = $"UI_Kits edititem {itemContainer} {kitId} {slot} Type {KitItemType.Command}"
				}
			}, EditingLayer + ".Main");

			#endregion

			#region Command

			EditFieldUi(player, ref container, EditingLayer + ".Main", CuiHelper.GetGuid(),
				"-240 -110",
				"0 -60",
				$"UI_Kits edititem {itemContainer} {kitId} {slot} Command ",
				"Command", edit["Command"]);

			#endregion

			#region Item

			var shortName = (string) edit["ShortName"];

			#region Image

			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0.5 1", AnchorMax = "0.5 1",
					OffsetMin = "-240 -265", OffsetMax = "-105 -130"
				},
				Image = {Color = HexToCuiColor("#161617")}
			}, EditingLayer + ".Main", EditingLayer + ".Image");

			if (!string.IsNullOrEmpty(shortName))
				container.Add(new CuiElement
				{
					Parent = EditingLayer + ".Image",
					Components =
					{
						new CuiImageComponent
						{
							ItemId = ItemManager.FindItemDefinition(shortName)?.itemid ?? 0,
							SkinId = (ulong) edit["SkinID"]
						},
						new CuiRectTransformComponent
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "10 10", OffsetMax = "-10 -10"
						}
					}
				});

			#endregion

			#region ShortName

			EditFieldUi(player, ref container, EditingLayer + ".Main", CuiHelper.GetGuid(),
				"-85 -190",
				"70 -130",
				$"UI_Kits edititem {itemContainer} {kitId} {slot} ShortName ",
				"ShortName", edit["ShortName"]);

			#endregion

			#region Skin

			EditFieldUi(player, ref container, EditingLayer + ".Main", CuiHelper.GetGuid(),
				"85 -190",
				"240 -130",
				$"UI_Kits edititem {itemContainer} {kitId} {slot} SkinID ",
				"SkinID", edit["SkinID"]);

			#endregion

			#region Select Item

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "0.5 1", AnchorMax = "0.5 1",
					OffsetMin = "-85 -265",
					OffsetMax = "55 -235"
				},
				Text =
				{
					Text = Msg(player, BtnSelect),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = HexToCuiColor("#4B68FF"),
					Command = $"UI_Kits selectitem {itemContainer} {kitId} {slot}"
				}
			}, EditingLayer + ".Main");

			#endregion

			#region Blueprint

			var bp = edit["Blueprint"] as int? ?? 0;
			CheckBoxUi(ref container,
				EditingLayer + ".Main",
				CuiHelper.GetGuid(),
				"0.5 1", "0.5 1",
				"65 -255",
				"75 -245",
				bp == 1,
				$"UI_Kits edititem {itemContainer} {kitId} {slot} Blueprint {(bp == 0 ? 1 : 0)}",
				Msg(player, BluePrint)
			);

			#endregion

			#region Amount

			EditFieldUi(player, ref container, EditingLayer + ".Main", CuiHelper.GetGuid(),
				"-240 -345",
				"-7.5 -285",
				$"UI_Kits edititem {itemContainer} {kitId} {slot} Amount ",
				"Amount", edit["Amount"]);

			#endregion

			#region Chance

			EditFieldUi(player, ref container, EditingLayer + ".Main", CuiHelper.GetGuid(),
				"7.5 -345",
				"240 -285",
				$"UI_Kits edititem {itemContainer} {kitId} {slot} Chance ",
				"Chance", edit["Chance"]);

			#endregion

			#region Display Name

			EditFieldUi(player, ref container, EditingLayer + ".Main", CuiHelper.GetGuid(),
				"-240 -425",
				"240 -365",
				$"UI_Kits edititem {itemContainer} {kitId} {slot} DisplayName ",
				"DisplayName",
				edit["DisplayName"]);

			#endregion

			#endregion

			#region Save Button

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "0.5 0", AnchorMax = "0.5 0",
					OffsetMin = "-90 10",
					OffsetMax = $"{(slot == -1 ? 90 : 55)} 40"
				},
				Text =
				{
					Text = Msg(player, BtnSave),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = HexToCuiColor("#4B68FF"),
					Command = $"UI_Kits saveitem {kitId} {slot} {itemContainer}",
					Close = EditingLayer
				}
			}, EditingLayer + ".Main");

			#endregion

			#region Remove Item

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "0.5 0", AnchorMax = "0.5 0",
					OffsetMin = "60 10",
					OffsetMax = "90 40"
				},
				Text =
				{
					Text = Msg(player, RemoveItem),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = HexToCuiColor("#FF4B4B"),
					Command = $"UI_Kits removeitem {kitId} {slot} {itemContainer}",
					Close = EditingLayer
				}
			}, EditingLayer + ".Main");

			#endregion

			#endregion

			CuiHelper.AddUi(player, container);
		}

		private void SelectItem(BasePlayer player, int kitId, int slot, string itemContainer,
			string selectedCategory = "", int page = 0, string input = "")
		{
			if (string.IsNullOrEmpty(selectedCategory)) selectedCategory = _itemsCategories.FirstOrDefault().Key;

			var container = new CuiElementContainer();

			#region Background

			container.Add(new CuiButton
			{
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
				Text = {Text = ""},
				Button =
				{
					Close = ModalLayer,
					Color = HexToCuiColor("#161617", 80)
				}
			}, "Overlay", ModalLayer, ModalLayer);

			#endregion

			#region Main

			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
					OffsetMin = "-260 -270",
					OffsetMax = "260 280"
				},
				Image =
				{
					Color = HexToCuiColor("#0E0E10")
				}
			}, ModalLayer, ModalLayer + ".Main");

			#region Categories

			var amountOnString = 4;
			var Width = 120f;
			var Height = 25f;
			var xMargin = 5f;
			var yMargin = 5f;

			var constSwitch = -(amountOnString * Width + (amountOnString - 1) * xMargin) / 2f;
			var xSwitch = constSwitch;
			var ySwitch = -15f;

			var i = 1;
			foreach (var category in _itemsCategories)
			{
				container.Add(new CuiButton
				{
					RectTransform =
					{
						AnchorMin = "0.5 1", AnchorMax = "0.5 1",
						OffsetMin = $"{xSwitch} {ySwitch - Height}",
						OffsetMax = $"{xSwitch + Width} {ySwitch}"
					},
					Text =
					{
						Text = $"{category.Key}",
						Align = TextAnchor.MiddleCenter,
						Font = "robotocondensed-regular.ttf",
						FontSize = 10,
						Color = "1 1 1 1"
					},
					Button =
					{
						Color = selectedCategory == category.Key
							? HexToCuiColor("#4B68FF")
							: HexToCuiColor("#161617"),
						Command = $"UI_Kits selectitem {itemContainer} {kitId} {slot}  {category.Key}"
					}
				}, ModalLayer + ".Main");

				if (i % amountOnString == 0)
				{
					ySwitch = ySwitch - Height - yMargin;
					xSwitch = constSwitch;
				}
				else
				{
					xSwitch += xMargin + Width;
				}

				i++;
			}

			#endregion

			#region Items

			amountOnString = 5;

			var strings = 4;
			var totalAmount = amountOnString * strings;

			ySwitch = ySwitch - yMargin - Height - 10f;

			Width = 85f;
			Height = 85f;
			xMargin = 15f;
			yMargin = 5f;

			constSwitch = -(amountOnString * Width + (amountOnString - 1) * xMargin) / 2f;
			xSwitch = constSwitch;

			i = 1;

			var canSearch = !string.IsNullOrEmpty(input) && input.Length > 2;

			var temp = canSearch
				? _itemsCategories
					.SelectMany(x => x.Value)
					.Where(x => x.shortName.StartsWith(input) || x.shortName.Contains(input) ||
					            x.shortName.EndsWith(input))
				: _itemsCategories[selectedCategory];

			var itemsAmount = temp.Count;

			temp.SkipAndTake(page * totalAmount, totalAmount).ForEach(item =>
			{
				container.Add(new CuiPanel
					{
						RectTransform =
						{
							AnchorMin = "0.5 1", AnchorMax = "0.5 1",
							OffsetMin = $"{xSwitch} {ySwitch - Height}",
							OffsetMax = $"{xSwitch + Width} {ySwitch}"
						},
						Image = {Color = HexToCuiColor("#161617")}
					}, ModalLayer + ".Main", ModalLayer + $".Item.{item}");

				container.Add(new CuiElement
				{
					Parent = ModalLayer + $".Item.{item}",
					Components =
					{
						new CuiImageComponent
						{
							ItemId = item.itemID
						},
						new CuiRectTransformComponent
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "5 5", OffsetMax = "-5 -5"
						}
					}
				});

				container.Add(new CuiButton
					{
						RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
						Text = {Text = ""},
						Button =
						{
							Color = "0 0 0 0",
							Command = $"UI_Kits takeitem {page} {itemContainer} {kitId} {slot} {item.shortName}",
							Close = ModalLayer
						}
					}, ModalLayer + $".Item.{item}");

				if (i % amountOnString == 0)
				{
					xSwitch = constSwitch;
					ySwitch = ySwitch - yMargin - Height;
				}
				else
				{
					xSwitch += xMargin + Width;
				}

				i++;
			});

			#endregion

			#region Search

			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0.5 0", AnchorMax = "0.5 0",
					OffsetMin = "-90 10", OffsetMax = "90 35"
				},
				Image = {Color = HexToCuiColor("#4B68FF")}
			}, ModalLayer + ".Main", ModalLayer + ".Search");

			container.Add(new CuiLabel
			{
				RectTransform =
				{
					AnchorMin = "0 0", AnchorMax = "1 1",
					OffsetMin = "10 0", OffsetMax = "0 0"
				},
				Text =
				{
					Text = canSearch ? $"{input}" : Msg(player, ItemSearch),
					Align = canSearch ? TextAnchor.MiddleLeft : TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = canSearch ? "1 1 1 0.8" : "1 1 1 1"
				}
			}, ModalLayer + ".Search");

			container.Add(new CuiElement
			{
				Parent = ModalLayer + ".Search",
				Components =
				{
					new CuiInputFieldComponent
					{
						FontSize = 10,
						Align = TextAnchor.MiddleLeft,
						Command = $"UI_Kits selectitem {itemContainer} {kitId} {slot} {selectedCategory} 0 ",
						Color = "1 1 1 0.95",
						CharsLimit = 150,
						NeedsKeyboard = true
					},
					new CuiRectTransformComponent
					{
						AnchorMin = "0 0", AnchorMax = "1 1",
						OffsetMin = "10 0", OffsetMax = "0 0"
					}
				}
			});

			#endregion

			#region Pages

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "0 0", AnchorMax = "0 0",
					OffsetMin = "10 10",
					OffsetMax = "80 35"
				},
				Text =
				{
					Text = Msg(player, Back),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = HexToCuiColor("#161617"),
					Command = page != 0
						? $"UI_Kits selectitem {itemContainer} {kitId} {slot} {selectedCategory} {page - 1} {input}"
						: ""
				}
			}, ModalLayer + ".Main");

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "1 0", AnchorMax = "1 0",
					OffsetMin = "-80 10",
					OffsetMax = "-10 35"
				},
				Text =
				{
					Text = Msg(player, Next),
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = HexToCuiColor("#4B68FF"),
					Command = itemsAmount > (page + 1) * totalAmount
						? $"UI_Kits selectitem {itemContainer} {kitId} {slot} {selectedCategory} {page + 1} {input}"
						: ""
				}
			}, ModalLayer + ".Main");

			#endregion

			#endregion

			CuiHelper.AddUi(player, container);
		}

		#endregion Editing UI

		#region UI.Components
		
		private static void UpdateUI(BasePlayer player, Action<CuiElementContainer> callback)
		{
			if (player == null) return;

			var container = new CuiElementContainer();

			callback?.Invoke(container);

			CuiHelper.AddUi(player, container);
		}

		
		private static void ShowGridUI(CuiElementContainer container, 
			int startIndex, int count,
			int itemsOnString,
			float marginX,
			float marginY,
			float itemWidth,
			float itemHeight,
			float offsetX,
			float offsetY,
			float aMinX, float aMaxX, float aMinY, float aMaxY,
			string backgroundColor,
			string parent, 
			Func<int, string> panelName = null,
			Func<int, string> destroyName = null,
			Action<int> callback = null)
		{
			var xSwitch = offsetX;
			var ySwitch = offsetY;

			for (var i = startIndex; i < count; i++)
			{
				container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = $"{aMinX} {aMinY}", AnchorMax = $"{aMaxX} {aMaxY}",
						OffsetMin = $"{xSwitch} {ySwitch - itemHeight}", 
						OffsetMax = $"{xSwitch + itemWidth} {ySwitch}"
					},
					Image = { Color = backgroundColor }
				}, parent, panelName != null ? panelName(i) : CuiHelper.GetGuid(), destroyName != null ? destroyName(i) : string.Empty);
				
				callback?.Invoke(i);
				
				if ((i + 1) % itemsOnString == 0)
				{
					xSwitch = offsetX;
					ySwitch = ySwitch - itemHeight - marginY;
				}
				else
				{
					xSwitch += itemWidth + marginX;
				}
			}
		}

		private void AddMoveButton(CuiElementContainer container,
			string layerParent,
			string direction,
			int yOffset,
			string moveCommand)
		{
			container.Add(new CuiButton
				{
					RectTransform =
					{
						AnchorMin = "1 1", AnchorMax = "1 1",
						OffsetMin = $"0 {yOffset - 15}", OffsetMax = $"10 {yOffset}"
					},
					Text =
					{
						Text = direction == "right" ? "▶" : "◀",
						Align = TextAnchor.MiddleCenter,
						Font = "robotocondensed-regular.ttf",
						FontSize = 7,
						Color = "1 1 1 1"
					},
					Button =
					{
						Color = direction == "right" ? HexToCuiColor("#50965F") : HexToCuiColor("#FF4B4B"),
						Command = moveCommand
					}
				}, layerParent, layerParent + $".Move.{direction}");
		}

		private void ErrorUi(BasePlayer player, string msg)
		{
			var container = new CuiElementContainer
			{
				{
					new CuiPanel
					{
						RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
						Image = {Color = _config.UI.ColorFive.Get()},
						CursorEnabled = true
					},
					"Overlay", ModalLayer, ModalLayer
				},
				{
					new CuiPanel
					{
						RectTransform =
						{
							AnchorMin = "0.5 0.5",
							AnchorMax = "0.5 0.5",
							OffsetMin = "-127.5 -75",
							OffsetMax = "127.5 140"
						},
						Image = {Color = _config.UI.ColorRed.Get()}
					},
					ModalLayer, ModalLayer + ".Main"
				},
				{
					new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -165", OffsetMax = "0 0"
						},
						Text =
						{
							Text = "XXX",
							Align = TextAnchor.MiddleCenter,
							Font = "robotocondensed-bold.ttf",
							FontSize = 120,
							Color = _config.UI.ColorWhite.Get()
						}
					},
					ModalLayer + ".Main"
				},
				{
					new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -175", OffsetMax = "0 -155"
						},
						Text =
						{
							Text = $"{msg}",
							Align = TextAnchor.MiddleCenter,
							Font = "robotocondensed-regular.ttf",
							FontSize = 12,
							Color = _config.UI.ColorWhite.Get()
						}
					},
					ModalLayer + ".Main"
				},
				{
					new CuiButton
					{
						RectTransform =
						{
							AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 30"
						},
						Text =
						{
							Text = Msg(player, BtnClose),
							Align = TextAnchor.MiddleCenter,
							Font = "robotocondensed-regular.ttf",
							FontSize = 12,
							Color = _config.UI.ColorWhite.Get()
						},
						Button = {Color = HexToCuiColor("#CD3838"), Close = ModalLayer}
					},
					ModalLayer + ".Main"
				}
			};

			CuiHelper.AddUi(player, container);
		}

		private void EditFieldUi(BasePlayer player, ref CuiElementContainer container,
			string parent,
			string name,
			string oMin,
			string oMax,
			string command,
			string label,
			object fieldValue)
		{
			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0.5 1", AnchorMax = "0.5 1",
					OffsetMin = $"{oMin}",
					OffsetMax = $"{oMax}"
				},
				Image =
				{
					Color = "0 0 0 0"
				}
			}, parent, name);

			container.Add(new CuiLabel
			{
				RectTransform =
				{
					AnchorMin = "0 1", AnchorMax = "1 1",
					OffsetMin = "0 -10", OffsetMax = "0 0"
				},
				Text =
				{
					Text = label,
					Align = TextAnchor.MiddleLeft,
					Font = "robotocondensed-regular.ttf",
					FontSize = 8,
					Color = "1 1 1 1"
				}
			}, name);

			container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0 0", AnchorMax = "1 1",
						OffsetMin = "0 0", OffsetMax = "0 -10"
					},
					Image = {Color = "0 0 0 0"}
				}, name, $"{name}.Value");

			CreateOutLine(ref container, $"{name}.Value", _config.UI.ColorOne.Get());

			container.Add(new CuiElement
			{
				Parent = $"{name}.Value",
				Components =
				{
					new CuiInputFieldComponent
					{
						FontSize = 12,
						Align = TextAnchor.MiddleLeft,
						Command = $"{command}",
						Color = "1 1 1 0.4",
						CharsLimit = 150,
						NeedsKeyboard = true,
						Text = $"{fieldValue}",
						Font = "robotocondensed-regular.ttf"
					},
					new CuiRectTransformComponent
					{
						AnchorMin = "0 0", AnchorMax = "1 1",
						OffsetMin = "10 0", OffsetMax = "0 0"
					}
				}
			});

			container.Add(new CuiButton
				{
					RectTransform =
					{
						AnchorMin = "1 1", AnchorMax = "1 1",
						OffsetMin = "-30 -40", OffsetMax = "0 0"
					},
					Text =
					{
						Text = Msg(player, EditRemoveField),
						Align = TextAnchor.MiddleCenter,
						Font = "robotocondensed-regular.ttf",
						FontSize = 14,
						Color = _config.UI.ColorOne.Get()
					},
					Button =
					{
						Color = "0 0 0 0",
						Command = $"{command}delete"
					}
				}, $"{name}.Value");
		}

		private void EditBoolFieldUi(BasePlayer player, ref CuiElementContainer container,
			string parent,
			string name,
			string oMin,
			string oMax,
			string command,
			string label,
			bool value)
		{
			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0.5 1",
					AnchorMax = "0.5 1",
					OffsetMin = $"{oMin}",
					OffsetMax = $"{oMax}"
				},
				Image =
				{
					Color = "0 0 0 0"
				}
			}, parent, name);

			CreateOutLine(ref container, name, _config.UI.ColorOne.Get());

			container.Add(new CuiLabel
			{
				RectTransform =
				{
					AnchorMin = "0 0", AnchorMax = "1 1",
					OffsetMin = "10 0", OffsetMax = "0 0"
				},
				Text =
				{
					Text = label,
					Align = TextAnchor.MiddleLeft,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				}
			}, name);

			container.Add(new CuiButton
			{
				RectTransform =
				{
					AnchorMin = "1 0.5", AnchorMax = "1 0.5",
					OffsetMin = "-40 -10", OffsetMax = "-10 10"
				},
				Text =
				{
					Text = value ? "✔" : string.Empty,
					Align = TextAnchor.MiddleCenter,
					Font = "robotocondensed-bold.ttf",
					FontSize = 10,
					Color = "1 1 1 1"
				},
				Button =
				{
					Color = _config.UI.ColorOne.Get(),
					Command = $"{command} {!value}"
				}
			}, name);
		}

		private void CheckBoxUi(ref CuiElementContainer container,
			string parent, string name, string aMin, string aMax,
			string oMin, string oMax, bool enabled,
			string command, string text,
			string color = null,
			int outlineSize = 3)
		{
			color ??= _config.UI.ColorThree.Get();
			
			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = aMin, AnchorMax = aMax,
					OffsetMin = oMin,
					OffsetMax = oMax
				},
				Image = {Color = "0 0 0 0"}
			}, parent, name);
			
			CreateOutLine(ref container, name, color, outlineSize);

			if (enabled)
				container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0 0", AnchorMax = "1 1"
					},
					Image = {Color = _config.UI.ColorThree.Get()}
				}, name);


			container.Add(new CuiButton
			{
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
				Text = {Text = ""},
				Button =
				{
					Color = "0 0 0 0",
					Command = $"{command}"
				}
			}, name);

			container.Add(new CuiLabel
			{
				RectTransform =
				{
					AnchorMin = "1 0.5", AnchorMax = "1 0.5",
					OffsetMin = "5 -10",
					OffsetMax = "100 10"
				},
				Text =
				{
					Text = $"{text}",
					Align = TextAnchor.MiddleLeft,
					Font = "robotocondensed-regular.ttf",
					FontSize = 10,
					Color = _config.UI.ColorWhite.Get()
				}
			}, name);
		}

		private void InfoItemUi(ref CuiElementContainer container, BasePlayer player,
			int slot,
			string oMin,
			string oMax,
			Kit kit,
			KitItem kitItem, int total, string itemContainer)
		{
			container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0.5 1",
						AnchorMax = "0.5 1",
						OffsetMin = $"{oMin}",
						OffsetMax = $"{oMax}"
					},
					Image =
					{
						Color = _config.UI.ColorOne.Get()
					}
				}, InfoLayer, InfoLayer + $".Item.{total}");

			if (kitItem != null)
			{
				container.Add(kitItem.GetImage("0 0", "1 1", "10 10", "-10 -10", InfoLayer + $".Item.{total}"));

				container.Add(new CuiLabel
					{
						RectTransform =
						{
							AnchorMin = "0 0", AnchorMax = "1 1",
							OffsetMin = "2.5 3.5", OffsetMax = "-2.5 -2.5"
						},
						Text =
						{
							Text = $"x{kitItem.Amount}",
							Align = TextAnchor.LowerRight,
							Font = "robotocondensed-regular.ttf",
							FontSize = 10,
							Color = "1 1 1 1"
						}
					}, InfoLayer + $".Item.{total}");

				var color = _config.RarityColors.Find(x => x.Chance == kitItem.Chance);
				if (color != null)
				{
					container.Add(new CuiPanel
						{
							RectTransform =
							{
								AnchorMin = "0 0", AnchorMax = "1 0",
								OffsetMin = "0 0", OffsetMax = "0 2"
							},
							Image =
							{
								Color = HexToCuiColor(color.Color)
							}
						}, InfoLayer + $".Item.{total}");

					container.Add(new CuiLabel
						{
							RectTransform =
							{
								AnchorMin = "0 0", AnchorMax = "1 1",
								OffsetMin = "2.5 2.5", OffsetMax = "-2.5 -2.5"
							},
							Text =
							{
								Text = $"{kitItem.Chance}%",
								Align = TextAnchor.UpperLeft,
								Font = "robotocondensed-regular.ttf",
								FontSize = 10,
								Color = "1 1 1 1"
							}
						}, InfoLayer + $".Item.{total}");
				}
			}

			if (IsAdmin(player))
				container.Add(new CuiButton
					{
						RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
						Text = {Text = ""},
						Button =
						{
							Color = "0 0 0 0",
							Command =
								$"UI_Kits startedititem {itemContainer} {kit.ID} {slot}",
							Close = InfoLayer
						}
					}, InfoLayer + $".Item.{total}");
		}

		private void RefreshKitUi(ref CuiElementContainer container, BasePlayer player, Kit kit)
		{
			var playerData = PlayerData.GetOrCreateKitData(player.UserIDString, kit.Name);
			if (playerData == null) return;

			var openedKits = GetOpenedKits(player);
			var targetUI = openedKits.useMainUI ? _config.UI : _config.MenuUI;
			switch (targetUI.Style)
			{
				case InterfaceStyle.NewRust:
				{
					container.Add(new CuiPanel
						{
							RectTransform =
							{
								AnchorMin = "0.5 0", AnchorMax = "0.5 0",
								OffsetMin = "-70 50", OffsetMax = "70 90"
							},
							Image = {Color = "0 0 0 0"}
						}, 
						Layer + $".Kit.{kit.ID}.Main", 
						Layer + $".Kit.{kit.ID}", 
						Layer + $".Kit.{kit.ID}");

					if (_config.ShowAllKits && _config.ShowNoPermDescription && !string.IsNullOrEmpty(kit.Permission) &&
					    !player.HasPermission(kit.Permission))
					{
						container.Add(new CuiLabel
							{
								RectTransform =
								{
									AnchorMin = targetUI.NoPermission.AnchorMin,
									AnchorMax = targetUI.NoPermission.AnchorMax,
									OffsetMin = targetUI.NoPermission.OffsetMin,
									OffsetMax = targetUI.NoPermission.OffsetMax
								},
								Text =
								{
									Text = Msg(player, kit.Name, NoPermissionDescription),
									Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter,
									Color = HexToCuiColor("#E2DBD3", 50)
								}
							}, Layer + $".Kit.{kit.ID}");
						return;
					}

					if (playerData.HasAmount > 0)
					{
						#region Title

						container.Add(new CuiLabel
							{
								RectTransform =
								{
									AnchorMin = targetUI.KitAmountCooldown.AnchorMin,
									AnchorMax = targetUI.KitAmountCooldown.AnchorMax,
									OffsetMin = targetUI.KitAmountCooldown.OffsetMin,
									OffsetMax = targetUI.KitAmountCooldown.OffsetMax								
								},
								Text =
								{
									Text = Msg(player, kit.Name, KitYouHave),
									Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = targetUI.ColorOne.Get() },
							}, Layer + $".Kit.{kit.ID}");

						#endregion

						#region Points

						var amount = Mathf.Min(playerData.HasAmount, 9);

						var width = amount == 1
							? targetUI.KitAmount.Width
							: targetUI.KitAmount.Width / amount * 0.9f;

						var margin = (targetUI.KitAmount.Width - width * amount) / (amount - 1);

						var xSwitch = -(targetUI.KitAmount.Width / 2f);

						for (var i = 0; i < amount; i++)
						{
							container.Add(new CuiPanel
								{
									RectTransform =
									{
										AnchorMin = targetUI.KitAmount.AnchorMin,
										AnchorMax = targetUI.KitAmount.AnchorMax,
										OffsetMin = $"{xSwitch} {targetUI.KitAmount.OffsetMin}",
										OffsetMax = $"{xSwitch + width} {targetUI.KitAmount.OffsetMax}"
									},
									Image =
									{
										Color = HexToCuiColor("#71B8ED", 70),
										Material = "assets/content/ui/namefontmaterial.mat",	
									}
								}, Layer + $".Kit.{kit.ID}");

							xSwitch += width + margin;
						}

						#endregion
					}
					else
					{
						var currentTime = GetCurrentTime();

						if (IsKitCooldown(kit, playerData, currentTime, out var isCooldown, out var wipeBlock))
						{
							var time = GetCooldownTimeRemaining(kit, playerData, currentTime, isCooldown);

							if (kit.Amount > 0)
							{
								container.Add(new CuiLabel
									{
										RectTransform =
										{
											AnchorMin = targetUI.KitAmountCooldown.AnchorMin,
											AnchorMax = targetUI.KitAmountCooldown.AnchorMax,
											OffsetMin = targetUI.KitAmountCooldown.OffsetMin,
											OffsetMax = targetUI.KitAmountCooldown.OffsetMax
										},
										Text =
										{
											Text = $"{FormatShortTime(time)}",
											Font = "robotocondensed-bold.ttf", FontSize = 14,
											Align = TextAnchor.MiddleCenter, Color = targetUI.ColorOne.Get()
										}
									}, Layer + $".Kit.{kit.ID}", Layer + $".Kit.{kit.ID}.Cooldown");
							}
							else
							{
								container.Add(new CuiPanel
									{
										Image =
										{
											Color = HexToCuiColor("#71B8ED", 10),
											Material = "assets/content/ui/namefontmaterial.mat",
										},
										RectTransform =
										{
											AnchorMin = targetUI.KitCooldown.AnchorMin,
											AnchorMax = targetUI.KitCooldown.AnchorMax,
											OffsetMin = targetUI.KitCooldown.OffsetMin,
											OffsetMax = targetUI.KitCooldown.OffsetMax
										}
									}, Layer + $".Kit.{kit.ID}", Layer + $".Kit.{kit.ID}.Cooldown");

								container.Add(new CuiElement
								{
									Parent = Layer + $".Kit.{kit.ID}.Cooldown",
									Components =
									{
										new CuiTextComponent
										{
											Text = $"{FormatShortTime(time)}", Font = "robotocondensed-bold.ttf",
											FontSize = 14, Align = TextAnchor.MiddleCenter,
											Color = targetUI.ColorOne.Get()
										},
										new CuiRectTransformComponent
											{AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"}
									}
								});
							}
						}
						else
						{
							if (kit.Sale)
							{
								container.Add(new CuiPanel
									{
										RectTransform =
										{
											AnchorMin = targetUI.KitSale.AnchorMin,
											AnchorMax = targetUI.KitSale.AnchorMax,
											OffsetMin = targetUI.KitSale.OffsetMin,
											OffsetMax = targetUI.KitSale.OffsetMax
										},
										Image =
										{
											Color = HexToCuiColor("#71B8ED", 10),
											Material = "assets/content/ui/namefontmaterial.mat",										
										}
									}, Layer + $".Kit.{kit.ID}", Layer + $".Kit.{kit.ID}.Sale");

								container.Add(new CuiLabel
									{
										RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
										Text =
										{
											Text = Msg(player, kit.Name, PriceFormat, kit.Price),
											Align = TextAnchor.MiddleCenter,
											Font = "robotocondensed-bold.ttf",
											FontSize = 12,
											Color = "1 1 1 1"
										}
									}, Layer + $".Kit.{kit.ID}.Sale");
							}
							else
							{
								container.Add(new CuiLabel
									{
										RectTransform =
										{
											AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"
										},
										Text =
										{
											Text = Msg(player, kit.Name, KitAvailableTitle),
											Font = "robotocondensed-bold.ttf", FontSize = 12,
											Align = TextAnchor.UpperCenter, Color = HexToCuiColor("#E2DBD3", 50)
										}
									}, Layer + $".Kit.{kit.ID}");
							}
						}

						if (kit.Amount > 0)
						{
							var kitAmountWidth = 140f;

							var amount = Mathf.Min(kit.Amount, 9);

							var hasAmount = kit.Amount > 9 ? 9 * playerData.Amount / kit.Amount : playerData.Amount;

							var width = amount == 1
								? kitAmountWidth
								: kitAmountWidth / amount * 0.9f;

							var margin = (kitAmountWidth - width * amount) / (amount - 1);

							var xSwitch = -(kitAmountWidth / 2f);

							for (var i = 0; i < amount; i++)
							{
								container.Add(new CuiPanel
									{
										RectTransform =
										{
											AnchorMin = "0.5 0",
											AnchorMax = "0.5 0",
											OffsetMin = $"{xSwitch} 0",
											OffsetMax = $"{xSwitch + width} 4"
										},
										Image =
										{
											Color = i < hasAmount
												?  HexToCuiColor("#71B8ED", 70) 
												: HexToCuiColor("#71B8ED", 10),
											Material = "assets/content/ui/namefontmaterial.mat",	
										}
									}, Layer + $".Kit.{kit.ID}");

								xSwitch += width + margin;
							}
						}
					}

					break;
				}
				
				default:
				{
					container.Add(new CuiPanel
						{
							RectTransform = {AnchorMin = "0 1", AnchorMax = "1 1"},
							Image = {Color = "0 0 0 0"}
						}, Layer + $".Kit.{kit.ID}.Main", Layer + $".Kit.{kit.ID}", Layer + $".Kit.{kit.ID}");

					if (_config.ShowAllKits && _config.ShowNoPermDescription && !string.IsNullOrEmpty(kit.Permission) &&
					    !player.HasPermission(kit.Permission))
					{
						container.Add(new CuiLabel
							{
								RectTransform =
								{
									AnchorMin = targetUI.NoPermission.AnchorMin,
									AnchorMax = targetUI.NoPermission.AnchorMax,
									OffsetMin = targetUI.NoPermission.OffsetMin,
									OffsetMax = targetUI.NoPermission.OffsetMax
								},
								Text =
								{
									Text = Msg(player, kit.Name, NoPermissionDescription),
									Align = TextAnchor.MiddleCenter,
									Font = "robotocondensed-regular.ttf",
									FontSize = 10,
									Color = targetUI.ColorFour.Get()
								}
							}, Layer + $".Kit.{kit.ID}");
						return;
					}

					if (playerData.HasAmount > 0)
					{
						#region Title

						container.Add(new CuiLabel
							{
								RectTransform =
								{
									AnchorMin = targetUI.KitAmountCooldown.AnchorMin,
									AnchorMax = targetUI.KitAmountCooldown.AnchorMax,
									OffsetMin = targetUI.KitAmountCooldown.OffsetMin,
									OffsetMax = targetUI.KitAmountCooldown.OffsetMax
								},
								Text =
								{
									Text = Msg(player, kit.Name, KitYouHave),
									Align = TextAnchor.MiddleCenter,
									Font = "robotocondensed-bold.ttf",
									FontSize = 12,
									Color = "1 1 1 1"
								}
							}, Layer + $".Kit.{kit.ID}");

						#endregion

						#region Points

						var amount = Mathf.Min(playerData.HasAmount, 9);

						var width = amount == 1
							? targetUI.KitAmount.Width
							: targetUI.KitAmount.Width / amount * 0.9f;

						var margin = (targetUI.KitAmount.Width - width * amount) / (amount - 1);

						var xSwitch = -(targetUI.KitAmount.Width / 2f);

						for (var i = 0; i < amount; i++)
						{
							container.Add(new CuiPanel
								{
									RectTransform =
									{
										AnchorMin = targetUI.KitAmount.AnchorMin,
										AnchorMax = targetUI.KitAmount.AnchorMax,
										OffsetMin = $"{xSwitch} {targetUI.KitAmount.OffsetMin}",
										OffsetMax = $"{xSwitch + width} {targetUI.KitAmount.OffsetMax}"
									},
									Image =
									{
										Color = HexToCuiColor(kit.Color)
									}
								}, Layer + $".Kit.{kit.ID}");

							xSwitch += width + margin;
						}

						#endregion
					}
					else
					{
						var currentTime = GetCurrentTime();

						if (IsKitCooldown(kit, playerData, currentTime, out var isCooldown, out var wipeBlock))
						{
							var time = GetCooldownTimeRemaining(kit, playerData, currentTime, isCooldown);

							if (kit.Amount > 0)
							{
								container.Add(new CuiLabel
									{
										RectTransform =
										{
											AnchorMin = targetUI.KitAmountCooldown.AnchorMin,
											AnchorMax = targetUI.KitAmountCooldown.AnchorMax,
											OffsetMin = targetUI.KitAmountCooldown.OffsetMin,
											OffsetMax = targetUI.KitAmountCooldown.OffsetMax
										},
										Text =
										{
											Text = $"{FormatShortTime(time)}",
											Align = TextAnchor.MiddleCenter,
											Font = "robotocondensed-bold.ttf",
											FontSize = 12,
											Color = "1 1 1 1"
										}
									}, Layer + $".Kit.{kit.ID}", Layer + $".Kit.{kit.ID}.Cooldown");
							}
							else
							{
								container.Add(new CuiPanel
									{
										RectTransform =
										{
											AnchorMin = targetUI.KitCooldown.AnchorMin,
											AnchorMax = targetUI.KitCooldown.AnchorMax,
											OffsetMin = targetUI.KitCooldown.OffsetMin,
											OffsetMax = targetUI.KitCooldown.OffsetMax
										},
										Image = {Color = HexToCuiColor(kit.Color)}
									}, Layer + $".Kit.{kit.ID}", Layer + $".Kit.{kit.ID}.Cooldown");

								container.Add(new CuiLabel
									{
										RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
										Text =
										{
											Text = $"{FormatShortTime(time)}",
											Align = TextAnchor.MiddleCenter,
											Font = "robotocondensed-bold.ttf",
											FontSize = 12,
											Color = "1 1 1 1"
										}
									}, Layer + $".Kit.{kit.ID}.Cooldown");
							}
						}
						else
						{
							if (kit.Sale)
							{
								container.Add(new CuiPanel
									{
										RectTransform =
										{
											AnchorMin = targetUI.KitSale.AnchorMin,
											AnchorMax = targetUI.KitSale.AnchorMax,
											OffsetMin = targetUI.KitSale.OffsetMin,
											OffsetMax = targetUI.KitSale.OffsetMax
										},
										Image = {Color = HexToCuiColor(kit.Color)}
									}, Layer + $".Kit.{kit.ID}", Layer + $".Kit.{kit.ID}.Sale");

								container.Add(new CuiLabel
									{
										RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
										Text =
										{
											Text = Msg(player, kit.Name, PriceFormat, kit.Price),
											Align = TextAnchor.MiddleCenter,
											Font = "robotocondensed-bold.ttf",
											FontSize = 12,
											Color = "1 1 1 1"
										}
									}, Layer + $".Kit.{kit.ID}.Sale");
							}
							else
							{
								container.Add(new CuiLabel
									{
										RectTransform =
										{
											AnchorMin = targetUI.KitAvailable.AnchorMin,
											AnchorMax = targetUI.KitAvailable.AnchorMax,
											OffsetMin = targetUI.KitAvailable.OffsetMin,
											OffsetMax = targetUI.KitAvailable.OffsetMax
										},
										Text =
										{
											Text = Msg(player, kit.Name, KitAvailableTitle),
											Align = TextAnchor.MiddleCenter,
											Font = "robotocondensed-regular.ttf",
											FontSize = 10,
											Color = targetUI.ColorFour.Get()
										}
									}, Layer + $".Kit.{kit.ID}");
							}
						}

						if (kit.Amount > 0)
						{
							var amount = Mathf.Min(kit.Amount, 9);

							var hasAmount = kit.Amount > 9 ? 9 * playerData.Amount / kit.Amount : playerData.Amount;

							var width = amount == 1
								? targetUI.KitAmount.Width
								: targetUI.KitAmount.Width / amount * 0.9f;

							var margin = (targetUI.KitAmount.Width - width * amount) / (amount - 1);

							var xSwitch = -(targetUI.KitAmount.Width / 2f);

							for (var i = 0; i < amount; i++)
							{
								container.Add(new CuiPanel
									{
										RectTransform =
										{
											AnchorMin = targetUI.KitAmount.AnchorMin,
											AnchorMax = targetUI.KitAmount.AnchorMax,
											OffsetMin = $"{xSwitch} {targetUI.KitAmount.OffsetMin}",
											OffsetMax = $"{xSwitch + width} {targetUI.KitAmount.OffsetMax}"
										},
										Image =
										{
											Color = i < hasAmount ? HexToCuiColor(kit.Color) : targetUI.ColorTwo.Get()
										}
									}, Layer + $".Kit.{kit.ID}");

								xSwitch += width + margin;
							}
						}
					}

					break;
				}
			}
		}

		#endregion

		#endregion

		#region Kit Helpers

		private bool GiveKitToPlayer(BasePlayer player, Kit kit,
			bool force = false,
			bool chat = false, bool usingUI = true)
		{ 
			if (!CanPlayerRedeemKit(player, kit, force, chat))
				return false;
			
			if (!force)
				ServerMgr.Instance.StartCoroutine(GiveKitItems(player, kit));
			else
				FastGiveKitItems(player, kit);

			kit.UseCommands(player);

			UpdatePlayerData(player, kit, force);

			SendNotify(player, KitClaimed, 0, kit.DisplayName);

			Interface.CallHook("OnKitRedeemed", player, kit.Name);

			PlayerData.Save(player.UserIDString);
			
			Log(player, kit.Name);

			HandleKitRedeemedUI(player, usingUI);
			return true;
		}

		private void HandleKitRedeemedUI(BasePlayer player, bool usingUI)
		{
			if (usingUI)
			{
				if (_config.UI.CloseAfterReceive)
				{
					ServerPanel?.Call("API_OnServerPanelCallClose", player);
					
					RemoveOpenedKits(player);

					CuiHelper.DestroyUi(player, Layer);
				}
				else
				{
					UpdateUI(player, container =>
					{
						MainKitsContentUI(player, container);
					});
				}
			}
		}

		private void UpdatePlayerData(BasePlayer player, Kit kit, bool force)
		{
			var playerData = PlayerData.GetOrCreateKitData(player.UserIDString, kit.Name);
			if (!force && playerData != null)
			{
				if (playerData.HasAmount > 0)
				{
					playerData.HasAmount -= 1;
				}
				else
				{
					if (kit.Amount > 0) playerData.Amount += 1;

					if (kit.Cooldown > 0) 
						playerData.Cooldown = GetCurrentTime() + GetCooldown(kit.Cooldown, player);
				}
			}
		}

		private bool CanPlayerRedeemKit(BasePlayer player, Kit kit, bool force, bool chat)
		{
			if (player == null || kit == null) return false;

			if (Interface.Oxide.CallHook("canRedeemKit", player) != null)
				return false;

			if (force) return true;
			
			var playerData = PlayerData.GetOrCreateKitData(player.UserIDString, kit.Name);
			if (playerData == null) return false;

			var kitConditions = CheckConditionsForKit(player, kit, playerData);
			if (kitConditions.Success) return true;
			
			SendMessageToNotifyOrUI(player, kitConditions.ErrorMessage, 1, chat);
			return false;
		}

		private (bool Success, string ErrorMessage) CheckConditionsForKit(BasePlayer player, Kit kit,
			PlayerData.KitData playerData)
		{
			if (playerData is not {HasAmount: > 0} &&
			    !string.IsNullOrEmpty(kit.Permission) &&
			    !player.HasPermission(kit.Permission))
				return (false, Msg(player, NoPermission));

			if (_config.BlockBuilding && !player.CanBuild()) 
				return (false, Msg(player, BBlocked));

			if (kit.CooldownAfterWipe > 0)
			{
				var leftTime = LeftWipeBlockTime(kit.CooldownAfterWipe);
				if (leftTime > 0)
					return (false, Msg(player, KitCooldown,
						FormatShortTime(TimeSpan.FromSeconds(leftTime))));
			}

			if (_config.UseNoEscape && !_config.NoEscapeWhiteList.Contains(kit.Name))
			{
				if (_config.UseRaidBlock && RaidBlocked(player)) return (false, Msg(player, NoEscapeCombatBlocked));

				if (_config.UseCombatBlock && CombatBlocked(player)) return (false, Msg(player, NoEscapeCombatBlocked));
			}

			if (playerData is {HasAmount: <= 0})
			{
				if (kit.Amount > 0 && playerData.Amount >= kit.Amount) return (false, Msg(player, KitLimit));

				var currentTime = GetCurrentTime();

				if (kit.Cooldown > 0 && playerData.Cooldown > currentTime)
					return (false, Msg(player, KitCooldown,
						FormatShortTime(TimeSpan.FromSeconds(playerData.Cooldown - currentTime))));
			}

			var totalCount = kit.beltCount + kit.wearCount + kit.mainCount;
			if (player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count <
			    kit.beltCount ||
			    player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count <
			    kit.wearCount ||
			    player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count <
			    kit.mainCount)
				if (totalCount > player.inventory.containerMain.capacity -
				    player.inventory.containerMain.itemList.Count)
					return (false, Msg(player, NotEnoughSpace));

			if (playerData is not {HasAmount: > 0} && kit.Sale &&
			    !_config.Economy.RemoveBalance(player, kit.Price))
				return (false, Msg(player, NotMoney));

			if (kit.UseBuilding && CopyPaste != null && !string.IsNullOrEmpty(kit.Building))
			{
				var success = CopyPaste?.Call("TryPasteFromSteamId", player.userID.Get(), kit.Building,
					_config.CopyPasteParameters.ToArray());
				if (success is string) return (false, Msg(player, BuildError));
			}

			return (true, null);
		}

		private void ProcessAutoKit(BasePlayer player, Kit kit)
		{
			var playerData = PlayerData.GetOrCreateKitData(player.UserIDString, kit.Name);
			if (!_config.IgnoreAutoKitChecking && !CheckConditionsForKit(player, kit, playerData).Success) return;
			
			kit.Get(player);
				
			kit.UseCommands(player);
                
			UpdatePlayerData(player, kit, false);
				
			Interface.CallHook("OnKitRedeemed", player, kit.Name);
		}

		private const int _itemsPerTick = 10;

		private IEnumerator GiveKitItems(BasePlayer player, Kit kit)
		{
			for (var index = 0; index < kit.Items.Count; index++)
			{
				kit.Items[index]?.Get(player);

				if (index % _itemsPerTick == 0)
					yield return CoroutineEx.waitForEndOfFrame;
			}
		}

		private void FastGiveKitItems(BasePlayer player, Kit kit)
		{
			kit.Items.ForEach(item => item?.Get(player));
		}

		private double GetCooldown(double cooldown, BasePlayer player)
		{
			var cd = Interface.CallHook("OnKitCooldown", player, cooldown);
			return cd != null ? Convert.ToDouble(cd) : cooldown;
		}

		private List<KitItem> GetPlayerItems(BasePlayer player)
		{
			var kitItems = new List<KitItem>();

			player.inventory.containerWear.itemList.FindAll(item => item != null && !item.IsLocked())
				.ForEach(item => kitItems.Add(ItemToKit(item, "wear")));

			player.inventory.containerMain.itemList.FindAll(item => item != null && !item.IsLocked())
				.ForEach(item => kitItems.Add(ItemToKit(item, "main")));

			player.inventory.containerBelt.itemList.FindAll(item => item != null && !item.IsLocked())
				.ForEach(item => kitItems.Add(ItemToKit(item, "belt")));

			return kitItems;
		}

		private KitItem ItemToKit(Item item, string container)
		{
			var kitItem = new KitItem
			{
				Amount = item.amount,
				Container = container,
				SkinID = item.skin,
				Blueprint = item.blueprintTarget,
				ShortName = item.info.shortname,
				DisplayName = !string.IsNullOrEmpty(item.name) ? item.name : string.Empty,
				Condition = item.condition,
				Weapon = null,
				Content = null,
				Chance = 100,
				Command = string.Empty,
				Position = item.position,
				Text = item.text,
				Image = string.Empty,
			};

			if (item.info.category == ItemCategory.Weapon)
			{
				var weapon = item.GetHeldEntity() as BaseProjectile;
				if (weapon != null)
					kitItem.Weapon = new Weapon
					{
						ammoType = weapon.primaryMagazine.ammoType.shortname,
						ammoAmount = weapon.primaryMagazine.contents
					};
			}

			if (item.contents != null)
				kitItem.Content = item.contents.itemList.Select(cont => new ItemContent
				{
					Amount = cont.amount,
					Condition = cont.condition,
					ShortName = cont.info.shortname
				});

			return kitItem;
		}

		#endregion

		#region Utils

		#region OpenedKits
		
		private readonly Dictionary<ulong, OpenedKits> _openKITS = new();
		
		private class OpenedKits
		{
			#region Fields

			public BasePlayer Player;
			
			public bool useMainUI;

			public ulong npcID;

			#endregion
			
			public OpenedKits(BasePlayer player, ulong targetID = DEFAULT_MAIN_TARGET_ID, bool mainUI = true)
			{
				Player = player;

				npcID = targetID;
                
				useMainUI = mainUI;
				
				UpdateKits(true);
			}

			#region Updates
			
			public List<Kit> availableKits, kitsToUpdate;

			public void SetKitsToUpdate(List<Kit> kits)
			{
				kitsToUpdate = kits;
			}

			public void UpdateKitsToUpdate()
			{
				var totalKitsAmount = GetTotalKitsAmount();
				SetKitsToUpdate(availableKits.SkipAndTake(currentPage * totalKitsAmount, totalKitsAmount));
			}
			
			public void UpdateKits(bool first = false)
			{
				availableKits = _instance.GetAvailableKits(Player, !first);

				UpdateKitsToUpdate();
			}

			public int GetTotalKitsAmount()
			{
				var targetUI=useMainUI ? _instance._config.UI : _instance._config.MenuUI;

				return targetUI.KitsOnString * targetUI.Strings;
			}

			#endregion

			#region Pages

			public int currentPage = DEFAULT_MAIN_PAGE;

			public bool showAll = DEFAULT_MAIN_SHOW_ALL;

			public void OnChangeCurrentPage(int page)
			{
				currentPage = page;
				
				if (availableKits.Count > currentPage * GetTotalKitsAmount() == false)
					OnChangeCurrentPage(Mathf.Max(0, currentPage - 1));
				
				UpdateKitsToUpdate();
			}
			
			public void OnChangeShowAll(bool newShowAll)
			{
				showAll = newShowAll;
				
				UpdateKits();
			}

			#endregion
		}

		private OpenedKits GetOpenedKits(BasePlayer player, bool mainUI = true)
		{
            if (!_openKITS.TryGetValue(player.userID, out var openedKits))
	            _openKITS.TryAdd(player.userID, openedKits = new OpenedKits(player, mainUI: mainUI));

            return openedKits;
		}
		
		private bool TryCreateOpenedKits(BasePlayer player, out OpenedKits openedKits, bool mainUI = true)
		{
			RemoveOpenedKits(player.userID);
			
			return _openKITS.TryAdd(player.userID, openedKits = new OpenedKits(player, mainUI: mainUI));
		}

		private bool IsOpenedKits(BasePlayer player)
		{
			return _openKITS.ContainsKey(player.userID);
		}
		
		private bool RemoveOpenedKits(BasePlayer player)
		{
			return _openKITS.Remove(player.userID);
		}

		private bool RemoveOpenedKits(ulong userID)
		{
			return _openKITS.Remove(userID);
		}

		private OpenedKits SetOpenedKits(BasePlayer player, 
			ulong targetID = DEFAULT_MAIN_TARGET_ID,
			int page = DEFAULT_MAIN_PAGE, 
			bool showAll = DEFAULT_MAIN_SHOW_ALL)
		{
			var openedKits = new OpenedKits(player, targetID, mainUI: true);
			openedKits.OnChangeCurrentPage(page);
			openedKits.OnChangeShowAll(showAll);
			_openKITS[player.userID] = openedKits;
			return openedKits;
		}
		
		#endregion

		#region Find Kits

		private Dictionary<string, int> _kitByName = new();

		private Dictionary<int, int> _kitByID = new();

		private Kit FindKitByName(string name)
		{
			return _kitByName.TryGetValue(name, out var index) ? _data.Kits[index] : null;
		}

		private Kit FindKitByID(int id)
		{
			return _kitByID.TryGetValue(id, out var index) ? _data.Kits[index] : null;
		}

		private bool TryFindKitByID(int id, out Kit kit)
		{
			if (_kitByID.TryGetValue(id, out var index))
			{
				kit = _data.Kits[index];
				return kit != null;
			}

			kit = null;
			return false;
		}

		#endregion

		#region Wipe

		private Coroutine _wipePlayers;

		private IEnumerator StartOnAllPlayers(string[] players,
			Action<string> callback = null,
			Action onFinish = null)
		{
			for (var i = 0; i < players.Length; i++)
			{
				callback?.Invoke(players[i]);

				if (i % 10 == 0)
					yield return CoroutineEx.waitForFixedUpdate;
			}

			onFinish?.Invoke();
			
			_wipePlayers = null;
		}

		private void DoWipePlayers(Action<int> callback = null)
		{
			try
			{
				var players = PlayerData.GetFiles();
				if (players is {Length: > 0})
				{
					var playersCount = players.Length;
					
					_wipePlayers =
						ServerMgr.Instance.StartCoroutine(StartOnAllPlayers(
							players, 
							userID => PlayerData.DoWipe(userID),
							() => _usersData?.Clear()));

					callback?.Invoke(playersCount);
				}
			}
			catch (Exception e)
			{
				PrintError($"[On Server Wipe] in wipe players, error: {e.Message}");
			}
		}

		#endregion

		private void CacheKits()
		{
			_kitByName.Clear();
			_kitByID.Clear();

			for (var index = 0; index < _data.Kits.Count; index++)
			{
				var kit = _data.Kits[index];

				kit.Update();
				kit.ID = _lastKitID++;

				_kitByName[kit.Name] = index;
				_kitByID[kit.ID] = index;
			}
		}
        
		private void DoRemoveKit(Kit kit)
		{
			_kitByName.Remove(kit.Name);
			_kitByID.Remove(kit.ID);
			_data.Kits.Remove(kit);

			CacheKits();
			SaveKits();
		}
		
		private void RegisterPermissions()
		{
			permission.RegisterPermission(PERM_ADMIN, this);

			if (!permission.PermissionExists(_config.ChangeAutoKitPermission))
				permission.RegisterPermission(_config.ChangeAutoKitPermission, this);

			_data.Kits.ForEach(kit =>
			{
				var perm = kit.Permission;

				if (!string.IsNullOrEmpty(perm) && !permission.PermissionExists(perm))
					permission.RegisterPermission(perm, this);
			});
		}

		private void RegisterCommands()
		{
			AddCovalenceCommand(_config.Commands, nameof(CmdOpenKits));
		}

		private void LoadServerPanel()
		{
			_serverPanelCategory.spStatus = ServerPanel is {IsLoaded: true};

			ServerPanel?.Call("API_OnServerPanelProcessCategory", Name);
		}
		
		private bool RaidBlocked(BasePlayer player)
		{
			return Convert.ToBoolean(NoEscape?.Call("IsRaidBlocked", player) ?? false);
		}

		private bool CombatBlocked(BasePlayer player)
		{
			return Convert.ToBoolean(NoEscape?.Call("IsCombatBlocked", player) ?? false);
		}

		private void StopEditing(BasePlayer player)
		{
			_itemEditing.Remove(player.userID);
			_kitEditing.Remove(player.userID);
		}

		private void FillCategories()
		{
			ItemManager.itemList.ForEach(item =>
			{
				var itemCategory = item.category.ToString();

				if (_itemsCategories.ContainsKey(itemCategory))
				{
					if (!_itemsCategories[itemCategory].Contains((item.itemid, item.shortname)))
						_itemsCategories[itemCategory].Add((item.itemid, item.shortname));
				}
				else
				{
					_itemsCategories.Add(itemCategory, new List<(int itemID, string shortName)>
					{
						(item.itemid, item.shortname)
					});
				}
			});
		}

		private void UpdatePlayerCooldownsHandler()
		{
			_playersToRemoveFromUpdate.Clear();
			
			foreach (var (userID, data) in _openKITS)
			{
				if (data.Player == null || !data.Player.IsConnected)
				{
					_playersToRemoveFromUpdate.Add(userID);
					continue;
				}
				
				var container = new CuiElementContainer();

				data.kitsToUpdate?.ForEach(kit => RefreshKitUi(ref container, data.Player, kit));

				CuiHelper.AddUi(data.Player, container);
			}

            foreach (var userID in _playersToRemoveFromUpdate) 
	            RemoveOpenedKits(userID);
		}

		private void FixItemsPositions()
		{
			_data.Kits.ForEach(kit =>
			{
				var positions = new Dictionary<string, int>
				{
					["belt"] = 0,
					["main"] = 0,
					["wear"] = 0
				};

				kit.Items.ForEach(item =>
				{
					if (positions.ContainsKey(item.Container) && item.Position == -1)
					{
						item.Position = positions[item.Container];

						positions[item.Container] += 1;
					}
				});
			});

			SaveKits();
		}

		#region Image Helpers

		private string GetImage(string name)
		{
#if CARBON
			return imageDatabase.GetImageString(name);
#else
			return Convert.ToString(ImageLibrary?.Call("GetImage", name));
#endif
		}

		private void LoadImages()
		{
#if CARBON
			imageDatabase = BaseModule.GetModule<ImageDatabaseModule>();
#endif
			_enabledImageLibrary = true;

			var imagesList = new Dictionary<string, string>
			{
				["mevent_arrow_up"] = "https://i.ibb.co/BcSZtPm/arrow-up.png",
				["mevent_arrow_down"] = "https://i.ibb.co/C60QSX0/down.png"
			};

			_data.Kits.ForEach(kit =>
			{
				RegisterImage(kit.Image, ref imagesList);

				kit.Items.ForEach(item => RegisterImage(item.Image, ref imagesList));
			});

			if (_config.UI.Logo.Enabled) RegisterImage(_config.UI.Logo.Image, ref imagesList);

#if CARBON
            imageDatabase.Queue(true, imagesList);
#else
			timer.In(1f, () =>
			{
				if (ImageLibrary is not {IsLoaded: true})
				{
					_enabledImageLibrary = false;

					BroadcastILNotInstalled();
					return;
				}

				ImageLibrary?.Call("ImportImageList", Title, imagesList, 0UL, true);
			});
#endif
		}

		private void BroadcastILNotInstalled()
		{
			for (var i = 0; i < 5; i++) PrintError("IMAGE LIBRARY IS NOT INSTALLED.");
		}

		private static void RegisterImage(string image, ref Dictionary<string, string> imagesList)
		{
			if (!string.IsNullOrEmpty(image))
				imagesList.TryAdd(image, image);
		}

		#endregion

		private static string HexToCuiColor(string hex, float alpha = 100)
		{
			if (string.IsNullOrEmpty(hex)) hex = "#FFFFFF";

			var str = hex.Trim('#');
			if (str.Length != 6) throw new Exception(hex);
			var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
			var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
			var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

			return $"{(double) r / 255} {(double) g / 255} {(double) b / 255} {alpha / 100f}";
		}

		private static string FormatShortTime(TimeSpan time)
		{
			return time.ToShortString();
		}

		private static void CreateOutLine(ref CuiElementContainer container, string parent, string color,
			float size = 2)
		{
			container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0 0",
						AnchorMax = "1 0",
						OffsetMin = $"{size} 0",
						OffsetMax = $"-{size} {size}"
					},
					Image = {Color = color}
				},
				parent);
			container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0 1",
						AnchorMax = "1 1",
						OffsetMin = $"{size} -{size}",
						OffsetMax = $"-{size} 0"
					},
					Image = {Color = color}
				},
				parent);
			container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0 0", AnchorMax = "0 1",
						OffsetMin = "0 0",
						OffsetMax = $"{size} 0"
					},
					Image = {Color = color}
				},
				parent);
			container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "1 0",
						AnchorMax = "1 1",
						OffsetMin = $"-{size} 0",
						OffsetMax = "0 0"
					},
					Image = {Color = color}
				},
				parent);
		}

		private List<Kit> GetAvailableKitList(BasePlayer player, 
			string targetId = "0", 
			bool showAll = false,
			bool checkAmount = true, bool gui = false)
		{
			if (showAll && IsAdmin(player))
				return _data.Kits;
			
			return _data.Kits.FindAll(kit => IsKitAvailable(player, targetId, checkAmount, gui, kit, DEFAULT_MAIN_TARGET_ID.ToString()));
		}

		private List<Kit> GetAvailableKits(BasePlayer player, bool checkOpenedKits = true)
		{
			var targetId = DEFAULT_MAIN_TARGET_ID;
			if (checkOpenedKits)
			{
				var openedKits = GetOpenedKits(player);
				if (openedKits.showAll && IsAdmin(player))
					return _data.Kits;

				targetId = openedKits.npcID;
			}
			
			return _data.Kits.FindAll(kit => IsKitAvailable(player, targetId.ToString(), true, true, kit, DEFAULT_MAIN_TARGET_ID.ToString()));
		}
		
		private bool IsKitAvailable(BasePlayer player, string targetId, bool checkAmount, bool gui, Kit kit,
			string ignoredTargetID)
		{
			if (kit.Hide || (gui && _config.KitsHidden.Contains(kit.Name)))
				return false;
			
			if (targetId != ignoredTargetID && !(_config.NpcKits.TryGetValue(targetId, out var npcKitsData) &&
			                                     npcKitsData.Kits.Contains(kit.Name)))
				return false;

			var data = PlayerData.GetOrCreateKitData(player.UserIDString, kit.Name);
			if (checkAmount && !_config.ShowUsesEnd && !(kit.Amount == 0 || (kit.Amount > 0 &&
			                                                                 (data?.Amount ?? 0) < kit.Amount)))
				return false;

			return _config.ShowAllKits || player.HasPermission(kit.Permission) ||
			       data is {HasAmount: > 0};
		}

		private List<Kit> GetAutoKits(BasePlayer player)
		{
			return _data.Kits
				.FindAll(kit => kit.Name == "autokit" || (_config.AutoKits.Contains(kit.Name) &&
				                                          (string.IsNullOrEmpty(kit.Permission) ||
				                                           player.HasPermission(kit.Permission))));
		}
		
		private int SecondsFromWipe()
		{
			return (int) DateTime.UtcNow
				.Subtract(SaveRestore.SaveCreatedTime.ToUniversalTime()).TotalSeconds;
		}

		private double LeftWipeBlockTime(double cooldown)
		{
			var leftTime = cooldown - SecondsFromWipe();
			return Math.Max(leftTime, 0);
		}

		private double UnBlockTime(double amount)
		{
			return TimeSpan.FromTicks(SaveRestore.SaveCreatedTime.ToUniversalTime().Ticks).TotalSeconds + amount;
		}

		private static double GetCurrentTime()
		{
			return TimeSpan.FromTicks(DateTime.UtcNow.Ticks).TotalSeconds;
		}

		private bool IsAdmin(BasePlayer player)
		{
			return player != null && ((player.IsAdmin && _config.FlagAdmin) || player.HasPermission(PERM_ADMIN));
		}

		private void UpdateOpenedUI(string id, string permName)
		{
			if (string.IsNullOrEmpty(id) || string.IsNullOrEmpty(permName) ||
			    !_data.Kits.Exists(x => x.Permission.Equals(permName))) return;

			var player = BasePlayer.Find(id);
			if (player == null) return;

			if (IsOpenedKits(player)) MainUi(player);
		}

		#endregion

		#region Log

		private void Log(BasePlayer player, string kitname)
		{
			if (player == null) return;

			var text = $"{player.displayName}[{player.UserIDString}] - Received Kit: {kitname}";

			if (_config.Logs.Console)
				Puts(text);

			if (_config.Logs.File)
				LogToFile(Name, $"[{DateTime.Now}] {text}", this);
		}

		#endregion

		#region Lang

		private const string
			UI_MeventRust_InfoKit_Title = "UI_MeventRust_InfoKit_Title",
			
			NoILError = "NoILError",
			KitShowInfo = "KitShowInfo",
			KitYouHave = "KitYouHave",
			EditRemoveField = "EditRemoveField",
			ChangeAutoKitOn = "ChangeAutoKitOn",
			ChangeAutoKitOff = "ChangeAutoKitOff",
			NoEscapeCombatBlocked = "NoEscapeCombatBlocked",
			NoEscapeRaidBlocked = "NoEscapeRaidBlocked",
			NotMoney = "NotMoney",
			PriceFormat = "PriceFormat",
			KitExist = "KitExist",
			KitNotExist = "KitNotExist",
			KitRemoved = "KitRemoved",
			AccessDenied = "AccessDenied",
			KitLimit = "KitLimit",
			KitCooldown = "KitCooldown",
			KitCreate = "KitCreate",
			KitClaimed = "KitClaimed",
			NotEnoughSpace = "NotEnoughtSpace",
			NotifyTitle = "NotifyTitle",
			Close = "Close",
			MainTitle = "MainTitle",
			Back = "Back",
			Next = "Next",
			NotAvailableKits = "NoAvailabeKits",
			CreateKit = "CreateKit",
			ListKits = "ListKits",
			ShowAll = "ShowAll",
			KitInfo = "KitInfo",
			KitTake = "KitGet",
			ComeBack = "ComeBack",
			Edit = "Edit",
			ContainerMain = "ContainerMain",
			ContainerWear = "ContaineWear",
			ContainerBelt = "ContainerBelt",
			CreateOrEditKit = "CreateOrEditKit",
			EnableKit = "EnableKit",
			AutoKit = "AutoKit",
			EnabledSale = "EnabledSale",
			SaveKit = "SaveKit",
			CopyItems = "CopyItems",
			RemoveKit = "RemoveKit",
			EditingTitle = "EditingTitle",
			ItemName = "ItemName",
			CmdName = "CmdName",
			BtnSelect = "BtnSelect",
			BluePrint = "BluePrint",
			BtnSave = "BtnSave",
			ItemSearch = "ItemSearch",
			BtnClose = "BtnClose",
			KitAvailableTitle = "KitAvailable",
			KitsList = "KitsList",
			KitsHelp = "KitsHelp",
			KitNotFound = "KitNotFound",
			RemoveItem = "RemoveItem",
			NoPermission = "NoPermission",
			BuildError = "BuildError",
			BBlocked = "BuildingBlocked",
			NoPermissionDescription = "NoPermissionDescription";

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				[KitExist] = "Kit with the same name already exist",
				[KitCreate] = "You have created a new kit - {0}",
				[KitNotExist] = "This kit doesn't exist",
				[KitRemoved] = "Kit {0} was removed",
				[AccessDenied] = "Access denied",
				[KitLimit] = "Usage limite reached",
				[KitCooldown] = "You will be able to use this kit after: {0}",
				[NotEnoughSpace] = "Can't redeem kit. Not enought space",
				[KitClaimed] = "You have claimed kit - {0}",
				[NotifyTitle] = "KITS",
				[Close] = "✕",
				[MainTitle] = "KITS",
				[Back] = "Back",
				[Next] = "Next",
				[NotAvailableKits] = "NO KITS AVAILABLE FOR YOU :(",
				[CreateKit] = "+ ADD KIT",
				[ListKits] = "List of kits",
				[ShowAll] = "SHOW ALL",
				[KitInfo] = "i",
				[KitTake] = "Take",
				[ComeBack] = "Come back",
				[Edit] = "+ EDIT KIT",
				[ContainerMain] = "Main",
				[ContainerWear] = "Wear",
				[ContainerBelt] = "Belt",
				[CreateOrEditKit] = "Create/Edit Kit",
				[EnableKit] = "Enable kit",
				[AutoKit] = "Auto kit",
				[EnabledSale] = "Enable sale",
				[SaveKit] = "Save kit",
				[CopyItems] = "Copy items from inventory",
				[RemoveKit] = "Remove kit",
				[EditingTitle] = "Item editing",
				[ItemName] = "Item",
				[CmdName] = "Command",
				[BtnSelect] = "Select",
				[BluePrint] = "Blueprint",
				[BtnSave] = "Save",
				[ItemSearch] = "Item search",
				[BtnClose] = "CLOSE",
				[KitAvailableTitle] = "KIT AVAILABLE\nTO RECEIVE",
				[KitsList] = "List of kits: {0}",
				[KitsHelp] =
					"KITS HELP\n- /{0} help - get help with kits\n- /{0} list - get a list of available kits\n- /{0} [name] - get the kit",
				[KitNotFound] = "Kit '{0}' not found",
				[RemoveItem] = "✕",
				[NoPermission] = "You don't have permission to get this kit",
				[BuildError] = "Can't place the building here",
				[BBlocked] = "Cannot do that while building blocked.",
				[NoPermissionDescription] = "PURCHASE THIS KIT AT\nSERVERNAME.GG",
				[PriceFormat] = "{0}$",
				[NotMoney] = "You don't have enough money!",
				[NoEscapeRaidBlocked] = "You cannot take this kit when you are raid blocked",
				[NoEscapeCombatBlocked] = "You cannot take this kit when you are combat blocked",
				[ChangeAutoKitOn] = "You have enabled autokits",
				[ChangeAutoKitOff] = "You have disabled autokits",
				[EditRemoveField] = "✕",
				[KitYouHave] = "YOU HAVE",
				[KitShowInfo] = "Show Info",
				[NoILError] = "The plugin does not work correctly, contact the administrator!",
				[UI_MeventRust_InfoKit_Title] = "KIT CONTENTS"
			}, this);

			lang.RegisterMessages(new Dictionary<string, string>
			{
				[KitExist] = "Набор с похожим названием уже существует",
				[KitCreate] = "Вы создали новый набор - {0}",
				[KitNotExist] = "Набор не найден",
				[KitRemoved] = "Набор {0} удалён",
				[AccessDenied] = "Доступ запрещён",
				[KitLimit] = "Достигнут лимит использования",
				[KitCooldown] = "Вы сможете использовать этот набор после: {0}",
				[NotEnoughSpace] = "Невозможно получить набор. Не достаточно места в инвентаре",
				[KitClaimed] = "Вы получили набор - {0}",
				[NotifyTitle] = "KITS",
				[Close] = "✕",
				[MainTitle] = "НАБОРЫ",
				[Back] = "Назад",
				[Next] = "Вперёд",
				[NotAvailableKits] = "ДЛЯ ВАС НЕТ ДОСТУПНЫХ НАБОРОВ :(",
				[CreateKit] = "+ СОЗДАТЬ НАБОР",
				[ListKits] = "Список наборов",
				[ShowAll] = "Показать все",
				[KitInfo] = "i",
				[KitTake] = "Получить",
				[ComeBack] = "Назад",
				[Edit] = "+ РЕДАКТИРОВАТЬ",
				[ContainerMain] = "Основной",
				[ContainerWear] = "Одежда",
				[ContainerBelt] = "Пояс",
				[CreateOrEditKit] = "Создать/Изменить Набор",
				[EnableKit] = "Включить",
				[AutoKit] = "Автокит",
				[EnabledSale] = "Включить продажу",
				[SaveKit] = "Сохранить набор",
				[CopyItems] = "Копировать предметы из инвентаря",
				[RemoveKit] = "Удалить набор",
				[EditingTitle] = "Редактирование предмета",
				[ItemName] = "Item",
				[CmdName] = "Command",
				[BtnSelect] = "Выбрать",
				[BluePrint] = "Blueprint",
				[BtnSave] = "Сохранить",
				[ItemSearch] = "Поиск предмета",
				[BtnClose] = "ЗАКРЫТЬ",
				[KitAvailableTitle] = "НАБОР ДОСТУПЕН\nДЛЯ ПОЛУЧЕНИЯ",
				[KitsList] = "Список наборов: {0}",
				[KitsHelp] =
					"ИНФОРМАЦИЯ О НАБОРАх\n- /{0} help - получить информацию о наборах\n- /{0} list - получить список доступных наборов\n- /{0} [name] - получить набор",
				[KitNotFound] = "Набор '{0}' не найден",
				[RemoveItem] = "✕",
				[NoPermission] = "У вас нет прав на получение этого набора",
				[BuildError] = "Здесть невозможность установить строение",
				[BBlocked] = "Получение набора в Building Block запрещено!",
				[NoPermissionDescription] = "КУПИТЕ ЭТОТ НАБОР НА\nSERVERNAME.GG",
				[PriceFormat] = "{0}$",
				[NotMoney] = "У вас недостаточно денег!",
				[NoEscapeRaidBlocked] = "У вас блокировка рейда! Вы не можете взять этот набор",
				[NoEscapeCombatBlocked] = "У вас блокировка боя! Вы не можете взять этот набор",
				[ChangeAutoKitOn] = "Вы включили автокиты",
				[ChangeAutoKitOff] = "Вы выключили автокиты",
				[EditRemoveField] = "✕",
				[KitYouHave] = "У ВАС ЕСТЬ",
				[KitShowInfo] = "ПОКАЗАТЬ ИНФО",
				[NoILError] = "Плагин работает некорректно, свяжитесь с администратором!",
				[UI_MeventRust_InfoKit_Title] = "СОДЕРЖИМОЕ НАБОРА"
			}, this, "ru");

			lang.RegisterMessages(new Dictionary<string, string>
			{
				[KitExist] = "Kit mit dem gleichen Namen existiert bereits",
				[KitCreate] = "Sie haben einen neuen Kit erstellt - {0}",
				[KitNotExist] = "Dieser Kit existiert nicht",
				[KitRemoved] = "Kit {0} wurde entfernt",
				[AccessDenied] = "Zugriff verweigert",
				[KitLimit] = "Nutzungslimit erreicht",
				[KitCooldown] = "Sie können diesen Kit nach verwenden: {0}",
				[NotEnoughSpace] = "Kit kann nicht eingelöst werden. Nicht genügend Platz",
				[KitClaimed] = "Sie haben den Kit beansprucht - {0}",
				[NotifyTitle] = "KITS",
				[Close] = "✕",
				[MainTitle] = "KITS",
				[Back] = "Zurück",
				[Next] = "Weiter",
				[NotAvailableKits] = "KEINE KITS FÜR SIE VERFÜGBAR :(",
				[CreateKit] = "+ ADD KIT",
				[ListKits] = "Liste der Kits",
				[ShowAll] = "Alle anzeigen",
				[KitInfo] = "i",
				[KitTake] = "Nehmen",
				[ComeBack] = "Zurück",
				[Edit] = "+ EDIT KIT",
				[ContainerMain] = "Hauptinventar",
				[ContainerWear] = "Ausrüstung",
				[ContainerBelt] = "Gürtel",
				[CreateOrEditKit] = "Kit erstellen/bearbeiten",
				[EnableKit] = "Kit aktivieren",
				[AutoKit] = "Auto-Kit",
				[EnabledSale] = "Verkauf aktivieren",
				[SaveKit] = "Kit speichern",
				[CopyItems] = "Gegenstände aus Inventar kopieren",
				[RemoveKit] = "Kit entfernen",
				[EditingTitle] = "Gegenstand bearbeiten",
				[ItemName] = "Gegenstand",
				[CmdName] = "Befehl",
				[BtnSelect] = "Auswählen",
				[BluePrint] = "Blaupause",
				[BtnSave] = "Speichern",
				[ItemSearch] = "Gegenstandsuche",
				[BtnClose] = "SCHLIESSEN",
				[KitAvailableTitle] = "KIT VERFÜGBAR\nZUR ENTNAHME",
				[KitsList] = "Liste der Kits: {0}",
				[KitsHelp] =
					"HILFE ZU KITS\n- /{0} help - Hilfe zu Kits erhalten\n- /{0} list - Liste der verfügbaren Kits erhalten\n- /{0} [name] - Kit erhalten",
				[KitNotFound] = "Kit '{0}' nicht gefunden",
				[RemoveItem] = "✕",
				[NoPermission] = "Sie haben keine Berechtigung, diesen Kit zu erhalten",
				[BuildError] = "Gebäude kann hier nicht platziert werden",
				[BBlocked] = "Aktion während Baublock nicht möglich.",
				[NoPermissionDescription] = "KAUFEN SIE DIESEN KIT AUF\nSERVERNAME.GG",
				[PriceFormat] = "{0}$",
				[NotMoney] = "Sie haben nicht genug Geld!",
				[NoEscapeRaidBlocked] = "Sie können diesen Kit nicht nehmen, wenn Sie im Raidblock sind",
				[NoEscapeCombatBlocked] = "Sie können diesen Kit nicht nehmen, wenn Sie im Kampfblock sind",
				[ChangeAutoKitOn] = "Sie haben Auto-Kits aktiviert",
				[ChangeAutoKitOff] = "Sie haben Auto-Kits deaktiviert",
				[EditRemoveField] = "✕",
				[KitYouHave] = "SIE HABEN",
				[KitShowInfo] = "Info anzeigen",
				[NoILError] = "Das Plugin funktioniert nicht korrekt, kontaktieren Sie den Administrator!",
				[UI_MeventRust_InfoKit_Title] = "KIT-INHALT"
			}, this, "de");

			lang.RegisterMessages(new Dictionary<string, string>
			{
				[KitExist] = "Kit avec le même nom existe déjà",
				[KitCreate] = "Vous avez créé un nouveau kit - {0}",
				[KitNotExist] = "Ce kit n'existe pas",
				[KitRemoved] = "Le kit {0} a été supprimé",
				[AccessDenied] = "Accès refusé",
				[KitLimit] = "Limite d'utilisation atteinte",
				[KitCooldown] = "Vous pourrez utiliser ce kit après : {0}",
				[NotEnoughSpace] = "Impossible de récupérer le kit. Pas assez d'espace",
				[KitClaimed] = "Vous avez réclamé le kit - {0}",
				[NotifyTitle] = "KITS",
				[Close] = "✕",
				[MainTitle] = "KITS",
				[Back] = "Retour",
				[Next] = "Suivant",
				[NotAvailableKits] = "PAS DE KITS DISPONIBLES POUR VOUS :(",
				[CreateKit] = "+ ADD KIT",
				[ListKits] = "Liste des kits",
				[ShowAll] = "Tout afficher",
				[KitInfo] = "i",
				[KitTake] = "Prendre",
				[ComeBack] = "Retour",
				[Edit] = "+ EDIT KIT",
				[ContainerMain] = "Principal",
				[ContainerWear] = "Équipement",
				[ContainerBelt] = "Ceinture",
				[CreateOrEditKit] = "Créer/Modifier un kit",
				[EnableKit] = "Activer le kit",
				[AutoKit] = "Kit auto",
				[EnabledSale] = "Activer la vente",
				[SaveKit] = "Enregistrer le kit",
				[CopyItems] = "Copier les objets de l'inventaire",
				[RemoveKit] = "Supprimer le kit",
				[EditingTitle] = "Modification de l'objet",
				[ItemName] = "Objet",
				[CmdName] = "Commande",
				[BtnSelect] = "Sélectionner",
				[BluePrint] = "Blueprint",
				[BtnSave] = "Enregistrer",
				[ItemSearch] = "Recherche d'objet",
				[BtnClose] = "FERMER",
				[KitAvailableTitle] = "KIT DISPONIBLE\nPOUR RÉCUPÉRATION",
				[KitsList] = "Liste des kits : {0}",
				[KitsHelp] =
					"AIDE SUR LES KITS\n- /{0} help - obtenir de l'aide sur les kits\n- /{0} list - obtenir la liste des kits disponibles\n- /{0} [name] - obtenir le kit",
				[KitNotFound] = "Kit '{0}' introuvable",
				[RemoveItem] = "✕",
				[NoPermission] = "Vous n'avez pas la permission d'obtenir ce kit",
				[BuildError] = "Impossible de placer le bâtiment ici",
				[BBlocked] = "Impossible d'effectuer cette action pendant le blocage de construction.",
				[NoPermissionDescription] = "ACHETEZ CE KIT SUR\nSERVERNAME.GG",
				[PriceFormat] = "{0}$",
				[NotMoney] = "Vous n'avez pas assez d'argent !",
				[NoEscapeRaidBlocked] = "Vous ne pouvez pas prendre ce kit lorsque vous êtes bloqué en raid",
				[NoEscapeCombatBlocked] = "Vous ne pouvez pas prendre ce kit lorsque vous êtes bloqué au combat",
				[ChangeAutoKitOn] = "Vous avez activé les kits automatiques",
				[ChangeAutoKitOff] = "Vous avez désactivé les kits automatiques",
				[EditRemoveField] = "✕",
				[KitYouHave] = "VOUS AVEZ",
				[KitShowInfo] = "Afficher les infos",
				[NoILError] = "Le plugin ne fonctionne pas correctement, contactez l'administrateur !",
				[UI_MeventRust_InfoKit_Title] = "CONTENU DU KIT"
			}, this, "fr");
		}

		private string Msg(string key, string userid = null, params object[] obj)
		{
			return string.Format(lang.GetMessage(key, this, userid), obj);
		}

		private string Msg(BasePlayer player, string key, params object[] obj)
		{
			return string.Format(lang.GetMessage(key, this, player.UserIDString), obj);
		}

		private void Reply(BasePlayer player, string key, params object[] obj)
		{
			SendReply(player, Msg(key, player.UserIDString, obj));
		}

		private string Msg(BasePlayer player, string kitName, string key, params object[] obj)
		{
			if (_config.CustomTitles.Enabled)
				if (_config.CustomTitles.KitTitles.TryGetValue(kitName, out var kitTitle) && kitTitle.Enabled)
					if (kitTitle.Titles.TryGetValue(key, out var titleConf) && titleConf.Enabled)
					{
						var msg = titleConf.GetMessage(player);
						if (!string.IsNullOrEmpty(msg)) return string.Format(msg, obj);
					}

			return Msg(player, key, obj);
		}

		private void SendNotify(BasePlayer player, string key, int type, params object[] obj)
		{
			if (_config.UseNotify && (Notify != null || UINotify != null))
				Interface.Oxide.CallHook("SendNotify", player, type, Msg(player, key, obj));
			else
				Reply(player, key, obj);
		}

		private void SendNotifyOrUI(BasePlayer player, string key, int type, bool chat, params object[] obj)
		{
			if (_config.UseNotify && (Notify != null || UINotify != null))
				Interface.Oxide.CallHook("SendNotify", player, type, Msg(player, key, obj));
			else if (chat)
				Reply(player, key, obj);
			else
				ErrorUi(player, Msg(player, key, obj));
		}

		private void SendMessageToNotifyOrUI(BasePlayer player, string message, int type, bool chat)
		{
			if (_config.UseNotify && (Notify != null || UINotify != null))
				Interface.Oxide.CallHook("SendNotify", player, type, message);
			else if (chat)
				SendReply(player, message);
			else
				ErrorUi(player, message);
		}

		#endregion

		#region API

		private bool TryClaimKit(BasePlayer player, string name, bool usingUI)
		{
			return !string.IsNullOrEmpty(name) &&
			       GiveKitToPlayer(player, FindKitByName(name), usingUI: usingUI);
		}

		private void GetKitNames(List<string> list)
		{
			list.AddRange(GetAllKits());
		}

		private string[] GetAllKits()
		{
			return _data.Kits.Select(kit => kit.Name).ToArray();
		}

		private object GetKitInfo(string name)
		{
			var kit = FindKitByName(name);
			if (kit == null) return null;

			var obj = new JObject
			{
				["name"] = kit.Name,
				["permission"] = kit.Permission,
				["max"] = kit.Amount,
				["image"] = kit.Image,
				["hide"] = kit.Hide,
				["description"] = kit.Description,
				["cooldown"] = kit.Cooldown,
				["building"] = kit.Building,
				["authlevel"] = 0,
				["items"] = new JArray(kit.Items.Select(itemData => new JObject
				{
					["amount"] = itemData.Amount,
					["container"] = itemData.Container,
					["itemid"] = itemData.itemId,
					["skinid"] = itemData.SkinID,
					["weapon"] = !string.IsNullOrEmpty(itemData.Weapon?.ammoType),
					["blueprint"] = itemData.Blueprint,
					["mods"] = new JArray(itemData.Content?.Select(x =>
						ItemManager.FindItemDefinition(x.ShortName).itemid) ?? new List<int>())
				}))
			};

			return obj;
		}

		private string[] GetKitContents(string name)
		{
			var kit = FindKitByName(name);
			if (kit == null) return null;

			var items = new List<string>();
			foreach (var item in kit.Items)
			{
				var itemstring = $"{item.ShortName}_{item.Amount}";
				if (item.Content.Count > 0)
					itemstring = item.Content.Aggregate(itemstring, (current, mod) => current + $"_{mod.ShortName}");

				items.Add(itemstring);
			}

			return items.ToArray();
		}

		private double GetKitCooldown(string name)
		{
			return FindKitByName(name)?.Cooldown ?? 0;
		}

		private double PlayerKitCooldown(ulong ID, string name)
		{
			return PlayerData.GetNotLoadKitData(ID.ToString(), name)?.Cooldown ?? 0.0;
		}

		private int KitMax(string name)
		{
			return FindKitByName(name)?.Amount ?? 0;
		}

		private double PlayerKitMax(ulong ID, string name)
		{
			return PlayerData.GetNotLoadKitData(ID.ToString(), name)?.Amount ?? 0;
		}

		private string KitImage(string name)
		{
			return FindKitByName(name)?.Image ?? string.Empty;
		}

		private string GetKitImage(string name)
		{
			return KitImage(name);
		}

		private string GetKitDescription(string name)
		{
			return FindKitByName(name)?.Description ?? string.Empty;
		}

		private int GetKitMaxUses(string name)
		{
			return FindKitByName(name)?.Amount ?? 0;
		}

		private int GetPlayerKitUses(ulong userId, string name)
		{
			return GetPlayerKitUses(userId.ToString(), name);
		}

		private int GetPlayerKitUses(string userId, string name)
		{
			var kitData = PlayerData.GetNotLoadKitData(userId, name);
			return kitData?.Amount ?? 0;
		}

		private void SetPlayerKitUses(ulong userId, string name, int amount)
		{
			var data = PlayerData.GetOrCreateKitData(userId.ToString(), name);
			if (data == null) return;

			data.Amount = amount;
		}

		private double GetPlayerKitCooldown(string userId, string name)
		{
			return GetPlayerKitCooldown(ulong.Parse(userId), name);
		}

		private double GetPlayerKitCooldown(ulong userId, string name)
		{
			var data = PlayerData.GetNotLoadKitData(userId.ToString(), name);
			if (data == null) return 0;

			return Mathf.Max((float) (data.Cooldown - GetCurrentTime()), 0f);
		}

		private bool IsKitCooldown(Kit kit, PlayerData.KitData playerData, double currentTime, out bool cooldown,
			out bool wipeBlock)
		{
			wipeBlock = false;
			cooldown = kit.Cooldown > 0 && playerData.Cooldown > currentTime;
			if (cooldown)
				return true;

			wipeBlock = kit.CooldownAfterWipe > 0 && LeftWipeBlockTime(kit.CooldownAfterWipe) > 0;
			return wipeBlock;
		}

		private TimeSpan GetCooldownTimeRemaining(Kit kit, PlayerData.KitData playerData, double currentTime,
			bool isCooldown)
		{
			return isCooldown ? TimeSpan.FromSeconds(playerData.Cooldown - currentTime) : TimeSpan.FromSeconds(LeftWipeBlockTime(kit.CooldownAfterWipe));
		}

		private bool GiveKit(BasePlayer player, string name, bool usingUI)
		{
#if TESTING
			Puts($"[GiveKit] player={player?.UserIDString}, name={name}, usingUI={usingUI}");
#endif
			return GiveKitToPlayer(player, FindKitByName(name), true, usingUI: usingUI);
		}

		private bool isKit(string name)
		{
			return IsKit(name);
		}

		private bool IsKit(string name)
		{
			return _data.Kits.Exists(x => x.Name == name);
		}

		private bool HasKitAccess(string userId, string name)
		{
			var kit = FindKitByName(name);
			return kit != null && userId.HasPermission(kit.Permission);
		}

		private int GetPlayerKitAmount(string userId, string name)
		{
			var kit = FindKitByName(name);
			if (kit == null)
				return 0;

			var playerData = PlayerData.GetNotLoadKitData(userId, name);
			if (playerData is {HasAmount: > 0})
				return playerData.HasAmount;

			return 0;
		}

		private JObject GetKitObject(string name)
		{
			return FindKitByName(name)?.ToJObject;
		}

		private IEnumerable<Item> CreateKitItems(string name)
		{
			var kit = FindKitByName(name);
			if (kit == null) yield break;
			
			foreach (var kitItem in kit.Items.FindAll(kitItem => kitItem.Type == KitItemType.Item))
				yield return kitItem.BuildItem();
		}
		
		private CuiElementContainer API_OpenPlugin(BasePlayer player)
		{
			RemoveOpenedKits(player.userID);
			
			TryCreateOpenedKits(player, out _, false);
			
			var container  = new CuiElementContainer();
            
			#region Background

			container.Add(new CuiPanel()
			{
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
				Image = {Color = "0 0 0 0"}
			}, "UI.Server.Panel.Content", "UI.Server.Panel.Content.Plugin", "UI.Server.Panel.Content.Plugin");

			container.Add(new CuiPanel()
			{
				RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
				Image = {Color = "0 0 0 0"}
			}, "UI.Server.Panel.Content.Plugin", Layer + ".Background", Layer + ".Background");

			#endregion

			#region Main
			
			container.Add(new CuiPanel
			{
				RectTransform =
				{
					AnchorMin = "0 0", AnchorMax = "1 1"
				},
				Image =
				{
					Color = "0 0 0 0"
				}
			}, Layer + ".Background", Layer + ".Main", Layer + ".Main");
			
			MainKitsHeader(player, container);

			MainKitsContentUI(player, container);
			
			MainKitsDescriptionUI(player, ref container);

			#endregion
			
			return container;
		}
		
		#endregion

		#region Convert

		#region uMod Kits

		[ConsoleCommand("kits.convert")]
		private void OldKitsConvert(ConsoleSystem.Arg arg)
		{
			if (!arg.IsAdmin) return;

			OldData oldKits = null;

			try
			{
				oldKits = Interface.Oxide.DataFileSystem.ReadObject<OldData>("Kits/kits_data");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			var amount = 0;

			oldKits?._kits.ToList().ForEach(oldKit =>
			{
				var kit = new Kit
				{
					ID = ++_lastKitID,
					Name = oldKit.Value.Name,
					DisplayName = oldKit.Value.Name,
					Permission = oldKit.Value.RequiredPermission,
					Amount = oldKit.Value.MaximumUses,
					Cooldown = oldKit.Value.Cooldown,
					Description = oldKit.Value.Description,
					Hide = oldKit.Value.IsHidden,
					Building = oldKit.Value.CopyPasteFile,
					Image = oldKit.Value.KitImage,
					Color = _config.KitColor,
					ShowInfo = true,
					Items = new List<KitItem>()
				};

				foreach (var item in oldKit.Value.MainItems)
					kit.Items.Add(KitItem.FromOld(item, "main"));

				foreach (var item in oldKit.Value.WearItems)
					kit.Items.Add(KitItem.FromOld(item, "wear"));

				foreach (var item in oldKit.Value.BeltItems)
					kit.Items.Add(KitItem.FromOld(item, "belt"));

				_data.Kits.Add(kit);

				var kitIndex = _data.Kits.IndexOf(kit);

				_kitByName[kit.Name] = kitIndex;
				_kitByID[kit.ID] = kitIndex;

				amount++;
			});

			Puts($"{amount} kits was converted!");

			SaveKits();
		}

		private class OldData
		{
			[JsonProperty] public Dictionary<string, OldKitsData> _kits = new(StringComparer.OrdinalIgnoreCase);
		}

		private class OldKitsData
		{
			public string Name;
			public string Description;
			public string RequiredPermission;

			public int MaximumUses;
			public int RequiredAuth;
			public int Cooldown;
			public int Cost;

			public bool IsHidden;

			public string CopyPasteFile;
			public string KitImage;

			public ItemData[] MainItems;
			public ItemData[] WearItems;
			public ItemData[] BeltItems;
		}

		private class ItemData
		{
			public string Shortname;

			public ulong Skin;

			public int Amount;

			public float Condition;

			public float MaxCondition;

			public int Ammo;

			public string Ammotype;

			public int Position;

			public int Frequency;

			public string BlueprintShortname;

			public ItemData[] Contents;
		}

		#endregion

		#region Old Data

		private void StartConvertOldData()
		{
			var data = LoadOldData();
			if (data != null)
				timer.In(0.3f, () =>
				{
					ConvertOldData(data);

					PrintWarning($"{data.Count} players was converted!");
				});
		}

		private Dictionary<ulong, Dictionary<string, OldKitData>> LoadOldData()
		{
			Dictionary<ulong, Dictionary<string, OldKitData>> players = null;
			try
			{
				players =
					Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, OldKitData>>>(
						$"{Name}/Data");
			}
			catch (Exception e)
			{
				PrintError(e.ToString());
			}

			return players ?? new Dictionary<ulong, Dictionary<string, OldKitData>>();
		}

		private void ConvertOldData(Dictionary<ulong, Dictionary<string, OldKitData>> players)
		{
			foreach (var check in players)
			{
				var userId = check.Key.ToString();

				var data = PlayerData.GetOrCreate(userId);

				foreach (var kitData in check.Value)
					data.Kits[kitData.Key] = new PlayerData.KitData
					{
						Amount = kitData.Value.Amount,
						Cooldown = kitData.Value.Cooldown,
						HasAmount = kitData.Value.HasAmount
					};

				PlayerData.SaveAndUnload(userId);
			}
		}

		#region Classes

		private class OldKitData
		{
			public int Amount;

			public double Cooldown;

			public int HasAmount;
		}

		#endregion

		#endregion

		#endregion

		#region Player Data

		private Dictionary<string, PlayerData> _usersData = new();

		private class PlayerData
		{
			#region Main

			#region Fields

			[JsonProperty(PropertyName = "Kits Data", ObjectCreationHandling = ObjectCreationHandling.Replace)]
			public Dictionary<string, KitData> Kits = new();

			#endregion

			#region Classes

			public class KitData
			{
				[JsonProperty(PropertyName = "Amount")]
				public int Amount;

				[JsonProperty(PropertyName = "Cooldown")]
				public double Cooldown;

				[JsonProperty(PropertyName = "HasAmount")]
				public int HasAmount;
			}

			#endregion

			#endregion

			#region Helpers

			private static string BaseFolder()
			{
				return "Kits" + Path.DirectorySeparatorChar + "Players" + Path.DirectorySeparatorChar;
			}

			public static PlayerData GetOrLoad(string userId)
			{
				if (!userId.IsSteamId()) return null;

				return GetOrLoad(BaseFolder(), userId);
			}

			public static KitData GetOrLoadKitData(string userId,
				string kitName,
				bool addKit = true)
			{
				var data = GetOrLoad(userId);
				if (data == null) return null;

				if (data.Kits.TryGetValue(kitName, out var kitData))
					return kitData;

				return
					addKit
						? data.Kits[kitName] = new KitData()
						: null;
			}


			private static PlayerData GetOrLoad(string baseFolder, string userId, bool load = true)
			{
				if (_instance._usersData.TryGetValue(userId, out var data)) return data;

				try
				{
					data = ReadOnlyObject(baseFolder + userId);
				}
				catch (Exception e)
				{
					Interface.Oxide.LogError(e.ToString());
				}

				return load
					? _instance._usersData[userId] = data
					: data;
			}

			public static PlayerData GetOrCreate(string userId)
			{
				if (!userId.IsSteamId()) return null;

				return GetOrLoad(userId) ?? (_instance._usersData[userId] = new PlayerData());
			}

			public static KitData GetOrCreateKitData(string userId, string kitName)
			{
				var data = GetOrCreate(userId);
				if (data == null) return null;

				if (data.Kits.TryGetValue(kitName, out var kitData))
					return kitData;

				return data.Kits[kitName] = new KitData();
			}

			public static void Save()
			{
				foreach (var userId in _instance._usersData.Keys)
					Save(userId);
			}

			public static void Save(string userId)
			{
				if (!_instance._usersData.TryGetValue(userId, out var data))
					return;

				Interface.Oxide.DataFileSystem.WriteObject(BaseFolder() + userId, data);
			}

			public static void SaveAndUnload(string userId)
			{
				Save(userId);

				Unload(userId);
			}

			public static void Unload(string userId)
			{
				_instance._usersData.Remove(userId);
			}

			#endregion

			#region Utils

			public static string[] GetFiles()
			{
				return GetFiles(BaseFolder());
			}

			public static string[] GetFiles(string baseFolder)
			{
				try
				{
					var json = ".json".Length;
					var paths = Interface.Oxide.DataFileSystem.GetFiles(baseFolder);
					for (var i = 0; i < paths.Length; i++)
					{
						var path = paths[i];
						var separatorIndex = path.LastIndexOf(Path.DirectorySeparatorChar);

						// We have to do this since GetFiles returns paths instead of filenames
						// And other methods require filenames
						paths[i] = path.Substring(separatorIndex + 1, path.Length - separatorIndex - 1 - json);
					}

					return paths;
				}
				catch
				{
					return Array.Empty<string>();
				}
			}

			private static PlayerData ReadOnlyObject(string name)
			{
				return Interface.Oxide.DataFileSystem.ExistsDatafile(name)
					? Interface.Oxide.DataFileSystem.GetFile(name).ReadObject<PlayerData>()
					: null;
			}

			#endregion

			#region Wipe

			public static void DoWipe(string userId, bool isWipe = true)
			{
				if (isWipe && _instance?._config?.SaveGivenKitsOnWipe == true)
				{
					var data = GetNotLoad(userId);
					if (data == null) return;

					data.Kits.RemoveAll((key, value) => value.HasAmount <= 0);

					if (data.Kits.Count > 0)
					{
						foreach (var kitData in data.Kits)
						{
							kitData.Value.Amount = 0;
							kitData.Value.Cooldown = 0;
						}

						Interface.Oxide.DataFileSystem.WriteObject(BaseFolder() + userId, data);
					}
					else
					{
						Interface.Oxide.DataFileSystem.DeleteDataFile(BaseFolder() + userId);
					}
				}
				else
				{
					Interface.Oxide.DataFileSystem.DeleteDataFile(BaseFolder() + userId);
				}
			}

			#endregion

			#region All Players

			public static void StartAll(Action<PlayerData> action)
			{
				var users = GetFiles(BaseFolder());

				foreach (var userId in users)
				{
					var loaded = _instance._usersData.ContainsKey(userId);

					var data = GetOrLoad(userId);
					if (data == null) continue;

					action.Invoke(data);

					Save(userId);

					if (!loaded)
						Unload(userId);
				}
			}

			public static List<PlayerData> GetAll()
			{
				var users = GetFiles(BaseFolder());

				var list = new List<PlayerData>();

				foreach (var userId in users)
				{
					var data = GetNotLoad(userId);
					if (data == null) continue;

					list.Add(data);
				}

				return list;
			}

			public static PlayerData GetNotLoad(string userId)
			{
				return GetOrLoad(BaseFolder(), userId, false);
			}

			public static KitData GetNotLoadKitData(string userId, string kitName)
			{
				var data = GetNotLoad(userId);
				return data?.Kits.GetValueOrDefault(kitName);
			}

			#endregion
		}

		#endregion

		#region Testing Functions

#if TESTING
		private static void SayDebug(string message)
		{
			Debug.Log($"[Kits] {message}");
		}

		[ConsoleCommand("kits.cui.debug")]
		private void CmdKitsCuiDebug(ConsoleSystem.Arg arg)
		{
			var steamID = new BasePlayer.EncryptedValue<ulong>();
			steamID.Set(76561197960839785UL);
			
			MainUi(new BasePlayer()
			{
				userID = steamID,
				UserIDString = steamID.ToString(),
				displayName = $"{steamID}",
			}, first: true);
		}
#endif

		#endregion
	}
}

#region Extension Methods

namespace Oxide.Plugins.KitsExtensionMethods
{
	// ReSharper disable ForCanBeConvertedToForeach
	// ReSharper disable LoopCanBeConvertedToQuery
	public static class ExtensionMethods
	{
		internal static Permission perm;

		public static bool IsURL(this string uriName)
		{
			return Uri.TryCreate(uriName, UriKind.Absolute, out var uriResult) &&
			       (uriResult.Scheme == Uri.UriSchemeHttp || uriResult.Scheme == Uri.UriSchemeHttps);
		}

		public static bool All<T>(this IList<T> a, Func<T, bool> b)
		{
			for (var i = 0; i < a.Count; i++)
				if (!b(a[i]))
					return false;
			return true;
		}

		public static int Average(this IList<int> a)
		{
			if (a.Count == 0) return 0;
			var b = 0;
			for (var i = 0; i < a.Count; i++) b += a[i];
			return b / a.Count;
		}

		public static T ElementAt<T>(this IEnumerable<T> a, int b)
		{
			using var c = a.GetEnumerator();
			while (c.MoveNext())
			{
				if (b == 0) return c.Current;
				b--;
			}

			return default;
		}

		public static bool Exists<T>(this IEnumerable<T> a, Func<T, bool> b = null)
		{
			using var c = a.GetEnumerator();
			while (c.MoveNext())
				if (b == null || b(c.Current))
					return true;

			return false;
		}

		public static T FirstOrDefault<T>(this IEnumerable<T> a, Func<T, bool> b = null)
		{
			using (var c = a.GetEnumerator())
			{
				while (c.MoveNext())
					if (b == null || b(c.Current))
						return c.Current;
			}

			return default;
		}

		public static int RemoveAll<T, V>(this IDictionary<T, V> a, Func<T, V, bool> b)
		{
			var c = new List<T>();
			using (var d = a.GetEnumerator())
			{
				while (d.MoveNext())
					if (b(d.Current.Key, d.Current.Value))
						c.Add(d.Current.Key);
			}

			c.ForEach(e => a.Remove(e));
			return c.Count;
		}

		public static IEnumerable<V> Select<T, V>(this IEnumerable<T> a, Func<T, V> b)
		{
			var c = new List<V>();
			using var d = a.GetEnumerator();
			while (d.MoveNext()) c.Add(b(d.Current));

			return c;
		}

		public static List<TResult> Select<T, TResult>(this List<T> source, Func<T, TResult> selector)
		{
			if (source == null || selector == null) return new List<TResult>();

			var r = new List<TResult>(source.Count);
			for (var i = 0; i < source.Count; i++) r.Add(selector(source[i]));

			return r;
		}

		public static List<T> SkipAndTake<T>(this List<T> source, int skip, int take)
		{
			var index = Mathf.Min(Mathf.Max(skip, 0), source.Count);
			return source.GetRange(index, Mathf.Min(take, source.Count - index));
		}

		public static string[] Skip(this string[] a, int count)
		{
			if (a.Length == 0) return Array.Empty<string>();
			var c = new string[a.Length - count];
			var n = 0;
			for (var i = 0; i < a.Length; i++)
			{
				if (i < count) continue;
				c[n] = a[i];
				n++;
			}

			return c;
		}

		public static List<T> Skip<T>(this IList<T> source, int count)
		{
			if (count < 0)
				count = 0;

			if (source == null || count > source.Count)
				return new List<T>();

			var result = new List<T>(source.Count - count);
			for (var i = count; i < source.Count; i++)
				result.Add(source[i]);
			return result;
		}

		public static Dictionary<T, V> Skip<T, V>(
			this IDictionary<T, V> source,
			int count)
		{
			var result = new Dictionary<T, V>();
			using var iterator = source.GetEnumerator();
			for (var i = 0; i < count; i++)
				if (!iterator.MoveNext())
					break;

			while (iterator.MoveNext()) result.Add(iterator.Current.Key, iterator.Current.Value);

			return result;
		}

		public static List<T> Take<T>(this IList<T> a, int b)
		{
			var c = new List<T>();
			for (var i = 0; i < a.Count; i++)
			{
				if (c.Count == b) break;
				c.Add(a[i]);
			}

			return c;
		}

		public static Dictionary<T, V> Take<T, V>(this IDictionary<T, V> a, int b)
		{
			var c = new Dictionary<T, V>();
			foreach (var f in a)
			{
				if (c.Count == b) break;
				c.Add(f.Key, f.Value);
			}

			return c;
		}

		public static Dictionary<T, V> ToDictionary<S, T, V>(this IEnumerable<S> a, Func<S, T> b, Func<S, V> c)
		{
			var d = new Dictionary<T, V>();
			using var e = a.GetEnumerator();
			while (e.MoveNext()) d[b(e.Current)] = c(e.Current);

			return d;
		}

		public static List<T> ToList<T>(this IEnumerable<T> a)
		{
			var b = new List<T>();
			using (var c = a.GetEnumerator())
			{
				while (c.MoveNext()) b.Add(c.Current);
			}

			return b;
		}

		public static HashSet<T> ToHashSet<T>(this IEnumerable<T> a)
		{
			return new HashSet<T>(a);
		}

		public static List<T> Where<T>(this List<T> source, Predicate<T> predicate)
		{
			if (source == null)
				return new List<T>();

			if (predicate == null)
				return new List<T>();

			return source.FindAll(predicate);
		}

		public static List<T> Where<T>(this List<T> source, Func<T, int, bool> predicate)
		{
			if (source == null)
				return new List<T>();

			if (predicate == null)
				return new List<T>();

			var r = new List<T>();
			for (var i = 0; i < source.Count; i++)
				if (predicate(source[i], i))
					r.Add(source[i]);
			return r;
		}

		public static List<T> Where<T>(this IEnumerable<T> source, Func<T, bool> predicate)
		{
			var c = new List<T>();

			using (var d = source.GetEnumerator())
			{
				while (d.MoveNext())
					if (predicate(d.Current))
						c.Add(d.Current);
			}

			return c;
		}

		public static List<T> OfType<T>(this IEnumerable<BaseNetworkable> a) where T : BaseEntity
		{
			var b = new List<T>();
			using var c = a.GetEnumerator();
			while (c.MoveNext())
				if (c.Current is T entity)
					b.Add(entity);

			return b;
		}

		public static int Sum<T>(this IList<T> a, Func<T, int> b)
		{
			var c = 0;
			for (var i = 0; i < a.Count; i++)
			{
				var d = b(a[i]);
				if (!float.IsNaN(d)) c += d;
			}

			return c;
		}

		public static T LastOrDefault<T>(this List<T> source)
		{
			if (source == null || source.Count == 0)
				return default;

			return source[^1];
		}

		public static int Count<T>(this List<T> source, Func<T, bool> predicate)
		{
			if (source == null)
				return 0;

			if (predicate == null)
				return 0;

			var count = 0;
			for (var i = 0; i < source.Count; i++)
				checked
				{
					if (predicate(source[i])) count++;
				}

			return count;
		}

		public static TAccumulate Aggregate<TSource, TAccumulate>(this List<TSource> source, TAccumulate seed,
			Func<TAccumulate, TSource, TAccumulate> func)
		{
			if (source == null) throw new Exception("Aggregate: source is null");

			if (func == null) throw new Exception("Aggregate: func is null");

			var result = seed;
			for (var i = 0; i < source.Count; i++) result = func(result, source[i]);
			return result;
		}

		public static int Sum(this IList<int> a)
		{
			var c = 0;
			for (var i = 0; i < a.Count; i++)
			{
				var d = a[i];
				if (!float.IsNaN(d)) c += d;
			}

			return c;
		}

		public static bool HasPermission(this string userID, string b)
		{
			perm ??= Interface.Oxide.GetLibrary<Permission>();
			return !string.IsNullOrEmpty(userID) && (string.IsNullOrEmpty(b) || perm.UserHasPermission(userID, b));
		}

		public static bool HasPermission(this BasePlayer a, string b)
		{
			return a.UserIDString.HasPermission(b);
		}

		public static bool HasPermission(this ulong a, string b)
		{
			return a.ToString().HasPermission(b);
		}

		public static bool IsReallyConnected(this BasePlayer a)
		{
			return a.IsReallyValid() && a.net.connection != null;
		}

		public static bool IsKilled(this BaseNetworkable a)
		{
			return (object) a == null || a.IsDestroyed;
		}

		public static bool IsNull<T>(this T a) where T : class
		{
			return a == null;
		}

		public static bool IsNull(this BasePlayer a)
		{
			return (object) a == null;
		}

		public static bool IsReallyValid(this BaseNetworkable a)
		{
			return !((object) a == null || a.IsDestroyed || a.net == null);
		}

		public static void SafelyKill(this BaseNetworkable a)
		{
			if (a.IsKilled()) return;
			a.Kill();
		}

		public static bool CanCall(this Plugin o)
		{
			return o is {IsLoaded: true};
		}

		public static bool IsInBounds(this OBB o, Vector3 a)
		{
			return o.ClosestPoint(a) == a;
		}

		public static bool IsHuman(this BasePlayer a)
		{
			return !(a.IsNpc || !a.userID.IsSteamId());
		}

		public static BasePlayer ToPlayer(this IPlayer user)
		{
			return user.Object as BasePlayer;
		}

		public static List<TResult> SelectMany<TSource, TResult>(this List<TSource> source,
			Func<TSource, List<TResult>> selector)
		{
			if (source == null || selector == null)
				return new List<TResult>();

			var result = new List<TResult>(source.Count);
			source.ForEach(i => selector(i).ForEach(j => result.Add(j)));
			return result;
		}

		public static IEnumerable<TResult> SelectMany<TSource, TResult>(
			this IEnumerable<TSource> source,
			Func<TSource, IEnumerable<TResult>> selector)
		{
			using var item = source.GetEnumerator();
			while (item.MoveNext())
			{
				using var result = selector(item.Current).GetEnumerator();
				while (result.MoveNext()) yield return result.Current;
			}
		}

		public static int Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			var sum = 0;

			using var element = source.GetEnumerator();
			while (element.MoveNext()) sum += selector(element.Current);

			return sum;
		}

		public static double Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			var sum = 0.0;

			using var element = source.GetEnumerator();
			while (element.MoveNext()) sum += selector(element.Current);

			return sum;
		}

		public static bool Any<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null) return false;

			using var element = source.GetEnumerator();
			while (element.MoveNext())
				if (predicate(element.Current))
					return true;

			return false;
		}
		
		public static string GetFieldTitle<T>(this string field)
		{
			var fieldInfo = typeof(T).GetField(field);
			if (fieldInfo == null) return field;

			var jsonAttribute = fieldInfo.GetCustomAttribute<JsonPropertyAttribute>();
			return jsonAttribute == null ? field : jsonAttribute.PropertyName;
		}
	}
}

#endregion Extension Methods

// --- End of file: Kits3.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoBowRaid.cs ---
// --- Original Local Path: NoBowRaid.cs ---

using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using System;
using Oxide.Core;
namespace Oxide.Plugins
{
    [Info("NoBowRaid", "Bamabo", "1.0.1")]
    [Description("Gets rid of one of the most broken mechanics in Rust")]

    class NoBowRaid : RustPlugin
    {
        private List<string> whitelist;
        private bool adminBypass;
        private bool ignoreTwig;
        private bool usePermissions;
        private float damageScale;
        void Init()
        {
            adminBypass = (bool)Config["adminBypass"];
            damageScale = Convert.ToSingle(Config["damageScale"]);
            ignoreTwig = (bool)Config["ignoreTwig"];
            usePermissions = (bool)Config["usePermissions"];
            if(usePermissions)
                permission.RegisterPermission("nobowraid.bypass", this);
            whitelist = Interface.Oxide.DataFileSystem.ReadObject<List<string>>("NoBowRaid_Whitelist");
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null)
                return;
            if (info == null)
                return;
            BasePlayer attacker = null;
            attacker = info?.Initiator?.ToPlayer();


            if (attacker)
            {

                if (usePermissions)
                    if (permission.UserHasPermission(attacker.UserIDString, "nobowraid.bypass"))
                        return;
                if (attacker.IsAdmin() && adminBypass)
                    return;
                string weapon = info.Weapon.name.ToString();
                if (weapon.Contains("bow_hunting.entity") || weapon.Contains("crossbow.entity"))
                {
                    BuildingBlock block = null;

                    if (entity.GetComponent<BuildingBlock>() != null)
                        block = entity.GetComponent<BuildingBlock>();

                    if (!whitelist.Any(entity.name.Contains) && !block)
                        info.damageTypes.ScaleAll(damageScale);

                    if (block)
                    {
                        if (block.grade.ToString().Equals("Twigs") && ignoreTwig)
                            return;

                        info.damageTypes.ScaleAll(damageScale);
                    }

                }
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file for NoBowRaid");
            Config.Clear();
            var defaultWhitelist = new List<object>() { "player", "animal" };
            Interface.Oxide.DataFileSystem.WriteObject("NoBowRaid_Whitelist", defaultWhitelist);
            Config["adminBypass"] = false;
            Config["damageScale"] = 0f;
            Config["ignoreTwig"] = true;
            Config["usePermissions"] = false;
            SaveConfig();
        }
    }
}

// --- End of file: NoBowRaid.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AlwaysDay.cs ---
// --- Original Local Path: AlwaysDay.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Always Day", "Orange", "1.0.1")]
    [Description("Stops time on your server at one time")]
    public class AlwaysDay : RustPlugin
    {
        #region Vars

        private TOD_Time time;

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            time = UnityEngine.Object.FindObjectOfType<TOD_Time>();
            time.ProgressTime = false;
            Server.Command($"env.time {config.time}");
        }

        private void Unload()
        {
            time.ProgressTime = true;
        }

        #endregion
        
        #region Configuration 1.1.2

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Time")]
            public string time;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                time =  "12"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                
                timer.Every(10f, () =>
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                });
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: AlwaysDay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MiniPanel.cs ---
// --- Original Local Path: MiniPanel.cs ---

﻿using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Дополнительное GUI", "BadMandarin", "1.0.1")]
    [Description("Дополнительное GUI")]
    class MiniPanel : RustPlugin
    {
        #region Classes
        private class PluginConfig
        {
            [JsonProperty("Гл.Анчор панельки")]
            public string PanelAnchor;

            [JsonProperty("Гл.Офсет панельки (Min)")]
            public string PanelOffsetMin;
            [JsonProperty("Гл.Офсет панельки (Max)")]
            public string PanelOffsetMax;

            [JsonProperty("Гл.Текст панельки")]
            public string PanelText;
            [JsonProperty("Гл.Цвет текста")]
            public string PanelColor;
            [JsonProperty("Гл.Прозрачность текста")]
            public float PanelAlpha;
            [JsonProperty("Гл.Команда")]
            public string PanelCmd;

            [JsonProperty("Стрелочка (Цвет)")]
            public string ArrowColor;
            [JsonProperty("Стрелочка включена? (1 - да, 0 - нет)")]
            public bool ArrowMode;

            [JsonProperty("Больше панелей")]
            public List<AddtionalPanel> _listPanels = new List<AddtionalPanel>();
        }

        private class AddtionalPanel
        {
            [JsonProperty("Анчор панельки")]
            public string PanelAnchor;
            [JsonProperty("Офсет панельки (Min)")]
            public string PanelOffsetMin;
            [JsonProperty("Офсет панельки (Max)")]
            public string PanelOffsetMax;
            [JsonProperty("Картинка")]
            public string PanelImageUrl;
            [JsonProperty("Команда")]
            public string PanelCmd;
        }
        #endregion

        #region Variables
        private string UI_Layer = "UI_Panelka";
        private PluginConfig config;
        private Dictionary<ulong, bool> _playerInfo = new Dictionary<ulong, bool>();
        #endregion

        #region OxideHooks
        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        void Unload()
        {
            foreach(var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, UI_Layer);
            }
        }
            

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }
        
        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                Draw_UIMain(player, config.PanelAnchor);
            }
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            Draw_UIMain(player, config.PanelAnchor);
        }
        #endregion

        #region Interface
        private void Draw_UIMain(BasePlayer player, string MainPosition = "0.01 0.99")
        {
            if (player == null) return;

            if (!_playerInfo.ContainsKey(player.userID))
                _playerInfo.Add(player.userID, false);

            CuiElementContainer container = new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        CursorEnabled = false,
                        RectTransform = { AnchorMin = MainPosition, AnchorMax = MainPosition, OffsetMin = config.PanelOffsetMin, OffsetMax = config.PanelOffsetMax },
                        
                        Image = { Color = GetColor("#E6E6E6", 0f) }
                    },
                    "Overlay", UI_Layer
                },
                new CuiElement
                {
                    Parent = UI_Layer,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = config.PanelText,
                            Align = TextAnchor.UpperLeft,
                            Font = "robotocondensed-bold.ttf",
                            Color = GetColor(config.PanelColor, config.PanelAlpha)
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = $"0 0",
                            AnchorMax = $"1 1"
                        }
                    }
                },
                {
                    new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Color = "0 0 0 0", Command = config.PanelCmd },
                        Text = { Text = "" }
                    },
                    UI_Layer
                }
            };
            if(config._listPanels.Count() < 1)
            {
                CuiHelper.DestroyUi(player, UI_Layer);
                CuiHelper.AddUi(player, container);
                return;
            }
            if (config.ArrowMode)
            {
                container.Add(new CuiElement
                {
                    Parent = UI_Layer,
                    Name = UI_Layer + $".Toggle",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = _playerInfo[player.userID]?"<size=26>▶</size>":"<size=26>◀</size>",
                            Align = TextAnchor.MiddleCenter,
                            Color = GetColor(config.ArrowColor),
                            Font = "robotocondensed-bold.ttf"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "1 0",
                            AnchorMax = "1 1",
                            OffsetMin = "0 0",
                            OffsetMax = "25 -10"
                        }
                    }
                });
            
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = "UI_TogglePanel" },
                    Text = { Text = "" }
                }, UI_Layer + $".Toggle");
            }
            if (_playerInfo[player.userID])
            {
                CuiHelper.DestroyUi(player, UI_Layer);
                CuiHelper.AddUi(player, container);
                return;
            }


            int counter = 0;
            foreach(var panel in config._listPanels)
            {

                container.Add(new CuiElement
                {
                    Parent = UI_Layer,
                    Name = UI_Layer + $".Panel_{counter}",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Url = panel.PanelImageUrl,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = panel.PanelAnchor,
                            AnchorMax = panel.PanelAnchor,
                            OffsetMin = panel.PanelOffsetMin,
                            OffsetMax = panel.PanelOffsetMax
                        }
                    }
                });
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = panel.PanelCmd },
                    Text = { Text = "" }
                }, UI_Layer + $".Panel_{counter}");
                counter++;
            }

            CuiHelper.DestroyUi(player, UI_Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Commands
        [ConsoleCommand("UI_TogglePanel")]
        private void CMD_UI_TogglePanel(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;

            if (!_playerInfo.ContainsKey(player.userID))
                _playerInfo.Add(player.userID, false);
            else
            {

                if (_playerInfo[player.userID])
                {
                    _playerInfo[player.userID] = false;
                    Draw_UIMain(player, config.PanelAnchor);
                }
                else
                {
                    _playerInfo[player.userID] = true;
                    Draw_UIMain(player, config.PanelAnchor);
                }
            }
            return;
        }
        #endregion

        #region Util
        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                PanelAnchor = "0.005 0.99",
                PanelOffsetMin = "0 -75",
                PanelOffsetMax = "180 0",
                PanelText = "<size=23>Игровой Сервер #1</size>\n<size=18>Открыть корзину</size>",
                PanelColor = "#E6E6E6",
                PanelAlpha = 0.5f,
                PanelCmd = "chat.say /store",
                ArrowMode = true,
                ArrowColor = "#FFFFFF",


                _listPanels = new List<AddtionalPanel>
                {
                   new AddtionalPanel
                   {
                        PanelAnchor = "1 1",
                        PanelOffsetMin = "0 -35",
                        PanelOffsetMax = "35 0",
                        PanelImageUrl = "https://steamcommunity-a.akamaihd.net/economy/image/-9a81dlWLwJ2UUGcVs_nsVtzdOEdtWwKGZZLQHTxDZ7I56KU0Zwwo4NUX4oFJZEHLbXU5A1PIYQNqhpOSV-fRPasw8rsUFJ5KBFZv668FFY4naeaJGhGtdnmx4Tek_bwY-iFlGlUsJMp3LuTot-mjFGxqUttZ2r3d4eLMlhpnZPxZK0/256fx256f",
                        PanelCmd = "chat.say /case1",
                   },
                   new AddtionalPanel
                   {
                        PanelAnchor = "1 1",
                        PanelOffsetMin = "35 -35",
                        PanelOffsetMax = "70 0",
                        PanelImageUrl = "https://ya-webdesign.com/images/csgo-cases-png-11.png",
                        PanelCmd = "chat.say /case2",
                   }
                }
            };
        }

        public static string GetColor(string hex, float alpha = 1f)
        {
            var color = ColorTranslator.FromHtml(hex);
            var r = Convert.ToInt16(color.R) / 255f;
            var g = Convert.ToInt16(color.G) / 255f;
            var b = Convert.ToInt16(color.B) / 255f;

            return $"{r} {g} {b} {alpha}";
        }
        #endregion
    }
}


// --- End of file: MiniPanel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPCases.cs ---
// --- Original Local Path: TPCases.cs ---

﻿
using Internal;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
        [Info("TPCases", "Sempai#3239", "5.0.0")]
        public class TPCases : RustPlugin
        {
            static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
            static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

            private string LStorage = "lay";

            [JsonProperty("Изображения плагина")]
            private Dictionary<string, string> PluginImages = new Dictionary<string, string>
            {
                ["0Bag"] = "https://gspics.org/images/2024/01/17/0lHbg9.png",
                ["1Bag"] = "https://gspics.org/images/2024/01/17/0lH7Q7.png",
                ["2Bag"] = "https://gspics.org/images/2024/01/17/0lHeZ8.png",
                ["3Bag"] = "https://gspics.org/images/2024/01/17/0lH5Pn.png"
            };
            [PluginReference] private Plugin ImageLibrary;
            #region Init
            public class ItemsData
            {
                public List<ItemData> CheckItemData = new List<ItemData>();

                public class ItemData
                {
                    public string ShortName { get; set; }
                    public string Url { get; set; }
                    public string Command { get; set; }
                    public ulong SkinID { get; set; }
                    public int AmountDrop { get; set; }

                    public ItemData(string shortname = null, string Url = null, string Command = null, ulong SkinID = 0, int amountdrop = 0)
                    {
                        this.ShortName = shortname;
                        this.Url = Url;
                        this.Command = Command;
                        this.SkinID = SkinID;
                        this.AmountDrop = amountdrop;
                    }
                }
            }


            void Data()
            {
                if (Interface.Oxide.DataFileSystem.ExistsDatafile("Case/PlayerAmount"))
                {
                    CheckFileDrop = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ItemsData>>("Case/PlayerAmount");
                }
                else
                {
                    CheckFileDrop = new Dictionary<ulong, ItemsData>();
                }
                if (Interface.Oxide.DataFileSystem.ExistsDatafile("Case/PlayerTimeOut"))
                {
                PlayerTimeOut = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, DataList>>("Case/PlayerTimeOut");
                }
                else
                {
                PlayerTimeOut = new Dictionary<ulong, DataList>();
                }
            }

            void OnServerInitialized()
            {
                foreach (var check in PluginImages)
                {
                    ImageLibrary.Call("AddImage", check.Value, check.Key);
                }
                foreach (var check in Settings.ListDrop)
                { 
                    ImageLibrary.Call("AddImage", check.Url, check.Url);
                }
                foreach (var check in Settings.ListDropTo)
                { 
                    ImageLibrary.Call("AddImage", check.Url, check.Url);
                }
                foreach (var check in Settings.ListDropFree)
                { 
                    ImageLibrary.Call("AddImage", check.Url, check.Url);
                }
                foreach (var check in Settings.ListDropFoo)
                { 
                    ImageLibrary.Call("AddImage", check.Url, check.Url);
                }
                ImageLibrary.Call("AddImage", "https://gspics.org/images/2024/01/17/0lHZJo.png", "fonItems");
                ImageLibrary.Call("AddImage", "", "backgroundFon");
                ImageLibrary.Call("AddImage", "https://gspics.org/images/2024/01/17/0lHY1E.png", "fonCases");
                ImageLibrary.Call("AddImage", "https://gspics.org/images/2024/01/17/0lHNKR.png", "fonCasesINV");
                ImageLibrary.Call("AddImage", "https://gspics.org/images/2024/01/17/0lH2IK.png", "openCase");
                ImageLibrary.Call("AddImage", "https://gspics.org/images/2024/01/17/0lHOju.png", "imagecasexp");
                timer.Every(60, OnServerSave);
                Data();
                BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
            }
            void OnPlayerConnected(BasePlayer player)
            {
                if (!CheckFileDrop.ContainsKey(player.userID))
                {
                    ItemsData check = new ItemsData() { CheckItemData = new List<ItemsData.ItemData> { } };
                    CheckFileDrop.Add(player.userID, check);
                }
                if (!PlayerTimeOut.ContainsKey(player.userID))
                {
                    DataList data = new DataList()
                    {
                        foocase = 0,
                        onecase = 0,
                        tocase = 0,
                        freecase = 0,
                        level = 0,
                        xp = 0
                    };
                    PlayerTimeOut.Add(player.userID, data);
                }

                InterfaceXP(player);
            }

            void Unload()
            {
                OnServerSave();
            }
            void OnServerSave()
            {
                Interface.Oxide.DataFileSystem.WriteObject("Case/PlayerAmount", CheckFileDrop);
                Interface.Oxide.DataFileSystem.WriteObject("Case/PlayerTimeOut", PlayerTimeOut);
             }
            public Dictionary<ulong, ItemsData> CheckFileDrop = new Dictionary<ulong, ItemsData>();
            public Dictionary<ulong, bool> EnableUI = new Dictionary<ulong, bool>();

            #endregion

            #region Config

            private ConfigData Settings { get; set; }


            public class Itemss
            {
                [JsonProperty("Предмет из игры(shortname)")] public string ShortName;
                [JsonProperty("Изображение")] public string Url;
                [JsonProperty("Команда")] public string Command;
                [JsonProperty("Скин")] public ulong SkinID;
                [JsonProperty("мин кол-во предмета")] public int MinDrop;
                [JsonProperty("макс кол-во предмета")] public int MaxDrop;
            }

            class ConfigData
            {
                [JsonProperty("Включить поддержку плагина скилл")]
                public bool Enable = true;
                [JsonProperty("Очищать ли склад предметов у игрока после вайпа?")]
                public bool ClearSklad = true;
                [JsonProperty("Описание плагина кейсов")]
                public string Desk = "Ахуенные кейсы, всем желаю преобрести и установить на свой супер пупер ахуенный сервер!";
                [JsonProperty("Очищать ли кулдавн игрока после вайпа?")]
                public bool ClearTime = true;
                [JsonProperty("Сколько выдавать очков xp за добычу ресурсов")]
                public double XpBonusGather = 1;
                [JsonProperty("Сколько выдавать очков xp за убийство животных")]
                public double XpKillAnimal = 3;
                [JsonProperty("Сколько выдавать очков xp за убийство игрока")]
                public double XpKillPlayer = 10;
                [JsonProperty("Сколько выдавать очков xp за убийство игрока в голову")]
                public double XpKillPlayerHead = 15;
                [JsonProperty("Сколько выдавать очков xp за сбитие вертолета")]
                public double XpKillHeli = 50;
                [JsonProperty("Сколько выдавать очков xp за разбитие бочек")]
                public double XpKillBarrel = 5;
                [JsonProperty("Сколько выдавать очков xp за уничтожении танка")]
                public double XpKillBradley = 100;
                [JsonProperty("Сколько давать кулдауна после открытия первого кейса?(в секундах)")]
                public double TimeOne = 150;
                [JsonProperty("Сколько давать кулдауна после открытия второго кейса?(в секундах)")]
                public double TimeTo = 150;
                [JsonProperty("Сколько давать кулдауна после открытия третьего кейса?(в секундах)")]
                public double TimeFree = 150;
                [JsonProperty("Сколько давать кулдауна после открытия четвертого кейса?(В секундах)")]
                public double TimeFoo = 150;
                [JsonProperty("Описание для первого кейса!")]
                public string DescOne = "Это первый кейс, он легкий, и тут конечно же будет мало ресурсов!";
                [JsonProperty("Описание для второй кейса!")]
                public string DescTo = "Это второй кейс, он получше, и тут конечно же будет побольше ресурсов";
                [JsonProperty("Описание для третьего кейса!")]
                public string DescFree = "Это третий кейс, он чем 2 предыдущих, и тут конечно же будет побольше, чем у предыдущих";
                [JsonProperty("Описание для четвертого кейса!")]
                public string DescFoo = "Это четвертый кейс!, он самый жесткий, тут может выпасть все что угодно!";
                [JsonProperty("Настройка предметов для первого кейса")]
                public List<Itemss> ListDrop { get; set; }
                [JsonProperty("Настройка предметов для второго кейса")]
                public List<Itemss> ListDropTo { get; set; }
                [JsonProperty("Настройка предметов для третьего кейса")]
                public List<Itemss> ListDropFree { get; set; }
                [JsonProperty("Настройка предметов для четвертого кейса")]
                public List<Itemss> ListDropFoo { get; set; }


                public static ConfigData GetNewCong()
                {
                    ConfigData newConfig = new ConfigData();

                    newConfig.ListDrop = new List<Itemss>
                {
                    new Itemss()
                    {
                        ShortName = "rifle.ak",
                        Url = null,
                        Command = null,
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    },
                    new Itemss()
                    {
                        ShortName = null,
                        Url = "https://i.imgur.com/KccfOc2.png",
                        Command = "хуита",
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    }
                };
                    newConfig.ListDropTo = new List<Itemss>
                {
                    new Itemss()
                    {
                        ShortName = "rifle.ak",
                        Url = null,
                        Command = null,
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    },
                    new Itemss()
                    {
                        ShortName = "wood",                        
                        Url = null,
                        Command = null,
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    },
                    new Itemss()
                    {
                        ShortName = null,
                        Url = "https://i.imgur.com/KccfOc2.png",
                        Command = "хуита",
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    }
                };
                    newConfig.ListDropFree = new List<Itemss>
                {
                    new Itemss()
                    {
                        ShortName = "rifle.ak",                        
                        Url = null,
                        Command = null,
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    },
                    new Itemss()
                    {
                        ShortName = "wood",                        
                        Url = null,
                        Command = null,
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    }
                };
                    newConfig.ListDropFoo = new List<Itemss>
                {
                    new Itemss()
                    {
                        ShortName = "rifle.ak",                        
                        Url = null,
                        Command = null,
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    },
                    new Itemss()
                    {
                        ShortName = "wood",                        
                        Url = null,
                        Command = null,
                        SkinID = 0,
                        MinDrop = 1,
                        MaxDrop = 2,
                    }
                };
                    return newConfig;
                }
            }

            protected override void LoadConfig()
            {
                base.LoadConfig();
                try
                {
                    Settings = Config.ReadObject<ConfigData>();
                    if (Settings?.ListDrop == null)  LoadDefaultConfig();
                    if (Settings?.ListDropFoo == null) LoadDefaultConfig();
                    if (Settings?.ListDropFree == null) LoadDefaultConfig();
                    if (Settings?.ListDropTo == null) LoadDefaultConfig();
                }
                catch
                {
                    LoadDefaultConfig();
                }

                NextTick(SaveConfig);
            }
            
            void OnNewSave() 
            {
                if (Settings.ClearSklad)
                {
                    CheckFileDrop?.Clear();
                    PrintWarning("Замечен вайп! Очещаем склад игроков!");
                }
                if (Settings.ClearTime)
                {
                    PrintWarning("Замечен вайп! Очищаем кулдавн игроков!");
                    PlayerTimeOut?.Clear();
                }
            }

            protected override void LoadDefaultConfig() => Settings = ConfigData.GetNewCong();
            protected override void SaveConfig() => Config.WriteObject(Settings);

            #endregion

            class DataList
            {
                [JsonProperty("Кулдаун первого кейса")]
                public double onecase { get; set; }
                [JsonProperty("Кулдаун второго кейса!")]
                public double tocase { get; set; }
                [JsonProperty("Кулдаун третьего кейса!")]
                public double freecase { get; set; }
                [JsonProperty("Кулдаун четвертого кейса!")]
                public double foocase { get; set; }
                [JsonProperty("Уровень")]
                public double level { get; set; }
                [JsonProperty("XP игрока")]
                public double xp { get; set; }
            }

        private Dictionary<ulong, DataList> PlayerTimeOut = new Dictionary<ulong, DataList>();

        [ConsoleCommand("openDesc")]
        private void cmdOPenDesc(ConsoleSystem.Arg Args)
        {
            BasePlayer player = Args.Player();
            DescriptionUi(player, Convert.ToInt32(Args.Args[0]));
        }

            [ConsoleCommand("opencase")]
            void giveopencaseitems(ConsoleSystem.Arg args)
            {
                BasePlayer player = args.Player();
                var container = new CuiElementContainer();
                if (player != null && args.HasArgs(1))
                {
                    if (args.Args[0] == "one")
                    {
                        if (CheckFileDrop[player.userID].CheckItemData.Count >= 18)
                        {
                            SendReply(player, "У вас заполнен склад!");
                            return;
                        }
                        var check = PlayerTimeOut[player.userID].onecase - CurrentTime();
                        var timecheck = TimeSpan.FromSeconds(check).ToShortString();

                        if (PlayerTimeOut[player.userID].level < 5) {
                            SendReply(player, "Ваш уровень слишком низок!" + $"\nТребуется уровень 5");
                            return;
                        }

                        if (check > 0)
                        {
                            SendReply(player, "У вас еще откат кейса!" + $"\nПодождите {timecheck}");
                            return;
                        }
                        if (check <= 0)
                        {

                            PlayerTimeOut[player.userID].onecase = 0;
                                var count = Settings.ListDrop.ElementAt(UnityEngine.Random.Range(0, Settings.ListDrop.Count));
                                var kolvo = UnityEngine.Random.Range(count.MinDrop, count.MaxDrop);
                                var add = CheckFileDrop[player.userID].CheckItemData;
                                add.Add(new ItemsData.ItemData
                                {
                                    ShortName = count.ShortName,
                                    Url = count.Url,
                                    Command = count.Command,
                                    SkinID = count.SkinID,
                                    AmountDrop = kolvo,
                                });

                                container.Add(new CuiElement
                                {
                                    Parent = Layer + ".Main" + $"Case{0}",
                                    Components = 
                                    {
                                        new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "openCase"), Color = "1 1 1 1" },
                                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                                    }
                                });
                                CuiHelper.AddUi(player, container);
                                Effect.server.Run( "assets/prefabs/deployable/vendingmachine/effects/vending-machine-purchase-human.prefab",player.transform.position);
                                if (count.Command != null) {
                                    SendReply(player, $"<color=#e5a779><size=15>Вы успешно открыли кейс</size></color>" + $"\n<color=#b3a1fc><size=15>Вам выпала команда</size></color>");
                                }
                                else {
                                    SendReply(player, $"<color=#e5a779><size=15>Вы успешно открыли кейс</size></color>" + $"\n<color=#b3a1fc><size=15>Вам выпало {ItemManager.FindItemDefinition(count.ShortName).displayName.english} в количестве {kolvo}</size></color>");
                                }
                                PlayerTimeOut[player.userID].onecase += CurrentTime() + Settings.TimeOne;
                            }
                    }
                    else if (args.Args[0] == "too")
                    {
                        if (CheckFileDrop[player.userID].CheckItemData.Count >= 18)
                        {
                        SendReply(player, "У вас заполнен склад!");
                        return;
                        }
                        var check = PlayerTimeOut[player.userID].tocase - CurrentTime();
                        var timechek = TimeSpan.FromSeconds(check).ToShortString();

                        if (PlayerTimeOut[player.userID].level < 10) {
                            SendReply(player, "Ваш уровень слишком низок!" + $"\nТребуется уровень 10");
                            return;
                        }

                        if (check > 0)
                        {
                        SendReply(player, "У вас еще откат кейса!" + $"\nПодождите {timechek}");
                        return;
                        }
                        if (check <= 0)
                        {
                            PlayerTimeOut[player.userID].tocase = 0;
                        var count = Settings.ListDropTo.ElementAt(UnityEngine.Random.Range(0, Settings.ListDropTo.Count));
                        var kolvo = UnityEngine.Random.Range(count.MinDrop, count.MaxDrop);
                        var add = CheckFileDrop[player.userID].CheckItemData;
                        add.Add(new ItemsData.ItemData
                        {
                            ShortName = count.ShortName,
                            Url = count.Url,
                            Command = count.Command,
                            SkinID = count.SkinID,
                            AmountDrop = kolvo,
                        });
                        container.Add(new CuiElement
                        {
                            Parent = Layer + ".Main" + $"Case{1}",
                            Components = 
                            {
                                new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "openCase"), Color = "1 1 1 1" },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                            }
                        });
                        CuiHelper.AddUi(player, container);
                        Effect.server.Run("assets/prefabs/deployable/vendingmachine/effects/vending-machine-purchase-human.prefab",player.transform.position);
                        if (count.Command != null) {
                            SendReply(player, $"<color=#e5a779><size=15>Вы успешно открыли кейс</size></color>" + $"\n<color=#b3a1fc><size=15>Вам выпала команда</size></color>");
                        }
                        else {
                            SendReply(player, $"<color=#e5a779><size=15>Вы успешно открыли кейс</size></color>" + $"\n<color=#b3a1fc><size=15>Вам выпало {ItemManager.FindItemDefinition(count.ShortName).displayName.english} в количестве {kolvo}</size></color>");
                        }
                        PlayerTimeOut[player.userID].tocase += CurrentTime() + Settings.TimeTo;
                        }
                    }
                    else if (args.Args[0] == "free")
                    {
                        if (CheckFileDrop[player.userID].CheckItemData.Count >= 18)
                        {
                            SendReply(player, "У вас заполнен склад!");
                            return;
                        }
                        var check = PlayerTimeOut[player.userID].freecase - CurrentTime();
                        var timecheck = TimeSpan.FromSeconds(check).ToShortString();

                        if (PlayerTimeOut[player.userID].level < 15) {
                            SendReply(player, "Ваш уровень слишком низок!" + $"\nТребуется уровень 15");
                            return;
                        }

                        if (check > 0)
                        {
                            SendReply(player, "У вас еще откат кейса!" + $"\nПодождите {timecheck}");
                        }

                        if (check <= 0)
                        {
                            PlayerTimeOut[player.userID].freecase = 0;
                            var count = Settings.ListDropFree.ElementAt(UnityEngine.Random.Range(0, Settings.ListDropFree.Count));
                            var kolvo = UnityEngine.Random.Range(count.MinDrop, count.MaxDrop);
                            var add = CheckFileDrop[player.userID].CheckItemData;
                            add.Add(new ItemsData.ItemData
                            {
                                ShortName = count.ShortName,
                                Url = count.Url,
                                Command = count.Command,
                                SkinID = count.SkinID,
                                AmountDrop = kolvo,
                            });
                            container.Add(new CuiElement
                            {
                                Parent = Layer + ".Main" + $"Case{2}",
                                Components = 
                                {
                                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "openCase"), Color = "1 1 1 1" },
                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                                }
                            });
                            CuiHelper.AddUi(player, container);
                            Effect.server.Run("assets/prefabs/deployable/vendingmachine/effects/vending-machine-purchase-human.prefab",player.transform.position);
                            if (count.Command != null) {
                                SendReply(player, $"<color=#e5a779><size=15>Вы успешно открыли кейс</size></color>" + $"\n<color=#b3a1fc><size=15>Вам выпала команда</size></color>");
                            }
                            else {
                                SendReply(player, $"<color=#e5a779><size=15>Вы успешно открыли кейс</size></color>" + $"\n<color=#b3a1fc><size=15>Вам выпало {ItemManager.FindItemDefinition(count.ShortName).displayName.english} в количестве {kolvo}</size></color>");
                            }                            
                            PlayerTimeOut[player.userID].freecase += CurrentTime() + Settings.TimeFree;
                        }
                    }
                    else if (args.Args[0] == "foo")
                    {
                        if (CheckFileDrop[player.userID].CheckItemData.Count >= 18)
                        {
                            SendReply(player, "У вас заполнен склад!");
                            return;
                        }
                        var check = PlayerTimeOut[player.userID].foocase - CurrentTime();
                        var timecheck = TimeSpan.FromSeconds(check).ToShortString();

                        if (PlayerTimeOut[player.userID].level < 20) {
                            SendReply(player, "Ваш уровень слишком низок!" + $"\nТребуется уровень 20");
                            return;
                        }

                        if (check > 0 )
                        {
                            SendReply(player, "У вас еще откат кейса!" + $"\nПодождите {timecheck}");
                            return;
                        }
                        if (check <= 0)
                        {
                            PlayerTimeOut[player.userID].foocase = 0;
                            var count = Settings.ListDropFoo.ElementAt(UnityEngine.Random.Range(0, Settings.ListDropFoo.Count));
                            var kolvo = UnityEngine.Random.Range(count.MinDrop, count.MaxDrop);
                            var add = CheckFileDrop[player.userID].CheckItemData;
                            add.Add(new ItemsData.ItemData
                            {
                                ShortName = count.ShortName,
                                Url = count.Url,
                                Command = count.Command,
                                SkinID = count.SkinID,
                                AmountDrop = kolvo,
                            });
                            container.Add(new CuiElement
                            {
                                Parent = Layer + ".Main" + $"Case{3}",
                                Components = 
                                {
                                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "openCase"), Color = "1 1 1 1" },
                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                                }
                            });
                            CuiHelper.AddUi(player, container);
                        Effect.server.Run("assets/prefabs/deployable/vendingmachine/effects/vending-machine-purchase-human.prefab",player.transform.position);
                        if (count.Command != null) {
                            SendReply(player, $"<color=#e5a779><size=15>Вы успешно открыли кейс</size></color>" + $"\n<color=#b3a1fc><size=15>Вам выпала команда</size></color>");
                        }
                        else {
                            SendReply(player, $"<color=#e5a779><size=15>Вы успешно открыли кейс</size></color>" + $"\n<color=#b3a1fc><size=15>Вам выпало {ItemManager.FindItemDefinition(count.ShortName).displayName.english} в количестве {kolvo}</size></color>");
                        }                        
                        PlayerTimeOut[player.userID].foocase += CurrentTime() + Settings.TimeFoo;
                    }
                    }
                }
            }

        const string Layer = "lay";

        [ConsoleCommand("returnCase")]
        private void cmdReturnCase(ConsoleSystem.Arg args)
        {
            BasePlayer player = args?.Player();
            DrawGui(player);
        }

        [ConsoleCommand("openInventory")]
        private void cmdOpenInventory(ConsoleSystem.Arg args)
        {
            BasePlayer player = args?.Player();
            DrawGuiStorage(player);
        }

        private void DrawGuiStorage(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = LStorage + ".Main",
                Parent = ".Mains",
                Components = 
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonCasesINV"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, LStorage + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.22 0.718", AnchorMax = "0.317 0.766" },
                Button = { Command = "returnCase", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, LStorage + ".Main");

            var Items = CheckFileDrop[player.userID].CheckItemData.Count;
            for (int i = 0, y = 0, x = 0; i < 18; i++)
            {
                container.Add(new CuiElement
                {
                    Name = LStorage + ".Main" + $"Item{i}",
                    Parent = LStorage + ".Main",
                    Components = 
                    {
                        new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonItems") },
                        new CuiRectTransformComponent { AnchorMin = $"{0.221 + (x * 0.095)} {0.542 - (y * 0.168)}", AnchorMax = $"{0.305 + (x * 0.095)} {0.69 - (y * 0.168)}" },
                    }
                });

                if (Items - 1 >= i)
                {
                    var image = CheckFileDrop[player.userID].CheckItemData.ElementAt(i).Url != null ? CheckFileDrop[player.userID].CheckItemData.ElementAt(i).Url : CheckFileDrop[player.userID].CheckItemData.ElementAt(i).ShortName;
                    container.Add(new CuiElement
                    {
                        Parent = LStorage + ".Main" + $"Item{i}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", image) },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 1", OffsetMax = "-5 -1" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0 ", AnchorMax = "1 1", OffsetMax = "-5 -1", OffsetMin = "5 1" },
                        Button = { Color = "0 0 0 0", Command = $"takeitem {i}" },
                        Text = { Text = $"{CheckFileDrop[player.userID].CheckItemData.ElementAt(i).AmountDrop.ToString()}" + "шт", Align = TextAnchor.LowerCenter, Font = "robotocondensed-regular.ttf", FontSize = 10 }
                    }, LStorage + ".Main" + $"Item{i}");
                }

                x++;
                if (x == 6)
                {
                    x = 0;
                    y++;
                }
            }

            CuiHelper.AddUi(player, container);
        }

        private void DrawGui(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = Layer + ".Main",
                Parent = ".Mains",
                Components = 
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonCases"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.78 0.805", AnchorMax = "0.795 0.833", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "desc" },
                Text = { Text = "?", Color = "1 1 1 0.7", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.67 0.705", AnchorMax = "0.765 0.755" },
                Button = { Command = "openInventory", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, Layer + ".Main");

            for (int i = 0; i < 4; i++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = 
                    {
                        AnchorMin = $"{0.232 + (i * 0.138)} 0.235",
                        AnchorMax = $"{0.353 + (i * 0.138)} 0.45"
                    },
                    Image = { Color = "0 0 0 0" }
                }, Layer + ".Main", Layer + ".Main" + $"Case{i}");

                if (i == 0)
                {
                    var check = PlayerTimeOut[player.userID].onecase - CurrentTime();
                    var timecheck = TimeSpan.FromSeconds(check).ToShortString();

                    if (PlayerTimeOut[player.userID].level < 5) {
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4" },
                            Text = { Text = $"<size=20>Уровень</size>\n<size=14>Требуется 5 уровень</size>", Color = "1 1 1 0.65",FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                        }, Layer + ".Main" + $"Case{i}");
                    }

                    if (check <= 0)
                        PlayerTimeOut[player.userID].onecase = 0;

                    if (PlayerTimeOut[player.userID].onecase > 0)
                    {
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4" },
                            Text = { Text = $"<size=20>ОСТАЛОСЬ</size>\n<size=14>{timecheck}</size>", Color = "1 1 1 0.65",FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                        }, Layer + ".Main" + $"Case{i}");
                    }
                }
                if (i == 1)
                {
                    var check = PlayerTimeOut[player.userID].tocase - CurrentTime();
                    var timecheck = TimeSpan.FromSeconds(check).ToShortString();

                    if (PlayerTimeOut[player.userID].level < 10) {
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4" },
                            Text = { Text = $"<size=20>Уровень</size>\n<size=14>Требуется 10 уровень</size>", Color = "1 1 1 0.65",FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                        }, Layer + ".Main" + $"Case{i}");
                    }

                    if (check <= 0)
                        PlayerTimeOut[player.userID].tocase = 0;

                    if (PlayerTimeOut[player.userID].tocase > 0)
                    {
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4" },
                            Text = { Text = $"<size=20>ОСТАЛОСЬ</size>\n<size=14>{timecheck}</size>", Color = "1 1 1 0.65",FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                        }, Layer + ".Main" + $"Case{i}");
                    }
                }
                if (i == 2)
                {
                    var checkss = PlayerTimeOut[player.userID].freecase - CurrentTime();
                    var timecheck = TimeSpan.FromSeconds(checkss).ToShortString();

                    if (PlayerTimeOut[player.userID].level < 15) {
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4" },
                            Text = { Text = $"<size=20>Уровень</size>\n<size=14>Требуется 15 уровень</size>", Color = "1 1 1 0.65",FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                        }, Layer + ".Main" + $"Case{i}");
                    }

                    if (checkss <= 0)
                        PlayerTimeOut[player.userID].freecase = 0;
                
                    if (PlayerTimeOut[player.userID].freecase > 0)
                    {
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4" },
                            Text = { Text = $"<size=20>ОСТАЛОСЬ</size>\n<size=14>{timecheck}</size>", Color = "1 1 1 0.65",FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                        }, Layer + ".Main" + $"Case{i}");
                    }
                }
                if (i == 3)
                {
                    var checksss = PlayerTimeOut[player.userID].foocase - CurrentTime();
                    var timecheck = TimeSpan.FromSeconds(checksss).ToShortString();

                    if (PlayerTimeOut[player.userID].level < 20) {
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4" },
                            Text = { Text = $"<size=20>Уровень</size>\n<size=14>Требуется 20 уровень</size>", Color = "1 1 1 0.65",FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                        }, Layer + ".Main" + $"Case{i}");
                    }

                    if (checksss <= 0)
                        PlayerTimeOut[player.userID].foocase = 0;

                    if (PlayerTimeOut[player.userID].foocase > 0)
                    {
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.4" },
                            Text = { Text = $"<size=20>ОСТАЛОСЬ</size>\n<size=14>{timecheck}</size>", Color = "1 1 1 0.65",FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                        }, Layer + ".Main" + $"Case{i}");
                    }
                }

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", },
                    Button = { Color = "0 0 0 0", Command = i == 0 ? "opencase one" : i == 1 ? "opencase too" : i == 2 ? "opencase free" : "opencase foo" },
                    Text = { Text = $"" }
                }, Layer + ".Main" + $"Case{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.045 0.8", AnchorMax = $"0.203 0.96", },
                    Button = { Color = "1 1 1 0", Command = $"openDesc {i}" },
                    Text = { Text = $"" }
                }, Layer + ".Main" + $"Case{i}");
            }

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("desc")]
        void DescUI(ConsoleSystem.Arg args) {
            var player = args.Player();
            CuiHelper.DestroyUi(player, Layer + ".Main" + ".Description");
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = Layer + ".Main" + ".Description",
                Parent = Layer + ".Main",
                Components = {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonDescription") },
                    new CuiRectTransformComponent { AnchorMin = $"0.58 0.6", AnchorMax = $"0.8 0.8" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.9 1" },
                Text = { Text = $"Описание кейсов", Color = "1 1 1 0.65",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, Layer + ".Main" + ".Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0", AnchorMax = "1 0.7" },
                Text = { Text = $"{Settings.Desk}", Color = "1 1 1 0.65",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, Layer + ".Main" + ".Description");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9 0.82", AnchorMax = "0.98 0.98" },
                Button = { Close = Layer + ".Main" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, Layer + ".Main" + ".Description");

            CuiHelper.AddUi(player, container);
        }

        private void DescriptionUi(BasePlayer player, int element)
        {
            CuiHelper.DestroyUi(player, Layer + ".Main" + $"Case{element}" + ".Description");
            CuiElementContainer container = new CuiElementContainer();
            int y = element == 0 ? 1 : element == 1 ? 0 : element == 2 ? 0 : 1;
            string Description = element == 0 ? Settings.DescOne : element == 1 ? Settings.DescTo : element == 2 ? Settings.DescFree : Settings.DescFoo;
            string Name = element == 0 ? "Мешок" : element == 1 ? "ДЕРЕВЯННЫЙ ЯЩИК" : element == 2 ? "СУМКА" : "ЗОЛОТАЯ БОЧКА";

            container.Add(new CuiElement
            {
                Name = Layer + ".Main" + $"Case{element}" + ".Description",
                Parent = Layer + ".Main",
                Components = {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonDescription") },
                    new CuiRectTransformComponent { AnchorMin = $"{0.078 + (element * 0.21)} {0.512 - (y * 0.12)}", AnchorMax = $"{0.28 + (element * 0.21)} {0.694 - (y * 0.12)}" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.9 1" },
                Text = { Text = $"Описание кейса '{Name}'", Color = "1 1 1 0.65",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, Layer + ".Main" + $"Case{element}" + ".Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0", AnchorMax = "1 0.7" },
                Text = { Text = $"{Description}", Color = "1 1 1 0.65",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, Layer + ".Main" + $"Case{element}" + ".Description");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9 0.82", AnchorMax = "0.98 0.98" },
                Button = { Close = Layer + ".Main" + $"Case{element}" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, Layer + ".Main" + $"Case{element}" + ".Description");

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("enablecase")]
        void Console_EnableCase(ConsoleSystem.Arg args) {
            var player = args.Player();
            var enable = EnableUI[player.userID] == true ? false : true;
            EnableUI[player.userID] = enable;
            InterfaceXP(player);
        }

        void InterfaceXP(BasePlayer player) {
            if (!EnableUI.ContainsKey(player.userID)) {
                EnableUI[player.userID] = true;
            }
            CuiHelper.DestroyUi(player, "Layer_xp");
            var container = new CuiElementContainer();

            var anchor = EnableUI[player.userID] == true ? "-430 16" : "-250 16";
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = anchor, OffsetMax = "-210 42.5" },
                Image = { Color = "0 0 0 0"}
            }, "Overlay", "Layer_xp");

            var text = EnableUI[player.userID] == true ? ">" : "<";
            var anchortext = EnableUI[player.userID] == true ? "0.2 1" : "0.3 1";
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = anchortext, OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "enablecase" },
                Text = { Text = text, Color = "1 1 1 0.7", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "Layer_xp");

            var anchorblock = EnableUI[player.userID] == true ? "0.15 0" : "0.3 0";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = anchorblock, AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.15"}
            }, "Layer_xp", "Image");

            var anchorimage = EnableUI[player.userID] == true ? "0.15 1" : "1 1";
            container.Add(new CuiElement
            {
                Parent = "Image",
                Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "imagecasexp"), Color = "1 1 1 0.6" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = anchorimage, OffsetMin = "6 6", OffsetMax = "-6 -6" }
                    }
            });

            if (EnableUI[player.userID]) {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.16 0.15", AnchorMax = $"1 0.85", OffsetMax = "-4 0" },
                    Image = { Color = "0 0 0 0"}
                }, "Image", "Progress");
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"{(float)PlayerTimeOut[player.userID].xp / 100} 1", OffsetMax = "0 0" },
                    Image = { Color = "0.96 0.41 0.07 0.9"}
                }, "Progress");

                container.Add(new CuiLabel
                {  
                    RectTransform = { AnchorMin = "0.18 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = $"{PlayerTimeOut[player.userID].xp}%", Color = "1 1 1 1", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "Image");

                container.Add(new CuiLabel
                {  
                    RectTransform = { AnchorMin = "0.35 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = $"({PlayerTimeOut[player.userID].level}) Ваш уровень", Color = "1 1 1 0.7", Align = TextAnchor.MiddleLeft, FontSize = 8, Font = "robotocondensed-regular.ttf" }
                }, "Image");
            }

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("takeitem")]
        private void skladgive(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            var item = CheckFileDrop[player.userID].CheckItemData.ElementAt(int.Parse(args.Args[0]));
            if (item.Command != null) {
                Server.Command(item.Command.Replace("%STEAMID%", player.UserIDString));
            }
            else {
                var ite = ItemManager.CreateByName(item.ShortName, item.AmountDrop);
                player.GiveItem(ite, BaseEntity.GiveItemReason.PickedUp);
            }
            CheckFileDrop[player.userID].CheckItemData.RemoveAt(int.Parse(args.Args[0]));
            DrawGuiStorage(player);
            SendReply(player, $"<color=#efd9c9>Вы успешно забрали свой приз</color>");
        }

        void ConvertXP(BasePlayer player, double xp) {
            PlayerTimeOut[player.userID].xp += xp;
            if (PlayerTimeOut[player.userID].xp >= 100) {
                PlayerTimeOut[player.userID].level += 1;
                SendReply(player, "Вы успешно апнули уровент!" + $"\nВаш уровень {PlayerTimeOut[player.userID].level}");
                PlayerTimeOut[player.userID].xp = 0;
            }
            InterfaceXP(player);
        }

        #region Функции получения xp
        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            ConvertXP(player, Settings.XpBonusGather);
        }

        public ulong lastDamageName;
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BradleyAPC && info.Initiator is BasePlayer)
                lastDamageName = info.Initiator.ToPlayer().userID;
            if (entity is BaseHelicopter && info.Initiator is BasePlayer)
                lastDamageName = info.Initiator.ToPlayer().userID;
        }

        [Oxide.Core.Plugins.HookMethod("OnEntityDeath")]
        void OnDeadEntity(BaseCombatEntity entity, HitInfo info)
        {
			if (entity==null || info==null) return;
            BasePlayer player = null;

            if (entity is BradleyAPC) {
                player = BasePlayer.FindByID(lastDamageName);
                ConvertXP(player, Settings.XpKillBradley);
            }
            if (entity is BaseHelicopter) {
                player = BasePlayer.FindByID(lastDamageName);
                ConvertXP(player, Settings.XpKillHeli);
            }
            
            EntityDeathFunc(entity, info);
        }

        void EntityDeathFunc(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || info.Initiator is BaseNpc || info.Initiator is ScientistNPC || info.InitiatorPlayer == null || info.InitiatorPlayer.GetComponent<NPCPlayer>()) return;
            if (info?.InitiatorPlayer == null) return;
            BasePlayer atacker = info.InitiatorPlayer;
            if (atacker as BasePlayer)
            {
                if (entity as BaseAnimalNPC)
                {
                    ConvertXP(atacker, Settings.XpKillAnimal);
                }
                if (entity as BasePlayer)
                {
                    if (atacker.userID == (entity as BasePlayer).userID) return;
                    if (info.isHeadshot) ConvertXP(atacker, Settings.XpKillPlayerHead);
                    else ConvertXP(atacker, Settings.XpKillPlayer);
                }
                if (entity.ShortPrefabName.Contains("barrel"))
                {
                    ConvertXP(atacker, Settings.XpKillBarrel);
                }
            }
        }
        #endregion
        }
    }

// --- End of file: TPCases.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/OurServers.cs ---
// --- Original Local Path: OurServers.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Our Servers", "Sempai#3239", "1.0.0")] 
    [Description("Show information about other servers (with fetching current online)")]
    public class OurServers : RustPlugin 
    {
        #region Classes

        private class Server
        {
            [JsonProperty("Name of your server in interface")] 
            public string DisplayName;

            [JsonProperty("Description of your server in interface")] 
            public string Description;

            [JsonProperty("IP:Port of server (ex: 127.0.0.1:12000)")]
            public string IPAndPort;

            [JsonProperty("Interface width (increase it, if your description is very length)")]
            public int ServerWidth = 250;

            [JsonIgnore] 
            public int CurrentOnline; 

            [JsonIgnore] 
            public int MaxOnline;

            [JsonIgnore]
            public bool Status = false;

            public string IP()                      => IPAndPort.Split(':')[0];
            public int    Port()                    => int.Parse(IPAndPort.Split(':')[1]);
            public int    GetOnline()               => Mathf.Min(MaxOnline, CurrentOnline);
            public void   UpdateStatus(bool status) => Status = status;
        } 

        private class Configuration
        {
            [JsonProperty("Servers configure")]
            public List<Server> Servers = new List<Server>();

            [JsonProperty("Command to open interface")]
            public string Command = "servers";

            [JsonProperty("Use chat instead of UI")]
            public bool UseChat = false;

            [JsonProperty("Information update interval in seconds (should be > 30)")]
            public int Interval = 60;

            [JsonProperty("Which API to use? (Possible options: steampowered or battlemetrics) (Default: battlemetrics)")]
            public string API = "battlemetrics";

            [JsonProperty("Steampowered API key")]
            public string SteamWebApiKey = "!!! You can get it HERE > https://steamcommunity.com/dev/apikey < and you need to insert HERE !!!";

            public static Configuration Generate()
            {
                return new Configuration
                {
                    Servers = new List<Server>
                    {
                        new Server
                        {
                            DisplayName = "UMOD-SERVER #1 - PROCEDURAL",
                            Description = "Example server, with example description",
                            IPAndPort   = "8.8.8.8:12000",
                            ServerWidth = 250
                        },
                        new Server
                        {
                            DisplayName = "UMOD-SERVER #2 - BARREN",
                            Description = "Example server, with example description",
                            IPAndPort   = "1.1.1.1:13000"
                        }
                    }
                };
            }
        }

        public class BattlemetricsApiResponse
        {
            [JsonProperty("data")]
            public List<ServerData> data;

            public class ServerData
            {
                [JsonProperty("id")]
                public string id;

                [JsonProperty("type")]
                public string type;

                [JsonProperty("attributes")]
                public Attributes attributes;
                
                public class Attributes
                {
                    [JsonProperty("id")]
                    public string id;

                    [JsonProperty("name")]
                    public string name;

                    [JsonProperty("ip")]
                    public string ip;

                    [JsonProperty("port")]
                    public int port;

                    [JsonProperty("portQuery")]
                    public int portQuery;

                    [JsonProperty("players")]
                    public int players;

                    [JsonProperty("maxPlayers")]
                    public int maxPlayers;

                    [JsonProperty("status")]
                    public string status;
                }
            }
        }

        public class SteampoweredApi
        {
            [JsonProperty("response")]
            public Response response;

            public class Response
            {
                [JsonProperty("servers")]
                public List<ServerData> servers;

                public class ServerData
                {
                    [JsonProperty("addr")]
                    public string addr;

                    [JsonProperty("gameport")]
                    public int gameport;

                    [JsonProperty("steamid")]
                    public string steamid;

                    [JsonProperty("name")]
                    public string name;
                    
                    [JsonProperty("appid")]
                    public int appid;

                    [JsonProperty("gamedir")]
                    public string gamedir;

                    [JsonProperty("version")]
                    public string version;

                    [JsonProperty("product")]
                    public string product;

                    [JsonProperty("region")]
                    public int region;

                    [JsonProperty("players")]
                    public int players;

                    [JsonProperty("max_players")]
                    public int max_players;

                    [JsonProperty("bots")]
                    public int bots;

                    [JsonProperty("map")]
                    public string map;

                    [JsonProperty("secure")]
                    public bool secure;

                    [JsonProperty("dedicated")]
                    public bool dedicated;

                    [JsonProperty("os")]
                    public string os;

                    [JsonProperty("gametype")]
                    public string gametype;
                }
            }
        }

        #endregion

        #region Variables

        // Coroutines
        private Coroutine UpdateAction;

        // Configuration
        private Configuration Settings;
        private bool          Initialized;
        private bool          Broken;

        #endregion

        #region Initialization

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.Servers == null) LoadDefaultConfig();
                SaveConfig();

                if (Settings.API == "steampowered" && (Settings.SteamWebApiKey == null || Settings.SteamWebApiKey == string.Empty || Settings.SteamWebApiKey.Length != 32))
                {
                    PrintError("Steampowered API requires an Steam Web API key to work! Check your configuration!");
                    Broken = true;
                }
            }
            catch
            {
                PrintError("Error reading config, please check!");
                Broken = true;
            }
        }

        protected override void SaveConfig() => Config.WriteObject(Settings);
        protected override void LoadDefaultConfig()
        {
            Settings = Configuration.Generate();
            SaveConfig();
        }

        private void OnServerInitialized()
        {
            if (Broken) return;

            cmd.AddChatCommand(Settings.Command, this, nameof(CmdShowServers));
            if (Settings.Interval < 30)
            {
                PrintError($"Update interval should be bigger then 30 s!");
                Settings.Interval = 30;
            }

            UpdateAction = ServerMgr.Instance.StartCoroutine(UpdateOnline());
        }

        private void Unload()
        {
            if (UpdateAction != null)
                ServerMgr.Instance.StopCoroutine(UpdateAction);
        }

        #endregion

        #region Functions

        private IEnumerator UpdateOnline()
        {
            while (true)
            {
                foreach (var check in Settings.Servers)
                {
                    if (Settings.API == "steampowered")
                    {
                        string url = $"https://api.steampowered.com/IGameServersService/GetServerList/v1/?format=json&key={Settings.SteamWebApiKey}&filter=\\gameaddr\\{check.IP()}:{check.Port()}";
                        webrequest.Enqueue(url, "", (code, response) =>
                        {
                            switch (code)
                            {
                                case 200:
                                    try
                                    {
                                        SteampoweredApi data = JsonConvert.DeserializeObject<SteampoweredApi>(response);
                                        if (data.response.servers != null)
                                        {
                                            switch (data.response.servers.Count)
                                            {
                                                case 1:
                                                    SteampoweredApi.Response.ServerData serverData = data.response.servers.Last();
                                                    if (serverData.addr != $"{check.IP()}:{check.Port()}")
                                                    {
                                                        PrintError($"Steampowered API: The response from Steampowered does not match the IP or port of the expected server! (Request: {check.IP()}:{check.Port()}, Response: {serverData.addr})");
                                                    }
                                                    else
                                                    {
                                                        check.CurrentOnline = serverData.players;
                                                        check.MaxOnline = serverData.max_players;
                                                        check.UpdateStatus(true);

                                                        Initialized = true;
                                                    }
                                                    break;

                                                default:
                                                    PrintError($"Steampowered API: The number of results is different than expected! Contact the plugin developer! (Server: {check.IP()}:{check.Port()}, Count: {data.response.servers.Count})");
                                                    break;
                                            }
                                        }
                                        else
                                        {
                                            check.UpdateStatus(false);
                                        }
                                    }
                                    catch
                                    {
                                        PrintError($"Steampowered API: Error parsing response from server. Perhaps the format has changed. Contact the plugin developer!");
                                    }
                                    break;

                                case 403:
                                    PrintError($"Steampowered API: Invalid Steam Web API key! Check it with your key indicated on the page: https://steamcommunity.com/dev/apikey");
                                    break;

                                default:
                                    PrintError($"Steampowered API HTTP CODE: {code}");
                                    break;
                            }
                        }, this);
                    }
                    else
                    {
                        string url = $"https://api.battlemetrics.com/servers?filter[search]=\"{check.IP()}:{check.Port()}\"";
                        webrequest.Enqueue(url, "", (code, response) =>
                        {
                            if (code == 200)
                            {
                                try
                                {
                                    BattlemetricsApiResponse apiResponse = JsonConvert.DeserializeObject<BattlemetricsApiResponse>(response);
                                    switch (apiResponse.data.Count)
                                    {
                                        case 1:
                                            BattlemetricsApiResponse.ServerData serverData = apiResponse.data.Last();
                                            if (check.IP() != serverData.attributes.ip || check.Port() != serverData.attributes.port)
                                            {
                                                PrintError($"Battlemetrics API: The response from Battlemetrics does not match the IP or port of the expected server! (Request: {check.IP()}:{check.Port()}, Response: {serverData.attributes.ip}:{serverData.attributes.port})");
                                            }
                                            else
                                            {
                                                check.CurrentOnline = serverData.attributes.players;
                                                check.MaxOnline = serverData.attributes.maxPlayers;
                                                check.UpdateStatus((serverData.attributes.status == "online"));

                                                Initialized = true;
                                            }
                                            break;

                                        case 0:
                                            PrintError($"Battlemetrics API: Server '{check.IP()}:{check.Port()}' not found! Perhaps he has not yet been interviewed. Wait a while.");
                                            break;

                                        default:
                                            PrintError($"Battlemetrics API: The number of results is different than expected! Contact the plugin developer! (Server: {check.IP()}:{check.Port()}, Count: {apiResponse.data.Count})");
                                            break;
                                    }
                                }
                                catch
                                {
                                    PrintError($"Battlemetrics API: Error parsing response from server. Perhaps the format has changed. Contact the plugin developer!");
                                }
                            }
                            else
                            {
                                PrintError($"Battlemetrics API HTTP CODE: {code}");
                            }
                        }, this);
                    }

                    yield return new WaitForSeconds(1f);
                }

                yield return new WaitForSeconds(Settings.Interval);
            }
        }

        #endregion 

        #region Commands

        [ConsoleCommand("UI_OurServersHandler")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !args.HasArgs(1)) return;

            switch (args.Args[0].ToLower())
            {
                case "show":
                {
                    if (!args.HasArgs(2)) return;

                    int index = 0;
                    if (!int.TryParse(args.Args[1], out index) || Settings.Servers.ElementAtOrDefault(index) == null) return;
                    UI_DrawInterface(player, index);
                    break;
                }
                case "hide":
                {
                    UI_DrawInterface(player, -2);
                    break;
                }
            }
        }

        private void CmdShowServers(BasePlayer player, string command, string[] args)
        {
            if (!Initialized) return;

            if (Settings.UseChat)
            {
                string resultMessage = "";
                foreach (var server in Settings.Servers)
                    resultMessage += $"{server.DisplayName} (IP: {server.IPAndPort}) - " + ((server.Status) ? $"{server.GetOnline()}/{server.MaxOnline} players online" : "OFFLINE") + "\n\n";
                
                player.ChatMessage(resultMessage); 
            }
            else
            {
                UI_DrawInterface(player);
            }
        }

        #endregion

        #region Interface

        private const string Layer = "UI_OurServersLayer";

        private void UI_DrawInterface(BasePlayer player, int index = -1)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();

            float  fadeSpeed     = 1f;
            Server choosedServer = null;
            if (index >= 0)
            {
                fadeSpeed     = 0f;
                choosedServer = Settings.Servers.ElementAtOrDefault(index);
            }
            else if (index == -2)
            {
                fadeSpeed = 0;
            }

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.284 0", AnchorMax = "0.952 1", OffsetMax = "0 0"},
                Image         = {FadeIn    = fadeSpeed, Color = "0 0 0 0.7"}
            }, "Menu", Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.032 0.893", AnchorMax = $"0.347 0.954", OffsetMax = "0 0" },
                Image = { Color = "0.86 0.55 0.35 1" }
            }, Layer, "Title");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"SERVERS", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-bold.ttf" }
            }, "Title");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.36 0.893", AnchorMax = $"0.97 0.954", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer, "Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = "Server updates @ <color=#db8c5a>store.хуита.ru</color>", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Description");

            var   list        = Settings.Servers.Where(p => p.CurrentOnline > -1).ToList();

            float width = 0.472f, height = 0.15f, startxBox = 0.028f, startyBox = 0.85f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in list)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                    Button = { Color = "0 0 0 0.5", Command = $"" },
                    Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, Layer, check.IPAndPort);

                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }

                if (check != choosedServer)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                        Image         = {FadeIn    = fadeSpeed, Color = "1 1 1 0.03008521"}
                    }, check.IPAndPort, check.IPAndPort + ".Help");

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin        = "15 -45", OffsetMax                  = "-15 -10"},
                        Text          = {FadeIn    = fadeSpeed, Text  = check.DisplayName, Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.UpperCenter}
                    }, check.IPAndPort);

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin      = "15 -105", OffsetMax                     = "-15 -5"},
                        Text          = {FadeIn    = fadeSpeed, Text  = check.IPAndPort, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 0.6", Align = TextAnchor.MiddleCenter}
                    }, check.IPAndPort);

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin                                 = "15 -150", OffsetMax                     = "-15 -5"},
                        Text          = {FadeIn    = fadeSpeed, Text  = ((check.Status) ? $"{check.GetOnline()} / {check.MaxOnline}" : "OFFLINE"), Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.4", Align = TextAnchor.MiddleCenter}
                    }, check.IPAndPort);

                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "15 10", OffsetMax = "-15 30"},
                        Image         = {FadeIn    = fadeSpeed, Color = ((check.Status) ? "1 1 1 0.4" : "1 0.2 0 0.4")}
                    }, check.IPAndPort, check.IPAndPort + ".Online");

                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = $"{(float) check.GetOnline() / check.MaxOnline} 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                        Image         = {FadeIn    = fadeSpeed, Color = "0.6 0.9 0.6 0.8"}
                    }, check.IPAndPort + ".Online");

                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0 0.8", AnchorMax  = "0.05 1", OffsetMin                                 = "0 0", OffsetMax = "0 0"},
                        Button        = {Color     = "1 1 1 0.1", Command = $"UI_OurServersHandler show {Settings.Servers.IndexOf(check)}"},
                        Text          = {FadeIn    = fadeSpeed, Text   = "i", Align                                       = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 1 1 0.7"}
                    }, check.IPAndPort + ".Help");
                }
                else 
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                        Image         = {FadeIn    = fadeSpeed, Color = "1 1 1 0.03008521"}
                    }, check.IPAndPort, check.IPAndPort + ".Help");

                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = "0 0.8", AnchorMax  = "0.05 1", OffsetMin                                 = "0 0", OffsetMax = "0 0"},
                        Button        = {Color     = "1 1 1 0.1", Command = $"UI_OurServersHandler hide"},
                        Text          = {FadeIn    = fadeSpeed, Text   = "X", Align                                       = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 1 1 0.7"}
                    }, check.IPAndPort + ".Help");

                    container.Add(new CuiLabel
                    {
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin        = "15 15", OffsetMax                      = "-15 -15"},
                        Text          = {FadeIn    = fadeSpeed, Text  = check.Description, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 1", Align = TextAnchor.MiddleCenter}
                    }, check.IPAndPort);
                }
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion
    }
}

// --- End of file: OurServers.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AbsolutCombat.cs ---
// --- Original Local Path: AbsolutCombat.cs ---

// Requires: ImageLibrary
using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using System.Collections;
using System.IO;
using System.Text;
using Oxide.Core.Libraries.Covalence;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("AbsolutCombat", "Absolut", "2.2.0", ResourceId = 2103)]

    class AbsolutCombat : RustPlugin
    {
        #region Fields

        [PluginReference]
        Plugin EventManager;

        [PluginReference]
        Plugin ServerRewards;

        [PluginReference]
        Plugin Economics;

        [PluginReference]
        Plugin BetterChat;

        [PluginReference]
        ImageLibrary ImageLibrary;

        Gear_Weapon_Data gwData;
        private DynamicConfigFile GWData;

        SavedPlayers playerData;
        private DynamicConfigFile PlayerData;

        string TitleColor = "<color=orange>";
        string MsgColor = "<color=#A9A9A9>";

        private Dictionary<ulong, Timer> PlayerGearSetTimer = new Dictionary<ulong, Timer>();
        private Dictionary<ulong, Timer> PlayerWeaponSetTimer = new Dictionary<ulong, Timer>();
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        private Dictionary<ulong, PurchaseItem> PendingPurchase = new Dictionary<ulong, PurchaseItem>();
        private Dictionary<ulong, PurchaseItem> SetSelection = new Dictionary<ulong, PurchaseItem>();
        private Dictionary<ulong, Dictionary<string, Dictionary<string, List<string>>>> WeaponSelection = new Dictionary<ulong, Dictionary<string, Dictionary<string, List<string>>>>();
        private List<ACPlayer> ACPlayers = new List<ACPlayer>();

        private Dictionary<ulong, GearCollectionCreation> NewGearCollection = new Dictionary<ulong, GearCollectionCreation>();
        private Dictionary<ulong, WeaponCollectionCreation> NewWeaponCollection = new Dictionary<ulong, WeaponCollectionCreation>();

        private Dictionary<ulong, string> SavingCollection = new Dictionary<ulong, string>();

        private Dictionary<ulong, screen> ACUIInfo = new Dictionary<ulong, screen>();
        class screen
        {
            public bool open;
            public bool admin;
            public string GearSet;
            public string WeaponSet;
            public int GearIndex;
            public int WeaponIndex;
        }



        //corpses///
        private readonly string corpsePrefab = "assets/prefabs/player/player_corpse.prefab";
        private uint corpsePrefabId;
        #endregion

        #region Hooks
        void Loaded()
        {
            GWData = Interface.Oxide.DataFileSystem.GetFile("AbsolutCombat_GWData");
            PlayerData = Interface.Oxide.DataFileSystem.GetFile("AbsolutCombat_PlayerData");
            lang.RegisterMessages(messages, this);
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (GetACPlayer(player))
                    DestroyACPlayer(GetACPlayer(player));
            }
            foreach (var timer in timers)
                timer.Value.Destroy();
            timers.Clear();
            SaveData();
            ACPlayers.Clear();
        }

        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            if (configData.UseServerRewards)
            {
                try
                {
                    ServerRewards.Call("isLoaded", null);
                }
                catch (Exception)
                {
                    PrintWarning(GetMSG("NOSR", Name));
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }
            if (configData.UseEconomics)
            {
                try
                {
                    Economics.Call("isLoaded", null);
                    if (configData.UseServerRewards && configData.UseEconomics)
                    {
                        PrintWarning(GetMSG("BOTHERROR", Name));
                        Interface.Oxide.UnloadPlugin(Name);
                        return;
                    }
                }
                catch (Exception)
                {
                    PrintWarning(GetMSG("NOECO", Name));
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
            }
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                OnPlayerInit(p);
            }
            timers.Add("info", timer.Once(900, () => InfoLoop()));
            timers.Add("save", timer.Once(600, () => SaveLoop()));
            timers.Add("cond", timer.Once(120, () => CondLoop()));
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player != null)
            {
                player.Command($"bind {configData.MenuKeyBinding} \"OpenACUI\"");
                InitializeACPlayer(player);
                GetSendMSG(player, "ACInfo", configData.MenuKeyBinding.ToUpper());
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (EventManager)
            {
                object isPlaying = EventManager?.Call("isPlaying", new object[] { player });
                if (isPlaying is bool)
                    if ((bool)isPlaying)
                        return;
            }
            DestroyUI(player);
            if (GetACPlayer(player).PlayerGearSets.Count() < 1)
            {
                //UnityEngine.Object.Destroy(player);
                ACPlayers.Remove(GetACPlayer(player));
                InitializeACPlayer(player);
            }
            player.inventory.Strip();
            GiveSet(player);
            GiveWeapon(player);
            player.health = 100f;
            PlayerHUD(player);
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo hitInfo)
        {
            try
            {
                var attacker = hitInfo.Initiator.ToPlayer() as BasePlayer;
                var victim = entity.ToPlayer();
                if (entity is BasePlayer && hitInfo.Initiator is BasePlayer)
                {
                    if (entity as BasePlayer == null || hitInfo == null) return;
                    if (!GetACPlayer(attacker) || !GetACPlayer(victim)) return;
                    if (victim.userID != attacker.userID)
                    {
                        if (EventManager)
                        {
                            object isPlaying = EventManager?.Call("isPlaying", new object[] { attacker });
                            if (isPlaying is bool)
                                if ((bool)isPlaying)
                                    return;
                        }
                        GetACPlayer(attacker).kills += 1;
                        GetACPlayer(victim).deaths += 1;
                        if (configData.UseServerRewards)
                            SRAction(attacker.userID, configData.KillReward, "ADD");
                        else if (configData.UseEconomics)
                                ECOAction(attacker.userID, configData.KillReward, "ADD");
                            else
                            GetACPlayer(attacker).money += configData.KillReward;
                        GetACPlayer(attacker).GearSetKills[GetACPlayer(attacker).currentGearSet] += 1;
                        GetACPlayer(attacker).WeaponSetKills[GetACPlayer(attacker).currentWeaponSet] += 1;
                        SendDeathNote(attacker, victim);
                        PlayerHUD(attacker);
                    }
                }
            }
            catch (Exception)
            {
            }
        }

        private void SRAction(ulong ID, int amount, string action)
        {
            if (action == "ADD")
                ServerRewards?.Call("AddPoints", new object[] { ID, amount });
            if (action == "REMOVE")
                ServerRewards?.Call("TakePoints", new object[] { ID, amount });
        }

        private void ECOAction(ulong ID, int amount, string action)
        {
            if (action == "ADD")
                Economics.Call("DepositS", ID.ToString(), amount);
            if (action == "REMOVE") 
                Economics.Call("WithdrawS", ID.ToString(), amount);
        }

        object OnBetterChat(IPlayer iplayer, string message)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return message;
            if (SavingCollection.ContainsKey(player.userID))
            {
                CollectionCreationChat(player, message.Split(' '));
                return true;
            }
            return message;
        }

        private object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            if (BetterChat) return null;
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return null;
            if (SavingCollection.ContainsKey(player.userID))
            {
                CollectionCreationChat(player, arg.Args);
                return true;
            }
            return null;
        }

        private void CollectionCreationChat(BasePlayer player, string[] Args)
        {
            if (Args.Contains("quit"))
            {
                ExitSetCreation(player);
                return;
            }
            var args = string.Join(" ", Args);
            var name = args;
            if (SavingCollection[player.userID] == "gear")
            NewGearCollection[player.userID].setname = name;
            else if (SavingCollection[player.userID] == "weapon")
                NewWeaponCollection[player.userID].setname = name;
            SaveCollect(player);
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity != null)
            {
                corpsePrefabId = StringPool.Get(corpsePrefab);
                if (configData.UseEnviroControl)
                {
                    if (entity.prefabID == corpsePrefabId)
                    {
                        entity.Kill();
                    }
                    var collectible = entity as CollectibleEntity;
                    if (collectible != null)
                    {
                        collectible.itemList = null;
                    }
                    var worldItem = entity as WorldItem;
                    if (worldItem != null)
                    {
                        worldItem.allowPickup = false;
                    }
                    var Heli = entity as BaseHelicopter;
                    if (Heli != null)
                    {
                        Heli.Kill();
                    }
                    var Plane = entity as CargoPlane;
                    if (Plane != null)
                    {
                        Plane.Kill();
                    }
                }
            }
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity target)
        {
            if (configData.UseEnviroControl && !isAuth(looter))
            {
                if ((target as StorageContainer)?.transform.position == Vector3.zero) return;
                timer.Once(0.01f, looter.EndLooting);
            }
        }

        void OnPlantGather(PlantEntity Plant, Item item, BasePlayer player)
        {
            if (configData.UseEnviroControl && !isAuth(player))
            {
                item.amount = 0;
            }
        }


        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (configData.UseEnviroControl && !isAuth(player))
            {
                item.amount = 0;
            }
        }
        void OnDispenserGather(ResourceDispenser Dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (configData.UseEnviroControl && !isAuth(player))
            {
                item.amount = 0;
            }
        }

        object OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        {
            if (configData.UseEnviroControl && !isAuth(crafter))
            {
                task.cancelled = true;
            }
            return null;
        }
        #endregion

        #region Functions

        public string GetImage(string shortname, ulong skin = 0)
        {
            var img = ImageLibrary.GetImage(shortname, skin);
            return img;
        }

        private void InitializeACPlayer(BasePlayer player)
        {
            if (!player.GetComponent<ACPlayer>())
            {
                if (playerData.players.ContainsKey(player.userID))
                {
                    //if (playerData.priorSave.ContainsKey(player.userID))
                    //{
                    //    if (playerData.players[player.userID].PlayerGearSets.Count() < 1 && playerData.priorSave[player.userID].PlayerGearSets.Count() > 0)
                    //    {
                    //        playerData.players[player.userID] = playerData.priorSave[player.userID];
                    //    }
                    //}
                    //if (playerData.players[player.userID].PlayerGearSets.Count() < 1 && playerData.priorSave[player.userID].PlayerGearSets.Count() < 1)
                    //{
                    //    playerData.players.Remove(player.userID);
                    //    playerData.priorSave.Remove(player.userID);
                    //    InitializeACPlayer(player);
                    //    return;
                    //}
                    ACPlayers.Add(player.gameObject.AddComponent<ACPlayer>());
                    ACPlayer ac = GetACPlayer(player);
                    var d = playerData.players[player.userID];
                    ac.deaths = d.deaths;
                    ac.kills = d.kills;
                    ac.money = d.money;
                    ac.PlayerGearSets = d.PlayerGearSets;
                    ac.PlayerWeaponSets = d.PlayerWeaponSets;
                    ac.GearSetKills = d.GearSetKills;
                    ac.WeaponSetKills = d.WeaponSetKills;
                    ac.currentGearSet = d.lastgearSet;
                    ac.currentWeaponSet = d.lastweaponSet;
                    ac.CurrentWeapons = d.lastWeapons;
                }
                else
                {
                    ACPlayers.Add(player.gameObject.AddComponent<ACPlayer>());
                    ACPlayer ac = GetACPlayer(player);
                    ac.currentGearSet = null;
                    ac.kills = 0;
                    ac.deaths = 0;
                    ac.money = 0;
                }
            }
            CheckSets(GetACPlayer(player));
        }

        void CheckSets(ACPlayer player)
        {
            foreach (var entry in gwData.GearSets.Where(kvp => kvp.Value.cost == 0))
                if (!player.PlayerGearSets.ContainsKey(entry.Key))
                {
                    player.PlayerGearSets.Add(entry.Key, new List<string>());
                    player.GearSetKills.Add(entry.Key, 0);
                    foreach (var gear in gwData.GearSets[entry.Key].set.Where(kvp => kvp.free == true))
                        player.PlayerGearSets[entry.Key].Add(gear.shortname);
                }
            foreach (var entry in gwData.WeaponSets.Where(kvp => kvp.Value.cost == 0))
                if (!player.PlayerWeaponSets.ContainsKey(entry.Key))
                {
                    player.PlayerWeaponSets.Add(entry.Key, new Dictionary<string, List<string>>());
                    player.WeaponSetKills.Add(entry.Key, 0);
                    foreach (var weapons in gwData.WeaponSets[entry.Key].set.Where(kvp => kvp.free == true))
                        player.PlayerWeaponSets[entry.Key].Add(weapons.shortname, new List<string>());
                }
            List<string> gearset = new List<string>();
            List<string> weaponset = new List<string>();
            foreach (var entry in player.PlayerGearSets)
                if (!gwData.GearSets.ContainsKey(entry.Key))
                {
                    gearset.Add(entry.Key);
                    if (player.currentGearSet == entry.Key)
                    {
                        player.currentGearSet = null;
                    }
                }
            foreach (var entry in player.PlayerWeaponSets)
                if (!gwData.WeaponSets.ContainsKey(entry.Key))
                {
                    weaponset.Add(entry.Key);
                    if (GetACPlayer(player.player).currentWeaponSet == entry.Key)
                    {
                        player.CurrentWeapons.Clear();
                        player.currentWeaponSet = null;
                    }
                }
            if (gearset != null)
                foreach (var entry in gearset)
                {
                    player.PlayerGearSets.Remove(entry);
                    player.GearSetKills.Remove(entry);
                }
            if (weaponset != null)
                foreach (var entry in weaponset)
                {
                    player.PlayerWeaponSets.Remove(entry);
                    player.WeaponSetKills.Remove(entry);
                }
            if (!gwData.GearSets.ContainsKey(player.currentGearSet)) player.currentGearSet = null;
            if (!gwData.WeaponSets.ContainsKey(player.currentWeaponSet)) player.currentWeaponSet = null;
            if (string.IsNullOrEmpty(player.currentGearSet) && player.PlayerGearSets.Count() > 0)
                player.currentGearSet = player.PlayerGearSets.First().Key;

            if (string.IsNullOrEmpty(player.currentWeaponSet) && player.PlayerWeaponSets.Count() > 0 || player.CurrentWeapons == null && player.PlayerWeaponSets.Count() > 0)
            {
                Puts("TRYING");
                player.currentWeaponSet = player.PlayerWeaponSets.First().Key;
                if (player.CurrentWeapons == null)
                    player.CurrentWeapons = new Dictionary<string, List<string>>();
                else player.CurrentWeapons.Clear();
                foreach (var wp in player.PlayerWeaponSets[player.currentWeaponSet])
                {
                    Puts($"ADDING:{wp.Key}");
                    player.CurrentWeapons.Add(wp.Key, new List<string>());
                    Puts("Items done");
                }
            }
            player.player.inventory.Strip();
            GiveSet(player.player);
            GiveWeapon(player.player);
            PlayerHUD(player.player);
        }

        private object CheckPoints(ulong ID) => ServerRewards?.Call("CheckPoints", ID);

        void DestroyACPlayer(ACPlayer player)
        {
            if (player.player == null) return;
            {
                SaveACPlayer(player);
                DestroyUI(player.player);
                player.player.Command($"bind {configData.MenuKeyBinding} \"\"");
                player.player.Command($"bind tab \"inventory.toggle\"");
                if (ACPlayers.Contains(player))
                {
                    UnityEngine.Object.Destroy(player);
                    ACPlayers.Remove(player);
                }
                ACUIInfo.Remove(player.player.userID);
            }
        }

        ACPlayer GetACPlayer(BasePlayer player)
        {
            if (!player.GetComponent<ACPlayer>())
                return null;
            else return player.GetComponent<ACPlayer>();
        }


        private string GetLang(string msg)
        {
            if (messages.ContainsKey(msg))
                return lang.GetMessage(msg, this);
            else return msg;
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string msg = string.Format(GetLang(message), arg1, arg2, arg3);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private string GetMSG(string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this), arg1, arg2, arg3);
            return msg;
        }

        static void TPPlayer(BasePlayer player, Vector3 destination)
        {
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
            StartSleeping(player);
            player.MovePosition(destination);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
            player.TransformChanged();
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }
        static void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }

        [ConsoleCommand("OpenACUI")]
        private void cmdOpenACUI(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (ACUIInfo.ContainsKey(player.userID))
                if (!ACUIInfo[player.userID].open)
                {
                    ACUIInfo[player.userID].open = true;
                    OpenACUI(player);
                }
                else
                    DestroyACPanel(player);
            else
                OpenACUI(player);
        }

        private void OpenACUI(BasePlayer player)
        {
            if (!ACUIInfo.ContainsKey(player.userID))
                ACUIInfo.Add(player.userID, new screen { admin = false, open = true, GearIndex = 0, GearSet = "", WeaponIndex = 0, WeaponSet = "" });
            ACPanel(player);
            GearListPanel(player);
            WeaponListPanel(player);
            GearPanel(player);
            WeaponPanel(player);
        }


        public void DestroyUI(BasePlayer player)
        {
            DestroyACPanel(player);
            CuiHelper.DestroyUi(player, PanelOnScreen);
            CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
            CuiHelper.DestroyUi(player, PanelStats);
        }

        public void DestroyACPanel(BasePlayer player)
        {
            if (ACUIInfo.ContainsKey(player.userID))
                ACUIInfo[player.userID].open = false;
            CuiHelper.DestroyUi(player, PanelAC);
            CuiHelper.DestroyUi(player, GPanel);
            CuiHelper.DestroyUi(player, WPanel);
            CuiHelper.DestroyUi(player, GLPanel);
            CuiHelper.DestroyUi(player, WLPanel);
            CuiHelper.DestroyUi(player, APanel);
        }

        public void Broadcast(string message, string userid = "0") => PrintToChat(message);

        private void SendDeathNote(BasePlayer player, BasePlayer victim)
        {
            string colorAttacker = "";
            string colorVictim = "";

            colorAttacker = "<color=#e60000>";
            colorVictim = "<color=#3366ff>";
            if (configData.BroadcastDeath)
            {
                string formatMsg = colorAttacker + player.displayName + "</color>" + GetLang("DeathMessage") + colorVictim + victim.displayName + "</color>";
                Broadcast(formatMsg);
            }
        }


        private void SaveCollect(BasePlayer player)
        {
            if (!SavingCollection.ContainsKey(player.userID)) return;
            var index = 0;
            var name = "";
            var type = SavingCollection[player.userID];
            if (type == "gear")
            {
                if (gwData.GearSets.Count == 0)
                    index = 0;
                else index = gwData.GearSets.Max(kvp => kvp.Value.index) + 1;
                List<Gear> gearlist = new List<Gear>();
                foreach (var entry in NewGearCollection[player.userID].collection.set)
                    gearlist.Add(entry.Value);
                name = NewGearCollection[player.userID].setname;
                var newset = new GearSet { cost = NewGearCollection[player.userID].collection.cost, killsrequired = NewGearCollection[player.userID].collection.killsrequired, set = gearlist, index = index };
                gwData.GearSets.Add(name, newset);
                NewGearCollection.Remove(player.userID);
            }
            else if(type == "weapon")
            {
                if (gwData.WeaponSets.Count == 0)
                    index = 0;
                else index = gwData.WeaponSets.Max(kvp => kvp.Value.index) + 1;
                List<Weapon> gearlist = new List<Weapon>();
                foreach (var entry in NewWeaponCollection[player.userID].collection.set)
                    gearlist.Add(entry.Value);
                name = NewWeaponCollection[player.userID].setname;
                var newset = new WeaponSet { cost = NewWeaponCollection[player.userID].collection.cost, killsrequired = NewWeaponCollection[player.userID].collection.killsrequired, set = gearlist, index = index };
                gwData.WeaponSets.Add(name, newset);
                NewWeaponCollection.Remove(player.userID);
            }
            SavingCollection.Remove(player.userID);
            GetSendMSG(player, "NewCollectionCreated", type.ToUpper(), name);
            DestroyACPanel(player);
            SaveData();
        }


        private void ExitSetCreation(BasePlayer player)
        {
            if (!SavingCollection.ContainsKey(player.userID)) return;
            SavingCollection.Remove(player.userID);
            DestroyACPanel(player);
        }

        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 1)
                    return false;
            return true;
        }

        private List<BasePlayer> FindPlayer(string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid)
                        {
                            foundPlayers.Add(p);
                            return foundPlayers;
                        }
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                        foundPlayers.Add(p);
                }
            return foundPlayers;
        }

        [ConsoleCommand("addmoney")]
        private void cmdaddmoney(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
                if (arg.connection.authLevel < 1)
                {
                    if (arg.connection.player != null)
                    {
                        var player = arg.connection.player as BasePlayer;
                        GetSendMSG(player, "NotAuthorized");
                    }
                    return;
                }
            chatAddMoney(null, "addmoney", arg.Args);
        }

        [ConsoleCommand("takemoney")]
        private void cmdtakemoney(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
                if (arg.connection.authLevel < 1)
                {
                    if (arg.connection.player != null)
                    {
                        var player = arg.connection.player as BasePlayer;
                        GetSendMSG(player, "NotAuthorized");
                    }
                    return;
                }
            chattakemoney(null, "takemoney", arg.Args);
        }

        [ConsoleCommand("addkills")]
        private void cmdaddkills(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
                if (arg.connection.authLevel < 1)
                {
                    if (arg.connection.player != null)
                    {
                        var player = arg.connection.player as BasePlayer;
                        GetSendMSG(player, "NotAuthorized");
                    }
                    return;
                }
            chatAddKills(null, "addkills", arg.Args);
        }

        [ConsoleCommand("takekills")]
        private void cmdtakekills(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
                if (arg.connection.authLevel < 1)
                {
                    if (arg.connection.player != null)
                    {
                        var player = arg.connection.player as BasePlayer;
                        GetSendMSG(player, "NotAuthorized");
                    }
                    return;
                }
            chatTakeKills(null, "takekills", arg.Args);
        }

        [ChatCommand("addmoney")]
        private void chatAddMoney(BasePlayer player, string command, string[] args)
        {
            if (player != null)
            {
                if (!isAuth(player))
                {
                    GetSendMSG(player, "NotAuthorized");
                    return;
                }
            }
            if (args.Length == 2)
            {
                int amount;
                if (!int.TryParse(args[1], out amount))
                {
                    if (player == null)
                        Puts(GetMSG("INVALIDENTRY", args[1]));
                    else
                        GetSendMSG(player, "INVALIDENTRY", args[1]);
                    return;
                }
                var partialPlayerName = args[0];
                var foundPlayers = FindPlayer(partialPlayerName);
                if (foundPlayers.Count() == 0)
                {
                    if (player == null)
                        Puts(GetMSG("NoPlayers", args[0]));
                    else
                        GetSendMSG(player, "NoPlayers", args[0]);
                    return;
                }
                if (foundPlayers.Count() > 1)
                {
                    if (player == null)
                        Puts(GetMSG("MultiplePlayers", args[0]));
                    else
                        GetSendMSG(player, "MultiplePlayers", args[0]);
                    return;
                }
                if (foundPlayers[0] != null)
                {
                    ulong requestor = 0;
                    if (player != null)
                        requestor = player.userID;
                    AddMoney(foundPlayers[0].userID, amount, true, requestor);
                    PlayerHUD(foundPlayers[0]);
                }
            }
            else
            {
                if (player == null)
                    Puts(GetMSG("ArgumentsIncorrect", "/addmoney PLAYERNAME AMOUNT", "/addmoney Absolut 20"));
                else
                    GetSendMSG(player, "ArgumentsIncorrect", "/addmoney PLAYERNAME AMOUNT", "/addmoney Absolut 20");
            }
        }

        [ChatCommand("addkills")]
        private void chatAddKills(BasePlayer player, string command, string[] args)
        {
            if (player != null)
            {
                if (!isAuth(player))
                {
                    GetSendMSG(player, "NotAuthorized");
                    return;
                }
            }
            if (args.Length == 4)
            {
                int amount;
                if (!int.TryParse(args[3], out amount))
                {
                    if (player == null)
                        Puts(GetMSG("INVALIDENTRY", args[1]));
                    else
                        GetSendMSG(player, "INVALIDENTRY", args[1]);
                    return;
                }
                var partialPlayerName = args[0];
                var type = args[1];
                var collection = args[2];
                var foundPlayers = FindPlayer(partialPlayerName);
                if (foundPlayers.Count() == 0)
                {
                    if (player == null)
                        Puts(GetMSG("NoPlayers", args[0]));
                    else
                        GetSendMSG(player, "NoPlayers", args[0]);
                    return;
                }
                if (foundPlayers.Count() > 1)
                {
                    if (player == null)
                        Puts(GetMSG("MultiplePlayers", args[0]));
                    else
                        GetSendMSG(player, "MultiplePlayers", args[0]);
                    return;
                }
                if (foundPlayers[0] != null)
                {
                    ulong requestor = 0;
                    if (player != null)
                        requestor = player.userID;
                    if (type == "weapon")
                    {
                        if (gwData.WeaponSets.ContainsKey(collection) && playerData.players[foundPlayers[0].userID].PlayerWeaponSets.ContainsKey(collection))
                            AddKills(foundPlayers[0].userID, amount, type, collection, requestor);
                        }
                    else if (type == "gear")
                    {
                            if (gwData.GearSets.ContainsKey(collection) && playerData.players[foundPlayers[0].userID].PlayerGearSets.ContainsKey(collection))
                                AddKills(foundPlayers[0].userID, amount, type, collection, requestor);
                        }
                    PlayerHUD(foundPlayers[0]);
                }
            }
            else
            {
                if (player == null)
                    Puts(GetMSG("ArgumentsIncorrect", "/addkills PLAYERNAME TYPE COLLECTION AMOUNT", "/addkills Absolut weapon starter 20"));
                else
                    GetSendMSG(player, "ArgumentsIncorrect", "/addkills PLAYERNAME TYPE COLLECTION AMOUNT", "/addkills Absolut weapon starter 20");
            }
        }

        [ChatCommand("takekills")]
        private void chatTakeKills(BasePlayer player, string command, string[] args)
        {
            if (player != null)
            {
                if (!isAuth(player))
                {
                    GetSendMSG(player, "NotAuthorized");
                    return;
                }
            }
            if (args.Length == 4)
            {
                int amount;
                if (!int.TryParse(args[3], out amount))
                {
                    if (player == null)
                        Puts(GetMSG("INVALIDENTRY", args[1]));
                    else
                        GetSendMSG(player, "INVALIDENTRY", args[1]);
                    return;
                }
                var partialPlayerName = args[0];
                var type = args[1];
                var collection = args[2];
                var foundPlayers = FindPlayer(partialPlayerName);
                if (foundPlayers.Count() == 0)
                {
                    if (player == null)
                        Puts(GetMSG("NoPlayers", args[0]));
                    else
                        GetSendMSG(player, "NoPlayers", args[0]);
                    return;
                }
                if (foundPlayers.Count() > 1)
                {
                    if (player == null)
                        Puts(GetMSG("MultiplePlayers", args[0]));
                    else
                        GetSendMSG(player, "MultiplePlayers", args[0]);
                    return;
                }
                if (foundPlayers[0] != null)
                {
                    ulong requestor = 0;
                    if (player != null)
                        requestor = player.userID;
                    if (type == "weapon")
                    {
                        if (gwData.WeaponSets.ContainsKey(collection) && playerData.players[foundPlayers[0].userID].PlayerWeaponSets.ContainsKey(collection))
                            TakeKills(foundPlayers[0].userID, amount, type, collection, requestor);
                    }
                    else if (type == "gear")
                    {
                        if (gwData.GearSets.ContainsKey(collection) && playerData.players[foundPlayers[0].userID].PlayerGearSets.ContainsKey(collection))
                            TakeKills(foundPlayers[0].userID, amount, type, collection, requestor);
                    }
                    PlayerHUD(foundPlayers[0]);
                }
            }
            else
            {
                if (player == null)
                    Puts(GetMSG("ArgumentsIncorrect", "/takekills PLAYERNAME TYPE COLLECTION AMOUNT", "/takekills Absolut weapon starter 20"));
                else
                    GetSendMSG(player, "ArgumentsIncorrect", "/takekills PLAYERNAME TYPE COLLECTION AMOUNT", "/takekills Absolut weapon starter 20");
            }
        }


        [ChatCommand("takemoney")]
        private void chattakemoney(BasePlayer player, string command, string[] args)
        {
            if (player != null)
            {
                if (!isAuth(player))
                {
                    GetSendMSG(player, "NotAuthorized");
                    return;
                }
            }
            if (args.Length == 2)
            {
                int amount;
                if (!int.TryParse(args[1], out amount))
                {
                    if (player == null)
                        Puts(GetMSG("INVALIDENTRY", args[1]));
                    else
                        GetSendMSG(player, "INVALIDENTRY", args[1]);
                    return;
                }
                var partialPlayerName = args[0];
                var foundPlayers = FindPlayer(partialPlayerName);
                if (foundPlayers.Count() == 0)
                {
                    if (player == null)
                        Puts(GetMSG("NoPlayers", args[0]));
                    else
                        GetSendMSG(player, "NoPlayers", args[0]);
                    return;
                }
                if (foundPlayers.Count() > 1)
                {
                    if (player == null)
                        Puts(GetMSG("MultiplePlayers", args[0]));
                    else
                        GetSendMSG(player, "MultiplePlayers", args[0]);
                    return;
                }
                if (foundPlayers[0] != null)
                {
                    ulong requestor = 0;
                    if (player != null)
                        requestor = player.userID;
                    TakeMoney(foundPlayers[0].userID, amount, true, requestor);
                    PlayerHUD(foundPlayers[0]);
                }
            }
            else
            {
                if (player == null)
                    Puts(GetMSG("ArgumentsIncorrect", "/takemoney PLAYERNAME AMOUNT", "/takemoney Absolut 20"));
                else
                    GetSendMSG(player, "ArgumentsIncorrect", "/takemoney PLAYERNAME AMOUNT", "/takemoney Absolut 20");
            }
        }

        #endregion

        #region UI Creation
        private string PanelAC = "PanelAC";
        private string GLPanel = "GLPanel";
        private string WLPanel = "WLPanel";
        private string GPanel = "GPanel";
        private string WPanel = "WPanel";
        private string APanel = "APanel";
        private string PanelOnScreen = "OnScreen";
        private string PanelPurchaseConfirmation = "PurchaseConfirmation";
        private string PanelStats = "StatsPanel";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer container, string panel, string png, string aMin, string aMax)
            {
                container.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                });
            }

            static public void CreateTextOverlay(ref CuiElementContainer container, string panel, string text, string color, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter, float fadein = 1.0f)
            {
                //if (configdata.DisableUI_FadeIn)
                //    fadein = 0;
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = fadein, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }
            static public void CreateTextOutline(ref CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string DistanceA, string DistanceB, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent{Color = colorText, FontSize = size, Align = align, Text = text },
                        new CuiOutlineComponent {Distance = DistanceA + " " + DistanceB, Color = colorOutline},
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "1 1 1 0.3" },
            {"light", ".564 .564 .564 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"white", "1 1 1 1" },
            {"limegreen", "0.42 1.0 0 1.0" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"customblue", "0.454 0.77 1.0 1.0" },
            {"CSorange", "1.0 0.64 0.10 1.0" }
        };

        private Dictionary<string, string> TextColors = new Dictionary<string, string>
        {
            {"limegreen", "<color=#6fff00>" }
        };


        private Dictionary<Slot, Vector2> LeftGearSlotPos = new Dictionary<Slot, Vector2>
        {
            { Slot.head, new Vector2(.4f, .65f) },
            { Slot.chest, new Vector2(.27f, .45f) },
            { Slot.legs, new Vector2(.27f, .25f) },
            { Slot.hands, new Vector2(.27f, .05f) },
        };

        private Dictionary<Slot, Vector2> RightGearSlotPos = new Dictionary<Slot, Vector2>
        {
            { Slot.chest2, new Vector2(.49f, .45f) },
            { Slot.legs2, new Vector2(.49f, .25f) },
            { Slot.feet, new Vector2(.49f, .05f) },
        };

        private Dictionary<Slot, Vector2> GearSlotPos = new Dictionary<Slot, Vector2>
        {
            { Slot.head, new Vector2(.4f, .65f) },
            { Slot.chest, new Vector2(.27f, .45f) },
            { Slot.chest2, new Vector2(.49f, .45f) },
            { Slot.legs, new Vector2(.27f, .25f) },
            { Slot.legs2, new Vector2(.49f, .25f) },
            { Slot.feet, new Vector2(.49f, .05f) },
            { Slot.hands, new Vector2(.27f, .05f) },
        };

        private Dictionary<Slot, Vector2> WeaponSlotPos = new Dictionary<Slot, Vector2>
        {
            { Slot.main, new Vector2(.27f, .45f) },
            { Slot.secondary, new Vector2(.49f, .45f) },
    };

        private Dictionary<Slot, Vector2> MainAttachmentSlotsPos = new Dictionary<Slot, Vector2>
        {
            { Slot.attachment1, new Vector2(.29f, .75f) },
            { Slot.attachment2, new Vector2(.29f, .45f) },
            { Slot.attachment3, new Vector2(.29f, .15f) },
    };

        private Dictionary<Slot, Vector2> SecondaryAttachmentSlotsPos = new Dictionary<Slot, Vector2>
        {
            { Slot.attachment1, new Vector2(.53f, .75f) },
            { Slot.attachment2, new Vector2(.53f, .45f) },
            { Slot.attachment3, new Vector2(.53f, .15f) },
    };
        private Dictionary<Slot, Vector2> AccessoriesSlotsPos = new Dictionary<Slot, Vector2>
        {
            { Slot.accessories1, new Vector2(.7f, .85f) },
            { Slot.accessories2, new Vector2(.7f, .7f) },
        };
        private Dictionary<Slot, Vector2> AmmunitionSlotsPos = new Dictionary<Slot, Vector2>
        {
            { Slot.ammunitionMain, new Vector2(.13f, 1.2f) },
            { Slot.ammunitionSecondary, new Vector2(.7f, 1.2f) },

        };
        #endregion 

        #region UI Panels

        void ACPanel(BasePlayer player)
        {
            //CuiHelper.DestroyUi(player, PanelAC);
            //var element = UI.CreateElementContainer(PanelAC, UIColors["dark"], "0.15 0.2", "0.87 0.8", true);
            //UI.CreatePanel(ref element, PanelAC, UIColors["header"], "0.01 0.02", "0.97 0.98");
            //RENDER IMAGE FROM TNT OR WHATEVER I USE...
            //CuiHelper.AddUi(player, element);
        }


        void GearListPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, GLPanel);
            var element = UI.CreateElementContainer(GLPanel, UIColors["dark"], "0.05 0.5", "0.15 0.8",true);
            UI.CreatePanel(ref element, GLPanel, UIColors["light"], $"0.05 0.03", $".95 .97");
            UI.CreateTextOutline(ref element, GLPanel, UIColors["white"], UIColors["black"], GetLang("GearCollection"), 14, "1", "1", "0.1 0.85", "0.9 0.94", TextAnchor.MiddleCenter);
            if (gwData.GearSets.Count() >= 1)
            {
                if (ACUIInfo[player.userID].GearIndex != 0)
                {
                    UI.LoadImage(ref element, GLPanel, GetImage("up"), "0.25 0.9", "0.75 1");
                    UI.CreateButton(ref element, GLPanel, "0 0 0 0", "", 12, "0.25 0.9", "0.75 1", $"UI_GearIndexShownChange {ACUIInfo[player.userID].GearIndex - 1}");
                }
                if (ACUIInfo[player.userID].GearIndex + 6 < gwData.GearSets.Max(kvp => kvp.Value.index))
                {
                    UI.LoadImage(ref element, GLPanel, GetImage("down"), "0.25 -.05", "0.75 0.05");
                    UI.CreateButton(ref element, GLPanel, "0 0 0 0", "", 12, "0.25 -.05", "0.75 0.05", $"UI_GearIndexShownChange {ACUIInfo[player.userID].GearIndex + 1}");
                }
                foreach (var entry in gwData.GearSets)
                {
                    if (entry.Value.index < ACUIInfo[player.userID].GearIndex) continue;
                    if (entry.Value.index > ACUIInfo[player.userID].GearIndex + 6) continue;
                    var pos = CalcSetButtons(entry.Value.index - ACUIInfo[player.userID].GearIndex);
                    if (ACUIInfo[player.userID].GearSet == entry.Key) UI.CreatePanel(ref element, GLPanel, UIColors["yellow"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    else if (GetACPlayer(player).PlayerGearSets.ContainsKey(entry.Key)) UI.CreatePanel(ref element, GLPanel, UIColors["green"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    else UI.CreatePanel(ref element, GLPanel, UIColors["red"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateButton(ref element, GLPanel, "0 0 0 0", entry.Key, 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ChangeGearSet {entry.Key}", TextAnchor.MiddleCenter);
                }
            }
            if (ACUIInfo[player.userID].admin)
                if (!NewGearCollection.ContainsKey(player.userID))
                    UI.CreateButton(ref element, GLPanel, UIColors["blue"], GetLang("CreateCollection"), 10, "0.1 -0.11", "0.9 -0.01", $"UI_CreateGearSet");
            CuiHelper.AddUi(player, element);
        }

        void WeaponListPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, WLPanel);
            var element = UI.CreateElementContainer(WLPanel, UIColors["dark"], "0.75 0.51", "0.85 0.8", true);
            UI.CreatePanel(ref element, WLPanel, UIColors["light"], $"0.05 0.03", $".95 .97");
            UI.CreateTextOutline(ref element, WLPanel, UIColors["white"], UIColors["black"], GetLang("WeaponCollection"), 14, "1", "1","0.1 0.85", "0.9 0.94", TextAnchor.MiddleCenter);
            if (gwData.WeaponSets.Count() >= 1)
            {
                if (ACUIInfo[player.userID].WeaponIndex != 0)
                {
                    UI.LoadImage(ref element, WLPanel, GetImage("up"), "0.25 0.9", "0.75 1");
                    UI.CreateButton(ref element, WLPanel, "0 0 0 0", "", 12, "0.25 0.9", "0.75 1", $"UI_WeaponIndexShownChange {ACUIInfo[player.userID].WeaponIndex - 1}");
                }
                if (ACUIInfo[player.userID].WeaponIndex + 6 < gwData.WeaponSets.Max(kvp => kvp.Value.index))
                {
                    UI.LoadImage(ref element, WLPanel, GetImage("down"), "0.25 -.05", "0.75 0.05");
                    UI.CreateButton(ref element, WLPanel, "0 0 0 0", "", 12, "0.25 -.05", "0.75 0.05", $"UI_WeaponIndexShownChange {ACUIInfo[player.userID].WeaponIndex + 1}");
                }
                foreach (var entry in gwData.WeaponSets)
                {
                    if (entry.Value.index < ACUIInfo[player.userID].WeaponIndex) continue;
                    if (entry.Value.index > ACUIInfo[player.userID].WeaponIndex + 6) continue;
                    var pos = CalcSetButtons(entry.Value.index - ACUIInfo[player.userID].WeaponIndex);
                    if (ACUIInfo[player.userID].WeaponSet == entry.Key) UI.CreatePanel(ref element, WLPanel, UIColors["yellow"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    else if (GetACPlayer(player).PlayerWeaponSets.ContainsKey(entry.Key)) UI.CreatePanel(ref element, WLPanel, UIColors["green"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    else UI.CreatePanel(ref element, WLPanel, UIColors["red"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                    UI.CreateButton(ref element, WLPanel, "0 0 0 0", entry.Key, 14, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ChangeWeaponSet {entry.Key}", TextAnchor.MiddleCenter);
                }
            }
            if (isAuth(player))
                UI.CreateButton(ref element, WLPanel, UIColors["orange"], GetLang("ToggleAdminView"), 12, "0.1 1.01", "0.9 1.15", "UI_SwitchAdminView", TextAnchor.MiddleCenter);
            if (ACUIInfo[player.userID].admin)
                if (!NewWeaponCollection.ContainsKey(player.userID))
                    UI.CreateButton(ref element, WLPanel, UIColors["blue"], GetLang("CreateCollection"), 10, "0.1 -0.11", "0.9 -0.01", $"UI_CreateWeaponSet");
            CuiHelper.AddUi(player, element);
        }

        private float[] CalcSetButtons(int number)
        {
            Vector2 position = new Vector2(0.055f, 0.74f);
            Vector2 dimensions = new Vector2(0.87f, 0.1f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 7)
            {
                offsetY = (-0.01f - dimensions.y) * number;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        void GearPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, GPanel);
            var element = UI.CreateElementContainer(GPanel, "0 0 0 0", "0.15 0.2", "0.45 0.8", true);
            if (NewGearCollection.ContainsKey(player.userID) && ACUIInfo[player.userID].admin)
            {
                Vector2 min = new Vector2(0f, 0f);
                Vector2 dimension = new Vector2(.2f, .15f);
                Vector2 offset2 = new Vector2(0.25f, 0f);
                Vector2 altmin;
                Vector2 max;
                Vector2 altmax;
                Dictionary<Slot, string> Usedslots = new Dictionary<Slot, string>();
                List<Slot> Unusedslots = new List<Slot>();
                foreach (var block in LeftGearSlotPos)
                {
                    foreach (var entry in NewGearCollection[player.userID].collection.set.Where(kvp => kvp.Value.slot == block.Key))
                        Usedslots.Add(entry.Value.slot, entry.Value.shortname);
                }
                foreach (var block in LeftGearSlotPos)
                    if (!Usedslots.ContainsKey(block.Key))
                        Unusedslots.Add(block.Key);
                foreach (var entry in Usedslots)
                {
                    min = LeftGearSlotPos[entry.Key];
                    max = min + dimension;
                    altmin = min - offset2;
                    altmax = altmin + dimension;

                    UI.LoadImage(ref element, GPanel, GetImage(entry.Value, NewGearCollection[player.userID].collection.set[entry.Value].skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                    UI.CreateButton(ref element, GPanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry.Key)} gear", TextAnchor.MiddleCenter);
                    if (NewGearCollection[player.userID].collection.set[entry.Value].free)
                    {
                        UI.CreatePanel(ref element, GPanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("Free"), 16, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                    }
                    else
                    {
                        if (NewGearCollection[player.userID].collection.set[entry.Value].price == 0 && NewGearCollection[player.userID].collection.set[entry.Value].killsrequired == 0)
                        {
                            UI.CreatePanel(ref element, GPanel, UIColors["red"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                            UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("ClickToDetail", NewGearCollection[player.userID].collection.set[entry.Value].price.ToString(), NewGearCollection[player.userID].collection.set[entry.Value].killsrequired.ToString()), 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        }
                        else
                        {
                            UI.CreatePanel(ref element, GPanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                            UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("ItemGearCost", NewGearCollection[player.userID].collection.set[entry.Value].price.ToString(), NewGearCollection[player.userID].collection.set[entry.Value].killsrequired.ToString()), 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        }
                    }
                    UI.CreateButton(ref element, GPanel, "0 0 0 0", "", 16, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", $"UI_AddItemAttributes {entry.Value} gear", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, GPanel, UIColors["red"], GetLang("Remove"), 12, $"{altmin.x - .05f} {altmin.y + .05f}", $"{altmin.x} {altmax.y - .05f}", $"UI_RemoveItem {entry.Value} gear", TextAnchor.MiddleCenter);
                }
                foreach (var entry in Unusedslots)
                {
                    min = LeftGearSlotPos[entry];
                    max = min + dimension;
                    UI.CreatePanel(ref element, GPanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                    UI.CreatePanel(ref element, GPanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                    if (NewGearCollection[player.userID].collection.set.Count() < 6)
                        UI.CreateButton(ref element, GPanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry)} gear", TextAnchor.MiddleCenter);
                    else UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("CollectionFull"), 12, "1", "1", $"{min.x} {min.y}", $"{max.x} {max.y}");
                }
                Usedslots.Clear();
                Unusedslots.Clear();
                foreach (var block in RightGearSlotPos)
                {
                    foreach (var entry in NewGearCollection[player.userID].collection.set.Where(kvp => kvp.Value.slot == block.Key))
                        Usedslots.Add(entry.Value.slot, entry.Value.shortname);
                }
                foreach (var block in RightGearSlotPos)
                    if (!Usedslots.ContainsKey(block.Key))
                        Unusedslots.Add(block.Key);
                foreach (var entry in Usedslots)
                {
                    min = RightGearSlotPos[entry.Key];
                    max = min + dimension;
                    altmin = min + offset2;
                    altmax = altmin + dimension;

                    UI.LoadImage(ref element, GPanel, GetImage(entry.Value, NewGearCollection[player.userID].collection.set[entry.Value].skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                    UI.CreateButton(ref element, GPanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry.Key)} gear", TextAnchor.MiddleCenter);
                    if (NewGearCollection[player.userID].collection.set[entry.Value].free)
                    {
                        UI.CreatePanel(ref element, GPanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("Free"), 16, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                    }
                    else
                    {
                        if (NewGearCollection[player.userID].collection.set[entry.Value].price == 0 && NewGearCollection[player.userID].collection.set[entry.Value].killsrequired == 0)
                        {
                            UI.CreatePanel(ref element, GPanel, UIColors["red"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                            UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("ClickToDetail", NewGearCollection[player.userID].collection.set[entry.Value].price.ToString(), NewGearCollection[player.userID].collection.set[entry.Value].killsrequired.ToString()), 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        }
                        else
                        {
                            UI.CreatePanel(ref element, GPanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                            UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("ItemGearCost", NewGearCollection[player.userID].collection.set[entry.Value].price.ToString(), NewGearCollection[player.userID].collection.set[entry.Value].killsrequired.ToString()), 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        }
                    }
                    UI.CreateButton(ref element, GPanel, "0 0 0 0", "", 16, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", $"UI_AddItemAttributes {entry.Value} gear", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, GPanel, UIColors["red"], GetLang("Remove"), 12, $"{altmin.x + .2f} {altmin.y + .05f}", $"{altmin.x + .25f} {altmax.y - .05f}", $"UI_RemoveItem {entry.Value} gear", TextAnchor.MiddleCenter);
                }
                foreach (var entry in Unusedslots)
                {
                    min = RightGearSlotPos[entry];
                    max = min + dimension;
                    UI.CreatePanel(ref element, GPanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                    UI.CreatePanel(ref element, GPanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                    if (NewGearCollection[player.userID].collection.set.Count() < 6)
                        UI.CreateButton(ref element, GPanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry)} gear", TextAnchor.MiddleCenter);
                    else UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("CollectionFull"), 12, "1", "1", $"{min.x} {min.y}", $"{max.x} {max.y}");
                }

                /////////////////
                if (configData.UseAccessories)
                {

                }



                UI.CreateButton(ref element, GPanel, UIColors["red"], GetLang("CancelCollection"), 14, "0.35 -.02", "0.65 0.02", $"UI_CancelGearSet");
                UI.CreateButton(ref element, GPanel, UIColors["green"], GetMSG("SaveCollection"), 18, "0.1 0.86", "0.9 0.91", $"UI_SaveCollect gear");
            }
            else
            {
                var set = ACUIInfo[player.userID].GearSet;
                if (!PendingPurchase.ContainsKey(player.userID))
                    PendingPurchase.Add(player.userID, new PurchaseItem { });
                else
                    PendingPurchase[player.userID].gear.Clear();
                var money = GetACPlayer(player).money;
                if (configData.UseServerRewards)
                    if (CheckPoints(player.userID) is int)
                        money = (int)CheckPoints(player.userID);
                else if (configData.UseEconomics)
                        money = (int)Economics.CallHook("GetPlayerMoney", player.userID);
                if (set == "") return;
                UI.CreateTextOutline(ref element, GPanel, UIColors["black"], UIColors["white"], GetMSG("BuySubMenu", set.ToUpper()), 20, "1", "1", "0.1 0.94", "0.9 0.99");
                foreach (var entry in gwData.GearSets.Where(kvp => kvp.Key == set))
                {
                    foreach (var block in LeftGearSlotPos)
                    {
                        var min = block.Value;
                        var max = block.Value + new Vector2(.2f, .15f);
                        UI.CreatePanel(ref element, GPanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                        UI.CreatePanel(ref element, GPanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                    }

                    foreach (var block in RightGearSlotPos)
                    {
                        var min = block.Value;
                        var max = block.Value + new Vector2(.2f, .15f);
                        UI.CreatePanel(ref element, GPanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                        UI.CreatePanel(ref element, GPanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                    }
                    foreach (var item in entry.Value.set)
                    {
                        string info = "";
                        PendingPurchase[player.userID].gear.Add(item.shortname, item);
                        Vector2 min = new Vector2(0f, 0f);
                        Vector2 dimension = new Vector2(.2f, .15f);
                        Vector2 offset2 = new Vector2(0.25f, 0f);
                        Vector2 altmin;

                        if (LeftGearSlotPos.ContainsKey(item.slot))
                        {
                            min = LeftGearSlotPos[item.slot];
                            altmin = min - offset2;
                        }
                        else if (RightGearSlotPos.ContainsKey(item.slot))
                        {
                            min = RightGearSlotPos[item.slot];
                            altmin = min + offset2;
                        }
                        else continue;
                        Vector2 max = min + dimension;
                        Vector2 altmax = altmin + dimension;


                        if (GetACPlayer(player).PlayerGearSets.ContainsKey(set))
                        {
                            if (GetACPlayer(player).currentGearSet == set)
                            {
                                UI.CreateButton(ref element, GPanel, UIColors["green"], GetMSG("CurrentlyEquipped"), 18, "0.1 0.86", "0.9 0.91", $"UI_ProcessSelection set {set}");
                            }
                            else
                            {
                                UI.CreateButton(ref element, GPanel, UIColors["green"], GetMSG("SelectCollection", set.ToUpper()), 18, "0.1 0.86", "0.9 0.91", $"UI_ProcessSelection set {set}");
                            }
                            UI.CreateTextOutline(ref element, GPanel, UIColors["white"], UIColors["green"], GetMSG("CurrentGearKills", GetACPlayer(player).GearSetKills[set].ToString()), 16, "1", "1", "0.1 0.81", "0.9 0.86");

                            var RequiredKills = GetACPlayer(player).GearSetKills[set];
                            if (GetACPlayer(player).PlayerGearSets[set].Contains(item.shortname))
                            {
                                UI.LoadImage(ref element, GPanel, GetImage(item.shortname, item.skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                UI.CreatePanel(ref element, GPanel, UIColors["green"], $"{altmin.x} {altmin.y + .025f}", $"{altmax.x} {altmax.y - .025f}");
                                info = GetLang("Owned");
                                UI.CreateLabel(ref element, GPanel, UIColors["white"], info, 16, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);
                            }
                            else if (money >= item.price && RequiredKills >= item.killsrequired)
                            {
                                UI.LoadImage(ref element, GPanel, GetImage(item.shortname, item.skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                UI.CreatePanel(ref element, GPanel, UIColors["red"], $"{altmin.x} {altmin.y + .025f}", $"{altmax.x} {altmax.y - .025f}");
                                info = GetMSG("ItemGearCost", item.price.ToString(), item.killsrequired.ToString());
                                UI.CreateTextOutline(ref element, GPanel, UIColors["white"], UIColors["green"], info, 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                UI.CreateButton(ref element, GPanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_PrepPurchase {item.shortname} gear", TextAnchor.MiddleCenter);
                            }
                            else
                            {
                                UI.LoadImage(ref element, GPanel, GetImage(item.shortname, item.skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                UI.CreatePanel(ref element, GPanel, UIColors["grey"], $"{altmin.x} {altmin.y + .025f}", $"{altmax.x} {altmax.y - .025f}");
                                info = GetMSG("ItemGearCost", item.price.ToString(), item.killsrequired.ToString());
                                UI.CreateLabel(ref element, GPanel, UIColors["red"], info, 12, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);
                            }
                        }
                        else
                        {
                            UI.LoadImage(ref element, GPanel, GetImage(item.shortname, item.skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                            UI.CreatePanel(ref element, GPanel, UIColors["grey"], $"{altmin.x} {altmin.y + .025f}", $"{altmax.x} {altmax.y - .025f}");
                            info = GetMSG("ItemGearCost", item.price.ToString(), item.killsrequired.ToString());
                            UI.CreateLabel(ref element, GPanel, UIColors["red"], info, 12, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);

                            if (money >= gwData.GearSets[set].cost && GetACPlayer(player).kills >= gwData.GearSets[set].killsrequired)
                            {
                                UI.CreateButton(ref element, GPanel, UIColors["blue"], GetMSG("UnlockCollection", gwData.GearSets[set].cost.ToString()), 16, "0.1 0.86", "0.9 0.91", $"UI_PurchasingPanel gear {set}", TextAnchor.MiddleCenter);
                            }
                            else
                            {
                                if (GetACPlayer(player).kills != 0)
                                {
                                    var percent = System.Convert.ToDouble(gwData.WeaponSets[set].killsrequired / GetACPlayer(player).kills);
                                    if (percent * 100 > 75)
                                        UI.CreateTextOutline(ref element, GPanel, UIColors["white"], UIColors["yellow"], GetMSG("CostOfGC", gwData.GearSets[set].cost.ToString(), gwData.GearSets[set].killsrequired.ToString()), 16, "1", "1", "0.1 0.86", "0.9 0.91");
                                    else if (percent * 100 > 25 && percent * 100 < 76)
                                        UI.CreateTextOutline(ref element, GPanel, UIColors["white"], UIColors["orange"], GetMSG("CostOfGC", gwData.GearSets[set].cost.ToString(), gwData.GearSets[set].killsrequired.ToString()), 16, "1", "1", "0.1 0.86", "0.9 0.91");
                                    else if (percent * 100 > 0 && percent * 100 < 26)
                                        UI.CreateTextOutline(ref element, GPanel, UIColors["white"], UIColors["red"], GetMSG("CostOfGC", gwData.GearSets[set].cost.ToString(), gwData.GearSets[set].killsrequired.ToString()), 16, "1", "1", "0.1 0.86", "0.9 0.91");
                                }
                                else UI.CreateTextOutline(ref element, GPanel, UIColors["white"], UIColors["red"], GetMSG("CostOfGC", gwData.GearSets[set].cost.ToString(), gwData.GearSets[set].killsrequired.ToString()), 16, "1", "1", "0.1 0.86", "0.9 0.91");
                            }
                        }
                    }
                }
                if (ACUIInfo[player.userID].admin)
                    UI.CreateButton(ref element, GPanel, UIColors["red"], GetLang("Delete"), 14, "0.05 0.8", "0.15 0.85", $"UI_DeleteGearSet");
            }
            CuiHelper.AddUi(player, element);
        }


        void WeaponPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, WPanel);
            var element = UI.CreateElementContainer(WPanel, "0 0 0 0", "0.45 0.2", "0.75 0.8", true);
            if (NewWeaponCollection.ContainsKey(player.userID) && ACUIInfo[player.userID].admin)
            {
                Vector2 min = new Vector2(0f, 0f);
                Vector2 dimension = new Vector2(.2f, .15f);
                Vector2 offset2 = new Vector2(0f, .16f);
                Vector2 altmin;
                Vector2 max;
                Vector2 altmax;
                Dictionary<Slot, string> UsedWeaponslots = new Dictionary<Slot, string>();
                List<Slot> UnusedWeaponslots = new List<Slot>();
                foreach (var block in WeaponSlotPos)
                {
                    foreach (var entry in NewWeaponCollection[player.userID].collection.set.Where(kvp => kvp.Value.slot == block.Key))
                        UsedWeaponslots.Add(entry.Value.slot, entry.Value.shortname);
                }
                foreach (var block in WeaponSlotPos)
                    if (!UsedWeaponslots.ContainsKey(block.Key))
                        UnusedWeaponslots.Add(block.Key);
                foreach (var entry in UsedWeaponslots)
                {
                    min = WeaponSlotPos[entry.Key];
                    max = min + dimension;
                    altmin = min + offset2;
                    altmax = altmin + dimension;

                    UI.LoadImage(ref element, WPanel, GetImage(entry.Value, NewWeaponCollection[player.userID].collection.set[entry.Value].skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                    UI.CreateButton(ref element, WPanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry.Key)} weapon", TextAnchor.MiddleCenter);
                    if (NewWeaponCollection[player.userID].collection.set[entry.Value].free)
                    {
                        UI.CreatePanel(ref element, WPanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        UI.CreateTextOutline(ref element, WPanel, UIColors["black"], UIColors["white"], GetMSG("Free"), 16, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                    }
                    else
                    {
                        if (NewWeaponCollection[player.userID].collection.set[entry.Value].price == 0 && NewWeaponCollection[player.userID].collection.set[entry.Value].killsrequired == 0)
                        {
                            UI.CreatePanel(ref element, WPanel, UIColors["red"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                            UI.CreateTextOutline(ref element, WPanel, UIColors["black"], UIColors["white"], GetMSG("ClickToDetail", NewWeaponCollection[player.userID].collection.set[entry.Value].price.ToString(), NewWeaponCollection[player.userID].collection.set[entry.Value].killsrequired.ToString()), 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        }
                        else
                        {
                            UI.CreatePanel(ref element, WPanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                            UI.CreateTextOutline(ref element, WPanel, UIColors["black"], UIColors["white"], GetMSG("ItemWeaponCost", NewWeaponCollection[player.userID].collection.set[entry.Value].price.ToString(), NewWeaponCollection[player.userID].collection.set[entry.Value].killsrequired.ToString()), 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                        }
                    }
                    UI.CreateButton(ref element, WPanel, "0 0 0 0", "", 16, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", $"UI_AddItemAttributes {entry.Value} weapon", TextAnchor.MiddleCenter);
                    UI.CreateButton(ref element, WPanel, UIColors["red"], GetLang("Remove"), 12, $"{altmin.x + .075f} {altmax.y}", $"{altmax.x - .075f} {altmax.y + .05f}", $"UI_RemoveItem {entry.Value} weapon", TextAnchor.MiddleCenter);
                }
                foreach (var entry in UnusedWeaponslots)
                {
                    min = WeaponSlotPos[entry];
                    max = min + dimension;
                    UI.CreatePanel(ref element, WPanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                    UI.CreatePanel(ref element, WPanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                    UI.CreateButton(ref element, WPanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry)} weapon", TextAnchor.MiddleCenter);
                }
                UI.CreateButton(ref element, WPanel, UIColors["green"], GetMSG("SaveCollection"), 18, "0.1 0.86", "0.9 0.91", $"UI_SaveCollect weapon");
            }
            else
            {
                var set = ACUIInfo[player.userID].WeaponSet;
                if (!PendingPurchase.ContainsKey(player.userID))
                    PendingPurchase.Add(player.userID, new PurchaseItem { });
                else
                    PendingPurchase[player.userID].weapon.Clear();
                if (!WeaponSelection.ContainsKey(player.userID))
                    WeaponSelection.Add(player.userID, new Dictionary<string, Dictionary<string, List<string>>>());

                var money = GetACPlayer(player).money;
                if (configData.UseServerRewards)
                {
                    if (CheckPoints(player.userID) is int)
                        money = (int)CheckPoints(player.userID);
                }
                else if (configData.UseEconomics)
                    money = (int)Economics.CallHook("GetPlayerMoney", player.userID); if (set == "") return;
                UI.CreateTextOutline(ref element, WPanel, UIColors["black"], UIColors["white"], GetMSG("BuySubMenu", set.ToUpper()), 20, "1", "1", "0.1 0.94", "0.9 0.99");
                foreach (var block in WeaponSlotPos)
                {
                    var min = block.Value;
                    var max = block.Value + new Vector2(.2f, .15f);
                    UI.CreatePanel(ref element, WPanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                    UI.CreatePanel(ref element, WPanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                }
                foreach (var entry in gwData.WeaponSets.Where(kvp => kvp.Key == set))
                {
                    if (!WeaponSelection[player.userID].ContainsKey(set))
                    {
                        WeaponSelection[player.userID].Clear();
                        WeaponSelection[player.userID].Add(entry.Key, new Dictionary<string, List<string>>());
                    }
                    foreach (var item in entry.Value.set)
                    {
                        string info = "";
                        PendingPurchase[player.userID].weapon.Add(item.shortname, item);
                        Vector2 min = new Vector2(0f, 0f);
                        Vector2 dimension = new Vector2(.2f, .15f);
                        Vector2 offset2 = new Vector2(0f, .15f);

                        if (WeaponSlotPos.ContainsKey(item.slot))
                        {
                            min = WeaponSlotPos[item.slot];
                        }
                        Vector2 max = min + dimension;
                        Vector2 altmin = min + offset2;
                        Vector2 altmax = altmin + dimension;
                        if (GetACPlayer(player).PlayerWeaponSets.ContainsKey(set))
                        {
                            if (GetACPlayer(player).PlayerWeaponSets[set].ContainsKey(item.shortname))
                                if (!WeaponSelection[player.userID][entry.Key].ContainsKey(item.shortname))
                                {
                                    WeaponSelection[player.userID][entry.Key].Add(item.shortname, new List<string>());
                                }

                            if (GetACPlayer(player).currentWeaponSet == set)
                            {
                                UI.CreateButton(ref element, WPanel, UIColors["green"], GetMSG("CurrentlyEquipped"), 18, "0.1 0.86", "0.9 0.91", $"UI_ProcessSelection weapon {set}");
                            }
                            else
                            {
                                UI.CreateButton(ref element, WPanel, UIColors["green"], GetMSG("SelectCollection", set.ToUpper()), 18, "0.1 0.86", "0.9 0.91", $"UI_ProcessSelection weapon {set}");
                            }
                            UI.CreateTextOutline(ref element, WPanel, UIColors["white"], UIColors["green"], GetMSG("CurrentWeaponKills", GetACPlayer(player).WeaponSetKills[set].ToString()), 16, "1", "1", "0.1 0.81", "0.9 0.86");
                            var RequiredKills = GetACPlayer(player).WeaponSetKills[set];
                            if (GetACPlayer(player).PlayerWeaponSets[set].ContainsKey(item.shortname))
                            {
                                UI.LoadImage(ref element, WPanel, GetImage(item.shortname, item.skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                UI.CreatePanel(ref element, WPanel, UIColors["green"], $"{altmin.x} {altmin.y + .025f}", $"{altmax.x} {altmax.y - .025f}");
                                info = GetLang("Owned");
                                UI.CreateLabel(ref element, WPanel, UIColors["white"], info, 16, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);
                            }
                            else if (money >= item.price && RequiredKills >= item.killsrequired)
                            {
                                UI.LoadImage(ref element, WPanel, GetImage(item.shortname, item.skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                UI.CreatePanel(ref element, WPanel, UIColors["red"], $"{altmin.x} {altmin.y + .025f}", $"{altmax.x} {altmax.y - .025f}");
                                info = GetMSG("ItemWeaponCost", item.price.ToString(), item.killsrequired.ToString());
                                UI.CreateTextOutline(ref element, WPanel, UIColors["white"], UIColors["green"], info, 16, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                UI.CreateButton(ref element, WPanel, "0 0 0 0", "", 12, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_PrepPurchase {item.shortname} weapon", TextAnchor.MiddleCenter);
                            }
                            else
                            {
                                UI.LoadImage(ref element, WPanel, GetImage(item.shortname, item.skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                UI.CreatePanel(ref element, WPanel, UIColors["grey"], $"{altmin.x} {altmin.y + .025f}", $"{altmax.x} {altmax.y - .025f}");
                                info = GetMSG("ItemWeaponCost", item.price.ToString(), item.killsrequired.ToString());
                                UI.CreateLabel(ref element, WPanel, UIColors["red"], info, 12, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);
                            }
                        }
                        else
                        {
                            UI.LoadImage(ref element, WPanel, GetImage(item.shortname, item.skin), $"{min.x} {min.y}", $"{max.x} {max.y}");
                            UI.CreatePanel(ref element, WPanel, UIColors["grey"], $"{altmin.x} {altmin.y + .025f}", $"{altmax.x} {altmax.y - .025f}");
                            info = GetMSG("ItemWeaponCost", item.price.ToString(), item.killsrequired.ToString());
                            UI.CreateLabel(ref element, WPanel, UIColors["red"], info, 12, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);

                            if (money >= gwData.WeaponSets[set].cost && GetACPlayer(player).kills >= gwData.WeaponSets[set].killsrequired)
                            {
                                UI.CreateButton(ref element, WPanel, UIColors["blue"], GetMSG("UnlockCollection", gwData.WeaponSets[set].cost.ToString()), 16, "0.1 0.86", "0.9 0.91", $"UI_PurchasingPanel weapon {set}", TextAnchor.MiddleCenter);

                            }
                            else
                            {
                                if (GetACPlayer(player).kills != 0)
                                {
                                    var percent = System.Convert.ToDouble(gwData.WeaponSets[set].killsrequired / GetACPlayer(player).kills);
                                    if (percent * 100 > 75)
                                        UI.CreateTextOutline(ref element, WPanel, UIColors["white"], UIColors["yellow"], GetMSG("CostOfWC", gwData.WeaponSets[set].cost.ToString(), gwData.WeaponSets[set].killsrequired.ToString()), 16, "1", "1", "0.1 0.86", "0.9 0.91");
                                    else if (percent * 100 > 25 && percent * 100 < 76)
                                        UI.CreateTextOutline(ref element, WPanel, UIColors["white"], UIColors["orange"], GetMSG("CostOfWC", gwData.WeaponSets[set].cost.ToString(), gwData.WeaponSets[set].killsrequired.ToString()), 16, "1", "1", "0.1 0.86", "0.9 0.91");
                                    else if (percent * 100 > 0 && percent * 100 < 26)
                                        UI.CreateTextOutline(ref element, WPanel, UIColors["white"], UIColors["red"], GetMSG("CostOfWC", gwData.WeaponSets[set].cost.ToString(), gwData.WeaponSets[set].killsrequired.ToString()), 16, "1", "1", "0.1 0.86", "0.9 0.91");
                                }
                                else UI.CreateTextOutline(ref element, WPanel, UIColors["white"], UIColors["red"], GetMSG("CostOfWC", gwData.WeaponSets[set].cost.ToString(), gwData.WeaponSets[set].killsrequired.ToString()), 16, "1", "1", "0.1 0.86", "0.9 0.91");
                            }

                        }
                    }
                }
            }
            CuiHelper.AddUi(player, element);
            AttachmentPanel(player);
        }

        private void AttachmentPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, APanel);
            var element = UI.CreateElementContainer(APanel, "0 0 0 0", "0.45 0.2", "0.75 0.45", true);
            if (NewWeaponCollection.ContainsKey(player.userID) && ACUIInfo[player.userID].admin)
            {
                Vector2 min = new Vector2(0f, 0f);
                Vector2 dimension = new Vector2(.125f, .2f);
                Vector2 offset2 = new Vector2(0.175f, 0f);
                Vector2 altmin;
                Vector2 max;
                Vector2 altmax;
                Dictionary<Slot, string> UsedAttachmentslots = new Dictionary<Slot, string>();
                List<Slot> UnusedAttachmentslots = new List<Slot>();
                Dictionary<Slot, string> UsedWeaponSlots = new Dictionary<Slot, string>();
                foreach (var block in WeaponSlotPos)
                {
                    foreach (var entry in NewWeaponCollection[player.userID].collection.set.Where(kvp => kvp.Value.slot == block.Key))
                        UsedWeaponSlots.Add(entry.Value.slot, entry.Value.shortname);
                }

                if (UsedWeaponSlots.ContainsKey(Slot.main))
                {
                    var item = ItemManager.Create(ItemManager.FindItemDefinition(UsedWeaponSlots[Slot.main]), 1, 0);
                    var held = item.GetHeldEntity() as BaseProjectile;
                    if (held != null /*item.contents.capacity != 0*/)
                    {
                        foreach (var block in MainAttachmentSlotsPos)
                        {
                            foreach (var entry in NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].attachments.Where(kvp => kvp.Value.slot == block.Key))
                                UsedAttachmentslots.Add(entry.Value.slot, entry.Value.shortname);
                        }
                        foreach (var block in MainAttachmentSlotsPos)
                            if (!UsedAttachmentslots.ContainsKey(block.Key))
                                UnusedAttachmentslots.Add(block.Key);
                        foreach (var entry in UsedAttachmentslots)
                        {
                            min = MainAttachmentSlotsPos[entry.Key];
                            max = min + dimension;
                            altmin = min - offset2;
                            altmax = altmin + dimension;

                            UI.LoadImage(ref element, APanel, GetImage(entry.Value, 0), $"{min.x} {min.y}", $"{max.x} {max.y}");
                            UI.CreateButton(ref element, APanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry.Key)} attachment {UsedWeaponSlots[Slot.main]}", TextAnchor.MiddleCenter);
                            if (NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].attachments[entry.Value].free)
                            {
                                UI.CreatePanel(ref element, APanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                UI.CreateTextOutline(ref element, APanel, UIColors["black"], UIColors["white"], GetMSG("Free"), 16, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                            }
                            else
                            {
                                if (NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].attachments[entry.Value].cost == 0 && NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].attachments[entry.Value].killsrequired == 0)
                                {
                                    UI.CreatePanel(ref element, APanel, UIColors["red"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                    UI.CreateTextOutline(ref element, APanel, UIColors["black"], UIColors["white"], GetMSG("ClickToDetail", NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].attachments[entry.Value].cost.ToString(), NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].attachments[entry.Value].killsrequired.ToString()), 10, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                }
                                else
                                {
                                    UI.CreatePanel(ref element, APanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                    UI.CreateTextOutline(ref element, APanel, UIColors["black"], UIColors["white"], GetMSG("ItemWeaponCost", NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].attachments[entry.Value].cost.ToString(), NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].attachments[entry.Value].killsrequired.ToString()), 10, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                }
                            }
                            UI.CreateButton(ref element, APanel, "0 0 0 0", "", 16, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", $"UI_AddItemAttributes {entry.Value} attachment {UsedWeaponSlots[Slot.main]}", TextAnchor.MiddleCenter);
                            UI.CreateButton(ref element, APanel, UIColors["red"], GetLang("Remove"), 8, $"{altmin.x - .05f} {altmin.y + .05f}", $"{altmin.x} {altmax.y - .05f}", $"UI_RemoveItem {entry.Value} attachment {UsedWeaponSlots[Slot.main]}", TextAnchor.MiddleCenter);
                        }
                        foreach (var entry in UnusedAttachmentslots)
                        {
                            min = MainAttachmentSlotsPos[entry];
                            max = min + dimension;
                            UI.CreatePanel(ref element, APanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                            UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                            UI.CreateButton(ref element, APanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry)} attachment {UsedWeaponSlots[Slot.main]}", TextAnchor.MiddleCenter);
                        }
                    }
                }
                UsedAttachmentslots.Clear();
                UnusedAttachmentslots.Clear();
                if (UsedWeaponSlots.ContainsKey(Slot.secondary))
                {
                    var item = ItemManager.Create(ItemManager.FindItemDefinition(UsedWeaponSlots[Slot.secondary]), 1, 0);
                    var held = item.GetHeldEntity() as BaseProjectile;
                    if (held != null /*&& item.contents.capacity != 0*/)
                    {
                        foreach (var block in SecondaryAttachmentSlotsPos)
                        {
                            foreach (var entry in NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].attachments.Where(kvp => kvp.Value.slot == block.Key))
                                UsedAttachmentslots.Add(entry.Value.slot, entry.Value.shortname);
                        }
                        foreach (var block in SecondaryAttachmentSlotsPos)
                            if (!UsedAttachmentslots.ContainsKey(block.Key))
                                UnusedAttachmentslots.Add(block.Key);
                        foreach (var entry in UsedAttachmentslots)
                        {
                            min = SecondaryAttachmentSlotsPos[entry.Key];
                            max = min + dimension;
                            altmin = min + offset2;
                            altmax = altmin + dimension;

                            UI.LoadImage(ref element, APanel, GetImage(entry.Value, 0), $"{min.x} {min.y}", $"{max.x} {max.y}");
                            UI.CreateButton(ref element, APanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry.Key)} attachment {UsedWeaponSlots[Slot.secondary]}", TextAnchor.MiddleCenter);
                            if (NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].attachments[entry.Value].free)
                            {
                                UI.CreatePanel(ref element, APanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                UI.CreateTextOutline(ref element, APanel, UIColors["black"], UIColors["white"], GetMSG("Free"), 16, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                            }
                            else
                            {
                                if (NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].attachments[entry.Value].cost == 0 && NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].attachments[entry.Value].killsrequired == 0)
                                {
                                    UI.CreatePanel(ref element, APanel, UIColors["red"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                    UI.CreateTextOutline(ref element, APanel, UIColors["black"], UIColors["white"], GetMSG("ClickToDetail", NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].attachments[entry.Value].cost.ToString(), NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].attachments[entry.Value].killsrequired.ToString()), 10, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                }
                                else
                                {
                                    UI.CreatePanel(ref element, APanel, UIColors["green"], $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                    UI.CreateTextOutline(ref element, APanel, UIColors["black"], UIColors["white"], GetMSG("ItemWeaponCost", NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].attachments[entry.Value].cost.ToString(), NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].attachments[entry.Value].killsrequired.ToString()), 10, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                }
                            }
                            UI.CreateButton(ref element, APanel, "0 0 0 0", "", 16, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", $"UI_AddItemAttributes {entry.Value} attachment {UsedWeaponSlots[Slot.secondary]}", TextAnchor.MiddleCenter);
                            UI.CreateButton(ref element, APanel, UIColors["red"], GetLang("Remove"), 8, $"{altmin.x + .125f} {altmin.y + .05f}", $"{altmin.x + .175f} {altmax.y - .05f}", $"UI_RemoveItem {entry.Value} attachment {UsedWeaponSlots[Slot.secondary]}", TextAnchor.MiddleCenter);
                        }
                        foreach (var entry in UnusedAttachmentslots)
                        {
                            min = SecondaryAttachmentSlotsPos[entry];
                            max = min + dimension;
                            UI.CreatePanel(ref element, APanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                            UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                            UI.CreateButton(ref element, APanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), entry)} attachment {UsedWeaponSlots[Slot.secondary]}", TextAnchor.MiddleCenter);
                        }
                    }
                }
                /////////////////////////////////////////
                Dictionary<Slot, string> UsedAmmunitionSlots = new Dictionary<Slot, string>();
                List<Slot> UnusedAmmunitionSlots = new List<Slot>();
                dimension = new Vector2(.125f, .175f);
                if (UsedWeaponSlots.ContainsKey(Slot.main))
                {
                    var held = ItemManager.Create(ItemManager.FindItemDefinition(UsedWeaponSlots[Slot.main]), 1, 0).GetHeldEntity() as BaseProjectile;
                    if (held != null)
                    {
                            min = AmmunitionSlotsPos[Slot.ammunitionMain];
                            max = min + dimension;
                        UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                        if (NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].ammoType != null)
                        {
                            UI.LoadImage(ref element, APanel, GetImage(NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.main]].ammoType, 0), $"{min.x} {min.y}", $"{max.x} {max.y}");
                        }
                            UI.CreateButton(ref element, APanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), Slot.ammunitionMain)} ammo {UsedWeaponSlots[Slot.main]}", TextAnchor.MiddleCenter);
                    }
                }
                UsedAmmunitionSlots.Clear();
                UnusedAmmunitionSlots.Clear();
                if (UsedWeaponSlots.ContainsKey(Slot.secondary))
                {
                    var held = ItemManager.Create(ItemManager.FindItemDefinition(UsedWeaponSlots[Slot.secondary]), 1, 0).GetHeldEntity() as BaseProjectile;
                    if (held != null)
                    {
                        min = AmmunitionSlotsPos[Slot.ammunitionSecondary];
                        max = min + dimension;
                        altmin = min - offset2;
                        altmax = altmin - dimension;
                        UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                        if (NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].ammoType != null)
                        {
                            UI.LoadImage(ref element, APanel, GetImage(NewWeaponCollection[player.userID].collection.set[UsedWeaponSlots[Slot.secondary]].ammoType, 0), $"{min.x} {min.y}", $"{max.x} {max.y}");
                        }
                        UI.CreateButton(ref element, APanel, "0 0 0 0", "", 16, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), Slot.ammunitionMain)} ammo {UsedWeaponSlots[Slot.secondary]}", TextAnchor.MiddleCenter);
                    }
                }
                UI.CreateButton(ref element, APanel, UIColors["red"], GetLang("CancelCollection"), 14, "0.3 -.05", "0.6 0.05", $"UI_CancelWeaponSet");
            }
            else
            {
                var set = ACUIInfo[player.userID].WeaponSet;
                if (!PendingPurchase.ContainsKey(player.userID))
                    PendingPurchase.Add(player.userID, new PurchaseItem { });
                else
                    PendingPurchase[player.userID].attachment.Clear();
                if (set == "") return;
                var money = GetACPlayer(player).money;
                if (configData.UseServerRewards)
                {
                    if (CheckPoints(player.userID) is int)
                        money = (int)CheckPoints(player.userID);
                }
                else if (configData.UseEconomics)
                    money = (int)Economics.CallHook("GetPlayerMoney", player.userID); foreach (var entry in gwData.WeaponSets.Where(kvp => kvp.Key == set))
                {
                    foreach (var item in entry.Value.set)
                    {
                        string info = "";
                        if (item.slot == Slot.main)
                            if (!string.IsNullOrEmpty(item.ammoType))
                            {
                                Vector2 dimension = new Vector2(.125f, .175f);
                                Vector2 offset = new Vector2(.002f, .003f);
                                Vector2 pos = AmmunitionSlotsPos[Slot.ammunitionMain];
                                UI.CreatePanel(ref element, APanel, UIColors["black"], $"{pos.x} {pos.y}", $"{pos.x + dimension.x} {pos.y + dimension.y}");
                                UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{pos.x + offset.x} {pos.y + offset.y}", $"{pos.x + dimension.x - offset.x} {pos.y + dimension.y - offset.y}");
                                UI.LoadImage(ref element, APanel, GetImage(item.ammoType), $"{pos.x} {pos.y}", $"{pos.x + dimension.x} {pos.y + dimension.y}");
                            }

                        if (item.slot == Slot.secondary)
                            if (!string.IsNullOrEmpty(item.ammoType))
                            {
                                Vector2 dimension = new Vector2(.125f, .175f);
                                Vector2 offset = new Vector2(.002f, .003f);
                                Vector2 pos = AmmunitionSlotsPos[Slot.ammunitionSecondary];
                                UI.CreatePanel(ref element, APanel, UIColors["black"], $"{pos.x} {pos.y}", $"{pos.x + dimension.x} {pos.y + dimension.y}");
                                UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{pos.x + offset.x} {pos.y + offset.y}", $"{pos.x + dimension.x - offset.x} {pos.y + dimension.y - offset.y}");
                                UI.LoadImage(ref element, APanel, GetImage(item.ammoType), $"{pos.x} {pos.y}", $"{pos.x + dimension.x} {pos.y + dimension.y}");
                            }

                        if (item.attachments.Count() > 0)
                        {
                            if (item.slot == Slot.main)
                            {
                                foreach (var block in MainAttachmentSlotsPos)
                                {
                                    Vector2 min = block.Value;
                                    Vector2 max = block.Value + new Vector2(.125f, .2f);
                                    UI.CreatePanel(ref element, APanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                                    UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                                }

                            }
                            if (item.slot == Slot.secondary)
                            {
                                foreach (var block in SecondaryAttachmentSlotsPos)
                                {
                                    Vector2 min = block.Value;
                                    Vector2 max = block.Value + new Vector2(.125f, .2f);
                                    UI.CreatePanel(ref element, APanel, UIColors["black"], $"{min.x} {min.y}", $"{max.x} {max.y}");
                                    UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{min.x + 0.002f} {min.y + 0.003f}", $"{max.x - 0.002f} {max.y - 0.003f}");
                                }
                            }
                            foreach (var attachment in item.attachments)
                            {
                                if (!PendingPurchase[player.userID].attachment.ContainsKey(item.slot))
                                    PendingPurchase[player.userID].attachment.Add(item.slot, new Dictionary<string, Attachment>());
                                PendingPurchase[player.userID].attachment[item.slot].Add(attachment.Key, attachment.Value);
                                Vector2 offset2 = new Vector2(0.175f, 0f);
                                Vector2 min = new Vector2(0f, 0f);
                                Vector2 max;
                                Vector2 altmin = new Vector2(0f, 0f);
                                Vector2 altmax;
                                if (item.slot == Slot.main)
                                {
                                    min = MainAttachmentSlotsPos[attachment.Value.slot];
                                    altmin = min - offset2;
                                }
                                else if (item.slot == Slot.secondary)
                                {
                                    min = SecondaryAttachmentSlotsPos[attachment.Value.slot];
                                    altmin = min + offset2;
                                }
                                Vector2 dimension = new Vector2(.125f, .2f);
                                Vector2 dimension1 = new Vector2(.15f, .3f);
                                max = min + dimension;
                                altmax = altmin + dimension1;
                                if (GetACPlayer(player).PlayerWeaponSets.ContainsKey(set))
                                {
                                    var weapon = ItemManager.Create(ItemManager.FindItemDefinition(item.shortname), 1, 0);
                                    if (GetACPlayer(player).PlayerWeaponSets[set].ContainsKey(item.shortname))
                                    {
                                        if (GetACPlayer(player).PlayerWeaponSets[set][item.shortname].Contains(attachment.Value.shortname))
                                        {
                                            if (!WeaponSelection[player.userID][entry.Key][item.shortname].Contains(attachment.Value.shortname))
                                            {
                                                if (WeaponSelection[player.userID][entry.Key][item.shortname].Count < weapon.contents.capacity)
                                                {
                                                    if (WeaponSelection[player.userID][entry.Key][item.shortname].Count == 0)
                                                    {
                                                        UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                                        info = GetLang("Unequipped");
                                                        UI.CreatePanel(ref element, APanel, UIColors["white"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                                        UI.CreateTextOutline(ref element, APanel, UIColors["red"], UIColors["black"], info, 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                                        UI.CreateButton(ref element, APanel, "0 0 0 0", "", 14, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_ProcessAttachment add {item.shortname} {attachment.Value.shortname} {set}", TextAnchor.MiddleCenter);
                                                    }
                                                    else
                                                        foreach (var a in WeaponSelection[player.userID][entry.Key][item.shortname])
                                                        {
                                                            if (DefaultAttachments[a].location != DefaultAttachments[attachment.Value.shortname].location)
                                                            {
                                                                UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                                                info = GetLang("Unequipped");
                                                                UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                                                UI.CreateTextOutline(ref element, APanel, UIColors["red"], UIColors["black"], info, 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                                                UI.CreateButton(ref element, APanel, "0 0 0 0", "", 14, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_ProcessAttachment add {item.shortname} {attachment.Value.shortname} {set}", TextAnchor.MiddleCenter);
                                                            }
                                                            else if (DefaultAttachments[a].location == DefaultAttachments[attachment.Value.shortname].location)
                                                            {
                                                                UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                                                info = GetLang("PositionFull");
                                                                UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                                                UI.CreateTextOutline(ref element, APanel, UIColors["black"], UIColors["red"], info, 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                                            }
                                                        }
                                                }
                                                else
                                                {
                                                    UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                                    info = GetLang("GunFull");
                                                    UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                                    UI.CreateTextOutline(ref element, APanel, UIColors["white"], UIColors["red"], info, 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                                }
                                            }
                                            else
                                            {
                                                UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                                info = GetLang("Equipped");
                                                UI.CreatePanel(ref element, APanel, UIColors["green"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                                UI.CreateTextOutline(ref element, APanel, UIColors["green"], UIColors["black"], info, 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                                UI.CreateButton(ref element, APanel, "0 0 0 0", "", 14, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_ProcessAttachment remove {item.shortname} {attachment.Value.shortname} {set}", TextAnchor.MiddleCenter);
                                            }
                                        }
                                        else if (money >= attachment.Value.cost && GetACPlayer(player).WeaponSetKills[set] >= attachment.Value.killsrequired)
                                        {
                                            UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                            UI.CreatePanel(ref element, APanel, UIColors["red"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                            info = GetMSG("ItemWeaponCost", attachment.Value.cost.ToString(), attachment.Value.killsrequired.ToString());
                                            UI.CreateTextOutline(ref element, APanel, UIColors["black"], UIColors["white"], info, 12, "1", "1", $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}");
                                            UI.CreateButton(ref element, APanel, "0 0 0 0", "", 10, $"{min.x} {min.y}", $"{max.x} {max.y}", $"UI_PrepPurchase {item.shortname} {attachment.Value.shortname}", TextAnchor.MiddleCenter);
                                        }
                                        else
                                        {
                                            UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                            UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                            info = GetMSG("ItemWeaponCost", attachment.Value.cost.ToString(), attachment.Value.killsrequired.ToString());
                                            UI.CreateLabel(ref element, APanel, UIColors["red"], info, 10, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);
                                        }
                                    }
                                    else
                                    {
                                        UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                        UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                        info = GetMSG("ItemWeaponCost", attachment.Value.cost.ToString(), attachment.Value.killsrequired.ToString());
                                        UI.CreateLabel(ref element, APanel, UIColors["red"], info, 10, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);
                                    }
                                }
                                else
                                {
                                    UI.LoadImage(ref element, APanel, GetImage(attachment.Value.shortname), $"{min.x} {min.y}", $"{max.x} {max.y}");
                                    UI.CreatePanel(ref element, APanel, UIColors["grey"], $"{altmin.x} {altmin.y }", $"{altmax.x} {altmax.y - .03f}");
                                    info = GetMSG("ItemWeaponCost", attachment.Value.cost.ToString(), attachment.Value.killsrequired.ToString());
                                    UI.CreateLabel(ref element, APanel, UIColors["red"], info, 10, $"{altmin.x} {altmin.y}", $"{altmax.x} {altmax.y}", TextAnchor.MiddleCenter);
                                }
                            }
                        }
                    }
                }
                if (ACUIInfo[player.userID].admin)
                    UI.CreateButton(ref element, APanel, UIColors["red"], GetLang("Delete"), 14, "0.8 1.9", "0.92 2.03", $"UI_DeleteWeaponSet");
            }
            CuiHelper.AddUi(player, element);
        }

        private void PurchaseConfirmation(BasePlayer player, string item)
        {
            var pending = PendingPurchase[player.userID];
            var itemname = item;
            var itemshortname = item;
            var currentGearSet = item;
            var itemprice = pending.setprice.ToString();
            if (pending.gearpurchase == true)
            {
                if (pending.set == false)
                {
                    itemname = pending.gear[item].shortname;
                    itemshortname = pending.gear[item].shortname;
                    itemprice = pending.gear[item].price.ToString();
                    currentGearSet = pending.setname;
                }
            }
            else if (pending.weaponpurchase == true)
            {
                if (pending.set == false)
                {
                    if (pending.attachmentpurchase == true)
                    {
                        itemname = pending.attachment[pending.weapon[item].slot][pending.attachmentName].shortname;
                        itemshortname = pending.attachment[pending.weapon[item].slot][pending.attachmentName].shortname;
                        itemprice = pending.attachment[pending.weapon[item].slot][pending.attachmentName].cost.ToString();
                        currentGearSet = pending.setname;
                    }
                    else
                    {
                        itemname = pending.weapon[item].shortname;
                        itemshortname = pending.weapon[item].shortname;
                        itemprice = pending.weapon[item].price.ToString();
                        currentGearSet = pending.setname;
                    }
                }
            }
            CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
            var element = UI.CreateElementContainer(PanelPurchaseConfirmation,"0 0 0 1", "0.4 0.3", "0.6 0.6", true);
            UI.CreatePanel(ref element, PanelPurchaseConfirmation, UIColors["header"], "0.03 0.02", "0.97 0.98");
            if (pending.set == false)
            {
                UI.CreateTextOutline(ref element, PanelPurchaseConfirmation, UIColors["white"], UIColors["black"], GetMSG("PurchaseInfo", itemname, itemprice), 18, "1", "1", "0.1 0.6", "0.9 0.95");
                UI.LoadImage(ref element, PanelPurchaseConfirmation, GetImage(itemshortname), "0.35 0.275", "0.65 0.575");
            }
            else UI.CreateTextOutline(ref element, PanelPurchaseConfirmation, UIColors["white"], UIColors["black"], GetMSG("PurchaseSetInfo", itemname, itemprice), 18, "1", "1", "0.1 0.3", "0.9 0.89"); 
            UI.CreateButton(ref element, PanelPurchaseConfirmation, UIColors["buttongreen"], "Yes", 18, "0.2 0.05", "0.475 0.25", $"UI_Purchase {item}");
            UI.CreateButton(ref element, PanelPurchaseConfirmation, UIColors["buttonred"], "No", 18, "0.525 0.05", "0.8 0.25", $"UI_DestroyPurchaseConfirmation");
            CuiHelper.AddUi(player, element);
        }

        void OnScreen(BasePlayer player, string msg)
        {
            CuiHelper.DestroyUi(player, PanelOnScreen);
            var element = UI.CreateElementContainer(PanelOnScreen, "0.0 0.0 0.0 0.0", "0.3 0.35", "0.7 0.65", false);
            UI.CreateTextOutline(ref element, PanelOnScreen, UIColors["white"], UIColors["green"], msg, 32, "1", "1", "0.0 0.0", "1.0 1.0");
            CuiHelper.AddUi(player, element);
            timer.Once(3, () => CuiHelper.DestroyUi(player, PanelOnScreen));
        }

        void PlayerHUD(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelStats);
            string money = GetACPlayer(player).money.ToString();
            var element = UI.CreateElementContainer(PanelStats, "0 0 0 0", "0.35 0.93", "0.65 1.0", false);
            if (GetACPlayer(player).currentWeaponSet != null)
            {
                UI.CreateTextOutline(ref element, PanelStats, UIColors["black"], UIColors["white"], GetMSG("Hud1", GetACPlayer(player).WeaponSetKills[GetACPlayer(player).currentWeaponSet].ToString()), 12, "1", "1", "0.05 0.66", "0.35 0.99", TextAnchor.MiddleLeft);
                UI.CreateTextOutline(ref element, PanelStats, UIColors["black"], UIColors["white"], GetMSG("Hud4", GetACPlayer(player).currentWeaponSet.ToUpper()), 12, "1", "1", "0.36 0.66", "0.95 0.99", TextAnchor.MiddleLeft);
            }
            if (GetACPlayer(player).currentGearSet != null)
            {
                UI.CreateTextOutline(ref element, PanelStats, UIColors["black"], UIColors["white"], GetMSG("Hud2", GetACPlayer(player).GearSetKills[GetACPlayer(player).currentGearSet].ToString()), 12, "1", "1", "0.05 0.33", "0.35 0.66", TextAnchor.MiddleLeft);
                UI.CreateTextOutline(ref element, PanelStats, UIColors["black"], UIColors["white"], GetMSG("Hud5", GetACPlayer(player).currentGearSet.ToUpper()), 12, "1", "1", "0.36 0.33", "0.95 0.66", TextAnchor.MiddleLeft);
            }
            if (configData.UseServerRewards)
            {
                if (CheckPoints(player.userID) is int)
                {
                    money = CheckPoints(player.userID).ToString();
                }
                else money = "0";
                UI.CreateTextOutline(ref element, PanelStats, UIColors["black"], UIColors["white"], GetMSG("Hud3a", money), 12, "1", "1", "0.05 0.0", "0.35 0.33", TextAnchor.MiddleLeft);
            }
            else if (configData.UseEconomics)
                UI.CreateTextOutline(ref element, PanelStats, UIColors["black"], UIColors["white"], GetMSG("Hud3a", Economics.CallHook("GetPlayerMoney", player.userID).ToString()), 12, "1", "1", "0.05 0.0", "0.35 0.33", TextAnchor.MiddleLeft);
            else
                UI.CreateTextOutline(ref element, PanelStats, UIColors["black"], UIColors["white"], GetMSG("Hud3b", money), 12, "1", "1", "0.05 0.0", "0.35 0.33", TextAnchor.MiddleLeft);
            UI.CreateTextOutline(ref element, PanelStats, UIColors["black"], UIColors["white"], GetMSG("Hud6", GetACPlayer(player).kills.ToString()), 12, "1", "1", "0.36 0.0", "0.95 0.33", TextAnchor.MiddleLeft);
            CuiHelper.AddUi(player, element);
        }

        private void SelectIfFree(BasePlayer player, string item, string type)
        {
            CuiHelper.DestroyUi(player, PanelAC);
            var element = UI.CreateElementContainer(PanelAC, UIColors["dark"], "0.4 0.3", "0.6 0.6", true);
            UI.CreatePanel(ref element, PanelAC, UIColors["light"], "0.03 0.02", "0.97 0.98");
            if (item == "collection")
                UI.CreateLabel(ref element, PanelAC, UIColors["limegreen"], GetMSG("UnlockCollectionFree"), 16, "0.1 0.5", "0.9 .98", TextAnchor.UpperCenter);     
                    else 
            UI.CreateLabel(ref element, PanelAC, UIColors["limegreen"], GetMSG("UnlockFree"), 16, "0.1 0.5", "0.9 .98", TextAnchor.UpperCenter);
            UI.CreateButton(ref element, PanelAC, UIColors["buttongreen"], "Yes", 18, "0.2 0.05", "0.475 0.25", $"UI_Free true {item} {type}");
            UI.CreateButton(ref element, PanelAC, UIColors["buttonred"], "No", 18, "0.525 0.05", "0.8 0.25", $"UI_Free false {item} {type}");
            CuiHelper.AddUi(player, element);
        }

        private void NumberPad(BasePlayer player, string cmd, string title, string item, string type)
        {
            CuiHelper.DestroyUi(player, PanelAC);
            var element = UI.CreateElementContainer(PanelAC, UIColors["dark"], "0.35 0.3", "0.65 0.7", true);
            UI.CreatePanel(ref element, PanelAC, UIColors["light"], "0.01 0.02", "0.99 0.98");
            UI.CreateLabel(ref element, PanelAC, UIColors["limegreen"], GetMSG(title, item), 16, "0.1 0.85", "0.9 .98", TextAnchor.UpperCenter);
            var n = 1;
            var i = 0;
                while (n < 10)
                {
                    CreateNumberPadButton(ref element, PanelAC, i, n, cmd, item, type); i++; n++;
                }
                while (n >= 10 && n < 25)
                {
                    CreateNumberPadButton(ref element, PanelAC, i, n, cmd, item, type); i++; n += 5;
                }
                while (n >= 25 && n < 200)
                {
                    CreateNumberPadButton(ref element, PanelAC, i, n, cmd, item, type); i++; n += 25;
                }
                while (n >= 200 && n <= 950)
                {
                    CreateNumberPadButton(ref element, PanelAC, i, n, cmd, item, type); i++; n += 50;
                }
                while (n >= 1000 && n <= 10000)
                {
                    CreateNumberPadButton(ref element, PanelAC, i, n, cmd, item, type); i++; n += 500;
                }
            //}
            CuiHelper.AddUi(player, element);
        }

        private void CreateNumberPadButton(ref CuiElementContainer container, string panelName, int i, int number, string command, string item, string type)
        {
            var pos = CalcNumButtonPos(i);
            UI.CreateButton(ref container, panelName, UIColors["buttonbg"], number.ToString(), 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"{command} {number} {item} {type}");
        }


        #endregion

        #region UI Calculations

        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.75f);
            Vector2 dimensions = new Vector2(0.15f, 0.15f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 5)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 4 && number < 10)
            {
                offsetX = (0.01f + dimensions.x) * (number - 5);
                offsetY = (-0.025f - dimensions.y) * 1;
            }
            if (number > 9 && number < 15)
            {
                offsetX = (0.01f + dimensions.x) * (number - 10);
                offsetY = (-0.025f - dimensions.y) * 2;
            }
            if (number > 14 && number < 20)
            {
                offsetX = (0.01f + dimensions.x) * (number - 15);
                offsetY = (-0.025f - dimensions.y) * 3;
            }
            if (number > 19 && number < 25)
            {
                offsetX = (0.01f + dimensions.x) * (number - 20);
                offsetY = (-0.025f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcNumButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.75f);
            Vector2 dimensions = new Vector2(0.09f, 0.10f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 9)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 8 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 9);
                offsetY = (-0.02f - dimensions.y) * 1;
            }
            if (number > 17 && number < 27)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.02f - dimensions.y) * 2;
            }
            if (number > 26 && number < 36)
            {
                offsetX = (0.01f + dimensions.x) * (number - 27);
                offsetY = (-0.02f - dimensions.y) * 3;
            }
            if (number > 35 && number < 45)
            {
                offsetX = (0.01f + dimensions.x) * (number - 36);
                offsetY = (-0.02f - dimensions.y) * 4;
            }
            if (number > 44 && number < 54)
            {
                offsetX = (0.01f + dimensions.x) * (number - 45);
                offsetY = (-0.02f - dimensions.y) * 5;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }


        #endregion

        #region UI Commands



        [ConsoleCommand("UI_AddItemAttributes")]
        private void cmdUI_AddGearAttributes(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var item = arg.Args[0];
            var type = arg.Args[1];
            if (type == "attachment")
                NewWeaponCollection[player.userID].collection.currentweapon = arg.Args[2];
            if (DefaultItems[Slot.chest].Contains(item))
            {
                NewGearCollection[player.userID].collection.set[item].free = true;
                DestroyACPanel(player);
                OpenACUI(player);
            }
            else SelectIfFree(player, item, type);
        }

        [ConsoleCommand("UI_RemoveItem")]
        private void cmdUI_RemoveItem(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var item = arg.Args[0];
            var type = arg.Args[1];
            if (type == "attachment")
                NewWeaponCollection[player.userID].collection.set[arg.Args[2]].attachments.Remove(item);
            else if (type == "gear")
                NewGearCollection[player.userID].collection.set.Remove(item);
            else if (type == "weapon")
                NewWeaponCollection[player.userID].collection.set.Remove(item);
            DestroyACPanel(player);
            OpenACUI(player);
        }
        [ConsoleCommand("UI_SelectCollectionItem")]
        private void cmdUI_SelectGear(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            Slot slot = (Slot)Enum.Parse(typeof(Slot), arg.Args[0]);
            string type = arg.Args[1];
            var page = 0;
            if (type == "attachment" || type == "ammo")
                NewWeaponCollection[player.userID].collection.currentweapon = arg.Args[2];
            else if (arg.Args.Length > 2)
            {
                page = Convert.ToInt32(arg.Args[2]);
            }
            DestroyACPanel(player);
            SelectGearSlotItem(player, slot,type, page);
        }

        private void SelectGearSlotItem(BasePlayer player, Slot slot, string type, int page = 0)
        {
            var element = UI.CreateElementContainer(PanelAC, "0 0 0 0", "0.275 0.25", "0.725 0.75", true);
            UI.CreateLabel(ref element, PanelAC, UIColors["black"], $"{TextColors["limegreen"]} {GetLang("SelectCollectionItem")}", 20, "0.05 .9", "1 1", TextAnchor.MiddleCenter);
            int entriesallowed = 25;
            int remainingentries = DefaultItems[slot].Count() - (page * entriesallowed);
            {
                if (remainingentries > entriesallowed)
                {
                    UI.CreateButton(ref element, PanelAC, UIColors["blue"], GetLang("Next"), 18, "0.87 0.03", "0.97 0.085", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), slot)} {type} { page + 1}");
                }
                if (page > 0)
                {
                    UI.CreateButton(ref element, PanelAC, UIColors["buttonred"], GetLang("Back"), 18, "0.73 0.03", "0.83 0.085", $"UI_SelectCollectionItem {Enum.GetName(typeof(Slot), slot)} {type} { page - 1}");
                }
            }
            int shownentries = page * entriesallowed;
            int i = 0;
            int n = 0;
            foreach (var entry in DefaultItems[slot])
            {
                if (type == "attachment")
                    if (NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].attachments.ContainsKey(entry)) continue;
                else if (type == "weapon")
                    if (NewWeaponCollection[player.userID].collection.set.ContainsKey(entry)) continue;
                i++;
                if (i < shownentries + 1) continue;
                else if (i <= shownentries + entriesallowed)
                {
                    var pos = CalcButtonPos(n);
                    UI.LoadImage(ref element, PanelAC, GetImage(entry), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                    UI.CreateButton(ref element, PanelAC, "0 0 0 0", "", 14, $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}", $"UI_AddItem {entry} {Enum.GetName(typeof(Slot), slot)} {type}", TextAnchor.MiddleCenter);
                    n++;
                }
            }
            CuiHelper.AddUi(player, element);
        }

        [ConsoleCommand("UI_AddItem")]
        private void cmdUI_AddItem(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var item = arg.Args[0];
            Slot slot = (Slot)Enum.Parse(typeof(Slot), arg.Args[1]);
            var type = arg.Args[2];
            DestroyACPanel(player);
            var existingitem = "";
            if (type == "gear")
            {
                foreach (var entry in NewGearCollection[player.userID].collection.set.Where(kvp => kvp.Value.slot == slot))
                    existingitem = entry.Key;
                if (existingitem != "")
                    NewGearCollection[player.userID].collection.set.Remove(existingitem);
                if (slot == Slot.chest)
                    NewGearCollection[player.userID].collection.set.Add(item, new Gear { shortname = item, slot = slot, container = "wear", amount = 1, free = true , skin = 0});
                else
                    NewGearCollection[player.userID].collection.set.Add(item, new Gear { shortname = item, slot = slot, container = "wear", amount = 1 , skin = 0});
            }
            else if (type == "weapon")
            {
                string ammo = null;
                foreach (var entry in NewWeaponCollection[player.userID].collection.set.Where(kvp => kvp.Value.slot == slot))
                    existingitem = entry.Key;
                if (existingitem != "")
                    NewWeaponCollection[player.userID].collection.set.Remove(existingitem);
                var gun = BuildItem(item, 1).GetHeldEntity() as BaseProjectile;
                if (gun != null)
                {
                    ammo = gun.primaryMagazine.ammoType.shortname;
                }
                    if (slot == Slot.main)
                    NewWeaponCollection[player.userID].collection.set.Add(item, new Weapon { shortname = item, slot = slot, container = "belt", amount = 1, free = true, ammoType = ammo ,skin = 0});
                else
                    NewWeaponCollection[player.userID].collection.set.Add(item, new Weapon { shortname = item, slot = slot, container = "belt", amount = 1 , ammoType = ammo, skin = 0});
            }
            else if (type == "attachment")
            {
                foreach (var entry in NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].attachments.Where(kvp => kvp.Value.slot == slot))
                    existingitem = entry.Key;
                if (existingitem != "")
                    NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].attachments.Remove(existingitem);
                NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].attachments.Add(item, new Attachment { shortname = item, slot = slot, location = DefaultAttachments[item].location });
            }
            else if (type == "ammo")
                NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].ammoType = item;
            //DestroyACPanel(player);
            //OpenACUI(player);
            SelectSkin(player, item, type);
        }

        private void SelectSkin(BasePlayer player, string item, string type)
        {
            if (gwData.Images.ContainsKey(item) && gwData.Images[item].Count() > 1)
            {
                var i = 0;
                var element = UI.CreateElementContainer(PanelAC, UIColors["dark"], "0.3 0.3", "0.7 0.9");
                UI.CreatePanel(ref element, PanelAC, UIColors["light"], "0.01 0.02", "0.99 0.98");
                UI.CreatePanel(ref element, PanelAC, "0 0 0 0", $".0001 0.0001", $"0.0002 0.0002", true);
                UI.CreateLabel(ref element, PanelAC, UIColors["black"], $"{TextColors["limegreen"]} {GetMSG("GearSkin", item)}", 20, "0.05 .9", "1 1", TextAnchor.MiddleCenter);
                foreach (var entry in gwData.Images[item])
                {
                    var pos = CalcButtonPos(i);
                    UI.LoadImage(ref element, PanelAC, entry.Value.ToString(), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                    UI.CreateButton(ref element, PanelAC, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectSkin {item} {entry.Key} {type}");
                    i++;
                }
                CuiHelper.AddUi(player, element);
            }
            else
            {
                if (type == "gear")
                    NewGearCollection[player.userID].collection.set[item].skin = 0;
                else if (type == "weapon")
                    NewWeaponCollection[player.userID].collection.set[item].skin = 0;
                DestroyACPanel(player);
                OpenACUI(player);
            }
        }

        [ConsoleCommand("UI_SetItemKillRequirement")]
        private void cmdUI_SetGearKillRequirement(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int kills = Convert.ToInt32(arg.Args[0]);
            var item = arg.Args[1];
            var type = arg.Args[2];
            if (type == "gear")
                NewGearCollection[player.userID].collection.set[item].killsrequired = kills;
            else if (type == "weapon")
                NewWeaponCollection[player.userID].collection.set[item].killsrequired = kills;
            else if (type == "attachment")
                NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].attachments[item].killsrequired = kills;
            DestroyACPanel(player);
            NumberPad(player, "UI_SetItemPrice", "SelectPrice", item, type);
        }

        [ConsoleCommand("UI_SetItemPrice")]
        private void cmdUI_SetGearPrice(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            var item = arg.Args[1];
            var type = arg.Args[2];
            if (type == "gear")
                NewGearCollection[player.userID].collection.set[item].price = amount;
            else if (type == "weapon")
                NewWeaponCollection[player.userID].collection.set[item].price = amount;
            else if (type == "attachment")
                NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].attachments[item].cost  = amount;
            DestroyACPanel(player);
            OpenACUI(player);
        }

        [ConsoleCommand("UI_SetCollectionCost")]
        private void cmdUI_SetCollectionCost(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int cost = Convert.ToInt32(arg.Args[0]);
            string type = arg.Args[1];
            if (type == "gear")
                NewGearCollection[player.userID].collection.cost = cost;
            else if (type == "weapon")
                NewWeaponCollection[player.userID].collection.cost = cost;
            DestroyACPanel(player);
            NumberPad(player, "UI_SetCollectionKills", "CollectionKills", "", type);
        }

        [ConsoleCommand("UI_SetCollectionKills")]
        private void cmdUI_SetCollectionKills(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            string type = arg.Args[1];
            if (type == "gear")
                NewGearCollection[player.userID].collection.killsrequired = amount;
            else if (type == "weapon")
                NewWeaponCollection[player.userID].collection.killsrequired = amount;
            DestroyACPanel(player);
            SetCollectionName(player);
        }

        private void SetCollectionName(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelAC);
            var element = UI.CreateElementContainer(PanelAC, UIColors["dark"], "0.4 0.3", "0.6 0.6");
            UI.CreatePanel(ref element, PanelAC, UIColors["light"], "0.03 0.02", "0.97 0.98");
            UI.CreateLabel(ref element, PanelAC, UIColors["limegreen"], GetMSG("CollectionName"), 16, "0.1 0.5", "0.9 .98", TextAnchor.UpperCenter);
            CuiHelper.AddUi(player, element);
        }

        [ConsoleCommand("UI_Free")]
        private void cmdUI_Free(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var answer = arg.Args[0];
            var item = arg.Args[1];
            var type = arg.Args[2];
            if (item == "collection")
            {
                if (answer == "true")
                {
                    if (type == "gear")
                        NewGearCollection[player.userID].collection.free = true;
                    else if (type == "weapon")
                        NewWeaponCollection[player.userID].collection.free = true;
                    DestroyACPanel(player);
                    SetCollectionName(player);
                }
                else if (answer == "false")
                {
                    if (type == "gear")
                        NewGearCollection[player.userID].collection.free = false;
                    else if (type == "weapon") NewWeaponCollection[player.userID].collection.free = false;
                    NumberPad(player, "UI_SetCollectionCost", "CollectionCost", " ", type);
                }
            }
            else
            {
                if (answer == "true")
                {
                    if (type == "gear")
                        NewGearCollection[player.userID].collection.set[item].free = true;
                    else if (type == "weapon")
                        NewWeaponCollection[player.userID].collection.set[item].free = true;
                    else if (type == "attachment")
                        NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].attachments[item].free = true;
                }
                else if (answer == "false")
                    if (type == "gear")
                        NewGearCollection[player.userID].collection.set[item].free = false;
                    else if (type == "weapon") NewWeaponCollection[player.userID].collection.set[item].free = false;
                    else if (type == "attachment")
                        NewWeaponCollection[player.userID].collection.set[NewWeaponCollection[player.userID].collection.currentweapon].attachments[item].free = false;
                DestroyACPanel(player);
                if (answer == "false")
                    NumberPad(player, "UI_SetItemKillRequirement", "SelectKillsRequired", item, type);
                else
                    OpenACUI(player);
            }
        }

        [ConsoleCommand("UI_ChangeGearSet")]
        private void cmdUI_ChangeGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var set = string.Join(" ",arg.Args);
            ACUIInfo[player.userID].GearSet = set;
            CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
            GearListPanel(player);
            GearPanel(player);
        }

        [ConsoleCommand("UI_ChangeWeaponSet")]
        private void cmdUI_ChangeWeaponSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var set = string.Join(" ", arg.Args);
            ACUIInfo[player.userID].WeaponSet = set;
            CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
            WeaponListPanel(player);
            WeaponPanel(player);
        }

        [ConsoleCommand("UI_SwitchAdminView")]
        private void cmdUI_SwitchAdminView(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (!isAuth(player))
            {
                GetSendMSG(player, "NotAuthorized");
                return;
            }
            if (ACUIInfo[player.userID].admin)
            {
                GetSendMSG(player, "ExitAdminView");
                ACUIInfo[player.userID].admin = false;
            }
            else
            {
                GetSendMSG(player, "EnterAdminView");
                ACUIInfo[player.userID].admin = true;
            }
                DestroyACPanel(player);
                OpenACUI(player);
        }

        [ConsoleCommand("UI_GearIndexShownChange")]
        private void cmdUI_GearIndexShownChange(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var index = Convert.ToInt32(arg.Args[0]);
            ACUIInfo[player.userID].GearIndex = index;
            GearListPanel(player);
        }

        [ConsoleCommand("UI_WeaponIndexShownChange")]
        private void cmdUI_WeaponIndexShownChange(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var index = Convert.ToInt32(arg.Args[0]);
            ACUIInfo[player.userID].WeaponIndex = index;
            WeaponListPanel(player);
        }

        [ConsoleCommand("UI_DestroyPurchaseConfirmation")]
        private void cmdUI_DestroyPurchaseConfirmation(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
        }

        [ConsoleCommand("UI_ProcessAttachment")]
        private void cmdUI_ProcessAttachment(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var request = arg.Args[0];
            var weapon = arg.Args[1];
            var attachment = arg.Args[2];
            var set = string.Join(" ", arg.Args.Skip(3).ToArray());
            ProcessAttachment(player, request, set, weapon, attachment);
        }

        void ProcessAttachment(BasePlayer player, string request, string set, string weapon, string attachment)
        {
            switch (request)
            {
                case "clear":
                    WeaponSelection[player.userID][set][weapon].Clear();
                    AttachmentPanel(player);
                    break;
                case "add":
                    WeaponSelection[player.userID][set][weapon].Add(attachment);
                    AttachmentPanel(player);
                    break;
                case "remove":
                    WeaponSelection[player.userID][set][weapon].Remove(attachment);
                    AttachmentPanel(player);
                    break;
            }
        }


        [ConsoleCommand("UI_ProcessSelection")]
        private void cmdUI_ProcessSelection(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var type = arg.Args[0];
            var set = string.Join(" ", arg.Args.Skip(1).ToArray());
            ProcessSelection(player, type, set);
        }

        void ProcessSelection(BasePlayer player, string type, string set)
        {
            switch (type)
            {
                case "set":
                    GetACPlayer(player).currentGearSet = set;
                    SelectSet(player, set);
                    break;
                case "weapon":
                    GetACPlayer(player).currentWeaponSet = set;
                    GetACPlayer(player).CurrentWeapons = WeaponSelection[player.userID][set];
                    SelectWeapons(player);
                    break;
            }
        }

        [ConsoleCommand("UI_PurchasingPanel")]
        private void cmdPurchasePanel(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (arg.Args[0] == "gear")
            {
                PendingPurchase[player.userID].gearpurchase = true;
                PendingPurchase[player.userID].weaponpurchase = false;
                PendingPurchase[player.userID].attachmentpurchase = false;
            }
            else
            {
                PendingPurchase[player.userID].weaponpurchase = true;
                PendingPurchase[player.userID].gearpurchase = false;
                PendingPurchase[player.userID].attachmentpurchase = false;
            }
            var item = string.Join(" ",arg.Args.Skip(1).ToArray());
            PurchaseConfirmation(player, item);
        }

        [ConsoleCommand("UI_PrepPurchase")]
        private void cmdUI_PrepPurchase(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            PendingPurchase[player.userID].set = false;
            var item = arg.Args[0];
            var type = arg.Args[1];
            if (type == "gear")
            {
                PendingPurchase[player.userID].gearpurchase = true;
                PendingPurchase[player.userID].weaponpurchase = false;
                PendingPurchase[player.userID].attachmentpurchase = false;
                PendingPurchase[player.userID].setname = ACUIInfo[player.userID].GearSet;
                PendingPurchase[player.userID].setprice = gwData.GearSets[ACUIInfo[player.userID].GearSet].cost;
                PendingPurchase[player.userID].setkillrequirement = gwData.GearSets[ACUIInfo[player.userID].GearSet].killsrequired;
            }
            else if (type == "weapon")
            {
                PendingPurchase[player.userID].weaponpurchase = true;
                PendingPurchase[player.userID].gearpurchase = false;
                PendingPurchase[player.userID].attachmentpurchase = false;
                PendingPurchase[player.userID].setname = ACUIInfo[player.userID].WeaponSet;
                PendingPurchase[player.userID].setprice = gwData.WeaponSets[ACUIInfo[player.userID].WeaponSet].cost;
                PendingPurchase[player.userID].setkillrequirement = gwData.WeaponSets[ACUIInfo[player.userID].WeaponSet].killsrequired;
            }
            else
            {
                PendingPurchase[player.userID].gearpurchase = false;
                PendingPurchase[player.userID].weaponpurchase = true;
                PendingPurchase[player.userID].attachmentpurchase = true;
                PendingPurchase[player.userID].setname = ACUIInfo[player.userID].WeaponSet;
                PendingPurchase[player.userID].attachmentName = arg.Args[1];
            }
            PurchaseConfirmation(player, item);
        }

        [ConsoleCommand("UI_Purchase")]
        private void cmdUI_Purchase(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var item = string.Join(" ", arg.Args);
            Purchase(player, item);
        }

        void Purchase(BasePlayer player, string item)
        {
            var money = GetACPlayer(player).money;
            var pending = PendingPurchase[player.userID];
            if (pending.gearpurchase == true)
            {
                if (pending.set == false)
                {
                    GetACPlayer(player).PlayerGearSets[pending.setname].Add(item);
                    DestroyACPanel(player);
                    if (configData.UseServerRewards)
                        SRAction(player.userID, pending.gear[item].price, "REMOVE");
                    else if (configData.UseEconomics)
                        ECOAction(player.userID, pending.gear[item].price, "REMOVE");
                    else
                        money -= pending.gear[item].price;
                    CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
                    OnScreen(player, GetMSG("purchaseitem", pending.gear[item].shortname, pending.setname));
                    timer.Once(3, () => { OpenACUI(player); });
                }
                else
                {
                    GetACPlayer(player).PlayerGearSets.Add(item, new List<string>());
                    GetACPlayer(player).GearSetKills.Add(item, 0);
                    foreach (var entry in gwData.GearSets[item].set.Where(kvp => kvp.free == true))
                        GetACPlayer(player).PlayerGearSets[item].Add(entry.shortname);
                    DestroyACPanel(player);
                    if (configData.UseServerRewards)
                        SRAction(player.userID, gwData.GearSets[item].cost, "REMOVE");
                    else if (configData.UseEconomics)
                        ECOAction(player.userID, gwData.GearSets[item].cost, "REMOVE");
                    else
                        money -= gwData.GearSets[item].cost;
                    PlayerHUD(player);
                    CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
                    OnScreen(player, GetMSG("purchaseset", item));
                    timer.Once(3, () => { OpenACUI(player); });
                }
            }
            else if (pending.weaponpurchase == true)
            {
                if (pending.set == false)
                {
                    if (pending.attachmentpurchase == true)
                    {
                        GetACPlayer(player).PlayerWeaponSets[pending.setname][item].Add(pending.attachmentName);
                        DestroyACPanel(player);
                        if (configData.UseServerRewards)
                            SRAction(player.userID, pending.attachment[pending.weapon[item].slot][pending.attachmentName].cost, "REMOVE");
                        else if (configData.UseEconomics)
                            ECOAction(player.userID, pending.attachment[pending.weapon[item].slot][pending.attachmentName].cost, "REMOVE");
                        else
                            money -= pending.attachment[pending.weapon[item].slot][pending.attachmentName].cost;
                        CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
                        OnScreen(player, GetMSG("purchaseattachment", pending.attachment[pending.weapon[item].slot][pending.attachmentName].shortname, pending.weapon[item].shortname));
                        timer.Once(3, () => { OpenACUI(player); });
                    }
                    else
                    {
                        GetACPlayer(player).PlayerWeaponSets[pending.setname].Add(item, new List<string>());
                        DestroyACPanel(player);
                        if (configData.UseServerRewards)
                            SRAction(player.userID, pending.weapon[item].price, "REMOVE");
                        else if (configData.UseEconomics)
                            ECOAction(player.userID, pending.weapon[item].price, "REMOVE");
                        else
                            money -= pending.weapon[item].price;
                        CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
                        OnScreen(player, GetMSG("purchaseweapon", pending.weapon[item].shortname, pending.setname));
                        timer.Once(3, () => { OpenACUI(player); });
                    }
                }
                else
                {
                    GetACPlayer(player).PlayerWeaponSets.Add(item, new Dictionary<string, List<string>>());
                    GetACPlayer(player).WeaponSetKills.Add(item, 0);
                    foreach (var entry in gwData.WeaponSets[item].set.Where(kvp => kvp.free == true))
                        GetACPlayer(player).PlayerWeaponSets[item].Add(entry.shortname, new List<string>());
                    DestroyACPanel(player);
                    if (configData.UseServerRewards)
                        SRAction(player.userID, gwData.WeaponSets[item].cost, "REMOVE");
                    else if (configData.UseEconomics)
                        ECOAction(player.userID, gwData.WeaponSets[item].cost, "REMOVE");
                    else
                        money -= gwData.WeaponSets[item].cost;
                    PlayerHUD(player);
                    CuiHelper.DestroyUi(player, PanelPurchaseConfirmation);
                    OnScreen(player, GetMSG("purchaseweaponset", item));
                    timer.Once(3, () => { OpenACUI(player); });
                }
            }
        }

        [ConsoleCommand("UI_SaveCollect")]
        private void cmdUI_SaveSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var type = arg.Args[0];
            if (SavingCollection.ContainsKey(player.userID))
                SavingCollection.Remove(player.userID);
            SavingCollection.Add(player.userID, type);
            if (type == "gear")
            {
                foreach (var entry in NewGearCollection[player.userID].collection.set)
                    if (entry.Value.price == 0 && entry.Value.killsrequired == 0)
                        entry.Value.free = true;
            }
            if (type == "weapon")
            {
                foreach (var entry in NewWeaponCollection[player.userID].collection.set)
                {
                    if (entry.Value.price == 0 && entry.Value.killsrequired == 0)
                        entry.Value.free = true;
                    foreach (var attachment in entry.Value.attachments)
                        if (attachment.Value.cost == 0 && attachment.Value.killsrequired == 0)
                            attachment.Value.free = true;
                }
            }
            SelectIfFree(player, "collection", type);
        }

        [ConsoleCommand("UI_CreateGearSet")]
        private void cmdUI_CreateGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            CreateGearSet(player);
        }
        [ConsoleCommand("UI_CancelGearSet")]
        private void cmdUI_CancelGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (NewGearCollection.ContainsKey(player.userID))
                NewGearCollection.Remove(player.userID);
            DestroyACPanel(player);
            OpenACUI(player);
        }

        [ConsoleCommand("UI_CancelWeaponSet")]
        private void cmdUI_CancelWeaponSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (NewWeaponCollection.ContainsKey(player.userID))
                NewWeaponCollection.Remove(player.userID);
            DestroyACPanel(player);
            OpenACUI(player);
        }

        [ConsoleCommand("UI_CreateWeaponSet")]
        private void cmdUI_CreateWeaponSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            CreateWeaponSet(player);
        }

        [ConsoleCommand("UI_DeleteGearSet")]
        private void cmdUI_DeleteGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var set = ACUIInfo[player.userID].GearSet;
            if (gwData.GearSets.ContainsKey(set))
            {
                gwData.GearSets.Remove(set);
                foreach (var entry in ACUIInfo)
                {
                    if (entry.Value.GearSet == set)
                        entry.Value.GearSet = "";
                }
                foreach (ACPlayer ac in ACPlayers)
                {
                    DestroyACPanel(ac.player);
                    OpenACUI(ac.player);
                    CheckSets(ac);
                }
            }
        }

        [ConsoleCommand("UI_DeleteWeaponSet")]
        private void cmdUI_DeleteWeaponSet(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var set = ACUIInfo[player.userID].WeaponSet;
            if (gwData.WeaponSets.ContainsKey(set))
            {
                gwData.WeaponSets.Remove(set);
                foreach (var entry in ACUIInfo)
                {
                    if (entry.Value.WeaponSet == set)
                        entry.Value.WeaponSet = "";
                }
                foreach (ACPlayer ac in ACPlayers)
                {
                    DestroyACPanel(ac.player);
                    OpenACUI(ac.player);
                    CheckSets(ac);
                }
            }
        }

        [ConsoleCommand("UI_SelectSkin")]
        private void cmdUI_SelectSkin(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var item = arg.Args[0];
            ulong skin;
            if (!ulong.TryParse(arg.Args[1], out skin)) skin = 0;
            var type = arg.Args[2];
            if (type == "gear")
                NewGearCollection[player.userID].collection.set[item].skin = skin;
            else if (type == "weapon")
                NewWeaponCollection[player.userID].collection.set[item].skin = skin;
            DestroyACPanel(player);
            OpenACUI(player);
        }



        #endregion

        #region Item Management

        private void SelectSet(BasePlayer player, string name)
        {
            if (!PlayerGearSetTimer.ContainsKey(player.userID))
            {
                player.inventory.Strip();
                GiveSet(player);
                GiveWeapon(player);
                PlayerHUD(player);
                DestroyACPanel(player);
                TimerPlayerGearSetselection(player);
            }
            else
            {
                GetSendMSG(player, "GearSetCooldown", GetACPlayer(player).currentGearSet);
                PlayerHUD(player);
            }
        }

        private void TimerPlayerGearSetselection(BasePlayer player)
        {
            if (PlayerGearSetTimer.ContainsKey(player.userID))
            {
                PlayerGearSetTimer.Remove(player.userID);
            }
            else PlayerGearSetTimer.Add(player.userID, timer.Once(configData.SetCooldown * 60, () => TimerPlayerGearSetselection(player)));
        }

        private void SelectWeapons(BasePlayer player)
        {
            if (!PlayerWeaponSetTimer.ContainsKey(player.userID))
            {
                player.inventory.Strip();
                GiveSet(player);
                GiveWeapon(player);
                PlayerHUD(player);
                DestroyACPanel(player);
                TimerPlayerWeaponselection(player);
            }
            else
            {
                GetSendMSG(player, "WeaponSetCooldown", GetACPlayer(player).currentWeaponSet);
                PlayerHUD(player);
            }
        }

        private void TimerPlayerWeaponselection(BasePlayer player)
        {
            if (PlayerWeaponSetTimer.ContainsKey(player.userID))
            {
                PlayerWeaponSetTimer.Remove(player.userID);
            }
            else PlayerWeaponSetTimer.Add(player.userID, timer.Once(configData.SetCooldown * 60, () => TimerPlayerGearSetselection(player)));
        }

        private void GiveSet(BasePlayer player)
        {
            if (GetACPlayer(player).currentGearSet == null) return;
            var set = gwData.GearSets[GetACPlayer(player).currentGearSet];
            foreach (var item in set.set)
            {
                if (GetACPlayer(player).PlayerGearSets[GetACPlayer(player).currentGearSet].Contains(item.shortname))
                    GiveItem(player, BuildSet(item), item.container);
            }
            PlayerHUD(player);
        }
        private void GiveWeapon(BasePlayer player)
        {
            if (GetACPlayer(player).CurrentWeapons == null) return;
            foreach (var weapon in GetACPlayer(player).CurrentWeapons)
            {
                foreach (var entry in gwData.WeaponSets[GetACPlayer(player).currentWeaponSet].set.Where(kvp => kvp.shortname == weapon.Key))
                    GiveItem(player, BuildWeapon(entry, player), entry.container);
            }
            PlayerHUD(player);
        }

        private Item BuildWeapon(Weapon weapon, BasePlayer player)
        {
            if (weapon == null) return null;
            var definition = ItemManager.FindItemDefinition(weapon.shortname);
            if (definition != null)
            {
                var item = ItemManager.Create(definition, weapon.amount, weapon.skin);
                if (item != null)
                {
                    var held = item.GetHeldEntity() as BaseProjectile;
                    if (held != null)
                    {
                        if (!string.IsNullOrEmpty(weapon.ammoType))
                        {
                            var ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
                            if (ammoType != null)
                                held.primaryMagazine.ammoType = ammoType;
                        }
                        held.primaryMagazine.contents = held.primaryMagazine.capacity;
                    }
                    if (weapon.ammo == 0) weapon.ammo = held.primaryMagazine.capacity * configData.DefaultAmmoReloads;
                    if (weapon.ammo < configData.DefaultAmmoReloads * 4)
                        weapon.ammo = 128;
                