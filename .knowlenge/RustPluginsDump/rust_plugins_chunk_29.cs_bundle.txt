    if (string.IsNullOrEmpty(weapon.ammoType))
                        GiveItem(player, BuildAmmo(held.primaryMagazine.ammoType.shortname, weapon.ammo), "");
                   else GiveItem(player, BuildAmmo(weapon.ammoType, weapon.ammo), "");
                    if (GetACPlayer(player).CurrentWeapons[weapon.shortname] == null) return item;
                    foreach (var attachment in GetACPlayer(player).CurrentWeapons[weapon.shortname])
                        if (weapon.attachments.ContainsKey(attachment))
                        {
                            BuildItem(attachment)?.MoveToContainer(item.contents);
                        }
                }
                return item;
            }
            Puts("Error making item: " + weapon.shortname);
            return null;
        }

        private Item BuildAmmo(string shortname, int amount)
        {
            var definition = ItemManager.FindItemDefinition(shortname);
            if (definition != null)
            {
                var item = ItemManager.Create(definition, amount, 0);
                if (item != null)
                    return item;
            }
            Puts("Error making ammo!");
            return null;
        }

        private Item BuildSet(Gear gear)
        {
            var definition = ItemManager.FindItemDefinition(gear.shortname);
            if (definition != null)
            {
                var item = ItemManager.Create(definition, gear.amount, gear.skin);
                if (item != null)
                    return item;
            }
            Puts("Error making item: " + gear.shortname);
            return null;
        }

        private Item BuildItem(string shortname, int amount = 1, ulong skin = 0)
        {
            var definition = ItemManager.FindItemDefinition(shortname);
            if (definition != null)
            {
                var item = ItemManager.Create(definition, amount, skin);
                if (item != null)
                    return item;
            }
            Puts("Error making attachment: " + shortname);
            return null;
        }

        public void GiveItem(BasePlayer player, Item item, string container)
        {
            if (item == null) return;
            ItemContainer cont;
            switch (container)
            {
                case "wear":
                    cont = player.inventory.containerWear;
                    break;
                case "belt":
                    cont = player.inventory.containerBelt;
                    break;
                default:
                    cont = player.inventory.containerMain;
                    break;
            }
            player.inventory.GiveItem(item, cont);
        }

        public void CreateGearSet(BasePlayer player)
        {
            if (NewGearCollection.ContainsKey(player.userID))
                NewGearCollection.Remove(player.userID);
            NewGearCollection.Add(player.userID, new GearCollectionCreation());
            DestroyACPanel(player);
            OpenACUI(player);
        }

        public void CreateWeaponSet(BasePlayer player)
        {
            if (NewWeaponCollection.ContainsKey(player.userID))
                NewWeaponCollection.Remove(player.userID);
            NewWeaponCollection.Add(player.userID, new WeaponCollectionCreation());
            DestroyACPanel(player);
            OpenACUI(player);
        }

        #endregion

        #region Classes
        [Serializable]
        class ACPlayer : MonoBehaviour
        {
            public BasePlayer player;
            public int kills;
            public int deaths;
            public int money;
            public Dictionary<string, List<string>> PlayerGearSets = new Dictionary<string, List<string>>();
            public Dictionary<string, Dictionary<string, List<string>>> PlayerWeaponSets = new Dictionary<string, Dictionary<string, List<string>>>();
            public string currentGearSet;
            public string currentWeaponSet;
            public Dictionary<string, List<string>> CurrentWeapons = new Dictionary<string, List<string>>();
            public Dictionary<string, int> GearSetKills = new Dictionary<string, int>();
            public Dictionary<string, int> WeaponSetKills = new Dictionary<string, int>();

            void Awake()
            {
                enabled = false;
                player = GetComponent<BasePlayer>();
            }
        }

        enum Slot
        {
            head,
            chest,
            chest2,
            legs,
            legs2,
            feet,
            hands,
            main,
            secondary,
            attachment1,
            attachment2,
            attachment3,
            accessories1,
            accessories2,
            weapon,
            ammunitionMain,
            ammunitionSecondary
        }

        class Gear_Weapon_Data
        {
            public Dictionary<string, GearSet> GearSets = new Dictionary<string, GearSet>();
            public Dictionary<string, WeaponSet> WeaponSets = new Dictionary<string, WeaponSet>();
            public Dictionary<Slot, List<string>> Items = new Dictionary<Slot, List<string>>();
            public Dictionary<string, Dictionary<ulong, uint>> Images = new Dictionary<string, Dictionary<ulong, uint>>();
        }

        class SavedPlayers
        {
            public Dictionary<ulong, SavedPlayer> players = new Dictionary<ulong, SavedPlayer>();
            public Dictionary<ulong, SavedPlayer> priorSave = new Dictionary<ulong, SavedPlayer>();
        }

        class SavedPlayer
        {
            public int kills;
            public int deaths;
            public int money;
            public string lastgearSet;
            public string lastweaponSet;
            public Dictionary<string, List<string>> lastWeapons = new Dictionary<string, List<string>>();
            public Dictionary<string, List<string>> PlayerGearSets = new Dictionary<string, List<string>>();
            public Dictionary<string, Dictionary<string, List<string>>> PlayerWeaponSets = new Dictionary<string, Dictionary<string, List<string>>>();
            public Dictionary<string, int> GearSetKills = new Dictionary<string, int>();
            public Dictionary<string, int> WeaponSetKills = new Dictionary<string, int>();
        }

        class GearSet
        {
            public int index;
            public int cost;
            public int killsrequired;
            public List<Gear> set = new List<Gear>();
        }

        class WeaponCollectionCreation
        {
            public string setname;
            public CreationWeaponSet collection = new CreationWeaponSet();
        }

        class GearCollectionCreation
        {
            public string setname;
            public CreationGearSet collection = new CreationGearSet();
        }


        class CreationGearSet
        {
            public int index;
            public int cost;
            public int killsrequired;
            public bool free;
            public Dictionary<string, Gear> set = new Dictionary<string, Gear>();
        }

        class CreationWeaponSet
        {
            public int index;
            public int cost;
            public int killsrequired;
            public bool free;
            public string currentweapon;
            public Dictionary<string, Weapon> set = new Dictionary<string, Weapon>();
        }

        class WeaponSet
        {
            public int index;
            public int cost;
            public int killsrequired;
            public List<Weapon> set = new List<Weapon>();
        }


        class Attachment
        {
            public bool free;
            public string shortname;
            public int cost;
            public int killsrequired;
            public Slot slot;
            public string location;
        }

        class PurchaseItem
        {
            public Dictionary<string, Gear> gear = new Dictionary<string, Gear>();
            public Dictionary<string, Weapon> weapon = new Dictionary<string, Weapon>();
            public Dictionary<Slot,Dictionary<string, Attachment>> attachment = new Dictionary<Slot, Dictionary<string, Attachment>>();
            public string setname;
            public bool set = true;
            public bool weaponpurchase;
            public bool gearpurchase;
            public bool attachmentpurchase;
            public string attachmentName;
            public int setprice;
            public int setkillrequirement;
        }

        class Gear
        {
            public bool free;
            public string shortname;
            public Slot slot;
            public int price;
            public ulong skin;
            public int killsrequired;
            public int amount;
            public string container;
        }

        class Weapon
        {
            public bool free;
            public string shortname;
            public ulong skin;
            public Slot slot;
            public string container;
            public int killsrequired;
            public int price;
            public int amount;
            public int ammo;
            public string ammoType;
            public Dictionary<string, Attachment> attachments = new Dictionary<string, Attachment>();
        }

        #endregion

        #region Timers

        private void SaveLoop()
        {
            if (timers.ContainsKey("save"))
            {
                timers["save"].Destroy();
                timers.Remove("save");
            }
            SaveData();
            timers.Add("save", timer.Once(600, () => SaveLoop()));
        }

        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            if (configData.InfoInterval == 0) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                GetSendMSG(p, "ACInfo", configData.MenuKeyBinding.ToUpper());
            }
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }

        private void CondLoop()
        {
            if (timers.ContainsKey("cond"))
            {
                timers["cond"].Destroy();
                timers.Remove("cond");
            }
            if (!configData.PersistentCondition) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                p.metabolism.calories.value = 500;
                p.metabolism.hydration.value = 250;
            }
            timers.Add("cond", timer.Once(120, () => CondLoop()));
        }


        #endregion

        #region External Hooks

        object AddMoney(ulong TargetID, int amount, bool notify = true, ulong RequestorID = 0)
        {
            try
            {
                BasePlayer target = BasePlayer.FindByID(TargetID);
                if (GetACPlayer(target) != null)
                {
                    GetACPlayer(target).money += amount;
                    if (notify)
                        GetSendMSG(target, "AddMoney", amount.ToString());
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "MoneyAdded", target.displayName, amount.ToString());
                    }
                    return true;
                }
                else if (playerData.players.ContainsKey(TargetID))
                {
                    playerData.players[TargetID].money += amount;
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "MoneyAddedOffline", amount.ToString());
                    }
                    return true;
                }
                else
                {
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "NotACPlayer");
                    }
                    return null;
                }
            }
            catch
            {
                if (RequestorID != 0)
                {
                    BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                    GetSendMSG(requestor, "AddMoneyError");
                }
                Puts(GetLang("AddMoneyError"));
                return null;
            }
        }


        object TakeMoney(ulong TargetID, int amount, bool notify = true, ulong RequestorID = 0)
        {
            try
            {
                BasePlayer target = BasePlayer.FindByID(TargetID);
                if (GetACPlayer(target) != null)
                {
                    GetACPlayer(target).money -= amount;
                    if (notify)
                        GetSendMSG(target, "TakeMoney", amount.ToString());
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "MoneyTaken", target.displayName, amount.ToString());
                    }
                    return true;
                }
                else if (playerData.players.ContainsKey(TargetID))
                {
                    playerData.players[TargetID].money -= amount;
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "MoneyTakenOffline", amount.ToString());
                    }
                    return true;
                }
                else
                {
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "NotACPlayer");
                    }
                    return null;
                }
            }
            catch
            {
                if (RequestorID != 0)
                {
                    BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                    GetSendMSG(requestor, "TakeMoneyError");
                }
                Puts(GetLang("TakeMoneyError"));
                return null;
            }
        }

        object AddKills(ulong TargetID, int amount, string type, string collection, ulong RequestorID = 0)
        {
            try
            {
                BasePlayer target = BasePlayer.FindByID(TargetID);
                if (GetACPlayer(target) != null)
                {
                    if (type == "gear")
                    GetACPlayer(target).GearSetKills[collection] += amount;
                    if (type == "weapon")
                        GetACPlayer(target).WeaponSetKills[collection] += amount;
                        GetSendMSG(target, "AddKills", amount.ToString(), collection.ToUpper());
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "KillsAdded", target.displayName, amount.ToString(), collection.ToUpper());
                    }
                    return true;
                }
                else
                {
                    if (type == "gear")
                        playerData.players[TargetID].GearSetKills[collection] += amount;
                    if (type == "weapon")
                        playerData.players[TargetID].WeaponSetKills[collection] += amount;
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "KillsAddedOffline",TargetID.ToString(), amount.ToString(), collection.ToUpper());
                    }
                    return true;
                }
            }
            catch
            {
                if (RequestorID != 0)
                {
                    BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                    GetSendMSG(requestor, "AddKillsError");
                }
                Puts(GetLang("AddKillsError"));
                return null;
            }
        }

        object TakeKills(ulong TargetID, int amount, string type, string collection, ulong RequestorID = 0)
        {
            try
            {
                BasePlayer target = BasePlayer.FindByID(TargetID);
                if (GetACPlayer(target) != null)
                {
                    if (type == "gear")
                    {
                        GetACPlayer(target).GearSetKills[collection] -= amount;
                        if (GetACPlayer(target).GearSetKills[collection] < 0)
                            GetACPlayer(target).GearSetKills[collection] = 0;
                    }
                    if (type == "weapon")
                    {
                        GetACPlayer(target).WeaponSetKills[collection] -= amount;
                        if (GetACPlayer(target).WeaponSetKills[collection] < 0)
                            GetACPlayer(target).WeaponSetKills[collection] = 0;
                    }
                    GetSendMSG(target, "TakeKills", amount.ToString(), collection.ToUpper());
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "KillsTaken", target.displayName, amount.ToString(), collection.ToUpper());
                    }
                    return true;
                }
                else
                {
                    if (type == "gear")
                    {
                        playerData.players[TargetID].GearSetKills[collection] -= amount;
                        if (playerData.players[TargetID].GearSetKills[collection] < 0)
                            playerData.players[TargetID].GearSetKills[collection] = 0;
                    }
                    if (type == "weapon")
                    {
                        playerData.players[TargetID].WeaponSetKills[collection] -= amount;
                        if (playerData.players[TargetID].WeaponSetKills[collection] < 0)
                            playerData.players[TargetID].WeaponSetKills[collection] = 0;
                    }
                    if (RequestorID != 0)
                    {
                        BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                        GetSendMSG(requestor, "KillsTakenOffline", TargetID.ToString(), amount.ToString(), collection.ToUpper());
                    }
                    return true;
                }
            }
            catch
            {
                if (RequestorID != 0)
                {
                    BasePlayer requestor = BasePlayer.FindByID(RequestorID);
                    GetSendMSG(requestor, "TakeKillsError");
                }
                Puts(GetLang("TakeKillsError"));
                return null;
            }
        }


        #endregion

        #region GWData Management
        private Dictionary<Slot, List<string>> DefaultItems = new Dictionary<Slot, List<string>>
            {
                {Slot.chest, new List<string>
                {
                    "tshirt",
                    "tshirt.long",
                    "shirt.collared",
                    "shirt.tanktop",
                    "jacket",
                    "jacket.snow",
                    "hoodie",
                    "burlap.shirt",
                    "hazmat.jacket",
                }
                },
            {Slot.chest2, new List<string>
            {
                "wood.armor.jacket",
                "roadsign.jacket",
                "metal.plate.torso",
                "bone.armor.suit",
                "attire.hide.vest",
                "attire.hide.poncho",
                "attire.hide.helterneck",
            }
            },
            {Slot.legs, new List<string>
                {
                    "pants",
                    "pants.shorts",
                    "hazmat.pants",
                    "burlap.trousers",
                    "attire.hide.pants",
                    "attire.hide.skirt",
                }
                },
            {Slot.legs2, new List<string>
                {
                    "wood.armor.pants",
                    "roadsign.kilt",
                }
                },
            {Slot.head, new List<string>
                {
                    "mask.bandana",
                    "mask.balaclava",
                    "hat.cap",
                    "hat.beenie",
                    "bucket.helmet",
                    "hat.boonie",
                    "santahat",
                    "riot.helmet",
                    "metal.facemask",
                    "hazmat.helmet",
                    "hat.miner",
                    "hat.candle",
                    "coffeecan.helmet",
                    "burlap.headwrap",
                }
                },
            {Slot.hands, new List<string>
                {
                    "burlap.gloves",
                    "hazmat.gloves",
                }
                },
            {Slot.feet, new List<string>
                {
                    "shoes.boots",
                    "hazmat.boots",
                    "burlap.shoes",
                    "attire.hide.boots",
                }
                },
                {Slot.secondary, new List<string>
                {
                    "pistol.revolver",
                    "pistol.semiauto",
                    "rifle.ak",
                    "rifle.bolt",
                    "shotgun.pump",
                    "shotgun.waterpipe",
                    "rifle.lr300",
                    "crossbow",
                    "smg.thompson",
                    "spear.wooden",
                    "spear.stone",
                    "smg.2",
                    "shotgun.double",
                    "salvaged.sword",
                    "salvaged.cleaver",
                    "rocket.launcher",
                    "rifle.semiauto",
                    "pistol.eoka",
                    "machete",
                    "mace",
                    "longsword",
                    "lmg.m249",
                    "knife.bone",
                    "flamethrower",
                    "bow.hunting",
                    "bone.club",
                }
                },
                {Slot.main, new List<string>
                {
                    "pistol.revolver",
                    "pistol.semiauto",
                    "rifle.ak",
                    "rifle.bolt",
                    "shotgun.pump",
                    "shotgun.waterpipe",
                    "rifle.lr300",
                    "crossbow",
                    "smg.thompson",
                    "spear.wooden",
                    "spear.stone",
                    "smg.2",
                    "shotgun.double",
                    "salvaged.sword",
                    "salvaged.cleaver",
                    "rocket.launcher",
                    "rifle.semiauto",
                    "pistol.eoka",
                    "machete",
                    "mace",
                    "longsword",
                    "lmg.m249",
                    "knife.bone",
                    "flamethrower",
                    "bow.hunting",
                    "bone.club",
                }
                },
            {Slot.attachment1, new List<string>
                {
                    "weapon.mod.lasersight",
                    "weapon.mod.flashlight",
                    "weapon.mod.silencer",
                    "weapon.mod.muzzlebrake",
                    "weapon.mod.muzzleboost",
                    "weapon.mod.small.scope",
                    "weapon.mod.holosight",
                }
                },
                {Slot.attachment2, new List<string>
                {
                    "weapon.mod.lasersight",
                    "weapon.mod.flashlight",
                    "weapon.mod.silencer",
                    "weapon.mod.muzzlebrake",
                    "weapon.mod.muzzleboost",
                    "weapon.mod.small.scope",
                    "weapon.mod.holosight",
                }
                },

                {Slot.attachment3, new List<string>
                {
                    "weapon.mod.lasersight",
                    "weapon.mod.flashlight",
                    "weapon.mod.silencer",
                    "weapon.mod.muzzlebrake",
                    "weapon.mod.muzzleboost",
                    "weapon.mod.small.scope",
                    "weapon.mod.holosight",
                }
                },

            {Slot.accessories1, new List<string>
                {
                    "bandage",
                    "syringe.medical",
                    "largemedkit",
                    "grenade.beancan",
                    "grenade.f1",
                    "flare",
                    "fun.guitar",
                    "building.planner",
                    "hammer",
                    "explosive.timed",
                    "explosive.satchel",
                }
                },
            {Slot.accessories2, new List<string>
                {
                    "bandage",
                    "syringe.medical",
                    "largemedkit",
                    "grenade.beancan",
                    "grenade.f1",
                    "flare",
                    "fun.guitar",
                    "building.planner",
                    "hammer",
                    "explosive.timed",
                    "explosive.satchel",
                }
                },
            {Slot.ammunitionMain, new List<string>
                {
                    "ammo.rifle.hv",
                    "ammo.rifle.explosive",
                    "ammo.rifle.incendiary",
                    "ammo.rifle",
                    "ammo.pistol.hv",
                    "ammo.pistol.fire",
                    "ammo.pistol",
                    "ammo.handmade.shell",
                    "ammo.rocket.basic",
                    "ammo.rocket.hv",
                    "ammo.rocket.fire",
                    "ammo.rocket.smoke",
                    "ammo.shotgun",
                    "ammo.shotgun.slug",
                    "arrow.hv",
                    "arrow.wooden",
            }
                },
            {Slot.ammunitionSecondary, new List<string>
                {
                    "ammo.rifle.hv",
                    "ammo.rifle.explosive",
                    "ammo.rifle.incendiary",
                    "ammo.rifle",
                    "ammo.pistol.hv",
                    "ammo.pistol.fire",
                    "ammo.pistol",
                    "ammo.handmade.shell",
                    "ammo.rocket.basic",
                    "ammo.rocket.hv",
                    "ammo.rocket.fire",
                    "ammo.rocket.smoke",
                    "ammo.shotgun",
                    "ammo.shotgun.slug",
            }
                }
            };

        private Dictionary<string, Attachment> DefaultAttachments = new Dictionary<string, Attachment>
        {
                        { "weapon.mod.muzzleboost", new Attachment
                        {
                            location = "front",
                        }
                        },
                        { "weapon.mod.flashlight", new Attachment
                        {
                            location = "middle",
                        }
                        },
                        { "weapon.mod.silencer", new Attachment
                        {
                            location = "front",
                            }
                        },
                        { "weapon.mod.muzzlebrake", new Attachment
                        {
                            location = "front",
                            }
                        },
                        { "weapon.mod.small.scope", new Attachment
                        {
                            location = "back",
                            }
                        },
                        { "weapon.mod.lasersight", new Attachment
                        {
                            location = "middle",
                            }
                        },
                        { "weapon.mod.holosight", new Attachment
                        {
                            location = "back",
                        }
                        }
        };

        private Dictionary<string, GearSet> DefaultGearSets = new Dictionary<string, GearSet>
                {
                    {"Starter", new GearSet{cost = 0, killsrequired = 0, index = 0, set = new List<Gear>
                    { new Gear
                        {
                        shortname = "tshirt",
                        skin = 10056,
                        slot = Slot.chest,
                        container = "wear",
                        amount = 1,
                        killsrequired = 0,
                        price = 0,
                        },
                        new Gear
                        {
                       shortname = "pants",
                        skin = 10001,
                        slot = Slot.legs,
                        container = "wear",
                        amount = 1,
                        killsrequired = 0,
                        price = 0,
                        },
                        new Gear
                        {
                        shortname = "shoes.boots",
                        skin = 10044,
                        slot = Slot.feet,
                        container = "wear",
                        amount = 1,
                        killsrequired = 0,
                        price = 0,
                        },
                        new Gear
                        {
                       shortname = "hat.cap",
                        skin = 10055,
                        slot = Slot.head,
                        container = "wear",
                        amount = 1,
                        killsrequired = 0,
                        price = 0,
                        },
                        new Gear
                        {
                        shortname = "burlap.gloves",
                        skin = 10128,
                        slot = Slot.hands,
                        container = "wear",
                        amount = 1,
                        killsrequired = 0,
                        price = 0,
                        }
                     } } },
                {"First", new GearSet{cost = 0, killsrequired = 10, index = 1, set = new List<Gear>
                    { new Gear
                        {
                        shortname = "hoodie",
                        skin = 10129,
                        slot = Slot.chest,
                        container = "wear",
                        amount = 1,
                        killsrequired = 5,
                        price = 5,
                        },
                        new Gear
                        {
                       shortname = "pants",
                        skin = 10001,
                        slot = Slot.legs,
                        container = "wear",
                        amount = 1,
                        killsrequired = 5,
                        price = 5,
                        },
                        new Gear
                        {
                        shortname = "shoes.boots",
                        skin = 10023,
                        slot = Slot.feet,
                        container = "wear",
                        amount = 1,
                        killsrequired = 5,
                        price = 5,
                        },
                        new Gear
                        {
                       shortname = "coffeecan.helmet",
                        skin = 0,
                        slot = Slot.head,
                        container = "wear",
                        amount = 1,
                        killsrequired = 5,
                        price = 5,
                        },
                        new Gear
                        {
                        shortname = "wood.armor.pants",
                        skin = 0,
                        slot = Slot.legs2,
                        container = "wear",
                        amount = 1,
                        killsrequired = 5,
                        price = 5,
                        },
                        new Gear
                        {
                        shortname = "wood.armor.jacket",
                        skin = 0,
                        slot = Slot.chest2,
                        container = "wear",
                        amount = 1,
                        killsrequired = 5,
                        price = 5,
                        }
                     } } }
        };

        private Dictionary<string, WeaponSet> DefaultWeaponSets = new Dictionary<string, WeaponSet>
                {
                    {"Starter", new WeaponSet{cost = 0, killsrequired = 0, index = 0, set = new List<Weapon>
                    { new Weapon
                        {
                        shortname = "bow.hunting",
                        skin = 0,
                        slot = Slot.main,
                        container = "belt",
                        amount = 1,
                        ammo = 128,
                        ammoType = "arrow.wooden",
                        killsrequired = 0,
                        price = 0,
                        },
                        new Weapon
                        {
                        shortname = "knife.bone",
                        skin = 0,
                        slot = Slot.secondary,
                        container = "belt",
                        amount = 1,
                        ammo = 0,
                        ammoType = "",
                        killsrequired = 0,
                        price = 0,
                        }
                     } } },
                {"First", new WeaponSet{cost = 0, killsrequired = 0, index = 1, set = new List<Weapon>
                    { new Weapon
                        {
                        shortname = "smg.thompson",
                        skin = 10120,
                        slot = Slot.main,
                        container = "belt",
                        amount = 1,
                        ammo = 128,
                        ammoType = "ammo.pistol",
                        killsrequired = 10,
                        price = 20,
                        attachments = new Dictionary<string, Attachment>
                        {
                            {"weapon.mod.muzzleboost", new Attachment {cost = 5, killsrequired = 5, slot = Slot.attachment1,location = "front", shortname = "weapon.mod.muzzleboost" } },
                            {"weapon.mod.lasersight", new Attachment {cost = 5, killsrequired = 5,  slot = Slot.attachment2,location = "middle", shortname = "weapon.mod.lasersight" } },
                            {"weapon.mod.holosight", new Attachment {cost = 5, killsrequired = 5,  slot = Slot.attachment3,location = "back", shortname = "weapon.mod.holosight" } }
                        } },
                        new Weapon
                        {
                        shortname = "pistol.semiauto",
                        skin = 10087,
                        slot = Slot.secondary,
                        container = "belt",
                        amount = 1,
                        ammo = 128,
                        ammoType = "ammo.pistol",
                        killsrequired = 10,
                        price = 20,
                        attachments = new Dictionary<string, Attachment>
                        {
                            {"weapon.mod.flashlight", new Attachment {cost = 5, killsrequired = 5,  slot = Slot.attachment1,location = "middle", shortname = "weapon.mod.flashlight" } },
                            {"weapon.mod.lasersight", new Attachment {cost = 5, killsrequired = 5,  slot = Slot.attachment2,location = "middle", shortname = "weapon.mod.lasersight" } },
                            {"weapon.mod.silencer", new Attachment {cost = 5, killsrequired = 5, slot = Slot.attachment3,location = "front", shortname = "weapon.mod.silencer" } }
                        } } } } }
        };

        void SaveACPlayer(ACPlayer player)
        {
            if (playerData.players.ContainsKey(player.player.userID))
            {
                if (!playerData.priorSave.ContainsKey(player.player.userID))
                    playerData.priorSave.Add(player.player.userID, playerData.players[player.player.userID]);
            }
            else playerData.players.Add(player.player.userID, new SavedPlayer { });
            var d = playerData.players[player.player.userID];
            d.deaths = player.deaths;
            d.kills = player.kills;
            d.money = player.money;
            d.PlayerGearSets = player.PlayerGearSets;
            d.GearSetKills = player.GearSetKills;
            d.PlayerWeaponSets = player.PlayerWeaponSets;
            d.WeaponSetKills = player.WeaponSetKills;
            d.lastgearSet = player.currentGearSet;
            d.lastweaponSet = player.currentWeaponSet;
            d.lastWeapons = player.CurrentWeapons;
            SaveData();
        }

        void SaveData()
        {
            GWData.WriteObject(gwData);
            PlayerData.WriteObject(playerData);
        }

        void LoadData()
        {
            try
            {
                playerData = PlayerData.ReadObject<SavedPlayers>();
            }
            catch
            {
                Puts("Couldn't load the Absolut Combat Saved Player Data, creating a new datafile");
                playerData = new SavedPlayers();
            }
            try
            {
                gwData = GWData.ReadObject<Gear_Weapon_Data>();
            }
            catch
            {
                Puts("Couldn't load the Absolut Combat Gear and Weapons Data, creating a new datafile");
                gwData = new Gear_Weapon_Data();
            }
            if (gwData.Items == null || gwData.Items.Count() == 0)
                LoadDefaultItemsList();
        }
        void LoadDefaultItemsList()
        {
            gwData.Items = DefaultItems;
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public int InfoInterval { get; set; }
            public int KillReward { get; set; }
            public bool BroadcastDeath { get; set; }
            public bool UseEnviroControl { get; set; }
            public int SetCooldown { get; set; }
            public bool PersistentCondition { get; set; }
            public string MenuKeyBinding { get; set; }
            public bool UseServerRewards { get; set; }
            public bool UseEconomics { get; set; }
            public int DefaultAmmoReloads { get; set; }
            public bool UseAccessories { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                KillReward = 5,
                BroadcastDeath = true,
                UseEnviroControl = true,
                SetCooldown = 10,
                InfoInterval = 15,
                PersistentCondition = true,
                MenuKeyBinding = "p",
                UseServerRewards = false,
                UseEconomics = false,
                DefaultAmmoReloads = 6,
                UseAccessories = true,
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "Absolut Combat: " },
            {"ACInfo", "This server is running Absolut Combat. Press '{0}' to access the Menu. You need kills and money to unlock equipment! Goodluck!"},
            {"purchaseitem", "You have successfully purchased: {0} from the {1} Gear Collection." },
            {"purchaseset", "You have successfully unlocked the {0} Gear Collection" },
            {"purchaseattachment", "You have successfully purchased: {0} for the {1}." },
            {"purchaseweapon", "You have successfully purchased the {0} from the {1} Weapon Collection" },
            {"purchaseweaponset", "You have successfully unlocked the {0} Weapon Collection" },
            {"BuySubMenu", "Collection: {0}" },
            {"CurrentGearKills", "Gear Kills:{0}" },
            {"CurrentWeaponKills", "Weapon Kills:{0}" },
            {"TotalKills", "Total Kills: {0}" },
            {"CurrentlyEquipped", "This is Currently Equipped"},
            {"GearCollection", "Gear Collections" },
            {"WeaponCollection", "Weapon Collections" },
            {"PurchaseInfo", "Are you sure you want to purchase: {0} for ${1}?" },
            {"PurchaseSetInfo", "Are you sure you want to purchase the Collection: {0} for ${1}?" },
            {"DeathMessage", " has killed " },
            {"SelectCollectionItem", "Please Select an Item for this slot.</color>" },
            {"GearSkin", "Please select a Skin for {0}</color>" },
            {"UnlockFree", "Do you want this item to unlock for free when the Collection is purchased?" },
            {"UnlockCollectionFree", "Do you want this Collection to be FREE?" },
            {"INVALIDENTRY", "The given value: {0} is invalid for this input!" },
            {"INVALIDSLOT", "Invalid Slot Provided!" },
            {"Back", "Back" },
            {"Cancel", "Cancel" },
            {"Delete", "Delete" },
            {"ToggleAdminView", "Toggle Admin View" },
            {"Hud1", "Current Weapon Kills: {0}"},
            {"Hud2", "Current Gear Kills: {0}"},
            {"Hud3a", "SR Points: {0}"},
            {"Hud3b", "Money: {0}"},
            {"Hud4", "Current Weapon Collection: {0}"},
            {"Hud5", "Current Gear Collection: {0}"},
            {"Hud6", "Total Kills: {0}"},
            {"GearSetCooldown", "You have changed your Gear Collection to: {0} however you are on cooldown and will not get the equipment until respawn" },
            {"WeaponSetCooldown", "You have changed your Weapon Collection to: {0} however you are on cooldown and will not get the equipment until respawn" },
            {"AddMoney", "You have been given {0} in Absolut Combat Money!" },
            {"MoneyAdded", "{0} has successfully been given {1} in Absolut Combat Money!" },
            {"KillsAdded", "{0} has successfully been given {1} Kills for the {2} Collection." },
            {"KillsTaken", "{1} Kills for the {2} Collection have been taken from {0}." },
            {"KillsAddedOffline", "SteamID {0} has successfully been given {1} Kills for the {2} Collection but the player is currently offline."},
            {"KillsTakenOffline", "{1} Kills for the {2} Collection have been taken from SteamID {0} but the player is currently offline."},
            {"MoneyAddedOffline", "{0} has successfully been given {1} but the player is currently offline."},
            {"NotACPlayer", "The provided User ID does not match an Absolut Combat Player " },
            {"AddMoneyError", "There was an error when trying to give money" },
            {"TakeMoney", "{0} in Absolut Combat Money has been taken from you!" },
            {"MoneyTaken", "{1} in Absolut Combat Money has been taken from {0}!" },
            {"MoneyTakenOffline", "{0} has successfully been taken but the player is currently offline."},
            {"TakeMoneyError", "There was an error when trying to take money" },
            {"AddKillsError", "There was an error adding kills." },
            {"ClearAttachments", "Clear Attachments: {0}" },
            {"NewSet", "You have successfully created Collection: {0}" },
            {"NotAuthorized", "You are not authorized to use this function" },
            {"ArgumentsIncorrect", "You have provided the wrong format. You must specify: {0}. For Example: {1}" },
            {"NoPlayers", "No players found that match {0}" },
            {"MultiplePlayers", "Multiple players found that match {0}" },
            {"NOSR", "ServerRewards is missing. Unloading {0} as it will not work without ServerRewards. Consider setting Use_ServerRewards to false..." },
            {"NOECO","Economics is missing. Unloading {0} as it will not work without Economics. Consider setting Use_Economics to false..." },
            {"BOTHERROR", "Both ServerRewards and Economics are enabled and loaded. This will cause errors so please disable one in the Config." },
            {"PurchaseMenuPlayer", "Purchase Menu               Balance: {0}               Kills: {1}" },
            {"SelectionMenuPlayer", "Selection Menu               Balance: {0}               Kills: {1}" },
            {"EnterAdminView", "You have entered Admin View." },
            {"ExitAdminView", "You have exited Admin View." },
            {"SelectCollection", "Equip Collection: {0}?" },
            {"CostOfGC", "This Gear Collection Requires ${0} & {1} Kills" },
            {"CostOfWC", "This Weapon Collection Requires ${0} & {1} Kills" },
            {"UnlockCollection", "Unlock Collection for ${0} Money?" },
            {"ItemGearCost", "Requires:\n{1} Gear Kills\n& ${0}" },
            {"ItemWeaponCost", "Requires:\n{1} Weapon Kills\n& ${0}" },
            {"Owned", "Owned" },
            {"Unequipped", "Unequipped" },
            {"Equipped", "Equipped" },
            {"GunFull", "Gun Full" },
            {"SelectToEquip", "Select to Equip" },
            {"SelectToUnequip", "Select to Unequip" },
            {"PositionFull", "Slot Unavailable" },
            {"SelectKillsRequired", "Please Select the Kill Requirement to Unlock: {0}" },
            {"SelectPrice", "Please Select the Price to Unlock: {0}" },
            {"CollectionName", "Please provide a name for the new collection. You can also type 'quit' to exit." },
            {"CollectionCost", "Please Select the Price to Unlock this Collection" },
            {"CollectionKills", "Please Select the Kills to Unlock this Collection" },
            {"CreateCollection", "Create New Collection?" },
            {"CancelCollection", "Cancel Collection Creation?" },
            {"SaveCollection", "Save Collection?" },
            {"Free", "FREE" },
            {"NewCollectionCreated", "You have successfully created {0} Collection: {1}" },
            {"ClickToDetail", "Set Item Cost" },
            {"Remove", "X" },
            {"AddKills", "You have been given {0} Kills for the {1} Collection" },
             {"TakeKills", "{0} Kills for the {1} Collection have been taken from you" }
        };
        #endregion
    }
}


// --- End of file: AbsolutCombat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CoverShop.cs ---
// --- Original Local Path: CoverShop.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("CoverShop", "Fipp", "0.0.1")]
    public class CoverShop : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;
        private ConfigData _config;

        class ItemsCover
        {
            [JsonProperty("Shortname предмета")] public string ShortName;
            [JsonProperty("Цена(В Изоленте)")] public int AmountForBuy;
            [JsonProperty("Кол-во")] public int Amount;
        }

        class ConfigData
        {
            [JsonProperty("Шанс выпадение Изоленты из бочек и ящиков(0-100%")]
            public int Chance = 25;

            [JsonProperty("Сколько минимум будет падать Изоленты")]
            public int AmountMin = 10;

            [JsonProperty("Сколько максимум будет падать Изоленты")]
            public int AmountMax = 15;

            [JsonProperty("Товары в магазине")] public List<ItemsCover> ListItems { get; set; }

            public static ConfigData GetNewCong()
            {
                ConfigData newConfig = new ConfigData();

                newConfig.ListItems = new List<ItemsCover>
                {
                    new ItemsCover()
                    {
                        ShortName = "rifle.ak",
                        AmountForBuy = 150,
                        Amount = 1
                    },
                    new ItemsCover()
                    {
                        ShortName = "syringe.medical",
                        AmountForBuy = 250,
                        Amount = 5
                    },
                    new ItemsCover()
                    {
                        ShortName = "metal.fragments",
                        AmountForBuy = 350,
                        Amount = 1500
                    },
                };
                return newConfig;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ConfigData>();

            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => _config = ConfigData.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(_config);

        void OnServerInitialized()
        {
            if (!ImageLibrary)
            {
                PrintWarning("Не найден ImageLibrary! Плагину будет плохо");
            }
        }

        public string Layer = "Layer_ui";


        [ChatCommand("shop")]
        void Shoping(BasePlayer player, string command, string[] args)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            var Panel = container.Add(new CuiPanel
            {
                Image = {Color = "0 0 0 0.8235294"},
                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                CursorEnabled = true,
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = {AnchorMin = "-100 -100", AnchorMax = "100 100", OffsetMax = "0 0"},
                Button = {Color = "0 0 0 0", Close = Layer},
                Text = {Text = ""}
            }, Layer);
            
            container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.001562446 0.9092593", AnchorMax = "0.9953126 0.9851852", OffsetMax = "0 0" },
                    Button = { Color = HexToCuiColor("#FFFFFF00") },
                    Text = { Text = $"МАГАЗИН".ToUpper(), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 30, Color = "1 1 1 0.3870127" }
                }, Layer, Layer + ".Teting");
            
            CuiHelper.AddUi(player, container);
            ResourceFind(player, 1);
        }

        void ResourceFind(BasePlayer player, int page)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Layer + ".Back");
            container.Add(new CuiButton
                {
                    RectTransform =
                        {AnchorMin = "0.002085398 0.4527777", AnchorMax = "0.05104575 0.5462968", OffsetMax = "0 0"},
                    Button = {FadeIn = 0f, Color = HexToCuiColor("#FFFFFF00"), Command = $"CommandCover {page - 1}"},
                    Text =
                    {
                        Text = "<", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                        FontSize = 40, Color = "0.9953126 0.9851852"
                    }
                }, Layer, Layer + ".Back");
            CuiHelper.DestroyUi(player, Layer + ".Run");
            container.Add(new CuiButton
                {
                    RectTransform =
                        {AnchorMin = "0.9494721 0.4527777", AnchorMax = "0.9984304 0.5462968", OffsetMax = "0 0"},
                    Button = {FadeIn = 0f, Color = HexToCuiColor("#FFFFFF00"), Command = $"CommandCover {page + 1}"},
                    Text =
                    {
                        Text = ">", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                        FontSize = 40, Color = "0.9953126 0.9851852"
                    }
                }, Layer, Layer + ".Run");
            for (int i = 0; i < 15; i++)
            {
                CuiHelper.DestroyUi(player, Layer + $".{i}.Img");
                CuiHelper.DestroyUi(player, Layer + $".{i}");
            }
            foreach (var check in _config.ListItems.Select((i, t) => new {A = i, B = t - (page - 1) * 15}).Skip((page - 1) * 15).Take(15))
            {
                container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin =
                                $"{0.08593751 + check.B * 0.175 - Math.Floor((double) check.B / 5) * 5 * 0.175} {0.7333337 - Math.Floor((double) check.B / 5) * 0.30}",
                            AnchorMax =
                                $"{0.1880209 + check.B * 0.175 - Math.Floor((double) check.B / 5) * 5 * 0.175} {0.9064818 - Math.Floor((double) check.B / 5) * 0.30}",
                            OffsetMax = "0 0"
                        },
                        Button =
                        {
                            Color = HexToCuiColor("#FFFFFF00"),
                            Command = $"CommandCover buy {check.A.ShortName}"
                        },
                        Text =
                        {
                            Text = $"x{check.A.Amount}", Align = TextAnchor.LowerRight, Font = "robotocondensed-bold.ttf", FontSize = 15
                        }
                    }, Layer, Layer + $".{check.B}");
                
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}",
                    Name = Layer + $".{check.B}.Img",
                    Components =
                    {
                        new CuiRawImageComponent
                            {FadeIn = 0.3f, Png = (string) ImageLibrary.Call("GetImage",  check.A.ShortName)},
                        new CuiRectTransformComponent
                            {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 1", OffsetMax = "-5 -1"}
                    }
                });
                
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}",
                    Name = Layer + $".{check.B}.Txt",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{check.A.AmountForBuy} Изоленты", Align = TextAnchor.UpperLeft,
                            Font = "robotocondensed-bold.ttf", FontSize = 15, Color = "1 1 1 0.6"
                        },
                        new CuiRectTransformComponent
                            {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 1", OffsetMax = "-5 -1"}
                    }
                });
            }
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("CommandCover")]
        void CoverConsole(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();

            if (player != null && args.HasArgs(1))
            {
                int page = 1;
                if (int.TryParse(args.Args[0], out page) && page > 0 && (page - 1) * 15 <= _config.ListItems.Count)
                {
                    ResourceFind(player, page);
                }
                else if (args.Args[0] == "buy")
                    {
                        if (args.HasArgs(2))
                        {
                            var items = _config.ListItems.FirstOrDefault(p => p.ShortName == args.Args[1]);
                            if (items != null)
                            {
                                var amountget = player.inventory.GetAmount(ItemManager.FindItemDefinition("ducttape").itemid);
                                if (amountget < items.AmountForBuy)
                                {
                                    SendReply(player, "У вас недостаточно Изоленты для покупки");
                                    return;
                                }
                                var item = ItemManager.CreateByName(items.ShortName, items.Amount);
                                player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                                player.inventory.Take(null, ItemManager.FindItemDefinition("ducttape").itemid, items.AmountForBuy);
                                SendReply(player, $"Вы успешно купили {ItemManager.FindItemDefinition($"{items.ShortName}").displayName.english}");
                            }
                        }
                    }
            }
        }
        
        private List<StorageContainer> handledContainers = new List<StorageContainer>();
        
        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container == null || player == null) return null;
            if (handledContainers.Contains(container)) return null;
            handledContainers.Add(container);

            if (Random.Range(0, 100) < _config.Chance)
            {
                if (container.inventory.itemList.Count == container.inventory.capacity)
                {
                    container.inventory.capacity++;
                }
                var item = ItemManager.CreateByName("ducttape", Random.Range(_config.AmountMin, _config.AmountMax), 1748707346);
                item.name = "Изолент";
                item.MoveToContainer(container.inventory);
            }
            return null;
        }
        private Item OnItemSplit(Item item, int amount)
        {
            if (item.info.shortname == "ducttape" && item.skin == 1748707346)
            {
                item.amount = item.amount - amount;
                Item splitAmount1 = ItemManager.CreateByItemID(item.info.itemid, amount, item.skin);
                splitAmount1.name = "Изолент";
                splitAmount1.MarkDirty();
                item.MarkDirty();
                return splitAmount1;
            }
            return null;
        }
        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        
        [ConsoleCommand("givecover")]
        void GiveCommands(ConsoleSystem.Arg args)
        {
            if (args.Player() == null) return;
            BasePlayer player = args.Player();
            if (!player.IsAdmin) return;
            if (args.Args[0] == null) return;
            int amount;
            if (!int.TryParse(args.Args[0], out amount))
            {
                SendReply(player, "Вы не указали кол-во Изолент");
                return;
            }
            var item = ItemManager.CreateByName("ducttape", amount, 1748707346);
            item.name = "Изолент";
            player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            SendReply(player, $"Вы успешно выдали {amount} Изолент");
        }
    }
}

// --- End of file: CoverShop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Flaska.cs ---
// --- Original Local Path: Flaska.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Flaska", "TopPlugin.ru", "1.0.0")]
    class Flaska : RustPlugin
    {
        #region Хуки
        void OnServerInitialized()
        {
            MutationRegistered();
        }

        object OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item) => OnDispenserGather(dispenser, entity, item);
        object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            UseTools(player, item);
            return null;
        }
        #endregion

        #region Команда
        [ConsoleCommand("flask_give")]
        void UraniumToolGive(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && !player.IsAdmin) return;
            BasePlayer target = BasePlayer.Find(args.Args[0]);
            CreateItem(target);
        }
        #endregion

        #region Mutations
        Dictionary<ItemDefinition, ItemDefinition> Transmutations;
        List<string> MutationItemList = new List<string>
        {
            "chicken.raw",
            "humanmeat.raw",
            "bearmeat",
            "deermeat.raw",
            "meat.boar",
            "wolfmeat.raw",
            "hq.metal.ore",
            "metal.ore",
            "sulfur.ore"
        };

        void MutationRegistered()
        {
            Transmutations = ItemManager.GetItemDefinitions().Where(p => MutationItemList.Contains(p.shortname)).ToDictionary(p => p, p => p.GetComponent<ItemModCookable>()?.becomeOnCooked);
            ItemDefinition wood = ItemManager.FindItemDefinition(-151838493);
            ItemDefinition charcoal = ItemManager.FindItemDefinition(-1938052175);
            Transmutations.Add(wood, charcoal);
        }
        #endregion

        #region Методы
        void UseTools(BasePlayer player, Item item)
        {
            foreach (var check in player.inventory.containerWear.itemList)
            {
                if (check.skin == 1552162306)
                {
                    if (Transmutations.ContainsKey(item.info))
                        item.info = Transmutations[item.info];
                }
            }
        }

        void CreateItem(BasePlayer player)
        {
            Item item = ItemManager.CreateByName("tactical.gloves", 1, 1552162306);
            item.name = "Волшебная фласка";
            player.GiveItem(item);
        }
        #endregion
    }
}

// --- End of file: Flaska.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UpLifted.cs ---
// --- Original Local Path: UpLifted.cs ---

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Configuration;
using UnityEngine;
using Network;
using Facepunch;
using Facepunch.Extend;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("UpLifted", "FuJiCuRa", "1.2.13", ResourceId = 110)]
    internal class UpLifted : RustPlugin
    {
        [PluginReference] private Plugin Clans, Friends;
        private static UpLifted UpL;
        private bool initialized;
        private bool Changed;
        private bool hasFullyLoaded;
        private double lastHour;
        private static bool isDayTime;
        private int versionMajor;
        private int versionMinor;
        private bool _newConfig = false;
        private static Dictionary<string, bool> adminAccessEnabled = new Dictionary<string, bool>();
        private static Dictionary<string, bool> adminLiftEntkill = new Dictionary<string, bool>();
        private static Dictionary<uint, Elevator> crossReference;
        private Dictionary<ulong, Elevator> playerStartups;
        private List<string> permissionGroups = new List<string>();
        private List<ConsoleSystem.Command> aclVars;
        private static WaitForFixedUpdate waitFFU = new WaitForFixedUpdate();
        private static WaitForEndOfFrame waitFOF = new WaitForEndOfFrame();
        private static string cabinControlUI = "CabinControlUI";
        private static string cabinDestroyUI = "CabinDestroyUI";
        private static string cabinSettingsUI = "CabinSettingsUI";
        private static string cabinPlacementUI = "CabinPlacementUI";
        private static string cabinSharingUI = "CabinSharingUI";

        private Dictionary<string, object> permissionBlock = new Dictionary<string, object>();

        private Dictionary<string, object> playerPermissionMatrix = new Dictionary<string, object>
        {
            {"MaxLiftPerUser", new object[] {-1, 1, 2, "The number of lifts a player can create"}},
            {"MaxMoveSpeed", new object[] {5, 1, 3, "The maximum speed being available to choose"}},
            {"MaxPlacementFloor", new object[] {-1, 2, 3, "The last floor a player can place a lift on"}},
            {"MaxFloorRange", new object[] {15, 3, 7, "The from-to-range a player can place a lift"}},
            {"MaxFloorLevel", new object[] {-1, 5, 10, "The last floor a player can place a lift to"}},
            {"FuelConsumePerFloor", new object[] {1, 5, 3, "The amount of consumed fuel per moved floor"}},
            {"FuelStorageItemSlots", new object[] {6, 1, 3, "The available slots for the central fuel storage"}},
            {"FuelStorageStackSize", new object[] {0, 500, 1000, "The stacksize limit for the central fuel storage"}},
            {
                "DoorSkin",
                new object[] {1276338615uL, 1276338615uL, 1276338615uL, "The default skin for new placements"}
            },
            {"BuildCostMultiplier", new object[] {1.0f, 2.0f, 1.5f, "The buildcost multiplier for build and remove"}},
            {"EnableBuildCost", new object[] {false, true, true, "Enable or disable buildcosts for a player"}},
            {"EnableFuelUsage", new object[] {false, true, true, "Enable or disable fuel usage for a player"}},
            {"CanCreate", new object[] {true, false, true, "Needed option to allow the placement of lifts"}},
            {"CanReskin", new object[] {true, false, true, "Needed option to allow door reskinning"}},
            {"CanPlaceOnFloor", new object[] {true, false, false, "Needed option to place on floors also"}},
            {"AccessVipShare", new object[] {true, false, false, "Needed option to allow access to VIP shares"}},
            {"BaseComfort", new object[] {100, 0, 25, "The cabin's enabled comfort level from 0 to 100"}},
            {"BaseTemperature", new object[] {34, 0, 17, "The cabin's enabled temperature level from 34 to 0"}},
        };

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string, object> data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        protected override void LoadDefaultConfig()
        {
            _newConfig = true;
            Config.Clear();
            LoadVariables();
        }

        private string msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {
                        "Couldn't use the RemoverTool on a Lift installation",
                        "Couldn't use the RemoverTool on a Lift installation"
                    },
                    {
                        "Couldn't add a home inside a Lift installation",
                        "Couldn't add a home inside a Lift installation"
                    },
                    {"Entkill disabled for Lifts. Toggle this by: ", "Entkill disabled for Lifts. Toggle this by: "},
                    {
                        "No build or place access inside a Lift installation",
                        "No build or place access inside a Lift installation"
                    },
                    {"You are not permitted for this command", "You are not permitted for this command"},
                    {"You are building blocked on that position", "You are building blocked on that position"},
                    {"You cannot place on deployed objects", "You cannot place on deployed objects"},
                    {"You do not own this foundation", "You do not own this foundation"},
                    {"You cannot place anymore on this level", "You cannot place anymore on this level"},
                    {"You reached your placement limit!", "You reached your placement limit!"},
                    {
                        "The foundation needs to be at least of grade Stone",
                        "The foundation needs to be at least of grade Stone"
                    },
                    {
                        "You cannot build under the terrain/caves/cliffs",
                        "You cannot build under the terrain/caves/cliffs"
                    },
                    {"Too close by another installed lift", "Too close by another installed lift"},
                    {"You can place on foundations only", "You can place on foundations only"},
                    {"Choose the planned Lift size", "Choose the planned Lift size"},
                    {"Choose where to pre-place doors", "Choose where to pre-place doors"},
                    {"You reached your placement limit", "You reached your placement limit"},
                    {"Lift admin access enabled", "Lift admin access enabled"},
                    {"Lift admin access disabled", "Lift admin access disabled"},
                    {"Lift admin entkill enabled", "Lift admin entkill enabled"},
                    {"Lift admin entkill disabled", "Lift admin entkill disabled"},
                    {"This lift was sucessfully reset", "This lift was sucessfully reset"},
                    {"Nothing valid to reset was found", "Nothing valid to reset was found"},
                    {
                        "The new lift failed for some reason. Please try from a lower floor",
                        "The new lift failed for some reason. Please try from a lower floor"
                    },
                    {"Do Placement", "Do Placement"}, {"Do Place (Upward Overwrite)", "Do Place (Upward Overwrite)"},
                    {"Cancel Action", "Cancel Action"}, {"Cancel", "Cancel"}, {"Tear down\nLift", "Tear down\nLift"},
                    {"Full Remove", "Full Remove"}, {"Keep Building", "Keep Building"},
                    {"Operating\nPanel", "Operating\nPanel"}, {"Lighting", "Lighting"}, {"Move Speed", "Move Speed"},
                    {"Floor OnHold", "Floor OnHold"}, {"Idle Close", "Idle Close"}, {"Power State", "Power State"},
                    {"Clan Share", "Clan Share"}, {"FriendShare", "FriendShare"}, {"Door Skin", "Door Skin"},
                    {"Update", "Update"}, {"Bad", "Bad"}, {"Good", "Good"}, {"FoC", "FoC"}, {"Door", "Door"},
                    {"Floor", "Floor"}, {"Current", "Current"}, {"Static", "Static"}, {"Share Mode", "Share Mode"},
                    {"Floor Sharing\nOptions", "Floor Sharing\nOptions"}, {"Switch\nAll Floors", "Switch\nAll Floors"},
                    {"Reset\nAll Floors", "Reset\nAll Floors"}, {"Settings\nPanel", "Settings\nPanel"},
                    {"PowerState.Internal", "Internal"}, {"PowerState.TC", "TC"}, {"PowerState.FoC", "FoC"},
                    {"CabinLightMode.Dynamic", "Dynamic"}, {"CabinLightMode.AlwaysOn", "AlwaysOn"},
                    {"CabinLightMode.Disabled", "Disabled"}, {"ShareMode.None", "None"}, {"ShareMode.Clan", "Clan"},
                    {"ShareMode.Friends", "Friends"}, {"ShareMode.Full", "Full"}, {"ShareMode.Public", "Public"},
                    {"FloorShare.Public", "Public"}, {"FloorShare.Full", "Full"}, {"FloorShare.Friends", "Friends"},
                    {"FloorShare.Clan", "Clan"}, {"FloorShare.Excluded", "Excluded"}, {"FloorShare.Hidden", "Hidden"},
                    {"FloorShare.HiddenVIP", "HiddenVIP"},
                }, this);
        }

        private bool loadOverrideCorrupted;
        private string createChatCommand;
        private string helpChatCommand;
        private string pluginPrefix;
        private string prefixColor;
        private string prefixFormat;
        private static int buildingGrade = 3;
        private static string knockEffectGuid;
        private int lastStableFloor;
        private static bool enableClanShare;
        private static bool enableFriendShare;
        private static bool clansEnabled;
        private static bool friendsEnabled;
        private bool sharingPlugins;
        private bool enableEntIdKillProtection;
        private bool enableRemoverToolProtection;
        private bool enableSetHomeDeny;
        private static bool isGroundBlockVulnerable;
        private static bool doorDestructionKillsLiftCabin;
        private static bool sleepWatchEnabled;
        private static float sleepWatchDelay;
        private static float sleepWatchInterval;
        private static bool sleepWatchMoveDown;
        private static bool preventPlacementInCaves;
        private static bool preventPlacementAboveDeployables;
        private bool admAccessSwitchable;
        private bool admSwitchEnabledAtLogin;
        private string admAccessToggleCmd;
        private int admAccessAuthLevel;
        private string admAccessPermission;
        private List<object> admPseudoPerms = new List<object>();
        private List<string> pseudoPerms = new List<string>();

        private void LoadVariables()
        {
            versionMinor = Convert.ToInt32(GetConfig("Debug", "VersionMinor", -1));
            if (!_newConfig && versionMinor < 1)
            {
                Config.Save(Manager.ConfigPath + string.Format("\\{0}_OLD.json", Name));
                PrintWarning("Created a copy of the old config");
                Config.Clear();
                Config["Debug", "VersionMinor"] = Version.Minor;
                Config["Debug", "VersionMajor"] = Version.Major;
                Changed = true;
            }

            if (versionMinor == -1)
            {
                Config["Debug", "VersionMinor"] = Version.Minor;
                Changed = true;
            }

            versionMajor = Convert.ToInt32(GetConfig("Debug", "VersionMajor", Version.Major));
            versionMinor = Convert.ToInt32(GetConfig("Debug", "VersionMinor", Version.Minor));
            loadOverrideCorrupted = Convert.ToBoolean(GetConfig("Debug", "LoadOverrideCorrupted", false));
            permissionBlock =
                (Dictionary<string, object>) GetConfig("Permission", "AccessControl", new Dictionary<string, object>());
            createChatCommand = Convert.ToString(GetConfig("Commands", "Start lift creation", "newlift"));
            helpChatCommand = Convert.ToString(GetConfig("Commands", "Reset lift movement", "liftaid"));
            pluginPrefix = Convert.ToString(GetConfig("Formatting", "PluginPrefix", "Up·Lift·ed"));
            prefixColor = Convert.ToString(GetConfig("Formatting", "PrefixColor", "#468499"));
            prefixFormat = Convert.ToString(GetConfig("Formatting", "PrefixFormat", "<color={0}>{1}</color>: "));
            enableEntIdKillProtection = Convert.ToBoolean(GetConfig("HealthCare", "EnableEntIdKillProtection", true));
            enableRemoverToolProtection =
                Convert.ToBoolean(GetConfig("HealthCare", "EnableRemoverToolProtection", true));
            enableSetHomeDeny = Convert.ToBoolean(GetConfig("HealthCare", "EnableSetHomeDeny", true));
            isGroundBlockVulnerable = Convert.ToBoolean(GetConfig("HealthCare", "IsGroundBlockVulnerable", true));
            doorDestructionKillsLiftCabin =
                Convert.ToBoolean(GetConfig("HealthCare", "DoorDestructionKillsLiftCabin", true));
            lastStableFloor = Convert.ToInt32(GetConfig("HealthCare", "LastStableFloor", 18));
            enableClanShare = Convert.ToBoolean(GetConfig("Support", "EnableClanSharing", true));
            enableFriendShare = Convert.ToBoolean(GetConfig("Support", "EnableFriendSharing", true));
            sleepWatchEnabled = Convert.ToBoolean(GetConfig("AbuseControl", "SleepWatchEnabled", true));
            sleepWatchDelay = Convert.ToSingle(GetConfig("AbuseControl", "SleepWatchDelay", 180));
            sleepWatchInterval = Convert.ToSingle(GetConfig("AbuseControl", "SleepWatchInterval", 60));
            sleepWatchMoveDown = Convert.ToBoolean(GetConfig("AbuseControl", "SleepWatchMoveDown", true));
            preventPlacementInCaves = Convert.ToBoolean(GetConfig("AbuseControl", "PreventPlacementInCaves", true));
            preventPlacementAboveDeployables =
                Convert.ToBoolean(GetConfig("AbuseControl", "PreventPlacementAboveDeployables", true));
            admAccessSwitchable = Convert.ToBoolean(GetConfig("Administrative", "AdmAccessSwitchable", true));
            admSwitchEnabledAtLogin = Convert.ToBoolean(GetConfig("Administrative", "AdmSwitchEnabledAtLogin", false));
            admAccessToggleCmd = Convert.ToString(GetConfig("Administrative", "AdmAccessToggleCmd", "liftadmin"));
            admAccessAuthLevel = Convert.ToInt32(GetConfig("Administrative", "AdmAccessAuthLevel", 2));
            admAccessPermission = Convert.ToString(GetConfig("Administrative", "AdmAccessPermission", "admaccess"));
            admPseudoPerms = (List<object>) GetConfig("Administrative", "AdmPseudoPerms",
                new List<object> {"fauxadm.allowed", "fakeadmin.allow"});
            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        private void Init()
        {
            LoadVariables();
            LoadDefaultMessages();
            permission.RegisterPermission(Title + "." + admAccessPermission, this);
            cmd.AddChatCommand(createChatCommand, this, "chatCmdTowerLift");
            cmd.AddChatCommand(helpChatCommand, this, "chatCmdLiftReset");
            cmd.AddChatCommand(admAccessToggleCmd, this, "chatCmdToggleAdm");
            cmd.AddConsoleCommand("upl." + admAccessToggleCmd, this, "cmdToggleAdm");
            cmd.AddChatCommand("liftowner", this, "chatCmdLiftOwner");
            UpL = this;
            hasFullyLoaded = false;
            aclVars = new List<ConsoleSystem.Command>();
        }

        private void Unload()
        {
            SaveData(true);
            if (Interface.Oxide.IsShuttingDown) return;
            foreach (ConsoleSystem.Command cmd in aclVars.ToList())
                ConsoleSystem.Index.Server.Dict.Remove(cmd.FullName?.ToLower());
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList()) LiftUI.DestroyAllUi(player);
            List<Elevator> objs1 = UnityEngine.Object.FindObjectsOfType<Elevator>().ToList();
            foreach (Elevator obj in objs1)
            {
                obj.enabled = false;
                UnityEngine.Object.Destroy(obj);
            } /*var objs3 = UnityEngine.Object.FindObjectsOfType<Prevent_Building>().ToList(); foreach (var obj in objs3) GameObject.Destroy(obj);*/

            List<CabinComfort> objs4 = UnityEngine.Object.FindObjectsOfType<CabinComfort>().ToList();
            foreach (CabinComfort obj in objs4) UnityEngine.Object.Destroy(obj);
        }

        private void OnPluginLoaded(Plugin name)
        {
            if (!initialized || name.Name == Title) return;
            if (name.Name == "Clans" && enableClanShare) clansEnabled = true;
            if (name.Name == "Friends" && enableFriendShare) friendsEnabled = true;
            if (clansEnabled || friendsEnabled) sharingPlugins = true;
        }

        private void OnPluginUnloaded(Plugin name)
        {
            if (!initialized || name.Name == Title) return;
            if (name.Name == "Clans") clansEnabled = false;
            if (name.Name == "Friends") friendsEnabled = false;
            if (!clansEnabled && !friendsEnabled) sharingPlugins = false;
        }

        private void OnServerInitialized()
        {
            CreateAcl();
            CreateOverview();
            crossReference = new Dictionary<uint, Elevator>();
            playerStartups = new Dictionary<ulong, Elevator>();
            foreach (string pseudoPerm in admPseudoPerms.ConvertAll(obj => Convert.ToString(obj)).ToList())
                if (permission.PermissionExists(pseudoPerm))
                    pseudoPerms.Add(pseudoPerm.ToLower());
            adminLiftEntkill = new Dictionary<string, bool>();
            adminAccessEnabled = new Dictionary<string, bool>();
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList()) SetPlayer(player);
            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList()) SetPlayer(player);
            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime + 1.5 &&
                TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunsetTime - 1.5) isDayTime = true;
            else isDayTime = false;
            lastHour = -1d;
            if (Clans && enableClanShare) clansEnabled = true;
            if (Friends && enableFriendShare) friendsEnabled = true;
            initialized = true;
            DynamicConfigFile _file = new DynamicConfigFile(Title);
            _file.Settings = new JsonSerializerSettings() {ReferenceLoopHandling = ReferenceLoopHandling.Ignore};
            Dictionary<uint, object> fromJson =
                Interface.Oxide.DataFileSystem.ReadObject<Dictionary<uint, object>>(Title) ??
                new Dictionary<uint, object>();
            int ct1 = 0;
            int ct2 = 0;
            foreach (KeyValuePair<uint, object> storedElev in fromJson)
            {
                ct1++;
                BaseNetworkable ent = BaseNetworkable.serverEntities.Find(storedElev.Key);
                if (ent == null) continue;
                Elevator elev = (ent as ProceduralLift).gameObject.AddComponent<Elevator>();
                try
                {
                    if (elev.Ld2Prt(ent as ProceduralLift,
                        JsonConvert.DeserializeObject<ELStorage>((string) storedElev.Value))) ct2++;
                }
                catch (Exception ex)
                {
                    if (!loadOverrideCorrupted)
                    {
                        PrintWarning("Loading problem detected at:" + ex.ToString());
                        PrintWarning("Plugin HALTED to protect the datafile. Contact the Developer");
                        Interface.Oxide.UnloadPlugin(UpL.Title);
                        return;
                    }

                    PrintWarning($"Failed loading of lift at '{ent.transform.position.ToString()} ");
                }
            }

            Puts($"Loaded \'{ct2} of {ct1}\' Lifts from disk");
            hasFullyLoaded = true;
            if (!enableEntIdKillProtection) Unsubscribe(nameof(OnServerCommand));
            if (!enableSetHomeDeny) Unsubscribe(nameof(OnPlayerCommand));
            if (!enableRemoverToolProtection) Unsubscribe(nameof(canRemove));
        }

        private object OnEntityStabilityCheck(StabilityEntity stabilityEntity)
        {
            if (stabilityEntity.GetComponentInParent<ProceduralLift>())
            {
                return false;
            }
            return null;
        }

        private void SaveData(bool isUnload = false)
        {
            if (!hasFullyLoaded)
            {
                PrintWarning("Lifts not saved to file due to before loading issue!");
                return;
            }

            DynamicConfigFile _file = new DynamicConfigFile(Title);
            _file.Settings = new JsonSerializerSettings() {ReferenceLoopHandling = ReferenceLoopHandling.Ignore};
            Dictionary<uint, object> toJson = new Dictionary<uint, object>();
            int ct1 = 0;
            int ct2 = 0;
            foreach (Elevator mapElevator in UnityEngine.Object.FindObjectsOfType<Elevator>().ToList())
            {
                if (mapElevator.lift == null) continue;
                ct1++;
                if (mapElevator.IsReady)
                {
                    ct2++;
                    bool success = false;
                    ELStorage data = mapElevator.Sv2Prt(out success, isUnload);
                    if (success) toJson.Add(mapElevator.lift.net.ID, JsonConvert.SerializeObject(data));
                    else PrintWarning("Excluded damaged entry from being saved");
                }
            }

            Interface.Oxide.DataFileSystem.WriteObject(Title, toJson);
            Puts($"Saved \'{ct2} of {ct1}\' Lifts to disk");
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private static bool HasFriendS(string owner, string friend)
        {
            if (enableFriendShare && UpL.Friends)
                return UpL.Friends.Call("HasFriendS", owner, friend) != null &&
                       (bool) UpL.Friends.CallHook("HasFriendS", owner, friend);
            return false;
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player != null) SetPlayer(player);
        }

        private void SetPlayer(BasePlayer player)
        {
            if (player.Connection != null && player.net.connection.authLevel >= admAccessAuthLevel ||
                IsPseudoAdmin(player.UserIDString) ||
                permission.UserHasPermission(player.UserIDString, admAccessPermission))
            {
                adminAccessEnabled[player.UserIDString] = admAccessSwitchable ? admSwitchEnabledAtLogin : true;
                adminLiftEntkill[player.UserIDString] = false;
            }
        }

        private static bool SameClanS(string owner, string member)
        {
            if (enableClanShare && UpL.Clans)
            {
                object o = UpL.Clans.Call("GetClanOf", owner);
                object m = UpL.Clans.Call("GetClanOf", member);
                return o != null && m != null && (string) o == (string) m;
            }

            return false;
        }

        private static bool ClanCheck(string owner, string oldTag, out string newTag)
        {
            newTag = default(string);
            if (clansEnabled)
            {
                object tag = UpL.Clans.Call("GetClanOf", owner);
                if (tag != null) newTag = (string) tag;
                if (newTag != oldTag && oldTag != "") return true;
            }

            return false;
        }

        private bool CrtPrcdrlLft(BasePlayer player, BaseEntity baseEntity, out ProceduralLift l, out int offset)
        {
            l = default(ProceduralLift);
            offset = default(int);
            float angle = 360f - Vector3.SignedAngle(player.transform.position - baseEntity.transform.position,
                              baseEntity.transform.forward, Vector3.up) - 180f;
            int offsetDown = Mathf.FloorToInt(angle / 45);
            bool isEven = offsetDown % 2 == 0;
            Vector3 liftPosition = baseEntity.transform.position + new Vector3(0, 3.60f, 0);
            ProceduralLift liftEntity = (ProceduralLift) GameManager.server.CreateEntity(StringPool.Get(2518050576),
                liftPosition, Quaternion.Euler(0, baseEntity.transform.eulerAngles.y, 0), true);
            if (liftEntity == null) return false;
            liftEntity.transform.localRotation *= Quaternion.Euler(0, (isEven ? offsetDown : offsetDown + 1) * 45, 0);
            liftEntity.OwnerID = player.userID;
            l = liftEntity;
            offset = -1;
            if (offsetDown == 7 || offsetDown == 0) offset = 1;
            else if (offsetDown == 1 || offsetDown == 2) offset = 2;
            else if (offsetDown == 3 || offsetDown == 4) offset = 3;
            else if (offsetDown == 5 || offsetDown == 6) offset = 4;
            return true;
        }

        private void chatCmdLiftOwner(BasePlayer player, string command, string[] args)
        {
            bool value = false;
            if (!adminAccessEnabled.TryGetValue(player.UserIDString, out value)) return;
            if (args == null || args.Length < 1) return;
            IPlayer newOwner = covalence.Players.FindPlayer(args[0]);
            if (newOwner == null) return;
            Ray ray = player.eyes.BodyRay();
            RaycastHit raycastHit;
            if (!Physics.Raycast(ray, out raycastHit, 10f, 2097153)) return;
            BaseEntity baseEntity = raycastHit.GetEntity();
            if (!baseEntity) return;
            Elevator obj;
            if (crossReference.TryGetValue(baseEntity.net.ID, out obj) && obj != null)
            {
                obj.SetOwner(Convert.ToUInt64(newOwner.Id));
                player.ChatMessage($"Changed lift ownership to {newOwner.Name}");
                return;
            }
        }

        private void chatCmdToggleAdm(BasePlayer player, string command, string[] args)
        {
            bool value = false;
            if (!adminAccessEnabled.TryGetValue(player.UserIDString, out value))
            {
                if (admAccessSwitchable)
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("You are not permitted for this command"));
                return;
            }

            bool value2 = adminLiftEntkill[player.UserIDString];
            bool value3 = value2;
            if (!value && args.Length > 0 && args[0].ToLower() == "kill") return;
            if (value && args.Length > 0 && args[0].ToLower() == "kill")
            {
                value3 = adminLiftEntkill[player.UserIDString];
                value3 = !value3;
                adminLiftEntkill[player.UserIDString] = value3;
                if (value3)
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("Lift admin entkill enabled"));
                else
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("Lift admin entkill disabled"));
            }
            else if (admAccessSwitchable)
            {
                value = !value;
                adminAccessEnabled[player.UserIDString] = value;
                if (value)
                {
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("Lift admin access enabled"));
                }
                else
                {
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("Lift admin access disabled"));
                    adminLiftEntkill[player.UserIDString] = false;
                }
            }
        }

        private void cmdToggleAdm(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Connection != null && arg.Connection.player != null)
                chatCmdToggleAdm((BasePlayer) arg.Connection.player, admAccessToggleCmd,
                    arg.Args != null ? arg.Args : new string[] { });
        }

        private void chatCmdLiftReset(BasePlayer player, string command, string[] args)
        {
            Ray ray = player.eyes.BodyRay();
            RaycastHit raycastHit;
            if (!Physics.Raycast(ray, out raycastHit, 10f, 2097153)) return;
            BaseEntity baseEntity = raycastHit.GetEntity();
            if (!baseEntity)
            {
                player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                   msg("Nothing valid to reset was found"));
                return;
            }

            Elevator obj;
            if (crossReference.TryGetValue(baseEntity.net.ID, out obj) && obj != null)
            {
                if (obj.IsOwner(player) || IsAdm(player)) obj.RstMvmnt(player);
                return;
            }
            else
            {
                player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                   msg("Nothing valid to reset was found"));
            }
        }

        private Vector3 GtGrndBldng(Vector3 sourcePos)
        {
            sourcePos.y = TerrainMeta.HeightMap.GetHeight(sourcePos);
            RaycastHit hitinfo;
            if (Physics.Raycast(sourcePos, Vector3.down, out hitinfo, 2097152))
            {
                sourcePos.y = Math.Max(hitinfo.point.y, sourcePos.y);
                return sourcePos;
            }

            if (Physics.Raycast(sourcePos, Vector3.up, out hitinfo, 2097152))
                sourcePos.y = Math.Max(hitinfo.point.y, sourcePos.y);
            return sourcePos;
        }

        private void chatCmdTowerLift(BasePlayer player, string command, string[] args)
        {
            if (!(bool) GetAccess("CanCreate", player.UserIDString, false))
            {
                player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                   msg("You are not permitted for this command"));
                return;
            }

            Ray ray = player.eyes.BodyRay();
            RaycastHit raycastHit;
            if (!Physics.Raycast(ray, out raycastHit, 10f, 2097152)) return;
            BaseEntity baseEntity = raycastHit.GetEntity();
            if (!baseEntity || !(baseEntity is BuildingBlock)) return;
            bool canPlaceFloor = (bool) GetAccess("CanPlaceOnFloor", player.UserIDString, false);
            if (!canPlaceFloor && baseEntity.ShortPrefabName != "foundation")
            {
                player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                   msg("You can place on foundations only"));
                return;
            }

            if (baseEntity.ShortPrefabName == "foundation" || canPlaceFloor && baseEntity.ShortPrefabName == "floor")
            {
                if (preventPlacementInCaves)
                {
                    RaycastHit hit;
                    if (Physics.Raycast(baseEntity.transform.position + Vector3.up, Vector3.up, out hit, 100f,
                            8454144) && !IsAdm(player))
                    {
                        player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                           msg("You cannot build under the terrain/caves/cliffs"));
                        return;
                    }
                }

                OBB obb = baseEntity.WorldSpaceBounds();
                if (player.IsBuildingBlocked(obb) && !IsAdm(player))
                {
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("You are building blocked on that position"));
                    return;
                }

                if (preventPlacementAboveDeployables)
                    if (Physics.CheckBox(obb.position + Vector3.up * 3, obb.extents, obb.rotation, 256,
                            QueryTriggerInteraction.Ignore) && !IsAdm(player))
                    {
                        player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                           msg("You cannot place on deployed objects"));
                        return;
                    }

                if (baseEntity.OwnerID != player.userID && !IsAdm(player))
                {
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("You do not own this foundation"));
                    return;
                }

                if ((int) (baseEntity as BuildingBlock).grade < 2 && !IsAdm(player))
                {
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("The foundation needs to be at least of grade Stone"));
                    return;
                }

                int startLevel = 1;
                if (canPlaceFloor && baseEntity.ShortPrefabName == "floor")
                {
                    Vector3 sourcePos = baseEntity.transform.position;
                    Vector3 groundPos = GtGrndBldng(sourcePos);
                    startLevel = Mathf.CeilToInt((sourcePos.y - groundPos.y) / 3f);
                }

                int maxPlace = (int) GetAccess("MaxPlacementFloor", player.UserIDString, 1, true);
                int maxLevel = (int) GetAccess("MaxFloorLevel", player.UserIDString, 1, true);
                int maxRange = lastStableFloor + 1 - startLevel;
                if (maxPlace != -1 && startLevel > maxPlace || maxLevel != -1 && maxLevel - startLevel < 1 ||
                    maxRange < 2)
                {
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("You cannot place anymore on this level"));
                    return;
                }

                List<Collider> list = Pool.GetList<Collider>();
                Vis.Colliders<Collider>(baseEntity.transform.TransformPoint(Vector3.zero), 4f, list, 536870912,
                    QueryTriggerInteraction.Collide);
                foreach (Collider current in list)
                    if (!(current.transform.root == baseEntity.gameObject.transform.root))
                    {
                        BaseEntity baseEntity2 = current.gameObject.ToBaseEntity();
                        Elevator obj;
                        if (baseEntity2 && crossReference.TryGetValue(baseEntity2.net.ID, out obj) && obj != null &&
                            !IsAdm(player))
                        {
                            player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                               msg("Too close by another installed lift"));
                            Pool.FreeList<Collider>(ref list);
                            return;
                        }
                    }

                Pool.FreeList<Collider>(ref list);
                int count = 0;
                if (crossReference.Count > 0)
                    count = (int) crossReference.Where(a =>
                            a.Value != null && a.Value.GetOwner == player.userID && a.Key == a.Value.liftID).ToList()
                        .Count();
                int limit = (int) GetAccess("MaxLiftPerUser", player.UserIDString, 1, true);
                if (limit > 0 && count >= limit && !IsAdm(player))
                {
                    player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                       msg("You reached your placement limit"));
                    return;
                }

                int offsetDown;
                ProceduralLift procLift;
                Elevator elev;
                if (CrtPrcdrlLft(player, baseEntity, out procLift, out offsetDown))
                {
                    baseEntity.RefreshEntityLinks();
                    elev = procLift.gameObject.AddComponent<Elevator>();
                    playerStartups[player.userID] = elev;
                    playerStartups[player.userID].controlUI = new LiftUI();
                    playerStartups[player.userID].controlUI.IntPlcmnt(elev, procLift, player, baseEntity, offsetDown,
                        startLevel, maxRange, maxLevel);
                }
                else
                {
                    UpL.playerStartups.Remove(player.userID);
                }
            }
        }

        private void OnTick()
        {
            if (lastHour == Math.Floor(TOD_Sky.Instance.Cycle.Hour)) return;
            lastHour = Math.Floor(TOD_Sky.Instance.Cycle.Hour);
            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime + 1.5 &&
                TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunsetTime - 1.5) isDayTime = true;
            else isDayTime = false;
        }

        private void OnTimeSunrise()
        {
            isDayTime = true;
        }

        private void OnTimeSunset()
        {
            isDayTime = false;
        }

        [ConsoleCommand("_ul.commands")]
        private void CmdLftCmmnds(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(2)) return;
            BasePlayer player = arg.Connection?.player as BasePlayer;
            if (player == null) return;
            uint elevatorID = arg.GetUInt(0, 0u);
            if (elevatorID == 0u) return;
            string action = arg.GetString(1, "");
            if (action == "") return;
            int num = arg.GetInt(2, -1);
            if (num == -1) return;
            Elevator obj = null;
            if (crossReference.TryGetValue(elevatorID, out obj) && obj != null)
                obj.UIEnterCommands(player, r(action), num);
        }

        [ConsoleCommand("_ul.placement")]
        private void CmdLftPlcmnt(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(2)) return;
            BasePlayer player = arg.Connection?.player as BasePlayer;
            if (player == null) return;
            string action = arg.GetString(0, "");
            if (action == "") return;
            int num = arg.GetInt(1, -1);
            if (num == -1) return;
            Elevator obj = null;
            if (playerStartups.TryGetValue(player.userID, out obj)) obj.controlUI.UpdtPlcmnt(player, action, num);
        }

        public class ELStorage
        {
            public float timeToTake = 0f;
            public float timeTaken = 0f;
            public ulong ownerID = 0uL;
            public uint groundBlockID = 0u;
            public uint[] doorsID = new uint[1];
            public int[] fShares = new int[1];
            public int startSock;
            public List<int> cQueue = new List<int>();
            public List<int> pQueue = new List<int>();
            public int _uFloor = 1;
            public int _cFloor = 1;
            public int _dFloor = 1;
            public int _lcFloor = 1;
            public int _lFloor = 1;
            public float initialHeight;
            public int _state;
            public int _call;
            public int _floor;
            public int _last;
            public int _tower;
            public int _power;
            public int _panel;
            public int _lightmode;
            public int moveSpeed;
            public int maxSpeed;
            public int fuelConsume;
            public bool enableFuel;
            public bool enableCost;
            public float costMultiplier;
            public int floorTime;
            public int closeTime;
            public int _sharemode;
            public ulong skinID;
            public string clanTag;
            public string oldTag;
            public uint cTime;
            public List<ulong> _passengers = new List<ulong>();

            public ELStorage()
            {
            }
        }

        public enum CabinState
        {
            Waiting = 0,
            Idle = 1,
            Busy = 2,
            UpKeep = 3
        }

        public enum MoveDirection
        {
            None = 0,
            Up = 1,
            Down = 2
        }

        public enum LastQueue
        {
            None = 0,
            Call = 1,
            Panel = 2,
            Force = 3
        }

        public enum TowerState
        {
            Creating = 0,
            Ready = 1,
            Loading = 2,
            Saving = 3,
            None = 4,
            Spawned = 5
        }

        public enum QState
        {
            Single = 1,
            None = 0,
            Multiple = 2,
        }

        public enum PowerState
        {
            Internal = 0,
            TC = 1,
            FoC = 2
        }

        public enum FloorState
        {
            Open = 2,
            Closed = 3,
            Busy = 1,
            None = 0
        }

        public enum CabinLightMode
        {
            Dynamic = 0,
            AlwaysOn = 1,
            Disabled = 2
        }

        public enum ShareMode
        {
            None = 0,
            Clan = 1,
            Friends = 2,
            Full = 3,
            Public = 4,
            Disabled = 5,
        }

        public enum FloorShare
        {
            Public = -1,
            Full = 0,
            Friends = 1,
            Clan = 2,
            Excluded = 3,
            Hidden = 4,
            HiddenVIP = 5
        }

        public class Elevator : FacepunchBehaviour
        {
            private Oxide.Core.Libraries.Time time = Interface.Oxide.GetLibrary<Core.Libraries.Time>();

            private string msg(string key, string id = null)
            {
                return UpL.lang.GetMessage(key, UpL, id);
            }

            public LiftUI controlUI; /*Prevent_Building preventBuild;*/
            private CabinComfort cabinComfort;
            private BoxCollider boxCollider;
            private List<uint> toBeProtected = new List<uint>();
            private int moveSpeed = 1;
            private int maxSpeed = 1;
            private int floorTime = 3;
            private int fuelConsume = 3;
            private int closeTime = 160;
            private bool enableFuel = true;
            private bool enableCost = true;
            private float costMultiplier = 1.0f;
            private bool calledDestroy = false;
            private float timeToTake = 0f;
            private float timeTaken = 0f;
            private ItemContainer storeBox = null;
            private ItemContainer[] tunaBoxes;
            private ulong skinID = 0uL;
            private string knockEffectGuid = "c76bed57f17dc634bb4b7726b69e4a11";
            private BuildingManager.Building baseBuilding;
            private BuildingPrivlidge buildingPrivilege;
            public Dictionary<ulong, bool[]> userAccessLevel = new Dictionary<ulong, bool[]>();
            private float initialHeight;
            private List<int> cQueue = new List<int>();
            private List<int> pQueue = new List<int>();
            private int startSock;
            private int _uFloor = 1;
            private int _cFloor = 1;
            private int _dFloor = 1;
            private int _lcFloor = 1;
            private int _lFloor = 1;
            private Vector3 _currentPosition = new Vector3();
            public ProceduralLift lift;
            public uint liftID;
            private BasePlayer ownerPlayer = null;
            private BasePlayer lastUser = null;
            private string clanTag = string.Empty;
            private string oldTag = string.Empty;
            private uint cTime;
            private ulong ownerID;
            private BaseEntity groundBlock = null;
            private BaseEntity roofBlock = null;
            private Vector3[] stops;
            private Door[] doors;
            private FloorShare[] floorShares;
            private SimpleLight cabinLight;
            private SimpleBuildingBlock floorGrill;
            private Recycler recyclerBox;
            private CodeLock cabinLock;
            private Mailbox fuelBox;
            private Vector3[] socketPoints = new Vector3[5];
            private int[] socketOrder = new int[5];
            private BaseEntity[][] baseBlocksFloors;
            private bool doorSwitched = false;
            private CabinState _state = CabinState.Idle;
            private QState _call = QState.None;
            private QState _panel = QState.None;
            private PowerState _power = PowerState.Internal;
            private FloorState _floor = FloorState.None;
            private TowerState _tower = TowerState.None;
            private LastQueue _last = LastQueue.None;
            private MoveDirection _direction = MoveDirection.None;
            private CabinLightMode _lightmode = CabinLightMode.Dynamic;
            public ShareMode _sharemode = ShareMode.None;
            public bool IsIdle => _state == CabinState.Waiting || _state == CabinState.Idle;
            private bool UpKeep => _state == CabinState.UpKeep;

            private void OnCreation()
            {
                _tower = TowerState.Creating;
            }

            private void OnReady()
            {
                _tower = TowerState.Ready;
            }

            private void OnSaving()
            {
                _tower = TowerState.Saving;
            }

            private void OnLoading()
            {
                _tower = TowerState.Loading;
            }

            private void OnSpawned()
            {
                _tower = TowerState.Spawned;
            }

            public bool IsReady => _tower == TowerState.Ready || _tower != TowerState.Saving &&
                                   _tower != TowerState.Loading && _tower != TowerState.Creating &&
                                   _tower != TowerState.None;

            private bool IsSpawned => _tower == TowerState.Spawned || _tower != TowerState.Creating;

            public int CurrentFloor
            {
                get { return _cFloor; }
                set { _cFloor = value; }
            }

            public int UpperFloor
            {
                get { return _uFloor; }
                set { _uFloor = value; }
            }

            public int LowerFloor
            {
                get { return _lFloor; }
                set { _lFloor = value; }
            }

            public int DestinationFloor
            {
                get { return _dFloor; }
                set { _dFloor = value; }
            }

            public int LastCallFromFloor
            {
                get { return _lcFloor; }
                set { _lcFloor = value; }
            }

            private int ArrSum { get { return _uFloor + 1; } }

            private Vector3 CurrentPosition
            {
                get { return _currentPosition; }
                set { _currentPosition = value; }
            }

            public Door GetDoorAt(int f)
            {
                return f - 1 <= doors.Length && doors[f] != null ? doors[f] : null;
            }

            public int GetDoorCount
            {
                get { return doors.Where(d => d != null).Count(); }
            }

            public bool IsGround(BaseEntity ent)
            {
                return groundBlock == ent ? true : false;
            }

            public bool IsDoor(BaseEntity ent)
            {
                return doors.ToList().Contains(ent) ? true : false;
            }

            public bool IsOwner(BasePlayer player)
            {
                return ownerID == player.userID ? true : IsAdm(player) ? true : false;
            }

            public ulong GetOwner
            {
                get { return ownerID; }
            }
             
            public string GetTag
            {
                get { return clanTag; }
            }
            public uint GetAge
            {
                get { return cTime; }
            }

            public void SetOwner(ulong id)
            {
                ownerID = id;
            }

            public bool EnableFuel
            {
                get { return enableFuel; }
            }
            public bool EnableBuildCost
            {
                get { return enableCost; }
            }
            public int GetLightMode
            {
                get { return (int)_lightmode; }
            }

            public int MoveSpeed
            {
                get { return moveSpeed; }
                set { moveSpeed = value; }
            }

            public int MaxSpeed
            {
                get { return maxSpeed; }
                set { maxSpeed = value; }
            }

            public int FloorWait
            {
                get { return floorTime; }
                set { floorTime = value; }
            }

            public int IdleWait
            {
                get { return closeTime; }
                set { closeTime = value; }
            }

            public int GetPowerState => (int) _power;

            public FloorShare GetFloorMode(int f)
            {
                return floorShares[f];
            }

            public ulong GetSkinID => skinID;
            private HashSet<BasePlayer> _passengers;
            private bool _holdDoorTriggered;
            private bool _holdSleeperTriggered;

            private bool HasPassenger()
            {
                return _passengers.Count > 0 ? true : false;
            }

            private bool DoorTriggered
            {
                get { return _holdDoorTriggered; }
                set { _holdDoorTriggered = value; }
            }

            private bool SleepTriggered
            {
                get { return _holdSleeperTriggered; }
                set { _holdSleeperTriggered = value; }
            }

            public bool IsPassenger(ulong id)
            {
                return _passengers.Select(p => p.userID).ToList().Contains(id);
            }

            private int SleeperCount
            {
                get { return _passengers.Where(p => p.IsSleeping()).ToList().Count; }
            }

            private bool IsDayTime()
            {
                return TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime + 1.5 &&
                       TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunsetTime - 1.5;
            }

            public void BeforeCreation()
            {
                RaycastHit hit;
                Ray ray = new Ray(groundBlock.transform.position + Vector3.up, groundBlock.transform.up);
                for (int l = 1; l < UpperFloor; l++)
                    if (Physics.Raycast(ray, out hit, 3f * UpperFloor, 2097152))
                    {
                        BaseEntity ent = hit.GetEntity();
                        if (ent) ent.Kill(BaseNetworkable.DestroyMode.None);
                    }
            }

            public bool IntNw(ProceduralLift procLift, BaseEntity baseEntity, BasePlayer basePlayer, int offSocket,
                int startFloor, int stopFloor, char[] placeDoors, List<ItemAmount> collectAmounts, bool hasCost,
                float costMulti)
            {
                toBeProtected = new List<uint>();
                OnCreation();
                enabled = false;
                UpperFloor = stopFloor;
                LowerFloor = startFloor;
                CurrentFloor = LowerFloor;
                DestinationFloor = LowerFloor;
                LastCallFromFloor = LowerFloor;
                ownerPlayer = basePlayer;
                ownerID = basePlayer.userID;
                if (ClanCheck(ownerID.ToString(), oldTag, out clanTag)) oldTag = clanTag;
                cTime = time.GetUnixTimestamp();
                groundBlock =
                    baseEntity; /*preventBuild = groundBlock.gameObject.AddComponent<Prevent_Building>(); preventBuild.Setup(groundBlock, UpperFloor); preventBuild.BeforeCreation();*/
                BeforeCreation();
                crossReference[groundBlock.net.ID] = this;
                GetBuilding();
                doors = Enumerable.Repeat(default(Door), ArrSum).ToArray();
                floorShares = Enumerable.Repeat(default(FloorShare), ArrSum).ToArray();
                tunaBoxes = Enumerable.Repeat(default(ItemContainer), ArrSum).ToArray();
                CurrentFloor = LowerFloor;
                startSock = offSocket;
                lift = procLift;
                lift.Spawn();
                liftID = lift.net.ID;
                //AddFlrGrll();
                FtCmpnnts(lift);                
                OnSpawned();                
                initialHeight = lift.transform.position.y;
                CurrentPosition = lift.transform.position;
                IntScktrdr();
                IntFlrStps();
                maxSpeed = (int) GetAccess("MaxMoveSpeed", basePlayer.UserIDString, 1);
                fuelConsume = (int) GetAccess("FuelConsumePerFloor", basePlayer.UserIDString, 5);
                enableFuel = (bool) GetAccess("EnableFuelUsage", basePlayer.UserIDString, true);
                enableCost = hasCost;
                costMultiplier = costMulti;
                SetStates();
                StartCoroutine(CrtNwShft(placeDoors, collectAmounts, basePlayer, hasCost, costMultiplier, done =>
                {
                    if (!done)
                    {
                        UpL.PrintWarning($"Failed lift creation by '{(basePlayer != null ? basePlayer.ToString(): ownerID.ToString())}' at '{groundBlock.transform.position.ToString()}' from floor '{LowerFloor}' to '{UpperFloor}' | Stopped at: {lastShaftError}");
                        if (basePlayer)
                            basePlayer.ChatMessage(string.Format(UpL.prefixFormat, UpL.prefixColor, UpL.pluginPrefix) + msg("The new lift failed for some reason. Please try from a lower floor") + $" | Stopped at: {lastShaftError}");
                        RmvBsmnt();
                        lastShaftError = string.Empty;
                    }
                }));
                return true;
            }

            public ELStorage Sv2Prt(out bool isFinished, bool isUnload = false)
            {
                isFinished = default(bool);
                ELStorage data = new ELStorage();
                try
                {
                    OnSaving();
                    data.timeToTake = timeToTake;
                    data.timeTaken = timeTaken;
                    data.ownerID = ownerID;
                    data.groundBlockID = groundBlock.net.ID;
                    data.doorsID = Enumerable.Repeat(0u, ArrSum).ToArray();
                    for (int i = _lFloor; i < _uFloor + 1; i++)
                        if (doors[i] != null)
                            data.doorsID[i] = doors[i].net.ID;
                    data.fShares = Enumerable.Repeat(0, ArrSum).ToArray();
                    for (int i = _lFloor; i < _uFloor + 1; i++)
                        if (doors[i] != null)
                            data.fShares[i] = (int) floorShares[i];
                    data.startSock = startSock;
                    data.cQueue = cQueue;
                    data.pQueue = pQueue;
                    data._uFloor = _uFloor;
                    data._cFloor = _cFloor;
                    data._dFloor = _dFloor;
                    data._lcFloor = _lcFloor;
                    data._lFloor = _lFloor;
                    data.initialHeight = initialHeight;
                    data._state = (int) _state;
                    data._call = (int) _call;
                    data._floor = (int) _floor;
                    data._panel = (int) _panel;
                    data._power = (int) _power;
                    data._tower = (int) _tower;
                    data._last = (int) _last;
                    data._lightmode = (int) _lightmode;
                    data._passengers = SavePassengers();
                    data.moveSpeed = moveSpeed;
                    data.maxSpeed = maxSpeed;
                    data.enableFuel = enableFuel;
                    data.fuelConsume = fuelConsume;
                    data.enableCost = enableCost;
                    data.costMultiplier = costMultiplier;
                    data.floorTime = floorTime;
                    data.closeTime = closeTime;
                    data._sharemode = (int) _sharemode;
                    data.clanTag = clanTag;
                    data.oldTag = oldTag;
                    data.cTime = cTime;
                    data.skinID = skinID;
                    if (!isUnload) OnReady();
                    isFinished = true;
                }
                catch
                {
                    UpL.PrintWarning("Catched an exception while saving");
                    isFinished = false;
                }

                return data;
            }

            public bool Ld2Prt(ProceduralLift procLift, ELStorage data)
            {
                OnLoading();
                crossReference[procLift.net.ID] = this;
                timeToTake = data.timeToTake;
                timeTaken = data.timeTaken;
                groundBlock = BaseNetworkable.serverEntities.Find(data.groundBlockID) as BaseEntity;
                if (groundBlock != null)
                {
                    GetBuilding();
                    crossReference[groundBlock.net.ID] = this;
                }

                lift = procLift;
                liftID = lift.net.ID;
                //AddFlrGrll();
                FtCmpnnts(lift);
                _uFloor = data._uFloor;
                _lFloor = data._lFloor;
                _cFloor = Mathf.Max(data._cFloor, _lFloor);
                _dFloor = Mathf.Max(data._dFloor, _lFloor);
                _lcFloor = Mathf.Max(data._lcFloor, _lFloor);
                _currentPosition = lift.transform.position;
                initialHeight = data.initialHeight;
                ownerID = data.ownerID;
                tunaBoxes = Enumerable.Repeat(default(ItemContainer), ArrSum).ToArray();
                GtCbnLght();
                GtRcclr();
                GtCbnLck();
                GetFuelBox();
                if (groundBlock == null)
                {
                    StartCoroutine(SoftDestroy());
                    return false;
                }

                doors = Enumerable.Repeat(default(Door), ArrSum).ToArray();
                for (int i = _lFloor; i < _uFloor + 1; i++)
                    if (data.doorsID[i] != 0)
                    {
                        Door getDoor = BaseNetworkable.serverEntities.Find(data.doorsID[i]) as Door;
                        if (getDoor)
                        {
                            if (i != CurrentFloor && getDoor.HasFlag(BaseEntity.Flags.Open))
                                getDoor.SetFlag(BaseEntity.Flags.Open, false);
                            if (!getDoor.HasFlag(BaseEntity.Flags.Locked))
                                getDoor.SetFlag(BaseEntity.Flags.Locked, true);
                            getDoor.knockEffect.guid = knockEffectGuid;
                            FtCmpnnts(getDoor);
                            FtCmpnnts(getDoor.FindLinkedEntity<BuildingBlock>());
                            BaseEntity slot = getDoor.GetSlot(BaseEntity.Slot.Lock);
                            if (slot != null)
                            {
                                if (slot is BaseFuelLightSource || slot is BaseOven)
                                {
                                    slot.KillMessage();
                                    AddFlrLght(getDoor);
                                }
                                else
                                {
                                    GetFlrLght(slot);
                                }
                            }
                            else
                            {
                                AddFlrLght(getDoor);
                            }

                            doors[i] = getDoor;
                        }
                    }

                floorShares = Enumerable.Repeat(default(FloorShare), ArrSum).ToArray();
                if (data.fShares != null)
                    for (int i = _lFloor; i < _uFloor + 1; i++)
                        floorShares[i] = (FloorShare) data.fShares[i];
                startSock = data.startSock;
                pQueue = data.pQueue ?? new List<int>();
                cQueue = data.cQueue ?? new List<int>();
                _state = (CabinState) data._state;
                _call = (QState) data._call;
                _panel = (QState) data._panel;
                _floor = (FloorState) data._floor;
                _power = (PowerState) data._power;
                _tower = (TowerState) data._tower;
                _last = (LastQueue) data._last;
                _lightmode = (CabinLightMode) data._lightmode;
                moveSpeed = data.moveSpeed;
                maxSpeed = data.maxSpeed;
                enableFuel = data.enableFuel;
                fuelConsume = data.fuelConsume;
                enableCost = data.enableCost;
                costMultiplier = data.costMultiplier;
                floorTime = data.floorTime;
                closeTime = data.closeTime;
                _sharemode = (ShareMode) data._sharemode;
                clanTag = data.clanTag;
                oldTag = data.oldTag;
                if (ClanCheck(ownerID.ToString(), oldTag, out clanTag)) oldTag = clanTag;
                cTime = data.cTime;
                if (cTime <= 1) cTime = time.GetUnixTimestamp();
                skinID = data.skinID;
                IntScktrdr();
                GtScktPnts();
                GtFlrStps();
                GtGrndDr();
                GtGrndSds();
                for (int floor = _lFloor + 1; floor < _uFloor + 1; floor++)
                {
                    GtFlrFrnt(floor);
                    GtFlrSds(floor);
                }

                GtRfTp();
                SetStates();
                SetupCollider();
                LoadPassengers(data._passengers as List<ulong>);
                controlUI = new LiftUI();
                controlUI.Init(this, lift.net.ID);
                OnReady();
                if (doors[CurrentFloor].HasFlag(BaseEntity.Flags.Open)) StartIdleClose();
                if (_lightmode == CabinLightMode.Dynamic && !IsDayTime() && HasPassenger() ||
                    _lightmode == CabinLightMode.AlwaysOn) SwtchCbnLght(true);
                else SwtchCbnLght(false);
                return true;
            }

            public void RstMvmnt(BasePlayer player)
            {
                OnCreation();
                enabled = false;
                if (recyclerBox) recyclerBox.SetFlag(BaseEntity.Flags.On, false);
                lift.transform.position =
                    new Vector3(lift.transform.position.x, initialHeight, lift.transform.position.z);
                MvPssngrs(initialHeight);
                SncPs(lift);
                SncKll(fuelBox);
                foreach (Door door in doors.Where(d => d != null).ToList())
                {
                    SwtchFlrLght(door, 3);
                    door.SetFlag(BaseEntity.Flags.Open, false);
                    SncKll(door);
                }

                _currentPosition = lift.transform.position;
                _state = CabinState.Idle;
                _call = QState.None;
                _panel = QState.None;
                _floor = FloorState.None;
                _last = LastQueue.None;
                _direction = MoveDirection.None;
                timeToTake = 0f;
                timeTaken = 0f;
                cQueue = new List<int>();
                pQueue = new List<int>();
                _cFloor = _lFloor;
                _dFloor = _lFloor;
                _lcFloor = _lFloor;
                OnReady();
                player.ChatMessage(string.Format(UpL.prefixFormat, UpL.prefixColor, UpL.pluginPrefix) +
                                   msg("This lift was sucessfully reset"));
            }

            public void ChckDrKnck(Door door, BasePlayer player)
            {
                lastUser = player;
                if (calledDestroy || UpKeep)
                {
                    SendEffRecycleStop(door);
                    return;
                }

                if (!HsLftAccss(player))
                {
                    if (IsPassenger(player.userID) && IsIdle && CurrentFloor == DestinationFloor)
                    {
                        OpenFloor(CurrentFloor);
                        SwtchFlrLght(CurrentFloor, 1);
                        return;
                    }

                    SendEffDenied(door);
                    return;
                }

                int index = Array.IndexOf(doors, door);
                if (index == -1) return;
                if (IsPassenger(player.userID))
                    if (CurrentFloor != DestinationFloor && !IsIdle)
                    {
                        SendEffRecycleStop(door);
                        return;
                    }

                if (!HsFlrAccss(player, GetFloorMode(index)))
                {
                    SendEffDenied(door);
                    return;
                }

                TryAddExternal(index, player);
            }

            public object ChckLftUs(ProceduralLift procLift, BasePlayer player)
            {
                lastUser = player;
                if (!HsLftAccss(player))
                {
                    SendEffDenied();
                    return false;
                }

                if (calledDestroy || !HasPassenger())
                    if (calledDestroy)
                        return false;
                controlUI.CrtCbnUI(player, true);
                return false;
            }

            public void SwtchFlrLght(object floor, int lvl)
            {
                Door door = null;
                if (floor is int) door = doors[(int) floor];
                else if (floor is Door) door = floor as Door;
                if (door == null) return;
                CardReader slot = (CardReader) door.GetSlot(BaseEntity.Slot.Lock);
                if (slot)
                {
                    slot.SetFlag(BaseEntity.Flags.Reserved1, lvl == 1);
                    slot.SetFlag(BaseEntity.Flags.Reserved2, lvl == 2);
                    slot.SetFlag(BaseEntity.Flags.Reserved3, lvl == 3);
                }
            }

            public void SwtchCbnLght(bool state)
            {
                if (cabinLight == null) AddCbnLght();
                if (!state && cabinLight.HasFlag(BaseEntity.Flags.On)) cabinLight.SetFlag(BaseEntity.Flags.On, false);
                else if (state && !cabinLight.HasFlag(BaseEntity.Flags.On))
                    cabinLight.SetFlag(BaseEntity.Flags.On, true);
            }

            public void SetUpKeep(bool flag)
            {
                if (flag && _state != CabinState.UpKeep)
                {
                    _state = CabinState.UpKeep;
                    enabled = false;
                }
                else if (!flag && _state == CabinState.UpKeep)
                {
                    _state = CabinState.Waiting;
                    if (doorSwitched)
                    {
                        doorSwitched = false;
                        foreach (Door door in doors.Where(d => d != null).ToList()) SwtchFlrLght(door, 3);
                        _call = QState.None;
                        _panel = QState.None;
                        cQueue = new List<int>();
                        pQueue = new List<int>();
                    }

                    enabled = true;
                    DoNextMove();
                }
            }

            public bool HsLftAccss(BasePlayer player)
            {
                userAccessLevel[player.userID] = new bool[3];
                bool flagA = player.userID == ownerID || IsAdm(player);
                userAccessLevel[player.userID][0] = flagA;
                bool flagC = clansEnabled &&
                             (_sharemode == ShareMode.Clan || _sharemode == ShareMode.Full ||
                              _sharemode == ShareMode.Public) && SameClanS(ownerID.ToString(), player.UserIDString);
                userAccessLevel[player.userID][1] = flagC;
                bool flagF = friendsEnabled &&
                             (_sharemode == ShareMode.Friends || _sharemode == ShareMode.Full ||
                              _sharemode == ShareMode.Public) && HasFriendS(ownerID.ToString(), player.UserIDString);
                userAccessLevel[player.userID][2] = flagF;
                if (_sharemode == ShareMode.Public) return true;
                return flagA || flagC || flagF;
            }

            public bool HsFlrAccss(BasePlayer player, FloorShare share, int p = 0)
            {
                if (IsOwner(player) || IsAdm(player) || share == FloorShare.Public) return true;
                if (share == FloorShare.HiddenVIP)
                    if ((bool) GetAccess("AccessVipShare", player.UserIDString, false))
                        return true;
                if (share == FloorShare.Friends)
                    if (friendsEnabled && userAccessLevel[player.userID][2])
                        return true;
                if (share == FloorShare.Clan)
                    if (clansEnabled && userAccessLevel[player.userID][1])
                        return true;
                return false;
            }

            public void UIEnterCommands(BasePlayer player, string action, int num)
            {
                lastUser = player;
                SendEffectTo(2414984321, lift, player);
                if (action == "fgngr")
                {
                    SetUpKeep(false);
                    return;
                }
                else if (action == "fjvgpu")
                {
                    if (num == 0)
                    {
                        SendEffLock();
                        return;
                    }

                    doorSwitched = true;
                    bool hasDoor = GetDoorAt(num) != null ? true : false;
                    StartCoroutine(SwtchFlrFrnt(player, num, hasDoor, GetDoorAt(num)));
                    return;
                }
                else if (action == "bcra")
                {
                    OpenFloor(num);
                    SwtchFlrLght(num, 1);
                    return;
                }
                else if (action == "pybfr")
                {
                    CloseFloor(num);
                    SwtchFlrLght(num, 3);
                    return;
                }
                else if (action == "zbir")
                {
                    if (num == 0)
                    {
                        SendEffLock();
                        return;
                    }

                    if (num == 6666)
                    {
                        if (IsOwner(player))
                        {
                            if (player.userID == ownerID) ownerPlayer = player;
                            controlUI.CrtDstryUI(player);
                            return;
                        }

                        return;
                    }

                    if (num == 7777)
                    {
                        if (IsOwner(player))
                        {
                            if (player.userID == ownerID) ownerPlayer = player;
                            controlUI.CrtSttngsUI(player);
                            return;
                        }

                        return;
                    }

                    if (num == 1111)
                    {
                        SetUpKeep(false);
                        controlUI.CrtCbnUI(player);
                        return;
                    }

                    TryAddInternal(num);
                    return;
                }
                else if (action == "sybbezbqr")
                {
                    if (num == 0)
                    {
                        SendEffLock();
                        return;
                    }

                    if (num == 1111)
                    {
                        for (int i = LowerFloor; i < ArrSum; i++)
                        {
                            floorShares[i] = (FloorShare) (int) floorShares[i] + 1;
                            if ((int) floorShares[i] > 5) floorShares[i] = (FloorShare) (-1);
                        }

                        controlUI.CrtShrngUI(player);
                        return;
                    }

                    if (num == 6666)
                    {
                        for (int i = LowerFloor; i < ArrSum; i++) floorShares[i] = (FloorShare) 0;
                        controlUI.CrtShrngUI(player);
                        return;
                    }

                    floorShares[num] = (FloorShare) (int) floorShares[num] + 1;
                    if ((int) floorShares[num] > 5) floorShares[num] = (FloorShare) (-1);
                    controlUI.CrtShrngUI(player);
                    return;
                }
                else if (action == "shry")
                {
                    if (num == 0)
                    {
                        SendEffDeploy();
                        player.inventory.loot.StartLootingEntity(recyclerBox, false);
                        player.inventory.loot.AddContainer(recyclerBox.inventory);
                        player.inventory.loot.SendImmediate();
                        player.ClientRPCPlayer<string>(null, player, r("ECP_BcraYbbgCnary"), r("shryfgbentr"));
                        return;
                    }
                    else
                    {
                        if (_power == PowerState.Internal && buildingPrivilege) _power = PowerState.TC;
                        else _power = PowerState.Internal;
                        controlUI.CrtSttngsUI(player);
                        return;
                    }
                }
                else if (action == "qrfgebl")
                {
                    if (num == 0)
                    {
                        controlUI.CrtSttngsUI(player);
                        return;
                    }

                    if (CurrentFloor != LowerFloor)
                    {
                        _last = LastQueue.Panel;
                        DestinationFloor = LowerFloor;
                        calledDestroy = true;
                        StrtMvng();
                        return;
                    }

                    bool keepBuilding = num == 2 ? true : false;
                    RmvBsmnt(keepBuilding);
                    return;
                }
                else if (action == "pnovayvtug")
                {
                    if ((int) _lightmode == 2)
                    {
                        _lightmode = (CabinLightMode) 0;
                    }
                    else
                    {
                        int tmp = (int) _lightmode;
                        tmp++;
                        _lightmode = (CabinLightMode) tmp;
                    }

                    if (_lightmode == CabinLightMode.AlwaysOn ||
                        _lightmode == CabinLightMode.Dynamic && !IsDayTime() && HasPassenger()) SwtchCbnLght(true);
                    else SwtchCbnLght(false);
                    controlUI.CrtSttngsUI(player);
                    return;
                }
                else if (action == "funerzbqr")
                {
                    if (num == 0) DefineShareMode(player);
                    else controlUI.CrtShrngUI(player);
                    return;
                }
                else if (action == "fcrrq")
                {
                    if (moveSpeed == maxSpeed) moveSpeed = 1;
                    else moveSpeed++;
                    controlUI.CrtSttngsUI(player);
                    return;
                }
                else if (action == "sybbejnvg")
                {
                    if (floorTime == 15) floorTime = 3;
                    else floorTime += 2;
                    controlUI.CrtSttngsUI(player);
                    return;
                }
                else if (action == "vqyrjnvg")
                {
                    if (closeTime >= 640) closeTime = -1;
                    else if (closeTime == -1) closeTime = 10;
                    else closeTime *= 2;
                    StartIdleClose();
                    controlUI.CrtSttngsUI(player);
                    return;
                }
                else if (action == "qbbefxva")
                {
                    SendEffDeploy();
                    SetUpKeep(false);
                    StoreBox(player);
                    return;
                }
                else if (action == "pnapry")
                {
                    return;
                }
            }

            private void DefineShareMode(BasePlayer player = null)
            {
                if (player != null) _sharemode = (ShareMode) (int) _sharemode + 1;
                if ((int) _sharemode > 4) _sharemode = (ShareMode) 0;
                if (player != null) controlUI.CrtSttngsUI(player);
            }

            public string GetShareMode(bool withsuffix = false)
            {
                int mode = (int) _sharemode;
                if (mode == 1)
                {
                    if (clansEnabled) return "<color=#008000>(o.k.)</color>";
                    else return "<color=#ffff00>(n/a)</color>";
                }
                else if (mode == 2)
                {
                    if (friendsEnabled) return "<color=#008000>(o.k.)</color>";
                    else return "<color=#ffff00>(n/a)</color>";
                }
                else if (mode == 3)
                {
                    if (friendsEnabled && clansEnabled) return "<color=#008000>(o.k.)</color>";
                    else return "<color=#ffff00>(n/a)</color>";
                }

                return "";
            }

            private void TryAddInternal(int num)
            {
                if (!pQueue.Contains(num))
                {
                    if (!PreFuelCheck(CurrentFloor, num))
                    {
                        Effect.server.Run(StringPool.Get(821899790), lift, 0u, new Vector3(-1f, -2f, 1.5f),
                            Vector3.zero, null, false);
                        return;
                    }

                    pQueue.Add(num);
                }
                else
                {
                    return;
                }

                OnPanelQueue();
                TryMvCbn(num, LastQueue.Panel);
            }

            private void TryAddExternal(int num, BasePlayer player)
            {
                if (num == CurrentFloor && !doors[CurrentFloor].HasFlag(BaseEntity.Flags.Open))
                {
                    Effect.server.Run(StringPool.Get(2125801479), doors[num], 0u, Vector3.zero, Vector3.zero, null,
                        false);
                    OpenFloor(num);
                    SwtchFlrLght(num, 1);
                    return;
                }

                if (!cQueue.Contains(num))
                {
                    if (_state == CabinState.Idle && !PreFuelCheck(CurrentFloor, num))
                    {
                        Effect.server.Run(StringPool.Get(3618221308), doors[num], 0u, Vector3.zero, Vector3.zero, null,
                            false);
                        Effect.server.Run(StringPool.Get(821899790), doors[num].GetSlot(BaseEntity.Slot.Lock), 0u,
                            Vector3.zero, Vector3.zero, null, false);
                        return;
                    }

                    Effect.server.Run(StringPool.Get(2125801479), doors[num], 0u, Vector3.zero, Vector3.zero, null,
                        false);
                    cQueue.Add(num);
                    SwtchFlrLght(num, 2);
                }
                else
                {
                    Effect.server.Run(StringPool.Get(2125801479), doors[num], 0u, Vector3.zero, Vector3.zero, null,
                        false);
                }

                OnCallQueue();
                LastCallFromFloor = num;
                TryMvCbn(num, LastQueue.Call);
            }

            private void TryMvCbn(int num, LastQueue last)
            {
                if (_last == LastQueue.None || _state == CabinState.Idle)
                {
                    DestinationFloor = num;
                    _last = last;
                    StrtMvng();
                }
            }

            public void StartIdleClose()
            {
                if (closeTime > 0)
                {
                    CancelInvoke(DoIdleClose);
                    Invoke(DoIdleClose, (float) closeTime);
                }
            }

            private void DoIdleClose()
            {
                if (SleepTriggered)
                {
                    if (SleeperCount > 0)
                    {
                        CancelInvoke(DoIdleClose);
                        return;
                    }
                    else
                    {
                        SleepTriggered = false;
                    }
                }

                if (!doors[CurrentFloor].HasFlag(BaseEntity.Flags.Open))
                {
                    CancelInvoke(DoIdleClose);
                    return;
                }

                lift.SetFlag(BaseEntity.Flags.Busy, true);
                doors[DestinationFloor].SetFlag(BaseEntity.Flags.Open, false);
                SwtchFlrLght(DestinationFloor, 3);
                _state = CabinState.Busy;
                _floor = FloorState.Busy;
                enabled = true;
            }

            private void CloseFloor(int num)
            {
                if (IsIdle && doors[num].HasFlag(BaseEntity.Flags.Open))
                {
                    CancelInvoke(DoIdleClose);
                    lift.SetFlag(BaseEntity.Flags.Busy, true);
                    doors[num].SetFlag(BaseEntity.Flags.Open, false);
                    _state = CabinState.Busy;
                    _floor = FloorState.Busy;
                    enabled = true;
                    return;
                }

                SendEffLock();
            }

            public void OpenFloor(int num, bool force = false)
            {
                if ((IsIdle || force) && !doors[num].HasFlag(BaseEntity.Flags.Open))
                {
                    CancelInvoke(DoIdleClose);
                    lift.SetFlag(BaseEntity.Flags.Busy, true);
                    doors[num].SetFlag(BaseEntity.Flags.Open, true);
                    _state = CabinState.Busy;
                    _floor = FloorState.Busy;
                    enabled = true;
                    return;
                }

                SendEffLock();
            }

            private void DoNextMove()
            {
                if (UpKeep) return;
                if (DoorTriggered)
                {
                    DoorTriggered = false;
                    Invoke(DoNextMove, (float) floorTime);
                    return;
                }

                if (_last == LastQueue.Panel || _last == LastQueue.Force)
                {
                    if (_call != QState.None)
                    {
                        DoCallMove();
                        CancelInvoke(DoIdleClose);
                        return;
                    }
                    else if (_panel != QState.None)
                    {
                        DoPanelMove();
                        CancelInvoke(DoIdleClose);
                        return;
                    }
                }

                if (_last == LastQueue.Call || _last == LastQueue.Force)
                {
                    if (_panel != QState.None)
                    {
                        DoPanelMove();
                        CancelInvoke(DoIdleClose);
                        return;
                    }
                    else if (_call != QState.None)
                    {
                        DoCallMove();
                        CancelInvoke(DoIdleClose);
                        return;
                    }
                }

                EnterIdle();
            }

            private void EnterIdle()
            {
                _last = LastQueue.None;
                _state = CabinState.Idle;
                enabled = false;
            }

            private void DoPanelMove()
            {
                DestinationFloor = pQueue[0];
                _last = LastQueue.Panel;
                StrtMvng();
            }

            private void DoCallMove()
            {
                DestinationFloor = cQueue[0];
                _last = LastQueue.Call;
                StrtMvng();
            }

            public void DoForceMove(int floor = 1)
            {
                _last = LastQueue.Force;
                DestinationFloor = floor;
                StrtMvng();
            }

            private void StrtMvng()
            {
                GetDirection();
                if (_last != LastQueue.Force && !calledDestroy && !FuelCheck())
                {
                    if (_last == LastQueue.Call)
                    {
                        OnCallQueue(true);
                        foreach (Door door in doors.Where(d => d != null).ToList()) SwtchFlrLght(door, 3);
                        if (LastCallFromFloor == DestinationFloor)
                            Effect.server.Run(StringPool.Get(821899790),
                                doors[LastCallFromFloor].GetSlot(BaseEntity.Slot.Lock), 0u, Vector3.zero, Vector3.zero,
                                null, false);
                    }
                    else if (_last == LastQueue.Panel)
                    {
                        OnPanelQueue(true);
                        {
                            Effect.server.Run(StringPool.Get(821899790), cabinLight, 0u, Vector3.zero, Vector3.zero,
                                null, false);
                        }
                    }

                    EnterIdle();
                    return;
                }

                CancelInvoke(DoIdleClose);
                _state = CabinState.Busy;
                enabled = true;
                timeToTake = Vector3.Distance(stops[CurrentFloor], stops[DestinationFloor]) / moveSpeed;
                timeTaken = 0f;
                lift.SetFlag(BaseEntity.Flags.Busy, true);
                _floor = FloorState.Busy;
            }

            private void GetDirection()
            {
                if (CurrentFloor < DestinationFloor) _direction = MoveDirection.Up;
                else _direction = MoveDirection.Down;
            }

            private void OnCallQueue(bool isDone = false)
            {
                if (isDone) cQueue.RemoveAt(0);
                if (cQueue.Count == 0) _call = QState.None;
                if (cQueue.Count == 1) _call = QState.Single;
                if (cQueue.Count > 1) _call = QState.Multiple;
            }

            private void OnPanelQueue(bool isDone = false)
            {
                if (isDone) pQueue.RemoveAt(0);
                if (pQueue.Count == 0) _panel = QState.None;
                if (pQueue.Count == 1) _panel = QState.Single;
                if (pQueue.Count > 1) _panel = QState.Multiple;
            }

            private void Update()
            {
                if (IsIdle || !IsReady || UpKeep) return;
                if (CurrentPosition == stops[DestinationFloor])
                {
                    if (doors[DestinationFloor].HasFlag(BaseEntity.Flags.Busy)) return;
                    if (calledDestroy)
                    {
                        enabled = false;
                        RmvBsmnt();
                        return;
                    }

                    _floor = FloorState.Open;
                    _state = CabinState.Waiting;
                    CurrentFloor = DestinationFloor;
                    if (_last != LastQueue.Force)
                    {
                        if (_last == LastQueue.Call) OnCallQueue(true);
                        if (_last == LastQueue.Panel) OnPanelQueue(true);
                    }

                    lift.SetFlag(BaseEntity.Flags.Busy, false);
                    if (_panel != QState.None || _call != QState.None)
                    {
                        Invoke(DoNextMove, (float) floorTime);
                    }
                    else
                    {
                        _last = LastQueue.None;
                        _state = CabinState.Idle;
                        enabled = false;
                        if (closeTime > 0)
                        {
                            CancelInvoke(DoIdleClose);
                            Invoke(DoIdleClose, (float) closeTime);
                        }
                    }

                    return;
                }

                if (doors[CurrentFloor].HasFlag(BaseEntity.Flags.Open))
                {
                    doors[CurrentFloor].SetFlag(BaseEntity.Flags.Open, false);
                    SwtchFlrLght(CurrentFloor, 3);
                    _floor = FloorState.Busy;
                    return;
                }

                if (doors[CurrentFloor].HasFlag(BaseEntity.Flags.Busy) ||
                    doors[CurrentFloor].HasFlag(BaseEntity.Flags.Open)) return;
                if (_floor != FloorState.Closed)
                {
                    _floor = FloorState.Closed;
                    if (recyclerBox == null) AddRcclr();
                    else recyclerBox.SetFlag(BaseEntity.Flags.On, true);
                    SendEffect(3499498126, lift);
                }

                timeTaken += Time.deltaTime;
                float y = Mathf.SmoothStep(stops[CurrentFloor].y, stops[DestinationFloor].y,
                    Mathf.InverseLerp(0, timeToTake, timeTaken));
                MvPssngrs(y);
                CurrentPosition = new Vector3(CurrentPosition.x, y, CurrentPosition.z);
                lift.transform.position = CurrentPosition;
                //floorGrill.transform.position = lift.transform.position - (Vector3.up * 0.4f);
                SncPs(lift);
                if (CurrentPosition == stops[DestinationFloor])
                {
                    SncKll(fuelBox);
                    timeToTake = 0f;
                    timeTaken = 0f;
                    recyclerBox.SetFlag(BaseEntity.Flags.On, false);
                    SendEffect(3618221308, lift);
                    doors[DestinationFloor].SetFlag(BaseEntity.Flags.Open, true);
                    _floor = FloorState.Busy;
                    SwtchFlrLght(DestinationFloor, 1);
                }
            }

            private void SncPs(BaseEntity entity)
            {
                if (entity.net.group.subscribers.Count == 0) return;
                if (Net.sv.write.Start())
                {
                    Net.sv.write.PacketID(Message.Type.GroupChange);
                    Net.sv.write.EntityID(entity.net.ID);
                    Net.sv.write.GroupID(entity.net.group.ID);
                    Net.sv.write.Send(new SendInfo(entity.net.group.subscribers));
                }

                if (Net.sv.write.Start())
                {
                    Net.sv.write.PacketID(Message.Type.EntityPosition);
                    Net.sv.write.EntityID(entity.net.ID);
                    Net.sv.write.Vector3(entity.GetNetworkPosition());
                    Net.sv.write.Vector3(entity.GetNetworkRotation().eulerAngles);
                    Net.sv.write.Float(entity.GetNetworkTime());
                    Write write = Net.sv.write;
                    SendInfo info = new SendInfo(entity.net.group.subscribers);
                    info.method = SendMethod.ReliableUnordered;
                    info.priority = Priority.Immediate;
                    write.Send(info);
                }

                if (entity.children != null)
                    foreach (BaseEntity current in entity.children)
                        SncPs(current);
            }

            private void SncKll(BaseEntity entity)
            {
                if (entity.net.group.subscribers.Count == 0) return;
                if (BaseEntity.Query.Server != null) BaseEntity.Query.Server.Move(entity);
                if (Net.sv.write.Start())
                {
                    Net.sv.write.PacketID(Message.Type.EntityDestroy);
                    Net.sv.write.UInt32(entity.net.ID);
                    Net.sv.write.UInt8(0);
                    Net.sv.write.Send(new SendInfo(entity.net.group.subscribers));
                }

                entity.SendNetworkUpdateImmediate(false);
                if (entity.children != null)
                    foreach (BaseEntity current in entity.children)
                        SncKll(current);
            }

            public void EntityKill(uint entid, bool isDoor)
            {
                if (lift == null || groundBlock == null) return;
                if (entid == lift.net.ID || entid == groundBlock.net.ID || isDoor && doorDestructionKillsLiftCabin)
                {
                    StartCoroutine(SoftDestroy(entid));
                    return;
                }

                crossReference.Remove(entid);
            }

            private void OnDestroy()
            {
                if (!floorGrill?.IsDestroyed ?? false)
                    floorGrill?.Kill();

                CancelInvoke(DoIdleClose);
                Destroy(boxCollider);
                if (!enabled || calledDestroy) return;
                foreach (uint id in toBeProtected.ToList()) crossReference.Remove(id);
                StartCoroutine(SoftDestroy());
            }

            private IEnumerator SoftDestroy(uint entid = 0u)
            {
                if (calledDestroy) yield break;
                calledDestroy = true;
                if (groundBlock && !groundBlock.IsDestroyed)
                {
                    crossReference.Remove(groundBlock.net.ID);
                    Destroy(groundBlock.gameObject.GetComponent<Prevent_Building>());
                    yield return waitFOF;
                }

                if (fuelBox && !fuelBox.IsDestroyed)
                {
                    fuelBox.KillMessage();
                    yield return waitFOF;
                }

                if (recyclerBox && !recyclerBox.IsDestroyed)
                {
                    recyclerBox.KillMessage();
                    yield return waitFOF;
                }

                if (cabinLight && !cabinLight.IsDestroyed)
                {
                    cabinLight.KillMessage();
                    yield return waitFOF;
                }

                if (cabinLock && !cabinLock.IsDestroyed)
                {
                    cabinLock.KillMessage();
                    yield return waitFOF;
                }

                if (doors != null && doors.Length > 0)
                    foreach (Door d in doors)
                    {
                        if (d == null) continue;
                        BaseEntity slot = d.GetSlot(BaseEntity.Slot.Lock);
                        if (slot != null && slot is CardReader) slot.KillMessage();
                    }

                crossReference.Remove(entid);
                Destroy(boxCollider);
                if (lift && !lift.IsDestroyed)
                {
                    crossReference.Remove(lift.net.ID);
                    SendEffect(2184296839, lift);
                    lift.KillMessage();
                    yield return waitFOF;
                }

                Destroy(this);
                yield return null;
            }

            public void SetupCollider()
            {
                gameObject.layer = 18;
                boxCollider = gameObject.AddComponent<BoxCollider>();
                boxCollider.isTrigger = true;
                boxCollider.center = new Vector3(0, -3.6f, 0);
                boxCollider.size = new Vector3(2.9f, 2.9f, 2.9f);
                _passengers = new HashSet<BasePlayer>();
            }

            private void SleepWatch()
            {
                if (SleepTriggered)
                {
                    if (sleepWatchMoveDown && CurrentFloor != LowerFloor)
                    {
                        if (_state != CabinState.Busy) DoForceMove(LowerFloor);
                        CancelInvoke(SleepWatch);
                        InvokeRandomized(SleepWatch, sleepWatchInterval, sleepWatchInterval,
                            sleepWatchInterval * 0.33f);
                        return;
                    }

                    if (CurrentFloor == LowerFloor || !sleepWatchMoveDown)
                        if (!doors[CurrentFloor].HasFlag(BaseEntity.Flags.Open))
                        {
                            OpenFloor(CurrentFloor);
                            SwtchFlrLght(CurrentFloor, 1);
                        }
                }

                foreach (BasePlayer player in _passengers.ToList())
                    if (player.IsSleeping() && !IsAdm(player))
                    {
                        SleepTriggered = true;
                        CancelInvoke(SleepWatch);
                        InvokeRandomized(SleepWatch, sleepWatchInterval, sleepWatchInterval,
                            sleepWatchInterval * 0.33f);
                        return;
                    }

                SleepTriggered = false;
                InvokeRandomized(SleepWatch, sleepWatchDelay, sleepWatchDelay, sleepWatchDelay * 0.33f);
            }

            public List<ulong> SavePassengers()
            {
                List<ulong> l = new List<ulong>();
                foreach (BasePlayer p in _passengers) l.Add(p.userID);
                return l;
            }

            public void LoadPassengers(List<ulong> l = null)
            {
                if (l == null || l.Count == 0) return;
                foreach (ulong id in l)
                {
                    BasePlayer p = BasePlayer.FindByID(id);
                    if (p != null) _passengers.Add(p);
                }

                if (_passengers.Count > 0 && GetLightMode == 0 && !IsDayTime()) SwtchCbnLght(true);
                if (_passengers.Count > 0 && sleepWatchEnabled)
                    InvokeRandomized(SleepWatch, sleepWatchDelay, sleepWatchDelay, sleepWatchDelay * 0.33f);
            }

            public void MvPssngrs(float toPos)
            {
                foreach (BasePlayer player in _passengers.ToList())
                    if (player.IsDead())
                        RemovePassenger(player);
            }

            public void RemovePassenger(BasePlayer player)
            {
                _passengers.Remove(player);
                (player as BaseEntity).SetParent(null, true, true);
                if (player != null)
                {
                    player.PauseFlyHackDetection(5f);
                    player.PauseSpeedHackDetection(5f);
                }

                controlUI.DestroyUi(player);
                if (_passengers.Count == 0)
                {
                    CancelInvoke(SleepWatch);
                    SleepTriggered = false;
                    if (GetLightMode == 0) SwtchCbnLght(false);
                }
            }

            public bool ClsDrpBx(Mailbox fuelBox)
            {
                foreach (BasePlayer player in _passengers.ToList())
                    if (player.inventory.loot != null)
                        if (player.inventory.loot.entitySource is Mailbox)
                        {
                            if (player.inventory.loot.containers.Contains(fuelBox.inventory))
                            {
                                Item slot = fuelBox.inventory.GetSlot(fuelBox.mailInputSlot);
                                if (slot != null)
                                {
                                    fuelBox.inventory.itemList.Remove(slot);
                                    fuelBox.inventory.MarkDirty();
                                    player.inventory.GiveItem(slot);
                                }
                            }

                            player.EndLooting();
                            player.ClientRPCPlayer(null, player, r("BaQvrq"));
                            return IsAdm(player);
                        }

                return false;
            }

            private void OnTriggerEnter(Collider other)
            {
                if ((other.gameObject.layer & 17) > 0)
                {
                    BasePlayer component = other.gameObject.GetComponent<BasePlayer>();
                    if (component != null && !_passengers.Contains(component))
                    {
                        _passengers.Add(component);
                        (component as BaseEntity).SetParent(lift, true, true);
                        _holdDoorTriggered = true;
                        StartIdleClose();
                    }

                    if (_passengers.Count == 1 && sleepWatchEnabled)
                        InvokeRandomized(SleepWatch, sleepWatchDelay, sleepWatchDelay, sleepWatchDelay * 0.33f);
                    if (_passengers.Count > 0 && GetLightMode == 0 && !IsDayTime()) SwtchCbnLght(true);
                }
            }

            private void OnTriggerExit(Collider other)
            {
                if ((other.gameObject.layer & 17) > 0)
                {
                    BasePlayer component = other.gameObject.GetComponent<BasePlayer>();
                    if (component != null && _passengers.Contains(component))
                    {
                        _passengers.Remove(component);
                        (component as BaseEntity).SetParent(null, true, true);
                        if (component != null)
                        {
                            component.PauseFlyHackDetection(5f);
                            component.PauseSpeedHackDetection(5f);
                        }

                        controlUI.DestroyUi(component);
                        _holdDoorTriggered = true;
                        StartIdleClose();
                    }

                    if (_passengers.Count == 0)
                    {
                        CancelInvoke(SleepWatch);
                        SleepTriggered = false;
                        if (GetLightMode == 0) SwtchCbnLght(false);
                    }
                }
            }

            public int GetFuel()
            {
                ItemContainer inv = null;
                if (_power == PowerState.Internal)
                {
                    inv = recyclerBox.inventory;
                    return inv.GetAmount(-946369541, false);
                }
                else
                {
                    if (buildingPrivilege == null) GetBuilding();
                    if (buildingPrivilege == null) return 0;
                    inv = buildingPrivilege.inventory;
                    return inv.GetAmount(-946369541, false);
                }
            }

            public Item GetFuelItem()
            {
                ItemContainer inv = null;
                if (_power == PowerState.Internal)
                {
                    inv = recyclerBox.inventory;
                }
                else
                {
                    if (buildingPrivilege == null) GetBuilding();
                    if (buildingPrivilege == null) return null;
                    inv = buildingPrivilege.inventory;
                }

                Item fuelItem = inv.FindItemByItemID(-946369541);
                if (fuelItem == null) return null;
                if (fuelItem.amount == 1) fuelItem.DoRemove();
                else fuelItem.amount--;
                return ItemManager.CreateByItemID(-946369541, 1);
            }

            public bool InsertFuel(Item item)
            {
                ItemContainer inv = null;
                if (_power == PowerState.Internal)
                {
                    inv = recyclerBox.inventory;
                }
                else
                {
                    if (buildingPrivilege == null) GetBuilding();
                    if (buildingPrivilege == null) inv = recyclerBox.inventory;
                    else inv = buildingPrivilege.inventory;
                }

                if (inv.maxStackSize <= 0)
                {
                    if (item.MoveToContainer(inv, -1, true)) return true;
                }
                else
                {
                    int hasAmount = inv.GetAmount(-946369541, false);
                    int maxAmount = inv.capacity * inv.maxStackSize;
                    if (hasAmount >= maxAmount)
                    {
                        WithDrawFuel(item);
                        return false;
                    }

                    foreach (Item slot in inv.FindItemsByItemID(-946369541).ToList<Item>())
                    {
                        inv.itemList.Remove(slot);
                        slot.Remove(0f);
                    }

                    ItemManager.DoRemoves();
                    int inputAmount = item.amount + hasAmount;
                    for (int i = 0; i < inv.capacity; i++)
                    {
                        Item slot = ItemManager.CreateByItemID(-946369541, Math.Min(inv.maxStackSize, inputAmount));
                        inv.itemList.Add(slot);
                        slot.parent = inv;
                        inputAmount -= slot.amount;
                        if (inputAmount <= 0)
                        {
                            inv.MarkDirty();
                            return true;
                        }
                    }

                    item.amount = inputAmount;
                    WithDrawFuel(item);
                }

                return false;
            }

            public void WithDrawFuel(Item item)
            {
                fuelBox.inventory.itemList.Add(item);
                item.parent = fuelBox.inventory;
                item.position = fuelBox.mailInputSlot;
                item.MarkDirty();
                fuelBox.inventory.MarkDirty();
            }

            private void GetBuilding()
            {
                baseBuilding = BuildingManager.server.GetBuilding((groundBlock as DecayEntity).buildingID);
                if (baseBuilding.HasBuildingPrivileges())
                    buildingPrivilege = baseBuilding.GetDominatingBuildingPrivilege();
            }

            public bool FuelCheck()
            {
                if (!enableFuel || lastUser != null && IsAdm(lastUser)) return true;
                int floors = _direction == MoveDirection.Up
                    ? DestinationFloor - CurrentFloor
                    : CurrentFloor - DestinationFloor;
                int needFuel = floors * fuelConsume;
                if (GetFuel() < needFuel) return false;
                ItemContainer inv = null;
                if (_power == PowerState.TC)
                    inv = buildingPrivilege.gameObject.GetComponent<StorageContainer>().inventory;
                else inv = recyclerBox.gameObject.GetComponent<StorageContainer>().inventory;
                List<Item> list = inv.FindItemsByItemID(-946369541).ToList<Item>();
                if (list == null || list.Count == 0) return false;
                foreach (Item current in list)
                {
                    int num = needFuel;
                    int num2 = 0;
                    while (num2 < num && current.amount > 0)
                    {
                        current.UseItem(1);
                        num2++;
                    }

                    if (num2 == num) return true;
                }

                return false;
            }

            public bool PreFuelCheck(int curr, int dest)
            {
                if (!enableFuel || lastUser != null && IsAdm(lastUser)) return true;
                int needFuel = fuelConsume * (curr < dest ? dest - curr : curr - dest);
                if (GetFuel() < needFuel) return false;
                return true;
            }

            private void SetStates()
            {
                if (!enableFuel) _power = PowerState.FoC;
                DefineShareMode();
                SetUpKeep(false);
            }

            public void IntFlrStps()
            {
                stops = new Vector3[ArrSum];
                stops[LowerFloor] = lift.transform.position;
                for (int i = LowerFloor + 1; i < ArrSum; i++)
                    stops[i] = stops[LowerFloor] + new Vector3(0, 3f * ((float) i - LowerFloor), 0);
            }

            public void GtFlrStps()
            {
                stops = new Vector3[ArrSum];
                Vector3 startPos = lift.transform.position;
                startPos.y = initialHeight;
                stops[LowerFloor] = startPos;
                for (int i = LowerFloor + 1; i < ArrSum; i++)
                    stops[i] = stops[LowerFloor] + new Vector3(0, 3f * ((float) i - LowerFloor), 0);
            }

            public void IntScktrdr()
            {
                int startAt = startSock;
                for (int j = 1; j < 5; j++)
                {
                    socketOrder[j] = startAt;
                    if (startAt >= 4) startAt = 1;
                    else startAt++;
                }
            }

            private void GtScktPnts()
            {
                Construction construction = (groundBlock as BuildingBlock).blockDefinition;
                int i = 1;
                foreach (Socket_Base socket in construction.allSockets.Where(s =>
                    s is ConstructionSocket && (s as ConstructionSocket).socketType == ConstructionSocket.Type.Wall))
                {
                    int o = socketOrder[i];
                    socketPoints[o] = groundBlock.transform.localToWorldMatrix.MultiplyPoint3x4(socket.position);
                    i++;
                }
            }

            private void PayInForShaft(List<ItemAmount> collectAmounts, BasePlayer player)
            {
                if (!(bool) GetAccess("EnableBuildCost", player.UserIDString, true)) return;
                List<Item> list = new List<Item>();
                foreach (ItemAmount current in collectAmounts)
                {
                    player.inventory.Take(list, current.itemDef.itemid, (int) current.amount);
                    player.Command(r("abgr.vai"), new object[] {current.itemDef.itemid, current.amount * -1f});
                }

                foreach (Item current2 in list) current2.Remove(0f);
            }

            public List<ItemAmount> GetPartsCost(int grade, int setFloors, char[] placeDoors, float costMulti)
            {
                List<ItemAmount> collectAmounts = new List<ItemAmount>();
                for (int floor = 1; floor < setFloors + 1; floor++)
                {
                    bool hasDoor = floor == UpperFloor
                        ? true
                        : Convert.ToBoolean(Convert.ToInt32(placeDoors[floor].ToString()));
                    if (hasDoor)
                    {
                        foreach (ItemAmount current in CostForPart(grade, 919059809))
                            if (collectAmounts.Any((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid))
                                collectAmounts
                                    .FirstOrDefault((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid)
                                    .amount += Mathf.Ceil(current.amount * costMulti);
                            else
                                collectAmounts.Add(new ItemAmount(current.itemDef,
                                    Mathf.Ceil(current.amount * costMulti)));
                        foreach (ItemAmount current in CostForObject(3647679950))
                            if (collectAmounts.Any((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid))
                                collectAmounts
                                    .FirstOrDefault((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid)
                                    .amount += Mathf.Ceil(current.amount * costMulti);
                            else
                                collectAmounts.Add(new ItemAmount(current.itemDef,
                                    Mathf.Ceil(current.amount * costMulti)));
                    }

                    float wallCount = hasDoor ? 3f : 4f;
                    foreach (ItemAmount current in CostForPart(grade, 2194854973))
                        if (collectAmounts.Any((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid))
                            collectAmounts.FirstOrDefault((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid)
                                    .amount += Mathf.Ceil(current.amount * costMulti) * wallCount;
                        else
                            collectAmounts.Add(new ItemAmount(current.itemDef,
                                Mathf.Ceil(current.amount * costMulti) * wallCount));
                }

                return collectAmounts;
            }

            private List<ItemAmount> CostForObject(uint prefabID)
            {
                Construction construction = PrefabAttribute.server.Find<Construction>(prefabID);
                return GameManager.server.FindPrefab(construction.fullName).GetComponent<BaseCombatEntity>()
                    .BuildCost();
            }

            private List<ItemAmount> CostForPart(int gradeNum, uint prefabID)
            {
                Construction construction = PrefabAttribute.server.Find<Construction>(prefabID);
                List<ItemAmount> fullAmount = new List<ItemAmount>();
                foreach (ItemAmount current in construction.defaultGrade.costToBuild)
                    if (fullAmount.Any((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid))
                        fullAmount.FirstOrDefault((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid)
                            .amount += current.amount;
                    else fullAmount.Add(new ItemAmount(current.itemDef, current.amount));
                foreach (ItemAmount current in construction.grades[gradeNum].costToBuild)
                    if (fullAmount.Any((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid))
                        fullAmount.FirstOrDefault((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid)
                            .amount += current.amount;
                    else fullAmount.Add(new ItemAmount(current.itemDef, current.amount));
                return fullAmount;
            }

            private void AddCbnLght()
            {
                cabinLight = (SimpleLight) GameManager.server.CreateEntity(StringPool.Get(1523703314),
                    lift.transform.position, default(Quaternion), true);
                if (cabinLight == null) return;
                cabinLight.SetParent(lift, 0);
                cabinLight.transform.localPosition = new Vector3(0f, -0.25f, -0.35f);
                cabinLight.transform.localRotation = Quaternion.Euler(60f, 0f, 0f);
                cabinLight.SetFlag(BaseEntity.Flags.Reserved8, true);
                cabinLight.SetFlag(BaseEntity.Flags.On, false);
                cabinLight.Spawn();
                FtCmpnnts(cabinLight);
            }

            private void AddFlrGrll()
            {
                floorGrill = (SimpleBuildingBlock)GameManager.server.CreateEntity(StringPool.Get(2480303744), lift.transform.position, Quaternion.identity, true);
                floorGrill.SetParent(lift, 0);
                floorGrill.transform.localPosition = new Vector3(0f, -0.4f, 0f);
                floorGrill.transform.localRotation = Quaternion.Euler(0f, lift.transform.eulerAngles.y + 45f, 0f);
                floorGrill.enableSaving = false;
                floorGrill.grounded = true;                
                floorGrill.Spawn();
                floorGrill.grounded = true;
                FtCmpnnts(floorGrill);
            }

            private void GtCbnLght()
            {
                foreach (BaseEntity child in lift.children.ToList())
                {
                    if (child is BaseFuelLightSource)
                    {
                        child.KillMessage();
                        AddCbnLght();
                        return;
                    }

                    if (child is SimpleLight) cabinLight = child as SimpleLight;
                }

                if (cabinLight == null)
                {
                    AddCbnLght();
                    return;
                }

                cabinLight.SetFlag(BaseEntity.Flags.Reserved8, true);
                cabinLight.SetFlag(BaseEntity.Flags.On, false);
                cabinLight.transform.localPosition = new Vector3(0f, -0.25f, -0.35f);
                cabinLight.transform.localRotation = Quaternion.Euler(60f, 0f, 0f);
                FtCmpnnts(cabinLight);
                cabinLight.SendNetworkUpdateImmediate();
            }

            private void FtCmpnnts(BaseEntity entity)
            {
                if (entity.net != null) crossReference[entity.net.ID] = this;
                if (entity is ProceduralLift)
                {
                    Transform antihack_volume = entity.gameObject.transform.Find("antihack_volume");
                    if (antihack_volume)
                    {
                        antihack_volume.SetParent(null);
                        Destroy(antihack_volume.GetComponent<BoxCollider>());
                        Destroy(antihack_volume.GetComponent<EnvironmentVolume>());
                    }

                    return;
                }

                if (entity is BaseCombatEntity) toBeProtected.Add(entity.net.ID);
                if (entity is Door) FillUppSlot(entity as Door);
                foreach (BoxCollider c in entity.GetComponents<BoxCollider>().ToList()) Destroy(c);
                foreach (MeshCollider c in entity.GetComponents<MeshCollider>().ToList()) Destroy(c);
                Destroy(entity.GetComponent<DestroyOnGroundMissing>());
                Destroy(entity.GetComponent<GroundWatch>());               
            }

            private void AddRcclr()
            {
                recyclerBox = (Recycler) GameManager.server.CreateEntity(StringPool.Get(1729604075),
                    lift.transform.position, default(Quaternion), true);
                if (recyclerBox == null) return;
                recyclerBox.SetParent(lift, 0);
                recyclerBox.transform.localPosition = new Vector3(0f, -3.75f, 0f);
                recyclerBox.transform.localRotation = Quaternion.Euler(90, 0, 0);
                recyclerBox.allowedItem = ItemManager.FindItemDefinition(-946369541);
                recyclerBox.onlyAcceptCategory = ItemCategory.Resources;
                recyclerBox.inventorySlots = (int) GetAccess("FuelStorageItemSlots", ownerID.ToString(), 2, true);
                recyclerBox.maxStackSize = (int) GetAccess("FuelStorageStackSize", ownerID.ToString(), 500, true);
                recyclerBox.Spawn();
                FtCmpnnts(recyclerBox);
                cabinComfort = recyclerBox.gameObject.AddComponent<CabinComfort>();
                cabinComfort.Setup(recyclerBox as BaseEntity,
                    (int) GetAccess("BaseComfort", ownerID.ToString(), 0, true),
                    (int) GetAccess("BaseTemperature", ownerID.ToString(), 0, true));
                recyclerBox.SetFlag(BaseEntity.Flags.Busy, true);
            }

            private void GtRcclr()
            {
                recyclerBox = null;
                foreach (BaseEntity child in lift.children)
                    if (child is Recycler)
                    {
                        recyclerBox = child as Recycler;
                        break;
                    }

                if (recyclerBox == null)
                {
                    AddRcclr();
                    return;
                }

                recyclerBox.transform.localPosition = new Vector3(0f, -3.75f, 0f);
                recyclerBox.transform.localRotation = Quaternion.Euler(90, 0, 0);
                recyclerBox.SendNetworkUpdate();
                FtCmpnnts(recyclerBox);
                recyclerBox.inventory.onlyAllowedItem = ItemManager.FindItemDefinition(-946369541);
                recyclerBox.onlyAcceptCategory = ItemCategory.Resources;
                cabinComfort = recyclerBox.gameObject.AddComponent<CabinComfort>();
                cabinComfort.Setup(recyclerBox as BaseEntity,
                    (int) GetAccess("BaseComfort", ownerID.ToString(), 0, true),
                    (int) GetAccess("BaseTemperature", ownerID.ToString(), 0, true));
                recyclerBox.SetFlag(BaseEntity.Flags.Busy, true);
            }

            private void AddCbnLck()
            {
                cabinLock = (CodeLock) GameManager.server.CreateEntity(StringPool.Get(3518824735),
                    lift.transform.position, default(Quaternion), true);
                if (cabinLock == null) return;
                cabinLock.SetParent(lift, 0);
                cabinLock.transform.localPosition = new Vector3(-0.81f, -2f, 1.45f);
                cabinLock.transform.localRotation = Quaternion.Euler(0, 90, 0);
                cabinLock.SetFlag(BaseEntity.Flags.Busy, true);
                cabinLock.Spawn();
            }

            private void GtCbnLck()
            {
                cabinLock = null;
                foreach (BaseEntity child in lift.children)
                    if (child is CodeLock)
                    {
                        cabinLock = child as CodeLock;
                        break;
                    }

                if (cabinLock == null)
                {
                    AddCbnLck();
                    return;
                }

                cabinLock.transform.localPosition = new Vector3(-0.81f, -2f, 1.45f);
                cabinLock.transform.localRotation = Quaternion.Euler(0, 90, 0);
                cabinLock.SetFlag(BaseEntity.Flags.Busy, true);
                DstryOnClnt(cabinLock);
                cabinLock.SendNetworkUpdateImmediate();
            }

            private void AddFuelBox()
            {
                fuelBox = (Mailbox) GameManager.server.CreateEntity(StringPool.Get(661881069), lift.transform.position,
                    default(Quaternion), true);
                if (fuelBox == null) return;
                fuelBox.OwnerID = ownerID;
                fuelBox.SetParent(lift, 0);
                fuelBox.transform.localPosition = new Vector3(0.9f, -3.8f, 0.9f);
                fuelBox.transform.localRotation = Quaternion.Euler(-90, 0, 180);
                fuelBox.allowedItem = ItemManager.FindItemDefinition(-946369541);
                fuelBox.onlyAcceptCategory = ItemCategory.Resources;
                fuelBox.needsBuildingPrivilegeToUse = false;
                fuelBox.Spawn();
                fuelBox.inventory.onItemAddedRemoved = new Action<Item, bool>(OnDropBoxAdded);
                FtCmpnnts(fuelBox);
                fuelBox.SetFlag(BaseEntity.Flags.Locked, !enableFuel);
            }

            private void OnDropBoxAdded(Item item, bool added)
            {
                if (!added || item == null) return;
                fuelBox.inventory.itemList.Remove(item);
                fuelBox.inventory.MarkDirty();
                InsertFuel(item);
                Effect.server.Run(fuelBox.mailDropSound.resourcePath, fuelBox.GetDropPosition(), default(Vector3), null,
                    false);
                bool isAdmin = ClsDrpBx(fuelBox);
            }

            private void GetFuelBox()
            {
                foreach (BaseEntity child in lift.children)
                    if (child is Mailbox)
                    {
                        fuelBox = child as Mailbox;
                        break;
                    }

                if (fuelBox == null)
                {
                    AddFuelBox();
                    return;
                }

                fuelBox.allowedItem = ItemManager.FindItemDefinition(-946369541);
                fuelBox.inventory.onlyAllowedItem = ItemManager.FindItemDefinition(-946369541);
                fuelBox.onlyAcceptCategory = ItemCategory.Resources;
                fuelBox.needsBuildingPrivilegeToUse = false;
                fuelBox.inventory.onItemAddedRemoved = new Action<Item, bool>(OnDropBoxAdded);
                fuelBox.SetFlag(BaseEntity.Flags.Locked, !enableFuel);
                FtCmpnnts(fuelBox);
            }

            private void DstryOnClnt(BaseEntity entity)
            {
                if (Net.sv.write.Start())
                {
                    Net.sv.write.PacketID(Message.Type.EntityDestroy);
                    Net.sv.write.UInt32(entity.net.ID);
                    Net.sv.write.UInt8(0);
                    Net.sv.write.Send(new SendInfo(entity.net.group.subscribers));
                }
            }

            private void AddFlrLght(BaseEntity parentEnt)
            {
                CardReader r = (CardReader) GameManager.server.CreateEntity(StringPool.Get(1841596500),
                    default(Vector3), default(Quaternion), true);
                if (r != null)
                {
                    r.SetParent(parentEnt, 0);
                    r.OwnerID = ownerID;
                    r.transform.localPosition = new Vector3(-0.09f, 0.2f, -1.3f);
                    r.transform.localRotation = Quaternion.Euler(0, -90, 0);
                    r.SetFlag(BaseEntity.Flags.Reserved8, true);
                    r.accessLevel = -1;
                    r.Spawn();
                    FtCmpnnts(r);
                    parentEnt.SetSlot(BaseEntity.Slot.Lock, r);
                    r.SetFlag(r.AccessLevel1, false);
                    r.SetFlag(r.AccessLevel2, false);
                    r.SetFlag(r.AccessLevel3, true);
                }
            }

            private void GetFlrLght(BaseEntity slot)
            {
                slot.transform.localPosition = new Vector3(-0.09f, 0.2f, -1.3f);
                slot.transform.localRotation = Quaternion.Euler(0, -90, 0);
                FtCmpnnts(slot);
                CardReader r = slot as CardReader;
                if (r)
                {
                    r.SetFlag(BaseEntity.Flags.Reserved8, true);
                    r.accessLevel = -1;
                    r.SetFlag(r.AccessLevel1, false);
                    r.SetFlag(r.AccessLevel2, false);
                    r.SetFlag(r.AccessLevel3, true);
                }

                DstryOnClnt(slot);
                slot.SendNetworkUpdateImmediate();
            }

            private void RmvBsmnt(bool liftOnly = false)
            {
                CancelInvoke(DoIdleClose);
                if (liftOnly)
                {
                    StartCoroutine(SoftDestroy());
                    return;
                }

                StartCoroutine(RemoveShaft(done =>
                {
                    if (done) calledDestroy = true;
                    Destroy(this);
                }));
            }

            private IEnumerator RemoveShaft(Action<bool> done)
            {
                List<ItemAmount> collectAmounts = new List<ItemAmount>();
                if (roofBlock)
                {
                    if (!roofBlock.IsDestroyed) roofBlock.Kill(BaseNetworkable.DestroyMode.None);
                    yield return waitFFU;
                }

                for (int floor = UpperFloor; floor > LowerFloor - 1; floor--)
                for (int i = 1; i < 5; i++)
                {
                    try
                    {
                        if (baseBlocksFloors[floor][i] != null && !baseBlocksFloors[floor][i].IsDestroyed)
                        {
                            Door door = baseBlocksFloors[floor][i]?.FindLinkedEntity<Door>();
                            if (door != null)
                            {
                                crossReference.Remove(door.net.ID);
                                if (door.HasSlot(BaseEntity.Slot.Lock))
                                {
                                    BaseEntity reader = door.GetSlot(BaseEntity.Slot.Lock);
                                    if (reader)
                                        if (!reader.IsDestroyed)
                                            reader.Kill(BaseNetworkable.DestroyMode.None);
                                }

                                if (enableCost)
                                    CollectPayOut(ref collectAmounts, CostForObject(door.prefabID), costMultiplier);
                                if (door != null && !door.IsDestroyed) door.Kill(BaseNetworkable.DestroyMode.None);
                            }

                            if (enableCost)
                                CollectPayOut(ref collectAmounts,
                                    CostForPart((int) (baseBlocksFloors[floor][i] as BuildingBlock).grade,
                                        baseBlocksFloors[floor][i].prefabID), costMultiplier);
                            if (baseBlocksFloors[floor][i] != null && !baseBlocksFloors[floor][i].IsDestroyed)
                                baseBlocksFloors[floor][i].Kill(BaseNetworkable.DestroyMode.None);
                        }
                    }
                    catch
                    {
                    }

                    yield return waitFFU;
                }

                PayOutForPart(collectAmounts);
                if (cabinLight && !cabinLight.IsDestroyed)
                {
                    cabinLight.Kill(BaseNetworkable.DestroyMode.None);
                    yield return waitFFU;
                }

                if (cabinLock && !cabinLock.IsDestroyed)
                {
                    cabinLock.Kill(BaseNetworkable.DestroyMode.None);
                    yield return waitFFU;
                }

                if (recyclerBox && !recyclerBox.IsDestroyed)
                {
                    recyclerBox.Kill(BaseNetworkable.DestroyMode.None);
                    yield return waitFFU;
                }

                if (fuelBox && !fuelBox.IsDestroyed)
                {
                    fuelBox.Kill(BaseNetworkable.DestroyMode.None);
                    yield return waitFFU;
                }

                if (lift && !lift.IsDestroyed)
                {
                    SendEffect(2184296839, lift);
                    crossReference.Remove(lift.net.ID);
                    lift.Kill(BaseNetworkable.DestroyMode.None);
                }

                if (groundBlock)
                {
                    Destroy(groundBlock.gameObject.GetComponent<Prevent_Building>());
                    crossReference.Remove(groundBlock.net.ID);
                }

                Destroy(boxCollider);
                done(true);
            }

            private void CollectPayOut(ref List<ItemAmount> collectAmounts, List<ItemAmount> partAmounts,
                float costMulti = 1.0f)
            {
                foreach (ItemAmount current in partAmounts)
                    if (collectAmounts.Any((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid))
                        collectAmounts.FirstOrDefault((ItemAmount x) => x.itemDef.itemid == current.itemDef.itemid)
                                .amount += current.amount * costMulti;
                    else collectAmounts.Add(new ItemAmount(current.itemDef, current.amount * costMulti));
            }

            private void PayOutForPart(List<ItemAmount> collectAmounts)
            {
                if (ownerPlayer == null)
                {
                    ownerPlayer = BasePlayer.FindByID(ownerID);
                    if (ownerPlayer == null) return;
                }

                foreach (ItemAmount current in collectAmounts)
                {
                    ownerPlayer.Command(r("abgr.vai"), new object[] {current.itemDef.itemid, current.amount});
                    Item item = ItemManager.Create(current.itemDef, (int) current.amount);
                    ownerPlayer.inventory.GiveItem(item);
                }
            }

            private string lastShaftError;

            private IEnumerator CrtNwShft(char[] d, List<ItemAmount> collectAmounts, BasePlayer player, bool hasCost,
                float costMulti, Action<bool> done)
            {
                lastShaftError = string.Empty;
                try
                {
                    GtScktPnts();
                }
                catch
                {
                    lastShaftError = "GetSocketPoints";
                    done(false);
                    yield break;
                }

                yield return waitFFU;
                try
                {
                    AddGrndDr();
                }
                catch
                {
                    lastShaftError = "AddGroundDoor";
                    done(false);
                    yield break;
                }

                yield return waitFFU;
                try
                {
                    AddGrndSds();
                }
                catch
                {
                    lastShaftError = "AddGroundSides";
                    done(false);
                    yield break;
                }

                yield return waitFFU;
                if (hasCost && player) player.ClientRPCPlayer(null, player, r("BaQvrq"));
                for (int floor = LowerFloor + 1; floor < ArrSum; floor++)
                {
                    try
                    {
                        AddFlrFrnt(floor,
                            floor == UpperFloor ? true : Convert.ToBoolean(Convert.ToInt32(d[floor].ToString())));
                    }
                    catch
                    {
                        lastShaftError = $"AddFloorFront Lvl:{floor}";
                        done(false);
                        yield break;
                    }

                    yield return waitFFU;
                    try
                    {
                        AddFlrSds(floor);
                    }
                    catch
                    {
                        lastShaftError = $"AddFloorSides Lvl:{floor}";
                        done(false);
                        yield break;
                    }

                    if (enableCost && player) player.ClientRPCPlayer(null, player, r("BaQvrq"));
                    yield return waitFFU;
                }

                try
                {
                    AddRfTp();
                }
                catch
                {
                    lastShaftError = "AddRoofTop";
                    done(false);
                    yield break;
                }

                try
                {
                    AddCbnLght();
                    SwtchCbnLght(false);
                }
                catch
                {
                    lastShaftError = "AddCabinLight";
                    done(false);
                    yield break;
                }

                try
                {
                    AddRcclr();
                }
                catch
                {
                    lastShaftError = "AddRecycler";
                    done(false);
                    yield break;
                }

                try
                {
                    AddCbnLck();
                }
                catch
                {
                    lastShaftError = "AddCbnLck";
                    done(false);
                    yield break;
                }

                try
                {
                    AddFuelBox();
                }
                catch
                {
                    lastShaftError = "AddFuelBox";
                    yield break;
                }

                SetupCollider();
                if (hasCost && player) player.ClientRPCPlayer(null, player, r("BaQvrq"));
                if (hasCost && player) PayInForShaft(collectAmounts, player);
                Invoke(DoIdleClose, (float) closeTime);
                controlUI = new LiftUI();
                controlUI.Init(this, lift.net.ID);
                OnReady();
                done(true);
                yield return null;
            }

            private bool AddGrndDr()
            {
                baseBlocksFloors = new BaseEntity[ArrSum][];
                for (int floor = LowerFloor; floor < ArrSum; floor++) baseBlocksFloors[floor] = new BaseEntity[5];
                EntityLink link = GtLnk(groundBlock, socketOrder[1]);
                BaseEntity baseBlock = AddWllFrm(groundBlock, link);
                baseBlocksFloors[LowerFloor][1] = baseBlock;
                BaseEntity baseFill = AddGrgDr(baseBlock);
                AddFlrLght(baseFill);
                doors[LowerFloor] = baseFill as Door;
                FillUppSlot(doors[LowerFloor]);
                doors[LowerFloor].knockEffect.guid = knockEffectGuid;
                crossReference[baseFill.net.ID] = this;
                baseFill.SetFlag(BaseEntity.Flags.Locked, true);
                baseFill.SetFlag(BaseEntity.Flags.Open, true);
                SwtchFlrLght(baseFill, 1);
                return true;
            }

            private void GtGrndDr()
            {
                baseBlocksFloors = new BaseEntity[ArrSum][];
                for (int floor = LowerFloor; floor < ArrSum; floor++) baseBlocksFloors[floor] = new BaseEntity[5];
                EntityLink link = GtLnk(groundBlock, socketOrder[1]);
                if (link.IsOccupied())
                {
                    baseBlocksFloors[LowerFloor][1] = link.connections.First().owner;
                    FtCmpnnts(baseBlocksFloors[LowerFloor][1]);
                    if (baseBlocksFloors[LowerFloor][1].FindLinkedEntity<Door>() == null)
                    {
                        BaseEntity baseFill = AddGrgDr(baseBlocksFloors[LowerFloor][1]);
                        AddFlrLght(baseFill);
                        doors[LowerFloor] = baseFill as Door;
                        FillUppSlot(doors[LowerFloor]);
                        doors[LowerFloor].knockEffect.guid = knockEffectGuid;
                    }
                }
                else
                {
                    AddGrndDr();
                }
            }

            private void AddRfTp()
            {
                BaseEntity baseBlock;
                EntityLink link = GtLnkRf(baseBlocksFloors[UpperFloor][3], 1);
                if (link.IsOccupied())
                {
                    DstryOnClnt(link.connections.First().owner);
                    baseBlock = link.connections.First().owner;
                    roofBlock = baseBlock;
                    FtCmpnnts(baseBlock);
                    return;
                }

                baseBlock = AddTpFlr(baseBlocksFloors[UpperFloor][3], link);
                roofBlock = baseBlock;
            }

            private void GtRfTp()
            {
                EntityLink link = GtLnkRf(baseBlocksFloors[UpperFloor][3], 1);
                if (link.IsOccupied())
                {
                    BaseEntity baseBlock = link.connections.First().owner;
                    roofBlock = baseBlock;
                    FtCmpnnts(baseBlock);
                }
                else
                {
                    AddRfTp();
                }
            }

            private bool AddGrndSds()
            {
                for (int side = 2; side < 5; side++)
                {
                    EntityLink link = GtLnk(groundBlock, socketOrder[side]);
                    if (link.IsOccupied())
                    {
                        link.connections.First().owner.Kill(BaseNetworkable.DestroyMode.None);
                        link.Clear();
                    }

                    BaseEntity baseBlock = AddWllSd(groundBlock, link);
                    baseBlocksFloors[LowerFloor][side] = baseBlock;
                }

                return true;
            }

            private void GtGrndSds()
            {
                for (int side = 2; side < 5; side++)
                {
                    EntityLink link = GtLnk(groundBlock, socketOrder[side]);
                    if (link.IsOccupied())
                    {
                        baseBlocksFloors[LowerFloor][side] = link.connections.First().owner;
                        FtCmpnnts(baseBlocksFloors[LowerFloor][side]);
                    }
                    else
                    {
                        BaseEntity baseBlock = AddWllSd(groundBlock, link);
                        baseBlocksFloors[LowerFloor][side] = baseBlock;
                    }
                }
            }

            private bool ClnnnrFlr(int level)
            {
                EntityLink fLink = GtLnkRf(baseBlocksFloors[level - 1][1], 2);
                if (fLink.IsOccupied())
                {
                    BaseEntity owner = fLink.connections.First().owner;
                    if (owner.transform.position.x == groundBlock.transform.position.x &&
                        owner.transform.position.z == groundBlock.transform.position.z)
                    {
                        owner.Kill(BaseNetworkable.DestroyMode.None);
                        fLink.Clear();
                        return true;
                    }
                }

                fLink = GtLnkRf(baseBlocksFloors[level - 1][1], 1);
                if (fLink.IsOccupied())
                {
                    BaseEntity owner = fLink.connections.First().owner;
                    if (owner.transform.position.x == groundBlock.transform.position.x &&
                        owner.transform.position.z == groundBlock.transform.position.z)
                    {
                        owner.Kill(BaseNetworkable.DestroyMode.None);
                        fLink.Clear();
                        return true;
                    }
                }

                return false;
            }

            private bool AddFlrFrnt(int level, bool isDoor)
            {
                EntityLink link = GtLnk(baseBlocksFloors[level - 1][1]);
                if (link.IsOccupied())
                {
                    link.connections.First().owner.Kill(BaseNetworkable.DestroyMode.None);
                    link.Clear();
                }

                BaseEntity baseBlock = null;
                if (isDoor)
                {
                    baseBlock = AddWllFrm(baseBlocksFloors[level - 1][1], link);
                    baseBlock.transform.rotation = baseBlocksFloors[LowerFloor][1].transform.rotation;
                    BaseEntity baseFill = null;
                    baseFill = AddGrgDr(baseBlock);
                    AddFlrLght(baseFill);
                    doors[level] = baseFill as Door;
                    FillUppSlot(doors[level]);
                    doors[level].knockEffect.guid = knockEffectGuid;
                    baseFill.SetFlag(BaseEntity.Flags.Locked, true, false);
                    crossReference[baseFill.net.ID] = this;
                }
                else
                {
                    baseBlock = AddWllSd(baseBlocksFloors[level - 1][1], link);
                    baseBlock.transform.rotation = baseBlocksFloors[LowerFloor][1].transform.localRotation *
                                                   Quaternion.Euler(0, 180f, 0);
                }

                baseBlock.SendNetworkUpdateImmediate();
                baseBlock.ClientRPC(null, r("ErserfuFxva"));
                baseBlocksFloors[level][1] = baseBlock;
                return true;
            }

            private void FillUppSlot(Door door)
            {
                if (door == null) return;
                if (door.GetSlot(BaseEntity.Slot.UpperModifier) is TreeMarker) return;
                door.GetSlot(BaseEntity.Slot.UpperModifier)?.Kill();
                BaseEntity marker = GameManager.server.CreateEntity(StringPool.Get(954334883), new Vector3(),
                    new Quaternion(), true);
                if (marker == null) return;
                marker.Spawn();
                door.SetSlot(BaseEntity.Slot.UpperModifier, marker);
                door.canTakeCloser = false;
            }

            private void GtFlrFrnt(int level)
            {
                if (baseBlocksFloors[level - 1][1] == null) return;
                EntityLink link = GtLnk(baseBlocksFloors[level - 1][1]);
                if (link != null && link.IsOccupied())
                {
                    baseBlocksFloors[level][1] = link.connections.First().owner;
                    FtCmpnnts(baseBlocksFloors[level][1]);
                    if (baseBlocksFloors[level][1].prefabID == 919059809 &&
                        baseBlocksFloors[level][1].FindLinkedEntity<Door>() == null)
                    {
                        BaseEntity baseFill = AddGrgDr(baseBlocksFloors[level][1]);
                        AddFlrLght(baseFill);
                        doors[level] = baseFill as Door;
                        FillUppSlot(doors[level]);
                        doors[level].knockEffect.guid = knockEffectGuid;
                        baseFill.SetFlag(BaseEntity.Flags.Locked, true);
                        if (CurrentFloor == level) baseFill.SetFlag(BaseEntity.Flags.Open, true);
                    }
                    else
                    {
                        FillUppSlot(doors[level]);
                    }
                }
                else
                {
                    BaseEntity baseBlock = null;
                    baseBlock = AddWllSd(baseBlocksFloors[level - 1][1], link);
                    baseBlock.transform.rotation = baseBlocksFloors[LowerFloor][1].transform.localRotation *
                                                   Quaternion.Euler(0, 180f, 0);
                    baseBlock.ClientRPC(null, r("ErserfuFxva"));
                    baseBlocksFloors[level][1] = baseBlock;
                }
            }

            private IEnumerator SwtchFlrFrnt(BasePlayer player, int level, bool hasDoor, Door door)
            {
                if (baseBlocksFloors[level - 1][1] == null) yield break;
                EntityLink link = GtLnk(baseBlocksFloors[level - 1][1]);
                if (link != null && link.IsOccupied())
                {
                    BaseEntity getBlock = link.connections.First().owner;
                    if (getBlock.prefabID == 919059809)
                    {
                        if (enableCost)
                        {
                            List<ItemAmount> collect = new List<ItemAmount>();
                            CollectPayOut(ref collect, CostForPart(3, 2194854973), costMultiplier);
                            if ((bool) GetAccess("EnableBuildCost", player.UserIDString))
                                foreach (ItemAmount collectAmount in collect)
                                {
                                    float have = (float) player.inventory.GetAmount(collectAmount.itemDef.itemid);
                                    if (have < collectAmount.amount)
                                    {
                                        SendEffect(3618221308, lift);
                                        yield break;
                                    }
                                }

                            PayInForShaft(collect, player);
                        }

                        Door getDoor = getBlock.FindLinkedEntity<Door>();
                        if (getDoor != null)
                        {
                            if (getDoor.HasSlot(BaseEntity.Slot.Lock))
                            {
                                BaseEntity reader = getDoor.GetSlot(BaseEntity.Slot.Lock);
                                if (reader != null)
                                {
                                    reader.Kill();
                                    yield return waitFOF;
                                }
                            }

                            doors[level] = null;
                            getDoor.Kill();
                            yield return waitFOF;
                        }

                        Effect.server.Run(StringPool.Get(2676581608), getBlock, 0u, Vector3.zero, Vector3.zero, null,
                            false);
                        getBlock.Kill();
                        AddFlrFrnt(level, !hasDoor);
                        controlUI.CrtSttngsUI(player);
                        yield break;
                    }
                    else if (getBlock.prefabID == 2194854973)
                    {
                        if (enableCost)
                        {
                            List<ItemAmount> collect = new List<ItemAmount>();
                            CollectPayOut(ref collect, CostForPart(3, 919059809), costMultiplier);
                            CollectPayOut(ref collect, CostForObject(3647679950), costMultiplier);
                            if ((bool) GetAccess("EnableBuildCost", player.UserIDString))
                                foreach (ItemAmount collectAmount in collect)
                                {
                                    float have = (float) player.inventory.GetAmount(collectAmount.itemDef.itemid);
                                    if (have < collectAmount.amount)
                                    {
                                        SendEffect(3618221308, lift);
                                        yield break;
                                    }
                                }

                            PayInForShaft(collect, player);
                        }

                        Effect.server.Run(StringPool.Get(2676581608), getBlock, 0u, Vector3.zero, Vector3.zero, null,
                            false);
                        getBlock.Kill();
                        AddFlrFrnt(level, !hasDoor);
                        controlUI.CrtSttngsUI(player);
                        yield break;
                    }
                }
            }

            private bool AddFlrSds(int level)
            {
                for (int side = 2; side < 5; side++)
                {
                    EntityLink link = GtLnk(baseBlocksFloors[level - 1][side]);
                    if (link.IsOccupied())
                    {
                        link.connections.First().owner.Kill(BaseNetworkable.DestroyMode.None);
                        link.Clear();
                    }

                    BaseEntity baseBlock = AddWllSd(baseBlocksFloors[level - 1][side], link);
                    baseBlocksFloors[level][side] = baseBlock;
                }

                return true;
            }

            private void GtFlrSds(int level)
            {
                for (int side = 2; side < 5; side++)
                {
                    if (baseBlocksFloors[level - 1][side] == null) continue;
                    EntityLink link = GtLnk(baseBlocksFloors[level - 1][side]);
                    if (link != null && link.IsOccupied())
                    {
                        baseBlocksFloors[level][side] = link.connections.First().owner;
                        FtCmpnnts(baseBlocksFloors[level][side]);
                    }
                    else
                    {
                        BaseEntity baseBlock = AddWllSd(baseBlocksFloors[level - 1][side], link);
                        baseBlocksFloors[level][side] = baseBlock;
                    }
                }
            }

            private EntityLink GtLnk(BaseEntity block, int num = 0)
            {
                return block.GetEntityLinks()?.FirstOrDefault((EntityLink e) =>
                    e.socket.socketName.EndsWith(r("jnyy-srznyr")) ||
                    e.socket.socketName.EndsWith($"{r("senzr-srznyr")}/{num}") ||
                    e.socket.socketName.EndsWith($"{r("jnyy-srznyr")}/{num}"));
            }

            private EntityLink GtLnkRf(BaseEntity block, int num = 0)
            {
                return block.GetEntityLinks()?.FirstOrDefault((EntityLink e) =>
                    e.socket.socketName.EndsWith(r("sybbe-srznyr")) ||
                    e.socket.socketName.EndsWith($"{r("sybbe-srznyr")}/{num}"));
            }

            private BaseEntity AddWllSd(BaseEntity placeOn, EntityLink link)
            {
                Construction construction = PrefabAttribute.server.Find<Construction>(2194854973);
                Construction.Target target = default(Construction.Target);
                target.socket = link.socket;
                if (placeOn.prefabID == 72949757 || placeOn.prefabID == 916411076)
                    target.rotation += Quaternion.Euler(0, 180f, 0).eulerAngles;
                target.entity = placeOn;
                BaseEntity baseEntity = CrtCnstrctn(target, construction);
                if (ObjctFnlzd(baseEntity)) return baseEntity;
                return null;
            }

            private BaseEntity AddTpFlr(BaseEntity placeOn, EntityLink link)
            {
                Construction construction = PrefabAttribute.server.Find<Construction>(916411076);
                Construction.Target target = default(Construction.Target);
                target.socket = link.socket;
                target.entity = placeOn;
                BaseEntity baseEntity = CrtCnstrctn(target, construction);
                if (ObjctFnlzd(baseEntity)) return baseEntity;
                return null;
            }

            private BaseEntity AddWllFrm(BaseEntity placeOn, EntityLink link)
            {
                Construction construction = PrefabAttribute.server.Find<Construction>(919059809);
                Construction.Target target = default(Construction.Target);
                if (link.IsOccupied())
                {
                    link.connections.First().owner.Kill(BaseNetworkable.DestroyMode.None);
                    link.Clear();
                }

                target.socket = link.socket;
                target.entity = placeOn;
                BaseEntity baseEntity = CrtCnstrctn(target, construction);
                if (ObjctFnlzd(baseEntity)) return baseEntity;
                return null;
            }

            private BaseEntity AddGrgDr(BaseEntity placeOn)
            {
                Construction construction = PrefabAttribute.server.Find<Construction>(3647679950);
                Construction.Target target = default(Construction.Target);
                Socket_Base[] source = PrefabAttribute.server.FindAll<Socket_Base>(placeOn.prefabID);
                target.socket = source.FirstOrDefault((Socket_Base s) =>
                    s.socketName == $"{placeOn.ShortPrefabName}{r("/fbpxrgf/senzr-srznyr/1")}");
                EntityLink link = placeOn.FindLink(target.socket);
                if (link.IsOccupied())
                {
                    if (link.connections.First().owner.ShortPrefabName == r("jnyy.senzr.tnentrqbbe"))
                    {
                        return link.connections.First().owner;
                    }
                    else
                    {
                        DstryOnClnt(link.connections.First().owner);
                        link.connections.First().owner.Kill();
                    }
                }

                target.entity = placeOn;
                BaseEntity baseEntity = CrtCnstrctn(target, construction);
                if (ObjctFnlzd(baseEntity,
                        skinID != 0uL
                            ? skinID
                            : Convert.ToUInt64(GetAccess("DoorSkin", ownerID.ToString(), 0uL, true))) &&
                    baseEntity != null) return baseEntity;
                return null;
            }

            private bool ObjctFnlzd(BaseEntity baseEntity, ulong skin = new ulong())
            {
                baseEntity.gameObject.AwakeFromInstantiate();
                BuildingBlock block = baseEntity as BuildingBlock;
                if (block)
                {
                    block.blockDefinition = PrefabAttribute.server.Find<Construction>(block.prefabID);
                    block.SetGrade((BuildingGrade.Enum) buildingGrade);
                    float num2 = block.currentGrade.maxHealth;
                }

                BaseCombatEntity combat = baseEntity as BaseCombatEntity;
                if (combat)
                {
                    float num2 = !(block != null) ? combat.startHealth : block.currentGrade.maxHealth;
                    combat.ResetLifeStateOnSpawn = false;
                    combat.InitializeHealth(num2, num2);
                }

                baseEntity.OwnerID = ownerID;
                baseEntity.skinID = skin;
                baseEntity.Spawn();
                if (baseEntity != null && baseEntity.net != null)
                {
                    FtCmpnnts(baseEntity);
                    if (baseEntity.prefabID == 919059809) SendEffect(172001365, baseEntity);
                    baseEntity.EntityLinkBroadcast();
                    if (ConVar.Server.stability)
                    {
                        StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
                        if (stabilityEntity)
                        {
                            stabilityEntity.StabilityCheck();
                            if (stabilityEntity.cachedStability < ConVar.Stability.collapse) return false;
                        }
                    }

                    return true;
                }

                return false;
            }

            private BaseEntity CrtCnstrctn(Construction.Target target, Construction component)
            {
                GameObject gameObject =
                    GameManager.server.CreatePrefab(component.fullName, Vector3.zero, Quaternion.identity, false);
                bool flag = UpdtPlcmnt(gameObject.transform, component, ref target);
                BaseEntity bsntt = gameObject.ToBaseEntity();
                if (!flag)
                {
                    if (bsntt.IsValid()) bsntt.Kill(BaseNetworkable.DestroyMode.None);
                    else GameManager.Destroy(gameObject, 0f);
                    return null;
                }

                DecayEntity dcyEntt = bsntt as DecayEntity;
                if (dcyEntt) dcyEntt.AttachToBuilding(target.entity as DecayEntity);
                return bsntt;
            }

            private bool UpdtPlcmnt(Transform tn, Construction common, ref Construction.Target target)
            {
                List<Socket_Base> list = Pool.GetList<Socket_Base>();
                common.FindMaleSockets(target, list);
                foreach (Socket_Base current in list)
                {
                    Construction.Placement plcmnt = null;
                    if (!(target.entity != null) || !(target.socket != null) ||
                        !target.entity.IsOccupied(target.socket))
                    {
                        if (plcmnt == null) plcmnt = current.DoPlacement(target);
                        if (plcmnt != null)
                        {
                            tn.position = plcmnt.position;
                            tn.rotation = plcmnt.rotation;
                            Pool.FreeList<Socket_Base>(ref list);
                            return true;
                        }
                    }
                }

                Pool.FreeList<Socket_Base>(ref list);
                return false;
            }

            private IEnumerator ChngDrSkns()
            {
                foreach (Door door in doors.Where(d => d != null).ToList())
                {
                    door.skinID = skinID;
                    door.SendNetworkUpdateImmediate();
                    SendEffect(172001365, door);
                    yield return waitFFU;
                }
            }

            private void StoreBox(BasePlayer player)
            {
                player.inventory.loot.StartLootingEntity(fuelBox, false);
                storeBox = new ItemContainer();
                storeBox.ServerInitialize(null, fuelBox.inventorySlots);
                storeBox.GiveUID();
                storeBox.onlyAllowedItem = ItemManager.FindItemDefinition(-148794216);
                storeBox.onItemAddedRemoved += new Action<Item, bool>(OnGarageDoorAdded);
                storeBox.playerOwner = player;
                player.inventory.loot.AddContainer(storeBox);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, r("ECP_BcraYbbgCnary"), r("znvyobkragel"));
            }

            private void OnGarageDoorAdded(Item item, bool bAdded)
            {
                ulong oldSkin = skinID;
                skinID = item.skin == 0uL
                    ? Convert.ToUInt64(GetAccess("DoorSkin", ownerID.ToString(), 0uL, true))
                    : item.skin;
                storeBox.itemList.Remove(item);
                storeBox.MarkDirty();
                storeBox.playerOwner.inventory.GiveItem(item);
                storeBox.playerOwner.EndLooting();
                storeBox.playerOwner.ClientRPCPlayer(null, storeBox.playerOwner, r("BaQvrq"));
                if (oldSkin != skinID) StartCoroutine(ChngDrSkns());
            }

            public void TunaBox(BasePlayer player, BaseOven oven, BaseEntity parent)
            {
                int f = Array.IndexOf(doors, (Door) parent);
                player.inventory.loot.StartLootingEntity(fuelBox, false);
                tunaBoxes[f] = new ItemContainer();
                tunaBoxes[f].ServerInitialize(null, fuelBox.inventorySlots);
                tunaBoxes[f].GiveUID();
                tunaBoxes[f].onlyAllowedItem = ItemManager.FindItemDefinition(-946369541);
                tunaBoxes[f].onItemAddedRemoved += new Action<Item, bool>(OnTunaFuelAdded);
                tunaBoxes[f].playerOwner = player;
                tunaBoxes[f].entityOwner = parent;
                player.inventory.loot.AddContainer(tunaBoxes[f]);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, r("ECP_BcraYbbgCnary"), r("znvyobkragel"));
            }

            private void OnTunaFuelAdded(Item item, bool bAdded)
            {
                if (!bAdded || item == null) return;
                ItemContainer parent = item.parent;
                int f = Array.IndexOf(tunaBoxes, parent);
                parent.itemList.Remove(item);
                parent.MarkDirty();
                InsertFuel(item);
                Effect.server.Run(fuelBox.mailDropSound.resourcePath, parent.entityOwner.transform.position,
                    default(Vector3), null, false);
                parent.playerOwner.EndLooting();
                parent.playerOwner.ClientRPCPlayer(null, parent.playerOwner, r("BaQvrq"));
                parent.playerOwner = null;
                parent.entityOwner = null;
                parent.Kill();
                tunaBoxes[f] = null;
            }

            public void SendEffect(uint id, BaseEntity ent)
            {
                Effect.server.Run(StringPool.Get(id), ent, 0u, Vector3.zero, Vector3.zero, null, false);
            }

            public void SendEffectTo(uint id, BaseEntity ent, BasePlayer player)
            {
                Effect effect = new Effect();
                effect.Init(Effect.Type.Generic, ent.transform.position, player.transform.forward, null);
                effect.pooledString = StringPool.Get(id);
                EffectNetwork.Send(effect, player.net.connection);
            }

            public void SendEffUnlock(BaseEntity e = null)
            {
                SendEffect(996087289, e != null ? e : lift);
            }

            public void SendEffLock(BaseEntity e = null)
            {
                SendEffect(242195671, e != null ? e : lift);
            }

            public void SendEffDenied(BaseEntity e = null)
            {
                SendEffect(4112119478, e != null ? e : lift);
            }

            public void SendEffUpdated(BaseEntity e = null)
            {
                SendEffect(4109975300, e != null ? e : lift);
            }

            public void SendEffDeploy(BaseEntity e = null)
            {
                SendEffect(1538559707, e != null ? e : lift);
            }

            public void SendEffFovChange(BaseEntity e = null)
            {
                SendEffect(2414984321, e != null ? e : lift);
            }

            public void SendEffRecycleStop(BaseEntity e = null)
            {
                SendEffect(3618221308, e != null ? e : lift);
            }

            public void SendEffRecycleStart(BaseEntity e = null)
            {
                SendEffect(3499498126, e != null ? e : lift);
            }
        }

        public class LiftUI
        {
            public LiftUI()
            {
            }

            private string msg(string key, string id = null)
            {
                return UpL.lang.GetMessage(key, UpL, id);
            }

            public Elevator elev = null;
            private uint elevatorID;
            private BaseEntity baseEntity;
            private ProceduralLift lift;
            private int lastIndex;
            private char[] doorsToPlaceChar;
            private int offsetDown;
            private bool hasCreateCost;
            private float costMultiplier;
            private List<ItemAmount> collectAmounts;

            private string[] floorLetters = new string[]
            {
                " ", "⑴", "⑵", "⑶", "⑷", "⑸", "⑹", "⑺", "⑻", "⑼", "⑽", "⑾", "⑿", "⒀", "⒁", "⒂", "⒃", "⒄", "⒅", "⒆", "⒇"
            };

            private string[] floorLettersSingle = new string[]
            {
                " ", "⑴", "⑵", "⑶", "⑷", "⑸", "⑹", "⑺", "⑻", "⑼", "⑽", "⑾", "⑿", "⒀", "⒁", "⒂", "⒃", "⒄", "⒅", "⒆", "⒇"
            };

            private int maxRows;
            private int numSpecialBtns;
            private int maxButtons;
            private int maxColumns;
            private float pWitdhHalf;
            private int currentFloor;
            private int upperFloor;
            private int lowerFloor;
            private bool useFloorNumbers;
            private int stopLevel;
            private int startLevel;
            private int arrLength;
            private bool enableFuel;
            private string textColorIron = "0.878431373 0.400000000 0.200000000 0.75";
            private string textColorNickel = "0.313725490 0.815686275 0.313725490 0.75";
            private string textColorChlorine = "0.121568627 0.941176471 0.121568627 0.75";
            private string textColorKrypton = "0.360784314 0.721568627 0.819607843 0.75";
            private string textColorSelenium = "1.0 0.631372549 0.0 0.75";
            private string textColorGold = "1.0 0.819607843 0.137254902 0.75";
            private string textColorBohrium = "0.878431373 0.0 0.219607843 0.75";
            private string textColorSilicon = "0.941176471 0.784313725 0.627450980 0.5";
            private string textColorMercury = "0.721568627 0.721568627 0.815686275 0.5";
            private string bgColorBromine = "0.650980392 0.160784314 0.160784314 0.05";
            private string bgColorAstantine = "0.458823529 0.309803922 0.270588235 0.5";
            private string buttonColor = "0.25 0.25 0.25 0.5";
            private string font = r("EbobgbPbaqrafrq-Erthyne.ggs");

            public static void DestroyAllUi(BasePlayer player)
            {
                if (player == null) return;
                CuiHelper.DestroyUi(player, cabinControlUI);
                CuiHelper.DestroyUi(player, cabinDestroyUI);
                CuiHelper.DestroyUi(player, cabinSettingsUI);
                CuiHelper.DestroyUi(player, cabinPlacementUI);
                CuiHelper.DestroyUi(player, cabinSharingUI);
            }

            public void DestroyUi(BasePlayer player)
            {
                if (player == null) return;
                CuiHelper.DestroyUi(player, cabinControlUI);
                CuiHelper.DestroyUi(player, cabinDestroyUI);
                CuiHelper.DestroyUi(player, cabinSettingsUI);
                CuiHelper.DestroyUi(player, cabinPlacementUI);
                CuiHelper.DestroyUi(player, cabinSharingUI);
            }

            public void Init(Elevator e, uint id)
            {
                elev = e;
                maxRows = 5;
                elevatorID = id;
                upperFloor = elev.UpperFloor;
                lowerFloor = elev.LowerFloor;
                enableFuel = elev.EnableFuel;
                useFloorNumbers = upperFloor > 20;
            }

            public void IntPlcmnt(Elevator e, ProceduralLift l, BasePlayer player, BaseEntity ent, int offSet,
                int startFrom, int limitRange, int maxFloor)
            {
                elev = e;
                lift = l;
                offsetDown = offSet;
                baseEntity = ent;
                startLevel = startFrom;
                int maxRange = Math.Min(limitRange, (int) GetAccess("MaxFloorRange", player.UserIDString, 3, true));
                stopLevel = Math.Min(maxFloor, maxRange + startFrom);
                if (stopLevel <= 0) stopLevel = limitRange + startFrom - 1;
                arrLength = stopLevel + 1;
                doorsToPlaceChar = Enumerable.Repeat('0', arrLength).ToArray();
                lastIndex = stopLevel;
                doorsToPlaceChar[startLevel] = '1';
                doorsToPlaceChar[lastIndex] = '1';
                hasCreateCost = (bool) GetAccess("EnableBuildCost", player.UserIDString, true);
                costMultiplier = Convert.ToSingle(GetAccess("BuildCostMultiplier", player.UserIDString, 1f));
                if (hasCreateCost) collectAmounts = elev.GetPartsCost(3, lastIndex, doorsToPlaceChar, costMultiplier);
                CrtPlcmntUI(player, lastIndex, doorsToPlaceChar);
            }

            public void UpdtPlcmnt(BasePlayer player, string action, int num)
            {
                elev.SendEffectTo(3499498126, player, player);
                if (action == "accept")
                {
                    if (num == 0)
                    {
                        elev.SendEffectTo(4112119478, player, player);
                        UpL.playerStartups.Remove(player.userID);
                        UnityEngine.Object.Destroy(lift.gameObject.GetComponent<Elevator>());
                        UnityEngine.Object.Destroy(lift, 1f);
                        try
                        {
                            lift.Kill();
                        }
                        catch
                        {
                        }

                        return;
                    }

                    baseEntity.RefreshEntityLinks();
                    if (!elev.IntNw(lift, baseEntity, player, offsetDown, startLevel, lastIndex, doorsToPlaceChar,
                        collectAmounts, hasCreateCost, costMultiplier))
                    {
                        elev.SendEffectTo(4112119478, player, player);
                        UpL.playerStartups.Remove(player.userID);
                        UnityEngine.Object.Destroy(lift.gameObject.GetComponent<Elevator>());
                        UnityEngine.Object.Destroy(lift, 1f);
                        try
                        {
                            lift.Kill();
                        }
                        catch
                        {
                        }

                        return;
                    }

                    elev.SendEffectTo(1538559707, player, player);
                    crossReference[lift.net.ID] = elev;
                    UpL.playerStartups.Remove(player.userID);
                    return;
                }

                if (action == "level")
                {
                    elev.SendEffectTo(996087289, player, player);
                    if (num == startLevel) num++;
                    if (lastIndex < num && num > startLevel) doorsToPlaceChar[lastIndex] = '0';
                    lastIndex = num;
                    doorsToPlaceChar[startLevel] = '1';
                    doorsToPlaceChar[lastIndex] = '1';
                    if (hasCreateCost)
                        collectAmounts = elev.GetPartsCost(3, lastIndex, doorsToPlaceChar, costMultiplier);
                    CrtPlcmntUI(player, num, doorsToPlaceChar);
                    return;
                }

                if (action == "door")
                {
                    doorsToPlaceChar[num] = doorsToPlaceChar[num] == '1' ? '0' : '1';
                    if (num > lastIndex) doorsToPlaceChar[num] = '0';
                    if (num == 0 || num == lastIndex) doorsToPlaceChar[num] = '1';
                    else if (num <= lastIndex)
                        elev.SendEffectTo(doorsToPlaceChar[num] == '1' ? 996087289u : 242195671u, player, player);
                    doorsToPlaceChar[0] = '1';
                    doorsToPlaceChar[lastIndex] = '1';
                    if (hasCreateCost)
                        collectAmounts = elev.GetPartsCost(3, lastIndex, doorsToPlaceChar, costMultiplier);
                    CrtPlcmntUI(player, lastIndex, doorsToPlaceChar);
                    return;
                }
            }

            private float[] ButtonPosControl(int i)
            {
                float bHeight = 1f / maxRows;
                float bWidth = 1f / maxColumns;
                int colNumber = i == 0 ? 0 : Mathf.FloorToInt(i / maxRows);
                int rowNumber = i - colNumber * maxRows;
                float offsetX = 0f + colNumber * bWidth;
                float offsetY = 0f + bHeight * rowNumber;
                return new float[]
                    {offsetX + 0.005f, offsetY + 0.005f, offsetX + bWidth - 0.005f, offsetY + bHeight - 0.005f};
            }

            private CuiPanel NewPanel()
            {
                return new CuiPanel
                {
                    Image = new CuiImageComponent {Color = bgColorBromine}, CursorEnabled = true,
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"}
                };
            }

            private CuiPanel NewBorderPanel(string c, string x, string y)
            {
                return new CuiPanel
                    {Image = new CuiImageComponent {Color = c}, RectTransform = {AnchorMin = x, AnchorMax = y}};
            }

            private CuiButton NewBgButton(string cmd, string viewForm)
            {
                return new CuiButton
                {
                    Button = {Command = cmd, Close = viewForm, Color = "0 0 0 0"},
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"}, Text = {Text = string.Empty}
                };
            }

            private CuiButton NormalButton(string x, string y, string cmd, string close, string color, string text,
                string tColor, int fontsize = 15, TextAnchor align = TextAnchor.MiddleCenter)
            {
                return new CuiButton
                {
                    RectTransform = {AnchorMin = x, AnchorMax = y},
                    Button = {Command = cmd, Close = close, Color = color},
                    Text = {Align = align, Text = text, Color = tColor, FontSize = fontsize, Font = font}
                };
            }

            private CuiButton PsBttn(int count, string command, string close, string bcolor, string text, string tcolor,
                int fontsize = 15)
            {
                float[] buPo = ButtonPosControl(count);
                return new CuiButton
                {
                    RectTransform = {AnchorMin = $"{buPo[0]} {buPo[1]}", AnchorMax = $"{buPo[2]} {buPo[3]}"},
                    Button = {Command = command, Close = close, Color = bcolor},
                    Text =
                    {
                        Align = TextAnchor.MiddleCenter, Text = text, Color = tcolor, FontSize = fontsize, Font = font
                    }
                };
            }

            public bool WayUpFree(BaseEntity ent, int fls)
            {
                RaycastHit hit;
                Ray ray;
                for (int l = 0; l < fls; l++)
                {
                    ray = new Ray(ent.transform.position + Vector3.up * (l * 3), ent.transform.up);
                    if (Physics.Raycast(ray, out hit, 3f, 2097152)) return false;
                }

                return true;
            }

            public void CrtPlcmntUI(BasePlayer player, int indexAt, char[] placeDoorsChar)
            {
                bool enoughRes = true; /*bool isUpFree = Prevent_Building.WayUpFree(baseEntity, indexAt);*/
                bool isUpFree = WayUpFree(baseEntity, indexAt);
                StringBuilder sb = new StringBuilder();
                if (hasCreateCost)
                    foreach (ItemAmount collectAmount in collectAmounts)
                    {
                        float have = (float) player.inventory.GetAmount(collectAmount.itemDef.itemid);
                        if (have < collectAmount.amount)
                        {
                            enoughRes = false;
                            sb.AppendLine(
                                $"<color=#ff6b00>{msg("Bad")}   </color>> {collectAmount.itemDef.displayName.english} (<color=#ff6b00>{have}</color> < {collectAmount.amount})");
                        }
                        else
                        {
                            sb.AppendLine(
                                $"<color=#00f700>{msg("Good")} </color>> {collectAmount.itemDef.displayName.english} (<color=#00f700>{have}</color> > {collectAmount.amount})");
                        }
                    }

                if (!hasCreateCost) enoughRes = true;
                CuiElementContainer result = new CuiElementContainer();
                string rootPanelName = result.Add(NewPanel(), "Overlay", cabinPlacementUI);
                result.Add(NewBgButton(string.Empty, string.Empty), cabinPlacementUI);
                float resizeX = (float) arrLength - 21f;
                if (resizeX < 15) resizeX = 15;
                float x1 = 0.375f - resizeX * 0.005f;
                float x2 = 0.625f + resizeX * 0.005f;
                float yP = 0.705f;
                result.Add(
                    NewBorderPanel("0.4 0.4 0.4 1.0", $"{x1 - 0.005} {(hasCreateCost ? 0.345: 0.425)}", $"{x2 + 0.005} {yP}"), rootPanelName);
                result.Add(NewBgButton(string.Empty, string.Empty), rootPanelName);
                yP -= 0.005f;
                string headerPanel1 = result.Add(NewBorderPanel(bgColorAstantine, $"{x1} {yP - 0.05f}", $"{x2} {yP}"),
                    rootPanelName);
                yP -= 0.055f;
                string headerPanel2 = result.Add(NewBorderPanel(bgColorAstantine, $"{x1} {yP - 0.05f}", $"{x2} {yP}"),
                    rootPanelName);
                yP -= 0.055f;
                string headerPanel3 = result.Add(NewBorderPanel(bgColorAstantine, $"{x1} {yP - 0.05f}", $"{x2} {yP}"),
                    rootPanelName);
                yP -= 0.055f;
                string headerPanel4 = result.Add(NewBorderPanel(bgColorAstantine, $"{x1} {yP - 0.05f}", $"{x2} {yP}"),
                    rootPanelName);
                string headerPanel5 = null;
                if (hasCreateCost)
                {
                    yP -= 0.055f + 0.025f;
                    headerPanel5 =
                        result.Add(NewBorderPanel(bgColorAstantine, $"{x1} {yP - 0.05f}", $"{x2} {yP + 0.025}"),
                            rootPanelName);
                }

                yP -= 0.055f;
                string headerPanel6 = result.Add(NewBorderPanel(bgColorAstantine, $"{x1} {yP - 0.05f}", $"{x2} {yP}"),
                    rootPanelName);
                result.Add(
                    NormalButton($"0.1 0", $"0.9 1", "", "", "0 0 0 0", msg("Choose the planned Lift size"),
                        textColorGold), headerPanel1);
                result.Add(
                    NormalButton($"0.1 0", $"0.9 1", "", "", "0 0 0 0", msg("Choose where to pre-place doors"),
                        textColorGold), headerPanel3);
                if (hasCreateCost)
                    result.Add(
                        NormalButton($"0.05 0.05", $"0.95 0.95", "", "", "0 0 0 0", sb.ToString().Replace("\r", ""),
                            textColorKrypton, 14, TextAnchor.MiddleLeft), headerPanel5);
                string textColor = isUpFree ? textColorKrypton : textColorSelenium;
                string command = enoughRes ? $"_ul.placement  accept 1" : "";
                string close = enoughRes ? cabinPlacementUI : "";
                string text = isUpFree ? msg("Do Placement") : msg("Do Place (Upward Overwrite)");
                int size = isUpFree ? 15 : 10;
                string button;
                string color;
                if (hasCreateCost && !enoughRes)
                {
                    textColor = textColorSilicon;
                    command = "";
                    close = "";
                    text = msg("Do Placement");
                    size = 15;
                }

                result.Add(NormalButton($"0.05 0.2", $"0.45 0.8", command, close, buttonColor, text, textColor, size),
                    headerPanel6);
                result.Add(
                    NormalButton($"0.55 0.2", $"0.95 0.8", $"_ul.placement  accept 0", cabinPlacementUI, buttonColor,
                        msg("Cancel Action"), textColorKrypton), headerPanel6);
                float step = 1f / (arrLength - startLevel);
                float x = 0f;
                for (int p = startLevel; p < arrLength; p++)
                {
                    if (p > indexAt) placeDoorsChar[p] = '0';
                    x += step;
                    button = indexAt < p ? "0.25 0.25 0.25 0.25" : "0.25 0.25 0.25 0.75";
                    color = indexAt < p ? textColorKrypton : textColorGold;
                    command = p != startLevel && p != indexAt ? $"_ul.placement level {p}" : "";
                    result.Add(
                        NormalButton($"{x - step + 0.005f} 0", $"{x - 0.005f} 1", command, "", button,
                            $"{p.ToString()}", color), headerPanel2);
                    command = p < indexAt && p != startLevel && p != indexAt ? $"_ul.placement door {p}" : "";
                    button = placeDoorsChar[p] == '1' || p == startLevel || p == indexAt
                        ? "0.25 0.25 0.25 0.75"
                        : "0.25 0.25 0.25 0.25";
                    color = placeDoorsChar[p] == '1' || p == startLevel || p == indexAt
                        ? textColorGold
                        : textColorKrypton;
                    result.Add(
                        NormalButton($"{x - step + 0.005f} 0", $"{x - 0.005f} 1", command, "", button,
                            $"{p.ToString()}", color), headerPanel4);
                }

                CuiHelper.DestroyUi(player, cabinPlacementUI);
                CuiHelper.AddUi(player, result);
            }

            public void CrtCbnUI(BasePlayer player, bool freshOpen = false)
            {
                elev.SendEffUnlock();
                int cP = 0;
                numSpecialBtns = 5;
                currentFloor = elev.CurrentFloor;
                bool isOwner = elev.IsOwner(player);
                bool isPassenger = elev.IsPassenger(player.userID) || IsAdm(player);
                maxButtons = elev.GetDoorCount + numSpecialBtns;
                maxColumns = Mathf.CeilToInt((float) maxButtons / (float) maxRows);
                pWitdhHalf = maxColumns * 0.05f;
                CuiElementContainer result = new CuiElementContainer();
                string rootPanelName = result.Add(NewPanel(), "Overlay", cabinControlUI);
                result.Add(NewBgButton(string.Empty, cabinControlUI), cabinControlUI);
                result.Add(
                    NewBorderPanel("0.4 0.4 0.4 1.0", $"{0.495f - pWitdhHalf} 0.295", $"{0.505f + pWitdhHalf} 0.705"),
                    rootPanelName);
                result.Add(NewBgButton(string.Empty, cabinControlUI), rootPanelName);
                string headerPanel =
                    result.Add(NewBorderPanel(bgColorAstantine, $"{0.5f - pWitdhHalf} 0.3", $"{0.5f + pWitdhHalf} 0.7"),
                        rootPanelName);
                if (isOwner)
                    for (int p = lowerFloor; p < upperFloor + 1; p++)
                    {
                        Door d = elev.GetDoorAt(p);
                        if (d == null) continue;
                        cP++;
                        string textColor = currentFloor != p ? textColorIron : textColorGold;
                        string command = currentFloor != p
                            ? $"_ul.commands {elevatorID} move {p}"
                            : $"_ul.commands {elevatorID} move 0";
                        string close = currentFloor != p ? cabinControlUI : string.Empty;
                        if (!isPassenger)
                        {
                            textColor = textColorMercury;
                            command = string.Empty;
                            close = string.Empty;
                        }

                        result.Add(
                            PsBttn(cP - 1, command, close, buttonColor,
                                useFloorNumbers ? $"({p.ToString()})" : floorLetters[p], textColor, 40), headerPanel);
                    }
                else
                    for (int p = lowerFloor; p < upperFloor + 1; p++)
                    {
                        Door d = elev.GetDoorAt(p);
                        if (d == null) continue;
                        FloorShare fShare = elev.GetFloorMode(p);
                        bool hasAccess = elev.HsFlrAccss(player, fShare, p);
                        if (fShare == FloorShare.Hidden || fShare == FloorShare.HiddenVIP && !hasAccess) continue;
                        cP++;
                        string close = string.Empty;
                        string textColor = textColorMercury;
                        string command = string.Empty;
                        if (fShare == FloorShare.Excluded)
                        {
                            textColor = textColorMercury;
                            command = string.Empty;
                            close = string.Empty;
                        }

                        if (hasAccess)
                        {
                            textColor = currentFloor != p ? textColorNickel : textColorChlorine;
                            command = currentFloor != p
                                ? $"_ul.commands {elevatorID} move {p}"
                                : $"_ul.commands {elevatorID} move 0";
                            close = currentFloor != p ? cabinControlUI : string.Empty;
                        }

                        result.Add(
                            PsBttn(cP - 1, command, close, buttonColor,
                                useFloorNumbers ? $"({p.ToString()})" : floorLetters[p], textColor, 40), headerPanel);
                    }

                int fillCount = maxColumns * maxRows - numSpecialBtns - cP;
                for (int f = 1; f < fillCount + 1; f++)
                    result.Add(PsBttn(cP++, string.Empty, string.Empty, buttonColor, "¨", textColorSilicon, 40),
                        headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} open {currentFloor}", cabinControlUI, buttonColor, "↔",
                        textColorSelenium, 40), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} close {currentFloor}", cabinControlUI, buttonColor, "↺",
                        textColorSelenium, 40), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} cancel {currentFloor}", cabinControlUI, buttonColor, "↲",
                        textColorSelenium, 40), headerPanel);
                bool flag = enableFuel == true && isOwner == true && (int) elev.GetPowerState == 0;
                result.Add(
                    PsBttn(cP++, flag ? $"_ul.commands {elevatorID} fuel 0" : string.Empty,
                        flag ? cabinControlUI : string.Empty, buttonColor,
                        enableFuel ? $"↯<size=18>({elev.GetFuel()}F)</size>" : $"↯<size=18>({msg("FoC")})</size>",
                        textColorSelenium, 40), headerPanel);
                result.Add(
                    PsBttn(cP++, isOwner == true ? $"_ul.commands {elevatorID} move 7777" : string.Empty,
                        isOwner == true ? cabinControlUI : string.Empty, buttonColor, "Ⓢ",
                        isOwner == true ? textColorSelenium : textColorMercury, 40), headerPanel);
                CuiHelper.DestroyUi(player, cabinControlUI);
                CuiHelper.AddUi(player, result);
            }

            public void CrtDstryUI(BasePlayer player)
            {
                CuiElementContainer result = new CuiElementContainer();
                string rootPanelName = result.Add(NewPanel(), "Overlay", cabinDestroyUI);
                result.Add(NewBgButton(string.Empty, cabinDestroyUI), cabinDestroyUI);
                result.Add(NewBorderPanel("0.4 0.4 0.4 1.0", $"0.345 0.445", $"0.655 0.555"), rootPanelName);
                result.Add(NewBgButton(string.Empty, cabinDestroyUI), rootPanelName);
                string headerPanel = result.Add(NewBorderPanel(bgColorAstantine, $"0.35 0.45", $"0.65 0.55"),
                    rootPanelName);
                result.Add(
                    NormalButton($"0.05 0.2", $"0.30 0.8", $"_ul.commands {elevatorID} destroy 1", cabinDestroyUI,
                        buttonColor, msg("Full Remove"), textColorBohrium, 17), headerPanel);
                result.Add(
                    NormalButton($"0.35 0.2", $"0.65 0.8", $"_ul.commands {elevatorID} destroy 2", cabinDestroyUI,
                        buttonColor, msg("Keep Building"), textColorBohrium, 17), headerPanel);
                result.Add(
                    NormalButton($"0.7 0.2", $"0.95 0.8", $"_ul.commands {elevatorID} destroy 0", cabinDestroyUI,
                        buttonColor, msg("Cancel"), textColorKrypton, 17), headerPanel);
                CuiHelper.DestroyUi(player, cabinControlUI);
                CuiHelper.AddUi(player, result);
            }

            public void CrtSttngsUI(BasePlayer player)
            {
                elev.SendEffUnlock();
                elev.SetUpKeep(true);
                int cP = 0;
                numSpecialBtns = 10;
                currentFloor = elev.CurrentFloor;
                maxButtons = upperFloor + 1 - lowerFloor + numSpecialBtns;
                maxColumns = Mathf.CeilToInt((float) maxButtons / (float) maxRows);
                pWitdhHalf = maxColumns * 0.05f;
                CuiElementContainer result = new CuiElementContainer();
                string rootPanelName = result.Add(NewPanel(), "Overlay", cabinSettingsUI);
                result.Add(NewBgButton($"_ul.commands {elevatorID} state 0", cabinSettingsUI), cabinSettingsUI);
                result.Add(
                    NewBorderPanel("0.4 0.4 0.4 1.0", $"{0.495f - pWitdhHalf} 0.295", $"{0.505f + pWitdhHalf} 0.705"),
                    rootPanelName);
                result.Add(NewBgButton($"_ul.commands {elevatorID} state 0", cabinSettingsUI), rootPanelName);
                string headerPanel =
                    result.Add(NewBorderPanel(bgColorAstantine, $"{0.5f - pWitdhHalf} 0.3", $"{0.5f + pWitdhHalf} 0.7"),
                        rootPanelName);
                for (int p = lowerFloor; p < upperFloor + 1; p++)
                {
                    bool hasDoor = elev.GetDoorAt(p) != null ? true : false;
                    cP++;
                    string textColor = hasDoor ? textColorIron : textColorNickel;
                    textColor = p == lowerFloor || p == upperFloor || p == currentFloor ? textColorGold : textColor;
                    string command = $"_ul.commands {elevatorID} switch {p}";
                    command = p == lowerFloor || p == upperFloor || p == currentFloor
                        ? $"_ul.commands {elevatorID} switch 0"
                        : command;
                    string text = hasDoor
                        ? $"{msg("Floor")} {p}\n- {msg("Door")} -"
                        : $"{msg("Floor")} {p}\n+ {msg("Door")} +";
                    text = p == lowerFloor || p == upperFloor ? $"{msg("Floor")} {p}\n{msg("Static")}" : text;
                    text = p == currentFloor ? $"{msg("Floor")} {p}\n{msg("Current")}" : text;
                    result.Add(PsBttn(cP - 1, command, string.Empty, buttonColor, text, textColor, 15), headerPanel);
                }

                int fillCount = maxColumns * maxRows - numSpecialBtns - cP;
                for (int f = 1; f < fillCount + 1; f++)
                    result.Add(PsBttn(cP++, string.Empty, string.Empty, buttonColor, "¨", textColorSilicon, 45),
                        headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} move 6666", cabinSettingsUI, buttonColor,
                        msg("Tear down\nLift"), textColorBohrium), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} move 1111", cabinSettingsUI, buttonColor,
                        msg("Operating\nPanel"), textColorSelenium), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} cabinlight 0", string.Empty, buttonColor,
                        msg("Lighting") +
                        $"\n<color=#2e96ad>{msg($"CabinLightMode.{(CabinLightMode) elev.GetLightMode}")}</color>",
                        textColorSelenium), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} speed 0", string.Empty, buttonColor,
                        msg("Move Speed") +
                        $"\n<color=#2e96ad>{elev.MoveSpeed.ToString()}</color> / <color=#2e96ad>{elev.MaxSpeed.ToString()}</color>",
                        textColorSelenium), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} floorwait 0", string.Empty, buttonColor,
                        msg("Floor OnHold") + $"\n<color=#2e96ad>{elev.FloorWait.ToString()}</color> s",
                        textColorSelenium), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} idlewait 0", string.Empty, buttonColor,
                        msg("Idle Close") +
                        $"\n<color=#2e96ad>{(elev.IdleWait != -1 ? elev.IdleWait.ToString() : "∞")}</color> s",
                        textColorSelenium), headerPanel);
                result.Add(
                    PsBttn(cP++, enableFuel ? $"_ul.commands {elevatorID} fuel 1" : string.Empty, string.Empty,
                        buttonColor,
                        msg("Power State") +
                        $"\n <color=#2e96ad>{msg($"PowerState.{(PowerState) elev.GetPowerState}")}</color>",
                        textColorSelenium), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} sharemode 0", string.Empty, buttonColor,
                        msg("Share Mode") +
                        $"\n <color=#2e96ad>{msg($"ShareMode.{elev._sharemode}")} {elev.GetShareMode()}</color>",
                        textColorSelenium), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} sharemode 1", cabinSettingsUI, buttonColor,
                        msg("Floor Sharing\nOptions"), textColorSelenium), headerPanel);
                bool canSkin = (bool) GetAccess("CanReskin", player.UserIDString, false, true);
                string skinId =
                    elev.GetSkinID == Convert.ToUInt64(GetAccess("DoorSkin", player.UserIDString, 0uL, true))
                        ? "Default"
                        : elev.GetSkinID.ToString();
                result.Add(
                    PsBttn(cP++, canSkin ? $"_ul.commands {elevatorID} doorskin 0" : string.Empty,
                        canSkin ? cabinSettingsUI : string.Empty, buttonColor,
                        msg("Door Skin") + $"\n<color=#2e96ad>{(canSkin ? skinId : "n.a.")}</color>",
                        textColorSelenium), headerPanel);
                CuiHelper.DestroyUi(player, cabinSettingsUI);
                CuiHelper.AddUi(player, result);
            }

            public void CrtShrngUI(BasePlayer player)
            {
                int cP = 0;
                numSpecialBtns = 5;
                maxButtons = elev.GetDoorCount + numSpecialBtns;
                maxColumns = Mathf.CeilToInt((float) maxButtons / (float) maxRows);
                pWitdhHalf = maxColumns * 0.05f;
                CuiElementContainer result = new CuiElementContainer();
                string rootPanelName = result.Add(NewPanel(), "Overlay", cabinSharingUI);
                result.Add(NewBgButton(string.Empty, cabinSharingUI), cabinSharingUI);
                result.Add(
                    NewBorderPanel("0.4 0.4 0.4 1.0", $"{0.495f - pWitdhHalf} 0.295", $"{0.505f + pWitdhHalf} 0.705"),
                    rootPanelName);
                result.Add(NewBgButton(string.Empty, cabinSharingUI), rootPanelName);
                string headerPanel =
                    result.Add(NewBorderPanel(bgColorAstantine, $"{0.5f - pWitdhHalf} 0.3", $"{0.5f + pWitdhHalf} 0.7"),
                        rootPanelName);
                for (int p = 1; p < upperFloor + 1; p++)
                {
                    Door d = elev.GetDoorAt(p);
                    if (d == null) continue;
                    cP++;
                    string textColor = textColorSilicon;
                    string command = $"_ul.commands {elevatorID} floormode {p}";
                    string close = string.Empty;
                    string text =
                        $"{msg("Floor")} {p}\n<color=#2e96ad>{msg($"FloorShare.{elev.GetFloorMode(p)}")}</color>";
                    result.Add(PsBttn(cP - 1, command, close, buttonColor, text, textColor, 15), headerPanel);
                }

                int fillCount = maxColumns * maxRows - numSpecialBtns - cP;
                for (int f = 1; f < fillCount + 1; f++)
                    result.Add(PsBttn(cP++, string.Empty, string.Empty, buttonColor, "¨", textColorSilicon, 40),
                        headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} floormode 1111", string.Empty, buttonColor,
                        msg("Switch\nAll Floors"), textColorKrypton), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} floormode 6666", string.Empty, buttonColor,
                        msg("Reset\nAll Floors"), textColorIron), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} move 7777", cabinSharingUI, buttonColor,
                        msg("Settings\nPanel"), textColorSelenium), headerPanel);
                result.Add(
                    PsBttn(cP++, $"_ul.commands {elevatorID} state 0", cabinSharingUI, buttonColor, msg("Close\nMenu"),
                        textColorSelenium), headerPanel);
                result.Add(PsBttn(cP++, string.Empty, string.Empty, buttonColor, "¨", textColorSilicon, 40),
                    headerPanel);
                CuiHelper.DestroyUi(player, cabinSharingUI);
                CuiHelper.AddUi(player, result);
            }
        }

        private static string r(string i)
        {
            return !string.IsNullOrEmpty(i)
                ? new string(i.Select(x =>
                    x >= 'a' && x <= 'z' ? (char) ((x - 'a' + 13) % 26 + 'a') :
                    x >= 'A' && x <= 'Z' ? (char) ((x - 'A' + 13) % 26 + 'A') : x).ToArray())
                : i;
        }

        public class Prevent_Building : FacepunchBehaviour
        {
            private BoxCollider boxCollider;
            private BaseEntity block;
            private int floors;

            public void Setup(BaseEntity ent, int f)
            {
                floors = f;
                float height = floors * 3f;
                block = ent;
                transform.SetParent(block.transform, false);
                gameObject.layer = 29;
                boxCollider = gameObject.AddComponent<BoxCollider>();
                boxCollider.center = new Vector3(0f, height / 2f, 0f);
                boxCollider.size = new Vector3(2.9f, height, 2.9f);
            }

            public void BeforeCreation()
            {
                RaycastHit hit;
                Ray ray = new Ray(transform.position + Vector3.up, transform.up);
                for (int l = 1; l < floors; l++)
                    if (Physics.Raycast(ray, out hit, 3f * floors, 2097152))
                    {
                        BaseEntity ent = hit.GetEntity();
                        if (ent) ent.Kill(BaseNetworkable.DestroyMode.None);
                    }
            }

            public static bool WayUpFree(BaseEntity ent, int fls)
            {
                RaycastHit hit;
                Ray ray;
                for (int l = 0; l < fls; l++)
                {
                    ray = new Ray(ent.transform.position + Vector3.up * (l * 3), ent.transform.up);
                    if (Physics.Raycast(ray, out hit, 3f, 2097152)) return false;
                }

                return true;
            }

            private void OnDestroy()
            {                
                Destroy(boxCollider);
            }
        }

        public class CabinComfort : FacepunchBehaviour
        {
            private SphereCollider sphereCollider;
            private TriggerComfort triggerComfort;
            private TriggerTemperature triggerTemperature;

            public void Setup(BaseEntity ent, int comfort = 0, int temp = 0)
            {
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = 1.4f;
                if (comfort > 0)
                {
                    triggerComfort = gameObject.AddComponent<TriggerComfort>();
                    triggerComfort.interestLayers.value = 131072;
                    triggerComfort.baseComfort = (float) comfort / 100f;
                    triggerComfort.triggerSize = sphereCollider.radius * gameObject.transform.localScale.y;
                    triggerComfort.minComfortRange = 1.4f;
                }

                if (temp > 0)
                {
                    triggerTemperature = gameObject.AddComponent<TriggerTemperature>();
                    triggerTemperature.interestLayers.value = 131072;
                    triggerTemperature.triggerSize = sphereCollider.radius * gameObject.transform.localScale.y;
                    triggerTemperature.Temperature = temp;
                }

                if (triggerTemperature || triggerComfort)
                {
                    gameObject.layer = 18;
                    transform.SetParent(ent.transform, false);
                }
                else
                {
                    Destroy(this);
                }
            }

            private void OnDestroy()
            {
                Destroy(sphereCollider);
                Destroy(triggerComfort);
                Destroy(triggerTemperature);
            }
        }

        private void OnMeleeAttack(BasePlayer player, HitInfo info)
        {
            if (info == null || info.HitEntity == null || info.HitEntity.GetComponent<CardReader>() == null) return;
            Elevator obj = null;
            if (crossReference.TryGetValue(info.HitEntity.net.ID, out obj) && obj != null)
                if (player != null && (obj.IsOwner(player) || IsAdm(player)) && obj.IsIdle)
                    obj.controlUI.CrtSttngsUI(player);
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd.FullName == "global.entid" && arg.GetString(0, string.Empty) == "kill")
            {
                BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(arg.GetUInt(1, 0u)) as BaseEntity;
                Elevator obj;
                if (baseEntity && crossReference.TryGetValue(baseEntity.net.ID, out obj) && obj != null)
                {
                    if (obj.IsGround(baseEntity) && isGroundBlockVulnerable) return null;
                    if (arg.Player() != null)
                    {
                        if (IsAdm(arg.Connection.userid.ToString()) &&
                            adminLiftEntkill[arg.Connection.userid.ToString()]) return null;
                        arg.Player().ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                                 msg("Entkill disabled for Lifts. Toggle this by: ") +
                                                 $" \'{admAccessToggleCmd} kill\'");
                    }

                    return false;
                }
            }

            return null;
        }

        private object OnPlayerCommand(ConsoleSystem.Arg arg)
        {
            string checkTp = arg.GetString(0, "");
            if (checkTp.ToLower().Contains("sethome") || checkTp.ToLower().Contains("home add"))
            {
                BasePlayer player = arg.Connection?.player as BasePlayer;
                if (player == null) return null;
                RaycastHit hit = new RaycastHit();
                if (Physics.Raycast(player.transform.position, Vector3.down, out hit, player.transform.position.y,
                    2097152))
                {
                    BaseEntity ent = hit.GetEntity();
                    Elevator obj;
                    if (ent && crossReference.TryGetValue(ent.net.ID, out obj) && obj != null)
                    {
                        if (obj.IsGround(ent) && isGroundBlockVulnerable) return null;
                        player.ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                           msg("Couldn't add a home inside a Lift installation"));
                        return false;
                    }
                }

                return null;
            }

            return null;
        }

        private object canRemove(BasePlayer player)
        {
            RaycastHit RayHit;
            bool flag1 = Physics.Raycast(player.eyes.HeadRay(), out RayHit, 10f, 2097409);
            BaseEntity TargetEntity = flag1 ? RayHit.GetEntity() : null;
            Elevator obj;
            if (TargetEntity && crossReference.TryGetValue(TargetEntity.net.ID, out obj) && obj != null)
            {
                if (obj.IsGround(TargetEntity) && isGroundBlockVulnerable) return null;
                return string.Format(prefixFormat, prefixColor, pluginPrefix) +
                       msg("Couldn't use the RemoverTool on a Lift installation");
            }

            return null;
        }

        private object CanBuild(Planner plan, Construction prefab, Construction.Target target)
        {
            if (plan == null || prefab == null ||
                prefab.deployable == null && !prefab.hierachyName.Contains("floor")) return null;
            Construction.Placement placement = new Construction.Placement();
            if (target.socket != null)
            {
                List<Socket_Base> list = Pool.GetList<Socket_Base>();
                prefab.FindMaleSockets(target, list);
                foreach (Socket_Base current in list)
                    if (!(target.entity != null) || !(target.socket != null) ||
                        !target.entity.IsOccupied(target.socket))
                    {
                        placement = current.DoPlacement(target);
                        if (placement != null) break;
                    }

                Pool.FreeList<Socket_Base>(ref list);
                if (placement == null) return null;
            }
            else
            {
                placement.position = target.position;
                placement.rotation = Quaternion.Euler(target.rotation);
                if (placement.rotation == Quaternion.identity)
                    placement.rotation = Quaternion.Euler(0, plan.GetOwnerPlayer().transform.rotation.y, 0);
            }

            OBB oBB = new OBB(placement.position, Vector3.one, placement.rotation, prefab.bounds);
            RaycastHit hit = new RaycastHit();
            if (Physics.Raycast(oBB.position, Vector3.down, out hit, oBB.position.y, 2097152))
            {
                BaseEntity ent = hit.GetEntity();
                if (ent != null && ent.ShortPrefabName.Contains("foundation") && crossReference.ContainsKey(ent.net.ID))
                {
                    Effect.server.Run(StringPool.Get(3618221308), ent, 0u, Vector3.zero, Vector3.zero, null, false);
                    plan.GetOwnerPlayer().ChatMessage(string.Format(prefixFormat, prefixColor, pluginPrefix) +
                                                      msg("No build or place access inside a Lift installation"));
                    return false;
                }
            }

            return null;
        }

        private void OnDoorKnocked(Door door, BasePlayer player)
        {
            Elevator obj;
            if (door != null && player != null && crossReference.TryGetValue(door.net.ID, out obj) && obj != null)
                obj.ChckDrKnck(door, player);
        }

        private void OnPlayerSleep(BasePlayer player)
        {
            if (initialized && player != null) LiftUI.DestroyAllUi(player);
        }

        private object OnLiftUse(ProceduralLift lift, BasePlayer player)
        {
            Elevator obj;
            if (lift != null && player != null && crossReference.TryGetValue(lift.net.ID, out obj) && obj != null)
                return obj.ChckLftUs(lift, player);
            return null;
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (!initialized || entity == null || entity.net == null) return null;
            Elevator obj;
            if (crossReference.TryGetValue(entity.net.ID, out obj) && obj != null)
            {
                if (obj.IsGround(entity) && isGroundBlockVulnerable) return null;
                if (obj.IsDoor(entity) && doorDestructionKillsLiftCabin) return null;
                if (info.damageTypes.Total() > entity.MaxHealth()) return false;
                NextFrame(() => entity.Heal(entity.MaxHealth()));
            }

            return null;
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (!initialized || entity == null || entity.net == null) return;
            Elevator obj;
            if (crossReference.TryGetValue(entity.net.ID, out obj) && obj != null)
            {
                bool isDoor = obj.IsDoor((BaseEntity) entity);
                obj.EntityKill(entity.net.ID, isDoor);
            }
        }

        private string CreateAcl(bool hasParams = false, bool isAdding = true, string newOrOldGroup = "")
        {
            string result = "acl successfully changed and saved to file";
            permissionGroups = new List<string>();
            bool wasAdded = false;
            foreach (KeyValuePair<string, object> current in permissionBlock)
            foreach (string key in (current.Value as Dictionary<string, object>).Keys.Select(c => c.ToLower()).ToList())
                if (!permissionGroups.Contains(key) && key != "admin" && key != "default")
                    permissionGroups.Add(key);
            foreach (KeyValuePair<string, object> usagePerm in playerPermissionMatrix)
            {
                object[] presets = usagePerm.Value as object[];
                if (!permissionBlock.ContainsKey(usagePerm.Key))
                {
                    wasAdded = true;
                    Dictionary<string, object> permgroups = new Dictionary<string, object>
                        {{"admin", presets[0]}, {"default", presets[1]}, {"vip_ex", presets[2]},};
                    foreach (string group in permissionGroups)
                        if (!permgroups.ContainsKey(group))
                            permgroups.Add(group, presets[2]);
                    if (hasParams && isAdding && !permgroups.ContainsKey(newOrOldGroup))
                        permgroups.Add(newOrOldGroup, presets[2]);
                    permissionBlock.Add(usagePerm.Key, permgroups);
                }
                else
                {
                    bool wasFilled = false;
                    Dictionary<string, object> current = permissionBlock[usagePerm.Key] as Dictionary<string, object>;
                    if (!current.ContainsKey("admin"))
                    {
                        current.Add("admin", presets[0]);
                        wasFilled = true;
                    }

                    if (!current.ContainsKey("default"))
                    {
                        current.Add("default", presets[0]);
                        wasFilled = true;
                    }

                    if (wasFilled)
                    {
                        permissionBlock[usagePerm.Key] = current;
                        wasAdded = true;
                    }
                }
            }

            foreach (KeyValuePair<string, object> current in permissionBlock.ToList())
            {
                if (!playerPermissionMatrix.ContainsKey(current.Key))
                {
                    permissionBlock.Remove(current.Key);
                    wasAdded = true;
                    continue;
                }

                Dictionary<string, object> groupSet = current.Value as Dictionary<string, object>;
                if (hasParams)
                {
                    if (isAdding)
                    {
                        if (newOrOldGroup == "admin" || newOrOldGroup == "default") return "Aborted: Is inbuilt group";
                        if (groupSet.ContainsKey(newOrOldGroup)) return "Aborted: Already added!";
                        groupSet.Add(newOrOldGroup, (playerPermissionMatrix[current.Key] as object[])[2]);
                        result = $"Group {newOrOldGroup} was added and activated";
                    }
                    else if (!isAdding)
                    {
                        if (newOrOldGroup == "admin" || newOrOldGroup == "default") return "Aborted: Is inbuilt group";
                        if (!groupSet.ContainsKey(newOrOldGroup) && !groupSet.ContainsKey(newOrOldGroup.ToLower()))
                            return "Aborted: Not found!";
                        groupSet.Remove(newOrOldGroup);
                        groupSet.Remove(newOrOldGroup.ToLower());
                        result = $"Group {newOrOldGroup} was removed";
                    }

                    permissionBlock[current.Key] = groupSet;
                    wasAdded = true;
                }

                foreach (string key in groupSet.Keys)
                    if (!permissionGroups.Contains(key) && key != "admin" && key != "default")
                        permissionGroups.Add(key);
            }

            if (wasAdded)
            {
                Config["Permission", "AccessControl"] = permissionBlock;
                SaveConfig();
                return result;
            }

            return string.Empty;
        }

        private void CreateOverview()
        {
            if (aclVars != null && aclVars.Count > 0)
                foreach (ConsoleSystem.Command cmd in aclVars.ToList())
                    ConsoleSystem.Index.Server.Dict.Remove(cmd.FullName?.ToLower());
            aclVars = new List<ConsoleSystem.Command>();
            string parent = "uplifted.acl.";
            foreach (KeyValuePair<string, object> current in permissionBlock.ToList())
            foreach (KeyValuePair<string, object> groupSet in current.Value as Dictionary<string, object>)
            {
                ConsoleSystem.Command newCmd = new ConsoleSystem.Command
                {
                    Name = current.Key.ToLower(), Parent = parent + groupSet.Key,
                    FullName = parent + groupSet.Key + "." + current.Key.ToLower(), ServerAdmin = true, Variable = true,
                    Description = "| " + (string) (playerPermissionMatrix[current.Key] as object[])[3],
                    GetOveride = () =>
                        (permissionBlock[current.Key] as Dictionary<string, object>)[groupSet.Key].ToString(),
                    SetOveride = delegate(string str)
                    {
                        bool changed = false;
                        object value = (permissionBlock[current.Key] as Dictionary<string, object>)[groupSet.Key];
                        TypeCode typeCode = Convert.GetTypeCode(value);
                        switch (typeCode)
                        {
                            case TypeCode.Boolean:
                                if (value.ToString().ToBool() != str.ToBool())
                                {
                                    (permissionBlock[current.Key] as Dictionary<string, object>)[groupSet.Key] =
                                        str.ToBool();
                                    changed = true;
                                }

                                break;
                            case TypeCode.Single:
                            case TypeCode.Double:
                                if (value.ToString().ToFloat() != str.ToFloat())
                                {
                                    (permissionBlock[current.Key] as Dictionary<string, object>)[groupSet.Key] =
                                        str.ToFloat();
                                    changed = true;
                                }

                                break;
                            case TypeCode.Int32:
                            case TypeCode.UInt32:
                            case TypeCode.UInt64:
                                if (value.ToString().ToInt() != str.ToInt())
                                {
                                    (permissionBlock[current.Key] as Dictionary<string, object>)[groupSet.Key] =
                                        str.ToInt();
                                    changed = true;
                                }

                                break;
                            default: break;
                        }

                        if (changed)
                        {
                            Config["Permission", "AccessControl"] = permissionBlock;
                            SaveConfig();
                            CreateAcl();
                        }
                    }
                };
                aclVars.Add(newCmd);
            }

            foreach (ConsoleSystem.Command aclVar in aclVars)
                ConsoleSystem.Index.Server.Dict[aclVar.FullName.ToLower()] = aclVar;
            ConsoleSystem.Index.All = ConsoleSystem.Index.Server.Dict.Values.ToArray<ConsoleSystem.Command>();
        }

        private static string GetGroup(string userid, bool isActive)
        {
            if (!isActive && UpL.IsAdmPassive(userid)) return "admin";
            bool value = false;
            if (adminAccessEnabled.TryGetValue(userid, out value))
                if (isActive && value || !isActive)
                    return "admin";
            foreach (string group in UpL.permissionGroups)
                if (UpL.permission.UserHasGroup(userid, group))
                    return group;
            return "default";
        }

        private static object GetAccess(string variable, string userid, object fallbackValue = default(object),
            bool isActive = true)
        {
            object usagePerm;
            if (UpL.permissionBlock.TryGetValue(variable, out usagePerm))
            {
                string grouptype = GetGroup(userid, isActive);
                Dictionary<string, object> perms = usagePerm as Dictionary<string, object>;
                object value;
                if (perms.TryGetValue(grouptype, out value)) return value;
            }

            return fallbackValue;
        }

        private bool IsAdmPassive(string id)
        {
            if (admAccessAuthLevel == 2 && ServerUsers.Is(Convert.ToUInt64(id), ServerUsers.UserGroup.Owner))
                return true;
            if (admAccessAuthLevel == 1 &&
                ServerUsers.Is(Convert.ToUInt64(id), ServerUsers.UserGroup.Moderator)) return true;
            if (IsPseudoAdmin(id)) return true;
            if (permission.UserHasPermission(id, admAccessPermission)) return true;
            return false;
        }

        private static bool IsAdm(object p)
        {
            bool value = false;
            if (p is BasePlayer && adminAccessEnabled.TryGetValue((p as BasePlayer).UserIDString, out value))
                return value;
            else if (p is ulong && adminAccessEnabled.TryGetValue((string) p, out value)) return value;
            else if (p is string && adminAccessEnabled.TryGetValue((string) p, out value)) return value;
            return value;
        }

        private bool IsPseudoAdmin(string id)
        {
            foreach (string perm in pseudoPerms)
                if (permission.UserHasPermission(id, perm))
                    return true;
            return false;
        }

        private void OnUserPermissionGranted(string id, string perm)
        {
            if (pseudoPerms.Contains(perm.ToLower()))
            {
                adminAccessEnabled[id] = admAccessSwitchable ? admSwitchEnabledAtLogin : true;
                adminLiftEntkill[id] = false;
            }
        }

        [ConsoleCommand("upl.reloadacl")]
        private void CmdAclReload(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            LoadConfig();
            permissionBlock =
                (Dictionary<string, object>) GetConfig("Permission", "AccessControl", new Dictionary<string, object>());
            CreateAcl();
            CreateOverview();
            SendReply(arg,
                $"Reloaded acl with '{permissionBlock.Count}' switches across '{permissionGroups.Count + 2}' groups");
        }

        [ConsoleCommand("upl.addgroup")]
        private void CmdAclGroupAdd(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            if (!arg.HasArgs(1))
            {
                SendReply(arg, "Provide a goupname");
                return;
            }

            string newOrOld = arg.GetString(0, "");
            if (newOrOld.Length < 3)
            {
                SendReply(arg, "Group needs to have at least 3 characters");
                return;
            }

            LoadConfig();
            permissionBlock =
                (Dictionary<string, object>) GetConfig("Permission", "AccessControl", new Dictionary<string, object>());
            string result = CreateAcl(true, true, newOrOld.ToLower());
            if (result.StartsWith("Aborted"))
            {
                SendWarning(arg, result);
            }
            else
            {
                CreateOverview();
                SendReply(arg, result);
            }
        }

        [ConsoleCommand("upl.delgroup")]
        private void CmdAclGroupDel(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            if (!arg.HasArgs(1))
            {
                SendReply(arg, "Provide a goupname");
                return;
            }

            string newOrOld = arg.GetString(0, "").ToLower();
            if (newOrOld.Length < 3)
            {
                SendReply(arg, "Group needs to have at least 3 characters");
                return;
            }

            LoadConfig();
            permissionBlock =
                (Dictionary<string, object>) GetConfig("Permission", "AccessControl", new Dictionary<string, object>());
            string result = CreateAcl(true, false, newOrOld);
            if (result.StartsWith("Aborted"))
            {
                SendWarning(arg, result);
            }
            else
            {
                CreateOverview();
                SendReply(arg, result);
            }
        }

        [ConsoleCommand("upl.clonegroup")]
        private void CmdCloneGoup(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Provide a source and destination goupname");
                return;
            }

            string fromGroup = arg.GetString(0, "").ToLower();
            string toGroup = arg.GetString(1, "").ToLower();
            if (fromGroup.Length < 3 || toGroup.Length < 3)
            {
                SendReply(arg, "Group needs to have at least 3 characters (from to)");
                return;
            }

            if (toGroup == "admin" || toGroup == "default")
            {
                SendReply(arg, "You cannot clone into a standard-group");
                return;
            }

            if (fromGroup != "admin" && fromGroup != "default" &&
                (!permissionGroups.Contains(toGroup) || !permissionGroups.Contains(fromGroup)))
            {
                SendReply(arg, "At least one group does not exist in the acl");
                return;
            }

            foreach (KeyValuePair<string, object> current in permissionBlock.ToList())
            {
                Dictionary<string, object> groupSet = current.Value as Dictionary<string, object>;
                (permissionBlock[current.Key] as Dictionary<string, object>)[toGroup] = groupSet[fromGroup];
            }

            Config["Permission", "AccessControl"] = permissionBlock;
            SaveConfig();
            CreateAcl();
            SendReply(arg, "Group successfully cloned");
        }

        [ConsoleCommand("upl.resetgroup")]
        private void CmdResetGoup(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            if (!arg.HasArgs(1))
            {
                SendReply(arg, "Provide a goupname");
                return;
            }

            string fromGroup = arg.GetString(0, "").ToLower();
            if (fromGroup.Length < 3)
            {
                SendReply(arg, "Group needs to have at least 3 characters");
                return;
            }

            int toGroup;
            if (fromGroup == "admin") toGroup = 0;
            else if (fromGroup == "default") toGroup = 2;
            else toGroup = 1;
            foreach (KeyValuePair<string, object> current in permissionBlock.ToList())
            {
                object[] groupSet = playerPermissionMatrix[current.Key] as object[];
                (permissionBlock[current.Key] as Dictionary<string, object>)[fromGroup] = groupSet[toGroup];
            }

            Config["Permission", "AccessControl"] = permissionBlock;
            SaveConfig();
            CreateAcl();
            SendReply(arg, "Group was successfully reset to default");
        }

        [ConsoleCommand("upl.getgroupforuser")]
        private void CmdGetGroupForUser(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            if (!arg.HasArgs(1))
            {
                SendReply(arg, "Provide a user-id or username");
                return;
            }

            string userString = arg.GetString(0, "").ToLower();
            if (!permission.UserExists(userString))
            {
                IPlayer p = covalence.Players.FindPlayerById(userString);
                if (p != null)
                {
                    if (!permission.UserExists(p.Id))
                    {
                        SendReply(arg, "No userdata found under the provided info");
                        return;
                    }

                    string group1 = GetGroup(p.Id, false);
                    string group2 = GetGroup(p.Id, true);
                    if (group1 != group2)
                        SendReply(arg, $"Group-result for '{p.Name}': {group1}(passive) | {group2}(active)");
                    else SendReply(arg, $"Group-result for '{p.Name}': {group2}");
                    return;
                }

                IPlayer pl = covalence.Players.FindPlayer(userString);
                if (pl != null)
                {
                    if (!permission.UserExists(pl.Id))
                    {
                        SendReply(arg, "No userdata found under the provided info");
                        return;
                    }

                    string group1 = GetGroup(pl.Id, false);
                    string group2 = GetGroup(pl.Id, true);
                    if (group1 != group2)
                        SendReply(arg, $"Group-result for '{pl.Name}': {group1}(passive) | {group2}(active)");
                    else SendReply(arg, $"Group-result for '{pl.Name}': {group2}");
                    return;
                }

                SendReply(arg, "No userdata found under the provided info");
                return;
            }
        }
    }
}

// --- End of file: UpLifted.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UItems.cs ---
// --- Original Local Path: UItems.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("UItems","Baks","1.2")]
    public class UItems:RustPlugin
    {
        #region var

        private string pluginPrefix = "uitems";

        #endregion

        #region config

        class PluginConfig
        {
            [JsonProperty("Привилегия для Инструментов")]
            public string ToolsPerm;
            [JsonProperty("Привилегия для Оружия")]
            public string WeaponPerm;
            [JsonProperty("Привилегия для Одежды")]
            public string AttirePerm;
            [JsonProperty("Привилегия для Патронов")]
            public string AmmunitionPerm;
            [JsonProperty("Привилегия для Ракет")]
            public string RocketPerm;
        }

        private PluginConfig config;
        
        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
            Config.WriteObject(config);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig
            {
                ToolsPerm = ".tools",
                AttirePerm = ".attire",
                WeaponPerm = ".weapon",
                AmmunitionPerm = ".ammo",
                RocketPerm = ".rocket"
            }, true);
            
        }

        #endregion

        #region hooks

        void OnServerInitialized()
        {
            LoadConfig();
            permission.RegisterPermission(pluginPrefix+config.AmmunitionPerm,this);
            permission.RegisterPermission(pluginPrefix+config.ToolsPerm,this);
            permission.RegisterPermission(pluginPrefix+config.AttirePerm,this);
            permission.RegisterPermission(pluginPrefix+config.RocketPerm,this);
            permission.RegisterPermission(pluginPrefix+config.WeaponPerm,this);
            
        }

        void OnLoseCondition(Item item, ref float amount)
        {
            if (item == null) return;
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null) return;
                switch (item.info.category)
            {
                case ItemCategory.Tool:
                    if (permission.UserHasPermission(player.UserIDString,pluginPrefix+config.ToolsPerm)) item.RepairCondition(amount);
                    break;
                case  ItemCategory.Attire:
                    if (permission.UserHasPermission(player.UserIDString,pluginPrefix+config.AttirePerm)) item.RepairCondition(amount);
                    break;
                case  ItemCategory.Weapon:
                    if (permission.UserHasPermission(player.UserIDString,pluginPrefix+config.WeaponPerm)) item.RepairCondition(amount);
                    break;
            }
        }
        object OnAmmoUnload(BaseProjectile projectile, Item item, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString,pluginPrefix+config.AmmunitionPerm)) return null;
            return false;
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString,pluginPrefix+config.AmmunitionPerm)) return;
            projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
            projectile.SendNetworkUpdateImmediate();
        }

        private void OnRocketLaunched(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString,pluginPrefix+config.RocketPerm)) return;
            var heldItem = player.GetActiveItem();
            if (heldItem == null) return;
            var weapon = heldItem.GetHeldEntity() as BaseProjectile;
            if (weapon == null)
            {
                return;
            }
            weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
            weapon.SendNetworkUpdateImmediate();
        }

        #endregion
        
    }
}

// --- End of file: UItems.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Achievements.cs ---
// --- Original Local Path: Achievements.cs ---

﻿using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Network;
using UnityEngine;
using UnityEngine.UI;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Oxide.Core.Configuration;
using System.IO;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Achievments", "FADERUST", "1.0.1")]
    class Achievements : RustPlugin
    {
        public class Achievs
        {
            public string name;
            public Dictionary<string, bool> dostij;
            public Dictionary<string, int> dones;
            public string uid;
        }
        public double Xmin = 0.05;
        public double Xmin2 = 0.95;
        public double ymin = 0.82;
        public double ymin2 = 0.9;
        public double Xbutton = 0.60;
        public Dictionary<string, Achievs> achievementses = new Dictionary<string, Achievs>();
        public double Xbutton2 = 0.85;
        public double ybutton = 0.84;
        public double ybutton2 = 0.88;
        public Dictionary<ulong, Dictionary<string, int>> pagea = new Dictionary<ulong, Dictionary<string, int>>();
        public Dictionary<string, Achievs> achievs = new Dictionary<string, Achievs>();

        DynamicConfigFile players_File = Interface.Oxide.DataFileSystem.GetFile("Achievments/achievs");
        [PluginReference]
        Plugin RustShop, Case;

        public void GiveCase(BasePlayer player, int casecount)
        {
            Case.Call("GiveCase", player, casecount);
        }
        public void AddBalance(ulong userid, int Amount)
        {
            RustShop.Call("AddBalance", userid, Amount);
        }
        [ChatCommand("ach")]
        void CommandAchievments(BasePlayer player)
        {
            createachievmentsmenu(player);
        }
        public Dictionary<string, int> getallachivments(BasePlayer player)
        {
            var achievdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            Dictionary<string, int> allachievs = new Dictionary<string, int>();
            allachievs.Add("CollectWood", 0);
            allachievs.Add("CollectStone", 0);
            allachievs.Add("CollectMetall", 0);
            allachievs.Add("CollectSulfur", 0);
            allachievs.Add("CollectHQM", 0);
            allachievs.Add("KillAnimals", 0);
            allachievs.Add("KillPlayers", 0);
            allachievs.Add("CrateBuildings", 0);
            allachievs.Add("CraftRifle", 0);
            allachievs.Add("KillModerators", 0);
            allachievs.Add("WinEvent", 0);
            allachievs.Add("CraftExplosiveC4", 0);
            allachievs.Add("CraftExplosiveRockets", 0);
            foreach (var achievsplayer in achievdata)
            {
                if (achievsplayer.Key.Equals(player.UserIDString))
                {
                    if (achievsplayer.Value != null)
                    {
                        if (achievsplayer.Value.dones == null)
                        {
                            return allachievs;
                        }
                    }
                    if (achievsplayer.Value != null)
                    {

                        if (achievsplayer.Value.dones != null)
                        {
                            foreach (var dostijs in achievsplayer.Value.dones)
                            {
                                if (allachievs.ContainsKey(dostijs.Key))
                                {
                                    allachievs.Remove(dostijs.Key);
                                    allachievs.Add(dostijs.Key, dostijs.Value);
                                }
                            }
                        }
                    }
                }
            }
            return allachievs;
        }
        void getgiveresource(BasePlayer player, string name)
        {
            if (name.Equals("CollectWood")) { player.ChatMessage("Вам был выдан калаш"); }
            if (name.Equals("CollectStone")) { }
        }
        public string getnameitem(string name)
        {
            if (name.Equals("stones")) { name = "CollectStone"; }
            if (name.Equals("wood")) { name = "CollectWood"; }
            if (name.Equals("sulfur_ore")) { name = "CollectSulfur"; }
            if (name.Equals("metal_ore")) { name = "CollectMetall"; }
            if (name.Equals("hq_metal_ore")) { name = "CollectHQM"; }
            return name;
        }
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            var achivdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            var achivlist = new Dictionary<string, int>();
            string items1 = item.info.name.Replace(".item", "");
            if (items1.Equals("stones") || items1.Equals("wood") || items1.Equals("metal_ore") || items1.Equals("sulfur_ore"))
            {
                string items = getnameitem(items1);
                foreach (var playersachivs in achivdata)
                {
                    if (playersachivs.Key.Equals(player.UserIDString))
                    {
                        if (playersachivs.Value.dones == null)
                        {
                            if (achivlist != null)
                            {
                                if (achivlist.ContainsKey(items))
                                { achivlist.Remove(items); }
                            }
                            achivlist.Add(items, item.amount);
                            achievsplayeradd(player, playersachivs.Value.dostij, achivlist);
                            return;
                        }
                        if (playersachivs.Value.dones != null)
                        {
                            if(playersachivs.Value.dostij == null)
                            {
                                foreach (var achivs in playersachivs.Value.dones)
                                {
                                    achivlist.Add(achivs.Key, achivs.Value);
                                }
                                foreach (var namedones in playersachivs.Value.dones)
                                {
                                    if (namedones.Key.Equals(items))
                                    {
                                        if (achivlist.ContainsKey(items))
                                        { achivlist.Remove(items); }
                                        achivlist.Add(items, namedones.Value + item.amount);
                                        achievsplayeradd(player, playersachivs.Value.dostij, achivlist);
                                        if(getmax(items) <= namedones.Value + item.amount)
                                        {
                                            if (namedones.Value < getmax(items))
                                            {
                                                dostijeniecompletehud(player, items);
                                            }
                                        }
                                        return;
                                    }
                                    if (!playersachivs.Value.dones.ContainsKey(items))
                                    {
                                        if (achivlist.ContainsKey(items))
                                        { achivlist.Remove(items); }
                                        achivlist.Add(items, item.amount);
                                        achievsplayeradd(player, playersachivs.Value.dostij, achivlist);
                                        return;
                                    }
                                }
                            }
                            if (playersachivs.Value.dostij != null)
                            {
                                foreach (var playerdostijes in playersachivs.Value.dostij)
                                {
                                    if (playerdostijes.Key.Equals(items))
                                    {
                                        return;
                                    }
                                }
                                foreach (var achivs in playersachivs.Value.dones)
                                {
                                    achivlist.Add(achivs.Key, achivs.Value);
                                }
                                foreach (var namedones in playersachivs.Value.dones)
                                {
                                    if (namedones.Key.Equals(items))
                                    {      
                                        if (achivlist.ContainsKey(items))
                                        { achivlist.Remove(items); }
                                        achivlist.Add(items, namedones.Value + item.amount);
                                        achievsplayeradd(player, playersachivs.Value.dostij, achivlist);
                                        if (getmax(items) <= namedones.Value + item.amount)
                                        {
                                            if (namedones.Value < getmax(items))
                                            {
                                                dostijeniecompletehud(player, items);
                                            }
                                        }
                                        return;
                                    }
                                    if (!playersachivs.Value.dones.ContainsKey(items))
                                    {
                                        if (achivlist.ContainsKey(items))
                                        { achivlist.Remove(items); }
                                        achivlist.Add(items, item.amount);
                                        achievsplayeradd(player, playersachivs.Value.dostij, achivlist);
                                        if (getmax(items) <= namedones.Value + item.amount)
                                        {
                                            if (namedones.Value < getmax(items))
                                            {
                                                dostijeniecompletehud(player, items);
                                            }
                                        }
                                        return;
                                    }
                                }
                            }

                        }
                    }
                }
            }
        }

        private void dostijeniecompletehud(BasePlayer player, string items)
        {
            CuiHelper.DestroyUi(player, "dostijescomplete");
            var container = new CuiElementContainer();
            var panel = container.Add(new CuiPanel
            {
                 Image =
                {
                    Color = "0.5450980392156863 0.1568627450980392 0.8784313725490196 0.8"
                },
                RectTransform =
                {
                    AnchorMin = "0.8 0.88",
                    AnchorMax = "1 1"
                }
            }, "Hud", "dostijescomplete");
            container.Add(new CuiElement()
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiTextComponent {Text = getcompletetext(items), Align = TextAnchor.UpperCenter, FontSize = 16},
                    new CuiRectTransformComponent {AnchorMin = " 0.1 0.05"}
                }
            });
            CuiHelper.AddUi(player, container);
            timer.Once(15, () =>
            {
                CuiHelper.DestroyUi(player, "dostijescomplete");
            });
        }
        void OnPlayerDie(BasePlayer killed, HitInfo info)
        {
            var achivdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            var achivlist = new Dictionary<string, int>();
            if(killed == null) {return; }
            if (info == null) { return; }
            if (info.InitiatorPlayer == null) { return; }
            if (killed.IsNpc) { return; }
            if (info.InitiatorPlayer.IsNpc) { return; }
            BasePlayer player = info.InitiatorPlayer;
            achievslistadd(player, "KillPlayers", 1);
        }
        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            string items1 = item.info.name.Replace(".item", "");
            string items = getnameitem(items1);
            int count = item.amount;
            achievslistadd(player, items, count);
        }
        public void achievslistadd(BasePlayer player, string name, int count)
        {
            var achivdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            var achivlist = new Dictionary<string, int>();
            foreach (var players in achivdata)
            {
                if (players.Key.Equals(player.UserIDString))
                {
                    if (players.Value.dones != null)
                    {
                        foreach (var donest in players.Value.dones)
                        {
                            if (donest.Key.Equals(name))
                            {
                                foreach (var achivslists in players.Value.dones)
                                {
                                    achivlist.Add(achivslists.Key, achivslists.Value);
                                }
                                if (players.Value.dostij == null)
                                {
                                    if (achivlist.ContainsKey(name)) { achivlist.Remove(name); }
                                    achivlist.Add(name, donest.Value + count);
                                    if (donest.Value + count >= getmax(name))
                                    {
                                        if (donest.Value < getmax(name))
                                        {
                                            dostijeniecompletehud(player, name);
                                        }
                                    }
                                    achievsplayeradd(player, players.Value.dostij, achivlist);
                                    return;
                                }
                                if (players.Value.dostij != null)
                                {
                                    foreach (var dostijes in players.Value.dostij)
                                    {
                                        if (dostijes.Key.Equals(name)) { return; }
                                    }
                                    if (achivlist.ContainsKey(name)) { achivlist.Remove(name); }
                                    achivlist.Add(name, donest.Value + count);
                                    if (donest.Value + count >= getmax(name))
                                    {
                                        if (donest.Value < getmax(name))
                                        {
                                            dostijeniecompletehud(player, name);
                                        }
                                    }
                                    achievsplayeradd(player, players.Value.dostij, achivlist);
                                    return;
                                }
                            }
                            if (!players.Value.dones.ContainsKey(name))
                            {
                                foreach (var achivslists in players.Value.dones)
                                {
                                    achivlist.Add(achivslists.Key, achivslists.Value);
                                }
                                achivlist.Add(name, count);
                                achievsplayeradd(player, players.Value.dostij, achivlist);
                                return;
                            }
                        }
                    }
                    if (players.Value.dones == null)
                    {
                        achivlist.Add(name, count);
                        achievsplayeradd(player, players.Value.dostij, achivlist);
                        return;
                    }
                }
            }
    }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) { return; }
            if (info == null) { return; }
            if (info.InitiatorPlayer == null) { return; }
            if (entity is BaseAnimalNPC)
            {
                BasePlayer player = info.InitiatorPlayer;
                achievslistadd(player, "KillAnimals", 1);
            }
        }
        public string getcompletetext(string items)
        {
            string text = null;
            if(items.Equals("CollectWood")) { text = "\n Вы выполнили достижение" + "\n" + "\n"  + "Добыть 500000 дерева"; }
            if (items.Equals("CollectStone")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Добыть 300000 камня"; }
            if (items.Equals("CollectSulfur")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Добыть 100000 серы"; }
            if (items.Equals("CollectMetall")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Добыть 200000 металла"; }
            if (items.Equals("KillPlayers")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Убить 20 игроков"; }
            if (items.Equals("KillAnimals")) {text = "\n Вы выполнили достижение" + "\n" + "\n" + "Убить 100 животных"; }
            if (items.Equals("CraftRifle")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Скрафтить 25 винтовок"; }
            if (items.Equals("CraftExplosiveC4")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Скрафтить 50 c4"; }
            if (items.Equals("CraftExplosiveRockets")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Скрафтить 100 ракет"; }
            if (items.Equals("CrateBuildings")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Построить 1000 объектов"; }
            if (items.Equals("CollectHQM")) { text = "\n Вы выполнили достижение" + "\n" + "\n" + "Добыть 1000 мвк"; }

                return text;
        }
        void OnItemCraft(ItemCraftTask item)
        {
            BasePlayer player = item.owner;
            string items = item.blueprint.name.Replace(".item", "");
            if(items.Equals("ak47u")) { achievslistadd(player, "CraftRifle", item.amount); return; }
            if (items.Equals("explosive.timed")) { achievslistadd(player, "CraftExplosiveC4", item.amount); return; }
            if(items.Equals("ammo_rocket_basic")) { achievslistadd(player, "CraftExplosiveRockets", item.amount); return; }
        }
        [ConsoleCommand("page2open")]
        void page2(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            CuiHelper.DestroyUi(player, "AchievmentsPanel");
            var container = new CuiElementContainer();
            var achievsdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            Dictionary<string, int> activeacivements = new Dictionary<string, int>();
            foreach (var playerstigs in pagea)
            {
                if (playerstigs.Key.Equals(player.userID))
                {
                    activeacivements = playerstigs.Value;
                }
            }
            var panel = container.Add(new CuiPanel
            {
                Image = {
                    Color = "0.7686274509803922 0.5529411764705882 0.7137254901960784 0.4",
                },
                CursorEnabled = true,
                RectTransform =
                {
                    AnchorMin = "0.35 0.11",
                    AnchorMax = "0.60 0.95",
                }

            }, "Hud", "AchievmentsPanel2");
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiButtonComponent {Close = "AchievmentsPanel2", Color = "0 0 0 0"},
                    new CuiRectTransformComponent {AnchorMin = "-5 -4", AnchorMax = "0 5"}
                }
            });
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiButtonComponent {Close = "AchievmentsPanel2", Color = "0 0 0 0"},
                    new CuiRectTransformComponent {AnchorMin = "1 -4", AnchorMax = "6 5"}
                }
            });
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Url = "https://i.imgur.com/8poCpfR.png"
                    },
                    new CuiRectTransformComponent
                    {
                    AnchorMin = "0.80 0.02",
                    AnchorMax = "0.90 0.08",
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Url = "https://i.imgur.com/xyzRFoD.png"

                    },
                    new CuiRectTransformComponent
                    {
                    AnchorMin = "0.1 0.02",
                    AnchorMax = "0.2 0.08",
                    }
                }
            });
            container.Add(new CuiButton
            {
                Button =
                {
                  Command = "createachivmenu",
                  Color = "0 0 0 0",
                },
                Text =
                {
                    Text = ""
                },
                RectTransform =
                {
                    AnchorMin = "0.1 0.02",
                    AnchorMax = "0.2 0.08",
                }
            }, panel, "Paget2");
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiTextComponent {Text = "Достижения", Align = TextAnchor.UpperLeft, FontSize = 20},
                    new CuiRectTransformComponent {AnchorMin = "0.35 0.92", AnchorMax = "0.8 0.98"}
                }
            });
            foreach (var dostij in activeacivements)
            {
                string xs = Xmin + " " + ymin;
                string ys = Xmin2 + " " + ymin2;


                if (ymin > 0.12)
                {
                    container.Add(new CuiPanel
                    {
                        Image =
                {
                    Color = "0.5490196078431373 0.1843137254901961 0.8313725490196078 0.7"
                },
                        RectTransform =
                {
                    AnchorMin = xs,
                    AnchorMax = ys,
                }


                    }, panel, "Dostjenie");
                    if (dostij.Value < getmax(dostij.Key))
                    {
                        container.Add(new CuiElement
                        {
                            Name = CuiHelper.GetGuid(),
                            Parent = panel,
                            Components =
                        {
                            new CuiTextComponent
                            {
                                Text = gettext(dostij.Key, dostij.Value), Align = TextAnchor.MiddleCenter
                            },
                            new CuiRectTransformComponent { AnchorMin = xs, AnchorMax = ys }
                        }
                        });
                    }
                    if (dostij.Value >= getmax(dostij.Key))
                    {
                        foreach (var test in achievsdata)
                        {
                            if (test.Key.Equals(player.UserIDString))
                            {
                                if (test.Value.dostij != null)
                                {
                                    foreach (var dostijenia in test.Value.dostij)
                                    {
                                        if (dostijenia.Key.Equals(dostij.Key))
                                        {
                                            container.Add(new CuiElement
                                            {
                                                Name = CuiHelper.GetGuid(),
                                                Parent = panel,
                                                Components =
                        {
                            new CuiTextComponent { Text = gettext(dostij.Key, dostij.Value) + " Выполнено", Align = TextAnchor.MiddleCenter},
                            new CuiRectTransformComponent { AnchorMin = xs, AnchorMax = ys }
                        }
                                            });
                                        }
                                    }
                                }
                            }
                        }
                        foreach (var test in achievsdata)
                        {
                            Dictionary<string, bool> dostiges = new Dictionary<string, bool>();
                            if (test.Key.Equals(player.UserIDString))
                            {
                                if (test.Value.dostij != null)
                                {
                                    foreach (var dostig in test.Value.dostij)
                                    {
                                        dostiges.Add(dostig.Key, dostig.Value);
                                    }
                                    if (!dostiges.ContainsKey(dostij.Key))
                                    {
                                        string xsbutton1 = Xbutton + " " + ybutton;
                                        string xsbutton2 = Xbutton2 + " " + ybutton2;
                                        container.Add(new CuiElement
                                        {
                                            Name = CuiHelper.GetGuid(),
                                            Parent = panel,
                                            Components =
                        {
                            new CuiTextComponent
                            {
                                Text = gettext(dostij.Key, dostij.Value), Align = TextAnchor.MiddleLeft
                            },
                            new CuiRectTransformComponent { AnchorMin = xs, AnchorMax = ys }
                        }
                                        });
                                        container.Add(new CuiButton
                                        {

                                            Button =
                                    {
                                        Command = "takeprize " + dostij.Key, Color = "0.407843137254902 0.2 0.8313725490196078 0.6",
                                    },
                                            Text =
                                    {
                                       Text = "Забрать", Align = TextAnchor.MiddleCenter
                                    },
                                            RectTransform =
                                    {
                                        AnchorMin = xsbutton1, AnchorMax = xsbutton2
                                    }

                                        }, panel, "Buttonget");
                                    }
                                }

                                if (test.Value.dostij == null)
                                {
                                    string xsbutton1 = Xbutton + " " + ybutton;
                                    string xsbutton2 = Xbutton2 + " " + ybutton2;
                                    container.Add(new CuiElement
                                    {
                                        Name = CuiHelper.GetGuid(),
                                        Parent = panel,
                                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = gettext(dostij.Key, dostij.Value), Align = TextAnchor.MiddleLeft
                            },
                            new CuiRectTransformComponent { AnchorMin = xs, AnchorMax = ys }
                        }
                                    });
                                    container.Add(new CuiButton
                                    {

                                        Button =
                                    {
                                        Command = "takeprize " + dostij.Key, Color = "0.407843137254902 0.2 0.8313725490196078 0.6",
                                    },
                                        Text =
                                    {
                                       Text = "Забрать", Align = TextAnchor.MiddleCenter
                                    },
                                        RectTransform =
                                    {
                                        AnchorMin = xsbutton1, AnchorMax = xsbutton2
                                    }

                                    }, panel, "Buttonget");
                                }
                            }
                        }
                    }
                    ymin = ymin - 0.1;
                    ymin2 = ymin2 - 0.1;
                    ybutton = ybutton - 0.1;
                    ybutton2 = ybutton2 - 0.1;
                }
            }
            Xmin = 0.05;
            Xmin2 = 0.95;
            ymin = 0.82;
            ymin2 = 0.9;
            Xbutton = 0.60;
            Xbutton2 = 0.85;
            ybutton = 0.84;
            ybutton2 = 0.88;
            CuiHelper.AddUi(player, container);
                }
        private string gettext(string key, int count)
        {
            string text = "Xex";
            int getmaxs = getmax(key);
            if (key.Equals("CollectWood")) { if (count < getmaxs) { text = "Добудьте 500000 дерева. Добыто: " +  + count + "/" + getmaxs + "\n Приз: 100 монет, 1 кейс"; }  if (count >= getmaxs) { text = "           Добудьте 500000 дерева - "; } }
            if (key.Equals("CollectStone")) { if (count < getmaxs) { text = "Добудьте 300000 камня. Добыто: " + count + "/" + getmaxs + "\n Приз: 150 монет"; } if (count >= getmaxs) { text = "           Добудьте 300000 камня - "; } }
            if (key.Equals("CollectMetall")) { if (count < getmaxs) { text = "Добудьте 200000 металла. Добыто: " + count + "/" + getmaxs + "\n Приз: 180 монет, 1 кейс"; } if (count >= getmaxs) { text = "           Добудьте 200000 металла - "; } }
            if (key.Equals("CollectSulfur")) { if (count < getmaxs) { text = "Добудьте 100000 серы. Добыто: " + count + "/" + getmaxs + "\n Приз: 200 монет, 1 кейс"; } if (count >= getmaxs) { text = "           Добудьте 100000 серы - "; } }
            if (key.Equals("CollectHQM")) { if (count < getmaxs) { text = "Добудьте 1000 мвк. Добыто: " + count + "/" + getmaxs + "\n Приз: 140 монет"; } if (count >= getmaxs) { text = "           Добудьте 1000 мвк - "; } }
            if (key.Equals("KillAnimals")) { if (count < getmaxs) { text = "Убейте 100 животных. Убито: " + count + "/" + getmaxs + "\n Приз: 50 монет"; } if (count >= getmaxs) { text = "           Убейте 100 животных - "; } }
            if (key.Equals("KillPlayers")) { if (count < getmaxs) { text = "Убейте 20 игроков. Убито: " + count + "/" + getmaxs + "\n Приз: 120 монет."; } if (count >= getmaxs) { text = "           Убейте 20 игроков - "; } }
            if (key.Equals("CrateBuildings")) { if (count < getmaxs) { text = "Постройте 1000 объектов. Построено: " + count + "/" + getmaxs + "\n Приз: 1 кейс, 50 монет"; } if (count >= getmaxs) { text = "           Постройте 1000 объектов - "; } }
            if (key.Equals("CraftRifle")) { if (count < getmaxs) { text = "Скрафтите 25 винтовок. Скрафчено: " + count + "/" + getmaxs + "\n Приз: 60 монет"; } if (count >= getmaxs) { text = "           Скрафтите 25 винтовок - "; } }
            if (key.Equals("KillModerators")) { if (count < getmaxs) { text = "Убейте модератора. Убито: " + count + "/" + getmaxs + "\n Приз: 2 кейса, 120 монет"; } if (count >= getmaxs) { text = "           Убейте модератора - "; } }
            if (key.Equals("WinEvent")) { if (count < getmaxs) { text = "Выиграйте 10 ивентов. Выиграно: " + count + "/" + getmaxs + "\n Приз: 2 кейса, 200 монет"; } if (count >= getmaxs) { text = "           Выиграйте 10 ивентов - "; } }
            if (key.Equals("CraftExplosiveC4")) { if (count < getmaxs) { text = "Скрафтите 50 c4. Скрафчено: " + count + "/" + getmaxs + "\n Приз: 100 монет"; } if (count >= getmaxs) { text = "           Скрафтите 50 c4 - "; } }
            if (key.Equals("CraftExplosiveRockets")) { if (count < getmaxs) { text = "Скрафтите 100 ракет. Скрафчено: " + count + "/" + getmaxs + "\n Приз: 110 монет, 1 кейс"; } if (count >= getmaxs) { text = "           Скрафтите 100 ракет - "; } }
            return text;
        }
        private int getmax(string name)
        {
            int countmax = 0;
            if (name.Equals("CollectWood")) { countmax = 500000; }
            if (name.Equals("CollectStone")) { countmax = 300000; }
            if (name.Equals("CollectMetall")) { countmax = 200000; }
            if (name.Equals("CollectSulfur")) { countmax = 100000; }
            if (name.Equals("CollectHQM")) { countmax = 1000; }
            if (name.Equals("KillAnimals")) { countmax = 100; }
            if (name.Equals("KillPlayers")) { countmax = 20; }
            if (name.Equals("CrateBuildings")) { countmax = 1000; }
            if (name.Equals("CraftRifle")) { countmax = 25; }
            if (name.Equals("KillModerators")) { countmax = 1; }
            if (name.Equals("WinEvent")) { countmax = 10; }
            if (name.Equals("CraftExplosiveC4")) { countmax = 50; }
            if (name.Equals("CraftExplosiveRockets")) { countmax = 100; }
            return countmax;
        }
        void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan.GetOwnerPlayer();
            achievslistadd(player, "CrateBuildings", 1);
        }
        [ConsoleCommand("createachivmenu")]
        void achivscreatemenu(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            createachievmentsmenu(player);
        }
        [ConsoleCommand("takeprize")]
        void takeprize(ConsoleSystem.Arg arg)
        {
            Dictionary<string, bool> dostij = new Dictionary<string, bool>();
            Achievs achivs = new Achievs();
            BasePlayer player = arg.Connection.player as BasePlayer;
            string name = arg.Args[0];
            var achievsdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            foreach (var players in achievsdata)
            {
                if(players.Key.Equals(player.UserIDString))
                {
                   achivs = players.Value;
                }
            }
            if(achivs.dostij != null && achivs.dostij.Count > 0)
            foreach(var dostijesg in achivs.dostij)
            {
                dostij.Add(dostijesg.Key, dostijesg.Value);
            }
            if (name.Equals("CollectStone")) { player.ChatMessage("Вам были выданы: 100 монет и 1 кейс!"); dostij.Add("CollectStone", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 100); GiveCase(player, 1); }
            if (name.Equals("CollectWood")) { player.ChatMessage("Вам были выданы: 150 монет!"); dostij.Add("CollectWood", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 150); }
            if (name.Equals("CollectMetall")) { player.ChatMessage("Вам были выданы: 180 монет и 1 кейс!"); dostij.Add("CollectMetall", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 180); GiveCase(player, 1); }
            if (name.Equals("CollectSulfur")) { player.ChatMessage("Вам были выданы: 200 монет и 1 кейс!"); dostij.Add("CollectSulfur", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 200); GiveCase(player, 1); }
            if (name.Equals("CollectHQM")) { player.ChatMessage("Вам были выданы: 140 монет!"); dostij.Add("CollectHQM", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 140); }
            if (name.Equals("KillAnimals")) { player.ChatMessage("Вам были выданы: 50 монет!"); dostij.Add("KillAnimals", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 50); }
            if (name.Equals("KillPlayers")) { player.ChatMessage("Вам были выданы: 120 монет!"); dostij.Add("KillPlayers", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 120); }
            if (name.Equals("CrateBuildings")) { player.ChatMessage("Вам были выданы: 50 монет и 1 кейс!"); dostij.Add("CrateBuildings", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 50); GiveCase(player, 1); }
            if (name.Equals("CraftRifle")) { player.ChatMessage("Вам были выданы: 100 монет и 1 кейс!"); dostij.Add("CraftRifle", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 100); GiveCase(player, 1); }
            if (name.Equals("KillModerators")) { player.ChatMessage("Вам были выданы: 120 монет и 2 кейса!"); dostij.Add("KillModerators", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 120); GiveCase(player, 2); }
            if (name.Equals("WinEvent")) { player.ChatMessage("Вам были выданы: 200 монет и 2 кейса!"); dostij.Add("WinEvent", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 200); GiveCase(player, 2); }
            if (name.Equals("CraftExplosiveRockets")) { player.ChatMessage("Вам были выданы: 100 монет!"); dostij.Add("CraftExplosiveRockets", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 100); }
            if (name.Equals("CraftExplosiveC4")) { player.ChatMessage("Вам были выданы: 110 монет и 1 кейс!"); dostij.Add("CraftExplosiveC4", true); achievsplayeradd(player, dostij, achivs.dones); createachievmentsmenu(player); AddBalance(player.userID, 110); GiveCase(player, 1); }
        }
        public void createachievmentsmenu(BasePlayer player)
        {
            var allachievsofplayer = getallachivments(player);
            CuiHelper.DestroyUi(player, "AchievmentsPanel");
            var achievsdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            CuiHelper.DestroyUi(player, "AchievmentsPanel2");
            Dictionary<string, int> dostijes = new Dictionary<string, int>();
            CuiElementContainer container = new CuiElementContainer();

            var panel = container.Add(new CuiPanel
            {
                Image = {
                    Color = "0.7686274509803922 0.5529411764705882 0.7137254901960784 0.4",
                },
                CursorEnabled = true,
                RectTransform =
                {
                    AnchorMin = "0.35 0.11",
                    AnchorMax = "0.60 0.95",
                }

            }, "Hud", "AchievmentsPanel");
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiButtonComponent {Close = "AchievmentsPanel", Color = "0 0 0 0"},
                    new CuiRectTransformComponent {AnchorMin = "-5 -4", AnchorMax = "0 5"}
                }
            });
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiButtonComponent {Close = "AchievmentsPanel", Color = "0 0 0 0"},
                    new CuiRectTransformComponent {AnchorMin = "1 -4", AnchorMax = "6 5"}
                }
            });
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiTextComponent {Text = "Достижения", Align = TextAnchor.UpperLeft, FontSize = 20},
                    new CuiRectTransformComponent {AnchorMin = "0.35 0.92", AnchorMax = "0.8 0.98"}
                }
            });
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Url = "https://i.imgur.com/8poCpfR.png"
                    },
                    new CuiRectTransformComponent
                    {
                    AnchorMin = "0.80 0.02",
                    AnchorMax = "0.90 0.08",
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = panel,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Url = "https://i.imgur.com/xyzRFoD.png"

                    },
                    new CuiRectTransformComponent
                    {
                    AnchorMin = "0.1 0.02",
                    AnchorMax = "0.2 0.08",
                    }
                }
            });
            container.Add(new CuiButton
            {
                Button =
                {
                  Command = "page2open",
                  Color = "0 0 0 0",
                },
                Text =
                {
                    Text = ""
                },
                RectTransform =
                {
                    AnchorMin = "0.80 0.02",
                    AnchorMax = "0.90 0.08",
                }
            }, panel, "Paget2");
            foreach (var dostij in allachievsofplayer)
            {
                string xs = Xmin + " " + ymin;
                string ys = Xmin2 + " " + ymin2;

                
                if (ymin > 0.12)
                {
                    container.Add(new CuiPanel
                    {
                        Image =
                {
                    Color = "0.5490196078431373 0.1843137254901961 0.8313725490196078 0.7"
                },
                        RectTransform =
                {
                    AnchorMin = xs,
                    AnchorMax = ys,
                }


                    }, panel, "Dostjenie");
                    if (dostij.Value < getmax(dostij.Key))
                    {
                        container.Add(new CuiElement
                        {
                            Name = CuiHelper.GetGuid(),
                            Parent = panel,
                            Components =
                        {
                            new CuiTextComponent
                            {
                                Text = gettext(dostij.Key, dostij.Value), Align = TextAnchor.MiddleCenter
                            },
                            new CuiRectTransformComponent { AnchorMin = xs, AnchorMax = ys }
                        }
                        });
                    }
                    if (dostij.Value >= getmax(dostij.Key))
                    {
                        foreach (var test in achievsdata)
                        {
                            if (test.Key.Equals(player.UserIDString))
                            {
                                if (test.Value.dostij != null)
                                {
                                    foreach (var dostijenia in test.Value.dostij)
                                    {
                                        if (dostijenia.Key.Equals(dostij.Key))
                                        {
                                            container.Add(new CuiElement
                                            {
                                                Name = CuiHelper.GetGuid(),
                                                Parent = panel,
                                                Components =
                        {
                            new CuiTextComponent { Text = gettext(dostij.Key, dostij.Value) + " Выполнено", Align = TextAnchor.MiddleCenter},
                            new CuiRectTransformComponent { AnchorMin = xs, AnchorMax = ys }
                        }
                                            });
                                        }
                                    }
                                }
                            }
                        }
                        foreach (var test in achievsdata)
                        {
                            Dictionary<string, bool> dostiges = new Dictionary<string, bool>();
                            if (test.Key.Equals(player.UserIDString))
                            {
                                if (test.Value.dostij != null)
                                {
                                    foreach (var dostig in test.Value.dostij)
                                    {
                                        dostiges.Add(dostig.Key, dostig.Value);
                                    }
                                    if (!dostiges.ContainsKey(dostij.Key))
                                    {
                                        string xsbutton1 = Xbutton + " " + ybutton;
                                        string xsbutton2 = Xbutton2 + " " + ybutton2;
                                        container.Add(new CuiElement
                                        {
                                            Name = CuiHelper.GetGuid(),
                                            Parent = panel,
                                            Components =
                        {
                            new CuiTextComponent
                            {
                                Text = gettext(dostij.Key, dostij.Value), Align = TextAnchor.MiddleLeft
                            },
                            new CuiRectTransformComponent { AnchorMin = xs, AnchorMax = ys }
                        }
                                        });
                                        container.Add(new CuiButton
                                        {

                                            Button =
                                    {
                                        Command = "takeprize " + dostij.Key, Color = "0.407843137254902 0.2 0.8313725490196078 0.6",
                                    },
                                            Text =
                                    {
                                       Text = "Забрать", Align = TextAnchor.MiddleCenter
                                    },
                                            RectTransform =
                                    {
                                        AnchorMin = xsbutton1, AnchorMax = xsbutton2
                                    }

                                        }, panel, "Buttonget");
                                    }
                                }

                                if (test.Value.dostij == null)
                                {
                                    string xsbutton1 = Xbutton + " " + ybutton;
                                    string xsbutton2 = Xbutton2 + " " + ybutton2;
                                    container.Add(new CuiElement
                                    {
                                        Name = CuiHelper.GetGuid(),
                                        Parent = panel,
                                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = gettext(dostij.Key, dostij.Value), Align = TextAnchor.MiddleLeft
                            },
                            new CuiRectTransformComponent { AnchorMin = xs, AnchorMax = ys }
                        }
                                    });
                                    container.Add(new CuiButton
                                    {

                                        Button =
                                    {
                                        Command = "takeprize " + dostij.Key, Color = "0.407843137254902 0.2 0.8313725490196078 0.6",
                                    },
                                        Text =
                                    {
                                       Text = "Забрать", Align = TextAnchor.MiddleCenter
                                    },
                                        RectTransform =
                                    {
                                        AnchorMin = xsbutton1, AnchorMax = xsbutton2
                                    }

                                    }, panel, "Buttonget");
                                }
                            }
                        }
                    }
                    ymin = ymin - 0.1;
                    ymin2 = ymin2 - 0.1;
                    ybutton = ybutton - 0.1;
                    ybutton2 = ybutton2 - 0.1;
                }
                if (ymin < 0.12)
                {
                    if (!dostij.Key.Equals("CrateBuildings"))
                    {
                        dostijes.Add(dostij.Key, dostij.Value);
                    }
                }
            }
            if (pagea.ContainsKey(player.userID))
            {
                pagea.Remove(player.userID);
            }
                pagea.Add(player.userID, dostijes);
            
        Xmin = 0.05;
        Xmin2 = 0.95;
        ymin = 0.82;
        ymin2 = 0.9;
        Xbutton = 0.60;
        Xbutton2 = 0.85;
        ybutton = 0.84;
        ybutton2 = 0.88;
            CuiHelper.AddUi(player, container);
        }
        void achievsplayeradd(BasePlayer player, Dictionary<string, bool> dostij, Dictionary<string, int> dones)
        {
            var achievdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            Dictionary<string, Achievs> playersachievs = new Dictionary<string, Achievs>();
            achievementses.Add(player.UserIDString, new Achievs()
            {
                dones = dones,
                dostij = dostij,
                name = player.displayName,
                uid = player.UserIDString
            });
            foreach (var pldf in achievdata)
            {
                if (pldf.Value != null)
                {
                    if (!pldf.Value.uid.Equals(player.UserIDString))
                    {
                        achievementses.Add(pldf.Value.uid, new Achievs()
                        {
                            name = pldf.Value.name,
                            dostij = pldf.Value.dostij,
                            dones = pldf.Value.dones,
                            uid = pldf.Value.uid,
                        });
                    }
                }
            }
          Interface.Oxide.DataFileSystem.WriteObject("Achievments/achievs", achievementses);
            achievementses = new Dictionary<string, Achievs>();
        }
        void OnPlayerInit(BasePlayer player)
        {
            Dictionary<string, Achievs> PlayerAchievs = new Dictionary<string, Achievs>();
            PlayerAchievs = players_File.ReadObject<Dictionary<string, Achievs>>();
            var achievdata = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Achievs>>("Achievments/achievs");
            if (!achievdata.ContainsKey(player.UserIDString))
            {
                PlayerAchievs.Add(player.UserIDString, new Achievs()
                {
                    name = player.displayName,
                    uid = player.UserIDString,
                    dostij = null,
                    dones = null,
                });
                Interface.Oxide.DataFileSystem.WriteObject("Achievments/achievs", PlayerAchievs);
            }
        }
        void OnServerIntializied()
        {
        }
    }
}
                                                                                                     

// --- End of file: Achievements.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ID.cs ---
// --- Original Local Path: ID.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using Oxide;

namespace Oxide.Plugins
{
    [Info("ID Lookup", "Cheeze", "0.1")]
    [Description("Lookup a connected player's steamid")]
    class ID : RustPlugin
    {



        #region vclean command
        [ChatCommand("id")]
        void cmdID(BasePlayer player, string cmd, string[] args)
        {

                if (args.Length == 1)
                {
                    int n;
                string name = GetPlayer(args[0], player).displayName.ToString();
                string targetID = null;                
                        targetID = GetPlayer(args[0], player).userID.ToString();


                    SendReply(player, name + "'s ID = " + targetID);
                }
                else
                {
                    SendReply(player, "Incorrect syntax! /id {target}");
                }
        }

        #endregion

        #region Functions
        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix = null)
        {
            BasePlayer targetPlayer = null;
            List<string> foundPlayers = new List<string>();
            string searchedLower = searchedPlayer.ToLower();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(searchedLower)) foundPlayers.Add(player.displayName);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(executer, prefix, "The Player can not be found.");
                    break;

                case 1:
                    targetPlayer = BasePlayer.Find(foundPlayers[0]);
                    break;

                default:
                    string players = ListToString(foundPlayers, 0, ", ");
                    SendChatMessage(executer, prefix, "Multiple matching players found: \n" + players);
                    break;
            }

            return targetPlayer;
        }

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        void SendChatMessage(BasePlayer player, string prefix, string msg = null)
        {
            SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
        }
        #endregion

    }
}

// --- End of file: ID.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SaveMyMap.cs ---
// --- Original Local Path: SaveMyMap.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using UnityEngine;

using IEnumerator = System.Collections.IEnumerator;

namespace Oxide.Plugins
{
	[Info("SaveMyMap", "Fujikura", "1.0.0", ResourceId = 2111)] 
	class SaveMyMap : RustPlugin
	{
		bool Changed;
		SaveRestore saveRestore = null;
		int Rounds;
		bool Initialized;
		string saveFolder;
		bool loadReload;
		string [] saveFolders;

		int saveInterval;
		int saveCustomAfter;
		bool callOnServerSave;
		float delayCallOnServerSave;
		bool saveAfterLoadFile;
		bool allowOutOfDateSaves;
		bool enableLoadOverride;
		int numberOfSaves;

		object GetConfig(string menu, string datavalue, object defaultValue)
		{
			var data = Config[menu] as Dictionary<string, object>;
			if (data == null)
			{
				data = new Dictionary<string, object>();
				Config[menu] = data;
				Changed = true;
			}
			object value;
			if (!data.TryGetValue(datavalue, out value))
			{
				value = defaultValue;
				data[datavalue] = value;
				Changed = true;
			}
			return value;
		}

		void LoadVariables()
		{
			saveInterval = Convert.ToInt32(GetConfig("Settings", "saveInterval", 1200));
			saveCustomAfter = Convert.ToInt32(GetConfig("Settings", "saveCustomAfter", 1));
			callOnServerSave = Convert.ToBoolean(GetConfig("Settings", "callOnServerSave", true));
			delayCallOnServerSave = Convert.ToInt32(GetConfig("Settings", "delayCallOnServerSave", 3));
			saveAfterLoadFile = Convert.ToBoolean(GetConfig("Settings", "saveAfterLoadFile", true));
			enableLoadOverride = Convert.ToBoolean(GetConfig("Settings", "enableLoadOverride", true));
			allowOutOfDateSaves = Convert.ToBoolean(GetConfig("Settings", "allowOutOfDateSaves", false));
			numberOfSaves = Convert.ToInt32(GetConfig("Settings", "numberOfSaves", 10));

			if (!Changed) return;
			SaveConfig();
			Changed = false;
		}
		
		void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			                      {
									{"kickreason", "Map restore was initiated. Please wait a momemt"},
									{"loadedinfo", "Saveinverval set to: {0} sec. | Custom save after every '{1}' saves"},
									{"alreadysaving", "Server already saving"},
									{"customsavecomplete", "Custom saving complete"},
									{"needconfirm", "You need to confirm with 'force'"},
									{"definefilename", "You need to define a filename to load"},
									{"lastfilename", "You can load the last file by typing 'load' as name"},
									{"filenotfound", "The given filename was not found."},
									{"dirnotfound", "Save Directory not found. Will be recreated for next save."},									
									{"loadoverride", "Loadfile override succesful."},										

			                      },this);
		}

		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadVariables();
		}

		void Init()
		{
			LoadVariables();
			LoadDefaultMessages();
			Rounds = 0;
			saveFolders = SaveFolders();
		}

		void Unload()
		{
			if (saveRestore != null)
				saveRestore.timedSave = true;
		}

		void OnServerInitialized()
		{
			saveRestore = SingletonComponent<SaveRestore>.Instance;
			saveRestore.timedSave = false;
			saveFolder = $"{ConVar.Server.rootFolder}/saves/{0}/";
			timer.Every(saveInterval, SaveLoop);
			Initialized = true;
			Puts(lang.GetMessage("loadedinfo", this), saveInterval, saveCustomAfter);
		}		
		
		void SaveLoop()
		{
			if (!Initialized) return;
			if (Rounds < saveCustomAfter && saveCustomAfter > 0) {
				foreach (BaseEntity current in BaseEntity.saveList)
					current.InvalidateNetworkCache();
				if (callOnServerSave)
					timer.Once(delayCallOnServerSave, () => Interface.CallHook("OnServerSave", null));
				IEnumerator original = SaveRestore.Save(ConVar.Server.rootFolder+"/"+SaveRestore.SaveFileName, true);					
				while (original.MoveNext()) {} 
				if (!callOnServerSave) Interface.Oxide.DataFileSystem.WriteObject(this.Title, new List<object>(new object[] { ConVar.Server.rootFolder+"/"+SaveRestore.SaveFileName, "default" }) );
				Rounds++;
			} else {
				string file = saveFolder + SaveRestore.SaveFileName;
				if (callOnServerSave)
					timer.Once(delayCallOnServerSave, () => Interface.CallHook("OnServerSave", file));
				try {
					SaveBackupCreate();
					foreach (BaseEntity current in BaseEntity.saveList)
						current.InvalidateNetworkCache();
					IEnumerator custom = SaveRestore.Save(file, true);					
					while (custom.MoveNext()) {}
					if (!callOnServerSave) Interface.Oxide.DataFileSystem.WriteObject(this.Title, new List<object>(new object[] { file, "custom" }) );}
				catch { PrintWarning(lang.GetMessage("dirnotfound", this)); }
				Rounds = 0;
			}
		}
		
		void OnServerSave(object file = null)
		{
			string type;
			if (file == null)
			{
				file = ConVar.Server.rootFolder+"/"+SaveRestore.SaveFileName;
				type = "default";
			}
			else
				type = "custom";
			Interface.Oxide.DataFileSystem.WriteObject(this.Title, new List<object>(new object[] { file, type }) );
		}
		
		object OnSaveLoad(Dictionary<BaseEntity, ProtoBuf.Entity> dictionary)
		{
			if (Initialized || loadReload) return null;
			if (!enableLoadOverride) return null;
			if (!loadReload)
			{
			List<string> filename = Interface.Oxide.DataFileSystem.ReadObject<List<string>>(this.Title);
			if (filename != null && filename.Count == 2)
				if (filename[1] == "custom")
				{
					loadReload = true;
					if (SaveRestore.Load(filename[0], allowOutOfDateSaves))
					{
						dictionary.Clear();
						Puts(lang.GetMessage("loadoverride", this));
						return true;
					}
				}
			}
			return null;
		}
		
		[ConsoleCommand("smm.save")]
		void cMapSave(ConsoleSystem.Arg arg)
		{
			if(arg.connection != null && arg.connection.authLevel < 2) return;
			if (SaveRestore.IsSaving) {
				SendReply(arg, lang.GetMessage("alreadysaving", this, arg.connection != null ? arg.connection.userid.ToString() : null ));
				return;
			}
			SaveBackupCreate();
			string saveName;
			saveName = saveFolder + SaveRestore.SaveFileName;
			try {
				foreach (BaseEntity current in BaseEntity.saveList)
					current.InvalidateNetworkCache();
				IEnumerator enumerator = SaveRestore.Save(saveName, true);
				while (enumerator.MoveNext()) {}
				Interface.Oxide.DataFileSystem.WriteObject(this.Title, new List<object>(new object[] { saveName, "custom" }) );
				arg.ReplyWith(lang.GetMessage("customsavecomplete", this, arg.connection != null ? arg.connection.userid.ToString() : null )); }
			catch { PrintWarning(lang.GetMessage("dirnotfound", this)); }
		}
		
		[ConsoleCommand("smm.loadmap")]
		void cLoadMap(ConsoleSystem.Arg arg)
		{
			if(arg.connection != null && arg.connection.authLevel < 2) return;
			if (arg.Args == null || arg.Args.Length != 1 || arg.Args[0] != "force")
			{
				SendReply(arg, lang.GetMessage("needconfirm", this, arg.connection != null ? arg.connection.userid.ToString() : null ));
				return;
			}
			foreach (var player in BasePlayer.activePlayerList.ToList())
				player.Kick(lang.GetMessage("kickreason", this, player.UserIDString));
			SaveRestore.Load(ConVar.Server.rootFolder+"/"+SaveRestore.SaveFileName, allowOutOfDateSaves);
		}

		[ConsoleCommand("smm.loadfile")]
		void cLoadFile(ConsoleSystem.Arg arg)
		{
			if(arg.connection != null && arg.connection.authLevel < 2) return;
			if (arg.Args == null || arg.Args.Length < 1 )
			{
					SendReply(arg, lang.GetMessage("definefilename", this, arg.connection != null ? arg.connection.userid.ToString() : null ));
					return;
			}
			int folderNumber = -1;
			if (arg.Args[0].Length <= 4 && arg.Args[0] != "last" && !int.TryParse(arg.Args[0], out folderNumber))
			{
					SendReply(arg, lang.GetMessage("lastfilename", this, arg.connection != null ? arg.connection.userid.ToString() : null ));
					return;
			}			
			string file = "";
			if (arg.Args[0] == "last")
			{
				List<string> filename = Interface.Oxide.DataFileSystem.ReadObject<List<string>>(this.Title);
				if (filename != null)
					file = filename.First();
			}
			else if (int.TryParse(arg.Args[0], out folderNumber))
			{
				file = $"{ConVar.Server.rootFolder}/saves/{folderNumber}/{SaveRestore.SaveFileName}";
			}
			if (file == "")
				file = saveFolder + arg.Args[0];

			foreach (var player in BasePlayer.activePlayerList.ToList())
				player.Kick(lang.GetMessage("kickreason", this));

			if (SaveRestore.Load(file, allowOutOfDateSaves))
			{
				if (saveAfterLoadFile)
				{
					foreach (BaseEntity current in BaseEntity.saveList)
						current.InvalidateNetworkCache();
					SaveRestore.Save(true);
				}
			}
			else
			{
				SendReply(arg, lang.GetMessage("filenotfound", this, arg.connection != null ? arg.connection.userid.ToString() : null ));
				return;
			}
		}

		Int32 UnixTimeStampUTC()
		{
			Int32 unixTimeStamp;
			DateTime currentTime = DateTime.Now;
			DateTime zuluTime = currentTime.ToUniversalTime();
			DateTime unixEpoch = new DateTime(1970, 1, 1);
			unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
			return unixTimeStamp;
		}
		
		string [] SaveFolders()
		{
			string [] dp = new string[numberOfSaves];
			for (int i = 0; i < numberOfSaves; i++)
			{
				dp[i] = $"{ConVar.Server.rootFolder}/saves/{i}/";
			}
			return dp;
		}
		
		void SaveBackupCreate()
		{
			DirectoryEx.Backup(SaveFolders());
			ConVar.Server.GetServerFolder("saves/0/");
		}
	}
}

// --- End of file: SaveMyMap.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomItemDefinitions-1.3.0.cs ---
// --- Original Local Path: CustomItemDefinitions-1.3.0.cs ---

using Oxide.Core.Plugins;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using System;
using SilentOrbit.ProtocolBuffers;
using System.Linq;
using System.Diagnostics;
using System.IO;
using Network;
using HarmonyLib;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Plugins.CustomItemDefinitionExtensions;
using UnityEngine.SceneManagement;
using Oxide.Core;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("CustomItemDefinitions", "0xF [dsc.gg/0xf-plugins]", "1.3.0")]
    [Description("Library of the Future. Allows you to create your own full-fledged custom items with own item definition.")]
    public class CustomItemDefinitions : RustPlugin
    {
        #region Consts
        public const ItemDefinition.Flag CUSTOM_DEFINITION_FLAG = (ItemDefinition.Flag)128;
        public static readonly ItemDefinition FallbackItemDefinition = ItemManager.FindItemDefinition("coal");
        public static readonly ItemDefinition FakeBlueprintItemDefinition = ItemManager.FindItemDefinition("rhib");
        #endregion

        #region CustomItemDefinition Class
        public class CustomItemDefinition
        {
            public int parentItemId;
            public string shortname;
            public int? itemId;
            public string defaultName;
            public string defaultDescription;
            public ulong defaultSkinId;
            public int? maxStackSize;
            public ItemCategory? category;
            public ItemDefinition.Flag flags;
            public ItemMod[] itemMods;
            public bool repairable;
            public bool craftable;
            public List<ItemAmount> blueprintIngredients;
            public int workbenchLevelRequired;

            public static CustomItemDefinition FromObject(object @object)
            {
                Type cidType = typeof(CustomItemDefinition);
                Type argType = @object.GetType();
                CustomItemDefinition @new = new CustomItemDefinition();

                foreach (PropertyInfo propertyInfo in argType.GetProperties())
                    SetField(@new, propertyInfo.Name, propertyInfo.GetValue(@object));

                foreach (FieldInfo fieldInfo in argType.GetFields())
                    SetField(@new, fieldInfo.Name, fieldInfo.GetValue(@object));

                void SetField(CustomItemDefinition cid, string fieldName, object value)
                {
                    FieldInfo fieldInfo = cidType.GetField(fieldName);
                    if (fieldInfo == null)
                    {
                        PluginInstance?.PrintWarning(string.Format("The field named \"{0}\" is missing in the CustomItemDefinition class, skipped", fieldName));
                        return;
                    }
                    fieldInfo.SetValue(cid, value);
                }
                return @new;
            }
        }
        #endregion

        #region Variables
        private static CustomItemDefinitions PluginInstance;
        private static Dictionary<int, ItemDefinition> AlreadyCreatedItemDefinitions;
        private static Dictionary<Plugin, HashSet<CustomItemDefinition>> CustomDefinitions = new Dictionary<Plugin, HashSet<CustomItemDefinition>>();
        #endregion

        #region Hooks
        void Init()
        {

            PluginInstance = this;

            CacheAlreadyCreated();

            FieldsToMutate.Initialize();

#if CARBON
            HarmonyInstance.Patch(AccessTools.Method(typeof(Carbon.Core.ModLoader), "UninitializePlugin"), prefix: new HarmonyMethod(typeof(Patches), nameof(Patches.UnloadPlugin)));
#else
            HarmonyInstance.Patch(AccessTools.Method(typeof(Oxide.Core.OxideMod), "UnloadPlugin"), prefix: new HarmonyMethod(typeof(Patches), nameof(Patches.UnloadPlugin)));
#endif
            HarmonyInstance.Patch(AccessTools.Method(typeof(Item), "Load"), prefix: new HarmonyMethod(typeof(Patches), nameof(Patches.Item_Load1)), postfix: new HarmonyMethod(typeof(Patches), nameof(Patches.Item_Load2)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(VendingMachineMapMarker), "GetAppMarkerData"), postfix: new HarmonyMethod(typeof(Patches), nameof(Patches.VendingMachineMapMarker_GetAppMarkerData)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(StorageMonitor), "FillEntityPayload"), postfix: new HarmonyMethod(typeof(Patches), nameof(Patches.StorageMonitor_FillEntityPayload)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(ProtoBuf.PlayerUpdateLoot), "WriteToStream"), new HarmonyMethod(typeof(Patches), nameof(Patches.PlayerUpdateLoot_WriteToStream)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(ProtoBuf.UpdateItem), "WriteToStream"), new HarmonyMethod(typeof(Patches), nameof(Patches.UpdateItem_WriteToStream)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(ProtoBuf.UpdateItemContainer), "WriteToStream"), new HarmonyMethod(typeof(Patches), nameof(Patches.UpdateItemContainer_WriteToStream)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(ProtoBuf.VendingMachine.SellOrderContainer), "WriteToStream"), new HarmonyMethod(typeof(Patches), nameof(Patches.SellOrderContainer_WriteToStream)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(ProtoBuf.ItemAmountList), "WriteToStream"), new HarmonyMethod(typeof(Patches), nameof(Patches.ItemAmountList_WriteToStream)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(ProtoBuf.IndustrialConveyor.ItemFilterList), "WriteToStream"), new HarmonyMethod(typeof(Patches), nameof(Patches.ItemFilterList_WriteToStream)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(ProtoBuf.IndustrialConveyorTransfer), "WriteToStream"), new HarmonyMethod(typeof(Patches), nameof(Patches.IndustrialConveyorTransfer_WriteToStream)));
            HarmonyInstance.Patch(AccessTools.Method(typeof(CuiImageComponent), "get_ItemId"), postfix: new HarmonyMethod(typeof(Patches), nameof(Patches.CuiItemIconPatch)));
        }

        private void Loaded()
        {
            Interface.Oxide.CallHook("OnCIDLoaded", this);
        }

        private void Unload()
        {
            foreach (Plugin plugin in CustomDefinitions.Keys)
                UnloadPluginItemDefinitions(plugin);
            CustomDefinitions.Clear();

            Interface.Oxide.CallHook("OnCIDUnloaded");
        }

        private static void OnItemDefinitionBroken(Item item, ProtoBuf.Item protoItem)
        {
            UnityEngine.Debug.LogWarning("Item has broken definition, the fallback item definition will be applied to it.");
            item.info = FallbackItemDefinition;
            item.text = protoItem.itemid.ToString();
        }

        void OnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
        {
            if (!saveInfo.forDisk)
                Mutate.ToClientSide(saveInfo.msg);
        }

        void OnLootNetworkUpdate(PlayerLoot loot)
        {
            RepairBench repairBench = loot.entitySource as RepairBench;
            if (repairBench == null)
                return;

            Item repairableItem = repairBench.inventory?.GetSlot(0);
            if (repairableItem == null)
                return;

            ItemDefinition itemDefinition = repairableItem.info;
            if (!itemDefinition.Blueprint || !itemDefinition.condition.repairable)
                return;

            BasePlayer player = loot.baseEntity;

            if (IsValidCustomItemDefinition(itemDefinition) && player.blueprints.HasUnlocked(itemDefinition))
                SendFakeUnlockedBlueprint(player, repairableItem.info.Parent.itemid);
            else
                player.SendNetworkUpdateImmediate();
        }

        void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            if (newItem == null || newItem.info != ItemManager.blueprintBaseDef)
                return;

            ItemDefinition blueprintTargetDef = newItem.blueprintTargetDef;
            if (blueprintTargetDef == null)
                return;

            player.ShowToast(GameTip.Styles.Blue_Normal, $"{blueprintTargetDef.displayName.translated} BLUEPRINT");
        }

        object OnItemCraft(IndustrialCrafter crafter, ItemBlueprint blueprint)
        {
            if (IsValidCustomItemDefinition(blueprint.targetItem) && !blueprint.userCraftable)
                return false;
            return null;
        }
        #endregion

        #region Commands
        [ConsoleCommand("itemid")]
        private void itemid(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;
            string shortname = arg.GetString(0);
            if (string.IsNullOrEmpty(shortname))
                return;

            ItemDefinition itemDefinition = ItemManager.FindItemDefinition(shortname);
            if (itemDefinition == null)
            {
                arg.ReplyWith("Item definion for the specified short name was not found.");
                return;
            }

            arg.ReplyWith(itemDefinition.itemid);
        }
        #endregion

        #region Classes
        public static class FieldsToMutate
        {
            public static List<FieldInfo> validFields;

            public static void Initialize()
            {
                validFields = CollectFields(typeof(ProtoBuf.Entity));
            }

            private static List<FieldInfo> CollectFields(Type type)
            {
                List<FieldInfo> result = new List<FieldInfo>();
                foreach (FieldInfo field in type.GetFields(BindingFlags.Public | BindingFlags.Instance))
                {
                    if (IsValidField(field))
                    {
                        result.Add(field);
                    }
                    else if (typeof(IProto).IsAssignableFrom(field.FieldType))
                    {
                        List<FieldInfo> collectedFields = CollectFields(field.FieldType);
                        if (collectedFields.Count > 0)
                        {
                            result.Add(field);
                            result.AddRange(CollectFields(field.FieldType));
                        }
                    }
                }
                return result;
            }

            public static bool IsValidField(FieldInfo field)
            {
                return Mutate.TypeToMethodMap.ContainsKey(field.FieldType);
            }
        }

        public static class Mutate
        {
            public static readonly Dictionary<Type, Action<object>> TypeToMethodMap = new Dictionary<Type, Action<object>>
            {
                { typeof(ProtoBuf.Item), obj => ToClientSide((ProtoBuf.Item)obj) },
                { typeof(ProtoBuf.ItemContainer), obj => ToClientSide((ProtoBuf.ItemContainer)obj) },
                { typeof(ProtoBuf.VendingMachine.SellOrder), obj => ToClientSide((ProtoBuf.VendingMachine.SellOrder)obj) },
                { typeof(ProtoBuf.WeaponRackItem), obj => ToClientSide((ProtoBuf.WeaponRackItem)obj) },
                { typeof(ProtoBuf.IndustrialConveyor.ItemFilter), obj => ToClientSide((ProtoBuf.IndustrialConveyor.ItemFilter)obj) },
                { typeof(ProtoBuf.ItemCrafter.Task), obj => ToClientSide((ProtoBuf.ItemCrafter.Task)obj) },
                { typeof(ProtoBuf.AppEntityPayload.Item), obj => ToClientSide((ProtoBuf.AppEntityPayload.Item)obj) },
                { typeof(ProtoBuf.ItemAmountList), obj => ToClientSide((ProtoBuf.ItemAmountList)obj) },
                { typeof(ProtoBuf.FrankensteinTable), obj => ToClientSide((ProtoBuf.FrankensteinTable)obj) },
                { typeof(List<ProtoBuf.Item>), obj => ToClientSide((List<ProtoBuf.Item>)obj) },
                { typeof(List<ProtoBuf.ItemContainer>), obj => ToClientSide((List<ProtoBuf.ItemContainer>)obj) },
                { typeof(List<ProtoBuf.VendingMachine.SellOrder>), obj => ToClientSide((List<ProtoBuf.VendingMachine.SellOrder>)obj) },
                { typeof(List<ProtoBuf.WeaponRackItem>), obj => ToClientSide((List<ProtoBuf.WeaponRackItem>)obj) },
                { typeof(List<ProtoBuf.IndustrialConveyor.ItemFilter>), obj => ToClientSide((List<ProtoBuf.IndustrialConveyor.ItemFilter>)obj) },
                { typeof(List<ProtoBuf.ItemCrafter.Task>), obj => ToClientSide((List<ProtoBuf.ItemCrafter.Task>)obj) },
                { typeof(List<ProtoBuf.AppEntityPayload.Item>), obj => ToClientSide((List<ProtoBuf.AppEntityPayload.Item>)obj) },
            };

            public static void ToClientSide(ProtoBuf.Entity protoEntity)
            {
                if (FieldsToMutate.validFields == null)
                    return;

                Stack<object> stack = new Stack<object>();
                stack.Push(protoEntity);
                for (int i = 0; i < FieldsToMutate.validFields.Count; i++)
                {
                    FieldInfo field = FieldsToMutate.validFields[i];
                    object peek = stack.Peek();
                    if (field.DeclaringType == peek.GetType())
                    {
                        object fieldValue = field.GetValue(peek);
                        if (fieldValue != null)
                        {
                            if (FieldsToMutate.IsValidField(field))
                            {
                                Mutate.ToClientSide(fieldValue);
                                while (i + 1 < FieldsToMutate.validFields.Count && FieldsToMutate.validFields[i + 1]?.DeclaringType != peek.GetType())
                                {
                                    stack.Pop();
                                    peek = stack.Peek();
                                }
                            }
                            else
                            {
                                stack.Push(fieldValue);
                            }
                        }
                    }
                }
            }

            public static void ToClientSide(object obj)
            {
                if (TypeToMethodMap.TryGetValue(obj.GetType(), out var method))
                {
                    method.Invoke(obj);
                }
                else
                {
                    UnityEngine.Debug.LogError("Unknown type to mutate: " + obj.GetType());
                }
            }

            public static void ToClientSide(ProtoBuf.VendingMachine.SellOrderContainer sellOrderContainer)
            {
                if (sellOrderContainer.sellOrders != null)
                    ToClientSide(sellOrderContainer.sellOrders);
            }

            public static void ToClientSide(List<ProtoBuf.VendingMachine.SellOrder> sellOrders)
            {
                foreach (ProtoBuf.VendingMachine.SellOrder order in sellOrders)
                    ToClientSide(order);
            }

            public static void ToClientSide(ProtoBuf.VendingMachine.SellOrder sellOrder)
            {
                ItemDefinition itemDefToSell = ItemManager.FindItemDefinition(sellOrder.itemToSellID);
                if (IsValidCustomItemDefinition(itemDefToSell))
                    sellOrder.itemToSellID = itemDefToSell.Parent.itemid;
                ItemDefinition currencyDef = ItemManager.FindItemDefinition(sellOrder.currencyID);
                if (IsValidCustomItemDefinition(currencyDef))
                    sellOrder.currencyID = currencyDef.Parent.itemid;
            }

            public static void ToClientSide(List<ProtoBuf.WeaponRackItem> weaponRackItems)
            {
                foreach (ProtoBuf.WeaponRackItem weaponRackItem in weaponRackItems)
                    ToClientSide(weaponRackItem);
            }

            public static void ToClientSide(ProtoBuf.WeaponRackItem rackItem)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(rackItem.itemID);
                if (IsValidCustomItemDefinition(itemDef))
                {
                    rackItem.itemID = itemDef.Parent.itemid;
                    if (rackItem.skinid == 0)
                    {
                        DefaultProperties defaultProperties = itemDef.GetComponent<DefaultProperties>();
                        if (defaultProperties != null && defaultProperties.skinId != 0UL)
                            rackItem.skinid = defaultProperties.skinId;
                    }
                }
            }

            public static void ToClientSide(List<ProtoBuf.IndustrialConveyor.ItemFilter> filters)
            {
                foreach (ProtoBuf.IndustrialConveyor.ItemFilter filter in filters)
                    ToClientSide(filter);
            }

            public static void ToClientSide(ProtoBuf.IndustrialConveyor.ItemFilter filter)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(filter.itemDef);
                if (IsValidCustomItemDefinition(itemDef))
                    filter.itemDef = itemDef.Parent.itemid;
            }

            public static void ToClientSide(List<ProtoBuf.IndustrialConveyorTransfer.ItemTransfer> transfers)
            {
                for (int i = 0; i < transfers.Count; i++)
                {
                    ProtoBuf.IndustrialConveyorTransfer.ItemTransfer transfer = transfers[i];
                    ItemDefinition itemDef = ItemManager.FindItemDefinition(transfers[i].itemId);
                    if (IsValidCustomItemDefinition(itemDef))
                        transfers[i] = new ProtoBuf.IndustrialConveyorTransfer.ItemTransfer { itemId = itemDef.Parent.itemid, amount = transfer.amount };
                }
            }

            public static void ToClientSide(List<ProtoBuf.ItemCrafter.Task> tasks)
            {
                foreach (ProtoBuf.ItemCrafter.Task task in tasks)
                    ToClientSide(tasks);
            }

            public static void ToClientSide(ProtoBuf.ItemCrafter.Task task)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(task.itemID);
                if (IsValidCustomItemDefinition(itemDef))
                {
                    task.itemID = itemDef.Parent.itemid;
                    if (task.skinID == 0)
                    {
                        DefaultProperties defaultProperties = itemDef.GetComponent<DefaultProperties>();
                        if (defaultProperties != null && defaultProperties.skinId != 0UL)
                            task.skinID = (int)defaultProperties.skinId;
                    }
                }
            }

            public static void ToClientSide(ProtoBuf.ItemAmountList itemAmountList)
            {
                if (itemAmountList.itemID == null)
                    return;

                for (int i = 0; i < itemAmountList.itemID.Count; i++)
                {
                    ItemDefinition itemDef = ItemManager.FindItemDefinition(itemAmountList.itemID[i]);
                    if (IsValidCustomItemDefinition(itemDef))
                        itemAmountList.itemID[i] = itemDef.Parent.itemid;
                }
            }

            public static void ToClientSide(List<ProtoBuf.AppEntityPayload.Item> items)
            {
                foreach (ProtoBuf.AppEntityPayload.Item item in items)
                    ToClientSide(item);
            }

            public static void ToClientSide(ProtoBuf.AppEntityPayload.Item item)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(item.itemId);
                if (IsValidCustomItemDefinition(itemDef))
                {
                    item.itemId = itemDef.Parent.itemid;
                }
            }

            public static void ToClientSide(List<ProtoBuf.AppMarker.SellOrder> sellOrders)
            {
                foreach (ProtoBuf.AppMarker.SellOrder sellOrder in sellOrders)
                    ToClientSide(sellOrder);
            }

            public static void ToClientSide(ProtoBuf.AppMarker.SellOrder sellOrder)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(sellOrder.itemId);
                if (IsValidCustomItemDefinition(itemDef))
                    sellOrder.itemId = itemDef.Parent.itemid;
            }

            public static void ToClientSide(ProtoBuf.FrankensteinTable frankensteinTable)
            {
                if (frankensteinTable.itemIds == null)
                    return;

                for (int i = 0; i < frankensteinTable.itemIds.Count; i++)
                {
                    ItemDefinition itemDef = ItemManager.FindItemDefinition(frankensteinTable.itemIds[i]);
                    if (IsValidCustomItemDefinition(itemDef))
                        frankensteinTable.itemIds[i] = itemDef.Parent.itemid;
                }
            }

            public static void ToClientSide(List<ProtoBuf.ItemContainer> containers)
            {
                foreach (ProtoBuf.ItemContainer container in containers)
                    ToClientSide(container);
            }

            public static void ToClientSide(ProtoBuf.ItemContainer container)
            {
                if (container.contents != null)
                    ToClientSide(container.contents);
            }

            public static void ToClientSide(List<ProtoBuf.Item> items)
            {
                foreach (ProtoBuf.Item item in items)
                    ToClientSide(item);
            }

            public static void ToClientSide(ProtoBuf.Item protoItem)
            {
                ItemDefinition itemDefinition = ItemManager.FindItemDefinition(protoItem.itemid);
                if (itemDefinition == null)
                {
                    protoItem.itemid = FallbackItemDefinition.itemid;
                    return;
                }

                if (protoItem.contents != null)
                    ToClientSide(protoItem.contents);


                bool IsBlueprint = itemDefinition == ItemManager.blueprintBaseDef;

                if (IsBlueprint && protoItem.instanceData != null)
                {
                    ItemDefinition blueprintItemDef = ItemManager.FindItemDefinition(protoItem.instanceData.blueprintTarget);
                    if (blueprintItemDef == null)
                        return;
                    itemDefinition = blueprintItemDef;
                }

                if (!IsValidCustomItemDefinition(itemDefinition))
                    return;

                if (!IsBlueprint)
                {
                    protoItem.itemid = itemDefinition.Parent.itemid;

                    DefaultProperties defaultProperties = itemDefinition.GetComponent<DefaultProperties>();
                    if (protoItem.name == null && defaultProperties.finalName != null)
                        protoItem.name = defaultProperties.finalName;
                    if (protoItem.skinid == 0UL && defaultProperties.skinId != 0UL)
                        protoItem.skinid = defaultProperties.skinId;
                }
                else if (protoItem.instanceData != null)
                {
                    protoItem.instanceData = new ProtoBuf.Item.InstanceData() { ShouldPool = true };
                    protoItem.instanceData.blueprintTarget = FakeBlueprintItemDefinition.itemid;
                }
            }
        }
        #endregion

        #region Methods
        private object Register(object @object, Plugin plugin)
        {
            if (@object is IEnumerable enumerable)
            {
                List<CustomItemDefinition> list = new List<CustomItemDefinition>();
                foreach (object item in enumerable)
                    list.Add(CustomItemDefinition.FromObject(item));

                return RegisterPluginItemDefinitions(list, plugin);
            }
            else
            {
                return RegisterPluginItemDefinition(CustomItemDefinition.FromObject(@object), plugin);
            }
        }

        private static void CacheAlreadyCreated()
        {
            if (AlreadyCreatedItemDefinitions == null)
            {
                AlreadyCreatedItemDefinitions = new Dictionary<int, ItemDefinition>();
                if (ServerMgr.Instance != null)
                {
                    foreach (GameObject gameObject in ServerMgr.Instance.gameObject.scene.GetRootGameObjects())
                    {
                        if (!gameObject.name.IsNumeric())
                            continue;

                        if (gameObject.TryGetComponent(out ItemDefinition itemDefinition))
                            AlreadyCreatedItemDefinitions.Add(itemDefinition.itemid, itemDefinition);
                    }
                }
            }
        }

        public static HashSet<ItemDefinition> RegisterPluginItemDefinitions(IEnumerable<CustomItemDefinition> definitions, Plugin plugin)
        {
            HashSet<ItemDefinition> hashSet = new HashSet<ItemDefinition>();
            foreach (var definition in definitions)
            {
                ItemDefinition resultItemDefinition = RegisterPluginItemDefinition(definition, plugin);
                if (resultItemDefinition != null)
                    hashSet.Add(resultItemDefinition);
            };
            return hashSet;
        }

        public static ItemDefinition RegisterPluginItemDefinition(CustomItemDefinition definition, Plugin plugin)
        {
            HashSet<CustomItemDefinition> pluginHashSet = null;
            if (!CustomDefinitions.TryGetValue(plugin, out pluginHashSet))
                pluginHashSet = (CustomDefinitions[plugin] = new HashSet<CustomItemDefinition>());

            if (pluginHashSet.Contains(definition))
            {
                PluginInstance.PrintError("Error by the plugin \"{0}\": The provided CustomItemDefinition is already contained", plugin.Name);
                return null;
            }


            if (string.IsNullOrEmpty(definition.shortname) || definition.parentItemId == 0)
            {
                PluginInstance.PrintError("Error of incorrect data provided by the plugin \"{0}\": The fields shortname, parentItemId is required", plugin.Name);
                return null;
            }

            if (!definition.itemId.HasValue)
                definition.itemId = definition.shortname.GetHashCode();


            else if (ItemManager.FindItemDefinition(definition.shortname) != null)
            {
                PluginInstance.PrintError("Error of incorrect data provided by the plugin \"{0}\": Shortname must be unique! The provided shortname - \"{1}\"", plugin.Name, definition.shortname);
                return null;
            }
            else if (ItemManager.FindItemDefinition(definition.itemId.Value) != null)
            {
                PluginInstance.PrintError("Error of incorrect data provided by the plugin \"{0}\": ItemId must be unique! The provided itemId - \"{1}\"", plugin.Name, definition.itemId);
                return null;
            }

            ItemDefinition parentItemDefinition = ItemManager.FindItemDefinition(definition.parentItemId);
            if (parentItemDefinition == null)
            {
                PluginInstance.PrintError("Error of incorrect data provided by the plugin \"{0}\": ItemDefinition by parentItemId not found! The provided parentItemId - \"{1}\"", plugin.Name, definition.parentItemId);
                return null;
            }
            if (parentItemDefinition.gameObject.scene.isLoaded)
            {
                PluginInstance.PrintError("Error by the plugin \"{0}\": You cannot use a custom ItemDefinition as a parent!", plugin.Name);
                return null;
            }

            ItemDefinition newItemDefinition;
            if (!AlreadyCreatedItemDefinitions.TryGetValue(definition.itemId.Value, out newItemDefinition))
            {
                if (newItemDefinition == null)
                {
                    newItemDefinition = CloneItemDefinition(parentItemDefinition);
                    newItemDefinition.name = definition.itemId.ToString();
                }
                AlreadyCreatedItemDefinitions[definition.itemId.Value] = newItemDefinition;
            }

            if (newItemDefinition == null)
            {
                PluginInstance.PrintError("Error by the plugin \"{0}\": Failure to create or search for a new item definition ({1})!", plugin.Name, definition.shortname);
                return null;
            }

            newItemDefinition.shortname = definition.shortname;
            newItemDefinition.itemid = definition.itemId.Value;
            if (definition.defaultName != null)
                newItemDefinition.displayName = definition.defaultName;
            if (definition.defaultDescription != null)
                newItemDefinition.displayDescription = definition.defaultDescription;
            newItemDefinition.Parent = parentItemDefinition;
            newItemDefinition.flags = CUSTOM_DEFINITION_FLAG;
            newItemDefinition.flags |= definition.flags;
            if (definition.category.HasValue)
                newItemDefinition.category = definition.category.Value;
            if (definition.maxStackSize.HasValue)
                newItemDefinition.stackable = definition.maxStackSize.Value;
            newItemDefinition.condition.repairable = definition.repairable;
            newItemDefinition.itemMods = null;
            foreach (ItemMod mod in newItemDefinition.GetComponentsInChildren<ItemMod>(true))
                UnityEngine.Object.DestroyImmediate(mod);


            if (!newItemDefinition.TryGetComponent(out ItemBlueprint itemBlueprint) && (definition.craftable || definition.repairable))
                itemBlueprint = newItemDefinition.gameObject.AddComponent<ItemBlueprint>();

            if (itemBlueprint)
            {
                itemBlueprint.defaultBlueprint = false;
                itemBlueprint.userCraftable = definition.craftable;
                itemBlueprint.isResearchable = definition.craftable || definition.repairable;
                itemBlueprint.workbenchLevelRequired = definition.workbenchLevelRequired;
                itemBlueprint.ingredients = definition.blueprintIngredients != null && definition.blueprintIngredients.Count > 0 ? definition.blueprintIngredients : parentItemDefinition.Blueprint?.ingredients ?? new List<ItemAmount>();
            }

            DefaultProperties defaultProperties = newItemDefinition.gameObject.AddComponent<DefaultProperties>();
            defaultProperties.name = definition.defaultName;
            defaultProperties.description = definition.defaultDescription;
            defaultProperties.finalName = FormatNameWithDescription(definition.defaultName, definition.defaultDescription);
            defaultProperties.skinId = definition.defaultSkinId;
            if (definition.itemMods != null)
            {
                foreach (ItemMod mod in definition.itemMods)
                {
                    if ((mod as object) == null)
                        continue;

                    Type type = mod.GetType();
                    Component component = newItemDefinition.gameObject.AddComponent(type);
                    mod.CopyFields(component as ItemMod);
                }
            }
            newItemDefinition.Initialize(ItemManager.itemList);
            ItemManager.itemDictionary[definition.itemId.Value] = newItemDefinition;
            ItemManager.itemDictionaryByName[definition.shortname] = newItemDefinition;
            if (!ItemManager.itemList.Contains(newItemDefinition))
                ItemManager.itemList.Add(newItemDefinition);

            pluginHashSet.Add(definition);
            return newItemDefinition;
        }

        public static void UnloadPluginItemDefinitions(Plugin plugin)
        {
            if (CustomDefinitions.TryGetValue(plugin, out HashSet<CustomItemDefinition> definitions))
            {
                foreach (var definition in definitions)
                    UnloadCustomItemDefinition(definition);
                definitions.Clear();
            }
                
        }
        public static void UnloadPluginItemDefinition(Plugin plugin, CustomItemDefinition definition)
        {
            if (CustomDefinitions.TryGetValue(plugin, out HashSet<CustomItemDefinition> definitions))
            {
                if (definitions.Contains(definition))
                {
                    UnloadCustomItemDefinition(definition);
                    definitions.Remove(definition);
                }
            }
        }

        private static void UnloadCustomItemDefinition(CustomItemDefinition definition)
        {
            if (ItemManager.itemDictionaryByName.TryGetValue(definition.shortname, out ItemDefinition itemDefinition))
            {
                itemDefinition.itemMods = null;
                foreach (ItemMod mod in itemDefinition.GetComponentsInChildren<ItemMod>(true))
                    UnityEngine.Object.DestroyImmediate(mod);
                itemDefinition.Initialize(ItemManager.itemList);
                ItemManager.itemDictionary.Remove(definition.itemId.Value);
                ItemManager.itemDictionaryByName.Remove(definition.shortname);
                ItemManager.itemList.Remove(itemDefinition);
            }
        }

        private static ItemDefinition CloneItemDefinition(ItemDefinition itemDefinition)
        {
            if (itemDefinition == null)
                return null;
            GameObject clone = UnityEngine.Object.Instantiate(itemDefinition.gameObject);
            UnityEngine.Object.DontDestroyOnLoad(clone);
            return clone.GetComponent<ItemDefinition>();
        }

        private static ItemDefinition CloneItemDefinition(string shortname) => CloneItemDefinition(ItemManager.FindItemDefinition(shortname));
        private static ItemDefinition CloneItemDefinition(int itemId) => CloneItemDefinition(ItemManager.FindItemDefinition(itemId));

        private static bool IsValidCustomItemDefinition(ItemDefinition itemDefinition)
        {
            if (itemDefinition == null)
                return false;

            return itemDefinition.HasFlag(CUSTOM_DEFINITION_FLAG) && itemDefinition.Parent != null;
        }

        private static void SendSnapshotWithUnlockedBlueprint(BasePlayer player, int itemId)
        {
            if (player == null || player.net == null || !player.IsConnected)
                return;

            Network.Connection connection = player.net.connection;
            try
            {
                NetWrite netWrite = Network.Net.sv.StartWrite();
                global::BaseNetworkable.SaveInfo saveInfo = new global::BaseNetworkable.SaveInfo
                {
                    forConnection = player.net.connection,
                    forDisk = false
                };
                netWrite.PacketID(Message.Type.Entities);
                netWrite.UInt32(connection.validate.entityUpdates + 1U);
                using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
                {
                    player.Save(saveInfo);
                    ProtoBuf.PersistantPlayer persistantData = saveInfo.msg.basePlayer.persistantData;
                    if (persistantData != null && persistantData.unlockedItems != null && !persistantData.unlockedItems.Contains(itemId))
                        persistantData.unlockedItems.Add(itemId);
                    saveInfo.msg.ToProto(netWrite);
                }
                netWrite.Send(new SendInfo(player.net.connection));
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogException(ex);
            }
            finally
            {
                connection.validate.entityUpdates++;
            }
        }

        private static void SendFakeUnlockedBlueprint(BasePlayer player, int itemId)
        {
            SendSnapshotWithUnlockedBlueprint(player, itemId);
            player.ClientRPCPlayer<int>(null, player, "UnlockedBlueprint", 0); // [Clientside RPC] Update blueprints
        }

        private static string FormatNameWithDescription(string name, string description)
        {
            if (!string.IsNullOrEmpty(description))
                return $"{string.Concat(Enumerable.Repeat("\n", description.Count(c => c == '\n')))}\n{name}\n\t\t\t\t\t\t\t\t\t\t\t\t{description.Replace("\n", "\n\t\t\t\t\t\t\t\t\t\t\t\t")}";
            return name;
        }
        #endregion

        #region Default Mods
        private class DefaultProperties : ItemMod
        {
            public string name;
            public string description;
            public string finalName;
            public ulong skinId;
        }
        #endregion

        #region Converters
        public class ItemAmountConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                if (value == null)
                {
                    writer.WriteNull();
                    return;
                }
                ItemAmount itemAmount = (ItemAmount)value;
                writer.WriteStartObject();
                writer.WritePropertyName("ShortName");
                writer.WriteValue(itemAmount.itemDef?.shortname);
                writer.WritePropertyName("Amount");
                writer.WriteValue(itemAmount.amount);
                writer.WriteEndObject();
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(ItemAmount);
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.Null)
                    return null;

                JObject jobject = JObject.Load(reader);
                ItemDefinition itemDefinition;
                string shortname = (string)jobject["ShortName"];
                if (string.IsNullOrEmpty(shortname))
                    itemDefinition = null;
                else
                    itemDefinition = ItemManager.FindItemDefinition(shortname);
                return new ItemAmount(itemDefinition, (float)jobject["Amount"]);
            }

            public override bool CanRead
            {
                get
                {
                    return true;
                }
            }
        }
        #endregion

        #region Harmony Patches
        internal static class Patches
        {
  
#if CARBON
            internal static void UnloadPlugin(RustPlugin plugin)
            {
                if (CustomDefinitions.ContainsKey(plugin))
                    UnloadPluginItemDefinitions(plugin);
            }
#else
            internal static void UnloadPlugin(string name)
            {
                Plugin plugin = Oxide.Core.Interface.Oxide.RootPluginManager.GetPlugin(name);
                if (plugin == null || (plugin.IsCorePlugin && !Oxide.Core.Interface.Oxide.IsShuttingDown))
                    return;
                if (CustomDefinitions.ContainsKey(plugin))
                    UnloadPluginItemDefinitions(plugin);
            }
#endif

            internal static void Item_Load1(Item __instance, ProtoBuf.Item __0)
            {
                if (__0.itemid == FallbackItemDefinition.itemid &&
                    __0.text != null &&
                    int.TryParse(__0.text, out int restoreItemId) &&
                    ItemManager.itemDictionary.ContainsKey(restoreItemId))
                    __0.itemid = restoreItemId;
            }

            internal static void Item_Load2(Item __instance, ProtoBuf.Item __0)
            {
                if (__instance.info == null)
                    OnItemDefinitionBroken(__instance, __0);
            }

            internal static void VendingMachineMapMarker_GetAppMarkerData(ref ProtoBuf.AppMarker __result)
            {
                if (__result.sellOrders != null)
                    Mutate.ToClientSide(__result.sellOrders);
            }

            internal static void StorageMonitor_FillEntityPayload(ref ProtoBuf.AppEntityPayload payload)
            {
                if (payload.items != null)
                    Mutate.ToClientSide(payload.items);
            }

            internal static bool PlayerUpdateLoot_WriteToStream(ProtoBuf.PlayerUpdateLoot __instance)
            {
                if (__instance.containers != null)
                    Mutate.ToClientSide(__instance.containers);
                return true;
            }

            internal static bool UpdateItem_WriteToStream(ProtoBuf.UpdateItem __instance)
            {
                if (__instance.item != null)
                    Mutate.ToClientSide(__instance.item);
                return true;
            }

            internal static bool UpdateItemContainer_WriteToStream(ProtoBuf.UpdateItemContainer __instance)
            {
                if (__instance.container != null)
                    Mutate.ToClientSide(__instance.container);
                return true;
            }

            internal static bool SellOrderContainer_WriteToStream(ref ProtoBuf.VendingMachine.SellOrderContainer __instance)
            {
                if (__instance.sellOrders != null)
                {
                    __instance = __instance.Copy();
                    Mutate.ToClientSide(__instance.sellOrders);
                }
                return true;
            }

            internal static bool ItemAmountList_WriteToStream(ProtoBuf.ItemAmountList __instance)
            {
                if (__instance.itemID != null)
                    Mutate.ToClientSide(__instance);
                return true;
            }

            internal static bool ItemFilterList_WriteToStream(ProtoBuf.IndustrialConveyor.ItemFilterList __instance)
            {
                if (__instance.filters != null)
                    Mutate.ToClientSide(__instance.filters);
                return true;
            }

            internal static bool IndustrialConveyorTransfer_WriteToStream(ProtoBuf.IndustrialConveyorTransfer __instance)
            {
                if (__instance.ItemTransfers != null)
                    Mutate.ToClientSide(__instance.ItemTransfers);
                return true;
            }

            internal static void CuiItemIconPatch(CuiImageComponent __instance, ref int __result)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition(__result);
                if (itemDef == null)
                    return;

                if (IsValidCustomItemDefinition(itemDef) && itemDef.TryGetComponent(out DefaultProperties defaultProperties))
                {
                    __result = itemDef.Parent.itemid;
                    if (__instance.SkinId == 0)
                        __instance.SkinId = defaultProperties.skinId;
                }
            }
        }
        #endregion
    }
}

#region Extensions
namespace Oxide.Plugins.CustomItemDefinitionExtensions
{
    public static class ItemModExtensions
    {
        public static void CopyFields(this ItemMod from, ItemMod to)
        {
            if ((from as object) == null || (to as object) == null)
                return;

            Type type = from.GetType();
            do
            {
                foreach (FieldInfo field in from.GetType().GetFields(BindingFlags.Static | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.SetField))
                    field.SetValue(to, field.GetValue(from));

                if (type == typeof(ItemMod))
                    break;

                type = type.BaseType;
            }
            while (type != null);
        }
    }
}
#endregion

// --- End of file: CustomItemDefinitions-1.3.0.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoSunGlare.cs ---
// --- Original Local Path: NoSunGlare.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Sun Glare", "Tryhard", "2.0.0")]
    [Description("Removes sun or sun glare")]
    public class NoSunGlare : RustPlugin
    {
        private WeatherConfig _config;

        #region Configuration

        public class WeatherConfig
        {
            [JsonProperty(PropertyName = "Clouds")]
            public float Clouds { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Opacity")]
            public float CloudOpacity { get; set; } = 0.97f;

            [JsonProperty(PropertyName = "Cloud Brightness")]
            public float CloudBrightness { get; set; } = 1.5f;

            [JsonProperty(PropertyName = "Cloud Coloring")]
            public int CloudColoring { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Saturation")]
            public int CloudSaturation { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Scattering")]
            public int CloudScattering { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Sharpness")]
            public int CloudSharpness { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Size")]
            public int CloudSize { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Coverage")]
            public int CloudCoverage { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Attenuation")]
            public int CloudAttenuation { get; set; } = -1;

            [JsonProperty(PropertyName = "Wind")]
            public float Wind { get; set; } = 0;

            [JsonProperty(PropertyName = "Rain")]
            public float Rain { get; set; } = 0;

            [JsonProperty(PropertyName = "Fog")]
            public float Fog { get; set; } = 0;

            [JsonProperty(PropertyName = "Fogginess")]
            public float Fogginess { get; set; } = 0;

            [JsonProperty(PropertyName = "Dust Chance")]
            public float DustChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Fog Chance")]
            public float FogChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Overcast Chance")]
            public float OvercastChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Storm Chance")]
            public float StormChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Clear Chance")]
            public float ClearChance { get; set; } = 1;

            [JsonProperty(PropertyName = "Atmosphere Contrast")]
            public float AtmosphereContrast { get; set; } = 1.2f;

            [JsonProperty(PropertyName = "Atmosphere Directionality")]
            public float AtmosphereDirectionality { get; set; } = 0;

            [JsonProperty(PropertyName = "Atmosphere Mie")]
            public float AtmosphereMie { get; set; } = 0;

            [JsonProperty(PropertyName = "Atmosphere Rayleigh")]
            public float AtmosphereRayleigh { get; set; } = 1.3f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<WeatherConfig>();

                if (_config == null) LoadDefaultConfig();
            }

            catch
            {
                PrintError("Configuration file is corrupt, check your config file at https://jsonlint.com/!");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new WeatherConfig();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        private void OnServerInitialized()
        {
            SetWeatherParameters(
                _config.Clouds,
                _config.CloudOpacity,
                _config.CloudBrightness,
                _config.CloudColoring,
                _config.CloudSaturation,
                _config.CloudScattering,
                _config.CloudSharpness,
                _config.CloudSize,
                _config.CloudCoverage,
                _config.CloudAttenuation,
                _config.Wind,
                _config.Rain,
                _config.Fog,
                _config.Fogginess,
                _config.DustChance,
                _config.FogChance,
                _config.OvercastChance,
                _config.StormChance,
                _config.ClearChance,
                _config.AtmosphereContrast,
                _config.AtmosphereDirectionality,
                _config.AtmosphereMie,
                _config.AtmosphereRayleigh
            );
        }

        private void SetWeatherParameters(
            float clouds,
            float cloudOpacity,
            float cloudBrightness,
            int cloudColoring,
            int cloudSaturation,
            int cloudScattering,
            int cloudSharpness,
            int cloudSize,
            int cloudCoverage,
            int cloudAttenuation,
            float wind,
            float rain,
            float fog,
            float fogginess,
            float dustChance,
            float fogChance,
            float overcastChance,
            float stormChance,
            float clearChance,
            float atmosphereContrast,
            float atmosphereDirectionality,
            float atmosphereMie,
            float atmosphereRayleigh)
        {
            var climate = SingletonComponent<Climate>.Instance;

            climate.Overrides.Clouds = clouds;
            climate.WeatherOverrides.Clouds.Opacity = cloudOpacity;
            climate.WeatherOverrides.Clouds.Brightness = cloudBrightness;
            climate.WeatherOverrides.Clouds.Coloring = cloudColoring;
            climate.WeatherOverrides.Clouds.Saturation = cloudSaturation;
            climate.WeatherOverrides.Clouds.Scattering = cloudScattering;
            climate.WeatherOverrides.Clouds.Sharpness = cloudSharpness;
            climate.WeatherOverrides.Clouds.Size = cloudSize;
            climate.WeatherOverrides.Clouds.Coverage = cloudCoverage;
            climate.WeatherOverrides.Clouds.Attenuation = cloudAttenuation;
            climate.Overrides.Wind = wind;
            climate.Overrides.Rain = rain;
            climate.Overrides.Fog = fog;
            climate.WeatherOverrides.Atmosphere.Fogginess = fogginess;
            climate.Weather.DustChance = dustChance;
            climate.Weather.FogChance = fogChance;
            climate.Weather.OvercastChance = overcastChance;
            climate.Weather.StormChance = stormChance;
            climate.Weather.ClearChance = clearChance;
            climate.WeatherOverrides.Atmosphere.Contrast = atmosphereContrast;
            climate.WeatherOverrides.Atmosphere.Directionality = atmosphereDirectionality;
            climate.WeatherOverrides.Atmosphere.MieMultiplier = atmosphereMie;
            climate.WeatherOverrides.Atmosphere.RayleighMultiplier = atmosphereRayleigh;

            ServerMgr.SendReplicatedVars("weather.");
        }
    }
}

// --- End of file: NoSunGlare.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Kits (2).cs ---
// --- Original Local Path: Kits (2).cs ---

﻿using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Globalization;
using Oxide.Core;
using System.IO;

namespace Oxide.Plugins
{
    [Info("Kits", "RustPlugin.ru", "3.2.4")]
    class Kits : RustPlugin
    {
        public static Oxide.Core.Libraries.Permission perm => Oxide.Core.Interface.Oxide.GetLibrary<Oxide.Core.Libraries.Permission>("Permission");
        private PluginConfig _config;
        private ImagesCache _imagesCache = new ImagesCache();
        private List<Kit> _kits;
        private Dictionary<ulong, Dictionary<string, KitData>> _kitsData;
        private Dictionary<BasePlayer, List<string>> _kitsGUI = new Dictionary<BasePlayer, List<string>>();

        #region Classes

        class PluginConfig
        {
            public Position Position { get; set; }
            public Position CloseButtonPosition { get; set; }
            public Position CloseButtonPositionNext1 { get; set; }
            public Position CloseButtonPositionNext2 { get; set; }
            public Position CloseButtonPositionNext3 { get; set; }
            public string CloseButtonColor { get; set; }
            public string MainBackgroundColor { get; set; }

            public string DefaultKitImage { get; set; }
            public float MarginTop { get; set; }
            public float MarginBottom { get; set; }
            public float MarginBetween { get; set; }
            public float KitWidth { get; set; }
            public string DisableMaskColor { get; set; }
            public string KitBackgroundColor { get; set; }
            public List<string> CustomAutoKits;
            public ImageConfig Image { get; set; }
            public LabelConfig Label { get; set; }
            public LabelConfig Amount { get; set; }
            public LabelConfig Time { get; set; }

            public static PluginConfig CreateDefault()
            {
                return new PluginConfig
                {
                    CustomAutoKits = new List<string>()
                    {
                        "autokit1",
                        "autokit2"
                    },
                    MainBackgroundColor = "#00000088",
                    Position = new Position
                    {
                        AnchorMin = "0 0.35",
                        AnchorMax = "1 0.65"
                    },
                    CloseButtonPosition = new Position
                    {
                        AnchorMin = "0.95 0.8",
                        AnchorMax = "0.997 0.98"
                    },
                    CloseButtonPositionNext1 = new Position
                    {
                        AnchorMin = "0.95 0.6",
                        AnchorMax = "0.997 0.78"
                    },
                    CloseButtonPositionNext2 = new Position
                    {
                        AnchorMin = "0.95 0.4",
                        AnchorMax = "0.997 0.58"
                    },
                    CloseButtonPositionNext3 = new Position
                    {
                        AnchorMin = "0.95 0.1",
                        AnchorMax = "0.997 0.38"
                    },
                    CloseButtonColor = "0 0 0 0.70",

                    DefaultKitImage = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "Kits" + Path.DirectorySeparatorChar + "home.png",
                    KitWidth = 0.12f,
                    MarginTop = 0.04f,
                    MarginBottom = 0.03f,
                    DisableMaskColor = "#000000DD",
                    MarginBetween = 0.01f,
                    KitBackgroundColor = "#00000088",

                    Image = new ImageConfig
                    {
                        Color = "#FFFFFFFF",
                        Position = new Position
                        {
                            AnchorMin = "0.05 0.15",
                            AnchorMax = "0.95 0.95"
                        },
                        Png = ""
                    },
                    Label = new LabelConfig
                    {
                        Position = new Position
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 0.15"
                        },
                        FontSize = 14,
                        ForegroundColor = "#FFFFFFFF",
                        BackgroundColor = "#00000000",
                        TextAnchor = TextAnchor.MiddleCenter
                    },
                    Amount = new LabelConfig
                    {
                        Position = new Position
                        {
                            AnchorMin = "0.05 0.85",
                            AnchorMax = "0.95 0.95"
                        },
                        FontSize = 14,
                        ForegroundColor = "#FFFFFFFF",
                        BackgroundColor = "#00000000",
                        TextAnchor = TextAnchor.MiddleCenter
                    },
                    Time = new LabelConfig
                    {
                        Position = new Position
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                        FontSize = 14,
                        ForegroundColor = "#FFFFFFFF",
                        BackgroundColor = "#00000000",
                        TextAnchor = TextAnchor.MiddleCenter
                    }
                };
            }

            public class LabelConfig
            {
                public Position Position { get; set; }
                public string ForegroundColor { get; set; }
                public string BackgroundColor { get; set; }
                public int FontSize { get; set; }
                public TextAnchor TextAnchor { get; set; }
            }

            public class ImageConfig
            {
                public Position Position { get; set; }
                public string Color { get; set; }
                public string Png { get; set; }
            }
        }

        public class Kit
        {
            public string Name { get; set; }
            public string DisplayName { get; set; }
            public int Amount { get; set; }
            public double Cooldown { get; set; }
            public bool Hide { get; set; }
            public string Permission { get; set; }
            public List<KitItem> Items { get; set; }

            public string Png { get; set; }
        }

        public class KitItem
        {
            public string ShortName { get; set; }
            public int Amount { get; set; }
            public int Blueprint { get; set; }
            public ulong SkinID { get; set; }
            public string Container { get; set; }
            public float Condition { get; set; }
            public Weapon Weapon { get; set; }
            public List<ItemContent> Content { get; set; }

        }
        public class Weapon
        {
            public string ammoType { get; set; }
            public int ammoAmount { get; set; }
        }
        public class ItemContent
        {
            public string ShortName { get; set; }
            public float Condition { get; set; }
            public int Amount { get; set; }
        }

        public class KitData
        {
            public int Amount { get; set; }
            public double Cooldown { get; set; }
        }

        public class Position
        {
            public string AnchorMin { get; set; }
            public string AnchorMax { get; set; }
        }

        public class ImagesCache : MonoBehaviour
        {
            private Dictionary<string, string> _images = new Dictionary<string, string>();

            public void Add(string name, string url)
            {
                if (_images.ContainsKey(name))
                    return;

                using (var www = new WWW(url))
                {
                    if (www.error != null)
                    {
                        print(string.Format("Image loading fail! Error: {0}", www.error));
                    }
                    else
                    {
                        if (www.bytes == null || www.bytes.Count() == 0)
                        {
                            Interface.Oxide.LogError($"Failed to add image for {name}. File address possibly invalide\n {url}");
                            return;
                        }

                        _images[name] = FileStorage.server.Store(www.bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                    }
                }
            }
            public string Get(string name)
            {
                if (_images.ContainsKey(name))
                    return _images[name];

                return string.Empty;
            }
        }

        #endregion

        #region Oxide hooks

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config.WriteObject(PluginConfig.CreateDefault(), true);
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var kits in _config.CustomAutoKits)
            {
                if (_kits.Exists(x => x.Name == kits))
                {
                    var kit1 = _kits.First(x => x.Name == kits);
                    if (permission.UserHasPermission(player.UserIDString, kit1.Permission))
                    {
                        player.inventory.Strip();
                        GiveItems(player, kit1);
                        return;
                    }
                }
            }
            if (_kits.Exists(x => x.Name == "autokit"))
            {
                player.inventory.Strip();
                var kit = _kits.First(x => x.Name == "autokit");
                GiveItems(player, kit);
            }

        }
        private void SaveKits()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits", _kits);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits_Data", _kitsData);
        }

        void OnServerSave()
        {
            SaveData();
            SaveKits();
        }


        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "<color=#008B8B>[Сервер]:</color> Kit {kitname} was removed",
                ["Kit Doesn't Exist"] = "<color=#008B8B>[Сервер]:</color> This kit doesn't exist",
                ["Not Found Player"] = "<color=#008B8B>[Сервер]:</color> Player not found",
                ["To Many Player"] = "<color=#008B8B>[Сервер]:</color> Found multipy players",
                ["Permission Denied"] = "<color=#008B8B>[Сервер]:</color> Access denied",
                ["Limite Denied"] = "<color=#008B8B>[Сервер]:</color> Useage limite reached",
                ["Cooldown Denied"] = "<color=#008B8B>[Сервер]:</color> You will be able to use this kit after {time}",
                ["Reset"] = "<color=#008B8B>[Сервер]:</color> Kits data wiped",
                ["Kit Already Exist"] = "<color=#008B8B>[Сервер]:</color> Kit with the same name already exist",
                ["Kit Created"] = "<color=#008B8B>[Сервер]:</color> You have created a new kit - {name}",
                ["Kit Extradited"] = "<color=#008B8B>[Сервер]:</color> You have claimed kit - {kitname}",
                ["Kit Cloned"] = "<color=#008B8B>[Сервер]:</color> You inventory was copyed to the kit",
                ["UI Amount"] = "Timeleft: {amount}",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["No Space"] = "Can't redeem kit. Not enought space"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "<color=#008B8B>[Сервер]:</color> {kitname} был удалён",
                ["Kit Doesn't Exist"] = "<color=#008B8B>[Сервер]:</color> Этого комплекта не существует",
                ["Not Found Player"] = "<color=#008B8B>[Сервер]:</color> Игрок не найден",
                ["To Many Player"] = "<color=#008B8B>[Сервер]:</color> Найдено несколько игроков",
                ["Permission Denied"] = "<color=#008B8B>[Сервер]:</color> У вас нет полномочий использовать этот комплект",
                ["Limite Denied"] = "<color=#008B8B>[Сервер]:</color> Вы уже использовали этот комплект максимальное количество раз",
                ["Cooldown Denied"] = "<color=#008B8B>[Сервер]:</color> Вы сможете использовать этот комплект через {time}",
                ["Reset"] = "<color=#008B8B>[Сервер]:</color> Вы обнулили все данные о использовании комплектов игроков",
                ["Kit Already Exist"] = "<color=#008B8B>[Сервер]:</color> Этот набор уже существует",
                ["Kit Created"] = "<color=#008B8B>[Сервер]:</color> Вы создали новый набор - {name}",
                ["Kit Extradited"] = "<color=#008B8B>[Сервер]:</color> Вы получили комплект {kitname}",
                ["Kit Cloned"] = "<color=#008B8B>[Сервер]:</color> Предметы были скопированы из инвентаря в набор",
                ["UI Amount"] = "Осталось: {amount}",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["No Space"] = "Невозможно получить набор - недостаточно места в инвентаре"
            }, this, "ru");
        }

        private void Loaded()
        {
            _config = Config.ReadObject<PluginConfig>();
            _kits = Interface.Oxide.DataFileSystem.ReadObject<List<Kit>>("Kits");
            _kitsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, KitData>>>("Kits_Data");

            LoadMessages();
        }

        private void Init()
        {
            perm.RegisterPermission("kits.admin", this);
        }

        private void Unload()
        {
            SaveData();

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
        }

        private void OnServerInitialized()
        {
            foreach (var kit in _kits)
            {
                _imagesCache.Add(kit.Name, kit.Png);
                if (!permission.PermissionExists(kit.Permission))
                    permission.RegisterPermission(kit.Permission, this);
            }

            timer.Repeat(1, 0, RefreshCooldownKitsUI);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            _kitsGUI.Remove(player);
        }

        #endregion

        #region Commands

        [ConsoleCommand("kit")]
        private void CommandConsoleKit(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
                return;

            var player = arg.Player();

            if (!arg.HasArgs())
                return;

            var value = arg.Args[0].ToLower();

            if (value == "ui")
            {
                TriggerUI(player);
                return;
            }

            if (value == "next1")
            {
                TriggerUI(player);
                TriggerUI1(player);
                return;
            }

            if (value == "next2")
            {
                TriggerUI(player);
                TriggerUI2(player);
                return;
            }

            if (value == "next3")
            {
                TriggerUI(player);
                TriggerUI3(player);
                return;
            }


            if (!_kitsGUI.ContainsKey(player))
                return;

            if (!_kitsGUI[player].Contains(value))
                return;

            GiveKit(player, value);

            var container = new CuiElementContainer();
            var kit = _kits.First(x => x.Name == value);
            var playerData = GetPlayerData(player.userID, value);

            if (kit.Amount > 0)
            {
                if (playerData.Amount >= kit.Amount)
                {
                    foreach (var kitname in _kitsGUI[player])
                    {
                        CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.button");
                        CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.amount");
                        CuiHelper.DestroyUi(player, $"ui.kits.{kitname}");
                    }

                    InitilizeKitsUI(ref container, player);
                    CuiHelper.AddUi(player, container);
                    return;
                }

                CuiHelper.DestroyUi(player, $"ui.kits.{value}.amount");
                InitilizeAmountLabelUI(ref container, value, GetMsg("UI Amount", player).Replace("{amount}", (kit.Amount - playerData.Amount).ToString()));
            }

            if (kit.Cooldown > 0)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    CuiHelper.DestroyUi(player, $"ui.kits.{value}.button");

                    InitilizeMaskUI(ref container, kit.Name);
                    InitilizeCooldownLabelUI(ref container, value, TimeSpan.FromSeconds(playerData.Cooldown - currentTime));
                }
            }

            CuiHelper.AddUi(player, container);

            return;
        }

        [ChatCommand("kit")]
        private void CommandChatKit(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (args.Length == 0)
            {
                TriggerUI(player);
                return;
            }

            if (!player.IsAdmin && !perm.UserHasPermission(player.UserIDString, "kits.admin"))
            {
                GiveKit(player, args[0].ToLower());
                return;
            }

            switch (args[0].ToLower())
            {
                case "help":
                    SendReply(player, GetMsg("Help", player));
                    return;
                case "add":
                    if (args.Length < 2)
                        SendReply(player, GetMsg("Help Add", player));
                    else
                        KitCommandAdd(player, args[1].ToLower());
                    return;
                case "clone":
                    if (args.Length < 2)
                        SendReply(player, GetMsg("Help Clone", player));
                    else
                        KitCommandClone(player, args[1].ToLower());
                    return;
                case "remove":
                    if (args.Length < 2)
                        SendReply(player, GetMsg("Help Remove", player));
                    else
                        KitCommandRemove(player, args[1].ToLower());
                    return;
                case "list":
                    KitCommandList(player);
                    return;
                case "reset":
                    KitCommandReset(player);
                    return;
                case "give":
                    if (args.Length < 3)
                    {
                        SendReply(player, GetMsg("Help Give", player));
                    }
                    else
                    {
                        var foundPlayer = FindPlayer(player, args[1].ToLower());
                        if (foundPlayer == null)
                            return;

                        KitCommandGive(player, foundPlayer, args[2].ToLower());
                    }
                    return;
                default:
                    GiveKit(player, args[0].ToLower());
                    return;
            }
        }

        #endregion

        #region Kits

        private bool GiveKit(BasePlayer player, string kitname)
        {
            if (string.IsNullOrEmpty(kitname))
                return false;

            if (Interface.Oxide.CallHook("canRedeemKit", player) != null)
            {
                return false;
            }
            if (!_kits.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return false;
            }

            var kit = _kits.First(x => x.Name == kitname);

            if (!string.IsNullOrEmpty(kit.Permission) && !permission.UserHasPermission(player.UserIDString, kit.Permission))
            {
                SendReply(player, GetMsg("Permission Denied", player));
                return false;
            }

            var playerData = GetPlayerData(player.userID, kitname);

            if (kit.Amount > 0 && playerData.Amount >= kit.Amount)
            {
                SendReply(player, GetMsg("Limite Denied", player));
                return false;
            }

            if (kit.Cooldown > 0)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    SendReply(player, GetMsg("Cooldown Denied", player).Replace("{time}", TimeExtensions.FormatTime(TimeSpan.FromSeconds(playerData.Cooldown - currentTime))));
                    return false;
                }
            }

            //foreach (var item in kit.Items)
            //    player.GiveItem(ItemManager.CreateByName(item.ShortName, item.Amount, item.Skin));
            int beltcount = kit.Items.Where(i => i.Container == "belt").Count();
            int wearcount = kit.Items.Where(i => i.Container == "wear").Count();
            int maincount = kit.Items.Where(i => i.Container == "main").Count();
            int totalcount = beltcount + wearcount + maincount;
            if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < beltcount || (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < wearcount || (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < maincount)
                if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                {
                    player.ChatMessage(GetMsg("No Space", player));
                    return false;
                }
            GiveItems(player, kit);

            if (kit.Amount > 0)
                playerData.Amount += 1;

            if (kit.Cooldown > 0)
                playerData.Cooldown = GetCurrentTime() + kit.Cooldown;

            SendReply(player, GetMsg("Kit Extradited", player).Replace("{kitname}", kit.DisplayName));
            return true;
        }

        private void KitCommandAdd(BasePlayer player, string kitname)
        {
            if (_kits.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Already Exist", player));
                return;
            }

            _kits.Add(new Kit
            {
                Name = kitname,
                DisplayName = kitname,
                Cooldown = 600,
                Hide = true,
                Permission = "kits.default",
                Amount = 0,
                Png = _config.DefaultKitImage,
                Items = GetPlayerItems(player)
            });
            permission.RegisterPermission($"kits.default", this);
            SendReply(player, GetMsg("Kit Created", player).Replace("{name}", kitname));

            SaveKits();
            SaveData();
        }

        private void KitCommandClone(BasePlayer player, string kitname)
        {
            if (!_kits.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }

            _kits.First(x => x.Name == kitname).Items = GetPlayerItems(player);

            SendReply(player, GetMsg("Kit Cloned", player).Replace("{name}", kitname));

            SaveKits();
        }

        private void KitCommandRemove(BasePlayer player, string kitname)
        {
            if (_kits.RemoveAll(x => x.Name == kitname) <= 0)
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }

            SendReply(player, GetMsg("Kit Was Removed", player).Replace("{kitname}", kitname));

            SaveKits();
        }

        private void KitCommandList(BasePlayer player)
        {
            foreach (var kit in _kits)
                SendReply(player, $"{kit.Name} - {kit.DisplayName}");
        }

        private void KitCommandReset(BasePlayer player)
        {
            _kitsData.Clear();

            SendReply(player, GetMsg("Reset", player));
        }

        private void KitCommandGive(BasePlayer player, BasePlayer foundPlayer, string kitname)
        {
            var reply = 28;
            if (reply == 0) { }
            if (!_kits.Exists(x => x.Name == reply.ToString())) { }

            if (!_kits.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }

            GiveItems(foundPlayer, _kits.First(x => x.Name == kitname));
            PrintToChat(player, $"<color=#008B8B>[Сервер]:</color> Игроку <color=#008B8B>{foundPlayer}</color> был выдан набор <color=#008B8B>{kitname}</color>");
            PrintToChat(foundPlayer, $"<color=#008B8B>[Сервер]:</color> Вам был выдан набор <color=#008B8B>{kitname}</color>");
            LogToFile("LogKitsGive", $"[Сервер]: Игроку {foundPlayer} был выдан набор {kitname} администратором {player}", this);
        }
        private void GiveItems(BasePlayer player, Kit kit)
        {
            foreach (var kitem in kit.Items)
            {
                GiveItem(player.inventory, BuildItem(kitem.ShortName, kitem.Amount, kitem.SkinID, kitem.Condition, kitem.Blueprint, kitem.Weapon, kitem.Content), kitem.Container == "belt" ? player.inventory.containerBelt : kitem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }
        private void GiveItem(PlayerInventory inv, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            var a = item.MoveToContainer(cont) || item.MoveToContainer(inv.containerBelt) || item.MoveToContainer(inv.containerWear) || item.MoveToContainer(inv.containerMain);
        }
        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, int blueprintTarget, Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;

            if (blueprintTarget != 0)
                item.blueprintTarget = blueprintTarget;

            if (weapon != null)
            {
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = weapon.ammoAmount;
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
            }
            if (Content != null)
            {
                foreach (var cont in Content)
                {
                    Item new_cont = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    new_cont.condition = cont.Condition;
                    new_cont.MoveToContainer(item.contents);
                }
            }
            return item;
        }
        #endregion

        #region UI

        private void TriggerUI(BasePlayer player)
        {
            if (_kitsGUI.ContainsKey(player))
                DestroyUI(player);
            else
                InitilizeUI(player);
        }

        private void TriggerUI2(BasePlayer player)
        {
            InitilizeUI2(player);
        }

        private void TriggerUI3(BasePlayer player)
        {
            InitilizeUI3(player);
        }

        private void TriggerUI1(BasePlayer player)
        {
            InitilizeUI(player);
        }

        private void InitilizeUI(BasePlayer player)
        {
            var kits = GetKitsForPlayer(player).ToList();
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.MainBackgroundColor) },
                RectTransform = { AnchorMin = _config.Position.AnchorMin, AnchorMax = _config.Position.AnchorMax },
                CursorEnabled = true
            }, name: "ui.kits");
            container.Add(new CuiButton
            {
                Button = { Command = "kit ui", Color = _config.CloseButtonColor },
                RectTransform = { AnchorMin = _config.CloseButtonPosition.AnchorMin, AnchorMax = _config.CloseButtonPosition.AnchorMax },
                Text = { Text = "X", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, "ui.kits");
            foreach (var kit in kits)
            {
                if (kits.Count > 7)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next2", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.965 0.3", AnchorMax = "0.997 0.7" },
                        Text = { Text = ">", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");
                }
            }

            InitilizeKitsUI(ref container, player);

            CuiHelper.AddUi(player, container);
        }
        private void InitilizeUI2(BasePlayer player)
        {
            var kits = GetKitsForPlayer(player).ToList();
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.MainBackgroundColor) },
                RectTransform = { AnchorMin = _config.Position.AnchorMin, AnchorMax = _config.Position.AnchorMax },
                CursorEnabled = true
            }, name: "ui.kits");
            container.Add(new CuiButton
            {
                Button = { Command = "kit ui", Color = _config.CloseButtonColor },
                RectTransform = { AnchorMin = _config.CloseButtonPosition.AnchorMin, AnchorMax = _config.CloseButtonPosition.AnchorMax },
                Text = { Text = "X", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, "ui.kits");

            foreach (var kit in kits)
            {
                if (kits.Count > 14)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next1", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.002 0.3", AnchorMax = "0.035 0.7" },
                        Text = { Text = "<", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");

                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next3", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.965 0.3", AnchorMax = "0.997 0.7" },
                        Text = { Text = ">", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");
                }
                else if (kits.Count > 7)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next1", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.002 0.3", AnchorMax = "0.035 0.7" },
                        Text = { Text = "<", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");

                }
            }


            if (kits.Count < 7)
            {
                InitilizeKitsUI(ref container, player);
            }
            else
            {
                InitilizeKitsUINext(ref container, player);
            }

            CuiHelper.AddUi(player, container);
        }

        private void InitilizeUI3(BasePlayer player)
        {
            var kits = GetKitsForPlayer(player).ToList();
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.MainBackgroundColor) },
                RectTransform = { AnchorMin = _config.Position.AnchorMin, AnchorMax = _config.Position.AnchorMax },
                CursorEnabled = true
            }, name: "ui.kits");
            container.Add(new CuiButton
            {
                Button = { Command = "kit ui", Color = _config.CloseButtonColor },
                RectTransform = { AnchorMin = _config.CloseButtonPosition.AnchorMin, AnchorMax = _config.CloseButtonPosition.AnchorMax },
                Text = { Text = "X", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, "ui.kits");

            foreach (var kit in kits)
            {
                if (kits.Count > 14)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next2", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.002 0.3", AnchorMax = "0.035 0.7" },
                        Text = { Text = "<", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");


                }
                else if (kits.Count > 7)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next1", Color = _config.CloseButtonColor },
                        RectTransform = { AnchorMin = _config.CloseButtonPositionNext1.AnchorMin, AnchorMax = _config.CloseButtonPositionNext1.AnchorMax },
                        Text = { Text = "1", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next2", Color = _config.CloseButtonColor },
                        RectTransform = { AnchorMin = _config.CloseButtonPositionNext2.AnchorMin, AnchorMax = _config.CloseButtonPositionNext2.AnchorMax },
                        Text = { Text = "2", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");
                }
            }


            if (kits.Count < 14)
            {
                InitilizeKitsUINext(ref container, player);
            }
            else if (kits.Count < 7)
            {
                InitilizeKitsUI(ref container, player);
            }
            else
            {
                InitilizeKitsUI2(ref container, player);
            }

            CuiHelper.AddUi(player, container);
        }

        private void DestroyUI(BasePlayer player)
        {
            if (!_kitsGUI.ContainsKey(player))
                return;

            foreach (var kitname in _kitsGUI[player])
            {
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.time");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.mask");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.button");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.amount");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}");
            }
            CuiHelper.DestroyUi(player, "ui.kits");

            _kitsGUI.Remove(player);
        }

        private void RefreshCooldownKitsUI()
        {
            var currentTime = GetCurrentTime();
            foreach (var playerGUIData in _kitsGUI)
            {
                var container = new CuiElementContainer();
                if (!_kitsData.ContainsKey(playerGUIData.Key.userID)) continue;
                var playerKitsData = _kitsData[playerGUIData.Key.userID];
                foreach (var kitname in playerGUIData.Value)
                {
                    var playerKitData = playerKitsData[kitname];
                    if (playerKitData.Cooldown > 0)
                    {
                        CuiHelper.DestroyUi(playerGUIData.Key, $"ui.kits.{kitname}.time");
                        if (playerKitData.Cooldown < currentTime)
                        {
                            CuiHelper.DestroyUi(playerGUIData.Key, $"ui.kits.{kitname}.mask");
                            InitilizeButtonUI(ref container, kitname);
                        }
                        else
                        {
                            InitilizeCooldownLabelUI(ref container, kitname, TimeSpan.FromSeconds(playerKitData.Cooldown - currentTime));
                        }
                    }
                }
                CuiHelper.AddUi(playerGUIData.Key, container);
            }
        }

        private void InitilizeKitsUI(ref CuiElementContainer container, BasePlayer player)
        {
            _kitsGUI[player] = new List<string>();
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).Take((int)(1.0f / (_config.KitWidth + _config.MarginBetween))).ToList();
            var pos = 0.490f - (kits.Count * _config.KitWidth + (kits.Count - 1) * _config.MarginBetween) / 2;

            foreach (var kit in kits)
            {
                _kitsGUI[player].Add(kit.Name);

                var playerData = GetPlayerData(player.userID, kit.Name);

                // Kit panel
                container.Add(new CuiPanel
                {
                    Image = { Color = HexToRustFormat(_config.KitBackgroundColor) },
                    RectTransform = { AnchorMin = $"{pos} {_config.MarginBottom}", AnchorMax = $"{pos + _config.KitWidth} {1.0f - _config.MarginTop}" }
                }, "ui.kits", $"ui.kits.{kit.Name}");

                pos += _config.KitWidth + _config.MarginBetween;

                InitilizeNameLabelUI(ref container, kit.Name, kit.DisplayName);

                InitilizeKitImageUI(ref container, kit.Name);

                if (kit.Amount > 0)
                {
                    InitilizeAmountLabelUI(ref container, kit.Name, GetMsg("UI Amount", player).Replace("{amount}", (kit.Amount - playerData.Amount).ToString()));
                }

                if (kit.Cooldown > 0 && (playerData.Cooldown > currentTime))
                {
                    InitilizeMaskUI(ref container, kit.Name);
                    InitilizeCooldownLabelUI(ref container, kit.Name, TimeSpan.FromSeconds(playerData.Cooldown - currentTime));
                }
                else
                {
                    InitilizeButtonUI(ref container, kit.Name);
                }
            }
        }

        private void InitilizeKitsUINext(ref CuiElementContainer container, BasePlayer player)
        {
            _kitsGUI[player] = new List<string>();
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).Take((int)(1.0f / (_config.KitWidth + _config.MarginBetween)) + 7).ToList();
            var pos = 0.525f - ((kits.Count - 7) * _config.KitWidth + (kits.Count - 1) * _config.MarginBetween) / 2;
            var kitsAmount = kits.Skip(7);
            foreach (var kit in kitsAmount)
            {
                _kitsGUI[player].Add(kit.Name);

                var playerData = GetPlayerData(player.userID, kit.Name);

                // Kit panel
                container.Add(new CuiPanel
                {
                    Image = { Color = HexToRustFormat(_config.KitBackgroundColor) },
                    RectTransform = { AnchorMin = $"{pos} {_config.MarginBottom}", AnchorMax = $"{pos + _config.KitWidth} {1.0f - _config.MarginTop}" }
                }, "ui.kits", $"ui.kits.{kit.Name}");

                pos += _config.KitWidth + _config.MarginBetween;

                InitilizeNameLabelUI(ref container, kit.Name, kit.DisplayName);

                InitilizeKitImageUI(ref container, kit.Name);

                if (kit.Amount > 0)
                {
                    InitilizeAmountLabelUI(ref container, kit.Name, GetMsg("UI Amount", player).Replace("{amount}", (kit.Amount - playerData.Amount).ToString()));
                }

                if (kit.Cooldown > 0 && (playerData.Cooldown > currentTime))
                {
                    InitilizeMaskUI(ref container, kit.Name);
                    InitilizeCooldownLabelUI(ref container, kit.Name, TimeSpan.FromSeconds(playerData.Cooldown - currentTime));
                }
                else
                {
                    InitilizeButtonUI(ref container, kit.Name);
                }
            }
        }

        private void InitilizeKitsUI2(ref CuiElementContainer container, BasePlayer player)
        {
            _kitsGUI[player] = new List<string>();
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).ToList();
            var pos = 0.56f - ((kits.Count - 14) * _config.KitWidth + (kits.Count - 1) * _config.MarginBetween) / 2;
            var kitsAmount = kits.Skip(14);
            foreach (var kit in kitsAmount)
            {
                _kitsGUI[player].Add(kit.Name);

                var playerData = GetPlayerData(player.userID, kit.Name);

                // Kit panel
                container.Add(new CuiPanel
                {
                    Image = { Color = HexToRustFormat(_config.KitBackgroundColor) },
                    RectTransform = { AnchorMin = $"{pos} {_config.MarginBottom}", AnchorMax = $"{pos + _config.KitWidth} {1.0f - _config.MarginTop}" }
                }, "ui.kits", $"ui.kits.{kit.Name}");

                pos += _config.KitWidth + _config.MarginBetween;

                InitilizeNameLabelUI(ref container, kit.Name, kit.DisplayName);

                InitilizeKitImageUI(ref container, kit.Name);

                if (kit.Amount > 0)
                {
                    InitilizeAmountLabelUI(ref container, kit.Name, GetMsg("UI Amount", player).Replace("{amount}", (kit.Amount - playerData.Amount).ToString()));
                }

                if (kit.Cooldown > 0 && (playerData.Cooldown > currentTime))
                {
                    InitilizeMaskUI(ref container, kit.Name);
                    InitilizeCooldownLabelUI(ref container, kit.Name, TimeSpan.FromSeconds(playerData.Cooldown - currentTime));
                }
                else
                {
                    InitilizeButtonUI(ref container, kit.Name);
                }
            }
        }

        private void InitilizeKitImageUI(ref CuiElementContainer container, string kitname)
        {
            string image = _imagesCache.Get(kitname);
            CuiRawImageComponent imageComp = new CuiRawImageComponent
            {
                Sprite = "assets/content/textures/generic/fulltransparent.tga",
                Color = HexToRustFormat(_config.Image.Color)
            };
            if (image != string.Empty)
            {
                imageComp.Png = image;
            }
            container.Add(new CuiElement
            {
                Parent = $"ui.kits.{kitname}",
                Components =
                {
                    imageComp,
                    new CuiRectTransformComponent {AnchorMin = _config.Image.Position.AnchorMin, AnchorMax = _config.Image.Position.AnchorMax }
                }
            });
        }

        private void InitilizeNameLabelUI(ref CuiElementContainer container, string kitname, string text)
        {
            var name = container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.Label.BackgroundColor) },
                RectTransform = { AnchorMin = _config.Label.Position.AnchorMin, AnchorMax = _config.Label.Position.AnchorMax }
            }, $"ui.kits.{kitname}");

            container.Add(new CuiLabel
            {
                Text = { Color = HexToRustFormat(_config.Label.ForegroundColor), FontSize = _config.Label.FontSize, Align = _config.Label.TextAnchor, Text = text }
            }, name);
        }

        private void InitilizeMaskUI(ref CuiElementContainer container, string kitname)
        {
            var name = container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.DisableMaskColor) }
            }, $"ui.kits.{kitname}", $"ui.kits.{kitname}.mask");
        }

        private void InitilizeAmountLabelUI(ref CuiElementContainer container, string kitname, string text)
        {
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.Amount.BackgroundColor) },
                RectTransform = { AnchorMin = _config.Amount.Position.AnchorMin, AnchorMax = _config.Amount.Position.AnchorMax }
            }, $"ui.kits.{kitname}", $"ui.kits.{kitname}.amount");

            container.Add(new CuiLabel
            {
                Text = { Color = HexToRustFormat(_config.Amount.ForegroundColor), FontSize = _config.Amount.FontSize, Align = _config.Amount.TextAnchor, Text = text }
            }, $"ui.kits.{kitname}.amount");
        }

        private void InitilizeButtonUI(ref CuiElementContainer container, string kitname)
        {
            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"kit {kitname}" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = "" }
            }, $"ui.kits.{kitname}", $"ui.kits.{kitname}.button");
        }

        private void InitilizeCooldownLabelUI(ref CuiElementContainer container, string kitname, TimeSpan time)
        {
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.Time.BackgroundColor) },
                RectTransform = { AnchorMin = _config.Time.Position.AnchorMin, AnchorMax = _config.Time.Position.AnchorMax }
            }, $"ui.kits.{kitname}", $"ui.kits.{kitname}.time");

            container.Add(new CuiLabel
            {
                Text = { Color = HexToRustFormat(_config.Time.ForegroundColor), FontSize = _config.Time.FontSize, Align = _config.Time.TextAnchor, Text = TimeExtensions.FormatShortTime(time) }
            }, $"ui.kits.{kitname}.time");
        }

        #endregion

        #region Helpers 

        private KitData GetPlayerData(ulong userID, string name)
        {
            if (!_kitsData.ContainsKey(userID))
                _kitsData[userID] = new Dictionary<string, KitData>();

            if (!_kitsData[userID].ContainsKey(name))
                _kitsData[userID][name] = new KitData();

            return _kitsData[userID][name];
        }

        private List<KitItem> GetPlayerItems(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }

        string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player == null ? null : player.UserIDString);

        private KitItem ItemToKit(Item item, string container)
        {
            KitItem kitem = new KitItem();
            kitem.Amount = item.amount;
            kitem.Container = container;
            kitem.SkinID = item.skin;
            kitem.Blueprint = item.blueprintTarget;
            kitem.ShortName = item.info.shortname;
            kitem.Condition = item.condition;
            kitem.Weapon = null;
            kitem.Content = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitem.Weapon = new Weapon();
                    kitem.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    kitem.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }
            if (item.contents != null)
            {
                kitem.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    kitem.Content.Add(new ItemContent()
                    {
                        Amount = cont.amount,
                        Condition = cont.condition,
                        ShortName = cont.info.shortname
                    });
                }
            }
            return kitem;
        }

        private List<Kit> GetKitsForPlayer(BasePlayer player)
        {
            return _kits.Where(kit => kit.Hide == false && (string.IsNullOrEmpty(kit.Permission) || permission.UserHasPermission(player.UserIDString, kit.Permission)) && (kit.Amount == 0 || (kit.Amount > 0 && GetPlayerData(player.userID, kit.Name).Amount < kit.Amount))).ToList();
        }

        private BasePlayer FindPlayer(BasePlayer player, string nameOrID)
        {
            ulong id;
            if (ulong.TryParse(nameOrID, out id) && nameOrID.StartsWith("7656119") && nameOrID.Length == 17)
            {
                var findedPlayer = BasePlayer.FindByID(id);
                if (findedPlayer == null || !findedPlayer.IsConnected)
                {
                    SendReply(player, GetMsg("Not Found Player", player));
                    return null;
                }

                return findedPlayer;
            }

            var foundPlayers = BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(nameOrID.ToLower()));

            if (foundPlayers.Count() == 0)
            {
                SendReply(player, GetMsg("Not Found Player", player));
                return null;
            }

            if (foundPlayers.Count() > 1)
            {
                SendReply(player, GetMsg("To Many Player", player));
                return null;
            }

            return foundPlayers.First();
        }

        private double GetCurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0)
                    result += $"{time.Days} д. ";

                if (time.Hours != 0)
                    result += $"{time.Hours} ч. ";

                if (time.Minutes != 0)
                    result += $"{time.Minutes} м. ";

                if (time.Seconds != 0)
                    result += $"{time.Seconds} с. ";

                return result;
            }

            public static string FormatTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0)
                    result += $"{Format(time.Days, "дней", "дня", "день")} ";

                if (time.Hours != 0)
                    result += $"{Format(time.Hours, "часов", "часа", "час")} ";

                if (time.Minutes != 0)
                    result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

                if (time.Seconds != 0)
                    result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units} {form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units} {form2}";

                return $"{units} {form3}";
            }
        }

        #endregion
    }
}
                      

// --- End of file: Kits (2).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XPPermissions.cs ---
// --- Original Local Path: XPPermissions.cs ---

using System.Collections.Generic;
using Oxide.Core.Libraries;
using Oxide.Core;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("XP Permissions", "PaiN", "0.3.1", ResourceId = 2024)]
    [Description("Grants player permission on their level up.")]
    class XPPermissions : RustPlugin
    {

        ConfigFile Cfg = new ConfigFile();

        class ConfigFile
        {
            public Dictionary<int, List<_Permission>> Permissions = new Dictionary<int, List<_Permission>>
            {
                {5, new List<_Permission> { new _Permission("default", "kit.default", "tag.default", "bgrade.permission") } }
            };
        }

        class _Permission
        {
            public List<string> Permission = new List<string>();
            public string Group;

            public _Permission(string groupname, params string[] permission)
            {
                foreach(string perm in permission)
                Permission.Add(perm);
                Group = groupname; 
            } 
        } 

        void Loaded() 
        {
            Cfg = Config.ReadObject<ConfigFile>();
            LoadMessages();
            permission.RegisterPermission("xppermissions.admin", this);
        }

        void LoadMessages()
        {
            Dictionary<string, string> messages = new Dictionary<string, string>
            {
                //{"CMD_NO_PERMISSION", "You do not have permission to use this command" },
                {"LVL_PERMISSION_GRANTED", "You have been granted the permission '{perm}' for reaching level {lvl}." },
                {"CONSOLE_LVL_PERM_GRANTED", "'{perm}' permission has been granted to ({id}/{name}) for reaching level ({lvl})"},
               // {"CMD_ADD_SYNTAX", "Syntax: \"/xpp add <permission> <level> <group>\" "},
               // {"CMD_XPPERMISSION_ADDED", "New XP Permission added! || Permission: {0} ## Level: {1} ## Group: {2} ||" },
              //  {"CMD_REMOVE_SYNTAX", "Syntax: \"/xpp remove <Level> <OPTIONAL:Group> <OPTIONAL:Permission> \" " },
              //  {"CMD_SYNTAX", "/xpp add <permission> <level> <group> \n /xpp remove <Level> <OPTIONAL:Group> <OPTIONAL:Permission> "}
            };
             
            lang.RegisterMessages(messages, this);   
        }

        protected override void LoadDefaultConfig() { PrintWarning("Creating a new configuration file . . ."); Config.WriteObject(Cfg, true); }

        void OnXpEarned(ulong id, float amount, string source)
        {
            BasePlayer player = BasePlayer.FindByID(id);
            var agent = BasePlayer.FindXpAgent(id);
            int level = (int)agent.CurrentLevel;
            if (Cfg.Permissions.Any(x => x.Key == level))
            {
                List<_Permission> info = Cfg.Permissions[level];
                foreach (_Permission lvl in info.ToList())
                {
                    foreach (var perm in lvl.Permission.ToList())
                    {
                        if (!permission.PermissionExists(perm))
                        {
                            PrintWarning(string.Format("Permission '{0}' does not exists. Attempt to grant permission has failed.", perm));
                            return;
                        }

                        if (permission.UserHasGroup(id.ToString(), lvl.Group) && !permission.UserHasPermission(id.ToString(), perm))
                        {
                            ConsoleSystem.Run.Server.Normal($"grant user {id} {perm}");
                            Puts(LangMsg("CONSOLE_LVL_PERM_GRANTED", null).Replace("{perm}", perm).Replace("{id}", id.ToString()).Replace("{name}", player?.displayName).Replace("{lvl}", level.ToString()));
                            PrintToChat(player, LangMsg("LVL_PERMISSION_GRANTED", id.ToString()).Replace("{perm}", perm).Replace("{lvl}", level.ToString()));

                        }
                    }
                }
            }
        }

      
        /* [ChatCommand("xpp")]
         void cmdXPP(BasePlayer player, string cmd, string[] args)
         {
             if(!permission.UserHasPermission(player.UserIDString, "xppermissions.admin"))
             {
                 player.ChatMessage(LangMsg("CMD_NO_PERMISSION", player.UserIDString));
                 return;
             }

             if (args.Length <= 1)
             {
                 player.ChatMessage(LangMsg("CMD_SYNTAX", player.UserIDString));
                 return;
             }

             int level;

             switch (args[0])
             {
                 case "add":
                     if (!int.TryParse(args[2], out level))
                     {
                         player.ChatMessage(LangMsg("CMD_ADD_SYNTAX", player.UserIDString));
                         return;
                     }

                     if (data.Permissions.ContainsKey(level))
                     {
                         foreach (_Permission sinfo in data.Permissions[level].ToList())
                             if (args[3] == sinfo.Group)
                                 sinfo.Permission.Add(args[1]);
                             else
                             {
                                 _Permission newperm = new _Permission(args[3], args[1]);
                                 data.Permissions[level].Add(newperm);
                             }
                     }
                     else 
                     {
                         _Permission perm = new _Permission(args[3], args[1]);
                         data.Permissions.Add(level, new List<_Permission> { perm });
                     }
                     break;
                 case "remove":
                     if (!int.TryParse(args[1], out level))
                     {
                         player.ChatMessage(LangMsg("CMD_REMOVE_SYNTAX", player.UserIDString));
                         return;
                     }
                     List<_Permission> info = data.Permissions[level];

                     if (args.Length == 4)
                     {   
                         foreach (_Permission lvl in info)
                             foreach (string perm in CopyList(lvl.Permission))
                                 if (args[2] == lvl.Group && args[3] == perm)
                                     lvl.Permission.Remove(perm);
                     }
                     else if(args.Length == 3)
                     {
                         foreach (_Permission lvl in info)
                             if (args[2] == lvl.Group)
                                 data.Permissions[level].Remove(lvl);
                     }
                     else if(args.Length == 2)
                     { 
                         if (data.Permissions.Any(x => x.Key == level))
                             data.Permissions.Remove(level);
                     }
                     break;
             }
             SaveData();
         }*/


        string LangMsg(string msg, string uid = null) => lang.GetMessage(msg, this, uid);
    }
}

// --- End of file: XPPermissions.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Fishing.cs ---
// --- Original Local Path: Fishing.cs ---

using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using System.Reflection;
using Oxide.Game.Rust.Cui;
using Facepunch.Extend;

namespace Oxide.Plugins
{
     [Info("Fishing", "Colon Blow", "1.2.2", ResourceId = 1537)]
     class Fishing : RustPlugin
     {
	public int fishchance;
	public int fishchancemodweapon;
	public int fishchancemodattire;
	public int fishchancemoditem;
	public int fishchancemodtime;
	public string FishIcon;
	public string chancetext1;
	public string chancetext2;
	public float currenttime;
	public float ghitDistance;
	public float whitDistance;
	private static int waterlayer;
	private static int groundlayer;
	private bool Changed;
	//string CaughtFish = "assets/content/unimplemented/fishing_rod/vm_fishing_rod/pluck_fish.prefab";
	string randomlootprefab = "assets/bundled/prefabs/radtown/dmloot/dm tier3 lootbox.prefab";

	Dictionary<ulong, string> GuiInfo = new Dictionary<ulong, string>();

        void Loaded()
        {                       
        	lang.RegisterMessages(messages, this);
        	LoadVariables();
		permission.RegisterPermission("fishing.allowed", this);
	}
        void LoadDefaultConfig()
        {
	    	Puts("No configuration file found, generating...");
	    	Config.Clear();
            	LoadVariables();
        }

        void OnServerInitialized()
        {
        	waterlayer = UnityEngine.LayerMask.GetMask("Water");
	        groundlayer = UnityEngine.LayerMask.GetMask("Terrain", "World", "Construction");
        }

        bool IsAllowed(BasePlayer player, string perm)
        {
        	if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
        	return false;
        }
//Configuration Variables

	public bool ShowFishCatchIcon = true;
	public bool allowrandomitemchance = true;
	public bool useweaponmod = true;
	public bool useattiremod = true;
	public bool useitemmod = true;
	public bool usetimemod = true;

	public int fishchancedefault = 10;
	public int randomitemchance = 1;
	public int fishchancemodweaponbonus = 10;
	public int fishchancemodattirebonus = 10;
	public int fishchancemoditembonus = 10;
	public int fishchancemodtimebonus = 10;

	public string iconcommonfish2 = "http://i.imgur.com/HftxU00.png";
	public string iconuncommonfish1 = "http://i.imgur.com/xReDQM1.png";
	public string iconcommonfish1 = "http://i.imgur.com/rBEmhpg.png";
	public string iconrandomitem = "http://i.imgur.com/y2scGmZ.png";
	public string iconrarefish1 = "http://i.imgur.com/jMZxGf1.png";

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void LoadConfigVariables()
        {
            CheckCfg("Show Fish Catch Indicator", ref ShowFishCatchIcon);
            CheckCfg("Allow Random Item Chance", ref allowrandomitemchance);
            CheckCfg("Allow Bonus from Weapon", ref useweaponmod);
            CheckCfg("Allow Bonus from Attire", ref useattiremod);
            CheckCfg("Allow Bonus from Item", ref useitemmod);
            CheckCfg("Allow Bonus from Time of Day", ref usetimemod);

            CheckCfg("Chance - Default to Catch Fish (Percentage)", ref fishchancedefault);
            CheckCfg("Chance - Get Random World Item (Percentage)", ref randomitemchance);
            CheckCfg("Bonus - From Weapon (Percentage)", ref fishchancemodweaponbonus);
            CheckCfg("Bonus - From Attire (Percentage)", ref fishchancemodattirebonus);
            CheckCfg("Bonus - From Items (Percentage)", ref fishchancemoditembonus);
            CheckCfg("Bonus - From Time of Day (Percentage)", ref fishchancemodtimebonus);

            CheckCfg("Icon - Url for Common Fish 2", ref iconcommonfish2);
            CheckCfg("Icon - Url for Common Fish 1", ref iconcommonfish1);
            CheckCfg("Icon - Url for UnCommon Fish 1", ref iconuncommonfish1);
            CheckCfg("Icon - Url for Random Item", ref iconrandomitem);
            CheckCfg("Icon - Url for Rare Fish 1", ref iconrarefish1);
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = System.Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

//Plugin Messages that use language
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"missedfish", "You Missed the fish...." },
            {"commonfish1", "You Got a Savis Island Swordfish" },
            {"commonfish2", "You Got a Hapis Island RazorJaw" },
            {"uncommonfish1", "You Got a Colon BlowFish" },
            {"rarefish1", "You Got a Craggy Island Dorkfish" },
            {"randomitem", "You found something in the water !!!" },
            {"chancetext1", "Your chance to catch a fish is : " },
            {"chancetext2", "% at Current time of : " }
        };

// Modifiers that chance the chance a player will get a fish or not
	void catchChanceMod(BasePlayer player)
	{

	fishchancemodweapon = 0;
	fishchancemodattire = 0;
	fishchancemoditem = 0;
	fishchancemodtime = 0;
	currenttime = TOD_Sky.Instance.Cycle.Hour;

	Item activeItem = player.GetActiveItem();

            	if (activeItem != null && activeItem.info.shortname == "spear.stone" && useweaponmod)
		{ 
		fishchancemodweapon = fishchancemodweaponbonus;
		}
            	if (activeItem != null && activeItem.info.shortname == "crossbow" && useweaponmod)
		{ 
		fishchancemodweapon = fishchancemodweaponbonus;
		}

	int hasBoonieOn = player.inventory.containerWear.GetAmount(-1397343301, true);
	if (hasBoonieOn >= 1 && useattiremod)
		{ 
		fishchancemodattire = fishchancemodattirebonus;
		}
	int hasPookie = player.inventory.containerMain.GetAmount(640562379, true);
	if (hasPookie >= 1 && useitemmod)
		{ 
		fishchancemoditem = fishchancemoditembonus;
		}
	if (currenttime < 8 && currenttime > 6 && usetimemod)
		{
		fishchancemodtime = fishchancemodtimebonus;
		}
	if (currenttime < 19 && currenttime > 16 && usetimemod)
		{
		fishchancemodtime = fishchancemodtimebonus;
		}
	return;
	}
	
// Checks to see if player is looking at water
	bool isLookingAtWater(BasePlayer player)
        {
		whitDistance = 0;
		ghitDistance = 0;
		UnityEngine.Ray ray = new UnityEngine.Ray(player.eyes.position, player.eyes.HeadForward());

		var hitsw = UnityEngine.Physics.RaycastAll(ray, 5f, waterlayer);
		var hitsg = UnityEngine.Physics.RaycastAll(ray, 5f, groundlayer);

	foreach (var hit in hitsw) 
		{
		if (hit.distance == null) return false;
		whitDistance = hit.distance;
		}
	foreach (var hit in hitsg)
		{
		if (hit.distance == null) return false;
		ghitDistance = hit.distance;
		}
		if (whitDistance < ghitDistance && whitDistance > 0) return true;
		return false;
        }

// Chance roll to see if player gets a fish or not in Open water areas
	void rollforfish(BasePlayer player, HitInfo hitInfo)
	{
		catchChanceMod(player);
		int roll = UnityEngine.Random.Range(0, 100);
		fishchance = fishchancedefault+fishchancemodweapon+fishchancemodattire+fishchancemoditem+fishchancemodtime;
		if (roll < fishchance)
                {
			catchFishFX(player, hitInfo);
			return;
                }
		else
		SendReply(player, lang.GetMessage("missedfish", this));
		return;
	}

// Effect for catching fish
	void catchFishFX(BasePlayer player, HitInfo hitInfo)
	{

	int fishtyperoll = UnityEngine.Random.Range(1, 100);
	if (fishtyperoll > 99)
		{
		FishIcon = iconrarefish1;
		SendReply(player, lang.GetMessage("rarefish", this));
		player.inventory.GiveItem(ItemManager.CreateByItemID(865679437, 5));
		player.Command("note.inv", 865679437, 5);
		}
	if (fishtyperoll >= 90 && fishtyperoll < 100)
		{
		FishIcon = iconuncommonfish1;
		SendReply(player, lang.GetMessage("uncommonfish1", this));
		player.inventory.GiveItem(ItemManager.CreateByItemID(865679437, 2));
		player.Command("note.inv", 865679437, 2);
		}
	if (fishtyperoll > 45 && fishtyperoll < 90)
		{
		FishIcon = iconcommonfish2;
		SendReply(player, lang.GetMessage("commonfish2", this));
		player.inventory.GiveItem(ItemManager.CreateByItemID(88869913, 1));
		player.Command("note.inv", 88869913, 1);
		}
	if (fishtyperoll >= 1 && fishtyperoll <= 45)
		{
		FishIcon = iconcommonfish1;
		SendReply(player, lang.GetMessage("commonfish1", this));
		player.inventory.GiveItem(ItemManager.CreateByItemID(865679437, 1));
		player.Command("note.inv", 865679437, 1);
		}
	if (fishtyperoll < randomitemchance && allowrandomitemchance)
		{
		FishIcon = iconrandomitem;
		SendReply(player, lang.GetMessage("randomitem", this));
		SpawnLootBox(player, hitInfo);
		}

	catchFishCui(player);
	}

// Runs Fishing Action on player attack when all criteria are met
	void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
	{
	var player = attacker as BasePlayer;

	if (!IsAllowed(player, "fishing.allowed")) return;
	if (IsAllowed(player, "fishing.allowed"))
		{
		if (hitInfo?.HitEntity as BaseCombatEntity) return;
		if (hitInfo == null) return;

		if (hitInfo.WeaponPrefab.ToString().Contains("spear") || hitInfo.WeaponPrefab.ToString().Contains("bow"))
			{
			if (isLookingAtWater(player))
				{
				rollforfish(player, hitInfo);
				hitInfo.CanGather = true;
				return;
				}
			}
			if (player.IsHeadUnderwater())
			{
				{
				rollforfish(player, hitInfo);
				hitInfo.CanGather = true;
				return;
				}
			}
		}
	}

// Show fish icon and player animation when catching fish
	void catchFishCui(BasePlayer player)
	{
	if (ShowFishCatchIcon) FishingGui(player);
	}

// Displays Fish catch icon
        void FishingGui(BasePlayer player)
        {
	DestroyCui(player);

        var elements = new CuiElementContainer();
        GuiInfo[player.userID] = CuiHelper.GetGuid();

        if (ShowFishCatchIcon)
        {
        	elements.Add(new CuiElement
                {
                    Name = GuiInfo[player.userID],
		    Parent = "Overlay",
                    Components =
                    {
                        new CuiRawImageComponent { Color = "1 1 1 1", Url = FishIcon, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent { AnchorMin = "0.220 0.03",  AnchorMax = "0.260 0.10" }
                    }
                });
            }

            CuiHelper.AddUi(player, elements);
	    timer.Once(1f, () => DestroyCui(player));
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                string guiInfo;
                if (GuiInfo.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);
            }
        }
	void DestroyCui(BasePlayer player)
	{
                string guiInfo;
                if (GuiInfo.TryGetValue(player.userID, out guiInfo)) CuiHelper.DestroyUi(player, guiInfo);
	}

	
	[ChatCommand("fishchance")]
        void cmdChatfishchance(BasePlayer player, string command, string[] args)
        {
	currenttime = TOD_Sky.Instance.Cycle.Hour;
	catchChanceMod(player);
	var fishchancepercent = fishchancedefault+fishchancemodweapon+fishchancemodattire+fishchancemoditem+fishchancemodtime;
	SendReply(player, lang.GetMessage("chancetext1", this) + fishchancepercent + lang.GetMessage("chancetext2", this) + currenttime);
        }

        void SpawnLootBox(BasePlayer player, HitInfo hitInfo)
        {
            var createdPrefab = GameManager.server.CreateEntity(randomlootprefab, hitInfo.HitPositionWorld);
            BaseEntity entity = createdPrefab?.GetComponent<BaseEntity>();
            entity?.Spawn();
        }
     }
}

// --- End of file: Fishing.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Ignore.cs ---
// --- Original Local Path: Ignore.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

using Oxide.Core;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Ignore", "Nogrod", "2.0.1", ResourceId = 1054)]
    class Ignore : RustPlugin
    {
        private ConfigData configData;
        private Dictionary<ulong, PlayerData> IgnoreData;
        private readonly Dictionary<ulong, HashSet<ulong>> ReverseData = new Dictionary<ulong, HashSet<ulong>>();

        class ConfigData
        {
            public int IgnoreLimit { get; set; }
        }

        class PlayerData
        {
            public string Name { get; set; } = string.Empty;
            public HashSet<ulong> Ignores { get; set; } = new HashSet<ulong>();
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                IgnoreLimit = 30
            };
            Config.WriteObject(config, true);
        }

        private void Init()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"List", "Ignored {0}:\n{1}"},
                {"NoIngored", "Your ignore list is empty."},
                {"NotOnIgnorelist", "{0} not found on your ignorelist."},
                {"IgnoreRemoved", "{0} was removed from your ignorelist."},
                {"PlayerNotFound", "Player '{0}' not found."},
                {"CantAddSelf", "You cant add yourself."},
                {"AlreadyOnList", "{0} is already ignored."},
                {"IgnoreAdded", "{0} is now ignored."},
                {"IgnorelistFull", "Your ignorelist is full."},
                {"HelpText", "Use /ignore <add|+|remove|-|list> <name/steamID> to add/remove/list ignores"},
                {"Syntax", "Syntax: /ignore <add/+/remove/-> <name/steamID> or /ignore list"}
            }, this);
            configData = Config.ReadObject<ConfigData>();
            try
            {
                IgnoreData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>(nameof(Ignore));
            }
            catch
            {
                IgnoreData = new Dictionary<ulong, PlayerData>();
            }
            foreach (var data in IgnoreData)
                foreach (var friend in data.Value.Ignores)
                    AddIgnoreReverse(data.Key, friend);
        }

        private void SaveIgnores()
        {
            Interface.Oxide.DataFileSystem.WriteObject(nameof(Ignore), IgnoreData);
        }

        private bool AddIgnoreS(string playerS, string ignoreS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(ignoreS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var ignoreId = Convert.ToUInt64(ignoreS);
            return AddIgnore(playerId, ignoreId);
        }

        private bool AddIgnore(ulong playerId, ulong ignoreId)
        {
            var playerData = GetPlayerData(playerId);
            if (playerData.Ignores.Count >= configData.IgnoreLimit || !playerData.Ignores.Add(ignoreId)) return false;
            AddIgnoreReverse(playerId, ignoreId);
            SaveIgnores();
            return true;
        }

        private bool RemoveIgnoreS(string playerS, string ignoreS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(ignoreS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var ignoreId = Convert.ToUInt64(ignoreS);
            return RemoveIgnore(playerId, ignoreId);
        }

        private bool RemoveIgnore(ulong playerId, ulong ignoreId)
        {
            if (!GetPlayerData(playerId).Ignores.Remove(ignoreId)) return false;
            HashSet<ulong> ignoreS;
            if (ReverseData.TryGetValue(ignoreId, out ignoreS))
                ignoreS.Remove(playerId);
            SaveIgnores();
            return true;
        }

        private bool HasIgnoredS(string playerS, string ignoreS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(ignoreS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var ignoreId = Convert.ToUInt64(ignoreS);
            return HasIgnored(playerId, ignoreId);
        }

        private bool HasIgnored(ulong playerId, ulong ignoreId)
        {
            return GetPlayerData(playerId).Ignores.Contains(ignoreId);
        }

        private bool AreIgnoredS(string playerS, string ignoreS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(ignoreS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var ignoreId = Convert.ToUInt64(ignoreS);
            return AreIgnored(playerId, ignoreId);
        }

        private bool AreIgnored(ulong playerId, ulong ignoreId)
        {
            return GetPlayerData(playerId).Ignores.Contains(ignoreId) && GetPlayerData(ignoreId).Ignores.Contains(playerId);
        }

        private bool IsIgnoredS(string playerS, string ignoreS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(ignoreS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var ignoreId = Convert.ToUInt64(ignoreS);
            return IsIgnored(playerId, ignoreId);
        }

        private bool IsIgnored(ulong playerId, ulong ignoreId)
        {
            return GetPlayerData(ignoreId).Ignores.Contains(playerId);
        }

        private string[] GetIgnoreListS(string playerS)
        {
            var playerId = Convert.ToUInt64(playerS);
            return GetIgnoreList(playerId);
        }

        private string[] GetIgnoreList(ulong playerId)
        {
            var playerData = GetPlayerData(playerId);
            var players = new List<string>();
            foreach (var friend in playerData.Ignores)
                players.Add(GetPlayerData(friend).Name);
            return players.ToArray();
        }

        private string[] IsIgnoredByS(string playerS)
        {
            var playerId = Convert.ToUInt64(playerS);
            var ignores = IsIgnoredBy(playerId);
            return ignores.ToList().ConvertAll(f => f.ToString()).ToArray();
        }

        private ulong[] IsIgnoredBy(ulong playerId)
        {
            HashSet<ulong> ignores;
            return ReverseData.TryGetValue(playerId, out ignores) ? ignores.ToArray() : new ulong[0];
        }

        private PlayerData GetPlayerData(ulong playerId)
        {
            var player = FindPlayer(playerId);
            PlayerData playerData;
            if (!IgnoreData.TryGetValue(playerId, out playerData))
                IgnoreData[playerId] = playerData = new PlayerData();
            if (player != null) playerData.Name = player.displayName;
            return playerData;
        }

        [ChatCommand("ignore")]
        private void cmdIgnore(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length <= 0 || args.Length == 1 && !args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                PrintMessage(player, "Syntax");
                return;
            }
            switch (args[0].ToLower())
            {
                case "list":
                    var ignoreList = GetIgnoreList(player.userID);
                    if (ignoreList.Length > 0)
                        PrintMessage(player, "List", $"{ignoreList.Length}/{configData.IgnoreLimit}", string.Join(", ", ignoreList));
                    else
                        PrintMessage(player, "NoIngored");
                    return;
                case "add":
                case "+":
                    var ignorePlayer = FindPlayer(args[1]);
                    if (ignorePlayer == null)
                    {
                        PrintMessage(player, "PlayerNotFound", args[1]);
                        return;
                    }
                    if (player == ignorePlayer)
                    {
                        PrintMessage(player, "CantAddSelf");
                        return;
                    }
                    var playerData = GetPlayerData(player.userID);
                    if (playerData.Ignores.Count >= configData.IgnoreLimit)
                    {
                        PrintMessage(player, "IgnorelistFull");
                        return;
                    }
                    if (playerData.Ignores.Contains(ignorePlayer.userID))
                    {
                        PrintMessage(player, "AlreadyOnList", ignorePlayer.displayName);
                        return;
                    }
                    AddIgnore(player.userID, ignorePlayer.userID);
                    PrintMessage(player, "IgnoreAdded", ignorePlayer.displayName);
                    return;
                case "remove":
                case "-":
                    var ignore = FindIgnore(args[1]);
                    if (ignore <= 0)
                    {
                        PrintMessage(player, "NotOnIgnorelist", args[1]);
                        return;
                    }
                    var removed = RemoveIgnore(player.userID, ignore);
                    PrintMessage(player, removed ? "IgnoreRemoved" : "NotOnIgnorelist", args[1]);
                    return;
            }
        }

        private void SendHelpText(BasePlayer player)
        {
            PrintMessage(player, "HelpText");
        }

        private void AddIgnoreReverse(ulong playerId, ulong ignoreId)
        {
            HashSet<ulong> ignoreS;
            if (!ReverseData.TryGetValue(ignoreId, out ignoreS))
                ReverseData[ignoreId] = ignoreS = new HashSet<ulong>();
            ignoreS.Add(playerId);
        }

        private void PrintMessage(BasePlayer player, string msgId, params object[] args)
        {
            PrintToChat(player, lang.GetMessage(msgId, this, player.UserIDString), args);
        }

        private ulong FindIgnore(string ignore)
        {
            if (string.IsNullOrEmpty(ignore)) return 0;
            foreach (var playerData in IgnoreData)
            {
                if (playerData.Key.ToString().Equals(ignore) || playerData.Value.Name.Contains(ignore, CompareOptions.OrdinalIgnoreCase))
                    return playerData.Key;
            }
            return 0;
        }

        private static BasePlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrIdOrIp)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrIdOrIp)
                    return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString == nameOrIdOrIp)
                    return sleepingPlayer;
                if (sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return sleepingPlayer;
            }
            return null;
        }

        private static BasePlayer FindPlayer(ulong id)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.userID == id)
                    return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.userID == id)
                    return sleepingPlayer;
            }
            return null;
        }
    }
}


// --- End of file: Ignore.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Rename.cs ---
// --- Original Local Path: Rename.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Rename", "Wulf/lukespragg", "0.3.0", ResourceId = 1184)]
    [Description("Allows players with permission to instantly rename other players or self")]

    class Rename : CovalencePlugin
    {
        #region Initialization

        StoredData storedData;
        const string permOthers = "rename.others";
        const string permSelf = "rename.self";

        bool persistent;
        bool preventAdmin;

        protected override void LoadDefaultConfig()
        {
            // Options
            Config["Persistent Renames (true/false)"] = persistent = GetConfig("Persistent Renames (true/false)", false);
            Config["Prevent Admin Renames (true/false)"] = preventAdmin = GetConfig("Prevent Admin Renames (true/false)", true);

            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
            LoadPersistentData();

            permission.RegisterPermission(permOthers, this);
            permission.RegisterPermission(permSelf, this);
        }

        #endregion

        #region Stored Data

        class StoredData
        {
            public readonly HashSet<PlayerInfo> Renames = new HashSet<PlayerInfo>();
        }

        class PlayerInfo
        {
            public string Id;
            public string Old;
            public string New;

            public PlayerInfo()
            {
            }

            public PlayerInfo(IPlayer player, string newName)
            {
                Id = player.Id;
                Old = player.Name;
                New = newName;
            }
        }

        void LoadPersistentData()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Title);
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Title, storedData);

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandUsageRename"] = "Usage: {0} <name or id> [new name] (new name only if renaming self)",
                ["CommandUsageReset"] = "Usage: {0} [name or id] (optional if resetting self)",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["PlayerIsAdmin"] = "{0} is admin and cannot be renamed",
                ["PlayerNameReset"] = "{0}'s name reset to {1}",
                ["PlayerNotFound"] = "{0} was not found",
                ["PlayerNotRenamed"] = "{0} is not renamed",
                ["PlayerRenamed"] = "{0} was renamed to {1}",
                ["YouWereRenamed"] = "You were renamed to {0}",
                ["YourNameReset"] = "Your name was reset to {0}"
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandUsageRename"] = "Utilisation : {0} <nom ou id> [nouveau nom] (nouveau nom uniquement si vous renommer)",
                ["CommandUsageReset"] = "Utilisation : {0} [nom ou id] (facultatif si la réinitialisation de soi)",
                ["NotAllowed"] = "Vous n’êtes pas autorisé à utiliser la commande « {0} »",
                ["PlayerIsAdmin"] = "Vous n’êtes pas autorisé à utiliser la commande « {0} »",
                ["PlayerNameReset"] = "Nom de {0} réinitialiser à {1}",
                ["PlayerNotFound"] = "{0} n’a pas été trouvée",
                ["PlayerNotRenamed"] = "{0} n’est pas renommé",
                ["PlayerRenamed"] = "A été renommé {0} {1}",
                ["YouWereRenamed"] = "Vous ont été renommées {0}",
                ["YourNameReset"] = "Votre nom a été réinitialisé à {0}"
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandUsageRename"] = "Verbrauch: {0} <Name oder Id> [neuer Name] (neuer Name nur, wenn Sie sich umbenennen)",
                ["CommandUsageReset"] = "Verwendung: {0} [Name oder Id] (optional, wenn selbst zurücksetzen)",
                ["NotAllowed"] = "Sie sind nicht berechtigt, verwenden Sie den Befehl '{0}'",
                ["PlayerIsAdmin"] = "{0} ist Admin und kann nicht umbenannt werden",
                ["PlayerNameReset"] = "{0} Namen auf {1} zurücksetzen",
                ["PlayerNotFound"] = "{0} wurde nicht gefunden",
                ["PlayerNotRenamed"] = "{0} wird nicht umbenannt",
                ["PlayerRenamed"] = "{0} wurde umbenannt in {1}",
                ["YouWereRenamed"] = "Sie wurden umbenannt in {0}",
                ["YourNameReset"] = "Ihr Name wurde auf {0} zurückgesetzt"
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandUsageRename"] = "Использование: {0} <имя или id> [новое название] (новое имя только в случае переименования самостоятельно)",
                ["CommandUsageReset"] = "Использование: {0} [имя или id] (необязательно, если сброс самоуправления)",
                ["NotAllowed"] = "Нельзя использовать команду «{0}»",
                ["PlayerIsAdmin"] = "{0} является администратором и не может быть переименован",
                ["PlayerNameReset"] = "{0} сброс {1} имя",
                ["PlayerNotFound"] = "{0} не найден",
                ["PlayerNotRenamed"] = "{0} не переименован",
                ["PlayerRenamed"] = "{0} был переименован в {1}",
                ["YouWereRenamed"] = "Вы были переименованы в {0}",
                ["YourNameReset"] = "Ваше имя было сброшено в {0}"
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandUsageRename"] = "Uso: {0} <nombre o id> [nuevo nombre] (nuevo nombre sólo si cambiar el nombre a sí mismo)",
                ["CommandUsageReset"] = "Uso: {0} [nombre o id] (opcional en caso de reajuste del uno mismo)",
                ["NotAllowed"] = "No se permite utilizar el comando '{0}'",
                ["PlayerIsAdmin"] = "{0} es admin y no se puede cambiar",
                ["PlayerNameReset"] = "Nombre de {0} a {1}",
                ["PlayerNotFound"] = "No se encontró {0}",
                ["PlayerNotRenamed"] = "{0} no se cambia el nombre",
                ["PlayerRenamed"] = "Fue retitulado {0} a {1}",
                ["YouWereRenamed"] = "Sie wurden umbenannt in {0}",
                ["YourNameReset"] = "Su nombre fue reajustado a {0}"
            }, this, "es");
        }

        #endregion

        #region Connections

        void OnUserConnected(IPlayer player)
        {
            var rename = storedData.Renames.FirstOrDefault(r => r.Id == player.Id);
            if (!persistent || rename == null) return;

            player.Rename(rename.New);
            Puts($"{rename.Old} was renamed to {rename.New}");
            player.Message(Lang("YouWereRenamed", player.Id, rename.New));

            var pos = player.Position();
            player.Teleport(pos.X, pos.Y, pos.Z);
        }

        #endregion

        #region Commands

        [Command("rename")]
        void RenameCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length >= 2 && !player.HasPermission(permOthers) || !player.HasPermission(permSelf))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            if (args.Length == 0 || args.Length == 1 && player.Id == "server_console")
            {
                player.Reply(Lang("CommandUsageRename", player.Id, command));
                return;
            }

            var target = args.Length >= 2 ? players.FindPlayer(args[0]) : player;
            if (target == null)
            {
                player.Reply(Lang("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }

            if (args.Length >= 2 && preventAdmin && target.IsAdmin)
            {
                player.Reply(Lang("PlayerIsAdmin", player.Id, target.Name.Sanitize()));
                return;
            }

            var newName = args.Length >= 2 ? args[1].Sanitize() : args[0].Sanitize();
            target.Message(Lang("YouWereRenamed", target.Id, newName.Sanitize()));
            if (!Equals(target, player)) player.Reply(Lang("PlayerRenamed", player.Id, target.Name.Sanitize(), newName.Sanitize()));

            if (persistent)
            {
                storedData.Renames.RemoveWhere(r => r.Id == target.Id);
                storedData.Renames.Add(new PlayerInfo(target, newName));
                SaveData();
            }

            target.Rename(newName);
        }

        [Command("resetname", "namereset")]
        void NameResetCommand(IPlayer player, string command, string[] args)
        {
            if (args.Length >= 1 && !player.HasPermission(permOthers) || !player.HasPermission(permSelf))
            {
                player.Reply(Lang("NotAllowed", player.Id, command));
                return;
            }

            if (args.Length == 0 && player.Id == "server_console")
            {
                player.Reply(Lang("CommandUsageReset", player.Id, command));
                return;
            }

            var target = args.Length >= 1 ? players.FindPlayer(args[0]) : player;
            if (target == null)
            {
                player.Reply(Lang("PlayerNotFound", player.Id, args[0].Sanitize()));
                return;
            }

            var rename = storedData.Renames.FirstOrDefault(r => r.Id == target.Id);
            if (rename == null)
            {
                player.Reply(Lang("PlayerNotRenamed", player.Id, args[0].Sanitize()));
                return;
            }

            target.Message(Lang("YourNameReset", target.Id, rename.Old.Sanitize()));
            if (!Equals(target, player)) player.Reply(Lang("PlayerNameReset", player.Id, target.Name.Sanitize(), rename.Old.Sanitize()));

            if (target.IsConnected) target.Rename(rename.Old);
            storedData.Renames.Remove(rename);
            SaveData();
        }
        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion
    }
}

// --- End of file: Rename.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Distance.cs ---
// --- Original Local Path: Distance.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using System.Text.RegularExpressions;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins
{
	[Info("Distance", "ignignokt84", "0.1.1", ResourceId = 1780)]
	class Distance : RustPlugin
	{
		/*
		
		Distance is a measurement plugin designed for zone layout.  Includes point-to-point measurement,
		rangefinder, and a history, and overlays measurement vectors and distances onto the screen for
		easy reference.
		
		TODO:
			intelligently order procedures
			improve rangefinder target identification
			live rangefinding mode
		
		*/
		
		// load default messages to Lang
		void LoadDefaultMessages()
		{
			var messages = new Dictionary<string, string>
			{
				{"ChatCommand", "distance"},
				{"VersionString", "Distance v. {0}"},
				{"DistanceHeader", "---- Distance ----"},
				{"HistoryHeader", "---- History ----"},
				{"UsageHeader", "---- Distance usage ----"},
				{"CmdUsageOrigin", "Set origin to current position"},
				{"CmdUsageGet", "Calculate distance to origin"},
				{"CmdUsageRf", "Calculate distance to target (rangefinder)"},
				{"CmdUsageHistory", "Show last " + histSize + " distances measured"},
				{"CmdUsageClear", "Clear origin, history, or all (both)"},
				{"InvalidParameter", "Invalid Parameter: {0}"},
				{"NoEntries", "No entries"},
				{"OriginSet", "Origin set to {0}"},
				{"OriginNotSet", "Cannot measure distance - origin not set"},
				{"NoTarget", "Unable to find a target"},
				{"ClearOrigin", "Origin cleared"},
				{"ClearHistory", "History cleared"}
			};
			lang.RegisterMessages(messages, this);
        }
		
		private FieldInfo serverinput;
		// TODO - create custom class for player-specific origin/history
		// origin (reference point for distance)
		private Dictionary<BasePlayer,Vector3> origin = new Dictionary<BasePlayer,Vector3>();
		// TODO - expand history data, allow deletion of individual elements
		// history - an array of Vector3[] (both points) paired with the distance result
		private Dictionary<BasePlayer,KeyValuePair<Vector3[],float>[]> history = new Dictionary<BasePlayer,KeyValuePair<Vector3[],float>[]>();
		// enum of valid arg[0] arguments
		public enum FirstArgs { origin, get, rf, history, clear, version };
		// enum of valid arg[1] arguments (clear parameters)
		public enum ClearArgs { origin, history, all };
		// adjustment for eye height for raytrace
		private Vector3 eyesAdjust = new Vector3(0f, 1.6f, 0f);
		// history size
		public const int histSize = 5;
		// TODO add more colors to color table to accommodate larger history sizes
		// history color table - string value paired with Color value
		public KeyValuePair<string,Color>[] histColors = new KeyValuePair<string,Color>[histSize]
			{new KeyValuePair<string,Color>("cyan", Color.cyan),
			 new KeyValuePair<string,Color>("magenta", Color.magenta),
			 new KeyValuePair<string,Color>("green", Color.green),
			 new KeyValuePair<string,Color>("red", Color.red),
			 new KeyValuePair<string,Color>("yellow", Color.yellow)};
		
		// usage information string with formatting
		public string usageString;

		void Loaded()
		{
			LoadDefaultMessages();
			string chatCommand = GetMessage("ChatCommand");
            cmd.AddChatCommand(chatCommand, this, "cmdChatDelegator");
			serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
			
			// build usage string
			usageString = wrapSize(14, wrapColor("orange", GetMessage("UsageHeader"))) + "\n" +
						  wrapSize(12, wrapColor("cyan", "/" + chatCommand + " origin") + " - " + GetMessage("CmdUsageOrigin") + "\n" +
									   wrapColor("cyan", "/" + chatCommand + " get") + " - " + GetMessage("CmdUsageGet") + "\n" +
									   wrapColor("cyan", "/" + chatCommand + " rf") + " - " + GetMessage("CmdUsageRf") + "\n" +
									   wrapColor("cyan", "/" + chatCommand + " history") + " - " + GetMessage("CmdUsageHistory") + "\n" +
									   wrapColor("cyan", "/" + chatCommand + " clear [origin|history|all]") + " - " + GetMessage("CmdUsageClear"));
		}
        
        // get message from Lang
        string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);
		
		// main delegator process - handles all commands
		void cmdChatDelegator(BasePlayer player, string command, string[] args)
		{
			if(args.Length == 1)
			{
				if(!Enum.IsDefined(typeof(FirstArgs), args[0]))
				{
					notifyInvalidParameter(player, args[0]);
				}
				else
				{
					switch((FirstArgs) Enum.Parse(typeof(FirstArgs), args[0]))
					{
						case FirstArgs.origin:
							setOrigin(player);
							return;
						case FirstArgs.rf:
							rangefinder(player);
							return;
						case FirstArgs.get:
							measure(player);
							return;
						case FirstArgs.history:
							showHistory(player);
							return;
						case FirstArgs.version:
							sendMessage(player, wrapSize(14, wrapColor("orange", String.Format(GetMessage("VersionString"), this.Version.ToString()))));
							return;
					}
				}
			}
			else if(args.Length == 2)
			{
				if(args[0] != "clear")
				{
					notifyInvalidParameter(player, args[0]);
				}
				else
				{
					if(!Enum.IsDefined(typeof(ClearArgs), args[1]))
					{
						notifyInvalidParameter(player, args[1]);
					}
					else
					{
						switch((ClearArgs) Enum.Parse(typeof(ClearArgs), args[1]))
						{
							case ClearArgs.origin:
								sendMessage(player, clearOrigin(player));
								return;
							case ClearArgs.history:
								sendMessage(player, clearHistory(player));
								return;
							case ClearArgs.all:
								sendMessage(player, clearOrigin(player) + "\n" + clearHistory(player));
								return;
						}
					}
				}
			}
			
			showUsage(player);
		}
		
		// send message indicating invalid parameter or command
		void notifyInvalidParameter(BasePlayer player, string message)
		{
			sendMessage(player, wrapSize(14, wrapColor("red", String.Format(GetMessage("InvalidParameter"), message))));
		}
		
		// send message containing distance measured
		void notifyDistance(BasePlayer player, string message)
		{
			sendMessage(player, wrapSize(14, wrapColor("orange", GetMessage("DistanceHeader"))) + "\n" + wrapSize(12, message));
		}
		
		// send message containing history
		void notifyHistory(BasePlayer player, string message)
		{
			sendMessage(player, wrapSize(14, wrapColor("orange", GetMessage("HistoryHeader"))) + wrapSize(12, message));
		}
		
		// show usage information
		void showUsage(BasePlayer player)
		{
			sendMessage(player, usageString);
		}
		
		// set origin to the player's position + 1.0y
		void setOrigin(BasePlayer player)
		{
			var input = serverinput.GetValue(player) as InputState;
			Vector3 pos = player.transform.position + new Vector3(0,1f,0);
			origin[player] = pos;
			sendMessage(player, wrapSize(12, wrapColor("cyan", String.Format(GetMessage("OriginSet"), pos.ToString()))));
		}
		
		// measure distance from player's current position to origin
		void measure(BasePlayer player)
		{
			Vector3 o = Vector3.zero;
			if(!origin.TryGetValue(player, out o))
			{
				// origin not set
				sendMessage(player, wrapSize(12, wrapColor("red", GetMessage("OriginNotSet"))));
				showUsage(player);
				return;
			}
			else
			{
				// get player position + 1.0y
				var input = serverinput.GetValue(player) as InputState;
				Vector3 playerPosition = player.transform.position + new Vector3(0,1f,0);
				// calculate distance
				float distance = Vector3.Distance(o, playerPosition);
				// save position distance information
				addToHistory(player, o, playerPosition, distance);
				// draw line/text and send distance information to player
				string value = wrapColor("cyan", distance.ToString("0.000"));
				draw(player, o, playerPosition, Color.white, 10f, wrapSize(16, value));
				notifyDistance(player, value);
			}
		}
		
		// rangefinder - raycast from eyes to object player is looking at
		void rangefinder(BasePlayer player)
		{
			// get player position + 1.6y as eye-level
			var input = serverinput.GetValue(player) as InputState;
			Vector3 playerEyes = player.transform.position + eyesAdjust;
			var direction = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
			// raycast in the direction the player is looking
			var hits = UnityEngine.Physics.RaycastAll(playerEyes, direction);
			float closest = 100000f;
			Vector3 target = Vector3.zero;
			Collider collider = null;
			// find the closest hit
			foreach (var hit in hits)
			{
				string name = hit.collider.gameObject.name;
				if(hit.collider.gameObject.layer == 18) // skip Triggers layer
					continue;
				// ignore zones, meshes, and landmark nobuild hits
				if (name.StartsWith("Zone Manager") ||
					name == "prevent_building" ||
					name == "preventBuilding" ||
					name == "Mesh")
					continue;
				
				if (hit.distance < closest)
				{
					closest = hit.distance;
					target = hit.point;
					collider = hit.collider;
				}
			}
			// no target found
			if(target == Vector3.zero)
			{
				sendMessage(player, wrapSize(12, wrapColor("red", GetMessage("NoTarget"))));
				return;
			}
			else
			{
				// target found, calculate distance
				float distance = Vector3.Distance(playerEyes, target);
				// save position distance information
				addToHistory(player, playerEyes, target, distance);
				// draw line/text and send distance information to player
				string targetname = getHitObjectName(collider);
				string value = wrapColor("cyan", targetname + ": " + distance.ToString("0.000"));
				draw(player, playerEyes, target, Color.white, 10f, wrapSize(16, value));
				notifyDistance(player, value);
			}
		}
		
		// determines what name to display to the player based on the object type/layer
		string getHitObjectName(Collider collider)
		{
			GameObject gameObject = collider.gameObject;
			string output = prettify(gameObject.name);
			
			// debugging printouts
			//Puts("name: " + output);
			//Puts("layer: " + gameObject.layer);
			
			//for(int i = 0; i < 32; i++) { // get layer names
			//	Puts("layer[" + i + "] = " + LayerMask.LayerToName(i));
			//}
			
			//foreach(Component component in gameObject.GetComponents(typeof(Component)))
			//{
			//	Puts("component: " + component.name);
			//}
			
			switch(gameObject.layer)
			{
				case 21:
					// deployable
					if(output != "Mesh Collider Batch")
						return output;
					return LayerMask.LayerToName(gameObject.layer);
				case 4:
					// terrain
					return LayerMask.LayerToName(gameObject.layer);
				case 15:
					// water
					return LayerMask.LayerToName(gameObject.layer);
				case 23:
					// construction
					return LayerMask.LayerToName(gameObject.layer);
				case 8:
					// debris
					return fixName(output);
				case 26:
					// prefabs?
					return fixName(gameObject.name);
			}
			
			return output;
		}
		
		// fixes worldmodel object naming
		string fixName(string str)
		{
			str = Regex.Replace(str.Replace("worldmodel(Clone)",""),"[\\._-]"," ");
			return properCase(str);
		}
		
		// fixes messy names (like prefab paths)
		string prettify(string str)
		{
			str = Regex.Replace(str.Split('/').Last().ToLower().Replace(".prefab",""),"[0-9\\(\\)]","").Replace('_',' ').Replace('-',' ');
			
			return properCase(str).Trim(' ');
		}
		
		// convert string to proper case
		string properCase(string str)
		{
			char[] newChars = new char[str.Length];
			char last = ' ';
			for(int i=0; i<str.Length; i++)
			{
				if(last == ' ')
					if(i == str.Length-1)
						newChars[i] = ' ';
					else
						newChars[i] = Char.ToUpper(str[i]);
				else
					newChars[i] = str[i];
				last = newChars[i];
			}
			return new String(newChars);
		}
		
		// clear origin setting
		string clearOrigin(BasePlayer player)
		{
			origin.Remove(player);
			return wrapSize(12, wrapColor("green", GetMessage("ClearOrigin")));
		}
		
		// clear history
		string clearHistory(BasePlayer player)
		{
			history.Remove(player);
			return wrapSize(12, wrapColor("green", GetMessage("ClearHistory")));
		}
		
		// add distance information to history array
		private void addToHistory(BasePlayer player, Vector3 p1, Vector3 p2, float distance)
		{
			KeyValuePair<Vector3[],float>[] hist;
			// initialize history if null
			if(!history.TryGetValue(player, out hist))
				hist = new KeyValuePair<Vector3[], float>[histSize];
			// shift history entries
			int i;
			for(i=hist.Length-1; i>0; i--)
			{
				hist[i] = hist[i-1];
			}
			// insert new distance information entry at index 0 of history
			hist[0] = new KeyValuePair<Vector3[],float>(new Vector3[] {p1, p2}, distance);
			history[player] = hist;
		}
		
		// display history information
		void showHistory(BasePlayer player)
		{
			bool histExists = false;
			string output = "";
			
			KeyValuePair<Vector3[],float>[] hist;
			if(!history.TryGetValue(player, out hist))
			{
				// history array is empty
				output = "\n" + wrapColor("red", GetMessage("NoEntries"));
				notifyHistory(player, output);
				return;
			}
			// loop through history array, draw lines and distances, and add values to output string
			for(int i=0; i<hist.Length; i++)
			{
				if(hist[i].Value > 0)
				{
					string value = hist[i].Value.ToString("0.000");
					output += "\n" + wrapColor(histColors[i].Key, (i+1) + ": " + value);
					draw(player, hist[i].Key[0], hist[i].Key[1], histColors[i].Value, 10f, wrapSize(16, wrapColor(histColors[i].Key,value)));
					histExists = true;
				}
			}
			// no entries
			if(!histExists)
				output = "\n" + wrapColor("red", GetMessage("NoEntries"));
			// send output string to player
			notifyHistory(player, output);
		}
		
		//  wrapper to send message to user (placeholder in case additional handling is needed)
		void sendMessage(BasePlayer player, string message)
		{
			SendReply(player, message);
		}
		
		// wrap a string in a <size> tag with the passed size
		static string wrapSize(int size, string input)
		{
			if(input == null || input == "")
				return input;
			return "<size=" + size + ">" + input + "</size>";
		}
		
		// wrap a string in a <color> tag with the passed color
		static string wrapColor(string color, string input)
		{
			if(input == null || input == "" || color == null || color == "")
				return input;
			return "<color=" + color + ">" + input + "</color>";
		}
		
		// draw a line on the screen between two points, delegate to drawText if text is passed
		static void draw(BasePlayer player, Vector3 from, Vector3 to, Color color, float duration, string text)
		{
			player.SendConsoleCommand("ddraw.line", duration, color, from, to);
			// if text string is not null or empty, calculate text position as midpoint of line + 0.1y (to place text above line)
			if(text != null && text != "")
			{
				Vector3 textPosition = ((from + to)/2f); // midpoint of line
				textPosition = textPosition + new Vector3(0,0.1f,0); // shift text 0.1y
				drawText(player, textPosition, color, duration, text);
			}
		}
		
		// draw text on the screen at the specified position
		static void drawText(BasePlayer player, Vector3 position, Color color, float duration, string text)
		{
			player.SendConsoleCommand("ddraw.text", duration, color, position, text);
		}
		
		object OnReject(Network.Connection conn, string reason)
		{
			return false;
		}
	}
}

// --- End of file: Distance.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MathQuiz.cs ---
// --- Original Local Path: MathQuiz.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("MathQuiz", "FREDWAY", "1.0.1")]
    [Description("Mathematical quiz with rewards")]

    class MathQuiz : CovalencePlugin
    {
        private bool QuizInProgress = false;
        private string Task = "";
        private string Answer = "";
        private string Winner = "";
        private string Reward = "";
        private Timer Reminder;

        #region Config Setip
        private string Prefix = "[MathQuiz]";
        private string PrefixColor = "#42dff4";
        private string SteamIDIcon = "";
        //private Dictionary<string, int> Rewards = new Dictionary<string, int>();
        private Dictionary<ItemDefinition, int> Rewards = new Dictionary<ItemDefinition, int>();
        private Dictionary<int, string> Tasks = new Dictionary<int, string>()
        {
            [0] = "{X} * {Y} + {Z}",
            [1] = "{X} * ({Y} - {Z})",
            [2] = "{X} * ({Y} + {Z})",
            [3] = "{X} + {Y} * {Z}",
        };
        private float QuizFreq = 300f;

        private class ConfigLocalization
        {
            public string Prefix { get; set; }
            public string PrefixColor { get; set; }
            public string SteamIDIcon { get; set; }
            public string Rewards { get; set; }
            public string Tasks { get; set; }
            public string QuizFreq { get; set; }
        }
        private static ConfigLocalization ConfigRus = new ConfigLocalization
        {
            Prefix = "Префикс в чате",
            PrefixColor = "Цвет префикса в чате",
            SteamIDIcon = "Steam ID сообщений в чате",
            Rewards = "Возможные награды",
            Tasks = "Варианты задач",
            QuizFreq = "Частота викторин(в секундах)"
        };
        private static ConfigLocalization ConfigEn = new ConfigLocalization
        {
            Prefix = "Chat Prefix",
            PrefixColor = "Color of the Chat Prefix",
            SteamIDIcon = "Plugin Icon SteamID",
            Rewards = "Possible rewards",
            Tasks = "Tasks",
            QuizFreq = "Frequency of the Quiz(in seconds)"

        };
        #endregion
        
        #region Loading config
        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        private new void LoadConfig()
        {
            Dictionary<string, object> rewards = new Dictionary<string, object>()
            {
                ["ammo.pistol"] = 100,
                ["ammo.pistol.fire"] = 50,
                ["ammo.pistol.hv"] = 50,
                ["ammo.rifle"] = 100,
                ["ammo.rifle.explosive"] = 50,
                ["ammo.rifle.hv"] = 50,
                ["ammo.rifle.incendiary"] = 50,
                ["rifle.ak"] = 1,
                ["smg.2"] = 1,
                ["smg.thompson"] = 1
            };
            GetConfig(ConfigRus.Prefix, ref Prefix);
            GetConfig(ConfigRus.PrefixColor, ref PrefixColor);
            GetConfig(ConfigRus.SteamIDIcon, ref SteamIDIcon);
            GetConfig(ConfigRus.QuizFreq, ref QuizFreq);
            GetConfig(ConfigRus.Rewards, ref rewards);
            SaveConfig();

            foreach(var item in rewards)
            {
                int count;
                bool done = false;
                if(!int.TryParse(item.Value.ToString(), out count))
                {
                    PrintWarning($"Error while adding item \"{item.Key}\" to the rewards list. Check it's value, must be integer.");
                    continue;
                }
                var itemdefs = ItemManager.GetItemDefinitions();
                foreach(var def in itemdefs)
                {
                    if(def.shortname == item.Key)
                    {
                        Rewards.Add(def, count);
                        done = true;
                        break;
                    }
                    if(def.itemid.ToString() == item.Key)
                    {
                        Rewards.Add(def, count);
                        done = true;
                        break;
                    }
                    if(def.displayName.english == item.Key)
                    {
                        Rewards.Add(def, count);
                        done = true;
                        break;
                    }
                }
                if (!done)
                {
                    PrintWarning($"Error while adding item \"{item.Key}\" to the rewards list. Item not found. Check your config.");
                    continue;
                }
            }

        }
        #endregion

        #region Localization
        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Quiz started"] = "The Math Quiz has began! Todays task is {0}\nThe first player who would type the right anwer to the chat will be rewarded!",
                ["Quiz ended"] = "The Quiz has ended. The winner is {0}! His rewards is {1} X{2}"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Quiz started"] = "Математическая виктроина началась! Задание на сегодня: {0}\nПервый игрок, написавий верный ответ в чат получит награду!",
                ["Quiz ended"] = "Викторина окончена. Победитель {0}! В качестве награды он получает {1}"
            }, this,"ru");
        }
        #endregion

        #region Initialization
        void Loaded()
        {
            LoadConfig();
            LoadMessages();
        }
        private void OnServerInitialized()
        {
            timer.Once(QuizFreq, () => { StartQuiz(); });
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!QuizInProgress) return;
            QuizInformToChat(true);
        }
        #endregion

        #region Quiz
        private void StartQuiz()
        {
            QuizInProgress = true;

            int num = Core.Random.Range(0, 4);
            Task = Tasks[num];
            int X = Core.Random.Range(2, 15);
            int Y = Core.Random.Range(2, 15);
            int Z = Core.Random.Range(2, 15);
            Task = Task.Replace("{X}", X.ToString()).Replace("{Y}", Y.ToString()).Replace("{Z}", Z.ToString());
            Answer = GetAnswer(X, Y, Z, num);
            if (Answer == "")
            {
                PrintWarning($"Something goes wrong! Please contact the developer. And give him this info:\nNum = {num}; X = {X}; Y = {Y}; Z = {Z}");
                StartQuiz();
            }
            QuizInformToChat(true);
            Log($"The quiz has begun! Task: {Task}. Correct answer: {Answer}");
            Reminder = timer.Repeat(120f, 0, () => { QuizInformToChat(true); });

        }
        private string GetAnswer(int X, int Y, int Z, int num)
        {
            switch (num)
            {
                case 0:
                    return $"{X * Y + Z}";
                case 1:
                    return $"{X * (Y - Z)}";
                case 2:
                    return $"{X * (Y + Z)}";
                case 3:
                    return $"{X + Y * Z}";
                default:
                    return "";
            }
        }
        private void EndQuiz(IPlayer winner)
        {
            if (Reminder != null && !Reminder.Destroyed) Reminder.Destroy();
            QuizInProgress = false;
            Winner = winner.Name;
            var reward = Rewards.ElementAt(Core.Random.Range(0, Rewards.Count));
            BasePlayer player = BasePlayer.FindByID(ulong.Parse(winner.Id));
            Reward = $"{reward.Key.displayName.english} x{reward.Value}";
            player.GiveItem(ItemManager.Create(reward.Key, reward.Value), BaseEntity.GiveItemReason.PickedUp);
            QuizInformToChat(false);
            timer.Once(QuizFreq, () => { StartQuiz(); });
            Log($"The quiz is over. Winner is {Winner} and he got {Reward}");

        }
        #endregion

        #region OnUserChat
        void OnUserChat(IPlayer player, string message)
        {
            if (!QuizInProgress) return;
            if (message.Contains(Answer))
            {
                EndQuiz(player);
            }
        }
        #endregion

        #region Helpers
        private void GetConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null)
            {
                var = (T)Convert.ChangeType(Config[Key], typeof(T));
            }
            Config[Key] = var;
        }
        private void QuizInformToChat(bool start)
        {
            foreach(IPlayer player in players.Connected)
            {
                string Message;
                if (start)
                {
                    Message = GetMsg("Quiz started", player.Id);
                    Message = string.Format(Message, Task);
                }else
                {
                    Message = GetMsg("Quiz ended", player.Id);
                    Message = string.Format(Message, Winner, Reward);
                }
                player.Command("chat.add", new object[] { SteamIDIcon, "<color=" + PrefixColor + ">" + Prefix + "</color> " + Message });
            }
        }
        
        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());
        #endregion
    }
}

// --- End of file: MathQuiz.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagicHammer.cs ---
// --- Original Local Path: MagicHammer.cs ---

using System;
using System.Collections.Generic;
using Rust;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("MagicHammer", "Norn", 0.4, ResourceId = 1375)]
    [Description("Hit stuff with the hammer and do things.")]
    public class MagicHammer : RustPlugin
    {
        int MODE_REPAIR = 1;
        int MODE_DESTROY = 2;
        int MAX_MODES = 2;
        [PluginReference]
        Plugin PopupNotifications;
        class StoredData
        {
            public Dictionary<ulong, MagicHammerInfo> Users = new Dictionary<ulong, MagicHammerInfo>();
            public StoredData()
            {
            }
        }

        class MagicHammerInfo
        {
            public ulong UserId;
            public int Mode;
            public bool Enabled;
            public bool Messages_Enabled;
            public MagicHammerInfo()
            {
            }
        }

        StoredData hammerUserData;
        static FieldInfo buildingPriv;
        void Loaded()
        {
            if (!permission.PermissionExists("can.mh")) permission.RegisterPermission("can.mh", this);
            hammerUserData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title + "_users");
            buildingPriv = typeof(BasePlayer).GetField("buildingPrivlidges", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }
        void OnPlayerInit(BasePlayer player)
        {
            InitPlayerData(player);
        }
        bool InitPlayerData(BasePlayer player)
        {
            if(CanMagicHammer(player))
            {
                MagicHammerInfo p = null;
                if (hammerUserData.Users.TryGetValue(player.userID, out p) == false)
                {
                    var info = new MagicHammerInfo();
                    info.Enabled = false;
                    info.Mode = MODE_REPAIR; //Repair
                    info.UserId = player.userID;
                    info.Messages_Enabled = true;
                    hammerUserData.Users.Add(player.userID, info);
                    Interface.GetMod().DataFileSystem.WriteObject(this.Title + "_users", hammerUserData);
                    Puts("Adding entry " + player.userID.ToString());
                }
            }
            else
            {
                MagicHammerInfo p = null;
                if (hammerUserData.Users.TryGetValue(player.userID, out p))
                {
                    Puts("Removing " + player.userID + " from magic hammer data, cleaning up...");
                    hammerUserData.Users.Remove(player.userID);
                }
            }
            return false;
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Updating configuration file...");
            Config.Clear();
            Config["iProtocol"] = Protocol.network;
            Config["bUsePopupNotifications"] = false;
            Config["bMessagesEnabled"] = true;
            Config["tMessageRepaired"] = "Entity: <color=#F2F5A9>{entity_name}</color> health <color=#2EFE64>updated</color> from <color=#FF4000>{current_hp}</color>/<color=#2EFE64>{new_hp}</color>.";
            Config["tMessageDestroyed"] = "Entity: <color=#F2F5A9>{entity_name}</color> <color=#FF4000>destroyed</color>.";
            Config["tMessageUsage"] = "/mh <enabled/mode>.";
            Config["tHammerEnabled"] = "Status: {hammer_status}.";
            Config["tHammerMode"] = "You have switched to: {hammer_mode} mode.";
            Config["tHammerModeText"] = "Choose your mode: 1 = <color=#2EFE64>repair</color>, 2 = <color=#FF4000>destroy</color>.";
            Config["tNoAccessCupboard"] = "You <color=#FF4000>don't</color> have access to all the tool cupboards around you.";
            Config["bDestroyCupboardCheck"] = true;
            SaveConfig();
        }
        bool CanMagicHammer(BasePlayer player)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "can.mh")) return true;
            return false;
        }
        private void PrintToChatEx(BasePlayer player, string result, string tcolour = "#F5A9F2")
        {
            if (Convert.ToBoolean(Config["bMessagesEnabled"]))
            {
                if (Convert.ToBoolean(Config["bUsePopupNotifications"]))
                {
                    PopupNotifications?.Call("CreatePopupNotification", "<color=" + tcolour + ">" + this.Title.ToString() + "</color>\n" + result, player);
                }
                else
                {
                    PrintToChat(player, "<color=\"" + tcolour + "\">[" + this.Title.ToString() + "]</color> " + result);
                }
            }
        }
        void Unload()
        {
            Puts("Saving hammer database...");
            SaveData();
        }
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title+"_users", hammerUserData);
        }
        int GetPlayerHammerMode(BasePlayer player)
        {
            MagicHammerInfo p = null;
            if (hammerUserData.Users.TryGetValue(player.userID, out p))
            {
                return p.Mode;
            }
            return -1;
        }
        bool SetPlayerHammerMode(BasePlayer player, int mode)
        {
            MagicHammerInfo p = null;
            if (hammerUserData.Users.TryGetValue(player.userID, out p))
            {
                p.Mode = mode;
                return true;
            }
            return false;
        }
        bool SetPlayerHammerStatus(BasePlayer player, bool enabled)
        {
            MagicHammerInfo p = null;
            if (hammerUserData.Users.TryGetValue(player.userID, out p))
            {
                p.Enabled = enabled;
                return true;
            }
            return false;
        }
        bool MagicHammerEnabled(BasePlayer player)
        {
            MagicHammerInfo p = null;
            if (hammerUserData.Users.TryGetValue(player.userID, out p))
            {
                return p.Enabled;
            }
            return false;
        }
        [ChatCommand("mh")]
        void cmdMH(BasePlayer player, string cmd, string[] args)
        {
            if (CanMagicHammer(player))
            {
                MagicHammerInfo p = null;
                if (hammerUserData.Users.TryGetValue(player.userID, out p) == false)
                {
                    InitPlayerData(player);
                }
                if (args.Length == 0 || args.Length > 2)
                {
                    PrintToChatEx(player, Config["tMessageUsage"].ToString());
                    if (player.net.connection.authLevel >= 1)
                    {
                        // Future Admin Cmds
                    }
                }
                else if (args[0] == "mode")
                {
                    if (args.Length == 1)
                    {
                        PrintToChatEx(player, Config["tHammerModeText"].ToString());
                    }
                    else if (args.Length == 2)
                    {
                        int mode = Convert.ToInt16(args[1]);
                        if (mode >= 1 && mode <= MAX_MODES)
                        {
                            string mode_text = "null";
                            if (mode == MODE_REPAIR)
                            {
                                mode_text = "<color=#2EFE64>repair</color>";
                            }
                            else if (mode == MODE_DESTROY)
                            {
                                mode_text = "<color=#FF4000>destroy</color>";
                            }
                            SetPlayerHammerMode(player, mode);
                            string parsed_config = Config["tHammerMode"].ToString();
                            parsed_config = parsed_config.Replace("{hammer_mode}", mode_text);
                            PrintToChatEx(player, parsed_config);
                        }
                        else
                        {
                            PrintToChatEx(player, "Valid modes: 1 - " + MAX_MODES.ToString() + "."); // Invalid Mode
                        }
                    }
                }
                else if (args[0] == "enabled")
                {
                    if (MagicHammerEnabled(player))
                    {
                        string parsed_config = Config["tHammerEnabled"].ToString();
                        parsed_config = parsed_config.Replace("{hammer_status}", "<color=#FF4000>disabled</color>");
                        PrintToChatEx(player, parsed_config);
                        SetPlayerHammerStatus(player, false);
                    }
                    else
                    {
                        string parsed_config = Config["tHammerEnabled"].ToString();
                        parsed_config = parsed_config.Replace("{hammer_status}", "<color=#2EFE64>enabled</color>");
                        PrintToChatEx(player, parsed_config);
                        SetPlayerHammerStatus(player, true);
                    }
                }
            }
        }
        void OnStructureRepairEx(BuildingBlock block, BasePlayer player)
        {
            if (CanMagicHammer(player) && MagicHammerEnabled(player))
            {
                int mode = GetPlayerHammerMode(player);
                if(mode != -1)
                {
                    string block_shortname = block.blockDefinition.hierachyName.ToString();
                    string block_displayname = block.blockDefinition.info.name.english.ToString();
                    float max_health = block.MaxHealth(); float current_health = block.Health();
                    if (mode == MODE_REPAIR)
                    {
                        if (current_health != max_health)
                        {
                            block.health = block.MaxHealth(); float new_hp = block.Health();
                            if (current_health != new_hp)
                            {
                                string parsed_config = Config["tMessageRepaired"].ToString();
                                parsed_config = parsed_config.Replace("{current_hp}", current_health.ToString());
                                parsed_config = parsed_config.Replace("{new_hp}", new_hp.ToString());
                                if (block_displayname.Length == 0)
                                {
                                    parsed_config = parsed_config.Replace("{entity_name}", block_shortname);
                                }
                                else
                                {
                                    parsed_config = parsed_config.Replace("{entity_name}", block_displayname);
                                }
                                PrintToChatEx(player, parsed_config);
                            }
                        }
                    }
                    else if (mode == MODE_DESTROY)
                    {
                        if (Convert.ToBoolean(Config["bDestroyCupboardCheck"]))
                        {
                            if (hasTotalAccess(player))
                            {
                                string parsed_config = Config["tMessageDestroyed"].ToString();
                                if (block_displayname.Length == 0)
                                {
                                    parsed_config = parsed_config.Replace("{entity_name}", block_shortname);
                                }
                                else
                                {
                                    parsed_config = parsed_config.Replace("{entity_name}", block_displayname);
                                }
                                PrintToChatEx(player, parsed_config);
                                RemoveEntity(block);
                            }
                            else
                            {
                                PrintToChatEx(player, Config["tNoAccessCupboard"].ToString());
                            }
                        }
                        else
                        {
                            string parsed_config = Config["tMessageDestroyed"].ToString();
                            if (block_displayname.Length == 0)
                            {
                                parsed_config = parsed_config.Replace("{entity_name}", block_shortname);
                            }
                            else
                            {
                                parsed_config = parsed_config.Replace("{entity_name}", block_displayname);
                            }
                            PrintToChatEx(player, parsed_config);
                            RemoveEntity(block);
                        }
                    }
                }
            }
        }
        static void RemoveEntity(BaseEntity entity)
        {
            if (entity == null) return;
            entity.KillMessage();
        }
        static bool hasTotalAccess(BasePlayer player) // Thanks Reneb
        {
            List<BuildingPrivlidge> playerpriv = buildingPriv.GetValue(player) as List<BuildingPrivlidge>;
            if (playerpriv.Count == 0)
            {
                return false;
            }
            foreach (BuildingPrivlidge priv in playerpriv.ToArray())
            {
                List<ProtoBuf.PlayerNameID> authorized = priv.authorizedPlayers;
                bool foundplayer = false;
                foreach (ProtoBuf.PlayerNameID pni in authorized.ToArray())
                {
                    if (pni.userid == player.userID)
                        foundplayer = true;
                }
                if (!foundplayer)
                {
                    return false;
                }
            }
            return true;
        }
        private void OnServerInitialized()
        {
            if (Config["tNoAccessCupboard"] == null) { Puts("Resetting configuration file (out of date)..."); LoadDefaultConfig(); }
        }
        void OnStructureRepair(BuildingBlock block, BasePlayer player)
        {
            OnStructureRepairEx(block, player);
        }
    }
}

// --- End of file: MagicHammer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HackCrateSettings.cs ---
// --- Original Local Path: HackCrateSettings.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
 using UnityEngine;

 namespace Oxide.Plugins
{
    [Info("HackCrateSettings", "CRACED", "1.0.2")]
    public class HackCrateSettings : RustPlugin
    {
        #region cfg
        private ConfigData cfg { get; set; }

        private class ConfigData
        {
            
            [JsonProperty("Время открытия ящика в сек(900 стандарт)")] public Dictionary<string, float> HackTimeList = new Dictionary<string, float>();
            
            [JsonProperty("Лутать ящик может только тот кто начал взлом?")]
            public bool hackOwner = false;
            
            [JsonProperty("Если включен параметр выше. Друзья могут лутать?(Только SoFriends)")]
            public bool friendsLoot = false;
            [JsonProperty("Если включен параметр выше. Люди из зеленой команды могут лутать?")]
            public bool teamLoot = false;
            public static ConfigData GetNewConf() 
            {
                var newConfig = new ConfigData();
                newConfig.HackTimeList = new Dictionary<string, float>()
                {
                    ["hackcratesettings.default"] = 180,
                    ["hackcratesettings.vip"] = 120,
                    ["hackcratesettings.prem"] = 60,
                };
                return newConfig; 
            }
        } 

        protected override void LoadDefaultConfig() => cfg = ConfigData.GetNewConf();
        protected override void SaveConfig() => Config.WriteObject(cfg);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        void OnEntityKill(HackableLockedCrate entity)
        {
            if (hackList.ContainsKey(entity.net.ID.Value))
                hackList.Remove(entity.net.ID.Value);
        }
        #endregion
        Dictionary<ulong, ulong> hackList = new Dictionary<ulong, ulong>();
        object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (player == null || crate == null) return null;
            crate.hackSeconds = 900 - GetTime(player.userID);
            if(cfg.hackOwner) if(!hackList.ContainsKey(crate.net.ID.Value)) hackList.Add(crate.net.ID.Value, player.userID);
            return null;
        }  
        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (player == null || container == null) return null;
            if (!cfg.hackOwner) return null;
            ulong ownerId;
            if (container.GetEntity() == null) return null;
            if (!hackList.TryGetValue(container.GetEntity().net.ID.Value, out ownerId)) return null;
            var owner = BasePlayer.FindByID(ownerId);
            if(owner == null || !owner.IsConnected)
            {
                hackList.Remove(container.GetEntity().net.ID.Value);
                return null;
            }
            if (cfg.friendsLoot && IsFriends(owner.userID, player.userID)) return null;
            if (cfg.teamLoot && owner.Team != null && owner.Team.members.Contains(player.userID)) return null;
            if (owner.userID != player.userID)
            {
                SendReply(player, "Вы не можете залутать данный ящик!");
                return false;
            }
            return null;
        }
        private float GetTime(ulong uid)
        {
            float min = 900;
            foreach (var privilege in cfg.HackTimeList) if (permission.UserHasPermission(uid.ToString(), privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        private void OnServerInitialized()
        {
            foreach (var perm in cfg.HackTimeList)
            {
                if(!permission.PermissionExists(perm.Key)) permission.RegisterPermission(perm.Key, this);
            }
        }

        [PluginReference] public Plugin SoFriends;
        private bool IsFriends(ulong owner, ulong player)
        {
            if (SoFriends)
                return (bool) SoFriends.CallHook("IsFriend", player, owner);
            return false;
        }
    }
}

// --- End of file: HackCrateSettings.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ExplosiveWeapons.cs ---
// --- Original Local Path: ExplosiveWeapons.cs ---

﻿using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using ConVar;
using System.IO;
using System.Text;
using Network;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("ExplosiveWeapons", "Cameron", "1.0.8")]
    [Description("Custom rocket launchers and weapon to make sutff go boom boom, flash flash and owow")]
    public class ExplosiveWeapons : CovalencePlugin
    {
        int bigRocketCount = 20;
        int littleRocketCount = 12;

        bool jerichoBlowUp = true;
        bool heatSeekerBlowUp = false;
        bool followBlowUp = false;
        bool javalinBlowUp = false;


        int xSize = 100;
        int ySize = 1;
        int maxRange = 250;

        int scatterSize = 3;

        float flashDuration = 4.0f;

        ulong jericoSkin = 2656578790;
        ulong seekerSkin = 2657299588;
        ulong trackSkin = 2657312965;
        ulong javalin = 2657315108;
        ulong multiGrenadeSkin = 2657418159;
        ulong molatoveGrenade = 2657408625;
        ulong flashBangSkin = 2657412999;
        ulong healingSkin = 2657414983;
        ulong impactNadeSkin = 2657418820;
        ulong stunGrenadeSkin = 2657417547;

        int instaHealAmount = 15;
        int passiveHealAmount = 50;

        bool spawnFlares = true;
        int stunDuration = 4;

        HashSet<ulong> skins = new HashSet<ulong>();
        #region Config

        private void Init()
        {
            permission.RegisterPermission("explosiveweapons.notarget", this);

            bigRocketCount = int.Parse(Config["jerichoBigRocketCount"].ToString());
            littleRocketCount = int.Parse(Config["jerichoSmallRocketCount"].ToString());
            xSize = int.Parse(Config["jerichoXSize"].ToString());
            ySize = int.Parse(Config["jerichoYSize"].ToString());
            maxRange = int.Parse(Config["maxRangeForJerichoAndJavalin"].ToString());
            scatterSize = int.Parse(Config["scatterSize"].ToString());
            flashDuration = int.Parse(Config["flashDuration"].ToString());

            jerichoBlowUp = (bool)Config["jericoDestroyOnShoot"];
            heatSeekerBlowUp = (bool)Config["heatSeekerDestroyOnShoot"];
            followBlowUp = (bool)Config["followDestroyOnShoot"];
            javalinBlowUp = (bool)Config["javalinDestroyOnShoot"];

            instaHealAmount = int.Parse(Config["instaHealAmount"].ToString());
            passiveHealAmount = int.Parse(Config["passiveHealAmount"].ToString());

            stunDuration = int.Parse(Config["stunDuration"].ToString());
            //skins

            jericoSkin = ulong.Parse(Config["jericoSkin"].ToString());
            seekerSkin = ulong.Parse(Config["seekerSkin"].ToString());
            trackSkin = ulong.Parse(Config["heatSeekSkin"].ToString());
            javalin = ulong.Parse(Config["javalinSkin"].ToString());
            multiGrenadeSkin = ulong.Parse(Config["scatterNadeSkin"].ToString());
            molatoveGrenade = ulong.Parse(Config["molatoveSkin"].ToString());
            flashBangSkin = ulong.Parse(Config["flashBangSkin"].ToString());
            healingSkin = ulong.Parse(Config["healingSkin"].ToString());
            impactNadeSkin = ulong.Parse(Config["impactNadeSkin"].ToString());
            stunGrenadeSkin = ulong.Parse(Config["stunGrenadeSkin"].ToString());


            if (Config["SpawnFlares"] == null)
            {
                Config["SpawnFlares"] = true;
                SaveConfig();

            }

            
            spawnFlares = (bool)Config["SpawnFlares"];

            skins.Add(jericoSkin);
            skins.Add(seekerSkin);
            skins.Add(trackSkin);
            skins.Add(javalin);
            skins.Add(multiGrenadeSkin);
            skins.Add(molatoveGrenade);
            skins.Add(flashBangSkin);
            skins.Add(healingSkin);
            skins.Add(impactNadeSkin);
            skins.Add(stunGrenadeSkin);

        }


        protected override void LoadDefaultConfig()
        {
            Config["jerichoBigRocketCount"] = 20;
            Config["jerichoSmallRocketCount"] = 12;
            Config["jerichoXSize"] = 100;
            Config["jerichoYSize"] = 1;
            Config["maxRangeForJerichoAndJavalin"] = 250;
            Config["scatterSize"] = 3;
            Config["flashDuration"] = 4.0;

            Config["jericoDestroyOnShoot"] = true;
            Config["heatSeekerDestroyOnShoot"] = false;
            Config["followDestroyOnShoot"] = false;
            Config["javalinDestroyOnShoot"] = false;
            //skins
            Config["instaHealAmount"] = 15;
            Config["passiveHealAmount"] = 50;

            Config["stunDuration"] = 4;

            Config["jericoSkin"] = 2656578790;
            Config["seekerSkin"] = 2657299588;
            Config["heatSeekSkin"] = 2657312965;
            Config["javalinSkin"] = 2657315108;
            Config["scatterNadeSkin"] = 2657418159;
            Config["molatoveSkin"] = 2657408625;
            Config["flashBangSkin"] = 2657412999;
            Config["healingSkin"] = 2657414983;
            Config["impactNadeSkin"] = 2657418820;
            Config["stunGrenadeSkin"] = 2657417547;
        }

        #endregion



        #region Commands
        [Command("GiveJerico"),Permission("explosiveweapons.admin")]
        private void JericoGive(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("rocket.launcher", 1, jericoSkin),
                          player.inventory.containerBelt);
        }
        [Command("GiveSeeker"), Permission("explosiveweapons.admin")]
        private void GiveSeeker(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("rocket.launcher", 1, seekerSkin),
                          player.inventory.containerBelt);
        }
        [Command("GiveFollow"), Permission("explosiveweapons.admin")]
        private void GiveFollow(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("rocket.launcher", 1, trackSkin),
                          player.inventory.containerBelt);
        }
        [Command("GiveJav"), Permission("explosiveweapons.admin")]
        private void GiveJav(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("rocket.launcher", 1, javalin),
                          player.inventory.containerBelt);
        }
        [Command("givemulti"), Permission("explosiveweapons.admin")]
        private void givemulti(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, multiGrenadeSkin),
                          player.inventory.containerBelt);
        }
        [Command("givemoly"), Permission("explosiveweapons.admin")]
        private void GiveMolly(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("grenade.beancan", 1, molatoveGrenade),
                          player.inventory.containerBelt);
        }
        [Command("giveflash"), Permission("explosiveweapons.admin")]
        private void giveflash(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, flashBangSkin),
                          player.inventory.containerBelt);
        }
        [Command("giveimpact"), Permission("explosiveweapons.admin")]
        private void giveimpact(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, impactNadeSkin),
                          player.inventory.containerBelt);
        }
        [Command("givestun"), Permission("explosiveweapons.admin")]
        private void givestun(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, stunGrenadeSkin),
                          player.inventory.containerBelt);
        }
        [Command("giveshealing"), Permission("explosiveweapons.admin")]
        private void givehealing(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, healingSkin),
                          player.inventory.containerBelt);
        }
        [Command("giveall"), Permission("explosiveweapons.admin")]
        private void giveallnades(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, stunGrenadeSkin),
                           player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, impactNadeSkin),
                          player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, flashBangSkin),
                          player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("grenade.beancan", 1, molatoveGrenade),
                          player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, multiGrenadeSkin),
                          player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("rocket.launcher", 1, javalin),
                          player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("rocket.launcher", 1, trackSkin),
                          player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("rocket.launcher", 1, seekerSkin),
                          player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("rocket.launcher", 1, jericoSkin),
                         player.inventory.containerBelt);
            player.inventory.GiveItem(ItemManager.CreateByName("grenade.f1", 1, healingSkin),
                          player.inventory.containerBelt);
        }
        #endregion

        #region Hooks

        
        void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            HeldEntity item = player.GetHeldEntity();
            Item invItem = item.GetItem();

            if(invItem.skin == jericoSkin) // jerico
            {
                entity.Kill();
                PlayEffect("assets/bundled/prefabs/fx/invite_notice.prefab", player);
                Jerico(player.IPlayer);
                if(jerichoBlowUp)
                    invItem.Remove();
                return;
            }
            else if(invItem.skin == seekerSkin)
            {
                entity.Kill();
                Vector3 firingDir = player.GetNetworkRotation() * Vector3.forward;

                Collider[] colliders = UnityEngine.Physics.OverlapCapsule(player.transform.position, player.transform.position + (firingDir * 100), 30);

                foreach (Collider col in colliders)
                {
                    BaseEntity ent = col.ToBaseEntity();
                    
                    if (ent.IsValid())
                    {
                        
                        if (ent is BasePlayer && ent != player )
                        {
                            
                            BasePlayer target = ent as BasePlayer;
                            if (target.IPlayer.HasPermission("explosiveweapons.notarget"))
                            {
                                player.ChatMessage($"No Target Found!");
                                return;
                            }
                            player.ChatMessage($"Target aquired! {target.displayName}");
                           
                            TracerRocket(player.transform.position, player.GetNetworkRotation(), ent as BasePlayer,player);
                            
                            if(heatSeekerBlowUp)
                                invItem.Remove();
                            return;
                        }
                    }

                }
                player.ChatMessage($"No Target Found!");

            }
            else if(invItem.skin == trackSkin)
            {
                entity.Kill();
                CursorRocket(player.transform.position,player.GetNetworkRotation(),player);
                if(followBlowUp)
                    invItem.DoRemove();
            }
            else if(invItem.skin == javalin)
            {
                entity.Kill();
                JavalinRocket(player.IPlayer);
                if(javalinBlowUp)
                    invItem.DoRemove();
            }

            return;    
        }
        private object OnExplosiveFuseSet(TimedExplosive ent, float fuseLength)
        {
            if(ent.skinID == molatoveGrenade)
            {
                OnCollision col = ent.gameObject.AddComponent<OnCollision>();
                col.ent = ent;
            }
            else if(ent.skinID == flashBangSkin)
            {
                timer.Once(fuseLength - 0.05f, () =>
                {

                    List<BasePlayer> playersNear = FindAllPlayersNear(ent.transform.position, 10);

                    foreach (BasePlayer item in playersNear)
                    {
                        if (item == null || item.gestureList == null) continue;

                        PlayEffect("assets/bundled/prefabs/fx/gestures/cameratakescreenshot.prefab", item);
                    }
                    PlayEffect("assets/bundled/prefabs/fx/survey_explosion.prefab", ent);
                    if (ent != null && !ent.IsDestroyed)
                        ent.Kill();
                    timer.Once(0.2f, () =>
                    {
                        foreach (BasePlayer item in playersNear)
                        {
                            if (item == null || item.gestureList == null) continue;
                            MakeUi(item);
                        }

                    });
                    timer.Once(flashDuration, () =>
                    {
                        foreach (BasePlayer item in playersNear)
                        {
                            if (item == null || item.gestureList == null) continue;
                            CuiHelper.DestroyUi(item, "Flashbang");
                        }

                    });
                }); 
            }
            else if(ent.skinID == healingSkin)
            {
                timer.Once(fuseLength - 0.05f, () =>
                {

                    List<BasePlayer> playersNear = FindAllPlayersNear(ent.transform.position, 10);

                    foreach (BasePlayer item in playersNear)
                    {
                        if (item == null) continue;
                        HealPlayer(item);
                    }
                    if(ent != null && !ent.IsDestroyed)
                        ent.Kill();

                });
            }
            else if(ent.skinID == impactNadeSkin)
            {
                OnCollisionExplode col = ent.gameObject.AddComponent<OnCollisionExplode>();
                col.ent = ent;
            }
            else if(ent.skinID == multiGrenadeSkin)
            {
                ulong ownerId = ent.OwnerID;
                timer.Once(fuseLength - 0.05f, () =>
                {
                    BasePlayer player = ent.creatorEntity as BasePlayer; // Added by ZEODE (ty)

                    Vector3 location = ent.transform.position;
                    Vector3 entityRight = ent.transform.right;
                    Vector3 entityForward = ent.transform.forward;
                    Quaternion rotation = ent.transform.rotation;
                    //grenade in a grenade
                    timer.Repeat(0.1f, 5, () => {


                        int randomRight = UnityEngine.Random.Range(scatterSize * -1, scatterSize);
                        int radonomForward = UnityEngine.Random.Range(scatterSize * -1, scatterSize);
                        BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/weapons/f1 grenade/grenade.f1.deployed.prefab", location + (Vector3.right * randomRight) + (Vector3.forward * radonomForward) + (Vector3.up * 2), rotation);
                        TimedExplosive newNade = entity as TimedExplosive;
                        entity.OwnerID = ownerId;
                        entity.creatorEntity = (BaseEntity)player;
                        entity.Spawn();
                        newNade.SetFuse(0.5f);

                    });



                });
            }
            else if(ent.skinID == stunGrenadeSkin)
            {
                timer.Once(fuseLength - 0.05f, () =>
                {

                    List<BasePlayer> playersNear = FindAllPlayersNear(ent.transform.position, 10);

                    foreach (BasePlayer seeker in playersNear)
                    {
                        if (seeker.IsWounded()) continue;
                        seeker.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, true);
                        seeker.SendNetworkUpdateImmediate();
                        PlayEffect("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", seeker);
                    }
                    //PlayEffect("assets/prefabs/locks/keypad/effects/lock.code.shock.prefab", seeker);
                    timer.Once(4, () =>
                    {
                        foreach (BasePlayer seeker in playersNear)
                        {
                            seeker.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);
                            seeker.SendNetworkUpdateImmediate();
                        }

                    });
                    if (ent != null && !ent.IsDestroyed)
                        ent.Kill();

                });
            }
            
            return null;
        }
        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (skins.Contains(targetItem.item.skin) || skins.Contains(item.item.skin) && item.item.skin == targetItem.item.skin)
            {
                return false;
            }
            return null;
        }
        object CanStackItem(Item item, Item targetItem)
        {
            if ((skins.Contains(targetItem.skin) || skins.Contains(item.skin)) && item.skin != targetItem.skin)
            {
                return false;
            }
            return null;
        }
        #endregion
        private void JavalinRocket(IPlayer iplayer)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            Vector3 firingDir = player.GetNetworkRotation() * Vector3.forward;

            RaycastHit hitInfo;
            Vector3 firingPos = player.eyes.transform.position + Vector3.up + Vector3.up;
            Vector3 target;
            if (UnityEngine.Physics.Raycast(firingPos, firingDir, out hitInfo, maxRange, 1236478737))
            {
                target = hitInfo.point;
            }
            else
            {
                target = firingPos + (firingDir.normalized * maxRange);

            }
            if (spawnFlares)
            {
                BaseEntity flare = GameManager.server.CreateEntity("assets/prefabs/tools/flareold/flare.deployed.prefab", target);
                flare.Spawn();
            }
            
            BaseEntity entity = GameManager.server.CreateEntity("assets/content/vehicles/mlrs/rocket_mlrs.prefab", firingPos + firingDir);
            ServerProjectile projectile = entity.GetComponent<ServerProjectile>();
            Vector3 vector3 = projectile.initialVelocity + firingDir * 10;
            //projectile.speed
            projectile.gravityModifier = 0;
            projectile.InitializeVelocity(vector3);

            entity.creatorEntity = (BaseEntity)player;
            entity.OwnerID = player.userID;
            entity.Spawn();

            timer.Once(0.25f, () => // Start up motion
            {
                if (entity == null || projectile == null || entity.IsDestroyed) return;
                PlayEffect("assets/content/vehicles/mlrs/effects/pfx_mlrs_backfire.prefab", entity);
                projectile.gravityModifier = -2.5f;
                Vector3 newVel = projectile.initialVelocity + firingDir * 5;
                projectile.InitializeVelocity(newVel);
            });

            timer.Once(4, () => //Start flattening out
            {
                if (entity == null || projectile == null || entity.IsDestroyed) return;
                projectile.gravityModifier = 4;//4
                Vector3 newVel = projectile.CurrentVelocity + firingDir;
                projectile.InitializeVelocity(newVel);
            });
            timer.Once(7f, () => // Rain rain rain
            {
                if (entity == null || projectile == null || entity.IsDestroyed) return;
                Vector3 direction = target - projectile.transform.position;
                projectile.gravityModifier = 0;
                projectile.InitializeVelocity(direction.normalized * 75);


            });
        }
        private void CursorRocket(Vector3 firePoint, Quaternion rot, BasePlayer player)
        {
            Vector3 firingDir = rot * Vector3.forward;
            BaseEntity entity = GameManager.server.CreateEntity("assets/content/vehicles/mlrs/rocket_mlrs.prefab", firePoint + (firingDir.normalized * 2), rot);
            ServerProjectile projectile = entity.GetComponent<ServerProjectile>();
            Vector3 vector3 = (rot * Vector3.forward).normalized;
            //projectile.speed
            projectile.gravityModifier = 0;
            projectile.InitializeVelocity(vector3);

            entity.creatorEntity = (BaseEntity)player;
            entity.OwnerID = player.userID;
            entity.Spawn();

            timer.Repeat(0.1f, 0, () =>
            {
                if (entity == null || projectile == null || entity.IsDestroyed) return;
                Vector3 currentDir = entity.transform.rotation * Vector3.forward;
                // Vector3 newDirection = (player.transform.position - entity.transform.position).normalized * 10; 
                Vector3 velocity = Vector3.Lerp(currentDir.normalized, (player.GetNetworkRotation() * Vector3.forward).normalized, UnityEngine.Time.deltaTime * 100);
                projectile.InitializeVelocity(velocity * 20);

            });
        }
        private void TracerRocket(Vector3 firePoint,Quaternion rot, BaseCombatEntity target, BasePlayer owner)
        {
            BaseCombatEntity player = target;
            Vector3 firingDir = rot * Vector3.forward;
            BaseEntity entity = GameManager.server.CreateEntity("assets/content/vehicles/mlrs/rocket_mlrs.prefab", firePoint + (firingDir.normalized * 2), rot);
            ServerProjectile projectile = entity.GetComponent<ServerProjectile>();
            Vector3 vector3 = (rot * Vector3.forward).normalized;
            //projectile.speed
            projectile.gravityModifier = 0;
            projectile.InitializeVelocity(vector3);
            entity.creatorEntity = (BaseEntity)owner;
            entity.OwnerID = owner.userID;
            entity.Spawn();
            
            timer.Repeat(0.1f, 0, () =>
            {
                if (entity == null || projectile == null || entity.IsDestroyed) return;
                Vector3 currentDir = entity.transform.rotation * Vector3.forward;
                // Vector3 newDirection = (player.transform.position - entity.transform.position).normalized * 10; 
                Vector3 velocity = Vector3.Lerp(currentDir.normalized, (player.transform.position + (Vector3.up)- entity.transform.position).normalized, UnityEngine.Time.deltaTime * 40);
                projectile.InitializeVelocity(velocity * 20);
                
            });
        }

        
        private List<BasePlayer> FindAllPlayersNear(Vector3 pos, float radius)
        {
            Collider[] cast = UnityEngine.Physics.OverlapSphere(pos, radius);
            List<BasePlayer> ents = new List<BasePlayer>();
            foreach (Collider item in cast)
            {
                BaseEntity entity = item.gameObject.ToBaseEntity();
                if (entity.IsValid() && entity is BasePlayer && entity is ScientistNPC == false && entity.IsVisible(pos))
                {
                    ents.Add(entity as BasePlayer);
                }
            }
            return ents;
        }
        private void HealPlayer(BasePlayer player)
        {
           
            PlayEffect("assets/prefabs/deployable/mixingtable/effects/mixing-table-deploy.prefab", player);
            player.ChatMessage("Healed!");
            player.CancelInvoke(new Action(player.WoundingTick));
            player.RecoverFromWounded();
            player.Heal(instaHealAmount);
            player.metabolism.ApplyChange(MetabolismAttribute.Type.HealthOverTime, passiveHealAmount, 20);
           
        }
        
        private void Jerico(IPlayer iplayer)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            Vector3 firingDir = player.GetNetworkRotation() * Vector3.forward;

            RaycastHit hitInfo;
            Vector3 firingPos = player.eyes.transform.position + Vector3.up + Vector3.up;
            Vector3 target;
            if (UnityEngine.Physics.Raycast(firingPos, firingDir, out hitInfo, maxRange, 1236478737))
            {
                target = hitInfo.point;
            }
            else
            {
                target = firingPos + (firingDir.normalized * maxRange);

            }

            if (spawnFlares)
            {
                for (int i = 0; i < 6; i++)
                {
                    BaseEntity flare = GameManager.server.CreateEntity("assets/prefabs/tools/flareold/flare.deployed.prefab", target + (Vector3.up * 20) + (Vector3.right * UnityEngine.Random.Range(-10, 10)) + (Vector3.forward * UnityEngine.Random.Range(-10, 10)));
                    flare.Spawn();
                }
            }
            BaseEntity entity = GameManager.server.CreateEntity("assets/content/vehicles/mlrs/rocket_mlrs.prefab", firingPos + firingDir);
            ServerProjectile projectile = entity.GetComponent<ServerProjectile>();
            Vector3 vector3 = projectile.initialVelocity + firingDir * 10;
            //projectile.speed
            projectile.gravityModifier = 0;
            projectile.InitializeVelocity(vector3);

            entity.creatorEntity = (BaseEntity)player;
            entity.OwnerID = player.userID;

            entity.Spawn();

            timer.Once(0.25f, () => // Start up motion
            {
                if (entity == null || projectile == null || entity.IsDestroyed) return;
                PlayEffect("assets/content/vehicles/mlrs/effects/pfx_mlrs_backfire.prefab", entity);
                projectile.gravityModifier = -2.5f;
                Vector3 newVel = projectile.initialVelocity + firingDir * 5;
                projectile.InitializeVelocity(newVel);
            });

            timer.Once(4, () => //Start flattening out
            {
                if (entity == null || projectile == null || entity.IsDestroyed) return;
                projectile.gravityModifier = 4;//4
                Vector3 newVel = projectile.CurrentVelocity + firingDir;
                projectile.InitializeVelocity(newVel);
            });

            timer.Once(6f, () => // Rain rain rain
            {
                if (entity == null || projectile == null || entity.IsDestroyed) return;
                Vector3 direction = target - projectile.transform.position;
                Vector3 location = entity.transform.position;
                Vector3 entityRight = entity.transform.right;
                Vector3 entityForward = entity.transform.forward;
                Quaternion rotation = entity.transform.rotation;
                timer.Repeat(0.05f, bigRocketCount, () =>
                {
                    if (entity == null || projectile == null || entity.IsDestroyed) return;
                    int randomRight = UnityEngine.Random.Range(xSize * -1, xSize);
                    int radonomForward = UnityEngine.Random.Range(ySize * -1, ySize);
                    PlayEffect("assets/content/vehicles/mlrs/effects/pfx_mlrs_backfire.prefab", entity);
                    SpawnRocket(location + (entityRight * randomRight) + (entityForward * radonomForward), firingDir, player, rotation, direction);
                });
                projectile.gravityModifier = 0;
                projectile.InitializeVelocity(direction.normalized * 75);


            });
        }
        private void SpawnRocket(Vector3 pos, Vector3 target, BasePlayer player, Quaternion rotation, Vector3 direction)
        {
            BaseEntity entity = GameManager.server.CreateEntity("assets/content/vehicles/mlrs/rocket_mlrs.prefab", pos + target, rotation);
            ServerProjectile projectile = entity.GetComponent<ServerProjectile>();

            Vector3 vector3 = direction.normalized * 75;
            projectile.gravityModifier = 0;
            projectile.InitializeVelocity(vector3);

            entity.creatorEntity = (BaseEntity)player;
            entity.OwnerID = player.userID;
            timer.Once(UnityEngine.Random.Range(0.0f, 3.0f), () =>
            {
                entity.OwnerID = player.userID;
                entity.Spawn();
                timer.Once(2f, () =>
                {
                    if (entity == null || projectile == null || entity.IsDestroyed) return;
                    PlayEffect("assets/content/vehicles/mlrs/effects/pfx_mlrs_backfire.prefab", entity);

                    timer.Repeat(0.05f, littleRocketCount, () =>
                    {

                        if (entity == null || projectile == null || entity.IsDestroyed) return;
                        int randomUp = UnityEngine.Random.Range(-20, 20);
                        int radonomForward = UnityEngine.Random.Range(-20, 20);
                        int radonom = UnityEngine.Random.Range(-20, 20);

                        SpawnSmallRocket(entity.transform.position + (Vector3.left * randomUp) + (Vector3.forward * radonomForward), target, player, projectile, direction);
                    });

                });
            });


        }
        private void SpawnSmallRocket(Vector3 pos, Vector3 target, BasePlayer player, ServerProjectile parentProjectile, Vector3 direction)
        {
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_basic.prefab", pos + target, parentProjectile.transform.rotation);
            ServerProjectile projectile = entity.GetComponent<ServerProjectile>();
            //projectile.speed
            projectile.gravityModifier = 0;

            Vector3 vector3 = direction.normalized * 75;
            projectile.gravityModifier = 0;
            projectile.InitializeVelocity(vector3);

            entity.creatorEntity = (BaseEntity)player;
            entity.OwnerID = player.userID;

            entity.Spawn();
        }


        private static void PlayEffect(string effect, BaseEntity entity)
        {
            BaseEntity playerEntity = entity;
            Effect reusableInstance = new Effect();
            reusableInstance.Clear();

            reusableInstance.Init(Effect.Type.Generic, playerEntity, 0, new Vector3(0, 0, 0), new Vector3(0, 0, 0), null);
            reusableInstance.scale = false ? 0.0f : 1f;


            reusableInstance.pooledString = effect;
            EffectNetwork.Send(reusableInstance);
        }
        private void MakeUi(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "1.0 1.0 1.0 1.0" },
                FadeOut = 1,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" }
            }, "Overlay", "Flashbang");
            CuiHelper.DestroyUi(player, "Flashbang");
            CuiHelper.AddUi(player, container);
        }
        public class OnCollision : MonoBehaviour
        {
            public BaseEntity ent { get; set; }
            

            void OnCollisionEnter(Collision collision)
            {

                PlayEffect("assets/bundled/prefabs/fx/impacts/stab/glass/glass1.prefab", ent);

                for (int i = 0; i < 15; i++)
                {
                    int randomRight = UnityEngine.Random.Range(-300, 300);
                    int radonomForward = UnityEngine.Random.Range(-300, 300);
                    BaseEntity entity = GameManager.server.CreateEntity("assets/bundled/prefabs/fireball.prefab", ent.transform.position + (Vector3.right * (randomRight / 100)) + (Vector3.forward * (radonomForward / 100)), new Quaternion(), true) as BaseEntity;
                    entity.creatorEntity = (BaseEntity)ent.creatorEntity;
                    entity.OwnerID = ent.OwnerID;
                    entity.Spawn();
                }
                ent.Kill();
                Destroy(this);
            }
        }
        public class OnCollisionExplode : MonoBehaviour
        {
            public TimedExplosive ent { get; set; }


            void OnCollisionEnter(Collision collision)
            {
                ent.Explode();
                Destroy(this);
            }
        }
    }
}

// --- End of file: ExplosiveWeapons.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoStashBug.cs ---
// --- Original Local Path: NoStashBug.cs ---

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoStashBug", "azalea`", "1.1")]
    class NoStashBug : RustPlugin
    {
        static int PreventBuilding = LayerMask.NameToLayer("Prevent Building");

        void OnServerInitialized()
        {
            var Stashes = UnityEngine.Object.FindObjectsOfType<StashContainer>();

            foreach (var stash in Stashes)
            {
                stash.gameObject.layer = PreventBuilding;
                stash.gameObject.transform.localScale = new Vector3(1f, 3f, 1f);
            }
        }

        void OnEntityBuilt(Planner plan, GameObject obj)
        {
            if (obj.GetComponent<StashContainer>() != null)
            {           
                obj.layer = PreventBuilding;
                obj.transform.localScale = new Vector3(1f, 3f, 1f);
            }
        }

    }
}

// --- End of file: NoStashBug.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPPanelSystem.cs ---
// --- Original Local Path: TPPanelSystem.cs ---

using System;
using System.Globalization;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("TPPanelSystem", "Sempai#3239/https://topplugin.ru/", "1.0.1")]
    public class TPPanelSystem : RustPlugin
    {
        #region Fields
        [PluginReference] private Plugin ImageLibrary;
        private Dictionary<ulong, bool> PanelVisibility = new Dictionary<ulong, bool>();
        private List<string> EventNames = new List<string>();
        private readonly string defaultSprite = "assets/content/ui/ui.icon.rust.png";
        private Dictionary<string, string> EventAnMinX = new Dictionary<string, string>();
        private Dictionary<string, string> EventAnMaxX = new Dictionary<string, string>();
        private readonly string Layer = "GRPLayer";
        private readonly string Layer1 = "GRPLayer_Store";
        #endregion

        #region [GUIBUILDER]
        protected CuiElement Panel(string name, string anMin, string anMax, string color, string parent, float fadeout, string png, bool cursor, string offsetmin, string offsetmax)
        {
            var Element = new CuiElement()
            
            {
                Name = name,
                Parent = parent,
                FadeOut = fadeout,
                Components =
                {
                    new CuiRawImageComponent { Png = png, Color = color },
                    new CuiRectTransformComponent { AnchorMin = anMin, AnchorMax = anMax, OffsetMin = offsetmin, OffsetMax = offsetmax }
                }
            };
            if (cursor)
            {
                Element.Components.Add(new CuiNeedsCursorComponent());
            }
            return Element;
        }
        protected CuiElement Text(string name, string parent, string color, string text, TextAnchor pos, int fsize, string anMin, string anMax, string fname = "robotocondensed-bold.ttf")
        {
            var Element = new CuiElement()
            {
                Name = name,
                Parent = parent,
                Components =
                {
                    new CuiTextComponent() { Color = color, Text = text, Align = pos, Font = fname, FontSize = fsize },
                    new CuiRectTransformComponent{ AnchorMin = anMin, AnchorMax = anMax }
                }
            };
            return Element;
        }
        protected CuiElement Button(string name, string parent, string sprite, string command, string color, string anMin, string anMax)
        {
            var Element = new CuiElement()
            {
                Name = name,
                Parent = parent,
                Components =
                {
                    new CuiButtonComponent { Command = command, Color = color, Sprite = sprite },
                    new CuiRectTransformComponent{ AnchorMin = anMin, AnchorMax = anMax }
                }
            };
            return Element;
        }
        #endregion

        #region Config

        private PluginConfig cfg;

        public class PluginConfig
        {
            [JsonProperty("Основные настройки")]
            public Settings MainSettings = new Settings();

            [JsonProperty("Сообщения")]
            public MessageSettings SettingsMessages = new MessageSettings();


            public class Settings
            {
                [JsonProperty("Включить показ кнопки магазина?")]
                public bool EnableStore = true;
                [JsonProperty("Фейк онлайн++")]
                public int FakeOnline = 10;
            }

            public class MessageSettings
            {
                [JsonProperty("Время обновления сообщений")]
                public float RefreshTimer = 30f;
                [JsonProperty("Размер текста для автосообщений")]
                public int TextSize = 12;
                [JsonProperty("Список сообщений", ObjectCreationHandling = ObjectCreationHandling.Replace)]
                public List<string> Messages = new List<string>
                {
                    "<color=lime>Пример сообщения 1</color>",
                    "<color=red>Пример сообщения 2</color>",
                    "<color=blue>Пример сообщения 3</color>"
                };
            }
        }


        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig(), true);
        }

        #endregion

        #region Lang [Локализация]

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"PanelHelpMessage", "Вы должны выбрать один из вариантов:\n/panel <color=green>on</color> - включает показ панели\n/panel <color=red>off</color> - выключает показ панели" },
            {"PanelOff", "Вы <color=red>выключили</color> показ панели" },
            {"PanelOn", "Вы <color=green>включили</color> показ панели" },
        };

        #endregion

        #region Hooks
        void InitializeLang()
        {
            lang.RegisterMessages(Messages, this, "ru");
            Messages = lang.GetMessages("ru", this);
        }
        void Loaded()
        {
            cfg = Config.ReadObject<PluginConfig>();
            Config.WriteObject(cfg);
            EventNames.Add("plane"); // 0
            EventNames.Add("heli"); // 1
            EventNames.Add("ch47"); // 2
            EventNames.Add("cargo"); // 3

            EventAnMinX.Add("0.29", "0.39"); // 0
            EventAnMinX.Add("0.365", "0.31"); // 1
            EventAnMinX.Add("0.448", "0.31"); // 2
            EventAnMinX.Add("0.53", "0.32"); // 3

            EventAnMaxX.Add("0.333", "0.61"); // 0
            EventAnMaxX.Add("0.41", "0.69"); // 1
            EventAnMaxX.Add("0.493", "0.69"); // 2
            EventAnMaxX.Add("0.575", "0.68"); // 3

            foreach(BasePlayer p in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(p);
            }
        }
        void OnServerInitialized()
        {
            if (!plugins.Exists("ImageLibrary"))
            {
                PrintWarning("DOWNLOAD 'ImageLibrary'! Plugin kryGrandRustPanel has closed...");
                Interface.Oxide.UnloadPlugin("ImageLibrary");
                return;
            }
            InitializeLang();
            ImageLibrary.Call("AddImage", "https://i.ibb.co/M9jRW8W/S4pX4lR.png", "background");
            ImageLibrary.Call("AddImage", "https://i.ibb.co/KLxjyXF/B9vjEY1.png", "online");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui_logo.png", "logo");
            ImageLibrary.Call("AddImage", "https://i.ibb.co/SmfhBWr/wkMLkoV.png", "store");

            ImageLibrary.Call("AddImage", "https://i.ibb.co/XC8pwFX/il3NdyE.png", "plane");
            ImageLibrary.Call("AddImage", "https://i.ibb.co/ydTGPt5/dc2G5L9.png", "heli");
            ImageLibrary.Call("AddImage", "https://i.ibb.co/wLqnrpm/N99MlcN.png", "ch47");
            ImageLibrary.Call("AddImage", "https://i.ibb.co/MP4rDvW/WWfMK1S.png", "cargo");

            ImageLibrary.Call("AddImage", "https://i.ibb.co/3mvDwbx/GnW1jFA.png", "plane_called");
            ImageLibrary.Call("AddImage", "https://i.ibb.co/r67dHhX/yD5eb3L.png", "heli_called");
            ImageLibrary.Call("AddImage", "https://i.ibb.co/yF5PxKp/Hr6TTXZ.png", "ch47_called");
            ImageLibrary.Call("AddImage", "https://i.ibb.co/SxZJshG/jA9fIc6.png", "cargo_called");
            InvokeHandler.Instance.InvokeRepeating(DrawMessage, cfg.SettingsMessages.RefreshTimer, cfg.SettingsMessages.RefreshTimer);

            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
        }
        void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(DrawMessage);
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, Layer1);
                CuiHelper.DestroyUi(player, "Message");
            }
        }
        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null) return;
            if (entity is CargoPlane || entity is BaseHelicopter || entity is CargoShip || entity is CH47Helicopter)
            {
                var tag = entity is CargoPlane ? "plane" : entity is BaseHelicopter ? "heli" : entity is CH47Helicopter ? "ch47" : entity is CargoShip ? "cargo" : "";
                timer.Once(1f, () => { foreach (var players in BasePlayer.activePlayerList) DrawEvents(players, tag); });
            }
            else return;
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }
            if (!PanelVisibility.ContainsKey(player.userID)) { PanelVisibility.Add(player.userID, true); }

            NextTick(() => 
            {
                DrawMessage();
                DrawMenu(player);
                if (cfg.MainSettings.EnableStore)
                {
                    DrawStoreMenu(player);
                }
                foreach (var players in BasePlayer.activePlayerList)
                {
                    if (PanelVisibility[players.userID] == false) return;
                    refreshPlayers();
                }
            });
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            timer.Once(1f, () => {
                foreach (var players in BasePlayer.activePlayerList)
                {
                    if (PanelVisibility[players.userID] == false) return;
                    refreshPlayers();
                }
            });
        }
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null || entity.net == null)  return;
            if (entity is CargoPlane)
                foreach (var player in BasePlayer.activePlayerList) DrawEvents(player, "plane");
            if (entity is BaseHelicopter)
                foreach (var player in BasePlayer.activePlayerList) DrawEvents(player, "heli");
            if (entity is CargoShip)
                foreach (var player in BasePlayer.activePlayerList) DrawEvents(player, "cargo");
            if (entity is CH47Helicopter)
                foreach (var player in BasePlayer.activePlayerList) DrawEvents(player, "ch47");
        }
        #endregion

        #region Custom Bools
        bool HasEntity(string name)
        {
            if (name == "plane") 
            {
                foreach (var check in BaseNetworkable.serverEntities) { if (check is CargoPlane) { return true; } }
            }
            if (name == "heli") 
            {
                foreach (var check in BaseNetworkable.serverEntities) { if (check is BaseHelicopter) { return true; } }
            }
            if (name == "ch47") 
            {
                foreach (var check in BaseNetworkable.serverEntities) { if (check is CH47Helicopter) { return true; } }
            }
            if (name == "cargo") 
            {
                foreach (var check in BaseNetworkable.serverEntities) { if (check is CargoShip) { return true; } }
            }

            return false;
        }

        #endregion

        #region Commands

        [ChatCommand("panel")]
        void PanelCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length < 1)
            {
                player.ChatMessage(Messages["PanelHelpMessage"]);
                return;
            }
            if (args[0] == "off")
            {
                if (!PanelVisibility.ContainsKey(player.userID))
                    PanelVisibility.Add(player.userID, false);
                else if (PanelVisibility.ContainsKey(player.userID) && PanelVisibility[player.userID] == false)
                    PanelVisibility[player.userID] = false;

                player.ChatMessage(Messages["PanelOff"]);
                CuiHelper.DestroyUi(player, Layer);
            }
            else if (args[0] == "on")
            {
                if (!PanelVisibility.ContainsKey(player.userID))
                    PanelVisibility.Add(player.userID, true);
                else if (PanelVisibility.ContainsKey(player.userID) && PanelVisibility[player.userID] == true)
                    PanelVisibility[player.userID] = true;

                player.ChatMessage(Messages["PanelOn"]);
                OnPlayerConnected(player);
            }
            else return;
        }

        #endregion

        #region UI

        void refreshPlayers()
        {
            var online = BasePlayer.activePlayerList.Count + cfg.MainSettings.FakeOnline;
            CuiElementContainer container = new CuiElementContainer();
            container.Add(Text(Layer + ".players", Layer, HexToRustFormat("#FFFFFF"), $"{online}/{ConVar.Server.maxplayers}", TextAnchor.MiddleCenter, 11, "0.65 0", "0.82 1"));
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(p, Layer + ".players");
                CuiHelper.AddUi(p, container);
            }
        }
        void DrawMessage()
        {
            foreach (var players in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(players, "Message");
                var container = new CuiElementContainer();

                container.Add(Panel("Message", "0.3453124 -0.0009259344", "0.6416667 0.0287037", HexToRustFormat("#FFFFFF00"), "Hud", 0, "", false, "0 0", "0 0"));

                container.Add(Text("Message.Message", "Message", "0 0 0 1", cfg.SettingsMessages.Messages[new System.Random().Next
                (cfg.SettingsMessages.Messages.Count)], TextAnchor.MiddleCenter, cfg.SettingsMessages.TextSize, "0 0", "1 1"));
                CuiHelper.AddUi(players, container);
            }
        }

        void DrawEvents(BasePlayer player, string name)
        {
            string anMinX = "";
            string EventAnMinY = "";
            string anMaxX = "";
            string EventAnMaxY = "";
            if (PanelVisibility[player.userID] == false) return;
            var container = new CuiElementContainer();
            for (int i = 0; i < EventNames.Count; i++)
            {
                if (EventNames[i] == name)
                {
                    anMinX = EventAnMinX.ElementAt(i).Key;
                    EventAnMinY = EventAnMinX.ElementAt(i).Value;
                    anMaxX = EventAnMaxX.ElementAt(i).Key;
                    EventAnMaxY = EventAnMaxX.ElementAt(i).Value;
                }
            }

            CuiHelper.DestroyUi(player, Layer + "." + name);
            container.Add(Panel(Layer + "." + name, $"{anMinX} {EventAnMinY}", $"{anMaxX} {EventAnMaxY}", "", Layer, 0.1f, HasEntity(name) ? (string)ImageLibrary.Call("GetImage", $"{name}_called") : (string)ImageLibrary.Call("GetImage", $"{name}"), false, "", ""));
            CuiHelper.AddUi(player, container);
        }

        private void DrawStoreMenu(BasePlayer player)
        {
            if (!cfg.MainSettings.EnableStore) return;
            CuiHelper.DestroyUi(player, Layer1);
            var container = new CuiElementContainer();

            /*container.Add(Panel(Layer1, "0.001041666 0.9648147", "0.001041666 0.9648147", HexToRustFormat("#FFFFFF00"), "Hud", 0f, "", false, "10 -4", "313 23"));
            container.Add(Panel(Layer1 + ".Store", "0.001849664 0.02469136", "0.08985749 1.012346", "", Layer1, 0f, (string)ImageLibrary.Call("GetImage", "store"), false, "0 0", "0 0"));
            container.Add(Button(Layer1 + ".button", Layer1 + ".Store", defaultSprite, "chat.say /store", "0 0 0 0", "0 0", "1 1"));*/

            CuiHelper.AddUi(player, container);
        }
        private void DrawMenu(BasePlayer player)

        {
            if (PanelVisibility[player.userID] == false) return;
            var online = BasePlayer.activePlayerList.Count().ToString();
            var time = TOD_Sky.Instance.Cycle.DateTime.ToString("HH:mm");

            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.001041666 0.9648147", AnchorMax = "0.001041666 0.9648147", OffsetMin = "10 -13", OffsetMax = "313 15" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", Layer); 

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "background"), FadeIn = 1f },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.09 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, Layer, "Logo");

            container.Add(new CuiElement
            {
                Parent = "Logo",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "logo"), FadeIn = 1f },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1 1", OffsetMax = "-1 -1" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.12 0", AnchorMax = $"0.26 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "chat.say /menu" },
                Text = { Text = $"Меню", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 11, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.618 0", AnchorMax = "0.7 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, Layer, "Online");

            container.Add(new CuiElement
            {
                Parent = "Online",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "online"), FadeIn = 1f },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "8 7.5", OffsetMax = "-8 -7.5" }
                }
            });

            
            container.Add(Panel(Layer + ".plane", "0.29 0.39", "0.333 0.61", "", Layer, 0.1f, HasEntity("plane") ? (string)ImageLibrary.Call("GetImage", "plane_called") : (string)ImageLibrary.Call("GetImage", "plane"), false, "0 0", "0 0"));
            container.Add(Panel(Layer + ".heli", "0.365 0.31", "0.41 0.69", "", Layer, 0.1f, HasEntity("heli") ? (string)ImageLibrary.Call("GetImage", "heli_called") : (string)ImageLibrary.Call("GetImage", "heli"), false, "0 0", "0 0"));

            container.Add(Panel(Layer + ".ch47", "0.448 0.31", "0.493 0.69", "", Layer, 0.1f, HasEntity("ch47") ? (string)ImageLibrary.Call("GetImage", "ch47_called") : (string)ImageLibrary.Call("GetImage", "ch47"), false, "0 0", "0 0"));
            container.Add(Panel(Layer + ".cargo", "0.53 0.32", "0.575 0.68", "", Layer, 0.1f, HasEntity("cargo") ? (string)ImageLibrary.Call("GetImage", "cargo_called") : (string)ImageLibrary.Call("GetImage", "cargo"), false, "0 0", "0 0"));

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Helpers

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion
    }
}

// --- End of file: TPPanelSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Crafter.cs ---
// --- Original Local Path: Crafter.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Rust;
using System;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Crafter", "Night_Tiger", "0.1.2")]
	[Description("Позволяет крафтить оружия: lr300, m249, m92, spas12")]
    class Crafter : RustPlugin
    {
        #region Fields
        static Crafter ins;
        private bool initialized;

        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("crafter.admin", this);
            permission.RegisterPermission("crafter.use", this);
        }

        private void OnServerInitialized()
        {
            ins = this;
            // LoadData();

            initialized = true;
        }
        #endregion

        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm) || permission.UserHasPermission(player.UserIDString, "crafter.admin");


        #region Commands
        [ChatCommand("craft")]
        void cmdCraftUser(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "crafter.use") && !player.IsAdmin)
            {
                SendReply(player, "У тебя нету прав использовать эту команду!");
                return;
            }
			
			if (args.Length == 0)
			player.ChatMessage($"<b><color=#ff0000ff>Крафт пулемета M249, винтовки LR-300, пистолета M92 Беретта или дробовика Spas 12!</color></b>\n<b><color=#ce422b> <size=15>Для крафта оружий используйте команды:</size></color></b>\n<b>/craft lr300</b>\n/craft m249\n/craft m92\n/craft spas");

            else if (args.Length == 1)
            {
                switch (args[0].ToLower())
				{
					case "lr300":
					{
						var mvk = player.inventory.GetAmount(317398316);//317398316 metal.refined
						var metal = player.inventory.GetAmount(69511070);//69511070 metal.fragments
						var rifle = player.inventory.GetAmount(176787552);//176787552 riflebody
						var spring = player.inventory.GetAmount(-1021495308);//-1021495308 metalspring
						
						if (mvk >= configData.CC.lr300.comp1 & metal >= configData.CC.lr300.comp2 & rifle >= configData.CC.lr300.comp3 & spring >= configData.CC.lr300.comp4)
						{
							player.inventory.Take(null, 317398316, configData.CC.lr300.comp1);
							player.inventory.Take(null, 69511070, configData.CC.lr300.comp2);
							player.inventory.Take(null, 176787552, configData.CC.lr300.comp3);
							player.inventory.Take(null, -1021495308, configData.CC.lr300.comp4);
						}
						else
						{
						player.ChatMessage($"<b><color=#ff0000ff>Недостаточно ресурсов!</color></b>\n<b><color=#ce422b> <size=15>Для крафта оружия нужны ресурсы:</size></color></b>\n<b>Мвк <color=#ce422b>{configData.CC.lr300.comp1}</color> шт. (В наличии <color=#ce422b>{mvk}</color> шт.)</b>\nМеталл <color=#ce422b>{configData.CC.lr300.comp2}</color> шт. (В наличии <color=#ce422b>{metal}</color> шт.)\n<b>Корпус винтовки <color=#ce422b>{configData.CC.lr300.comp3}</color> шт. (В наличии <color=#ce422b>{rifle}</color> шт.)</b>\n<b>Пружины <color=#ce422b>{configData.CC.lr300.comp4}</color> шт. (В наличии <color=#ce422b>{spring}</color> шт.)</b>\n\nКак соберешь эти ресурсы, прописывай <color=#ce422b>/craft lr300</color>");
							return;
						}

						player.inventory.GiveItem(ItemManager.CreateByItemID(-1812555177, 1));
						player.ChatMessage($"<b>Оружие LR-300 успешно скрафчено!");
						return;
					}
					case "m249":
					{
						var mvk = player.inventory.GetAmount(317398316);
						var metal = player.inventory.GetAmount(69511070);
						var rifle = player.inventory.GetAmount(176787552);
						var spring = player.inventory.GetAmount(-1021495308);
						if (mvk >= configData.CC.m249.comp1 & metal >= configData.CC.m249.comp2 & rifle >= configData.CC.m249.comp3 & spring >= configData.CC.m249.comp4)
						{
							player.inventory.Take(null, 317398316, configData.CC.m249.comp1);
							player.inventory.Take(null, 69511070, configData.CC.m249.comp2);
							player.inventory.Take(null, 176787552, configData.CC.m249.comp3);
							player.inventory.Take(null, -1021495308, configData.CC.m249.comp4);
						}
						else
						{
						player.ChatMessage($"<b><color=#ff0000ff>Недостаточно ресурсов!</color></b>\n<b><color=#ce422b> <size=15>Для крафта оружия нужны ресурсы:</size></color></b>\n<b>Мвк <color=#ce422b>{configData.CC.m249.comp1}</color> шт. (В наличии <color=#ce422b>{mvk}</color> шт.)</b>\nМеталл <color=#ce422b>{configData.CC.m249.comp2}</color> шт. (В наличии <color=#ce422b>{metal}</color> шт.)\n<b>Корпус винтовки <color=#ce422b>{configData.CC.m249.comp3}</color> шт. (В наличии <color=#ce422b>{rifle}</color> шт.)</b>\n<b>Пружины <color=#ce422b>{configData.CC.m249.comp4}</color> шт. (В наличии <color=#ce422b>{spring}</color> шт.)</b>\n\nКак соберешь эти ресурсы, прописывай <color=#ce422b>/craft m249</color>");
							return;
						}

						player.inventory.GiveItem(ItemManager.CreateByItemID(-2069578888, 1));
						player.ChatMessage($"<b>Оружие M249 успешно скрафчено!");
						return;
					}
					case "m92":
					{
						var mvk = player.inventory.GetAmount(317398316);
						var pipe = player.inventory.GetAmount(95950017);
						var semi = player.inventory.GetAmount(573926264);
						var spring = player.inventory.GetAmount(-1021495308);
						if (mvk >= configData.CC.m92.comp1 & pipe >= configData.CC.m92.comp2 & semi >= configData.CC.m92.comp3 & spring >= configData.CC.m92.comp4)
						{
							player.inventory.Take(null, 317398316, configData.CC.m92.comp1);
							player.inventory.Take(null, 95950017, configData.CC.m92.comp2);
							player.inventory.Take(null, 573926264, configData.CC.m92.comp3);
							player.inventory.Take(null, -1021495308, configData.CC.m92.comp4);
						}
						else
						{
						player.ChatMessage($"<b><color=#ff0000ff>Недостаточно ресурсов!</color></b>\n<b><color=#ce422b> <size=15>Для крафта оружия нужны ресурсы:</size></color></b>\n<b>Мвк <color=#ce422b>{configData.CC.m92.comp1}</color> шт. (В наличии <color=#ce422b>{mvk}</color> шт.)</b>\nТрубы <color=#ce422b>{configData.CC.m92.comp2}</color> шт. (В наличии <color=#ce422b>{pipe}</color> шт.)\n<b>Корпус полуавтомата <color=#ce422b>{configData.CC.m92.comp3}</color> шт. (В наличии <color=#ce422b>{semi}</color> шт.)</b>\n<b>Пружины <color=#ce422b>{configData.CC.m92.comp4}</color> шт. (В наличии <color=#ce422b>{spring}</color> шт.)</b>\n\nКак соберешь эти ресурсы, прописывай <color=#ce422b>/craft m92</color>");
							return;
						}

						player.inventory.GiveItem(ItemManager.CreateByItemID(-852563019, 1));
						player.ChatMessage($"<b>Оружие M92 успешно скрафчено!");
						return;
					}
					case "spas":
					{
						var mvk = player.inventory.GetAmount(317398316);
						var pipe = player.inventory.GetAmount(95950017);
						var metal = player.inventory.GetAmount(69511070);
						var spring = player.inventory.GetAmount(-1021495308);
						if (mvk >= configData.CC.spas.comp1 & pipe >= configData.CC.spas.comp2 & metal >= configData.CC.spas.comp3 & spring >= configData.CC.spas.comp4)
						{
							player.inventory.Take(null, 317398316, configData.CC.spas.comp1);
							player.inventory.Take(null, 95950017, configData.CC.spas.comp2);
							player.inventory.Take(null, 69511070, configData.CC.spas.comp3);
							player.inventory.Take(null, -1021495308, configData.CC.spas.comp4);
						}
						else
						{
						player.ChatMessage($"<b><color=#ff0000ff>Недостаточно ресурсов!</color></b>\n<b><color=#ce422b> <size=15>Для крафта оружия нужны ресурсы:</size></color></b>\n<b>Мвк <color=#ce422b>{configData.CC.spas.comp1}</color> шт. (В наличии <color=#ce422b>{mvk}</color> шт.)</b>\nТрубы <color=#ce422b>{configData.CC.spas.comp2}</color> шт. (В наличии <color=#ce422b>{pipe}</color> шт.)\n<b>Металл <color=#ce422b>{configData.CC.spas.comp3}</color> шт. (В наличии <color=#ce422b>{metal}</color> шт.)</b>\n<b>Пружины <color=#ce422b>{configData.CC.spas.comp4}</color> шт. (В наличии <color=#ce422b>{spring}</color> шт.)</b>\n\nКак соберешь эти ресурсы, прописывай <color=#ce422b>/craft spas</color>");
							return;
						}

						player.inventory.GiveItem(ItemManager.CreateByItemID(-41440462, 1));
						player.ChatMessage($"<b>Оружие Spas 12 успешно скрафчено!");
						return;
					}
				}
            
            } else {
				return;
			}

        }


        [ChatCommand("admcraft")]
        void cmdCraftAdmin(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "crafter.admin") && !player.IsAdmin) return;
			if (args.Length == 0)
			player.ChatMessage($"<b><color=#ff0000ff>Крафт пулемета M249 или винтовки LR-300!</color></b>\n<b><color=#ce422b> <size=15>Для крафта оружий используйте команды:</size></color></b>\n<b>/admcraft lr300</b>\n/admcraft m249");

            else if (args.Length == 1 || args.Length == 2)
            {
                switch (args[0].ToLower())
				{
					case "lr300":
					{
						player.inventory.GiveItem(ItemManager.CreateByItemID(-1812555177, 1));
						return;
					}
					case "m249":
					{
						player.inventory.GiveItem(ItemManager.CreateByItemID(-2069578888, 1));
						return;
					}
					case "m92":
					{
						player.inventory.GiveItem(ItemManager.CreateByItemID(-852563019, 1));
						return;
					}
					case "spas":
					{
						player.inventory.GiveItem(ItemManager.CreateByItemID(-41440462, 1));
						return;
					}
				}
            
            } else {
				return;
			}
        }

        #endregion


        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Компоненты необходимые для крафта")]
            public CrafterComponents CC { get; set; }

            public class CrafterComponents
            {
                [JsonProperty(PropertyName = "Для винтовки LR-300")]
                public CClr300 lr300 { get; set; }
				[JsonProperty(PropertyName = "Для пулемета M249")]
                public CCm249 m249 { get; set; }
                [JsonProperty(PropertyName = "Для пистолета M92")]
                public CCm92 m92 { get; set; }
				[JsonProperty(PropertyName = "Для дробовика Spas12")]
                public CCspas spas { get; set; }

                public class CClr300
                {
                    [JsonProperty(PropertyName = "Металл высокого качества")]
                    public int comp1 { get; set; }
                    [JsonProperty(PropertyName = "Фрагменты металла")]
                    public int comp2 { get; set; }
                    [JsonProperty(PropertyName = "Корпус винтовки")]
                    public int comp3 { get; set; }
                    [JsonProperty(PropertyName = "Пружины")]
                    public int comp4 { get; set; }
                }
				public class CCm249
                {
                    [JsonProperty(PropertyName = "Металл высокого качества")]
                    public int comp1 { get; set; }
                    [JsonProperty(PropertyName = "Фрагменты металла")]
                    public int comp2 { get; set; }
                    [JsonProperty(PropertyName = "Корпус винтовки")]
                    public int comp3 { get; set; }
                    [JsonProperty(PropertyName = "Пружины")]
                    public int comp4 { get; set; }
                }
				public class CCm92
                {
                    [JsonProperty(PropertyName = "Металл высокого качества")]
                    public int comp1 { get; set; }
                    [JsonProperty(PropertyName = "Трубы")]
                    public int comp2 { get; set; }
                    [JsonProperty(PropertyName = "Корпус полуавтомата")]
                    public int comp3 { get; set; }
                    [JsonProperty(PropertyName = "Пружины")]
                    public int comp4 { get; set; }
                }
				public class CCspas
                {
                    [JsonProperty(PropertyName = "Металл высокого качества")]
                    public int comp1 { get; set; }
                    [JsonProperty(PropertyName = "Трубы")]
                    public int comp2 { get; set; }
                    [JsonProperty(PropertyName = "Фрагменты металла")]
                    public int comp3 { get; set; }
                    [JsonProperty(PropertyName = "Пружины")]
                    public int comp4 { get; set; }
                }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                CC = new ConfigData.CrafterComponents
                {
                    lr300 = new ConfigData.CrafterComponents.CClr300
                    {
                        comp1 = 60,
                        comp2 = 200,
                        comp3 = 2,
                        comp4 = 10
                    },
                    m249 = new ConfigData.CrafterComponents.CCm249
                    {
                        comp1 = 120,
                        comp2 = 400,
                        comp3 = 4,
                        comp4 = 20
                    },
					m92 = new ConfigData.CrafterComponents.CCm92
                    {
                        comp1 = 15,
                        comp2 = 3,
                        comp3 = 1,
                        comp4 = 2
                    },
					spas = new ConfigData.CrafterComponents.CCspas
                    {
                        comp1 = 15,
                        comp2 = 3,
                        comp3 = 200,
                        comp4 = 1
                    }
                }
            };
        }
        #endregion
    }
}


// --- End of file: Crafter.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DMBuildings.cs ---
// --- Original Local Path: DMBuildings.cs ---

using System.Collections.Generic;
using System;

using Rust;

namespace Oxide.Plugins
{
     [Info("DMBuildings", "ColonBlow", "1.2.5", ResourceId = 1239)]
     internal class DMBuildings : RustPlugin
     {
         private const int DamageTypeMax = (int) DamageType.LAST;
         private readonly float[] _modifiers = new float[DamageTypeMax];
         private bool _didConfigChange;

         private void Loaded() => LoadConfigValues();
         protected override void LoadDefaultConfig() => Puts("New configuration file created.");

         private void LoadConfigValues()
         {
             foreach (DamageType val in Enum.GetValues(typeof(DamageType)))
             {
                 if (val == DamageType.LAST) continue;
                 _modifiers[(int) val] = Convert.ToSingle(GetConfigValue("Building_Multipliers", val.ToString(), 1.0));
             }

             if (!_didConfigChange) return;
             Puts("Configuration file updated.");
             SaveConfig();
         }

         private object GetConfigValue(string category, string setting, object defaultValue)
         {
             var data = Config[category] as Dictionary<string, object>;
             object value;
             if (data == null)
             {
                 data = new Dictionary<string, object>();
                 Config[category] = data;
                 _didConfigChange = true;
             }

             if (data.TryGetValue(setting, out value)) return value;
             value = defaultValue;
             data[setting] = value;
             _didConfigChange = true;
             return value;
         }

         private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
         {
             if (entity is BuildingBlock)
             for (var i = 0; i < DamageTypeMax; i++)
             {
                 hitInfo.damageTypes.Scale((DamageType) i, _modifiers[i]);
             }

             if (entity is Door)
             for (var i = 0; i < DamageTypeMax; i++)
             {
                 hitInfo.damageTypes.Scale((DamageType) i, _modifiers[i]);
             }
		else return;
         }
     }
}

// --- End of file: DMBuildings.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RaidZone.cs ---
// --- Original Local Path: RaidZone.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;
using System.Collections;
using System;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Random = UnityEngine.Random;
using Oxide.Core.Plugins;
using Newtonsoft.Json.Linq;
using System.Text.RegularExpressions;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("RaidZone", "fermens", "0.1.51")]
    [Description("Рейблок по зонам")]
    public class RaidZone : RustPlugin
    {
        #region КОНФИГa
        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private static Dictionary<string, string> _names = new Dictionary<string, string>
        {
            { "wall Stone", "вашу каменную стену"},
            { "wall.low Stone", "вашу каменную низкую стену"},
            { "wall.frame Stone", "ваш каменный настенный каркас"},
            { "foundation Stone", "ваш каменный фундамент"},
            { "roof Stone", "вашу каменную крышу"},
            { "wall.doorway Stone", "ваш каменный дверной проём"},
            { "foundation.steps Stone", "ваши каменные ступеньки"},
            { "block.stair.lshape Stone", "вашу каменную L-лестницу"},
            { "block.stair.ushape Stone", "вашу каменную U-лестницу"},
            { "foundation.triangle Stone", "ваш каменный треугольный фундамент"},
            { "wall.window Stone", "ваш каменное окно"},
            { "wall.half Stone", "вашу каменную полустену"},
            { "wall Metal", "вашу металлическую стену"},
            { "wall.low Metal", "вашу металлическую низкую стену"},
            { "wall.frame Metal", "ваш металлический настенный каркас"},
            { "foundation Metal", "ваш металлический фундамент"},
            { "roof Metal", "вашу металлическую крышу"},
            { "wall.doorway Metal", "ваш металлический дверной проём"},
            { "foundation.steps Metal", "ваши металлические ступеньки"},
            { "block.stair.lshape Metal", "вашу металлическую L-лестницу"},
            { "block.stair.ushape Metal", "вашу металлическую U-лестницу"},
            { "foundation.triangle Metal", "ваш металлический треугольный фундамент"},
            { "wall.window Metal", "ваше металлическое окно"},
            { "wall.half Metal", "вашу металлическую полустену"},
            { "wall TopTier", "вашу бронированную стену"},
            { "wall.low TopTier", "вашу бронированную низкую стену"},
            { "wall.frame TopTier", "ваш бронированный настенный каркас"},
            { "foundation TopTier", "ваш бронированный фундамент"},
            { "roof TopTier", "вашу бронированную крышу"},
            { "wall.doorway TopTier", "ваш бронированный дверной проём"},
            { "foundation.steps TopTier", "ваши бронированные ступеньки"},
            { "block.stair.lshape TopTier", "вашу бронированную L-лестницу"},
            { "block.stair.ushape TopTier", "вашу бронированную U-лестницу"},
            { "foundation.triangle TopTier", "ваш бронированный треугольный фундамент"},
            { "wall.window TopTier", "ваше бронированное окно"},
            { "wall.half TopTier", "вашу бронированную полустену"},
            { "wall Wood", "вашу деревянную стену"},
            { "wall.low Wood", "вашу деревянную низкую стену"},
            { "wall.frame Wood", "ваш деревянный настенный каркас"},
            { "foundation Wood", "ваш деревянный фундамент"},
            { "roof Wood", "вашу деревянную крышу"},
            { "wall.doorway Wood", "ваш деревянный дверной проём"},
            { "foundation.steps Wood", "ваши деревянные ступеньки"},
            { "block.stair.lshape Wood", "вашу деревянную L-лестницу"},
            { "block.stair.ushape Wood", "вашу деревянную U-лестницу"},
            { "foundation.triangle Wood", "ваш деревянный треугольный фундамент"},
            { "wall.window Wood", "ваше деревянное окно"},
            { "door.hinged.metal", "вашу металлическую дверь"},
            { "floor Wood", "ваш деревянный пол"},
            { "floor Metal", "ваш металлический пол"},
            { "door.hinged.wood", "вашу деревянную дверь"},
            { "floor Stone", "ваш каменный пол"},
            { "door.double.hinged.wood", "вашу двойную деревянную дверь"},
            { "door.double.hinged.metal", "вашу двойную металлическую дверь"},
            { "shutter.wood.a", "ваши деревянные ставни"},
            { "wall.frame.garagedoor", "вашу гаражную дверь"},
            { "wall.window.bars.wood", "вашу деревянную решетку"},
            { "floor.triangle Stone", "ваш каменный треугольный потолок"},
            { "wall.external.high.wood", "ваши высокие деревянные ворота"},
            { "door.double.hinged.toptier", "вашу двойную бронированную дверь"},
            { "floor.triangle Metal", "ваш металлический треугольный потолок"},
            { "wall.frame.netting", "вашу сетчатую стену"},
            { "door.hinged.toptier", "вашу бронированную дверь"},
            { "shutter.metal.embrasure.a", "ваши металлические ставни"},
            { "wall.external.high.stone", "вашу высокую каменную стену"},
            { "gates.external.high.stone", "ваши высокие каменные ворота"},
            { "floor.ladder.hatch", "ваш люк с лестнице"},
            { "floor.grill", "ваш решетчатый настил"},
            { "floor.triangle Wood", "ваш деревянный треугольный потолок"},
            { "floor.triangle TopTier", "ваш бронированный треугольный потолок"},
            { "gates.external.high.wood", "ваши высокие деревянные ворота"},
            { "wall.half Wood", "вашу деревянную полустену"},
            { "floor TopTier", "ваш треугольный бронированный потолок"},
            { "wall.frame.cell", "вашу тюремную стену"},
            { "wall.window.bars.metal", "вашу металлическую решетку"},
            { "wall.frame.fence", "ваш сетчатый забор"},
            { "shutter.metal.embrasure.b", "вашу металлическую бойницу"},
            { "wall.window.glass.reinforced", "ваше окно из укрепленного стекла"},
            { "wall.frame.fence.gate", "вашу сетчатую дверь"},
            { "floor.frame Stone", "ваш каменный пол"},
            { "wall.frame.cell.gate", "вашу тюремную решетку"},
            { "floor.frame Metal", "ваш металический пол"},
            { "floor.frame Wood", "ваш деревянный пол" }
        };

        private static string[] _spisok = new string[] { "wall.external.high", "wall.external.high.stone", "gates.external.high.wood", "gates.external.high.stone", "wall.window.bars.metal", "wall.window.bars.toptier", "wall.window.glass.reinforced", "wall.window.bars.wood" };

        class POSITION
        {
            [JsonProperty("Нулевая точка")]
            public string zero;

            [JsonProperty("offsetmax")]
            public string offsetmax;

            [JsonProperty("offsetmin")]
            public string offsetmin;
        }

        class GUI
        {
            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Цвет фона")]
            public string background;

            [JsonProperty("Цвет нижней полоски")]
            public string footline;

            [JsonProperty("Цвет текста")]
            public string colortext;

            [JsonProperty("Размер текста")]
            public string sizetext;

            [JsonProperty("Время капсом?")]
            public bool timeupper;

            [JsonProperty("Расположение")]
            public POSITION position;
        }

        class MARKER
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Цвет маркера")]
            public string color1;

            [JsonProperty("Цвет обводки")]
            public string color2;

            [JsonProperty("Прозрачность")]
            public float alfa;

            [JsonProperty("Отображать круг?")]
            public bool circle;

            [JsonProperty("Отображать маркером взрыва?")]
            public bool boom;
        }

        class BLOCK
        {
            [JsonProperty("Телепорт")]
            public bool tp;

            [JsonProperty("Киты")]
            public bool kits;

            [JsonProperty("Трейд")]
            public bool trade;

            [JsonProperty("Строительство")]
            public bool build;

            [JsonProperty("Ремонт/улучшение/ремув - не плагином")]
            public bool ingame;

            [JsonProperty("Команды")]
            public string[] commands;

            [JsonProperty("Сообщение о блоке")]
            public string text;

            [JsonProperty("Можно строить/устанавливать во время блокировки [prefabId]")]
            public uint[] whitelist;
        }

        class VK
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("API от группы")]
            public string api;

            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Кд на отправку")]
            public float cooldown;

            [JsonProperty("Сообщение при входе игрока на сервер, при условии, что он не присоеденил свой вк")]
            public string message;
        }

        class Discord
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Кд на отправку")]
            public float cooldown;
        }

        class COMBATBLOCK
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Блокировать при попадании по игроку?")]
            public bool damageto;

            [JsonProperty("Блокировать при получении урона от игрока?")]
            public bool damagefrom;

            [JsonProperty("Блокировать команды")]
            public string[] blacklist;

            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Время блокировки")]
            public float blockseconds;

            [JsonProperty("Включить GUI?")]
            public bool enablegui;
        }

        class GAME
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Кд на отправку")]
            public float cooldown;
        }

        enum MES { rnmain, rndelete, notallow, rnmainadded, rnaddcooldown, rnadd, rnconfirm, rncancel, rnnocode, rnnovk, rnnewvk, rnprivate, rnerror, rnblack, rnerror2 }

        private class PluginConfig
        {
            [JsonProperty("Время блокировки")]
            public int blockseconds;

            [JsonProperty("Название сервера - для оповещений")]
            public string servername;

            [JsonProperty("Радиус")]
            public float radius;

            [JsonProperty("Снимать блокировку если вышел из рейд-зоны?")]
            public bool blockremove;

            [JsonProperty("Сброс рейдблока при смерти?")]
            public bool removedeath;

            [JsonProperty("Рейдблок установливается даже если на территории нет шкафа?")]
            public bool cupboard;

            [JsonProperty("Настройка маркера на карте")]
            public MARKER marker;

            [JsonProperty("Настройка GUI")]
            public GUI gui;

            [JsonProperty("Настройка блокировки")]
            public BLOCK block;

            [JsonProperty("Команда")]
            public string command;

            [JsonProperty("Настройка комбатблока")]
            public COMBATBLOCK combatblock;

            [JsonProperty("Оповещение о рейде в игре")]
            public GAME GAME;

            [JsonProperty("Оповещание о рейде в ВК")]
            public VK vk;

            [JsonProperty("Оповещание о рейде в Дискорд")]
            public Discord discord;

            [JsonProperty("Сообщения")]
            public Dictionary<MES, string> messages;

            [JsonProperty("Названия - для оповещаний")]
            public Dictionary<string, string> names;

            [JsonProperty("Дополнительный список на что кидать РБ")]
            public string[] spisok;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    blockseconds = 120,
                    radius = 75f,
                    blockremove = true,
                    servername = "HaxLite X10",
                    cupboard = false,
                    removedeath = false,
                    gui = new GUI
                    {
                        background = "0.4842625 0.1774008 0.1774008 0.3960784",
                        colortext = "1 1 1 0.7",
                        sizetext = "18",
                        timeupper = true,
                        footline = "0.9442612 0.5032899 0.5032899 1",
                        text = "БЛОКИРОВКА НА {time}",
                        position = new POSITION
                        {
                            zero = "0.5 0",
                            offsetmin = "-200 85",
                            offsetmax = "180 107"
                        }
                    },
                    marker = new MARKER
                    {
                        alfa = 0.6f,
                        color1 = "#FF0000",
                        color2 = "#000000",
                        enable = true,
                        boom = true,
                        circle = true
                    },
                    block = new BLOCK
                    {
                        build = true,
                        kits = true,
                        trade = true,
                        ingame = true,
                        tp = true,
                        commands = new string[] { "oo", "duel" },
                        whitelist = new uint[] { 2335812770, 2057881102, 1206527181, 2089327217, 2150203378 },
                        text = "<color=yellow>Вы находитесь в зоне рейд-блока!</color>"
                    },
                    vk = new VK
                    {
                        api = "",
                        cooldown = 1200f,
                        enable = true,
                        text = "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}",
                        message = "Вы не добавили свой Вк для оповещений о рейде\nВы можете это сделать командой <color=yellow>/rn add vk.com/ID</color>"
                    },
                    discord = new Discord
                    {
                        cooldown = 1200f,
                        enable = true,
                        text = "```Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}```"
                    },
                    combatblock = new COMBATBLOCK
                    {
                        enable = true,
                        blockseconds = 30f,
                        damagefrom = true,
                        damageto = true,
                        blacklist = new string[] { "tpr", "home", "tpa", "oo" },
                        text = "<color=yellow>Вы недавно стрелялись с другим игроком!</color>\nВы сможете использовать эту команду через <color=yellow>{time}</color>",
                        enablegui = true
                    },
                    GAME = new GAME
                    {
                        enable = true,
                        cooldown = 300f,
                        text = "<color=yellow>ВНИМАНИЕ! ВАШ ДОМ РЕЙДИТ ИГРОК {name}! КВАДРАТ {quad}</color>"
                    }, messages = new Dictionary<MES, string>
                    {
                        { MES.notallow, "У вас нет доступа к этой команде!" },
                        { MES.rnmain, "Что бы добавить оповещание о рейде в <color=yellow>ВК</color>.\nНапишите в чат: <color=yellow>/rn add vk.com/ID</color>\nПример: <color=yellow>/rn add vk.com/fermenspwnz</color>"},
                        { MES.rnmainadded, "Ваш ВК указан как: <color=#c6ec79>vk.com/{value}</color>\n<color=yellow>/rn delete</color> - отвязать ВК"},
                        { MES.rnaddcooldown, "Отправить новый код вы сможете через {time}"},
                        { MES.rnadd, "Введите в игре /rn accept {num}, для подтверджения аккаунта." },
                        { MES.rnconfirm, "<color=#c6ec79>Отлично! Ваш VK подтвержден!</color>"},
                        { MES.rncancel, "<color=yellow>Не верный код!</color>"},
                        { MES.rnnocode, "<color=yellow>Вы не указали код!</color>"},
                        { MES.rndelete, "<color=#c6ec79>Ваш VK успешно отвязан от игрового аккаунта!</color>"},
                        { MES.rnnovk, "<color=yellow>У вас нет привязаного к игровому аккаунту ВК!</color>"},
                        { MES.rnnewvk, "Вы указали VK: <color=yellow>{id}</color>\nВам в VK отправлено сообщение с кодом.\n<color=yellow>/rn accept <код></color> - подтвердить авторизацию."},
                        { MES.rnprivate, "Ваши настройки приватности не позволяют отправить вам сообщение (<color=#a2d953>{id}</color>)"},
                        { MES.rnerror, "Невозможно отправить сообщение.\nПроверьте правильность ссылки (<color=#a2d953>{id}</color>) или повторите попытку позже."},
                        { MES.rnblack, "Невозможно отправить сообщение.\nВы добавили группу в черный список или не подписаны на нее, если это не так, то просто напишите в группу сервера любое сообщение и попробуйте еще раз."},
                        { MES.rnerror2, "Вы указали неверный VK ID (<color=#a2d953>{id}</color>), если это не так, то просто напишите в группу сервера любое сообщение и попробуйте еще раз."}
                    },
                    names = _names,
                    spisok = _spisok,
                    command = "rn"
                };
            }
        }
        #endregion

        #region БЛОККОМАНД
        private object OnServerCommand(ConsoleSystem.Arg arg) => blocker(arg.Player(), arg.cmd.FullName);
        
        private object OnUserCommand(IPlayer ipplayer, string com, string[] args)
        {
            com = com.TrimStart('/').Substring(com.IndexOf(".", StringComparison.Ordinal) + 1);
            BasePlayer player = BasePlayer.Find(ipplayer.Id);
            return blocker(player, com);
        }

        private object blocker(BasePlayer player, string command)
        {
            if (player == null) return null;

            if (IsBlock.ContainsKey(player.userID))
            {
                if (config.block.commands.Contains(command))
                {
                    player.ChatMessage(config.block.text);
                    return false;
                }
            }

            COMBATBK cOMBATBK;
            if (HasCombatBlock(player) && player.TryGetComponent<COMBATBK>(out cOMBATBK) && cOMBATBK.tick > 0)
            {
                if (config.combatblock.blacklist.Contains(command))
                {
                    player.ChatMessage(config.combatblock.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(cOMBATBK.tick)).ToLower()));
                    return false;
                }
            }

            return null;
        }
        #endregion

        #region КОМБАТБЛОК
        private static List<ulong> combatblock = new List<ulong>();
        private bool HasCombatBlock(BasePlayer player)
        {
            return combatblock.Contains(player.userID) ? true : false;
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (info == null || info.HitEntity == null || IsNPC(attacker)) return;
            if (info.HitEntity is BasePlayer)
            {
                BasePlayer target = info.HitEntity.ToPlayer();
                if (target == null || IsNPC(target)) return;
                int block = (int)config.combatblock.blockseconds;
                if (config.combatblock.damageto)
                {
                    ADDCOMBATBLOCK(attacker, block);
                }
                if (config.combatblock.damagefrom)
                {
                    ADDCOMBATBLOCK(target, block);
                }
            }
        }

        private void ADDCOMBATBLOCK(BasePlayer player, int time, bool raidblock = false)
        {
            if (!raidblock && IsBlock.ContainsKey(player.userID)) return;
            COMBATBK cOMBATBK;
            if (!player.TryGetComponent<COMBATBK>(out cOMBATBK))
            {
                cOMBATBK = player.gameObject.AddComponent<COMBATBK>();
            }

            if(time > cOMBATBK.tick) cOMBATBK.tick = time;
            if (raidblock == true) cOMBATBK.ADDRAID();
        }

        class COMBATBK : MonoBehaviour
        {
            BasePlayer player;
            public int tick;
            public bool raidblock;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null)
                {
                    Destroy(this);
                    return;
                }
                raidblock = false;
                if (!combatblock.Contains(player.userID)) combatblock.Add(player.userID);
                InvokeRepeating(nameof(TICK), 1f, 1f);
            }

            public void ADDRAID()
            {
                if (ins.IsBlock.ContainsKey(player.userID)) ins.IsBlock.Remove(player.userID);
                ins.IsBlock.Add(player.userID, null);
                raidblock = true;
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIJSON.Replace("{text}", config.gui.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(tick)))));
            }

            private void TICK()
            {
                tick--;
                GameObject gameObject; 
                if (tick <= 0 || !raidblock && ins.IsBlock.TryGetValue(player.userID, out gameObject) && gameObject != null)
                {
                    Destroy(this);
                    return;
                }
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIJSON.Replace("{text}", config.gui.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(tick)))));
            }

            public void DoDestroy() => Destroy(this);

            private void OnDestroy()
            {
                if (IsInvoking(nameof(TICK))) CancelInvoke(nameof(TICK));
                if(combatblock.Contains(player.userID)) combatblock.Remove(player.userID);
                GameObject x;
                if (ins.IsBlock.TryGetValue(player.userID, out x))
                {
                    if (raidblock && x == null)
                    {
                        ins.IsBlock.Remove(player.userID);
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                    }
                }
                else
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                }
            }
        }


        /*
                private void REMOVECOMBATBLOCK(BasePlayer player)
                {
                    COMBATBLOCKER cOMBATBLOCKER;
                    if (!combatblock.TryGetValue(player, out cOMBATBLOCKER)) return;
                    if (!cOMBATBLOCKER.ttime.Destroyed) cOMBATBLOCKER.ttime.Destroy();
                    if (!IsBlock.Contains(player.userID)) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                }*/
        #endregion

        #region ИГРОК ВЫШЕЛ ИЗ СЕРВЕРА

        Dictionary<BasePlayer, GameObject> disconnected = new Dictionary<BasePlayer, GameObject>();

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            COMBATBK cOMBATBK;
            if (player.TryGetComponent<COMBATBK>(out cOMBATBK)) cOMBATBK.DoDestroy();
            GameObject gameObject;
            if (!IsBlock.TryGetValue(player.userID, out gameObject) || gameObject == null) return;
            ZONE zONE;
            if (!gameObject.TryGetComponent<ZONE>(out zONE)) return;
            disconnected[player] = gameObject;
            zONE.RemovePlayer(player);
        }
        #endregion

        #region GRID
        private static Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        private void CreateSpawnGrid()
        {
            Grids.Clear();
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (0.0066666666666667f * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz + 20f));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos)
        {
            return Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        }
        #endregion

        #region CONSOLECOMMAND
        [ConsoleCommand("vkintegra")]
        private void Cmdvkintegra(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            JObject vks = Interface.Oxide.DataFileSystem.ReadObject<JObject>("VKBotUsers");
            if (vks == null)
            {
                arg.ReplyWith("ДатаФайл VKBotUsers отсутсвует или пуст!");
            }
            int i = 0;
            foreach (var z in vks["VKUsersData"])
            {
                foreach (JObject obj in z)
                {
                    ulong userid = (ulong)obj["UserID"];
                    if (!VkPlayers.ContainsKey(userid))
                    {
                        VkPlayers.Add(userid, "id" + (string)obj["VkID"]);
                        i++;
                    }
                }
            }
            arg.ReplyWith($"Добавили {i} юзеров.");
            SaveVK();
        }
        #endregion
        private static RaidZone ins;
        private void Init()
        {
            ins = this;
            Unsubscribe(nameof(OnPlayerAttack));
            Unsubscribe(nameof(OnPlayerDeath));
            Unsubscribe(nameof(CanAffordUpgrade));
            Unsubscribe(nameof(OnStructureRepair));
            Unsubscribe(nameof(OnStructureDemolish));
        }

        private void OnServerInitialized()
        {
            if (config.spisok == null)
            {
                config.marker.circle = true;
                config.marker.boom = true;
                config.vk.message = "Вы не добавили свой Вк для оповещений о рейде\nВы можете это сделать командой <color=yellow>/rn add vk.com/ID</color>";
                config.spisok = _spisok;
                SaveConfig();
            }

            if (string.IsNullOrEmpty(config.command))
            {
                config.command = "rn";
                SaveConfig();
            }

            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand(config.command, this, "callcommandrn");

            #region НАСТРОЙКА КАПСА
            if (config.gui.timeupper)
            {
                m0 = m0.ToUpper();
                m1 = m1.ToUpper();
                m2 = m2.ToUpper();
                s0 = s0.ToUpper();
                s1 = s1.ToUpper();
                s2 = s2.ToUpper();
            }
            else
            {
                m0 = m0.ToLower();
                m1 = m1.ToLower();
                m2 = m2.ToLower();
                s0 = s0.ToLower();
                s1 = s1.ToLower();
                s2 = s2.ToLower();
            }
            #endregion

            #region НАСТРОЙКА GUI
            string raidtext = "{\"name\":\"RAIDTEXT\",\"parent\":\"RAIDFONE\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":{sizetext},\"align\":\"MiddleCenter\",\"color\":\"{colortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}".Replace("{sizetext}", config.gui.sizetext).Replace("{colortext}", config.gui.colortext);
            GUITEXT = "[" + raidtext + "]";
            GUIJSON = "[{\"name\":\"RAIDFONE\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{background}\"},{\"type\":\"RectTransform\",\"anchormin\":\"{zero}\",\"anchormax\":\"{zero}\",\"offsetmin\":\"{offsetmin}\",\"offsetmax\":\"{offsetmax}\"}]},{\"name\":\"BOTTOMSHIT\",\"parent\":\"RAIDFONE\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{footline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.05\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{raidtext}]".Replace("{background}", config.gui.background).Replace("{footline}", config.gui.footline).Replace("{zero}", config.gui.position.zero).Replace("{offsetmax}", config.gui.position.offsetmax).Replace("{offsetmin}", config.gui.position.offsetmin).Replace("{raidtext}", raidtext);
            #endregion

            #region НАСТРОЙКА МАРКЕРА
            if (!ColorUtility.TryParseHtmlString(config.marker.color1, out COLOR1))
            {
                Debug.LogError("ЦВЕТ МАРКЕРА НЕ В ФОРМАТЕ HEX!");
            }

            if (!ColorUtility.TryParseHtmlString(config.marker.color2, out COLOR2))
            {
                Debug.LogError("ЦВЕТ ОБВОДКИ МАРКЕРА НЕ В ФОРМАТЕ HEX!");
            }
            #endregion

            #region НАСТРОЙКА БЛОКИРОВКИ
            if (config.block.ingame)
            {
                Subscribe(nameof(CanAffordUpgrade));
                Subscribe(nameof(OnStructureRepair));
                Subscribe(nameof(OnStructureDemolish));
            }
            #endregion

            #region НАСТРОЙКА КОМБАТБЛОКА
            if (config.combatblock.enable) Subscribe(nameof(OnPlayerAttack));
            #endregion

            #region НАСТРОЙКА ОПОВЕЩЕНИЯ О РЕЙДЕ
            VkPlayers = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>("raidzone_vk");
            permission.RegisterPermission(permvk, this);
            if (config.vk.enable && string.IsNullOrEmpty(config.vk.api))
            {
                Debug.LogError("ВЫ ВКЛЮЧИЛИ ОПОВЕЩЕНИЕ ДЛЯ ВК, НО ПРИ ЭТОМ НЕ УКАЗАЛИ API ОТ ГРУППЫ!");
            }
            #endregion

            if (config.removedeath) Subscribe(nameof(OnPlayerDeath));

            if (config.names == null)
            {
                config.names = _names;
                SaveConfig();
            }
            CreateSpawnGrid();
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            timer.Once(0.1f, () =>
            {
                if (!player.IsConnected) return;
                COMBATBK cOMBATBK;
                if (player.TryGetComponent<COMBATBK>(out cOMBATBK)) cOMBATBK.DoDestroy();
                GameObject gameObject;
                if (!IsBlock.TryGetValue(player.userID, out gameObject) || gameObject == null) return;
                ZONE zONE;
                if (!gameObject.TryGetComponent<ZONE>(out zONE)) return;
                zONE.RemovePlayer(player);
            });
        }

        #region ОПОВЕЩЕНИЕ О РЕЙДЕ
        [PluginReference] private Plugin DiscordCore, HaxBot;
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info, Item item)
        {
            if (info == null || entity == null) return;
            BasePlayer player = info.InitiatorPlayer;
            if (player == null) return;
            if (entity is BuildingBlock)
            {
                int tt = (int)(entity as BuildingBlock).grade;
                if (tt <= 0) return;
                ServerMgr.Instance.StartCoroutine(GORAID(entity, player, tt));
            }
            else if(entity is AnimatedBuildingBlock || entity is SamSite || entity is AutoTurret || entity is DecayEntity && config.spisok.Contains(entity.ShortPrefabName))
            {
                ServerMgr.Instance.StartCoroutine(GORAID(entity, player));
            }
        }

        private IEnumerator GORAID(BaseCombatEntity entity, BasePlayer player, int tt = 0)
        {
            Vector3 position = entity.transform.position;
            string dname = entity.ShortPrefabName;
            if (tt == 1) dname += " Wood";
            else if (tt == 2) dname += " Stone";
            else if (tt == 3) dname += " Metal";
            else if (tt == 4) dname += " TopTier";
            BuildingPrivlidge priv = entity.GetBuildingPrivilege(entity.WorldSpaceBounds());
            yield return new WaitForEndOfFrame();
            if (priv != null && !priv.authorizedPlayers.Any(x => x.userid == player.userID))
            {
                CreateTrigger(position, config.blockseconds);
                yield return new WaitForEndOfFrame();
                string name = player.displayName;
                string quad = GetNameGrid(position);
                string connect = ConVar.Server.ip + ":" + ConVar.Server.port;

                string destroy;
                if (!config.names.TryGetValue(dname, out destroy))
                {
                    config.names.Add(dname, dname);
                    destroy = dname;
                    SaveConfig();
                }

                foreach (var z in priv.authorizedPlayers)
                {
                    ALERTPLAYER(z.userid, name, quad, connect, destroy);
                    yield return new WaitForEndOfFrame();
                }
            }
            else if (priv == null && config.cupboard)
            {
                CreateTrigger(position, config.blockseconds);
            }
            yield break;
        }

        class ALERT
        {
            public DateTime gamecooldown;
            public DateTime discordcooldown;
            public DateTime vkcooldown;
            public DateTime vkcodecooldown;
        }

        private static Dictionary<ulong, ALERT> alerts = new Dictionary<ulong, ALERT>();
        private static Dictionary<ulong, string> VkPlayers = new Dictionary<ulong, string>();

        private void ALERTPLAYER(ulong ID, string name, string quad, string connect, string destroy)
        {
            ALERT alert;
            if(!alerts.TryGetValue(ID, out alert))
            {
                alerts.Add(ID, new ALERT());
                alert = alerts[ID];
            }

            #region ОПОВЕЩЕНИЕ В ИГРЕ
            if (config.GAME.enable && alert.gamecooldown < DateTime.Now)
            {
                BasePlayer player = BasePlayer.FindByID(ID);
                if (player != null && player.IsConnected)
                {
                    player.ChatMessage(config.GAME.text.Replace("{name}", name).Replace("{quad}", quad).Replace("{destroy}", destroy));
                    alert.gamecooldown = DateTime.Now.AddSeconds(config.GAME.cooldown);
                }
            }
            #endregion
            #region ОПОВЕЩЕНИЕ В ДИСКОРДЕ
            if (config.discord.enable && alert.discordcooldown < DateTime.Now)
            {
                if (HaxBot != null) HaxBot.Call("SENDMESSAGE", ID, config.discord.text.Replace("{ip}", connect).Replace("{destroy}", destroy).Replace("{name}", name).Replace("{quad}", quad).Replace("{servername}", config.servername));
                else if (DiscordCore != null) DiscordCore.Call("SendMessageToUser", ID.ToString(), config.discord.text.Replace("{ip}", connect).Replace("{destroy}", destroy).Replace("{name}", name).Replace("{quad}", quad).Replace("{servername}", config.servername));
                alert.discordcooldown = DateTime.Now.AddSeconds(config.discord.cooldown);
            }
            #endregion
            #region ОПОВЕЩЕНИЕ В ВК
            if (config.vk.enable && alert.vkcooldown < DateTime.Now)
            {
                string vkid;
                if (VkPlayers.TryGetValue(ID, out vkid))
                {
                    GetRequest(vkid, config.vk.text.Replace("{ip}", connect).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername));
                    alert.vkcooldown = DateTime.Now.AddSeconds(config.vk.cooldown);
                }
            }
            #endregion
        }

        private object CanBuild(Planner plan, Construction prefab)
        {
            BasePlayer player = plan.GetOwnerPlayer();
           // Debug.Log(prefab.fullName + " - " + prefab.prefabID);
            if (player == null || !HasBlock(player.userID) || config.block.whitelist.Contains(prefab.prefabID) || prefab.fullName.Contains("assets/prefabs/building core/")) return null;
            player.ChatMessage(config.block.text);
            return false;
        }

        private void CreateTrigger(Vector3 position, int time)
        {
            ZONE oNE = GETZONE(position);
            if (oNE != null)
            {
                oNE.Refresh(config.blockseconds);
                return;
            }
            GameObject sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            sphere.transform.position = position;
            TriggerBase trigger = sphere.GetComponent<TriggerBase>() ?? sphere.gameObject.AddComponent<TriggerBase>();
            trigger.interestLayers = LayerMask.GetMask("Player (Server)");
            trigger.enabled = true;
            ZONE zONE = sphere.AddComponent<ZONE>();
            zONE.START(config.radius, time);
        }

        #region ВК
        class CODE
        {
            public string id;
            public ulong gameid;
        }

        private static Dictionary<string, CODE> VKCODES = new Dictionary<string, CODE>();

        private void callcommandrn(BasePlayer player, string command, string[] arg)
        {
            if (!config.vk.enable) return;
            bool vkaccess = permission.UserHasPermission(player.UserIDString, permvk);

            if (!vkaccess)
            {
                player.ChatMessage(config.messages[MES.notallow]);
                return;
            }
            if(arg == null || arg.Length == 0)
            {
                string vkid;
                if (!VkPlayers.TryGetValue(player.userID, out vkid))
                {
                    player.ChatMessage(config.messages[MES.rnmain]);
                }
                else
                {
                    player.ChatMessage(config.messages[MES.rnmainadded].Replace("{value}", vkid));
                }
                return;
            }
            string command1 = arg[0].ToLower();
            if (command1 == "add")
            {
                if (arg.Length > 1)
                {
                    ALERT aLERT;
                    if (alerts.TryGetValue(player.userID, out aLERT) && aLERT.vkcodecooldown > DateTime.Now)
                    {
                        player.ChatMessage(config.messages[MES.rnaddcooldown].Replace("{time}", FormatTime(aLERT.vkcodecooldown - DateTime.Now).ToLower()));
                        return;
                    }

                    string vkid = arg[1].ToLower().Replace("vk.com/", "").Replace("https://", "").Replace("http://", "");
                    string num = RANDOMNUM();
                    GetRequest(vkid, config.messages[MES.rnadd].Replace("{num}", num), player, num);
                }
            }else if (command1 == "accept")
            {
                if (arg.Length > 1)
                {
                    CODE cODE;
                    if (VKCODES.TryGetValue(arg[1], out cODE) && cODE.gameid == player.userID)
                    {
                        string vkid;
                        if(VkPlayers.TryGetValue(player.userID, out vkid))
                        {
                            vkid = cODE.id;
                        }
                        else
                        {
                            VkPlayers.Add(player.userID, cODE.id);
                        }
                        VKCODES.Remove(arg[1]);
                        player.ChatMessage(config.messages[MES.rnconfirm]);
                        SaveVK();
                    }
                    else
                    {
                        player.ChatMessage(config.messages[MES.rncancel]);
                    }
                }
                else
                {
                    player.ChatMessage(config.messages[MES.rnnocode]);
                }
            }
            else if (command1 == "delete")
            {
                if (VkPlayers.ContainsKey(player.userID))
                {
                    VkPlayers.Remove(player.userID);
                    player.ChatMessage(config.messages[MES.rndelete]);
                }
                else
                {
                    player.ChatMessage(config.messages[MES.rnnovk]);
                }
            }
        }

        private void GetRequest(string reciverID, string msg, BasePlayer player = null, string num = null) => webrequest.Enqueue("https://api.vk.com/method/messages.send?domain=" + reciverID + "&message=" + msg.Replace("#", "%23") + "&v=5.80&access_token=" + config.vk.api, null, (code2, response2) => ServerMgr.Instance.StartCoroutine(GetCallback(code2, response2, reciverID, player, num)), this);
        
        private IEnumerator GetCallback(int code, string response, string id, BasePlayer player = null, string num = null)
        {
            if (player == null) yield break;
            if (response == null || code != 200)
            {
                ALERT alert;
                if (alerts.TryGetValue(player.userID, out alert)) alert.vkcooldown = DateTime.Now;
                Debug.Log("НЕ ПОЛУЧИЛОСЬ ОТПРАВИТЬ СООБЩЕНИЕ В ВК! => обнулили кд на отправку");
                yield break;
            }
            yield return new WaitForEndOfFrame();
            if (!response.Contains("error"))
            {
                ALERT aLERT;
                if (alerts.TryGetValue(player.userID, out aLERT))
                {
                    aLERT.vkcodecooldown = DateTime.Now.AddMinutes(10);
                }
                else
                {
                    alerts.Add(player.userID, new ALERT {vkcodecooldown = DateTime.Now.AddMinutes(10) });
                }
                if (VKCODES.ContainsKey(num)) VKCODES.Remove(num);
                VKCODES.Add(num, new CODE { gameid = player.userID, id = id });
                player.ChatMessage(config.messages[MES.rnnewvk].Replace("{id}", id));
            }
            else if (response.Contains("PrivateMessage"))
            {
                player.ChatMessage(config.messages[MES.rnprivate].Replace("{id}", id));
            }
            else if(response.Contains("ErrorSend"))
            {
                player.ChatMessage(config.messages[MES.rnerror].Replace("{id}", id));
            }
            else if(response.Contains("BlackList"))
            {
                player.ChatMessage(config.messages[MES.rnblack]);
            }
            else
            {
                player.ChatMessage(config.messages[MES.rnerror2].Replace("{id}", id));
            }
            yield break;
        }
        #endregion
        #endregion

        #region HEADER
        private const string permvk = "raidzone.vk";
        private const string genericPrefab = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string raidPrefab = "assets/prefabs/tools/map/explosionmarker.prefab";
        private static string GUIJSON = "";
        private static string GUITEXT = "";
        private static Color COLOR1;
       
        private static Color COLOR2;
        private Dictionary<ulong, GameObject> IsBlock = new Dictionary<ulong, GameObject>();
        private static List<MapMarkerGenericRadius> mapMarkerGenericRadii = new List<MapMarkerGenericRadius>();
        #endregion

        #region ZONE - КЛАСС
        class ZONE : MonoBehaviour
        {
            private MapMarkerGenericRadius generic;
            private MapMarkerExplosion explosion;
            private SphereCollider sphere;
            private List<Network.Connection> ZONEPLAYERS = new List<Network.Connection>();

            public int seconds;

            void Awake()
            {
                sphere = GetComponent<SphereCollider>();
                if (sphere == null)
                {
                    Destroy(this);
                    Debug.Log("sphere null");
                    return;
                }
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "RaidZone";
                sphere.radius = config.radius;
                sphere.isTrigger = true;
                sphere.enabled = true;
            }

            public void START(float radius, int time)
            {
                if (sphere == null)
                {
                    Destroy(this);
                    Debug.Log("sphere null");
                    return;
                }

                seconds = time;
                InvokeRepeating(nameof(OneSecond), 0f, 1f);

                if (config.marker.enable)
                {
                    if (config.marker.boom)
                    {
                        explosion = (MapMarkerExplosion)GameManager.server.CreateEntity(raidPrefab, sphere.transform.position);
                        explosion.SetDuration(time);
                        explosion.enableSaving = false;
                        explosion.Spawn();
                        explosion.SendNetworkUpdate();
                    }

                    if (config.marker.circle)
                    {
                        generic = (MapMarkerGenericRadius)GameManager.server.CreateEntity(genericPrefab, sphere.transform.position);
                        generic.color1 = COLOR1;
                        generic.color2 = COLOR2;
                        generic.radius = radius / 145f;
                        generic.alpha = config.marker.alfa;
                        generic.enableSaving = false;
                        generic.Spawn();
                        generic.SendUpdate();
                        mapMarkerGenericRadii.Add(generic);
                    }
                }
            }

            public void Refresh(int time)
            {
                seconds = time;
            }

            private void OneSecond()
            {
                if (seconds <= 0)
                {
                    DoDestroy();
                    return;
                }

                string GUI = GUITEXT.Replace("{text}", config.gui.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(seconds))));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = ZONEPLAYERS }, null, "DestroyUI", "RAIDTEXT");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = ZONEPLAYERS }, null, "AddUI", GUI);
                seconds--;
            }

            public void AddPlayer(BasePlayer player)
            {
                if (!player.IsConnected || ZONEPLAYERS.Contains(player.net.connection)) return;

              /*  COMBATBK cOMBATBK;
                if (player.TryGetComponent<COMBATBK>(out cOMBATBK))
                {
                    cOMBATBK.DoDestroy();
                }*/

                GameObject x;
                if (ins.IsBlock.TryGetValue(player.userID, out x))
                {
                    if (!config.blockremove && x != null && x != gameObject)
                    {
                        ZONE zONE = x.GetComponent<ZONE>();
                        zONE.RemovePlayer(player, false);
                    }
                    else
                    {
                        ins.IsBlock.Remove(player.userID);
                    }
                }

                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIJSON.Replace("{text}", config.gui.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(seconds)))));
                ZONEPLAYERS.Add(player.net.connection);
                ins.IsBlock.Add(player.userID, gameObject);
             //   Debug.Log(player.displayName + " добавили");
            }

            public void RemovePlayer(BasePlayer player, bool newzone = true)
            {
                if (!player.IsConnected || !ZONEPLAYERS.Contains(player.net.connection)) return;
                ZONEPLAYERS.Remove(player.net.connection);
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                if (ins.IsBlock.ContainsKey(player.userID)) ins.IsBlock.Remove(player.userID);
                // Debug.Log(player.displayName + " удалили");
                if(newzone) Invoke(nameof(CHECKNEWZONE), 0.1f);
            }

            private void CHECKNEWZONE(BasePlayer player)
            {
                if (player == null || player.IsDead() || !player.IsConnected) return;
                ZONE zONE = GETZONE(player.transform.position);
                if (zONE == null) return;
                COMBATBK cOMBATBK;
                if (player.TryGetComponent<COMBATBK>(out cOMBATBK))
                {
                    cOMBATBK.DoDestroy();
                }
                zONE.AddPlayer(player);
            }

            public void DoDestroy()
            {
                UnityEngine.GameObject.Destroy(gameObject);
                Destroy(this);
            }

            private void OnDestroy()
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = ZONEPLAYERS }, null, "DestroyUI", "RAIDFONE");
                foreach(Network.Connection connection in ZONEPLAYERS)
                {
                    if (ins.IsBlock.ContainsKey(connection.userid)) ins.IsBlock.Remove(connection.userid);
                }
                ZONEPLAYERS.Clear();
                if (config.marker.enable)
                {
                    if(config.marker.circle) RemoveGeneric(generic);
                    if (config.marker.boom && !explosion.IsDestroyed) explosion.Kill();
                }
            }
        }

        private void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        {
            if (trigger == null || trigger.name != "RaidZone") return;
            BasePlayer player = entity.ToPlayer();
            if (player == null || IsNPC(player)) return;
            ZONE zONE = trigger.GetComponent<ZONE>();
            if (zONE == null) return;
            COMBATBK cOMBATBK;
            if (player.TryGetComponent<COMBATBK>(out cOMBATBK))
            {
                cOMBATBK.DoDestroy();
            }
            zONE.AddPlayer(player);
        }

        private void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
        {
            if (trigger == null || trigger.name != "RaidZone") return;
            BasePlayer player = entity.ToPlayer();
            if (player == null || IsNPC(player)) return;

            ZONE zONE = trigger.GetComponent<ZONE>();
            if (zONE == null) return;

            if (!config.blockremove) 
            {
                zONE.RemovePlayer(player, false);
                NextTick(() =>
                {
                    ADDCOMBATBLOCK(player, zONE.seconds, true);
                });
            }
            else
            {
                zONE.RemovePlayer(player);
            }
        }
        #endregion

        #region ПОРНО
        private bool HasBlock(ulong ID)
        {
            return IsBlock.ContainsKey(ID);
        }

        private bool HasBlockTera(Vector3 position)
        {
            return GETZONE(position) != null ? true : false;
        }

        private string CanTeleport(BasePlayer player)
        {
            if(!config.block.tp) return null;
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        private string canTeleport(BasePlayer player)
        {
            if (!config.block.tp) return null;
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        private int? CanBGrade(BasePlayer player, int grade, BuildingBlock block, Planner plan)
        {
            if (!HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return 0;
        }

        private string CanTrade(BasePlayer player)
        {
            if (!config.block.trade) return null;
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        private string canRemove(BasePlayer player)
        {
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        object canRedeemKit(BasePlayer player)
        {
            if (!config.block.kits) return null;
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        private bool? CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (!HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return false;
        }

        private object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (!HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return false;
        }

        private bool? OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (!HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return false;
        }

        object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player)
        {   
            if(player == null || !HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return null;
        }
        #endregion

        #region ХЕЛПЕРЫ
        private static ZONE GETZONE(Vector3 position)
        {
            List<SphereCollider> sphereColliders = new List<SphereCollider>();
            Vis.Colliders(position, 0.1f, sphereColliders);
            if (sphereColliders.Count > 0)
            {
                foreach (var z in sphereColliders)
                {
                    ZONE oNE = z.gameObject.GetComponent<ZONE>();
                    if (oNE == null) continue;
                    return oNE;
                }
            }
            return null;
        }

        private static void RemoveGeneric(MapMarkerGenericRadius mapMarker)
        {
            if (mapMarkerGenericRadii.Contains(mapMarker)) mapMarkerGenericRadii.Remove(mapMarker);
            if (!mapMarker.IsDestroyed) mapMarker.Kill();
        }

        private string RANDOMNUM() => Random.Range(1000, 99999).ToString();
        #endregion

        #region DISMOUNT
        private void CanDismountEntity(BasePlayer player, BaseMountable entity)
        {
            NextTick(() =>
            {
                if (!player.IsConnected) return;
                ZONE zONE = GETZONE(player.transform.position);
                if (zONE == null) return;
                zONE.AddPlayer(player);
            });
        }
        #endregion

        private void SaveVK()
        {
            if (VkPlayers.Count > 0) Interface.Oxide.DataFileSystem.WriteObject("raidzone_vk", VkPlayers);
        }

        private void Unload()
        {
            SaveVK();
            foreach (var z in mapMarkerGenericRadii.ToList())
            {
                RemoveGeneric(z);
            }

            foreach(ZONE zONE in UnityEngine.Object.FindObjectsOfType<ZONE>().ToList())
            {
                zONE.DoDestroy();
            }

            foreach (COMBATBK zONE in UnityEngine.Object.FindObjectsOfType<COMBATBK>().ToList())
            {
                zONE.DoDestroy();
            }

            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "RAIDFONE");
            combatblock.Clear();
            IsBlock.Clear();
            VKCODES.Clear();
            alerts.Clear();
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            timer.Once(0.1f, () =>
            {
                if (!player.IsConnected) return;
                ZONE zONE = GETZONE(player.transform.position);
                if (zONE == null)
                {
                    if (config.blockremove)
                    {
                        GameObject x;
                        if (IsBlock.TryGetValue(player.userID, out x))
                        {
                            if (x == null) return;
                            ZONE zONE2 = x.GetComponent<ZONE>();
                            zONE2.RemovePlayer(player, false);
                        }
                    }
                    return;
                }
                zONE.AddPlayer(player);
            });
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!player.IsConnected) return;

            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
            }
            if (config.vk.enable && !string.IsNullOrEmpty(config.vk.message) && permission.UserHasPermission(player.UserIDString, permvk) && !VkPlayers.ContainsKey(player.userID)) player.ChatMessage(config.vk.message);

            if (config.marker.enable) foreach (var z in mapMarkerGenericRadii) z.SendUpdate();

            GameObject gameObject;
            if(disconnected.TryGetValue(player, out gameObject) && gameObject != null)
            {
                ZONE zONE;
                if (!gameObject.TryGetComponent<ZONE>(out zONE)) return;
                zONE.AddPlayer(player);
                disconnected.Remove(player);
            }
        }

        private static bool IsNPC(BasePlayer player)
        {
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true;
            return false;
        }

        #region ВРЕМЯ
        private static string m0 = "МИНУТ";
        private static string m1 = "МИНУТЫ";
        private static string m2 = "МИНУТУ";

        private static string s0 = "СЕКУНД";
        private static string s1 = "СЕКУНДЫ";
        private static string s2 = "СЕКУНДУ";

        private static string FormatTime(TimeSpan time)
        => (time.Minutes == 0 ? string.Empty : FormatMinutes(time.Minutes)) + ((time.Seconds == 0) ? string.Empty : FormatSeconds(time.Seconds));

        private static string FormatMinutes(int minutes) => FormatUnits(minutes, m0, m1, m2);

        private static string FormatSeconds(int seconds) => FormatUnits(seconds, s0, s1, s2);

        private static string FormatUnits(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9 || tmp == 0)
                return $"{units} {form1} ";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2} ";

            return $"{units} {form3} ";
        }
        #endregion
    }
}


// --- End of file: RaidZone.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Portgun.cs ---
// --- Original Local Path: Portgun.cs ---

// Reference: RustBuild
using System.Collections.Generic;
using System;
using System.Reflection;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;


namespace Oxide.Plugins
{
    [Info("Portgun", "Reneb", "2.0.1")]
    class Portgun : RustPlugin
    {
        private FieldInfo serverinput;
        private int collLayers;
        
        void Loaded()
        {
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            if (!permission.PermissionExists(permissionPortgun)) permission.RegisterPermission(permissionPortgun, this);
        }
        void OnServerInitialized()
        {
            collLayers = UnityEngine.LayerMask.GetMask(new string[] { "Construction", "Deployed", "Tree", "Terrain", "Resource", "World", "Water", "Default" });
        }

        private static string permissionPortgun = "canportgun";
        private static int authLevel = 2;
         
        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<int>("Configure - Admin Level", ref authLevel);
            CheckCfg<string>("Configure - Permission", ref permissionPortgun);
            SaveConfig();
        }

        bool hasAccess( BasePlayer player )
        {
            if (player.net.connection.authLevel >= authLevel) return true;
            return permission.UserHasPermission(player.userID.ToString(), permissionPortgun);
        }

        [ChatCommand("p")]
        void cmdChatPortgun(BasePlayer player, string command, string[] args)
        {
            if(!hasAccess(player))
            {
                SendReply(player, "You are not allowed to use this command");
                return;
            }
            RaycastHit hitInfo;
            if(!UnityEngine.Physics.Raycast(player.eyes.HeadRay(), out hitInfo, Mathf.Infinity, collLayers))
            {
                SendReply(player, "Couldn't find a destination");
                return;
            }
            Debug.Log(hitInfo.point.ToString());
            Debug.Log(hitInfo.distance.ToString());
            player.MovePosition(hitInfo.point);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", hitInfo.point, null, null, null, null);
        }
    }
}

// --- End of file: Portgun.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GoldenFish.cs ---
// --- Original Local Path: GoldenFish.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("GoldenFish", "Mercury & DezLife", "1.0.831")]
    [Description("RF")]
    class GoldenFish : RustPlugin
    {    
        #region CONFIG

        public class CustomItem
        {
            [JsonProperty("Отображаемое имя", Order = 0)]
            public string DisplayName;
            [JsonProperty("Этот парамтр менять не нужно", Order = 1)]
            public string ShortName;

            [JsonProperty("Шанс выпадения", Order = 2)]
            public int DropChance;
            [JsonProperty("Кол-вл выпадения", Order = 3)]
            public int DropAmount;

            [JsonProperty("Скин ID рыбки", Order = 4)]
            public ulong SkinId = 1686591036;

            [JsonProperty("Призы за переработку", Order = 5)]
            public List<ItemGiveInfo> GiveItems = new List<ItemGiveInfo>();

            public Item Copy(int amount = 1)
            {
                Item x = ItemManager.CreateByPartialName(ShortName, amount);
                x.skin = SkinId;
                x.name = DisplayName;

                return x;
            }

            public Item CreateItem(int amount)
            {
                Item item = ItemManager.CreateByPartialName(ShortName, amount);
                item.name = DisplayName;
                item.skin = SkinId;
                return item;
            }
        }

        public class ItemGiveInfo
        {
            [JsonProperty("Шортнейм предмета")] public string shortname;
            [JsonProperty("СкинИД предмета")] public ulong skinID;
            [JsonProperty("Минимальное количество предметов")] public int Minamount;
            [JsonProperty("Максимальное количество предметов")] public int Maxamount;
        }


        private Configuration _CFG;

        public class Configuration
        {
            [JsonProperty("Настройка плагина")]
            public CustomItem customItem = new CustomItem();
        }
        protected override void LoadDefaultConfig()
        {
            _CFG = new Configuration()
            {
                customItem =  new CustomItem
                {
                    DisplayName = "Золотая рыбка",
                    ShortName = "fish.troutsmall",
                    DropChance = 30,
                    DropAmount = 1,
                    SkinId = 1686591036,
                    GiveItems = new List<ItemGiveInfo>
                    {
                         new ItemGiveInfo
                         {
                             shortname = "stones",
                             skinID = 0U,
                             Minamount = 100,
                             Maxamount = 2000
                         },
                         new ItemGiveInfo
                         {
                             shortname = "metal.refined",
                             skinID = 0U,
                             Minamount = 50,
                             Maxamount = 100
                         },
                         new ItemGiveInfo
                         {
                             shortname = "rifle.m39",
                             skinID = 0U,
                             Minamount = 1,
                             Maxamount = 1
                         },
                         new ItemGiveInfo
                         {
                             shortname = "explosive.satchel",
                             skinID = 0U,
                             Minamount = 1,
                             Maxamount = 3
                         },
                         new ItemGiveInfo
                         {
                             shortname = "surveycharge",
                             skinID = 0U,
                             Minamount = 1,
                             Maxamount = 5
                         },
                    }
                }          
            };
            SaveConfig(_CFG);
        }

        void SaveConfig(Configuration config)
        {
            Config.WriteObject(config, true);
            SaveConfig();
        }

        public void LoadConfigVars()
        {
            _CFG = Config.ReadObject<Configuration>();
            Config.WriteObject(_CFG, true);
        }
        #endregion

        #region command

        [ChatCommand("gf.give")]
        private void CmdChatDebugGoldfSpawn(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
                var item = _CFG.customItem.CreateItem(100);
                item.MoveToContainer(player.inventory.containerMain);
            
        }

        #endregion

        #region hooks
        void OnServerInitialized()
        {
            LoadConfigVars();
            PrintWarning($"--------------------------------- -");
            PrintWarning($"             GoldenFish            ");
            PrintWarning($"     Author = Mercury & DezLife    ");
            PrintWarning($"        vk.com/skyeyeplugins       ");
            PrintWarning($"         Version = {Version}       ");
            PrintWarning($"-----------------------------------");
        }

        private Item OnItemSplit(Item item, int amount)
        {
            var customItem = _CFG.customItem;
            if (customItem.SkinId == item.skin)
            {
                if (customItem != null)
                {
                    Item x = ItemManager.CreateByPartialName(customItem.ShortName, amount);
                    x.name = customItem.DisplayName;
                    x.skin = customItem.SkinId;
                    x.amount = amount;

                    item.amount -= amount;
                    return x;
                }
            }
            return null;
        }

        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem().skin != targetItem.GetItem().skin)
            if (item.GetItem().skin == _CFG.customItem.SkinId || targetItem.GetItem().skin == _CFG.customItem.SkinId) return false;
            return null;
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin)
            if (item.skin == _CFG.customItem.SkinId || targetItem.skin == _CFG.customItem.SkinId) return false;
            return null;
        }

        #endregion

        List<ulong> Players = new List<ulong>();
        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container.ShortPrefabName == "survivalfishtrap.deployed")
            {
                if (Players.Contains(container.net.ID)) return null;
                Players.Add(container.net.ID);
                container.SetFlag(BaseEntity.Flags.Busy, true);
            }
            return null;
        }

        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (entity.ShortPrefabName == "survivalfishtrap.deployed")
            {
                if (Players.Contains(entity.net.ID))
                {
                    Players.Remove(entity.net.ID);
                    entity.SetFlag(BaseEntity.Flags.Busy, false);
                }
            }
        }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container.entityOwner == null) return;
            if (container.entityOwner.ShortPrefabName == "survivalfishtrap.deployed" && item.info.shortname == "fish.troutsmall")
            {
                if (Players.Contains(container.entityOwner.net.ID)) return;

                bool goodChance = UnityEngine.Random.Range(0, 100) >= (100 - _CFG.customItem.DropChance);
                if (goodChance)
                {
                    item.skin = _CFG.customItem.SkinId;
                    item.name = _CFG.customItem.DisplayName;
                }    
            }
        }

        object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (item == null || action == null || action == "")
                return null;
            if (item.info.shortname != "fish.troutsmall")
                return null;
            if (action != "Gut")
                return null;
            if (player == null)
                return null;
            if (_CFG.customItem.SkinId != item.skin) return null;

            var iteItemsGives = _CFG.customItem.GiveItems;

            int RandomItem = UnityEngine.Random.Range(0, _CFG.customItem.GiveItems.Count);
            Item itemS = ItemManager.CreateByName(iteItemsGives[RandomItem].shortname, UnityEngine.Random.Range(iteItemsGives[RandomItem].Minamount, iteItemsGives[RandomItem].Maxamount), iteItemsGives[RandomItem].skinID);

            if (!player.inventory.containerMain.IsFull()) itemS.MoveToContainer(player.inventory.containerMain);
            else player.GiveItem(itemS, BaseEntity.GiveItemReason.Generic);
            ItemRemovalThink(item, player, 1);
            return false;

        }
        private static void ItemRemovalThink(Item item, BasePlayer player, int itemsToTake)
        {
            if (item.amount == itemsToTake)
            {
                item.RemoveFromContainer();
                item.Remove();
            }
            else
            {
                item.amount = item.amount - itemsToTake;
                player.inventory.SendSnapshot();
            }
        }
    }
}


// --- End of file: GoldenFish.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPWipeBlock.cs ---
// --- Original Local Path: TPWipeBlock.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TPWipeBlock", "Sempai#3239", "5.0.0")]
    class TPWipeBlock : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary, Duel, ArenaTournament;
        private static ConfigData config;
        private string CONF_IgnorePermission = "block.ignore";
        private class ConfigData
        {
            [JsonProperty("Настройки от мазепы")] public List<WeaponData> weaponDatas;

            [JsonProperty(PropertyName = "Начало отрисовки столбцов(требуется для центрирования)")]
            public float StartUI = 0.288f;
            [JsonProperty(PropertyName = "Информация плагина")]
            public string Info = "Ахуенный плагин скилов всем советую, а кто не купит, тот гомосек";
            [JsonProperty(PropertyName = "Блокировка предметов")]
            public Dictionary<int, List<string>> items;
        }
        public class WeaponData
        {
            [JsonProperty("Префаб оружия")] public string Prefab;
            [JsonProperty("Длительность перезарядки оружия")] public float ReloadInSeconds;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                weaponDatas = new List<WeaponData>()
                {
                    new WeaponData
                    {
                        Prefab = "assets/prefabs/weapons/semi auto rifle/semi_auto_rifle.entity.prefab",
                        ReloadInSeconds = 5
                    },
                    new WeaponData
                    {
                        Prefab = "assets/prefabs/weapons/ak47u/ak47u.entity.prefab",
                        ReloadInSeconds = 5
                    },
                    new WeaponData
                    {
                        Prefab = "assets/prefabs/weapons/ak47u/iceskin/ak47u_ice.entity.prefab",
                        ReloadInSeconds = 5
                    }
                },

                items = new Dictionary<int, List<string>>
                {
                    [7200] = new List<string>()
                    {
                       "crossbow",
                       "shotgun.waterpipe",
                       "flamethrower",
                       "bucket.helmet",
                       "pistol.revolver",
                       "riot.helmet"
                    },
                    [14400] = new List<string>()
                    {
                        "pistol.python",
                        "pistol.semiauto",
                        "shotgun.double",
                        "coffeecan.helmet",
                        "pistol.m92",
                        "roadsign.jacket"
                    },
                    [21600] = new List<string>()
                    {
                        "rifle.semiauto",
                        "shotgun.pump",
                        "smg.2",
                        "smg.mp5",
                        "smg.thompson",
                        "shotgun.spas12"
                    },
                    [36000] = new List<string>()
                    {
                        "rifle.m39",
                        "metal.facemask",
                        "rifle.bolt",
                        "grenade.f1",
                        "hmlmg",
                        "metal.plate.torso"
                    },
                    [64800] = new List<string>()
                    {
                        "heavy.plate.helmet",
                        "heavy.plate.jacket",
                        "heavy.plate.pants",
                        "rifle.ak.ice",
                        "metal.plate.torso.icevest",
                        "metal.facemask.icemask"
                    },
                    [86400] = new List<string>()
                    {
                        "rifle.ak",
                        "rifle.lr300",
                        "rifle.l96",
                        "grenade.beancan",
                        "explosive.satchel",
                        "ammo.rifle.explosive"
                    },
                    [1008000] = new List<string>()
                    {
                        "lmg.m249",
                        "rocket.launcher",
                        "explosive.timed",
                        "rifle.ak.diver",
                        "multiplegrenadelauncher",
                        "homingmissile.launcher"
                    },
                }
            };
        }


        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private object CanWearItem(PlayerInventory inventory, Item item)
        {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (!player.userID.IsSteamId())
            {
                return null;
            }
            if (playerOnDuel(player)) return null;

            if (permission.UserHasPermission(player.UserIDString, CONF_IgnorePermission))
                return null;

            var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                    return null;

                MessBlockUi(player, item.info.shortname);
                timer.Once(0.8f, () =>
                {
                    CuiHelper.DestroyUi(player, Layer);
                });
            }
            return isBlocked;
        }

        private object CanEquipItem(PlayerInventory inventory, Item item)
        {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            if (playerOnDuel(player)) return null;

            if (permission.UserHasPermission(player.UserIDString, CONF_IgnorePermission))
                return null;

            var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                    return null;
                MessBlockUi(player, item.info.shortname);
                timer.Once(3.8f, () =>
                {
                    CuiHelper.DestroyUi(player, Layer);
                });
            }
            return isBlocked;
        }

        private object OnWeaponReload(BaseProjectile weapon, BasePlayer player)
        {
            return OnMagazineReload(weapon, 0, player);
        } 


        object OnMagazineReload(BaseProjectile projectile, int desiredAmount, BasePlayer player)
        {
            if (!player.userID.IsSteamId())
            {
                return null;
            }
            if (playerOnDuel(player)) return null;

            if (permission.UserHasPermission(player.UserIDString, CONF_IgnorePermission))
                return null;

            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType.shortname) > 0 ? false : (bool?)null;
            

            NextTick(() =>
            {
                if (isBlocked == false)
                {
                    projectile.primaryMagazine.contents = 0;
                    projectile.SendNetworkUpdate();
                    player.SendNetworkUpdate();
                    MessBlockUi(player, projectile.primaryMagazine.ammoType.shortname);
                    timer.Once(2f, () =>
                    {
                        CuiHelper.DestroyUi(player, Layer);
                    });
                }
            });

            WeaponData weaponData = TryGetWeaponData(projectile.PrefabName);
            if (weaponData != null)
            {
                timer.Once(weaponData.ReloadInSeconds, () =>
                {
                    var isBlockedTwo = IsBlocked(projectile.primaryMagazine.ammoType.shortname) > 0;
                    NextTick(() =>
                    {
                        if (isBlockedTwo)
                        {
                            if (projectile.primaryMagazine.contents != 0)
                            {
                                Item bullets = ItemManager.CreateByName(projectile.primaryMagazine.ammoType.shortname, projectile.primaryMagazine.contents);
                                if (bullets != null && player != null)
                                    player.GiveItem(bullets);
                            }
                            else
                            {
                                return;
                            }


                            projectile.primaryMagazine.contents = 0;
                            projectile.SendNetworkUpdate();
                            player.SendNetworkUpdate();
                            MessBlockUi(player, projectile.primaryMagazine.ammoType.shortname);
                            timer.Once(2f, () =>
                            {
                                CuiHelper.DestroyUi(player, Layer);
                            });
                        }
                    });
                });
            }

            return isBlocked;
        }

        private WeaponData TryGetWeaponData(string prefab) => config.weaponDatas.Where(p => p.Prefab == prefab).FirstOrDefault();

        private bool playerOnDuel(BasePlayer player)
        {
            if (plugins.Find("ArenaTournament") && (bool)plugins.Find("ArenaTournament").Call("IsOnTournament", player.userID)) return true;
            if (plugins.Find("Duel") && (bool)plugins.Find("Duel").Call("IsPlayerOnActiveDuel", player)) return true;
            if (plugins.Find("OneVSOne") && (bool)plugins.Find("OneVSOne").Call("IsEventPlayer", player)) return true;
            return false;
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(CONF_IgnorePermission, this);
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_bg.png", "fonblock");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_items.png", "backgrounditems");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_block1.png", "block_1");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_block2.png", "block_2");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_block3.png", "block_3");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_block4.png", "block_4");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_block5.png", "block_5");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_block6.png", "block_6");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/wipeblock_lock.png", "castleimage");
            ImageLibrary.Call("AddImage", "https://i.imgur.com/BeBP63b.png", "fonDescription");
            foreach (var check in config.items.SelectMany(p => p.Value))
                ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{check}.png", check);
        }

        private void MessBlockUi(BasePlayer player, string shortname)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat("#534E489E") },
                RectTransform =
                     {AnchorMin = "0.5 0.9", AnchorMax = "0.5 0.9", OffsetMin = "-120 -25", OffsetMax = "120 50"},
                CursorEnabled = false,
            }, "Overlay", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".BlockItem",
                Components =
                 {
                     new CuiImageComponent {Color = "1 1 1 0.1"},
                     new CuiRectTransformComponent { AnchorMin = "0.01586128 0.05839238", AnchorMax = "0.2891653 0.9208925" }
                 }
            });

            container.Add(new CuiElement
            {
                Parent = Layer + ".BlockItem",
                Components =
                 {
                     new CuiRawImageComponent
                     {
                         Png = (string) ImageLibrary.Call("GetImage", $"{shortname}")
                     },
                     new CuiRectTransformComponent
                         {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 1", OffsetMax = "-5 -1"}
                 }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                 {
                     new CuiTextComponent()
                     {
                         Color = "1 1 1 1",
                         Text = "Предмет заблокирован, для получения дополнительной информации пишите /block",
                         FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"
                     },
                     new CuiRectTransformComponent {AnchorMin = "0.3204 0.0833925", AnchorMax = "0.9802345 0.9458925"},
                 }
            });

            CuiHelper.AddUi(player, container);
        }

        private const string Layer = "lay";
        void BlockUi(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = Layer + ".Main",
                Parent = ".Mains",
                Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonblock"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.78 0.805", AnchorMax = "0.795 0.833", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "blockdesc" },
                Text = { Text = "?", Color = "1 1 1 0.7", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Main");

            float width = 0.05f, height = 0.5f, startxBox = config.StartUI, startyBox = 0.71f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in config.items)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "2 1", OffsetMax = "-2 -1" },
                    Image = { Color = "0 0 0 0" }
                }, Layer + ".Main", "Items");
                xmin += width + 0.012f;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }

                float width1 = 1f, height1 = 0.156f, startxBox1 = 0f, startyBox1 = 1f - height1, xmin1 = startxBox1, ymin1 = startyBox1;
                foreach (var item in check.Value)
                {
                    var color = IsBlocked(item) > 0 ? "1 1 1 0.2" : "1 1 1 1";
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = xmin1 + " " + ymin1, AnchorMax = (xmin1 + width1) + " " + (ymin1 + height1 * 1), OffsetMax = "0 0" },
                        Image = { Color = "0 0 0 0" }
                    }, "Items", "Settings");
                    xmin1 += width1;
                    if (xmin1 + width1 >= 1)
                    {
                        xmin1 = startxBox1;
                        ymin1 -= height1 + 0.013f;
                    }

                    container.Add(new CuiElement
                    {
                        Parent = "Settings",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "backgrounditems"), FadeIn = 1f },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                        }
                    });

                    container.Add(new CuiElement
                    {
                        Parent = "Settings",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item), Color = color, FadeIn = 1f },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 10", OffsetMax = "-10 -10" }
                        }
                    });
                }
                var block = check.Value.Count() == 6 ? "block_6" : check.Value.Count() == 5 ? "block_5" : check.Value.Count() == 4 ? "block_4" : check.Value.Count() == 3 ? "block_3" : check.Value.Count() == 2 ? "block_2" : "block_1";
                var anchors = check.Value.Count() == 6 ? "0" : check.Value.Count() == 5 ? "0.17" : check.Value.Count() == 4 ? "0.335" : check.Value.Count() == 3 ? "0.505" : check.Value.Count() == 2 ? "0.675" : "0.843";
                if (IsBlocked(check.Value.ElementAt(0)) > 0)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Items",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", block), FadeIn = 1f },
                            new CuiRectTransformComponent { AnchorMin = $"0 {anchors}", AnchorMax = $"1 1", OffsetMin = "-6 -6", OffsetMax = "6 6" }
                        }
                    });
                }

                var anchortext = check.Value.Count() == 6 ? "6.1" : check.Value.Count() == 5 ? "5" : check.Value.Count() == 4 ? "4" : check.Value.Count() == 3 ? "2.8" : check.Value.Count() == 2 ? "1.8" : "0.65";
                var text = IsBlocked(check.Value.ElementAt(0)) > 0 ? $"{FormatShortTime(TimeSpan.FromSeconds(IsBlocked(check.Value.ElementAt(0))))}" : "";
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 {anchortext}", OffsetMax = "0 0" },
                    Text = { Text = text, Color = "1 1 1 0.8", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
                }, "Settings");

                var offmin = check.Value.Count() == 6 ? 2.95f : check.Value.Count() == 5 ? 2.34f : check.Value.Count() == 4 ? 1.85 : check.Value.Count() == 3 ? 1.25 : check.Value.Count() == 2 ? 0.76 : 0.15;
                if (IsBlocked(check.Value.ElementAt(0)) > 0)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Settings",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "castleimage"), Color = "1 1 1 1", FadeIn = 1f },
                            new CuiRectTransformComponent { AnchorMin = $"0.37 {offmin + 0.33}", AnchorMax = $"0.63 {offmin + 0.67}", OffsetMax = $"0 0" }
                        }
                    });
                }
            }

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("blockdesc")]
        void DescUI(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            CuiHelper.DestroyUi(player, Layer + ".Main" + ".Description");
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = Layer + ".Main" + ".Description",
                Parent = Layer + ".Main",
                Components = {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonDescription") },
                    new CuiRectTransformComponent { AnchorMin = $"0.58 0.6", AnchorMax = $"0.8 0.8" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.9 1" },
                Text = { Text = $"Описание блокировки", Color = "1 1 1 0.65", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, Layer + ".Main" + ".Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0", AnchorMax = "1 0.7" },
                Text = { Text = $"{config.Info}", Color = "1 1 1 0.65", FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, Layer + ".Main" + ".Description");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9 0.82", AnchorMax = "0.98 0.98" },
                Button = { Close = Layer + ".Main" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, Layer + ".Main" + ".Description");

            CuiHelper.AddUi(player, container);
        }

        private double IsBlocked(string shortName)
        {
            if (!config.items.SelectMany(p => p.Value).Contains(shortName))
                return 0;
            var blockTime = config.items.FirstOrDefault(p => p.Value.Contains(shortName)).Key;
            var lefTime = (UnBlockTime(blockTime)) - CurrentTime();
            return lefTime > 0 ? lefTime : 0;
        }

        private bool BlockTimeGui(string shortName)
        {
            var blockTime = config.items.FirstOrDefault(p => p.Value.Contains(shortName)).Key;
            var lefTime = (UnBlockTime(blockTime)) - CurrentTime();
            if (lefTime > 0)
            {
                return true;
            }

            return false;
        }
        private double UnBlockTime(int amount) => SaveRestore.SaveCreatedTime.ToUniversalTime().Subtract(epoch).TotalSeconds + amount;
        private double IsBlocked(ItemDefinition itemDefinition) => IsBlocked(itemDefinition.shortname);
        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
            {
                result = $"{time.Days.ToString("00")}:";
            }
            result += $"{time.Hours.ToString("00")}:";
            result += $"{time.Minutes.ToString("00")}";
            return result;
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
    }
}

// --- End of file: TPWipeBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AimTrain.cs ---
// --- Original Local Path: AimTrain.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections;
using Oxide.Game.Rust.Cui;
using UI = Oxide.Plugins.AimTrainUI.UIMethods;
using Anchor = Oxide.Plugins.AimTrainUI.Anchor;

namespace Oxide.Plugins
{
    [Info("AimTrain", "iAciid", "1.1.2")]
    public class AimTrain : RustPlugin
    {
        #region Declaration

        [PluginReference]
        Plugin Kits, NoEscape;
        Configuration config;
        StoredData storedData;
        Dictionary<string, Arena> ArenasCache = new Dictionary<string, Arena>();
        Dictionary<ulong, PlayerData> PlayersCache = new Dictionary<ulong, PlayerData>();
        Dictionary<ulong, string> EditArena = new Dictionary<ulong, string>();
        List<ulong> NoAmmo = new List<ulong>();
        public static AimTrain Instance;
        string MainContainer = "Main.Container";
        string StatsContainer = "Stats.Container";
        CuiElementContainer CachedContainer;

        #endregion

        #region Config

        public class Configuration
        {
            [JsonProperty(PropertyName = "Enable AimTrain")]
            public bool EnableAimTrain = true;
            [JsonProperty(PropertyName = "Use permissons for Arena")]
            public bool ArenaPermission = false;
            [JsonProperty(PropertyName = "Needs empty inventory to join")]
            public bool IgnoreInv = true;
            [JsonProperty(PropertyName = "Enable UI")]
            public bool EnableUI = true;
            [JsonProperty(PropertyName = "Use NoEscape Raid/Combatblock")]
            public bool UseNoEscape = false;
            [JsonProperty(PropertyName = "Bot Names")]
            public List<string> BotNames;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    BotNames = new List<string>()
                    {
                        "Bot1",
                        "Bot2",
                        "Bot3"
                    },
                };
            }

        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintWarning($"Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ClearInv"] = "Please clear your inventory before you join AimTrain.",
                ["JoinAT"] = "You've joined AimTrain! Use /at to leave.",
                ["LeaveAT"] = "You've left AimTrain.",
                ["SpawnBot"] = "Created a new Bot spawn point({0}).",
                ["SpawnPlayer"] = "Created the spawn point for players({0}).",
                ["ATAdmin"] = string.Join("\n", new[]{
                    "<size=16><color=#4286f4>AimTrain</color></size>",
                    "/aimtrain add <name> - <i>Create a Arena</i>",
                    "/at_edit <name> - <i>to edit a Arena</i>",
                    "/aimtrain delete <name> - <i>Delete a Arena</i>",
                    "/aimtrain list - <i>See all Arenas</i>",
                    "/aimtrain info <name> - <i>See the settings for your Arena</i>",
                    "/aimtrain sbot - <i>Set spawn points for bots</i>",
                    "/aimtrain splayer - <i>Set spawn points for players)</i>",
                    "/aimtrain botkit <name> - <i>Add a kit for the Bots</i>",
                    "/aimtrain playerkit <name> - <i>Add a kit for the players</i>",
                    "/aimtrain movement - <i>Enable bot moving</i>",
                    "/aimtrain enable - <i>Enable AimTrain</i>",
                    "/aimtrain botcount <amount> - <i>Change the amount of bots in the Arena</i>"}),
                ["EnableAimTrain"] = "AimTrain enabled: {0}",
                ["ErrorSpawns"] = "No spawn points for players set.",
                ["ErrorSpawnsbot"] = "You don't have spawn points for bots set {0} / 2.",
                ["CantWhileAimTrain"] = "You cant perform this action while you are in AimTrain.",
                ["NoPerm"] = "You don't have permissions to join this Arena!",
                ["ArenaExist"] = "This Arena already exists!",
                ["ArenaNotExisting"] = "This Arena doesn't exist, use /aimtrain add to create a Arena.",
                ["EditArena"] = "You are now editing Arena: {0}.",
                ["NotEditingArena"] = "You aren't editing a Arena, use /at_edit <name> in order to do so",
                ["ArenaCreated"] = "You created a new Arena called: {0}.",
                ["ArenaDeleted"] = "You deleted the Arena: {0}.",
                ["InvalidName"] = "Not a valid Arena Name.",
                ["ClearBotKit"] = "You cleared all Bot Kits.",
                ["ClearBotSpawns"] = "You cleared all spawn points for the Bots!",
                ["ClearPlayerSpawns"] = "You cleared all spawn points for the Players!",
                ["AddedBotKit"] = "You added the Kit <i>{0}</i> to the Bot Kits.",
                ["AddedPlayerKit"] = "You changed the Player Kit to <i>{0}</i>."
            }, this);
        }

        #endregion

        #region Data

        public class Position
        {
            public float PosX;
            public float PosY;
            public float PosZ;

            public Position()
            {
            }

            public Position(float x, float y, float z)
            {
                PosX = x;
                PosY = y;
                PosZ = z;
            }

            public Vector3 ToVector3()
            {
                return new Vector3(PosX, PosY, PosZ);
            }
        }

        public class Arena
        {
            public bool Enabled = true;
            public string PlayerKit = "Player Kit";
            public List<string> Kits = new List<string>();
            public int BotCount = 5;
            public bool BotMoving = true;
            public Dictionary<int, Position> SpawnsBot = new Dictionary<int, Position>();
            public Dictionary<int, Position> SpawnsPlayer = new Dictionary<int, Position>();

            [JsonIgnore]
            public int Players;

            public Arena()
            {
            }
        }

        public class PlayerData
        {
            public string Arena;
            public Position position;
            public int Hits;
            public int Bullets;
            public int Headshots;

            public PlayerData()
            {
            }
        }

        public class StoredData
        {
            public Dictionary<string, Arena> Arenas = new Dictionary<string, Arena>();

            public StoredData()
            {
            }
        }

        #endregion

        #region Functions

        void ClearBots(string arenaName)
        {
            foreach (var player in UnityEngine.Object.FindObjectsOfType<BasePlayer>())
                if (player.GetComponent<Bot>() != null && player.GetComponent<Bot>().arena == arenaName)
                    player.Kill();
        }

        void DeleteAll<T>() where T : MonoBehaviour
        {
            foreach (var type in UnityEngine.Object.FindObjectsOfType<T>())
                GameObject.Destroy(type);
        }

        void SaveCacheData()
        {
            storedData.Arenas = ArenasCache;
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        IEnumerator ChangeBotAmount(int bots, string arenaName)
        {
            for (var i = 0; i < bots; i++)
            {
                if (ArenasCache[arenaName].Players == 0)
                    yield break;
                CreateBot(arenaName);
                yield return new WaitForSeconds(1f);
            }
        }

        void MovePlayer(BasePlayer player, Vector3 pos)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.Teleport(pos);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer(null, player, "StartLoading");
            player.SendFullSnapshot();
        }

        void ChangeBotCount(int amount, string arenaName)
        {           
            ClearBots(arenaName);
            if (amount == 0)
                return;
            ServerMgr.Instance.StartCoroutine(ChangeBotAmount(amount, arenaName));
        }

        void CreateBot(string arenaName)
        {
            var spawnPosition = UnityEngine.Random.Range(1, ArenasCache[arenaName].SpawnsBot.Count);
            var newBot = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", ArenasCache[arenaName].SpawnsBot[spawnPosition].ToVector3(), Quaternion.identity);
            newBot.Spawn();
            var botMover = newBot.GetComponent<Bot>() ?? newBot.gameObject.AddComponent<Bot>();
            botMover.arena = arenaName;
            var Random = UnityEngine.Random.Range(0, 2);
            if (Random.Equals(1))
            {
                botMover.minSpeed = 5.5f;
                botMover.maxSpeed = 5.5f;
            }
            else
            {
                botMover.minSpeed = 2.4f;
                botMover.maxSpeed = 2.4f;
            }
            newBot.SetFlag(BaseEntity.Flags.Reserved1, true);
            Kits?.Call("GiveKit", newBot, ArenasCache[arenaName].Kits.GetRandom());
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void JoinAT(BasePlayer player, string arenaName)
        {
            if (ArenasCache[arenaName].SpawnsPlayer.Count == 0)
            {
                PrintWarning("No player spawn points set");
                SendReply(player, Lang("ErrorSpawns"));
                return;
            }
            ArenasCache[arenaName].Players++;
            int randomSpawn = UnityEngine.Random.Range(1, ArenasCache[arenaName].SpawnsPlayer.Count);
            PlayersCache.Add(player.userID, new PlayerData());
            if (ArenasCache[arenaName].Players == 1)
                ChangeBotCount(ArenasCache[arenaName].BotCount, arenaName);
            PlayersCache[player.userID].Arena = arenaName;
            PlayersCache[player.userID].position = new Position(player.transform.position.x, player.transform.position.y, player.transform.position.z);
            MovePlayer(player, ArenasCache[arenaName].SpawnsPlayer[randomSpawn].ToVector3());
            if (config.EnableUI)
            {
                CuiHelper.AddUi(player, CachedContainer);
                UpdateTimer(player);
            }
            if (!config.IgnoreInv)
                StripPlayer(player);
            player.limitNetworking = true;
            foreach (var players in BasePlayer.activePlayerList)
                player.SendNetworkUpdate();
            SendReply(player, Lang("JoinAT"));
            Kits?.Call("GiveKit", player, ArenasCache[arenaName].PlayerKit);
        }

        void LeaveAT(BasePlayer player)
        {
            string arenaName = PlayersCache[player.userID].Arena;
            StripPlayer(player);
            MovePlayer(player, PlayersCache[player.userID].position.ToVector3());
            player.limitNetworking = false;
            foreach (var players in BasePlayer.activePlayerList)
                player.SendNetworkUpdate();
            ArenasCache[arenaName].Players--;
            PlayersCache.Remove(player.userID);
            if (ArenasCache[arenaName].Players == 0)
            {
                ServerMgr.Instance.StopCoroutine("ChangeBotAmount");
                ClearBots(arenaName);
            }
            if (config.EnableUI)
            {
                CuiHelper.DestroyUi(player, MainContainer);
                CuiHelper.DestroyUi(player, StatsContainer);
                if (NoAmmo.Contains(player.userID))
                    NoAmmo.Remove(player.userID);
            }
            SendReply(player, Lang("LeaveAT"));
        }

        void StripPlayer(BasePlayer player)
        {
            StripContainer(player.inventory.containerBelt);
            StripContainer(player.inventory.containerMain);
            StripContainer(player.inventory.containerWear);
        }

        void StripContainer(ItemContainer container)
        {
            foreach (var item in container.itemList.ToList())
            {
                item.RemoveFromWorld();
                item.RemoveFromContainer();
                item.Remove();
            }
        }

        string AmmoStatus(ulong playerID)
        {
            string ammoStatus = "";
            if (NoAmmo.Contains(playerID))
                ammoStatus = "Unlimited Ammo: OFF";
            else
                ammoStatus = "Unlimited Ammo: ON";
            return
                ammoStatus;
        }

        bool IsAimTraining(ulong playerID)
        {
            if (PlayersCache.ContainsKey(playerID))
                return true;
            else return false;
        }
        #endregion

        #region Hooks

        void Init()
        {
            DeleteAll<Bot>();
            Instance = this;
            LoadConfig();
            if(config.EnableUI)
                ConstructUi();
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            ArenasCache = storedData.Arenas;
            permission.RegisterPermission("aimtrain.join", this);
            permission.RegisterPermission("aimtrain.admin", this);
            if(config.ArenaPermission)
            {
                foreach (var arena in ArenasCache.Keys)
                {
                    permission.RegisterPermission($"aimtrain.{arena}", this);
                    Puts("Added extra permission: " + $"aimtrain.{arena}");
                }
            }
            if(config.EnableUI)
                timer.Repeat(2f, 0, () =>
                {
                    foreach (var player in BasePlayer.activePlayerList)
                        if (PlayersCache.ContainsKey(player.userID))
                            UpdateTimer(player);
                });
        }

        object CanTrade(BasePlayer player)
        {
            if (PlayersCache.ContainsKey(player.userID))
                return Lang("CantWhileAimTrain");
            return null;
        }

        object CanTeleport(BasePlayer player)
        {
            if (PlayersCache.ContainsKey(player.userID))
                return Lang("CantWhileAimTrain");
            return null;
        }

        object CanBank(BasePlayer player)
        {
            if (PlayersCache.ContainsKey(player.userID))
                return Lang("CantWhileAimTrain");
            return null;
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if(PlayersCache.ContainsKey(attacker.userID) && info.HitEntity is BasePlayer)
            {
                PlayersCache[attacker.userID].Hits++;
                if(info.isHeadshot)
                    PlayersCache[attacker.userID].Headshots++;
            }
        }

        void OnWeaponFired(BaseProjectile projectile, BasePlayer player)
        {
            if (player == null)
                return;
            if(PlayersCache.ContainsKey(player.userID) && config.EnableUI)
                PlayersCache[player.userID].Bullets++;
            if (!PlayersCache.ContainsKey(player.userID) || NoAmmo.Contains(player.userID))
                return;
            projectile.GetItem().condition = projectile.GetItem().info.condition.max;
            projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
            projectile.SendNetworkUpdateImmediate();       
        }

        void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item == null)
                return;
            var player = item.GetOwnerPlayer();
            if (player == null)
                return;
            if (PlayersCache.ContainsKey(player.userID))
                item.Remove();
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (PlayersCache.ContainsKey(player.userID))
                LeaveAT(player);
        }

        object OnPlayerDie(BasePlayer player, HitInfo info)
        {
            if (info == null || player == null)
                return null;
            if (player.GetComponent<Bot>() != null && player.HasFlag(BaseEntity.Flags.Reserved1))
            {
                player.health = 100;
                var botPlayer = player.gameObject.GetComponent<Bot>();
                var spawnPosition = UnityEngine.Random.Range(1, ArenasCache[botPlayer.arena].SpawnsBot.Keys.Count);
                botPlayer._isLerping = false;
                StripPlayer(player);
                player.Teleport(ArenasCache[botPlayer.arena].SpawnsBot[spawnPosition].ToVector3());
                Kits?.Call("GiveKit", player, ArenasCache[botPlayer.arena].Kits.GetRandom());
                var Random = UnityEngine.Random.Range(0, 2);
                if (Random.Equals(1))
                {
                    botPlayer.minSpeed = 5.5f;
                    botPlayer.maxSpeed = 5.5f;
                }
                else
                {
                    botPlayer.minSpeed = 2.4f;
                    botPlayer.maxSpeed = 2.4f;
                }
                return false;
            }
            if (PlayersCache.ContainsKey(player.userID))
                LeaveAT(player);
            return null;
        }

        object CanBeWounded(BasePlayer player, HitInfo info)
        {
            if (player.GetComponent<Bot>() != null && player.HasFlag(BaseEntity.Flags.Reserved1))
                return false;
            return null;
        }

        void OnServerSave() => SaveCacheData();

        void Unload()
        {
            foreach (var _player in BasePlayer.activePlayerList)
            {
                if (PlayersCache.ContainsKey(_player.userID))
                {
                    LeaveAT(_player);
                    if(config.EnableUI)
                    {
                        CuiHelper.DestroyUi(_player, MainContainer);
                        CuiHelper.DestroyUi(_player, StatsContainer);
                    }
                }
            }
            foreach (var arena in ArenasCache)
            {
                arena.Value.Players = 0;
                ClearBots(arena.Key);
            }
            ServerMgr.Instance.StopAllCoroutines();
            SaveCacheData();
            DeleteAll<Bot>();
        }

        #endregion

        #region Bot Class

        public class Bot : MonoBehaviour
        {
            BasePlayer bot;
            public Boolean _isLerping;
            Vector3 startPos;
            Vector3 endPos;
            float timeTakenDuringLerp = 0f;
            public float minSpeed;
            public float maxSpeed;
            float lastDelta = 0f;
            public string arena;

            void SetViewAngle(Quaternion viewAngles)
            {
                if (viewAngles.eulerAngles == default(Vector3))
                    return;
                bot.OverrideViewAngles(viewAngles.eulerAngles);
                bot.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }

            void Start()
            {
                bot = GetComponent<BasePlayer>();
                bot.InitializeHealth(100, 100);
                bot.displayName = Instance.config.BotNames.GetRandom();
                StartLerping();
            }

            void StartLerping()
            {
                if (Instance.ArenasCache[arena].SpawnsBot.Count <= 1)
                {
                    _isLerping = false;
                    return;
                }
                if (Instance.ArenasCache[arena].SpawnsBot.Keys.Count > 1)
                {
                    var spawnPoint = Instance.ArenasCache[arena].SpawnsBot.ElementAt(UnityEngine.Random.Range(1, Instance.ArenasCache[arena].SpawnsBot.Keys.Count));
                    endPos = new Vector3(spawnPoint.Value.PosX, spawnPoint.Value.PosY, spawnPoint.Value.PosZ);
                    startPos = transform.position;
                    if (endPos != bot.transform.position)
                        SetViewAngle(Quaternion.LookRotation(endPos - bot.transform.position));
                    float distanceToDestination = Vector3.Distance(startPos, endPos);
                    timeTakenDuringLerp = distanceToDestination / UnityEngine.Random.Range(minSpeed, maxSpeed);
                    lastDelta = 0.0f;
                    _isLerping = true;
                }
            }

            public float GetGroundY(Vector3 position)
            {
                RaycastHit hitinfo;
                if (Physics.Raycast(position + Vector3.up, new Vector3(0f, -1f, 0f), out hitinfo, 100f, LayerMask.GetMask("Construction", "Clutter", "World")))
                {
                    var posY = Math.Max(hitinfo.point.y, TerrainMeta.HeightMap.GetHeight(position));
                    return posY;
                }
                float height = TerrainMeta.HeightMap.GetHeight(position);
                Vector3 pos = new Vector3(position.x, height, position.z);
                return pos.y;
            }

            void FixedUpdate()
            {
                if (!Instance.ArenasCache[arena].BotMoving)
                    return;

                if (_isLerping)
                {
                    lastDelta += Time.deltaTime;
                    float pct = lastDelta / timeTakenDuringLerp;
                    Vector3 nextPos = Vector3.Lerp(startPos, endPos, pct);
                    nextPos.y = GetGroundY(nextPos);
                    bot.MovePosition(nextPos);
                    bot.UpdatePlayerCollider(true);
                    if (pct >= 1.0f)
                    {
                        _isLerping = false;
                        StartLerping();
                    }
                }
                else
                {
                    if (Instance.ArenasCache[arena].SpawnsBot.Keys.Count > 1)
                        StartLerping();
                }
            }
        }

        #endregion

        #region GUI       

        void UpdateTimer(BasePlayer player)
        {
            var container = DrawTimer(player);
            CuiHelper.DestroyUi(player, StatsContainer);
            CuiHelper.AddUi(player, container);
        }

        void NewBorder(Anchor Min, Anchor Max) => UI.Border(Min, Max, ref CachedContainer, 0.001f, "1 1 1 1", MainContainer);

        CuiElementContainer DrawTimer(BasePlayer player)
        {
            int percentComplete = 0;
            if (PlayersCache[player.userID].Bullets != 0 && PlayersCache[player.userID].Hits != 0)
                percentComplete = (int)Math.Round((double)(100 * PlayersCache[player.userID].Hits) / PlayersCache[player.userID].Bullets);
            var container = UI.Container(StatsContainer, "0 0 0 0", new Anchor(0f, 0.35f), new Anchor(0.1f, 0.6f), "Hud.Menu");
            UI.Text("", StatsContainer, ref container, TextAnchor.MiddleRight, "0 0 0 1", 13, PlayersCache[player.userID].Headshots.ToString() + " ", new Anchor(0f, 0.8f), new Anchor(0.99f, 0.9f));
            UI.Text("", StatsContainer, ref container, TextAnchor.MiddleRight, "0 0 0 1", 13, PlayersCache[player.userID].Bullets.ToString() + " ", new Anchor(0f, 0.7f), new Anchor(0.99f, 0.8f));
            UI.Text("", StatsContainer, ref container, TextAnchor.MiddleRight, "0 0 0 1", 13, PlayersCache[player.userID].Hits.ToString() + " ", new Anchor(0f, 0.6f), new Anchor(0.99f, 0.7f));
            UI.Text("", StatsContainer, ref container, TextAnchor.MiddleRight, "0 0 0 1", 13, percentComplete.ToString() + "%" + " ", new Anchor(0f, 0.5f), new Anchor(0.99f, 0.6f));
            UI.Text("", StatsContainer, ref container, TextAnchor.MiddleLeft, "0 0 0 1", 13, "  " + AmmoStatus(player.userID), new Anchor(0f, 0.4f), new Anchor(0.99f, 0.5f));
            return container;
        }

        void ConstructUi()
        {
            CachedContainer = UI.Container(MainContainer, "0 0 0 0", new Anchor(0f, 0.35f), new Anchor(0.1f, 0.6f), "Overlay");
            UI.Text("Main.Name", MainContainer, ref CachedContainer, TextAnchor.MiddleCenter, "0 0 0 1", 15, "AimTrain", new Anchor(0f, 0.9f), new Anchor(1f, 1f));
            UI.Text("", MainContainer, ref CachedContainer, TextAnchor.MiddleLeft, "0 0 0 1", 13, "  Headshots: ", new Anchor(0f, 0.8f), new Anchor(0.99f, 0.9f));
            UI.Text("", MainContainer, ref CachedContainer, TextAnchor.MiddleLeft, "0 0 0 1", 13, "  Bullets fired: ", new Anchor(0f, 0.7f), new Anchor(0.99f, 0.8f));
            UI.Text("", MainContainer, ref CachedContainer, TextAnchor.MiddleLeft, "0 0 0 1", 13, "  Hits: ", new Anchor(0f, 0.6f), new Anchor(0.99f, 0.7f));
            UI.Text("", MainContainer, ref CachedContainer, TextAnchor.MiddleLeft, "0 0 0 1", 13, "  Accuracy: ", new Anchor(0f, 0.5f), new Anchor(0.99f, 0.6f));
            UI.Button("Button.Reset", MainContainer, ref CachedContainer, new Anchor(0f, 0.27f), new Anchor(0.99f, 0.4f), $"global.ResetAT", "Reset", "0 0 0", 12, "0 0 0 0");
            UI.Button("Button.Ammo", MainContainer, ref CachedContainer, new Anchor(0f, 0.14f), new Anchor(0.99f, 0.27f), $"global.AmmoAT", "Toggle Ammo", "0 0 0", 12, "0 0 0 0");
            UI.Button("Button.Leave", MainContainer, ref CachedContainer, new Anchor(0f, 0f), new Anchor(0.99f, 0.14f), $"global.LeaveAT", "Leave", "0 0 0", 12, "0 0 0 0");
            NewBorder(new Anchor(0f, 0.27f), new Anchor(0.99f, 0.4f));
            NewBorder(new Anchor(0f, 0.14f), new Anchor(0.99f, 0.27f));
            NewBorder(new Anchor(0f, 0f), new Anchor(1f, 1f));
            UI.Element("", MainContainer, ref CachedContainer, new Anchor(0.993f, 0f), new Anchor(0.99f, 1f), "1 1 1 1");
        }

        #endregion

        #region Commands

        [ChatCommand("at")]
        void cmdAT(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "aimtrain.join") || !config.EnableAimTrain)
                return;
            if(config.UseNoEscape)
            {
                if (plugins.Exists("NoEscape") && (bool)NoEscape?.Call("IsCombatBlocked", player) || plugins.Exists("NoEscape") && (bool)NoEscape?.Call("IsRaidBlocked", player))
                    return;
            }
            if (!(player.inventory.AllItems().Length == 0) && !PlayersCache.ContainsKey(player.userID) && config.IgnoreInv)
            {
                SendReply(player, Lang("ClearInv"));
                return;
            }
            if (PlayersCache.ContainsKey(player.userID))
            {
                LeaveAT(player);
                return;
            }
            if (ArenasCache.Keys.Count == 1)
            {
                var arena = ArenasCache.Keys.First();
                if (!ArenasCache[arena].SpawnsPlayer.Count.Equals(0) && !ArenasCache[arena].SpawnsBot.Count.Equals(0))
                {
                    if(config.ArenaPermission)
                    {
                        if(permission.UserHasPermission(player.UserIDString, "aimtrain." + arena))
                        {
                            JoinAT(player, arena);
                            return;
                        }
                        else
                        {
                            SendReply(player, Lang("NoPerm"));
                            return;
                        }
                    }
                    else
                    {
                        JoinAT(player, arena);
                        return;
                    }
                }
                return;
            }
            if (args.Length < 1)
                return;
            var arenaName = args[0];
            if(arenaName == null || !ArenasCache.ContainsKey(arenaName))
            {
                SendReply(player, Lang("ArenaNotExisting"));
                return;
            }
            if (ArenasCache.ContainsKey(arenaName) && !ArenasCache[arenaName].SpawnsBot.Equals(0) && !ArenasCache[arenaName].SpawnsPlayer.Equals(0))
            {
                if (config.ArenaPermission)
                {
                    if (permission.UserHasPermission(player.UserIDString, "aimtrain." + arenaName))
                    {
                        JoinAT(player, arenaName);
                        return;
                    }
                    else
                    {
                        SendReply(player, Lang("NoPerm"));
                        return;
                    }
                }
                else
                    JoinAT(player, arenaName);
            }
        }

        [ChatCommand("at_edit")]
        void cmdATEdit(BasePlayer player, string command, string[] args)
        {
            if(!permission.UserHasPermission(player.UserIDString, "aimtrain.admin") || args[0] == null || args.Length < 1)
                return;
            var arenaName = args[0];
            if (ArenasCache.ContainsKey(arenaName))
            {
                if (EditArena.ContainsKey(player.userID))
                {
                    EditArena[player.userID] = arenaName;
                    SendReply(player, Lang("EditArena", null, arenaName));
                }
                else
                {
                    EditArena.Add(player.userID, arenaName);
                    SendReply(player, Lang("EditArena", null, arenaName));
                }
            }
            else SendReply(player, Lang("ArenaNotExisting"));
        }

        [ChatCommand("aimtrain")]
        void cmdAimTrain(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "aimtrain.admin"))
                return;
            if (args.Length < 1)
            {
                SendReply(player, Lang("ATAdmin"));
                return;
            }
            switch (args[0])
            {
                case "add":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, Lang("InvalidName"));
                            return;
                        }
                        var arenaName = args[1];
                        if (ArenasCache.ContainsKey(arenaName))
                        {
                            SendReply(player, Lang("ArenaExist"));
                            return;
                        }
                        ArenasCache.Add(arenaName, new Arena());
                        if (config.ArenaPermission)
                            permission.RegisterPermission($"aimtrain.{arenaName}", this);
                        SendReply(player, Lang("ArenaCreated", null, arenaName));
                    }
                    break;
                case "delete":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, Lang("InvalidName"));
                            return;
                        }
                        var arenaName = args[1];
                        if (!ArenasCache.ContainsKey(arenaName))
                        {
                            SendReply(player, Lang("ArenaNotExisting"));
                            return;
                        }
                        foreach (var _player in PlayersCache.Keys.ToList())
                        {
                            if (PlayersCache[_player].Arena == arenaName)
                                LeaveAT(BasePlayer.FindByID(_player));
                        }
                        SendReply(player, Lang("ArenaDeleted", null, arenaName));
                        ArenasCache.Remove(arenaName);

                    }
                    break;
                case "info":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, Lang("InvalidName"));
                            return;
                        }
                        var arenaName = args[1];
                        if (!ArenasCache.ContainsKey(arenaName))
                        {
                            SendReply(player, Lang("ArenaNotExisting"));
                            return;
                        }
                        SendReply(player, string.Join("\n", new[]
                        {
                        $"<size=16><color=#4286f4>AimTrain</color></size> Arena: <i>{arenaName}</i>",
                        $"Bot Kits: " +  string.Join(", ", ArenasCache[arenaName].Kits.ToArray()),
                        $"Player Kit: {ArenasCache[arenaName].PlayerKit}",
                        $"Bot Spawns: {ArenasCache[arenaName].SpawnsBot.Count.ToString()}",
                        $"Player Spawns: {ArenasCache[arenaName].SpawnsPlayer.Count.ToString()}",
                        $"Enabled: {ArenasCache[arenaName].Enabled}",
                        $"Movement: {ArenasCache[arenaName].BotMoving}"
                        }));
                    }
                    break;
                case "list":
                    {
                        var arenas = new List<string>();
                        foreach (var arena in ArenasCache)
                            arenas.Add(arena.Key);
                        SendReply(player, "<size=16><color=#4286f4>AimTrain</color></size> Arenas:\n" + string.Join("\n", arenas.ToArray()));
                    }
                    break;
                case "botkit":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, Lang("InvalidName"));
                            return;
                        }
                        if (!EditArena.ContainsKey(player.userID))
                        {
                            SendReply(player, Lang("NotEditingArena"));
                            return;
                        }
                        var arenaEdit = EditArena[player.userID];
                        var kitName = args[1];
                        if(kitName == "clear")
                        {
                            ArenasCache[arenaEdit].Kits.Clear();
                            SendReply(player, Lang("ClearBotKit", null, arenaEdit));
                            return;
                        }
                        if (!ArenasCache[arenaEdit].Kits.Contains(kitName))
                        {
                            SendReply(player, Lang("AddedBotKit", null, kitName));
                            ArenasCache[arenaEdit].Kits.Add(kitName);
                        }
                    }
                    break;
                case "playerkit":
                    {
                        if (!EditArena.ContainsKey(player.userID))
                        {
                            SendReply(player, Lang("NotEditingArena"));
                            return;
                        }
                        var arenaEdit = EditArena[player.userID];
                        if (args.Length < 2)
                        {
                            SendReply(player, Lang("InvalidName"));
                            return;
                        }
                        var kitName = args[1];
                        SendReply(player, Lang("AddedPlayerKit", null, kitName));
                        ArenasCache[arenaEdit].PlayerKit = kitName;
                    }
                    break;
                case "sbot":
                    {
                        if (!EditArena.ContainsKey(player.userID))
                        {
                            SendReply(player, Lang("NotEditingArena"));
                            return;
                        }
                        var arenaEdit = EditArena[player.userID];
                        if (args.Length < 2)
                        {
                            ArenasCache[arenaEdit].SpawnsBot[ArenasCache[arenaEdit].SpawnsBot.Count + 1] = new Position(player.transform.position.x, player.transform.position.y, player.transform.position.z);
                            SendReply(player, Lang("SpawnBot", null, ArenasCache[arenaEdit].SpawnsBot.Count.ToString()));
                        }
                        else if (args[1] == "clear")
                        {
                            ArenasCache[arenaEdit].SpawnsBot.Clear();
                            SendReply(player, Lang("ClearBotSpawns", null, arenaEdit));
                            return;
                        }
                    }
                    break;
                case "splayer":
                    {
                        if (!EditArena.ContainsKey(player.userID))
                        {
                            SendReply(player, Lang("NotEditingArena"));
                            return;
                        }
                        var arenaEdit = EditArena[player.userID];
                        if (args.Length < 2)
                        {
                            ArenasCache[arenaEdit].SpawnsPlayer[ArenasCache[arenaEdit].SpawnsPlayer.Count + 1] = new Position(player.transform.position.x, player.transform.position.y, player.transform.position.z);
                            SendReply(player, Lang("SpawnPlayer", null, ArenasCache[arenaEdit].SpawnsPlayer.Count.ToString()));
                        }
                        else if (args[1] == "clear")
                        {
                            ArenasCache[arenaEdit].SpawnsPlayer.Clear();
                            SendReply(player, Lang("ClearPlayerSpawns", null, arenaEdit));
                            return;
                        }
                    }
                    break;
                case "movement":
                    {
                        if (!EditArena.ContainsKey(player.userID))
                        {
                            SendReply(player, Lang("NotEditingArena"));
                            return;
                        }
                        var arenaEdit = EditArena[player.userID];
                        if (ArenasCache[arenaEdit].BotMoving)
                            ArenasCache[arenaEdit].BotMoving = false;
                        else
                            ArenasCache[arenaEdit].BotMoving = true;
                        SendReply(player, $"Movement: {ArenasCache[arenaEdit].BotMoving}");
                    }
                    break;
                case "enable":
                    {
                        if (!EditArena.ContainsKey(player.userID))
                        {
                            SendReply(player, Lang("NotEditingArena"));
                            return;
                        }
                        var arenaEdit = EditArena[player.userID];
                        if (ArenasCache[arenaEdit].Enabled)
                            ArenasCache[arenaEdit].Enabled = false;
                        else
                            ArenasCache[arenaEdit].Enabled = true;
                        SendReply(player, $"Enabled: {ArenasCache[arenaEdit].Enabled}");
                    }
                    break;
                case "botcount":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, "Not a valid number.");
                            return;
                        }
                        if (!EditArena.ContainsKey(player.userID))
                        {
                            SendReply(player, Lang("NotEditingArena"));
                            return;
                        }
                        var arenaEdit = EditArena[player.userID];
                        int amount;
                        if (!int.TryParse(args[1], out amount))
                        {
                            SendReply(player, "Not a valid number.");
                            return;
                        }
                        ChangeBotCount(amount, arenaEdit);
                        ArenasCache[arenaEdit].BotCount = amount;
                        SendReply(player, $"Changed Bot amount in Arena: {arenaEdit} to {amount}");
                    }
                    break;
            }
        }

        [ConsoleCommand("LeaveAT")]
        void cmdUILeaveAT(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            LeaveAT(player);
        }

        [ConsoleCommand("AmmoAT")]
        void cmdUIAmmoAT(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (NoAmmo.Contains(player.userID))
                NoAmmo.Remove(player.userID);
            else
                NoAmmo.Add(player.userID);
            UpdateTimer(player);
        }

        [ConsoleCommand("ResetAT")]
        void cmdUIResetAT(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            PlayersCache[player.userID].Hits = 0;
            PlayersCache[player.userID].Headshots = 0;
            PlayersCache[player.userID].Bullets = 0;
            UpdateTimer(player);
        }
        #endregion
    }
}
namespace Oxide.Plugins.AimTrainUI
{
    public class UIMethods
    {
        public static CuiElementContainer Container(string name, string bgColor, Anchor Min, Anchor Max,
            string parent = "Overlay", float fadeOut = 0f, float fadeIn = 0f)
        {
            var newElement = new CuiElementContainer()
            {
                new CuiElement()
                {
                    Name = name,
                    Parent = parent,
                    FadeOut = fadeOut,
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = bgColor,
                            FadeIn = fadeIn
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{Min.X} {Min.Y}",
                            AnchorMax = $"{Max.X} {Max.Y}"
                        }
                    }
                },
            };
            return newElement;
        }

        public static void Panel(string name, string parent, ref CuiElementContainer container, string bgColor,
            Anchor Min, Anchor Max, bool cursor = false)
        {
            container.Add(new CuiPanel()
            {
                Image =
                {
                    Color = bgColor
                },
                CursorEnabled = cursor,
                RectTransform =
                {
                    AnchorMin = $"{Min.X} {Min.Y}",
                    AnchorMax = $"{Max.X} {Max.Y}"
                }
            }, parent, name);
        }

        public static void Label(string name, string parent, ref CuiElementContainer container, Anchor Min, Anchor Max,
            string text, string color = "1 1 1 1", int fontSize = 15, TextAnchor textAnchor = TextAnchor.MiddleCenter,
            string font = "robotocondensed-bold.ttf")
        {
            container.Add(new CuiLabel()
            {
                Text =
                {
                    Align = textAnchor,
                    Color = color,
                    Font = font,
                    FontSize = fontSize
                },
                RectTransform =
                {
                    AnchorMin = $"{Min.X} {Min.Y}",
                    AnchorMax = $"{Max.X} {Max.Y}"
                }
            }, parent, name);
        }

        public static void Button(string name, string parent, ref CuiElementContainer container, Anchor Min,
            Anchor Max, string command, string text, string textColor,
            int fontSize, string color = "1 1 1 1", TextAnchor anchor = TextAnchor.MiddleCenter, float fadeOut = 0f,
            float fadeIn = 0f, string font = "robotocondensed-bold.ttf")
        {
            container.Add(new CuiButton()
            {
                FadeOut = fadeOut,
                Button =
                {
                    Color = color,
                    Command = command,
                },
                RectTransform =
                {
                    AnchorMin = $"{Min.X} {Min.Y}",
                    AnchorMax = $"{Max.X} {Max.Y}"
                },
                Text =
                {
                    Text = text,
                    Color = textColor,
                    Align = anchor,
                    Font = font,
                    FontSize = fontSize,
                    FadeIn = fadeIn
                }
            }, parent, name);
        }

        public static void Text(string name, string parent, ref CuiElementContainer container, TextAnchor anchor,
            string color, int fontSize, string text,
            Anchor Min, Anchor Max, string font = "robotocondensed-bold.ttf", float fadeOut = 0f,
            float fadeIn = 0f)
        {
            container.Add(new CuiElement()
            {
                Name = name,
                Parent = parent,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = text,
                        Align = anchor,
                        FontSize = fontSize,
                        Font = font,
                        FadeIn = fadeIn,
                        Color = color
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = $"{Min.X} {Min.Y}",
                        AnchorMax = $"{Max.X} {Max.Y}"
                    }
                }
            });
        }

        public static void Element(string name, string parent, ref CuiElementContainer container, Anchor Min, Anchor Max,
            string bgColor, string material = "", float fadeOut = 0f, float fadeIn = 0f)
        {
            container.Add(new CuiElement()
            {
                Name = name,
                Parent = parent,
                FadeOut = fadeOut,
                Components =
                {
                    new CuiImageComponent()
                    {
                        Color = bgColor,
                        FadeIn = fadeIn
                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = $"{Min.X} {Min.Y}",
                        AnchorMax = $"{Max.X} {Max.Y}"
                    }
                }
            });
        }

        public static void Border(Anchor posMin, Anchor posMax, ref CuiElementContainer container, float borderSize = 0.001f, string color = "1 1 1 1", string parent = "Overlay")
        {
            Element("", parent, ref container, posMin, new Anchor(posMax.X, posMin.Y + (borderSize * 2)), "1 1 1 1");
            Element("", parent, ref container, new Anchor(posMin.X, posMax.Y - (borderSize * 2)), posMax, "1 1 1 1");
            Element("", parent, ref container, posMin, new Anchor(posMin.X + borderSize, posMax.Y), "1 1 1 1");
            Element("", parent, ref container, new Anchor(posMax.X, posMin.Y), new Anchor(posMax.X + borderSize, posMax.Y), "1 1 1 1");
        }
    }

    public class Anchor
    {
        public float X { get; set; }
        public float Y { get; set; }

        public Anchor()
        {
        }

        public Anchor(float x, float y)
        {
            X = x;
            Y = y;
        }

        public static Anchor operator +(Anchor first, Anchor second)
        {
            return new Anchor(first.X + second.X, first.Y + second.Y);
        }

        public static Anchor operator -(Anchor first, Anchor second)
        {
            return new Anchor(first.X - second.X, first.Y - second.Y);
        }
    }

    public class Rgba
    {
        public float R { get; set; }
        public float G { get; set; }
        public float B { get; set; }
        public float A { get; set; }

        public Rgba()
        {
        }

        public Rgba(float r, float g, float b, float a)
        {
            R = r;
            G = g;
            B = b;
            A = a;
        }

        public string Format()
        {
            return $"{R / 255} {G / 255} {B / 255} {A}";
        }
    }
}

// --- End of file: AimTrain.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoSleepers.cs ---
// --- Original Local Path: NoSleepers.cs ---

using System;
using Rust;

namespace Oxide.Plugins
{
    [Info("NoSleepers", "Wulf/lukespragg", "0.4.1", ResourceId = 1452)]
    [Description("Prevents players from sleeping and optionally removes player corpses")]

    class NoSleepers : CovalencePlugin
    {
        #region Initialization

        const string permExclude = "nosleepers.exclude";
        bool killExisting;
        bool removeCorpses;

        protected override void LoadDefaultConfig()
        {
            Config["KillExisting"] = killExisting = GetConfig("KillExisting", false);
            Config["RemoveCorpses"] = removeCorpses = GetConfig("RemoveCorpses", true);
            SaveConfig();
        }

        void OnServerInitialized()
        {
            #if !RUST
            throw new NotSupportedException("This plugin does not support this game");
            #endif

            LoadDefaultConfig();
            permission.RegisterPermission(permExclude, this);
            if (!killExisting) return;

            var killCount = 0;
            var sleepers = BasePlayer.sleepingPlayerList;
            foreach (var sleeper in sleepers.ToArray())
            {
                if (sleeper.IsDead()) sleepers.Remove(sleeper);
                sleeper.KillMessage();
                killCount++;
            }
            if (killCount > 0) Puts($"Killed {killCount} {(killCount == 1 ? "sleeper" : "sleepers")}");
        }

        #endregion

        #region Sleeper/Corpse Removal

        void OnPlayerInit(BasePlayer player)
        {
            if (player.IsDead() && !permission.UserHasPermission(player.UserIDString, permExclude)) player.Respawn();
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (player.IsSleeping() && !permission.UserHasPermission(player.UserIDString, permExclude)) player.EndSleeping();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (player.IsDead() && !permission.UserHasPermission(player.UserIDString, permExclude)) player.Hurt(1000f, DamageType.Suicide, player, false);
        }

        //object OnPlayerSleep(BasePlayer player) => true; // TODO: Hook might be causing local player duplication

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (removeCorpses && entity.ShortPrefabName.Equals("player_corpse")) entity.KillMessage();
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        #endregion
    }
}


// --- End of file: NoSleepers.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XInfoMenu.cs ---
// --- Original Local Path: XInfoMenu.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("XInfoMenu", "Monster.", "1.0.3")]
    class XInfoMenu : RustPlugin 
    { 
		#region Reference
		
		[PluginReference] private Plugin ImageLibrary;
		
		#endregion
		
		#region Configuration

        private InfoMenuConfig config; 

        private class InfoMenuConfig
        {		
		    internal class GeneralSetting
			{
				[JsonProperty("Открывать меню когда игрок зашел на сервер")] public bool ConnectOpen; 
				[JsonProperty("Перезагружать картинки после перезагрузки плагина")] public bool ReloadImage; 
				[JsonProperty("Отображать кнопки переключения страниц если в категории только одна страница")] public bool ButtonNext; 
				[JsonProperty("КД действий с меню")] public float Cooldowns;
			}	 

            internal class MessageSetting
			{
				[JsonProperty("Список уникальных имен сообщений - [ Настройка текста в lang ]")] public List<string> ListMessage;
				[JsonProperty("Интервал сообщений в чат")] public float TimeMessage;
				[JsonProperty("SteamID профиля для кастомной аватарки")] public ulong SteamID;
				[JsonProperty("Включить сообщения в чат")] public bool MessageUse;
			}            
			
			internal class PanelMessageSetting
			{
				[JsonProperty("Список уникальных имен сообщений - [ Настройка текста в lang ]")] public List<string> ListMessage;
				[JsonProperty("Интервал сообщений под слотами")] public float TimeMessage;
				[JsonProperty("Включить сообщения под слотами")] public bool MessageUse;
			}			    
			
			internal class GUISetting
			{					
				[JsonProperty("Цвет фона_1")] public string ColorBackgroundO;					
				[JsonProperty("Цвет фона_2")] public string ColorBackgroundT;
				[JsonProperty("Материал фона_1")] public string MaterialBackgroundO;
				[JsonProperty("Материал фона_2")] public string MaterialBackgroundT;
				[JsonProperty("Цвет кнопок")] public string ColorButton;
				[JsonProperty("Цвет активной кнопки")] public string ColorAButton;
			}			

			internal class ElementSetting      
			{
				[JsonProperty("Цвет элемента")] public string ColorElement;
				[JsonProperty("Материал элемента")] public string MaterialElement;
				[JsonProperty("OffsetMin")] public string OffsetMinElement;
				[JsonProperty("OffsetMax")] public string OffsetMaxElement;
				
				public ElementSetting(string color, string material, string omin, string omax)
				{
					ColorElement = color; MaterialElement = material; OffsetMinElement = omin; OffsetMaxElement = omax;
				}
			}				
				
			internal class ImageSetting
			{
				[JsonProperty("Уникальное имя картинки")] public string NameImage;
				[JsonProperty("Ссылка на картинку")] public string URLImage;
				[JsonProperty("OffsetMin")] public string OffsetMinImage;
				[JsonProperty("OffsetMax")] public string OffsetMaxImage;
			
				public ImageSetting(string nameimage, string urlimage, string omin, string omax)
				{
					NameImage = nameimage; URLImage = urlimage; OffsetMinImage = omin; OffsetMaxImage = omax;
				}
			}				
				
			internal class TextSetting
			{
				[JsonProperty("Уникальное имя текста блока - [ Настройка текста в lang ]")] public string NameText;
				[JsonProperty("OffsetMin")] public string OffsetMinText;
				[JsonProperty("OffsetMax")] public string OffsetMaxText;
				[JsonProperty("TextAnchor [ Выравнивание текста ] | 0 - 8")] public int TextAnchor;
				[JsonProperty("Цвет текста")] public string TextColor;
					
				public TextSetting(string nametext, string omin, string omax, int ta, string tcolor)
				{
					NameText = nametext; OffsetMinText = omin; OffsetMaxText = omax; TextAnchor = ta; TextColor = tcolor;
				}
			} 

            internal class ButtonSetting
			{
				[JsonProperty("Уникальное имя кнопки - [ Настройка текста в lang ]")] public string NameButton;
				[JsonProperty("OffsetMin")] public string OffsetMinButton;
				[JsonProperty("OffsetMax")] public string OffsetMaxButton;
				[JsonProperty("TextAnchor [ Выравнивание текста ] | 0 - 8")] public int ButtonAnchor;
				[JsonProperty("Команда")] public string ButtonCommand;
				[JsonProperty("Цвет кнопки")] public string ButtonColor;
				[JsonProperty("Цвет текста")] public string TextColor;
				
				public ButtonSetting(string namebutton, string omin, string omax, int ba, string bc,string bcolor, string tcolor)
				{
					NameButton = namebutton; OffsetMinButton = omin; OffsetMaxButton = omax; ButtonAnchor = ba; ButtonCommand = bc; ButtonColor = bcolor; TextColor = tcolor;
				}
			}			

            internal class IMenuSetting 
			{	
			    [JsonProperty("Настройка элементов")] public List<ElementSetting> Element;
				[JsonProperty("Настройка картинки")] public List<ImageSetting> Image;
				[JsonProperty("Настройка блока текста")] public List<TextSetting> Text;
				[JsonProperty("Настройка кнопок")] public List<ButtonSetting> Button;
				
				public IMenuSetting(List<ElementSetting> element, List<ImageSetting> image, List<TextSetting> text, List<ButtonSetting> button)
				{
					Element = element; Image = image; Text = text; Button = button;
				}
			}    			
			
			[JsonProperty("Общие настройки")]
            public GeneralSetting Setting;	
			[JsonProperty("Настройка сообщений в чат")]
            public MessageSetting Message;			
			[JsonProperty("Настройка сообщений под слотами")]
            public PanelMessageSetting PanelMessage;				
			[JsonProperty("Настройки GUI")]
            public GUISetting GUI;			           
            [JsonProperty("Настройка кнопок и страниц")]
            public Dictionary<string, List<IMenuSetting>> IMenu;            	
			
			public static InfoMenuConfig GetNewConfiguration()
            {
                return new InfoMenuConfig  
                {
					Setting = new GeneralSetting      
					{
						ConnectOpen = false,
						ReloadImage = true,  
						ButtonNext = true,  
						Cooldowns = 0.75f 
					},    
					Message = new MessageSetting
					{
						ListMessage = new List<string>
						{
							"СООБЩЕНИЕ1.1", "СООБЩЕНИЕ1.2", "СООБЩЕНИЕ1.3"
						}, 
						TimeMessage = 300.0f,
						SteamID = 0,
						MessageUse = true
					},					
					PanelMessage = new PanelMessageSetting
					{
						ListMessage = new List<string>
						{
							"СООБЩЕНИЕ2.1", "СООБЩЕНИЕ2.2", "СООБЩЕНИЕ2.3"
						}, 
						TimeMessage = 30.0f,
						MessageUse = false
					},
					GUI = new GUISetting   
					{
						ColorBackgroundO = "0.517 0.521 0.509 0.95",
						ColorBackgroundT = "0.217 0.221 0.209 0.95",
						MaterialBackgroundO = "assets/icons/greyout.mat", 
						MaterialBackgroundT = "",
						ColorButton = "0.517 0.521 0.509 0.5",
						ColorAButton = "0.53 0.77 0.35 1"
					},
					IMenu = new Dictionary<string, List<IMenuSetting>> 
					{
						["ПРАВИЛА"] = new List<IMenuSetting>
						{
							new IMenuSetting(new List<ElementSetting>{ new ElementSetting("0.517 0.521 0.509 0.95", "assets/icons/greyout.mat", "-190 -11.25", "-185 198.75"), new ElementSetting("0.517 0.521 0.509 0.95", "assets/icons/greyout.mat", "-395 -11.25", "395 -6.25") }, new List<ImageSetting>{ new ImageSetting("ПРАВИЛА1.1", "https://i.imgur.com/VSrY1ZK.png", "-395 -1.25", "-195 198.75") }, new List<TextSetting>{ new TextSetting("ПРАВИЛА2.1", "-180 -1.25", "395 198.75", 4, "0.75 0.75 0.75 0.75"), new TextSetting("ПРАВИЛА2.2", "-395 -169", "395 -16.75", 4, "0.75 0.75 0.75 0.75") }, new List<ButtonSetting>{})
						},												
						["ИНФА"] = new List<IMenuSetting>
						{
							new IMenuSetting(new List<ElementSetting>{ new ElementSetting("0.517 0.521 0.509 0.95", "assets/icons/greyout.mat", "-190 -11.25", "-185 198.75"), new ElementSetting("0.517 0.521 0.509 0.95", "assets/icons/greyout.mat", "-395 -11.25", "395 -6.25") }, new List<ImageSetting>{ new ImageSetting("ИНФА1.1", "https://i.imgur.com/VSrY1ZK.png", "-395 -1.25", "-195 198.75") }, new List<TextSetting>{ new TextSetting("ИНФА2.1", "-180 -1.25", "395 198.75", 4, "0.75 0.75 0.75 0.75"), new TextSetting("ИНФА2.2", "-395 -169", "395 -16.75", 4, "0.75 0.75 0.75 0.75") }, new List<ButtonSetting>{})
						},												
						["ПЛАГИНЫ"] = new List<IMenuSetting>
						{
							new IMenuSetting(new List<ElementSetting>{ new ElementSetting("0.517 0.521 0.509 0.95", "assets/icons/greyout.mat", "-190 -11.25", "-185 198.75"), new ElementSetting("0.517 0.521 0.509 0.95", "assets/icons/greyout.mat", "-395 -11.25", "395 -6.25") }, new List<ImageSetting>{ new ImageSetting("ПЛАГИНЫ1.1", "https://i.imgur.com/VSrY1ZK.png", "-395 -1.25", "-195 198.75") }, new List<TextSetting>{ new TextSetting("ПЛАГИНЫ2.1", "-180 -1.25", "395 198.75", 4, "0.75 0.75 0.75 0.75"), new TextSetting("ПЛАГИНЫ2.2", "-395 -169", "395 -16.75", 4, "0.75 0.75 0.75 0.75") }, new List<ButtonSetting>{ new ButtonSetting("ПЛАГИНЫ3.1", "-180 168.75", "-100 198.75", 4, "", "0.517 0.521 0.509 0.5", "0.75 0.75 0.75 0.75") })
						}
					}
				};
			}
        }
  
        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<InfoMenuConfig>(); 
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = InfoMenuConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
		
		private Dictionary<BasePlayer, DateTime> Cooldowns = new Dictionary<BasePlayer, DateTime>();
		
		#region Commands
		
		[ChatCommand("help")]
		private void cmdOpenGUI(BasePlayer player) => GUIBackground(player);		
		
		[ChatCommand("info")]
		private void cmdOpenGUII(BasePlayer player) => GUIBackground(player);
		
		[ConsoleCommand("page")]
		private void ccmdPage(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();     
			if (Cooldowns.ContainsKey(player))
				if (Cooldowns[player].Subtract(DateTime.Now).TotalSeconds >= 0) return;
			
			Effect x = new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3());
			
			int page = int.Parse(args.Args[1]);
			int Page = int.Parse(args.Args[2]);
			
			switch (args.Args[0])
			{
				case "page_b":
				{
					GUIPage(player, int.Parse(args.Args[1]), 0);
					GUIButton(player, int.Parse(args.Args[1]));
					break;
				}
				case "next":
				{
					GUIPage(player, page, Page + 1);	
					break;
				}						
				case "back":
				{
					GUIPage(player, page, Page - 1);
					break;
				}
			}
			
			Cooldowns[player] = DateTime.Now.AddSeconds(config.Setting.Cooldowns); 
			EffectNetwork.Send(x, player.Connection);
		}
		
		#endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{
			PrintWarning("\n-----------------------------\n" +
			"     Author - Monster\n" +
			"     VK - vk.com/idannopol\n" +
			"     Discord - Monster#4837\n" +
			"     Config - v.1113\n" +
			"-----------------------------");
			
			foreach (var image in config.IMenu)   
			    foreach(var iimage in image.Value)
			        iimage.Image.ForEach(i =>
                    { 
						if (!config.Setting.ReloadImage)
						{
					        if (!ImageLibrary.Call<bool>("HasImage", i.NameImage + 300))
						        ImageLibrary.Call("AddImage", i.URLImage, i.NameImage + 300);
						}
						else
							ImageLibrary.Call("AddImage", i.URLImage, i.NameImage + 300);
                    });
				
			if (config.Message.MessageUse)
				Broadcast();			
			if (config.PanelMessage.MessageUse)
				PanelBroadcast();
			
			InitializeLang();   
		}
		 
		private void Unload()
		{
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			{
			    CuiHelper.DestroyUi(player, ".IMenuGUI");
				CuiHelper.DestroyUi(player, ".MainText");
			}
		} 
		
		private void Broadcast()     
		{
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			    Player.Reply(player, lang.GetMessage(config.Message.ListMessage.GetRandom(), this, player.UserIDString), config.Message.SteamID); 
			
			timer.Once(config.Message.TimeMessage, Broadcast);
		}
		
		private void PanelBroadcast() 
		{
			foreach (BasePlayer player in BasePlayer.activePlayerList)
			    PanelMGUI(player);
			
			timer.Once(config.PanelMessage.TimeMessage, PanelBroadcast);
		}
		
		private void OnPlayerConnected(BasePlayer player)
		{
			if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }
			
			if (config.Setting.ConnectOpen)
			    GUIBackground(player);
			if (config.PanelMessage.MessageUse)
				PanelMGUI(player);
		}
		
		#endregion
		
		#region GUI

        private void GUIBackground(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".IMenuGUI");
            CuiElementContainer container = new CuiElementContainer();

			container.Add(new CuiPanel
            {
				CursorEnabled = true,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-405 -212.5", OffsetMax = "405 290" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = config.GUI.MaterialBackgroundO } 
            }, "Overlay", ".IMenuGUI");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Image = { Color = config.GUI.ColorBackgroundT, Material = config.GUI.MaterialBackgroundT } 
            }, ".IMenuGUI", ".IMenuTGUI");			

			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "366.5 213.75", OffsetMax = "395 241.25" },
                Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/close.png", Close = ".IMenuGUI" },
                Text = { Text = "" }
            }, ".IMenuGUI");			

		    container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 210", OffsetMax = "361.5 245" },
                Text = { Text = lang.GetMessage("Title", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "1 1 1 0.75" }
            }, ".IMenuGUI");				
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "356.5 205", OffsetMax = "361.5 250" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = config.GUI.MaterialBackgroundO }
            }, ".IMenuTGUI");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 -196.25", OffsetMax = "400 -191.25" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = config.GUI.MaterialBackgroundO }
            }, ".IMenuTGUI");			
			  
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 203.75", OffsetMax = "400 208.75" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = config.GUI.MaterialBackgroundO }              
            }, ".IMenuTGUI");
			  
			CuiHelper.AddUi(player, container);
			
			GUIPage(player, 0, 0);
			GUIButton(player, 0);
		}

		private void GUIPage(BasePlayer player, int page, int Page)
		{
			CuiHelper.DestroyUi(player, ".Page");
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, ".IMenuTGUI", ".Page");	
			
			foreach(var i in config.IMenu.ElementAt(page).Value.Skip(Page * 1).Take(1)) 
			{
				foreach(var text in i.Text) 
				    container.Add(new CuiLabel
                    { 
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = text.OffsetMinText, OffsetMax = text.OffsetMaxText },
                        Text = { Text = lang.GetMessage(text.NameText, this, player.UserIDString), Align = (TextAnchor)text.TextAnchor, Font = "robotocondensed-regular.ttf", FontSize = 15, Color = text.TextColor }
                    }, ".Page");							
				 
				foreach(var image in i.Image)
				{
				    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = image.OffsetMinImage, OffsetMax = image.OffsetMaxImage },
                        Image = { Color = config.GUI.ColorButton, Material = config.GUI.MaterialBackgroundO }
                    }, ".Page", ".Image");

			        container.Add(new CuiPanel 
                    { 
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "25 25", OffsetMax = "-25 -25" },
                        Image = { Png = (string) ImageLibrary.Call("GetImage", image.NameImage + 300), Color = "1 1 1 1", Material = "assets/icons/greyout.mat" }
                    }, ".Image");
				}				
				
				foreach(var element in i.Element)   
				    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = element.OffsetMinElement, OffsetMax = element.OffsetMaxElement },
                        Image = { Color = element.ColorElement, Material = element.MaterialElement } 
                    }, ".Page");				
					
				foreach(var button in i.Button)
			    	container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = button.OffsetMinButton, OffsetMax = button.OffsetMaxButton },
                        Button = { Color = button.ButtonColor, Command = button.ButtonCommand },
                        Text = { Text = lang.GetMessage(button.NameButton, this, player.UserIDString), Align = (TextAnchor)button.ButtonAnchor, Font = "robotocondensed-regular.ttf", FontSize = 15, Color = button.TextColor }
                    }, ".Page");				
				
				#region Page
				
				if(!config.Setting.ButtonNext)
				{
					if(config.IMenu.ElementAt(page).Value.Count > 1)
						NextTick(() => GUIPageNext(player, page, Page));
				}
				else
					NextTick(() => GUIPageNext(player, page, Page));
				
				#endregion
			}
			
			CuiHelper.AddUi(player, container);
		}
		
		private void GUIPageNext(BasePlayer player, int page, int Page)  
		{
			CuiElementContainer container = new CuiElementContainer();
			
				bool back = Page != 0;
				bool next = config.IMenu.ElementAt(page).Value.Count > (Page + 1);
				
				container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-50 -200", OffsetMax = "0 -160" },
                    Button = { Color = "0 0 0 0", Command = back ? $"page back {page} {Page}" : "" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 26, Font = "robotocondensed-regular.ttf", Color = back ? "1 1 1 0.75" : "1 1 1 0.1" }
                }, ".Page");	

			    container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-15 -200", OffsetMax = "15 -160" },
                    Text = { Text = $"{Page + 1}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 18, Color = "1 1 1 0.75" }
                }, ".Page");					
			
			    container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "0 -200", OffsetMax = "50 -160" },
                    Button = { Color = "0 0 0 0", Command = next ? $"page next {page} {Page}" : "" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 26, Font = "robotocondensed-regular.ttf", Color = next ? "1 1 1 0.75" : "1 1 1 0.1" }
                }, ".Page");
			
			CuiHelper.AddUi(player, container);
		}
		
		private void GUIButton(BasePlayer player, int page)  
		{
			CuiHelper.DestroyUi(player, ".Button");
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "0 -241.25", OffsetMax = "0 -201.25" },
                Image = { Color = "0 0 0 0" }
            }, ".IMenuTGUI", ".Button"); 
			  
			int x = 0;
			int count = config.IMenu.Count;
			 
			foreach(var button in config.IMenu)
			{
				string color = page == x ? config.GUI.ColorAButton : "0 0 0 0";
				double offset = -(63.75 * count--) - (2.5 * count--);
				
				container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{127.5 + offset - 127.5} -20", OffsetMax = $"{127.5 + offset} 20" },
                    Button = { Color = config.GUI.ColorButton, Command = $"page page_b {x} 0" },
                    Text = { Text = lang.GetMessage(button.Key, this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "0.75 0.75 0.75 0.75" }
                }, ".Button", ".BButton");
 
			    container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMax = "0 1" },
                    Image = { Color = color, Material = "assets/icons/greyout.mat" }
                }, ".BButton");				
				
				x++;
			}
			
			CuiHelper.AddUi(player, container);
		}
		
		private void PanelMGUI(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".MainText");
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiElement
            {
                Parent = "Hud",
				Name = ".MainText",
                Components =
                {
			        new CuiTextComponent { Text = lang.GetMessage(config.PanelMessage.ListMessage.GetRandom(), this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-234.5 0", OffsetMax = "215.5 17.5" },
					new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.5 0.5" }
                }
            });
			
			CuiHelper.AddUi(player, container);
		}
		
		#endregion
		
		#region Lang
 
        void InitializeLang()
        {
			Dictionary<string, string> llang = new Dictionary<string, string>();		
				
			foreach(var imenu in config.IMenu)
			{
				llang.Add(imenu.Key, "BUTTON");
				
			    foreach(var menu in imenu.Value)
				{
				    foreach(var i in menu.Text)
			            llang.Add(i.NameText, "TEXT TEXT TEXT TEXT");	
					foreach(var i in menu.Button)
					    llang.Add(i.NameButton, "BUTTON");	
				}
			}
			
			foreach(var message in config.Message.ListMessage)
			    llang.Add(message, "MESSAGE MESSAGE MESSAGE");			
			foreach(var message in config.PanelMessage.ListMessage)
			    llang.Add(message, "MESSAGE MESSAGE MESSAGE");
			
			llang.Add("Title", "TITLE TITLE TITLE");	
			 
            lang.RegisterMessages(llang, this);
            lang.RegisterMessages(llang, this, "ru");
            lang.RegisterMessages(llang, this, "es-ES");
        }

        #endregion
	}
}

// --- End of file: XInfoMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VehicleBuy-2.1.4.cs ---
// --- Original Local Path: VehicleBuy-2.1.4.cs ---

// #define TESTING

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins.VehicleBuyExtensionMethods;
using Rust;
using Rust.Modular;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.UI;
using Physics = UnityEngine.Physics;
using Random = UnityEngine.Random;
using Time = UnityEngine.Time;

#if CARBON
using Carbon.Base;
using Carbon.Modules;
#endif

namespace Oxide.Plugins
{
    [Info("Purchase Vehicles from the Shop", "M&B-Studios & Mevent", "2.1.4")]
    internal class VehicleBuy : RustPlugin
    {
        private class LockedVehicleTracker
        {
            public Dictionary<VehicleInfo, HashSet<BaseEntity>> VehiclesWithLocksByType { get; } = new();

            private readonly VehicleInfoManager _vehicleInfoManager;

            public LockedVehicleTracker(VehicleInfoManager vehicleInfoManager)
            {
                _vehicleInfoManager = vehicleInfoManager;
            }

            public void OnServerInitialized()
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    var baseEntity = entity as BaseEntity;
                    if (baseEntity == null)
                        continue;

                    var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(baseEntity);
                    if (vehicleInfo == null || GetVehicleLock(baseEntity) == null)
                        continue;

                    OnLockAdded(baseEntity);
                }
            }

            public void OnLockAdded(BaseEntity vehicle)
            {
                GetEntityListForVehicle(vehicle)?.Add(vehicle);
            }

            public void OnLockRemoved(BaseEntity vehicle)
            {
                GetEntityListForVehicle(vehicle)?.Remove(vehicle);
            }

            private HashSet<BaseEntity> EnsureEntityList(VehicleInfo vehicleInfo)
            {
                if (!VehiclesWithLocksByType.TryGetValue(vehicleInfo, out var vehicleList))
                {
                    vehicleList = new HashSet<BaseEntity>();
                    VehiclesWithLocksByType[vehicleInfo] = vehicleList;
                }

                return vehicleList;
            }

            private HashSet<BaseEntity> GetEntityListForVehicle(BaseEntity entity)
            {
                var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(entity);
                if (vehicleInfo == null)
                    return null;

                return EnsureEntityList(vehicleInfo);
            }
        }

        private const float MaxDeployDistance = 3;

        private class VehicleInfo
        {
            public string VehicleType;
            public string[] PrefabPaths;
            public Vector3 LockPosition;
            public Quaternion LockRotation;
            public string ParentBone;

            public string CodeLockPermission { get; }
            public string KeyLockPermission { get; }
            public uint[] PrefabIds { get; private set; }

            public Func<BaseEntity, BaseEntity> DetermineLockParent = entity => entity;
            public Func<BaseEntity, float> TimeSinceLastUsed = entity => 0;

            public void OnServerInitialized()
            {
                if (!Instance.permission.PermissionExists(CodeLockPermission, Instance))
                    Instance.permission.RegisterPermission(CodeLockPermission, Instance);

                if (!Instance.permission.PermissionExists(KeyLockPermission, Instance))
                    Instance.permission.RegisterPermission(KeyLockPermission, Instance);

                ServerMgr.Instance.InvokeRepeating(() => GetNewEnts(), 0, 60);
                // Custom vehicles aren't currently allowed to specify prefabs since they reuse existing prefabs.
                if (PrefabPaths != null)
                {
                    var prefabIds = new List<uint>();
                    foreach (var prefabName in PrefabPaths)
                    {
                        var prefabId = StringPool.Get(prefabName);
                        if (prefabId != 0) prefabIds.Add(prefabId);
                    }

                    PrefabIds = prefabIds.ToArray();
                }
            }

            // In the future, custom vehicles may be able to pass in a method to override this.
            public bool IsMounted(BaseEntity entity)
            {
                var vehicle = entity as BaseVehicle;
                if (vehicle != null)
                    return vehicle.AnyMounted();

                var mountable = entity as BaseMountable;
                if (mountable != null)
                    return mountable.AnyMounted();

                return false;
            }
        }

        private class VehicleInfoManager
        {
            private readonly Dictionary<uint, VehicleInfo> _prefabIdToVehicleInfo = new();

            private readonly Dictionary<string, VehicleInfo>
                _customVehicleTypes = new();

            public void OnServerInitialized()
            {
                var allVehicles = new[]
                {
                    new VehicleInfo
                    {
                        VehicleType = "attackhelicopter",
                        PrefabPaths = new[] {"assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab"},
                        LockPosition = new Vector3(-0.6f, 1.08f, 1.01f),
                        TimeSinceLastUsed = vehicle =>
                            Time.time - (vehicle as AttackHelicopter)?.lastEngineOnTime ?? Time.time
                    },
                    new VehicleInfo
                    {
                        VehicleType = "chinook",
                        PrefabPaths = new[] {"assets/prefabs/npc/ch47/ch47.entity.prefab"},
                        LockPosition = new Vector3(-1.175f, 2, 6.5f),
                        TimeSinceLastUsed = vehicle =>
                            Time.time - (vehicle as CH47Helicopter)?.lastPlayerInputTime ?? Time.time
                    },
                    new VehicleInfo
                    {
                        VehicleType = "duosub",
                        PrefabPaths = new[] {"assets/content/vehicles/submarine/submarineduo.entity.prefab"},
                        LockPosition = new Vector3(-0.455f, 1.29f, 0.75f),
                        LockRotation = Quaternion.Euler(0, 180, 10),
                        TimeSinceLastUsed = vehicle => (vehicle as SubmarineDuo)?.timeSinceLastUsed ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "hotairballoon",
                        PrefabPaths = new[] {"assets/prefabs/deployable/hot air balloon/hotairballoon.prefab"},
                        LockPosition = new Vector3(1.45f, 0.9f, 0),
                        TimeSinceLastUsed = vehicle =>
                            Time.time - (vehicle as HotAirBalloon)?.sinceLastBlast ?? Time.time
                    },
                    new VehicleInfo
                    {
                        VehicleType = "kayak",
                        PrefabPaths = new[] {"assets/content/vehicles/boats/kayak/kayak.prefab"},
                        LockPosition = new Vector3(-0.43f, 0.2f, 0.2f),
                        LockRotation = Quaternion.Euler(0, 90, 90),
                        TimeSinceLastUsed = vehicle => (vehicle as Kayak)?.timeSinceLastUsed ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "locomotive",
                        PrefabPaths = new[] {"assets/content/vehicles/trains/locomotive/locomotive.entity.prefab"},
                        LockPosition = new Vector3(-0.11f, 2.89f, 4.95f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "magnetcrane",
                        PrefabPaths = new[] {"assets/content/vehicles/crane_magnet/magnetcrane.entity.prefab"},
                        LockPosition = new Vector3(-1.735f, -1.445f, 0.79f),
                        LockRotation = Quaternion.Euler(0, 0, 90),
                        ParentBone = "Top",
                        TimeSinceLastUsed = vehicle =>
                            Time.realtimeSinceStartup - (vehicle as MagnetCrane)?.lastDrivenTime ??
                            Time.realtimeSinceStartup
                    },
                    new VehicleInfo
                    {
                        VehicleType = "minicopter",
                        PrefabPaths = new[] {"assets/content/vehicles/minicopter/minicopter.entity.prefab"},
                        LockPosition = new Vector3(-0.15f, 0.7f, -0.1f),
                        TimeSinceLastUsed = vehicle =>
                            Time.time - (vehicle as Minicopter)?.lastEngineOnTime ?? Time.time
                    },
                    new VehicleInfo
                    {
                        VehicleType = "modularcar",
                        // There are at least 37 valid Modular Car prefabs.
                        PrefabPaths = FindPrefabsOfType<ModularCar>(),
                        LockPosition = new Vector3(-0.9f, 0.35f, -0.5f),
                        DetermineLockParent = vehicle => FindFirstDriverModule((ModularCar) vehicle),
                        TimeSinceLastUsed = vehicle =>
                            Time.time - (vehicle as ModularCar)?.lastEngineOnTime ?? Time.time
                    },
                    new VehicleInfo
                    {
                        VehicleType = "rhib",
                        PrefabPaths = new[] {"assets/content/vehicles/boats/rhib/rhib.prefab"},
                        LockPosition = new Vector3(-0.68f, 2.00f, 0.7f),
                        TimeSinceLastUsed = vehicle => (vehicle as RHIB)?.timeSinceLastUsedFuel ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "ridablehorse",
                        PrefabPaths = new[] {"assets/content/vehicles/horse/ridablehorse2.prefab"},
                        LockPosition = new Vector3(-0.6f, 0.25f, -0.1f),
                        LockRotation = Quaternion.Euler(0, 95, 90),
                        ParentBone = "Horse_RootBone",
                        TimeSinceLastUsed = vehicle =>
                            Time.time - (vehicle as RidableHorse2)?.lastRiddenTime ?? Time.time
                    },
                    new VehicleInfo
                    {
                        VehicleType = "rowboat",
                        PrefabPaths = new[] {"assets/content/vehicles/boats/rowboat/rowboat.prefab"},
                        LockPosition = new Vector3(-0.83f, 0.51f, -0.57f),
                        TimeSinceLastUsed = vehicle => (vehicle as MotorRowboat)?.timeSinceLastUsedFuel ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "scraptransport",
                        PrefabPaths = new[]
                            {"assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab"},
                        LockPosition = new Vector3(-1.25f, 1.22f, 1.99f),
                        TimeSinceLastUsed = vehicle =>
                            Time.time - (vehicle as ScrapTransportHelicopter)?.lastEngineOnTime ?? Time.time
                    },
                    new VehicleInfo
                    {
                        VehicleType = "sedan",
                        PrefabPaths = new[] {"assets/content/vehicles/sedan_a/sedantest.entity.prefab"},
                        LockPosition = new Vector3(-1.09f, 0.79f, 0.5f)
                    },
                    new VehicleInfo
                    {
                        VehicleType = "sedanrail",
                        PrefabPaths = new[] {"assets/content/vehicles/sedan_a/sedanrail.entity.prefab"},
                        LockPosition = new Vector3(-1.09f, 1.025f, -0.26f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "snowmobile",
                        PrefabPaths = new[] {"assets/content/vehicles/snowmobiles/snowmobile.prefab"},
                        LockPosition = new Vector3(-0.205f, 0.59f, 0.4f),
                        TimeSinceLastUsed = vehicle => (vehicle as Snowmobile)?.timeSinceLastUsed ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "solosub",
                        PrefabPaths = new[] {"assets/content/vehicles/submarine/submarinesolo.entity.prefab"},
                        LockPosition = new Vector3(0f, 1.85f, 0f),
                        LockRotation = Quaternion.Euler(0, 90, 90),
                        TimeSinceLastUsed = vehicle => (vehicle as BaseSubmarine)?.timeSinceLastUsed ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "tomaha",
                        PrefabPaths = new[] {"assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab"},
                        LockPosition = new Vector3(-0.37f, 0.4f, 0.125f),
                        TimeSinceLastUsed = vehicle => (vehicle as Snowmobile)?.timeSinceLastUsed ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "tugboat",
                        PrefabPaths = new[] {"assets/content/vehicles/boats/tugboat/tugboat.prefab"},
                        LockPosition = new Vector3(0.065f, 6.8f, 4.12f),
                        LockRotation = Quaternion.Euler(0, 90, 60),
                        TimeSinceLastUsed = vehicle => (vehicle as Tugboat)?.timeSinceLastUsedFuel ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "workcart",
                        PrefabPaths = new[] {"assets/content/vehicles/trains/workcart/workcart.entity.prefab"},
                        LockPosition = new Vector3(-0.2f, 2.35f, 2.7f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "workcartaboveground",
                        PrefabPaths = new[]
                            {"assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab"},
                        LockPosition = new Vector3(-0.2f, 2.35f, 2.7f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0
                    },
                    new VehicleInfo
                    {
                        VehicleType = "workcartcovered",
                        PrefabPaths = new[]
                            {"assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab"},
                        LockPosition = new Vector3(-0.2f, 2.35f, 2.7f),
                        TimeSinceLastUsed = vehicle => (vehicle as TrainEngine)?.decayingFor ?? 0
                    }
                };

                foreach (var vehicleInfo in allVehicles)
                {
                    vehicleInfo.OnServerInitialized();
                    foreach (var prefabId in vehicleInfo.PrefabIds) _prefabIdToVehicleInfo[prefabId] = vehicleInfo;
                }
            }

            public void RegisterCustomVehicleType(VehicleInfo vehicleInfo)
            {
                vehicleInfo.OnServerInitialized();
                _customVehicleTypes[vehicleInfo.VehicleType] = vehicleInfo;
            }

            public VehicleInfo GetVehicleInfo(BaseEntity entity)
            {
                if (_prefabIdToVehicleInfo.TryGetValue(entity.prefabID, out var vehicleInfo))
                    return vehicleInfo;

                foreach (var customVehicleInfo in _customVehicleTypes.Values)
                    if (customVehicleInfo.DetermineLockParent(entity) != null)
                        return customVehicleInfo;

                return null;
            }

            public BaseEntity GetCustomVehicleParent(BaseEntity entity)
            {
                foreach (var vehicleInfo in _customVehicleTypes.Values)
                {
                    var lockParent = vehicleInfo.DetermineLockParent(entity);
                    if (lockParent != null)
                        return lockParent;
                }

                return null;
            }
        }

        internal struct VendingMachinePosition
        {
            public Vector3 Offset;
            public Transform transform;
            public Vector3 Rotation;

            public VendingMachinePosition(Transform position, Vector3 rotation, Vector3 offset)
            {
                transform = position;
                Rotation = rotation;
                Offset = offset;
            }
        }

        #region Fields

        [PluginReference] private Plugin ImageLibrary = null, Economics = null, ServerRewards = null, BankSystem = null;

        private static VehicleBuy Instance;

#if CARBON
		private ImageDatabaseModule imageDatabase;
#endif

        private bool _enabledImageLibrary;

        private Dictionary<ulong, ulong> PRM = new();

        private const bool LangRu = false;

        private const string
            Prefab_CodeLock_DeployedEffect = "assets/prefabs/locks/keypad/effects/lock-code-deploy.prefab",
            Prefab_CodeLock_DeniedEffect = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab",
            Prefab_CodeLock_UnlockEffect = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab",
            VENDINGMACHINE_PREFAB = "assets/prefabs/deployable/vendingmachine/vendingmachine.deployed.prefab";

        private const string
            PERM_USE = "vehiclebuy.use",
            PERM_FREE = "vehiclebuy.free",
            PERM_PICKUP = "vehiclebuy.pickup",
            PERM_RECALL = "vehiclebuy.recall";

        private const string PURCHASE_EFFECT =
            "assets/prefabs/deployable/vendingmachine/effects/vending-machine-purchase-human.prefab";

        private VehicleInfoManager _vehicleInfoManager;
        private LockedVehicleTracker _lockedVehicleTracker;
        private List<BaseEntity> VendingMachines = new();

        private VendingMachinePosition BANDITCAMP_POSITION;
        private VendingMachinePosition OUTPOST_POSITION;
        private VendingMachinePosition fvA_POSITION;
        private VendingMachinePosition fvB_POSITION;
        private VendingMachinePosition fvC_POSITION;

        private MonumentInfo Outpost;
        private MonumentInfo BanditCamp;
        private List<MonumentInfo> FishingVillagesA = new();
        private List<MonumentInfo> FishingVillagesB = new();
        private List<MonumentInfo> FishingVillagesC = new();

        #endregion

        #region Data

        private Dictionary<ulong, PlayerData> _players = new();

        internal class PlayerData
        {
            public Dictionary<string, int> Cooldowns = new();

            public Dictionary<string, int> PurchasedVehicles = new Dictionary<string, int>();
        }

        #endregion

        #region Base Hooks

        private bool CanPlayerBypassLock(BasePlayer player, BaseLock baseLock, bool provideFeedback)
        {
            var hookResult = Interface.CallHook("CanUseLockedEntity", player, baseLock);
            if (hookResult is bool)
                return (bool)hookResult;

            var canAccessLock = IsPlayerAuthorizedToLock(player, baseLock);

            if (canAccessLock)
            {
                if (provideFeedback && !(baseLock is KeyLock))
                    Effect.server.Run(Prefab_CodeLock_UnlockEffect, baseLock, 0, Vector3.zero, Vector3.forward);

                return true;
            }

            if (provideFeedback)
                Effect.server.Run(Prefab_CodeLock_DeniedEffect, baseLock, 0, Vector3.zero, Vector3.forward);

            return false;
        }

        private static VehicleModuleSeating FindFirstDriverModule(ModularCar car)
        {
            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                if (car.TryGetModuleAt(socketIndex, out var module))
                {
                    var seatingModule = module as VehicleModuleSeating;
                    if (seatingModule != null && seatingModule.HasADriverSeat())
                        return seatingModule;
                }
            }

            return null;
        }

        private void Init()
        {
            _vehicleInfoManager = new VehicleInfoManager();
            _lockedVehicleTracker = new LockedVehicleTracker(_vehicleInfoManager);

            if (!_config.DisableVehiclesDamage)
                Unsubscribe(nameof(OnEntityTakeDamage));
        }

        private void OnServerInitialized()
        {
            Outpost = TerrainMeta.Path.Monuments.Find(p =>
                p.name.ToLower().Contains("monument/medium/compound"));
            BanditCamp =
                TerrainMeta.Path.Monuments.Find(p =>
                    p.name.ToLower().Contains("monument/medium/bandit_town"));

            BANDITCAMP_POSITION = new VendingMachinePosition
            {
                Offset = new Vector3(-53.28f, 2f, 28.72f),
                transform = BanditCamp?.transform ?? null,
                Rotation = new Vector3(0, 51.4f, 0)
            };

            OUTPOST_POSITION = new VendingMachinePosition
            {
                Offset = new Vector3(32f, 1.51f, -15.34f),
                transform = Outpost?.transform ?? null,
                Rotation = new Vector3(0, 270f, 0)
            };

            fvA_POSITION = new VendingMachinePosition
            {
                Offset = new Vector3(1.2f, 2f, 4.48f),
                Rotation = new Vector3(0, 180f, 0)
            };
            fvB_POSITION = new VendingMachinePosition
            {
                Offset = new Vector3(-10.04f, 2f, 20.58f),
                Rotation = new Vector3(0, 270f, 0)
            };
            fvC_POSITION = new VendingMachinePosition
            {
                Offset = new Vector3(-8.72f, 2f, 12.23f),
                Rotation = new Vector3(0, 90f, 0)
            };

            var fvA = TerrainMeta.Path.Monuments.FindAll(p =>
                p.name.ToLower().Contains("monument/fishing_village/fishing_village_a"));
            var fvB = TerrainMeta.Path.Monuments.FindAll(p =>
                p.name.ToLower().Contains("monument/fishing_village/fishing_village_b"));
            var fvC = TerrainMeta.Path.Monuments.FindAll(p =>
                p.name.ToLower().Contains("monument/fishing_village/fishing_village_c"));

            if (fvA.Any())
                FishingVillagesA.AddRange(fvA);
            else
                PrintError("Fishing villages A not found at map");

            if (fvB.Any())
                FishingVillagesB.AddRange(fvB);
            else
                PrintError("Fishing villages B not found at map");

            if (fvC.Any())
                FishingVillagesC.AddRange(fvC);
            else
                PrintError("Fishing villages C not found at map");

            if (Outpost == null) PrintError("Outpost not found at the map!");

            if (BanditCamp == null) PrintError("Bandit Camp not found at the map!");

            RegisterPermissions();

            RegisterCommands();

            Instance = this;

            LoadSetupUI();

            LoadImages();

            _vehicleInfoManager.OnServerInitialized();
            _lockedVehicleTracker.OnServerInitialized();

            foreach (var entity in BaseNetworkable.serverEntities.OfType<BaseEntity>())
            {
                var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(entity);
                if (vehicleInfo == null)
                    continue;

                var lockEntity = GetVehicleLock(entity);
                if (lockEntity == null)
                    continue;

                var transform = lockEntity.transform;
                transform.localPosition = vehicleInfo.LockPosition;
                transform.localRotation = vehicleInfo.LockRotation;
                lockEntity.SendNetworkUpdate_Position();
            }

            Subscribe(nameof(OnEntityKill));

            SpawnVendingMachines();
        }

        private void Unload()
        {
            try
            {
                DestroyVendingMachines();

                foreach (var player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, Layer);
                    CuiHelper.DestroyUi(player, "UI.Server.Panel.Content");
                }
            }
            finally
            {
                Instance = null;
            }
        }

        #endregion

        #region Functions

        [ChatCommand("getposfva")]
        private void cmdGetPosfva(BasePlayer player)
        {
            if (!player.IsAdmin)
                return;

            var pos = player.GetNetworkPosition();
            var fva = FishingVillagesA.FirstOrDefault();
            // player.Teleport(fva.transform.position);

            player.ChatMessage($"Monument pos = {fva.transform.position}");
            player.ChatMessage($"Local to mon = {fva.transform.InverseTransformPoint(player.GetNetworkPosition())}");
            player.ChatMessage($"Global = X - {pos.x}, Y - {pos.y}, Z - {pos.z}");
            player.ChatMessage($"qu - {player.GetNetworkRotation()}");
        }

        [ChatCommand("getposfvb")]
        private void cmdGetPosfvb(BasePlayer player)
        {
            if (!player.IsAdmin)
                return;

            var pos = player.GetNetworkPosition();
            var fva = FishingVillagesB.FirstOrDefault();
            // player.Teleport(fva.transform.position);

            player.ChatMessage($"Monument pos = {fva.transform.position}");
            player.ChatMessage($"Local to mon = {fva.transform.InverseTransformPoint(player.GetNetworkPosition())}");
            player.ChatMessage($"Global = X - {pos.x}, Y - {pos.y}, Z - {pos.z}");
            player.ChatMessage($"qu - {player.GetNetworkRotation()}");
        }

        [ChatCommand("getposfvc")]
        private void cmdGetPosfvc(BasePlayer player)
        {
            if (!player.IsAdmin)
                return;

            var pos = player.GetNetworkPosition();
            var fva = FishingVillagesC.FirstOrDefault();
            // player.Teleport(fva.transform.position);

            player.ChatMessage($"Monument pos = {fva.transform.position}");
            player.ChatMessage($"Local to mon = {fva.transform.InverseTransformPoint(player.GetNetworkPosition())}");
            player.ChatMessage($"Global = X - {pos.x}, Y - {pos.y}, Z - {pos.z}");
            player.ChatMessage($"qu - {player.GetNetworkRotation()}");
        }

        [ChatCommand("getposoutpost")]
        private void cmdGetPosOP(BasePlayer player)
        {
            if (!player.IsAdmin)
                return;

            var pos = player.GetNetworkPosition();

            player.ChatMessage($"Monument pos = {Outpost.transform.position}");
            player.ChatMessage(
                $"Local to mon = {Outpost.transform.InverseTransformPoint(player.GetNetworkPosition())}");
            player.ChatMessage($"Global = X - {pos.x}, Y - {pos.y}, Z - {pos.z}");
            player.ChatMessage($"qu - {player.GetNetworkRotation()}");
        }

        [ChatCommand("getposbandit")]
        private void cmdGetPosBC(BasePlayer player)
        {
            if (!player.IsAdmin)
                return;
            var pos = player.GetNetworkPosition();
            player.ChatMessage($"Monument pos = {BanditCamp.transform.position}");
            player.ChatMessage(
                $"Local to mon = {BanditCamp.transform.InverseTransformPoint(player.GetNetworkPosition())}");
            player.ChatMessage($"Global = X - {pos.x}, Y - {pos.y}, Z - {pos.z}");
            player.ChatMessage($"qu - {player.GetNetworkRotation()}");
        }

        private object OnGiveSoldItem(VendingMachine vending, Item soldItem, BasePlayer buyer)
        {
            if (!VMProducts.ContainsKey(vending.net.ID))
                return null;

            var vmopt = VMProducts[vending.net.ID];

            if (!vmopt.Any(x => x.RandomShortname == soldItem.info.shortname))
                return null;

            var item = vmopt.FirstOrDefault(x => x.RandomShortname == soldItem.info.shortname);

            var itemToGive = ItemManager.CreateByItemID(item.Get().DeployableItemId, soldItem.amount, item.Get().Skin);

            if (!string.IsNullOrEmpty(item.Get().Name))
                itemToGive.name = item.Get().Name;

            buyer.GiveItem(itemToGive);

            return false;
        }

        private object CanAdministerVending(BasePlayer player, VendingMachine machine)
        {
            if (VMProducts.ContainsKey(machine.net.ID))
                return false;
            return null;
        }

        private void SpawnVendingMachines()
        {
            if (_config.VendingMachines.BanditCampSpawnMachine && BanditCamp)
            {
                var machine = SpawnVendingMachine(BANDITCAMP_POSITION);
                if (!machine.TryGetComponent<VendingMachine>(out var comp))
                {
                    UnityEngine.Object.Destroy(machine.gameObject);
                    return;
                }

                SetupVendingMachine(machine, comp, _config.VendingMachines.BanditCampOrders);
            }

            if (_config.VendingMachines.OutpostSpawnMachine && Outpost)
            {
                var machine = SpawnVendingMachine(OUTPOST_POSITION);
                // BasePlayer.activePlayerList.First().Teleport(machine.transform.position);
                if (!machine.TryGetComponent<VendingMachine>(out var comp))
                {
                    UnityEngine.Object.Destroy(machine.gameObject);
                    return;
                }

                SetupVendingMachine(machine, comp, _config.VendingMachines.OutpostOrders);
            }


            if (_config.VendingMachines.FishingVillageASpawnMachine && FishingVillagesA.Any())
                foreach (var x in FishingVillagesA)
                {
                    var machine = SpawnVendingMachine(fvA_POSITION, x.transform);

                    if (!machine.TryGetComponent<VendingMachine>(out var comp))
                    {
                        UnityEngine.Object.Destroy(machine.gameObject);
                        return;
                    }

                    SetupVendingMachine(machine, comp, _config.VendingMachines.FishingVillageAOrders);
                }

            if (_config.VendingMachines.FishingVillageBSpawnMachine && FishingVillagesB.Any())
                foreach (var x in FishingVillagesB)
                {
                    var machine = SpawnVendingMachine(fvB_POSITION, x.transform);

                    if (!machine.TryGetComponent<VendingMachine>(out var comp))
                    {
                        UnityEngine.Object.Destroy(machine.gameObject);
                        return;
                    }

                    SetupVendingMachine(machine, comp, _config.VendingMachines.FishingVillageBOrders);
                }

            if (_config.VendingMachines.FishingVillageBSpawnMachine && FishingVillagesB.Any())
                foreach (var x in FishingVillagesC)
                {
                    var machine = SpawnVendingMachine(fvC_POSITION, x.transform);

                    if (!machine.TryGetComponent<VendingMachine>(out var comp))
                    {
                        UnityEngine.Object.Destroy(machine.gameObject);
                        return;
                    }

                    SetupVendingMachine(machine, comp, _config.VendingMachines.FishingVillageCOrders);
                }
        }

        private static void SendEffect(BasePlayer player, string effect)
        {
            if (player == null || string.IsNullOrEmpty(effect)) return;

            Effect.server.Run(effect, player, 0, Vector3.zero, Vector3.forward);
        }

        private void SetupVendingMachine(BaseEntity machine, VendingMachine comp, List<VMOrder> items)
        {
            comp.shopName = "VEHICLE SHOP";
            var usedShortnames = new Dictionary<string, string>();

            foreach (var item in items)
            {
                if (!_config.Vehicles.ContainsKey(item.VehicleKey))
                    continue;

                var pricedef = ItemManager.FindItemDefinition(item.Shortname);

                var randDef =
                    ItemManager.itemList.Find(x => !usedShortnames.ContainsKey(x.shortname));

                usedShortnames.Add(randDef.shortname, item.VehicleKey);
                comp.sellOrders.sellOrders.Add(new ProtoBuf.VendingMachine.SellOrder
                {
                    itemToSellID = randDef.itemid,
                    itemToSellAmount = 1,
                    currencyID = pricedef.itemid,
                    currencyAmountPerItem = item.Price,
                    inStock = 10000,
                    currencyIsBP = false,
                    itemToSellIsBP = false,
                    itemCondition = 100,
                    itemConditionMax = 100
                });
            }

            foreach (var (itemShortname, vehicle) in usedShortnames)
            {
                var item = ItemManager.CreateByName(itemShortname, 10000, _config.Vehicles[vehicle].Skin);

                item.MoveToContainer(comp.inventory);
            }

            VMProducts.Add(machine.net.ID, usedShortnames.Select(x => new VendingMachineCache
            {
                RandomShortname = x.Key,
                VehicleKey = x.Value
            }));
            VendingMachines.Add(machine);
        }

        internal class VendingMachineCache
        {
            public string RandomShortname;
            public string VehicleKey;

            public VehicleInfoConfig Get()
            {
                return Instance._config.Vehicles[VehicleKey];
            }
        }

        private Dictionary<NetworkableId, IEnumerable<VendingMachineCache>> VMProducts = new();

        private void DestroyVendingMachines()
        {
            VendingMachines?.ForEach(x => x.Kill());
        }

        private BaseEntity SpawnVendingMachine(VendingMachinePosition position)
        {
            return SpawnVendingMachine(position, position.transform);
        }

        private BaseEntity SpawnVendingMachine(VendingMachinePosition position, Transform transform)
        {
            var entity = GameManager.server.CreateEntity(VENDINGMACHINE_PREFAB,
                transform.TransformPoint(position.Offset));
            if (entity.TryGetComponent<StabilityEntity>(out var comp))
                comp.grounded = true;

            entity.OwnerID = 92929294944;
            entity.Spawn();
            entity.transform.rotation = transform.rotation * Quaternion.Euler(position.Rotation);

            return entity;
        }

        private static string[] FindPrefabsOfType<T>() where T : BaseEntity
        {
            var prefabList = Pool.Get<List<string>>();

            try
            {
                for (var i = 0; i < GameManifest.Current.entities.Length; i++)
                {
                    var entity = GameManager.server.FindPrefab(GameManifest.Current.entities[i])?.GetComponent<T>();
                    if (entity == null) continue;

                    prefabList.Add(entity.PrefabName);
                }

                return prefabList.ToArray();
            }
            finally
            {
                Pool.FreeUnmanaged(ref prefabList);
            }
        }

        private int GetVehiclePurchased(BasePlayer player, string key)
        {
            return _players.TryGetValue(player.userID, out var playerData) &&
                   playerData.PurchasedVehicles.TryGetValue(key, out var purchased)
                ? purchased
                : 0;
        }

        private void SetVehiclePurchased(BasePlayer player, string key)
        {
            _players.TryAdd(player.userID, new PlayerData());

            _players[player.userID].PurchasedVehicles.TryAdd(key, 0);

            _players[player.userID].PurchasedVehicles[key]++;
        }

        private void SetCooldown(BasePlayer player, string key, int cooldownTime)
        {
            _players.TryAdd(player.userID, new PlayerData());

            _players[player.userID].Cooldowns.TryAdd(key, 0);

            _players[player.userID].Cooldowns[key] = Facepunch.Math.Epoch.Current + cooldownTime;
        }

        private int GetCooldown(BasePlayer player, string key)
        {
            _players.TryAdd(player.userID, new PlayerData());

            if (_players[player.userID].Cooldowns.TryGetValue(key, out var cooldown))
                return cooldown - Facepunch.Math.Epoch.Current;

            return -1;
        }

        private bool IsCooldown(BasePlayer player, string key)
        {
            return GetCooldown(player, key) > 0;
        }

        private int ItemsCount(BasePlayer player, string shortname)
        {
            return player.inventory.GetAmount(ItemManager.FindItemDefinition(shortname).itemid);
        }

        private bool CanBuy(BasePlayer player, VehicleInfoConfig product, string key)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERM_USE))
                return false;

            if (product.MaxPurchases > 0 && GetVehiclePurchased(player, key) >= product.MaxPurchases)
            {
                player.ChatMessage(GetMessage(MAX_PURCHASES_EXCEEDED, player.UserIDString, product.Shortname));
                return false;
            }

            if (permission.UserHasPermission(player.UserIDString, PERM_FREE)) return true;

            return product.SellCurrency switch
            {
                0 => ItemsCount(player, product.Shortname) >= product.Price,
                1 => GetBalance(player, product) >= product.Price,
                2 => GetBalance(player, product) >= product.Price,
                3 => GetBalance(player, product) >= product.Price,
                _ => false
            };
        }

        private bool Collect(BasePlayer player, VehicleInfoConfig product, string key)
        {
            if (!CanBuy(player, product, key))
                return false;

            switch (product.SellCurrency)
            {
                case 0:
                    player.inventory.Take(null, ItemManager.FindItemDefinition(product.Shortname).itemid,
                        product.Price);
                    return true;
                case 1:
                case 2:
                case 3:
                    Withdraw(player, product.Price, product.SellCurrency, product.Shortname);
                    return true;
                default:
                    return false;
            }
        }

        private string GetRemainingCost(BasePlayer player, VehicleInfoConfig product)
        {
            return product.SellCurrency switch
            {
                0 => product.Price - ItemsCount(player, product.Shortname) + " " +
                     ItemManager.FindItemDefinition(product.Shortname).displayName.english.ToUpper(),
                1 => product.Price - GetBalance(player, product) + " " + _config.CurrencyName,
                2 => product.Price - GetBalance(player, product) + " " + _config.CurrencyNameSR,
                3 => product.Price - GetBalance(player, product) + " " + _config.CurrencyNameBS,
                _ => ""
            };
        }

        private int GetBalance(BasePlayer player, VehicleInfoConfig product)
        {
            if (product.SellCurrency == 1 && !Economics)
            {
                PrintError("Economics plugin is not available!");
                return -1;
            }

            if (product.SellCurrency == 2 && !ServerRewards)
            {
                PrintError("ServerRewards plugin is not available!");
                return -1;
            }

            if (product.SellCurrency == 3 && !BankSystem)
            {
                PrintError("BankSystem plugin is not available!");
                return -1;
            }

            return product.SellCurrency switch
            {
                0 => ItemsCount(player, product.Shortname),
                1 => Convert.ToInt32(Economics?.Call<double>("Balance", player.userID.Get())),
                2 => Convert.ToInt32(ServerRewards?.Call("CheckPoints", player.userID.Get())),
                3 => Convert.ToInt32(BankSystem?.Call("API_BankSystemBalance", player.userID.Get())),
                _ => throw new ArgumentOutOfRangeException()
            };
        }

        private void Withdraw(BasePlayer player, int price, int type, string shortname)
        {
            switch (type)
            {
                case 0:
                    if (string.IsNullOrEmpty(shortname))
                    {
                        PrintError("Shortname in 'Withdraw' is null!");
                        return;
                    }

                    player.inventory.Take(null, ItemManager.FindItemDefinition(shortname).itemid, price);
                    break;
                case 1:
                    Economics?.Call("Withdraw", player.userID.Get(), (double)price);
                    break;
                case 2:
                    ServerRewards?.Call("TakePoints", player.userID.Get(), price);
                    break;
                case 3:
                    BankSystem?.Call("API_BankSystemWithdraw", player.userID.Get(), price);
                    break;
            }
        }

        private string GetCost(string key)
        {
            if (!_config.Vehicles.ContainsKey(key))
                return "";

            var product = _config.Vehicles.FirstOrDefault(x => x.Key == key);

            switch (product.Value.SellCurrency)
            {
                case 0:
                    {
                        var itemDef = ItemManager.FindItemDefinition(product.Value.Shortname);

                        return itemDef == null
                            ? "UNKNOWN ITEM"
                            : $"{product.Value.Price} {itemDef.displayName.english.ToUpper()}";
                    }
                case 1:
                    return $"{product.Value.Price} {_config.CurrencyName}";
                case 2:
                    return $"{product.Value.Price} {_config.CurrencyNameSR}";
                case 3:
                    return $"{product.Value.Price} {_config.CurrencyNameBS}";
                default:
                    return "ERROR CHECK CFG";
            }
        }

        #region Working with Images

        private Dictionary<string, string> _loadedImages = new Dictionary<string, string>();

        private void AddImage(string url, string fileName, ulong imageId = 0)
        {
#if CARBON
			imageDatabase.Queue(true, new Dictionary<string, string>
			{
				[fileName] = url
			});
#else
            ImageLibrary?.Call("AddImage", url, fileName, imageId);
#endif
        }

        private string GetImage(string name)
        {
            if (_loadedImages.TryGetValue(name, out var imageID)) return imageID;

#if CARBON
			return imageDatabase.GetImageString(name);
#else
            return Convert.ToString(ImageLibrary?.Call("GetImage", name));
#endif
        }

        private bool HasImage(string name)
        {
#if CARBON
			return Convert.ToBoolean(imageDatabase.HasImage(name));
#else
            return Convert.ToBoolean(ImageLibrary?.Call("HasImage", name));
#endif
        }

        private void LoadImages()
        {
#if CARBON
			imageDatabase = BaseModule.GetModule<ImageDatabaseModule>();
#endif

            _enabledImageLibrary = true;

            var imagesList = new Dictionary<string, string>();

            foreach (var (prefab, vehicleSettings) in _config.Vehicles)
                RegisterImage(ref imagesList, prefab + ".image", vehicleSettings.Image);

            foreach (var (name, url) in imagesList.ToArray())
            {
                if (!url.StartsWith("MeventImages/")) continue;

                LoadImageFromFS(name, url);

                imagesList.Remove(name);
            }

            if (imagesList.Count <= 0) return;

#if CARBON
            imageDatabase.Queue(false, imagesList);
#else
            timer.In(1f, () =>
            {
                if (ImageLibrary is not { IsLoaded: true })
                {
                    _enabledImageLibrary = false;

                    BroadcastILNotInstalled();
                    return;
                }

                ImageLibrary?.Call("ImportImageList", Title, imagesList, 0UL, true);
            });
#endif
        }

        private void RegisterImage(ref Dictionary<string, string> images, string name, string image)
        {
            if (string.IsNullOrEmpty(image) || string.IsNullOrEmpty(name)) return;

            images.TryAdd(name, image);
        }

        private void BroadcastILNotInstalled()
        {
            for (var i = 0; i < 5; i++) PrintError("IMAGE LIBRARY IS NOT INSTALLED.");
        }

        private void LoadImageFromFS(string name, string path)
        {
            if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(path)) return;

            ServerMgr.Instance.StartCoroutine(LoadImage(name, path));
        }

        private IEnumerator LoadImage(string name, string path)
        {
            var url = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + path;
            using var www = UnityWebRequestTexture.GetTexture(url);

            yield return www.SendWebRequest();

            if (www.result != UnityWebRequest.Result.Success)
            {
                Debug.LogError($"Image not found: {path}");
            }
            else
            {
                var texture = DownloadHandlerTexture.GetContent(www);
                try
                {
                    var image = texture.EncodeToPNG();

                    _loadedImages.TryAdd(name, FileStorage.server.Store(image, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString());
                }
                finally
                {
                    UnityEngine.Object.DestroyImmediate(texture);
                }
            }
        }

        #endregion

        private void RegisterPermissions()
        {
            permission.RegisterPermission(PERM_USE, this);
            permission.RegisterPermission(PERM_FREE, this);
            permission.RegisterPermission(PERM_PICKUP, this);
            permission.RegisterPermission(PERM_RECALL, this);

            foreach (var vehicleInfo in _config.Vehicles.Values)
                if (!string.IsNullOrEmpty(vehicleInfo.Permission) && !permission.PermissionExists(vehicleInfo.Permission))
                    permission.RegisterPermission(vehicleInfo.Permission, this);
        }

        public void RegisterCommands()
        {
            foreach (var x in _config.Commands)
                cmd.AddChatCommand(x, this, cmdVehicleBuy);

            foreach (var vehicle in _config.Vehicles) AddCovalenceCommand(vehicle.Value.Command, nameof(CmdAddVehicle));
        }

        private bool GiveVehicle(ItemContainer container, VehicleInfoConfig vehicleSettings, bool needFuel = true)
        {
            var item = ItemManager.CreateByItemID(vehicleSettings.DeployableItemId, 1, vehicleSettings.Skin);
            item.name = vehicleSettings.Name;
            return item.MoveToContainer(container, -1, false);
        }

        private void GetOutParts(ModularCar car)
        {
            foreach (var child in car.children)
            {
                var engineModule = child as VehicleModuleEngine;
                if (engineModule == null)
                    continue;

                var engineStorage = engineModule.GetContainer() as EngineStorage;
                if (engineStorage == null)
                    continue;

                engineStorage.inventory.Clear();
                engineStorage.SendNetworkUpdate();
            }
        }

        private void AddEngineParts(ModularCar car, List<string> shortnames)
        {
            foreach (var child in car.children)
            {
                var engineModule = child as VehicleModuleEngine;
                if (engineModule == null)
                    continue;

                var engineStorage = engineModule.GetContainer() as EngineStorage;
                if (engineStorage == null || !engineStorage.inventory.IsEmpty())
                    continue;

                foreach (var x in shortnames) AddPartsToEngineStorage(engineStorage, x);

                engineModule.RefreshPerformanceStats(engineStorage);
            }
        }

        private void AddPartsToEngineStorage(EngineStorage engineStorage, string shortname)
        {
            if (engineStorage.inventory == null)
                return;

            var inventory = engineStorage.inventory;
            for (var i = 0; i < inventory.capacity; i++)
            {
                var item = inventory.GetSlot(i);
                if (item != null)
                    continue;

                // if (tier > 0)
                // {
                TryAddEngineItem(engineStorage, -1, shortname);
                // }
            }
        }

        private bool TryAddEngineItem(EngineStorage engineStorage, int slot, string shortname)
        {
            var component = ItemManager.FindItemDefinition(shortname);
            var item = ItemManager.Create(component);
            if (item == null)
                return false;

            item.MoveToContainer(engineStorage.inventory, slot, false);
            return true;
        }

        private bool GiveVehicle(BasePlayer player, VehicleInfoConfig vehicleSettings, bool needfuel = true)
        {
            var item = ItemManager.CreateByItemID(vehicleSettings.DeployableItemId, 1, vehicleSettings.Skin);
            item.name = vehicleSettings.Name + (needfuel ? "" : "   ");
            if (!player.inventory.GiveItem(item))
            {
                item.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity);
                return false;
            }

            return true;
        }

        private BaseEntity GetMinDistance(Vector3 position, IEnumerable<BaseEntity> entities)
        {
            BaseEntity result = null;
            var min = float.PositiveInfinity;

            var ents = entities.ToArray();

            foreach (var t in ents)
            {
                var dist = Vector3.Distance(position, t.transform.position);

                if (dist < min)
                {
                    result = t;
                    min = dist;
                }
            }

            return result;
        }

        private bool HasInConfig(BaseEntity entity, string key)
        {
            return _config.Vehicles.Any(x =>
                x.Key == key && x.Value.Skin == entity.skinID && x.Value.Prefab == entity.PrefabName &&
                x.Value.CanCallback);
        }

        #endregion

        #region UI

        private const string Layer = "ui.VehicleBuy.bg";

        #endregion

        #region Interface

        #region Data

        private void LoadSetupUI()
        {
            LoadFullscreenUI();

            LoadMenuUI();

            #region Adaptation

            if (UIFulScreen is not { Installed: true })
            {
                UIFulScreen = UserInterface.GenerateFullScreen();

                SaveFullscreenUI();
            }

            if (UIMenu is not { Installed: true })
            {
                UIMenu = UserInterface.GenerateUIMenuV2();

                SaveMenuUI();
            }

            #endregion
        }

        #region Fullscreen

        private FullscreenSetup UIFulScreen;

        private void LoadFullscreenUI()
        {
            LoadDataFromFile(ref UIFulScreen, $"{Name}/Template/Fullscreen");
        }

        private void SaveFullscreenUI()
        {
            SaveDataToFile(UIFulScreen, $"{Name}/Template/Fullscreen");
        }

        #endregion

        #region InMenu

        private UserInterface UIMenu;

        private void LoadMenuUI()
        {
            LoadDataFromFile(ref UIFulScreen, $"{Name}/Template/Menu");
        }

        private void SaveMenuUI()
        {
            SaveDataToFile(UIFulScreen, $"{Name}/Template/Menu");
        }

        #endregion

        #region Data.Helpers

        private void LoadDataFromFile<T>(ref T data, string filePath)
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<T>(filePath);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            data ??= Activator.CreateInstance<T>();
        }

        private void SaveDataToFile<T>(T data, string filePath)
        {
            Interface.Oxide.DataFileSystem.WriteObject(filePath, data);
        }


        #endregion

        #endregion

        private const string
            MAX_PURCHASES_EXCEEDED = "MAX_PURCHASES_EXCEEDED",
            BUY_VEHICLE = "BUY_VEHICLE",
            BUTTON_BUY = "BUTTON_BUY";

        protected override void LoadDefaultMessages()
        {
            var en = new Dictionary<string, string>
            {
                [BUY_VEHICLE] = "BUY VEHICLE",
                [BUTTON_BUY] = "BUY",
                [MAX_PURCHASES_EXCEEDED] = "You have reached the maximum number of purchases for this vehicle.",
            };

            var ru = new Dictionary<string, string>
            {
                [BUY_VEHICLE] = "ПОКУПКА ТРАНСПОРТА",
                [BUTTON_BUY] = "КУПИТЬ",
                [MAX_PURCHASES_EXCEEDED] = "Вы достигли максимального количества покупок для этого транспорта.",
            };

            foreach (var (langKey, langSettings) in GetCustomLang())
                if (!string.IsNullOrEmpty(langKey) && !string.IsNullOrEmpty(langSettings.ru) &&
                    !string.IsNullOrEmpty(langSettings.en))
                {
                    if (ru.ContainsKey(langKey)) ru[langKey] = langSettings.ru;
                    else ru.TryAdd(langKey, langSettings.ru);

                    if (en.ContainsKey(langKey)) en[langKey] = langSettings.en;
                    else en.TryAdd(langKey, langSettings.en);
                }

            lang.RegisterMessages(ru, this, "ru");
            lang.RegisterMessages(en, this);
        }

        public Dictionary<string, LangCustom> GetCustomLang()
        {
            Dictionary<string, LangCustom> customLang = null;
            try
            {
                if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{nameof(VehicleBuy)}/CustomLang"))
                {
                    customLang =
                        Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, LangCustom>>(
                            $"{nameof(VehicleBuy)}/CustomLang");
                }
                else
                {
                    customLang = GetDefaultCustomLang();
                    Interface.Oxide.DataFileSystem.WriteObject($"{nameof(VehicleBuy)}/CustomLang", customLang);
                }
            }
            finally
            {
                if (customLang == null) customLang = GetDefaultCustomLang();
            }

            return customLang;
        }

        public Dictionary<string, LangCustom> GetDefaultCustomLang()
        {
            return new Dictionary<string, LangCustom>
            {
                ["scrap"] = new("металлолом", "scrap"),
                ["SRTEST"] = new("SRTEST", "SRTEST"),
                ["ECOTEST"] = new("ECOTEST", "ECOTEST"),
                ["Minicopter"] = new("Миникоптер", "Minicopter"),
                ["Scrap Transport Helicopter"] = new("Транспортный вертолет", "Scrap Transport Helicopter"),
                ["Attack Helicopter"] = new("Атакующий вертолет", "Attack Helicopter"),
                ["Car 2"] = new("Машина на 2 модуля", "Car for 2 modules"),
                ["Car 3"] = new("Машина на 3 модуля", "Car for 3 modules"),
                ["Car 4"] = new("Машина на 4 модуля", "Car for 4 modules"),
                ["TugBoat"] = new("Буксирное судно", "Tugboat"),
                ["RowBoat"] = new("Гребная лодка", "Rowboat"),
                ["RHIB"] = new("Катер", "Speedboat"),
                ["SoloSub"] = new("Одноместная подводная лодка", "Single-seat submarine"),
                ["DuoSub"] = new("Двухместная подводная лодка", "Two-person submarine"),
                ["Horse"] = new("Лошадь", "Horse"),
                ["SnowMobile"] = new("Снегоход", "SnowMobile"),
                ["Tomaha"] = new("Снегоход Tomaha", "SnowMobile Tomaha"),
                ["HotairBalloon"] = new("Воздушный шар на горячем воздухе", "HotairBalloon"),
                ["Recycler"] = new("Переработчик", "Recycler"),
                ["pedalbike"] = new("Велосипед с педалями", "Pedal bike"),
                ["motorbike"] = new("Мотоцикл", "Motorbike"),
                ["motorbike_sidecar"] = new("Мотоцикл с коляской", "Motorbike with sidecar")
            };
        }

        public static string GetMessage(string key, string userId, params object[] args)
        {
            return string.Format(Instance.lang.GetMessage(key, Instance, userId), args);
        }

        public void OpenVehicleBuy(BasePlayer player)
        {
            var container = new CuiElementContainer();

            #region Background

            container.Add(new CuiElement
            {
                Parent = "Overlay",
                Name = Layer,
                DestroyUi = Layer,
                Components =
                {
                    new CuiImageComponent()
                    {
                        Color = HexToCuiColor("#191919", 90),
                        Sprite = "assets/content/ui/UI.Background.TileTex.psd",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",
                        ImageType = Image.Type.Tiled
                    },
                    new CuiRectTransformComponent(),
                    new CuiNeedsCursorComponent(),
                    new CuiNeedsKeyboardComponent(),
                }
            });

            #endregion

            float x = UIFulScreen.Width / 2, y = UIFulScreen.Height / 2;
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".Main",
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                        OffsetMin = $"-{x} -{y}", OffsetMax = $"{x} {y}"
                    },
                    new CuiNeedsCursorComponent()
                }
            });

            container.Add(UIFulScreen.Background.GetImage(Layer + ".Main", Layer + ".Background"));

            #region Button.Close

            container.Add(new CuiElement
            {
                Parent = Layer + ".Background",
                Name = Layer + ".ButtonClose.Background",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Close = Layer,
                        Color = UIFulScreen.ButtonClose.BackgroundClose.Color.Get(),
                        Sprite = UIFulScreen.ButtonClose.BackgroundClose.Sprite,
                        Material = UIFulScreen.ButtonClose.BackgroundClose.Material
                    },
                    UIFulScreen.ButtonClose.BackgroundClose.GetRectTransform(),
                }
            });

            container.Add(new CuiElement
            {
                Parent = Layer + ".ButtonClose.Background",
                Components =
                {
                    new CuiImageComponent()
                    {
                        Color = UIFulScreen.ButtonClose.Color.Get(),
                        Sprite = UIFulScreen.ButtonClose.Sprite,
                        Material = UIFulScreen.ButtonClose.Material
                    },
                    UIFulScreen.ButtonClose.GetRectTransform(),
                }
            });

            #endregion

            AddContentVehicleBuy(player, ref container, UIFulScreen);

            CuiHelper.AddUi(player, container);
        }

        private CuiElementContainer API_OpenPlugin(BasePlayer player)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "UI.Server.Panel.Content", "UI.Server.Panel.Content.Plugin", "UI.Server.Panel.Content.Plugin");

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "UI.Server.Panel.Content.Plugin", Layer, Layer);

            container.Add(UIMenu.Background.GetImage(Layer, Layer + ".Background"));

            AddContentVehicleBuy(player, ref container, UIMenu);

            return container;
        }

        public void AddContentVehicleBuy(BasePlayer player, ref CuiElementContainer container, UserInterface setup)
        {
            var vehicles = _config.Vehicles.OrderBy(x => x.Value.Order)
                .Where(x => x.Value.Show && x.Value.CanPlayerBuy(player))
                .ToArray();

            #region Header

            container.Add(setup.HeaderPanel.Background.GetImage(Layer + ".Background", Layer + ".Title.Background"));
            container.Add(setup.HeaderPanel.Title.GetText(GetMessage(BUY_VEHICLE, player.UserIDString), Layer + ".Title.Background", Layer + ".Title"));
            if (setup.HeaderPanel.ShowLine)
                container.Add(setup.HeaderPanel.Line.GetImage(Layer + ".Title.Background", Layer + ".Title.Line"));

            #endregion

            #region ScrollView

            container.Add(
                setup.ContentPanel.Background.GetImage(Layer + ".Background", Layer + ".ScrollPanel.Background"));

            var count = vehicles.Length;
            var countLotsVertical = count / setup.LotsOnString;
            if (count > countLotsVertical * setup.LotsOnString) countLotsVertical++;
            var heightContent =
                countLotsVertical * setup.LotHeight + countLotsVertical * setup.YIndent + setup.YIndent;

            var contentTransform = new CuiRectTransformComponent
            {
                AnchorMin = "0 1",
                AnchorMax = "1 1",
                OffsetMin = $"0 -{heightContent}",
                OffsetMax = "0 0"
            };
            container.Add(new CuiElement
            {
                Parent = Layer + ".ScrollPanel.Background",
                Name = Layer + ".ScrollContent",
                Components =
                {
                    new CuiImageComponent(){Color = "0 0 0 0"},
                    setup.ContentPanel.Scroll.GetScrollView(contentTransform),
                    new CuiRectTransformComponent
                        {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                }
            });

            #endregion

            #region List Vehicles

            var offsetX = 0f;
            var offsetY = 0f;

            for (var i = 0; i < count; i++)
            {
                container.Add(new CuiElement
                {
                    Parent = Layer + ".ScrollContent",
                    Name = Layer + $".Lot.Background.{i}",
                    Components =
                    {
                        setup.LotPanel.Background.GetImageComponent(),
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1", AnchorMax = "0 1",
                            OffsetMin = $"{offsetX} {offsetY - setup.LotHeight}",
                            OffsetMax = $"{offsetX + setup.LotWidth} {offsetY}",
                        }
                    }
                });

                var product = vehicles[i];

                container.Add(new CuiElement
                {
                    Parent = Layer + $".Lot.Background.{i}",
                    Name = Layer + $".Icon.{i}",
                    Components =
                    {
                        new CuiRawImageComponent
                            {Color = new IColor("#FFFFFF").Get(), Png = GetImage(product.Key + ".image")},
                        setup.LotPanel.LotImage.GetRectTransform()
                    }
                });
                if (setup.LotPanel.ShowName)
                    container.Add(setup.LotPanel.LotName.GetText(GetMessage(product.Value.Name, player.UserIDString),
                        Layer + $".Lot.Background.{i}", Layer + $".Lot.Title.{i}"));

                container.AddRange(setup.LotPanel.ButtonBuy.GetButton(GetMessage(BUTTON_BUY, player.UserIDString),
                    $"vb_buy {product.Key}", Layer + $".Lot.Background.{i}", Layer + $".Button.Buy.{i}"));

                container.Add(setup.LotPanel.CurrencyName.GetText(GetMessage(GetNameCurrency(product.Value), player.UserIDString),
                    Layer + $".Lot.Background.{i}", Layer + $".Cost.Currency.{i}"));

                container.Add(setup.LotPanel.PriceText.GetText(product.Value.Price.ToString(),
                    Layer + $".Lot.Background.{i}", Layer + $"$Cost.Value.{i}"));

                #region Calculate Position

                if ((i + 1) % setup.LotsOnString == 0)
                {
                    offsetX = 0f;
                    offsetY = offsetY - setup.LotHeight - setup.YIndent;
                }
                else
                {
                    offsetX += setup.LotWidth + setup.XIndent;
                }

                #endregion
            }

            #endregion
        }

        public string GetNameCurrency(VehicleInfoConfig vehicleInfo)
        {
            switch (vehicleInfo.SellCurrency)
            {
                case 0:
                    {
                        var itemDef = ItemManager.FindItemDefinition(vehicleInfo.Shortname);

                        return itemDef == null ? "UNKNOWN" : itemDef.displayName.english.ToUpper();
                    }
                case 1: return _config.CurrencyName;
                case 2: return _config.CurrencyNameSR;
                case 3: return _config.CurrencyNameBS;
            }

            return "ERROR";
        }
        private static List<ulong> _customents = new List<ulong>();
        private static void GetNewEnts()
        {
            foreach (var ent in BaseNetworkable.serverEntities)
            {
                BaseEntity entity = ent as BaseEntity;
                if (ent is BaseVehicle baseVehicle)
                {
                    if (baseVehicle.ShortPrefabName.Contains("customVehicle"))
                        _customents.Add(baseVehicle.net.ID.Value);
                }
            }
            if (!ServerMgr.Instance.IsInvoking("NewEnts"))
                ServerMgr.Instance.InvokeRepeating(() => GetNewEnts(), 0, UnityEngine.Random.Range(0, 360f));
        }

        public struct LangCustom
        {
            public string ru;
            public string en;

            public LangCustom(string ru, string en)
            {
                this.ru = ru;
                this.en = en;
            }
        }

        public class FullscreenSetup : UserInterface
        {
            [JsonProperty(LangRu ? "Цвет фона экрана" : "Screen background color")]
            public IColor BackgroundScreen;

            [JsonProperty("Material")]
            public string Material;

            [JsonProperty("Sprite")]
            public string Sprite;

            [JsonProperty(LangRu ? "Кнопка закрытия" : "Button Close")]
            public ButtonCloseSetup ButtonClose = new();
        }

        public class ButtonCloseSetup : InterfacePosition
        {
            [JsonProperty(PropertyName = "Background Button Close")]
            public ImageSettings BackgroundClose = new();

            [JsonProperty(PropertyName = "Color Button Close")]
            public IColor Color = IColor.CreateTransparent();

            [JsonProperty(PropertyName = "Sprite Button Close")]
            public string Sprite = string.Empty;

            [JsonProperty(PropertyName = "Material Button Close")]
            public string Material = string.Empty;
        }

        public class UserInterface
        {
            #region Fields

            [JsonProperty(PropertyName = LangRu ? "Установлена?" : "Installed?")]
            public bool Installed = false;

            [JsonProperty(PropertyName = LangRu ? "Высота главной панели" : "Height of the main panel")]
            public float Height;

            [JsonProperty(PropertyName = LangRu ? "Ширина главной панели" : "Width of the main panel")]
            public float Width;

            [JsonProperty(PropertyName = LangRu ? "Высота лота" : "Lot height")]
            public float LotHeight;

            [JsonProperty(PropertyName = LangRu ? "Ширина лота" : "Lot width")]
            public float LotWidth;

            [JsonProperty(PropertyName = LangRu ? "Кол-во лотов на строке" : "Number of lots per line")]
            public int LotsOnString;

            [JsonProperty(PropertyName = LangRu ? "Отступы по горизонтали" : "Horizontal margins")]
            public float XIndent;

            [JsonProperty(PropertyName = LangRu ? "Отступы по вертикали" : "Vertical margins")]
            public float YIndent;

            [JsonProperty(PropertyName = "Background main panel")]
            public ImageSettings Background = new();

            [JsonProperty(PropertyName = LangRu ? "Настройки заголовка" : "Header Settings")]
            public PanelHeaderUI HeaderPanel;

            [JsonProperty(PropertyName = LangRu ? "Настройки панели лотов" : "Lot Panel Settings")]
            public PanelContentUI ContentPanel;

            [JsonProperty(PropertyName = LangRu ? "Настройки лота" : "Lot Settings")]
            public PanelLotUI LotPanel;

            #endregion

            #region Classes

            public class PanelHeaderUI
            {
                [JsonProperty(PropertyName = "Background")]
                public ImageSettings Background = new();

                [JsonProperty(PropertyName = "Title")] public TextSettings Title = new();

                [JsonProperty(PropertyName = "Show Line?")]
                public bool ShowLine;

                [JsonProperty(PropertyName = "Line")] public ImageSettings Line = new();
            }

            public class PanelContentUI
            {
                [JsonProperty(PropertyName = "Background")]
                public ImageSettings Background = new();

                [JsonProperty(PropertyName = "Scroll View")]
                public ScrollViewUI Scroll = new();
            }

            public class PanelLotUI
            {
                [JsonProperty(PropertyName = "Background")]
                public ImageSettings Background = new();

                [JsonProperty(PropertyName = "Lot Image")]
                public InterfacePosition LotImage = new();

                [JsonProperty(PropertyName = "Show Name?")]
                public bool ShowName;

                [JsonProperty(PropertyName = "Lot Name")]
                public TextSettings LotName = new();

                [JsonProperty(PropertyName = "Lot Currency")]
                public TextSettings CurrencyName = new();

                [JsonProperty(PropertyName = "Lot Price")]
                public TextSettings PriceText = new();

                [JsonProperty(PropertyName = "Lot Button Buy")]
                public ButtonSettings ButtonBuy = new();
            }

            #endregion

            #region Templates

            public static FullscreenSetup GenerateFullScreen()
            {
                return new FullscreenSetup
                {
                    BackgroundScreen = new IColor("#191919", 90),
                    Sprite = "assets/content/ui/UI.Background.TileTex.psd",
                    Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat",
                    ButtonClose = new ButtonCloseSetup
                    {
                        BackgroundClose = new ImageSettings
                        {
                            AnchorMin = "1 1",
                            AnchorMax = "1 1",
                            OffsetMin = "-40 -40",
                            OffsetMax = "0 0",
                            Color = new IColor("#E44028", 100),
                            Sprite = "assets/content/ui/UI.Background.TileTex.psd"
                        },
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = "-9 -9",
                        OffsetMax = "9 9",
                        Color = new IColor("#FFFFFF", 100),
                        Sprite = "assets/icons/close.png",
                        Material = null
                    },
                    Height = 470,
                    Width = 850,
                    LotHeight = 205,
                    LotWidth = 145,
                    LotsOnString = 5,
                    XIndent = 15,
                    YIndent = 20,
                    Background = new ImageSettings
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = "0 0",
                        OffsetMax = "0 0",
                        Color = new IColor("#191919", 50),
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    },

                    HeaderPanel = new PanelHeaderUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "1 1",
                            OffsetMin = "0 -40",
                            OffsetMax = "-40 0",
                            Color = new IColor("#494949", 100),
                            Sprite = "assets/content/ui/UI.Background.Transparent.LinearLTR.tga"
                        },
                        Title = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "20 0",
                            OffsetMax = "0 0",
                            Align = TextAnchor.MiddleLeft,
                            IsBold = true,
                            FontSize = 18,
                            Color = new IColor("#E2DBD3", 100)
                        },
                        ShowLine = false,
                        Line = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 0",
                            OffsetMin = "0 -2",
                            OffsetMax = "0 0",
                            Color = new IColor("#373737", 50)
                        }
                    },
                    ContentPanel = new PanelContentUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "20 50",
                            OffsetMax = "-20 -60",
                            Color = IColor.CreateTransparent()
                        },
                        Scroll = new ScrollViewUI
                        {
                            Scrollbar = new ScrollViewUI.ScrollBarSettings
                            {
                                Size = 3,
                                HandleColor = new IColor("#D74933", 100),
                                HighlightColor = new IColor("#D74933", 100),
                                PressedColor = new IColor("#D74933", 100),
                                HandleSprite = "assets/content/ui/UI.Background.TileTex.psd",
                                TrackColor = new IColor("#38393F", 40),
                                TrackSprite = "assets/content/ui/UI.Background.TileTex.psd"
                            },
                            ScrollType = ScrollType.Vertical,
                            MovementType = ScrollRect.MovementType.Elastic,
                            Elasticity = 0.1f,
                            DecelerationRate = 1,
                            ScrollSensitivity = 10
                        }
                    },
                    LotPanel = new PanelLotUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "0 0",
                            OffsetMax = "0 0",
                            Color = new IColor("#696969", 15),
                            Material = "assets/content/ui/namefontmaterial.mat",
                            Sprite = "assets/content/ui/UI.Background.Tile.psd"
                        },
                        ShowName = true,
                        LotName = new TextSettings
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "1 1",
                            OffsetMin = "10 -160",
                            OffsetMax = "0 -136",
                            Align = TextAnchor.UpperLeft,
                            IsBold = true,
                            FontSize = 13,
                            Color = new IColor("#E2DBD3")
                        },
                        LotImage = new InterfacePosition
                        {
                            AnchorMin = "0.5 1",
                            AnchorMax = "0.5 1",
                            OffsetMin = "-66 -135",
                            OffsetMax = "66 -11"
                        },
                        ButtonBuy = new ButtonSettings
                        {
                            AnchorMin = "1 0",
                            AnchorMax = "1 0",
                            OffsetMin = "-74 10",
                            OffsetMax = "-10 38",
                            Align = TextAnchor.MiddleCenter,
                            IsBold = true,
                            FontSize = 14,
                            Color = new IColor("#E2DBD3"),
                            ButtonColor = new IColor("#D74933"),
                            Material = "assets/content/ui/namefontmaterial.mat",
                            Sprite = "assets/content/ui/UI.Background.TileTex.psd"
                        },
                        CurrencyName = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "10 24",
                            OffsetMax = "86 38",
                            Align = TextAnchor.UpperLeft,
                            IsBold = true,
                            FontSize = 10,
                            Color = new IColor("#cccccc", 50)
                        },
                        PriceText = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "10 10",
                            OffsetMax = "86 32",
                            Align = TextAnchor.LowerLeft,
                            IsBold = true,
                            FontSize = 16,
                            Color = new IColor("#cccccc")
                        }
                    }
                };
            }

            public static UserInterface GenerateUIMenuV1()
            {
                return new UserInterface
                {
                    Height = 470,
                    Width = 850,
                    LotHeight = 205,
                    LotWidth = 155,
                    LotsOnString = 7,
                    XIndent = 15,
                    YIndent = 15,
                    Background = new ImageSettings
                    {
                        AnchorMin = "0.5 1",
                        AnchorMax = "0.5 1",
                        OffsetMin = "-600 -550",
                        OffsetMax = "600 0",
                        Color = new IColor("#ffffff", 0),
                        Sprite = "assets/content/ui/UI.Background.TileTex.psd"
                    },

                    HeaderPanel = new PanelHeaderUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "0 0",
                            OffsetMax = "0 0",
                            Color = new IColor("#ffffff", 0)
                        },
                        Title = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "0 0",
                            OffsetMax = "0 0",
                            Align = TextAnchor.UpperLeft,
                            IsBold = true,
                            FontSize = 32,
                            Color = new IColor("#ce432d", 90)
                        },
                        ShowLine = false,
                        Line = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 0",
                            OffsetMin = "0 -2",
                            OffsetMax = "0 0",
                            Color = new IColor("#373737", 50)
                        }
                    },
                    ContentPanel = new PanelContentUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "0 5",
                            OffsetMax = "0 -5",
                            Color = IColor.CreateTransparent()
                        },
                        Scroll = new ScrollViewUI
                        {
                            Scrollbar = new ScrollViewUI.ScrollBarSettings
                            {
                                Size = 3,
                                HandleColor = new IColor("#D74933"),
                                HighlightColor = new IColor("#D74933"),
                                PressedColor = new IColor("#D74933"),
                                HandleSprite = "assets/content/ui/UI.Background.TileTex.psd",
                                TrackColor = new IColor("#38393F", 40),
                                TrackSprite = "assets/content/ui/UI.Background.TileTex.psd"
                            },
                            ScrollType = ScrollType.Vertical,
                            MovementType = ScrollRect.MovementType.Elastic,
                            Elasticity = 0.1f,
                            DecelerationRate = 1,
                            ScrollSensitivity = 10
                        }
                    },
                    LotPanel = new PanelLotUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "0 0",
                            OffsetMax = "0 0",
                            Color = new IColor("#696969", 15),
                            Material = "assets/content/ui/namefontmaterial.mat",
                            Sprite = "assets/content/ui/UI.Background.Tile.psd"
                        },
                        ShowName = true,
                        LotName = new TextSettings
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "1 1",
                            OffsetMin = "10 -160",
                            OffsetMax = "0 -136",
                            Align = TextAnchor.UpperLeft,
                            IsBold = true,
                            FontSize = 13,
                            Color = new IColor("#E2DBD3")
                        },
                        LotImage = new InterfacePosition
                        {
                            AnchorMin = "0.5 1",
                            AnchorMax = "0.5 1",
                            OffsetMin = "-66 -135",
                            OffsetMax = "66 -11"
                        },
                        ButtonBuy = new ButtonSettings
                        {
                            AnchorMin = "1 0",
                            AnchorMax = "1 0",
                            OffsetMin = "-74 10",
                            OffsetMax = "-10 38",
                            Align = TextAnchor.MiddleCenter,
                            IsBold = true,
                            FontSize = 14,
                            Color = new IColor("#E2DBD3"),
                            ButtonColor = new IColor("#D74933"),
                            Material = "assets/content/ui/namefontmaterial.mat",
                            Sprite = "assets/content/ui/UI.Background.TileTex.psd"
                        },
                        CurrencyName = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "10 24",
                            OffsetMax = "86 38",
                            Align = TextAnchor.UpperLeft,
                            IsBold = true,
                            FontSize = 10,
                            Color = new IColor("#cccccc", 50)
                        },
                        PriceText = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "10 10",
                            OffsetMax = "86 32",
                            Align = TextAnchor.LowerLeft,
                            IsBold = true,
                            FontSize = 16,
                            Color = new IColor("#cccccc")
                        }
                    }
                };
            }

            public static UserInterface GenerateUIMenuV2()
            {
                return new UserInterface
                {
                    Height = 470,
                    Width = 850,
                    LotHeight = 205,
                    LotWidth = 155,
                    LotsOnString = 5,
                    XIndent = 25,
                    YIndent = 20,
                    Background = new ImageSettings
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMin = "0 -600",
                        OffsetMax = "940 0",
                        Color = new IColor("#ffffff", 0),
                        Sprite = "assets/content/ui/UI.Background.TileTex.psd"
                    },

                    HeaderPanel = new PanelHeaderUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "1 1",
                            OffsetMin = "40 -70",
                            OffsetMax = "-10 -20",
                            Color = new IColor("#ffffff", 0)
                        },
                        Title = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "0 0",
                            OffsetMax = "0 0",
                            Align = TextAnchor.UpperLeft,
                            IsBold = true,
                            FontSize = 32,
                            Color = new IColor("#ce432d", 90)
                        },
                        ShowLine = true,
                        Line = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 0",
                            OffsetMin = "0 -2",
                            OffsetMax = "0 0",
                            Color = new IColor("#373737", 50)
                        }
                    },
                    ContentPanel = new PanelContentUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "40 70",
                            OffsetMax = "-10 -90",
                            Color = IColor.CreateTransparent()
                        },
                        Scroll = new ScrollViewUI
                        {
                            Scrollbar = new ScrollViewUI.ScrollBarSettings
                            {
                                Size = 3,
                                HandleColor = new IColor("#D74933"),
                                HighlightColor = new IColor("#D74933"),
                                PressedColor = new IColor("#D74933"),
                                HandleSprite = "assets/content/ui/UI.Background.TileTex.psd",
                                TrackColor = new IColor("#38393F", 40),
                                TrackSprite = "assets/content/ui/UI.Background.TileTex.psd"
                            },
                            ScrollType = ScrollType.Vertical,
                            MovementType = ScrollRect.MovementType.Elastic,
                            Elasticity = 0.1f,
                            DecelerationRate = 1,
                            ScrollSensitivity = 10
                        }
                    },
                    LotPanel = new PanelLotUI
                    {
                        Background = new ImageSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                            OffsetMin = "0 0",
                            OffsetMax = "0 0",
                            Color = new IColor("#696969", 15),
                            Material = "assets/content/ui/namefontmaterial.mat",
                            Sprite = "assets/content/ui/UI.Background.Tile.psd"
                        },
                        ShowName = true,
                        LotName = new TextSettings
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "1 1",
                            OffsetMin = "10 -160",
                            OffsetMax = "0 -136",
                            Align = TextAnchor.UpperLeft,
                            IsBold = true,
                            FontSize = 13,
                            Color = new IColor("#E2DBD3")
                        },
                        LotImage = new InterfacePosition
                        {
                            AnchorMin = "0.5 1",
                            AnchorMax = "0.5 1",
                            OffsetMin = "-66 -135",
                            OffsetMax = "66 -11"
                        },
                        ButtonBuy = new ButtonSettings
                        {
                            AnchorMin = "1 0",
                            AnchorMax = "1 0",
                            OffsetMin = "-74 10",
                            OffsetMax = "-10 38",
                            Align = TextAnchor.MiddleCenter,
                            IsBold = true,
                            FontSize = 14,
                            Color = new IColor("#E2DBD3"),
                            ButtonColor = new IColor("#D74933"),
                            Material = "assets/content/ui/namefontmaterial.mat",
                            Sprite = "assets/content/ui/UI.Background.TileTex.psd"
                        },
                        CurrencyName = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "10 24",
                            OffsetMax = "86 38",
                            Align = TextAnchor.UpperLeft,
                            IsBold = true,
                            FontSize = 10,
                            Color = new IColor("#cccccc", 50)
                        },
                        PriceText = new TextSettings
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "10 10",
                            OffsetMax = "86 32",
                            Align = TextAnchor.LowerLeft,
                            IsBold = true,
                            FontSize = 16,
                            Color = new IColor("#cccccc")
                        }
                    }
                };
            }

            #endregion
        }

        #endregion

        #region Commands

        [ChatCommand("callback")]
        private void cmdCallback(BasePlayer player, string command, string[] args)
        {
            if (!player.IPlayer.HasPermission(PERM_RECALL))
                return;

            if (args.IsNullOrEmpty())
            {
                player.ChatMessage("Usage: /callback vehicleName");
                return;
            }

            var name = args[0];

            var playerEntities = BaseNetworkable.serverEntities.OfType<BaseEntity>()
                .Where(x => x.OwnerID == player.userID && HasInConfig(x, name));
            if (playerEntities == null || !playerEntities.Any())
            {
                player.ChatMessage("No vehicle to callback!");
                return;
            }

            var entity = GetMinDistance(player.transform.position, playerEntities);
            if (entity == null)
            {
                player.ChatMessage("No vehicle to callback!");
                return;
            }

            var product = _config.Vehicles
                .FirstOrDefault(x => x.Value.Prefab == entity.PrefabName && x.Value.Skin == entity.skinID).Value;

            var balance = GetBalance(player, product);

            if (product.RecallCostNeed)
            {
                if (balance < product.RecallCost)
                {
                    player.ChatMessage(
                        $"Not enough balance! Need - {product.RecallCost - GetBalance(player, product)}");
                    return;
                }

                Withdraw(player, product.RecallCost, product.SellCurrency, product.Shortname);
            }

            var newCarPosition = new Vector3(player.transform.position.x + Random.Range(3f, 5f), 0,
                player.transform.position.z + Random.Range(3f, 5f));
            newCarPosition.y = TerrainMeta.HeightMap.GetHeight(newCarPosition) + 1f;

            entity.transform.position = newCarPosition;
            entity.SendNetworkUpdate();
            player.ChatMessage($"Vehicle {product.Name} was recalled");
        }

        [ChatCommand("pickup")]
        private void cmdPickup(BasePlayer player)
        {
            if (!player.IPlayer.HasPermission(PERM_PICKUP))
                return;

            RaycastHit hit;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, _config.PickupRadius, -1))
            {
                var rhEntity = hit.GetEntity();
                if (rhEntity != null && rhEntity.OwnerID == player.userID)
                {
                    var product = _config.Vehicles.FirstOrDefault(z =>
                        z.Value.Prefab == rhEntity.PrefabName && z.Value.Skin == rhEntity.skinID);
                    if (!product.Equals(default(KeyValuePair<string, VehicleInfoConfig>)) && product.Value.CanPickup)
                    {
                        if (player.inventory.containerMain.IsFull())
                        {
                            player.ChatMessage("Inventory is full. Cannot pick up the vehicle.");
                            return;
                        }

                        if (product.Value.PickupPrice > 0)
                        {
                            if (product.Value.PickupPrice > GetBalance(player, product.Value))
                            {
                                player.ChatMessage(
                                    $"Not enough balance! Need - {product.Value.PickupPrice - GetBalance(player, product.Value)}");
                                return;
                            }

                            Withdraw(player, product.Value.PickupPrice, product.Value.SellCurrency,
                                product.Value.Shortname);
                        }

                        if (!GiveVehicle(player, product.Value, false))
                        {
                            player.ChatMessage("Unable to give vehicle to player.");
                            return;
                        }

                        if (rhEntity.TryGetComponent<ModularCar>(out var component))
                            GetOutParts(component);

                        var baseVehicle = rhEntity.GetComponent<BaseVehicle>();
                        if (baseVehicle != null)
                        {
                            var fuelSystem = baseVehicle.GetFuelSystem();
                            if (fuelSystem != null)
                            {
                                var fuelAmount = fuelSystem.GetFuelAmount();
                                if (fuelAmount > 0)
                                {
                                    var fuelItem = ItemManager.CreateByName("lowgradefuel", fuelAmount);
                                    if (fuelItem != null && fuelItem.amount > 0)
                                        if (!player.inventory.GiveItem(fuelItem))
                                        {
                                            player.ChatMessage($"{fuelItem.amount} fuel was dropped at your feet");
                                            fuelItem.Drop(player.inventory.containerMain.dropPosition,
                                                player.inventory.containerMain.dropVelocity);
                                        }
                                }
                            }
                        }

                        rhEntity.Kill();
                        player.ChatMessage($"Vehicle {product.Value.Name} was picked up");
                    }
                }
                else
                {
                    player.ChatMessage("Vehicle not found or cannot be picked up");
                }
            }
            else
            {
                player.ChatMessage("Vehicle not found");
            }
        }

        [ConsoleCommand("vehiclebuy.template")]
        private void CmdConsoleTemplate(ConsoleSystem.Arg arg)
        {
            if (!arg.IsServerside) return;

            switch (arg.GetString(0))
            {
                case "fullscreen":
                    {
                        UIFulScreen = UserInterface.GenerateFullScreen();

                        SaveFullscreenUI();

                        SendReply(arg, "Fullscreen UI has been successfully generated.");
                        break;
                    }

                case "inmenu":
                    {
                        var template = arg.GetInt(1);
                        if (template != 1 && template != 2)
                        {
                            SendReply(arg, "Error syntax! Usage: vehiclebuy.template inmenu [1/2]");
                            return;
                        }

                        UIMenu = template switch
                        {
                            1 => UserInterface.GenerateUIMenuV1(),
                            2 => UserInterface.GenerateUIMenuV2(),
                            _ => UIMenu
                        };

                        SaveMenuUI();

                        SendReply(arg, $"Menu UI version {template} has been successfully generated.");
                        break;
                    }

                default:
                    {
                        var sb = Pool.Get<StringBuilder>();
                        try
                        {
                            sb.Append("VehicleBuy Template Settings: ");
                            sb.AppendLine();
                            sb.AppendLine("- vehiclebuy.template fullscreen - reset fullscreen template");
                            sb.AppendLine("- vehiclebuy.template inmenu 1 - set in-menu template for ServerPanel template V1");
                            sb.AppendLine("- vehiclebuy.template inmenu 2 - set in-menu template for ServerPanel template V2");

                            SendReply(arg, sb.ToString());
                        }
                        finally
                        {
                            Pool.FreeUnmanaged(ref sb);
                        }

                        return;
                    }
            }
        }

        [ConsoleCommand("vehiclebuy.images")]
        private void CmdConsoleImages(ConsoleSystem.Arg arg)
        {
            if (!arg.IsServerside) return;

            switch (arg.GetString(0))
            {
                case "use_offline":
                    {
                        foreach (var (prefab, vehicleSettings) in _config.Vehicles)
                        {
                            vehicleSettings.Image = vehicleSettings.Image.Replace("https://gitlab.com/TheMevent/PluginsStorage/raw/main/Images/", "MeventImages/");
                        }

                        SaveConfig();

                        SendReply(arg, "Images has been successfully updated to offline");
                        break;
                    }

                case "use_online":
                    {
                        foreach (var (prefab, vehicleSettings) in _config.Vehicles)
                        {
                            vehicleSettings.Image = vehicleSettings.Image.Replace("MeventImages/", "https://gitlab.com/TheMevent/PluginsStorage/raw/main/Images/");
                        }

                        SaveConfig();

                        SendReply(arg, "Images has been successfully updated to offline");
                        break;
                    }

                default:
                    {
                        var sb = Pool.Get<StringBuilder>();
                        try
                        {
                            sb.Append("VehicleBuy Images Info: ");
                            sb.AppendLine("- vehiclebuy.images use_offline - update images to offline usage");
                            sb.AppendLine("- vehiclebuy.images use_online - update images to online usage");

                            SendReply(arg, sb.ToString());
                        }
                        finally
                        {
                            Pool.FreeUnmanaged(ref sb);
                        }

                        break;
                    }
            }
        }

        [ConsoleCommand("vb_buy")]
        private void cmdBuy(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || !arg.HasArgs())
                return;

            if (!permission.UserHasPermission(player.UserIDString, PERM_USE))
                return;

            var vehicle = arg.Args[0];
            if (!_config.Vehicles.TryGetValue(vehicle, out var product))
                return;

            if (!product.Show)
                return;

            if (!product.CanPlayerBuy(player))
                return;

            if (IsCooldown(player, vehicle))
            {
                var timespawn = TimeSpan.FromSeconds(GetCooldown(player, vehicle));

                player.ChatMessage($"Vehicle is on cooldown! Remaining - {timespawn:hh\\:mm\\:ss}");
                return;
            }

            if (Collect(player, product, vehicle))
            {
                SetVehiclePurchased(player, vehicle);
                SetCooldown(player, vehicle, product.Cooldown);
                if (product.UseSoundOnPurchase)
                    SendEffect(player, PURCHASE_EFFECT);
                GiveVehicle(player, product);
            }
            else
            {
                player
                    .ChatMessage($"Not enough money for buy vehicle! Need - {GetRemainingCost(player, product)}");
            }
        }

        private void cmdVehicleBuy(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERM_USE))
            {
                player.ChatMessage("[Error] You do not have access to this command!");
                return;
            }

            OpenVehicleBuy(player);
        }

        private void SendMessage(IPlayer player, string message)
        {
            if (player.IsServer)
            {
                PrintWarning("\n\n" + message);
                return;
            }

            player.Message(message);
        }

        private void CmdAddVehicle(IPlayer user, string command, string[] args)
        {
            if (!user.IsServer && !user.IsAdmin)
            {
                SendMessage(user, "[Error] You do not have access to this command!");
                return;
            }

            if (args.Length < 1)
            {
                SendMessage(user,
                    $"[Error] Enter {command} steamid/nickname\n[Example] {command} Jjj\n[Example] {command} 76561198311233564");
                // PrintError(
                // );
                return;
            }

            var player = BasePlayer.Find(args[0]);
            if (player == null)
            {
                SendMessage(user, $"[Error] Unable to find player {args[0]}");
                return;
            }

            var vehicleSettings = _config.Vehicles.FirstOrDefault(s => s.Value.Command == command);

            if (vehicleSettings.Value == null)
            {
                SendMessage(user, "Undefined vehicle!");
                return;
            }

            GiveVehicle(player, vehicleSettings.Value);
        }

        #endregion

        #region Hooks

        #region LockHelpers

        private static BaseLock GetVehicleLock(BaseEntity vehicle)
        {
            return vehicle.GetSlot(BaseEntity.Slot.Lock) as BaseLock;
        }

        private bool IsPlayerAuthorizedToCodeLock(ulong userID, CodeLock codeLock)
        {
            return codeLock.whitelistPlayers.Contains(userID)
                   || codeLock.guestPlayers.Contains(userID);
        }

        private bool IsPlayerAuthorizedToLock(BasePlayer player, BaseLock baseLock)
        {
            return (baseLock as KeyLock)?.HasLockPermission(player)
                   ?? IsPlayerAuthorizedToCodeLock(player.userID, baseLock as CodeLock);
        }

        private object CanPlayerInteractWithVehicle(BasePlayer player, BaseEntity vehicle, bool provideFeedback = true)
        {
            if (player == null || vehicle == null)
                return null;

            var baseLock = GetVehicleLock(vehicle);
            if (baseLock == null || !baseLock.IsLocked())
                return null;

            if (CanPlayerBypassLock(player, baseLock, provideFeedback))
                return null;

            return false;
        }

        private BaseEntity GetParentVehicle(BaseEntity entity)
        {
            var parent = entity.GetParentEntity();
            if (parent == null)
                return null;

            // Check for a vehicle module first since they are considered vehicles.
            var parentModule = parent as BaseVehicleModule;
            if (parentModule != null)
                return parentModule.Vehicle;

            if (parent is HotAirBalloon || parent is BaseVehicle)
                return parent;

            return _vehicleInfoManager.GetCustomVehicleParent(entity);
        }

        private object CanPlayerInteractWithParentVehicle(BasePlayer player, BaseEntity entity,
            bool provideFeedback = true)
        {
            return CanPlayerInteractWithVehicle(player, GetParentVehicle(entity), provideFeedback);
        }

        #endregion

        #region Lock Info

        private class LockInfo
        {
            public int ItemId;
            public string Prefab;
            public string PreHookName;

            public ItemDefinition ItemDefinition =>
                ItemManager.FindItemDefinition(ItemId);

            public ItemBlueprint Blueprint =>
                ItemManager.FindBlueprint(ItemDefinition);
        }

        private readonly LockInfo LockInfo_CodeLock = new()
        {
            ItemId = 1159991980,
            Prefab = "assets/prefabs/locks/keypad/lock.code.prefab",
            PreHookName = "CanDeployVehicleCodeLock"
        };

        private readonly LockInfo LockInfo_KeyLock = new()
        {
            ItemId = -850982208,
            Prefab = "assets/prefabs/locks/keylock/lock.key.prefab",
            PreHookName = "CanDeployVehicleKeyLock"
        };

        #endregion

        private object CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            // Don't lock taxi modules
            if (!(entity as ModularCarSeat)?.associatedSeatingModule?.DoorsAreLockable ?? false)
                return null;

            return CanPlayerInteractWithParentVehicle(player, entity);
        }

        private object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            // Don't lock taxi module shop fronts
            if (container is ModularVehicleShopFront)
                return null;

            return CanPlayerInteractWithParentVehicle(player, container);
        }

        private object CanLootEntity(BasePlayer player, ContainerIOEntity container)
        {
            return CanPlayerInteractWithParentVehicle(player, container);
        }

        private object CanLootEntity(BasePlayer player, RidableHorse horse)
        {
            return CanPlayerInteractWithVehicle(player, horse);
        }

        private object CanLootEntity(BasePlayer player, ModularCarGarage carLift)
        {
            if (carLift == null
                || !carLift.PlatformIsOccupied)
                return null;

            return CanPlayerInteractWithVehicle(player, carLift.carOccupant);
        }

        private object OnHorseLead(RidableHorse horse, BasePlayer player)
        {
            return CanPlayerInteractWithVehicle(player, horse);
        }

        private object OnHotAirBalloonToggle(HotAirBalloon hab, BasePlayer player)
        {
            return CanPlayerInteractWithVehicle(player, hab);
        }

        private object OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer player)
        {
            if (electricSwitch == null)
                return null;

            var autoTurret = electricSwitch.GetParentEntity() as AutoTurret;
            if (autoTurret != null)
                return CanPlayerInteractWithParentVehicle(player, autoTurret);

            return null;
        }

        private object OnTurretAuthorize(AutoTurret entity, BasePlayer player)
        {
            return CanPlayerInteractWithParentVehicle(player, entity);
        }

        private object OnTurretTarget(AutoTurret autoTurret, BasePlayer player)
        {
            if (autoTurret == null || player == null || player.UserIDString == null)
                return null;

            var turretParent = autoTurret.GetParentEntity();
            var vehicle = turretParent as BaseVehicle ?? (turretParent as BaseVehicleModule)?.Vehicle;
            if (vehicle == null)
                return null;

            var baseLock = GetVehicleLock(vehicle);
            if (baseLock == null)
                return null;

            if (CanPlayerBypassLock(player, baseLock, false))
                return false;

            return null;
        }

        private object CanSwapToSeat(BasePlayer player, ModularCarSeat carSeat)
        {
            // Don't lock taxi modules
            if (!carSeat.associatedSeatingModule.DoorsAreLockable)
                return null;

            return CanPlayerInteractWithParentVehicle(player, carSeat, false);
        }

        private object OnVehiclePush(BaseVehicle vehicle, BasePlayer player)
        {
            return CanPlayerInteractWithVehicle(player, vehicle);
        }

        private void OnEntityKill(BaseLock baseLock)
        {
            var vehicle = GetParentVehicle(baseLock);
            if (vehicle == null)
                return;

            _lockedVehicleTracker.OnLockRemoved(vehicle);
        }

        private void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (entity == null || info == null ||
                !info.damageTypes.Has(DamageType.Decay) ||
                !_config.Vehicles.Values.Any(vehicle => vehicle.Prefab == entity.PrefabName && vehicle.Skin == entity.skinID))
                return;

            info.damageTypes.ScaleAll(0f);
        }

        // Handle the case where a cockpit is removed but the car remains
        // If a lock is present, either move the lock to another cockpit or destroy it
        private void OnEntityKill(VehicleModuleSeating seatingModule)
        {
            if (seatingModule == null || !seatingModule.HasADriverSeat())
                return;

            var car = seatingModule.Vehicle as ModularCar;
            if (car == null)
                return;

            var baseLock = seatingModule.GetComponentInChildren<BaseLock>();
            if (baseLock == null)
                return;

            baseLock.SetParent(null);

            var car2 = car;
            var baseLock2 = baseLock;

            NextTick(() =>
            {
                if (car2 == null)
                {
                    _lockedVehicleTracker.OnLockRemoved(car2);
                    baseLock2.Kill();
                }
                else
                {
                    var driverModule = FindFirstDriverModule(car2);
                    if (driverModule == null)
                    {
                        _lockedVehicleTracker.OnLockRemoved(car2);
                        baseLock2.Kill();
                    }
                    else
                    {
                        baseLock2.SetParent(driverModule);
                    }
                }
            });
        }

        // Allow players to deploy locks directly without any commands.
        private object CanDeployItem(BasePlayer basePlayer, Deployer deployer, NetworkableId entityId)
        {
            if (basePlayer == null || deployer == null)
                return null;

            var deployable = deployer.GetDeployable();
            if (deployable == null)
                return null;

            var activeItem = basePlayer.GetActiveItem();
            if (activeItem == null)
                return null;

            var itemid = activeItem.info.itemid;

            LockInfo lockInfo;
            if (itemid == LockInfo_CodeLock.ItemId)
                lockInfo = LockInfo_CodeLock;
            else if (itemid == LockInfo_KeyLock.ItemId)
                lockInfo = LockInfo_KeyLock;
            else
                return null;

            var vehicle = GetVehicleFromEntity(BaseNetworkable.serverEntities.Find(entityId) as BaseEntity, basePlayer);
            if (vehicle == null)
                return null;

            var vehicleInfo = _vehicleInfoManager.GetVehicleInfo(vehicle);
            if (vehicleInfo == null)
                return null;

            var player = basePlayer.IPlayer;

            // Trick to make sure the replies are in chat instead of console.
            player.LastCommand = CommandType.Chat;

            if (!VerifyCanDeploy(player, vehicle, vehicleInfo, lockInfo)
                || !VerifyDeployDistance(player, vehicle))
                return false;

            activeItem.UseItem();
            DeployLockForPlayer(vehicle, vehicleInfo, lockInfo, basePlayer);
            return false;
        }

        private BaseLock DeployLock(BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo, ulong ownerId = 0)
        {
            var parentToEntity = vehicleInfo.DetermineLockParent(vehicle);
            if (parentToEntity == null)
                return null;

            var baseLock =
                GameManager.server.CreateEntity(lockInfo.Prefab, vehicleInfo.LockPosition, vehicleInfo.LockRotation) as
                    BaseLock;
            if (baseLock == null)
                return null;

            var keyLock = baseLock as KeyLock;
            if (keyLock != null) keyLock.keyCode = Random.Range(1, 100000);

            // Assign lock ownership when the lock is being deployed by/for a player.
            if (ownerId != 0) baseLock.OwnerID = ownerId;

            baseLock.SetParent(parentToEntity, vehicleInfo.ParentBone);
            baseLock.Spawn();
            vehicle.SetSlot(BaseEntity.Slot.Lock, baseLock);

            // Auto lock key locks to be consistent with vanilla.
            if (ownerId != 0 && keyLock != null) keyLock.SetFlag(BaseEntity.Flags.Locked, true);

            Effect.server.Run(Prefab_CodeLock_DeployedEffect, baseLock.transform.position);
            Interface.CallHook("OnVehicleLockDeployed", vehicle, baseLock);
            _lockedVehicleTracker.OnLockAdded(vehicle);

            return baseLock;
        }

        private BaseLock DeployLockForPlayer(BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo,
            BasePlayer player)
        {
            var originalVehicleOwnerId = vehicle.OwnerID;

            // Temporarily set the player as the owner of the vehicle, for compatibility with AutoCodeLock (OnItemDeployed).
            vehicle.OwnerID = player.userID;

            var baseLock = DeployLock(vehicle, vehicleInfo, lockInfo, player.userID);
            if (baseLock == null)
            {
                vehicle.OwnerID = originalVehicleOwnerId;
                return null;
            }

            // Allow other plugins to detect the code lock being deployed (e.g., to auto lock).
            var lockItem = GetPlayerLockItem(player, lockInfo);
            if (lockItem != null)
            {
                Interface.CallHook("OnItemDeployed", lockItem.GetHeldEntity(), vehicle, baseLock);
            }
            else
            {
                // Temporarily increase the player inventory capacity to ensure there is enough space.
                player.inventory.containerMain.capacity++;
                var temporaryLockItem = ItemManager.CreateByItemID(lockInfo.ItemId);
                if (player.inventory.GiveItem(temporaryLockItem))
                {
                    Interface.CallHook("OnItemDeployed", temporaryLockItem.GetHeldEntity(), vehicle, baseLock);
                    temporaryLockItem.RemoveFromContainer();
                }

                temporaryLockItem.Remove();
                player.inventory.containerMain.capacity--;
            }

            // Revert the vehicle owner to the original, after OnItemDeployed is called.
            vehicle.OwnerID = originalVehicleOwnerId;


            // Potentially assign vehicle ownership when the lock is being deployed by/for a player.
            ClaimVehicle(vehicle, player.userID);

            return baseLock;
        }

        private static void ClaimVehicle(BaseEntity vehicle, ulong ownerId)
        {
            vehicle.OwnerID = ownerId;
            Interface.CallHook("OnVehicleOwnershipChanged", vehicle);
        }

        private static Item GetPlayerLockItem(BasePlayer player, LockInfo lockInfo)
        {
            return player.inventory.FindItemByItemID(lockInfo.ItemId);
        }

        private bool VerifyDeployDistance(IPlayer player, BaseEntity vehicle)
        {
            if (vehicle.Distance(player.Object as BasePlayer) <= MaxDeployDistance)
                return true;

            return false;
        }

        private static bool IsDead(BaseEntity entity)
        {
            return (entity as BaseCombatEntity)?.IsDead() ?? false;
        }

        private bool VerifyVehicleIsNotDead(IPlayer player, BaseEntity vehicle)
        {
            if (!IsDead(vehicle))
                return true;

            return false;
        }

        private bool VerifyNotForSale(IPlayer player, BaseEntity vehicle)
        {
            var rideableAnimal = vehicle as BaseRidableAnimal;
            if (rideableAnimal == null || !rideableAnimal.IsForSale())
                return true;

            return false;
        }

        private bool AllowNoOwner(BaseEntity vehicle)
        {
            return vehicle.OwnerID != 0;
        }

        private bool AllowDifferentOwner(IPlayer player, BaseEntity vehicle)
        {
            return vehicle.OwnerID == 0
                   || vehicle.OwnerID.ToString() == player.Id;
        }

        private bool VerifyNoOwnershipRestriction(IPlayer player, BaseEntity vehicle)
        {
            if (!AllowNoOwner(vehicle)) return false;

            if (!AllowDifferentOwner(player, vehicle)) return false;

            return true;
        }

        private bool VerifyCanBuild(IPlayer player, BaseEntity vehicle)
        {
            var basePlayer = player.Object as BasePlayer;

            if (vehicle.OwnerID == 0)
            {
                if (!basePlayer.IsBuildingAuthed() || !basePlayer.IsBuildingAuthed(vehicle.WorldSpaceBounds()))
                    return false;
            }
            else if (basePlayer.IsBuildingBlocked() || basePlayer.IsBuildingBlocked(vehicle.WorldSpaceBounds()))
            {
                return false;
            }

            return true;
        }

        private bool VerifyVehicleHasNoLock(IPlayer player, BaseEntity vehicle)
        {
            if (GetVehicleLock(vehicle) == null)
                return true;

            return false;
        }

        private bool VerifyVehicleCanHaveALock(IPlayer player, BaseEntity vehicle)
        {
            if (CanVehicleHaveALock(vehicle))
                return true;

            return false;
        }

        private static bool CanCarHaveLock(ModularCar car)
        {
            return FindFirstDriverModule(car) != null;
        }

        private static bool CanVehicleHaveALock(BaseEntity vehicle)
        {
            // Only modular cars have restrictions
            var car = vehicle as ModularCar;
            return car == null || CanCarHaveLock(car);
        }

        private bool VerifyNotMounted(IPlayer player, BaseEntity vehicle, VehicleInfo vehicleInfo)
        {
            if (!vehicleInfo.IsMounted(vehicle))
                return true;

            return false;
        }

        private bool VerifyCanDeploy(IPlayer player, BaseEntity vehicle, VehicleInfo vehicleInfo, LockInfo lockInfo)
        {
            var basePlayer = player.Object as BasePlayer;

            return
                VerifyVehicleIsNotDead(player, vehicle)
                && VerifyNotForSale(player, vehicle)
                && VerifyNoOwnershipRestriction(player, vehicle)
                && VerifyCanBuild(player, vehicle)
                && VerifyVehicleHasNoLock(player, vehicle)
                && VerifyVehicleCanHaveALock(player, vehicle)
                && VerifyNotMounted(player, vehicle, vehicleInfo)
                && !DeployWasBlocked(vehicle, basePlayer, lockInfo);
        }

        private static bool DeployWasBlocked(BaseEntity vehicle, BasePlayer player, LockInfo lockInfo)
        {
            var hookResult = Interface.CallHook(lockInfo.PreHookName, vehicle, player);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static RidableHorse2 GetClosestHorse(HitchTrough hitchTrough, BasePlayer player)
        {
            var closestDistance = 1000f;
            RidableHorse2 closestHorse = null;

            for (var i = 0; i < hitchTrough.hitchSpots.Length; i++)
            {
                var hitchSpot = hitchTrough.hitchSpots[i];
                if (!hitchSpot.IsOccupied())
                    continue;

                var distance = Vector3.Distance(player.transform.position, hitchSpot.tr.position);
                if (distance < closestDistance)
                {
                    closestDistance = distance;
                    closestHorse = hitchSpot.hitchableEntRef.Get(true) as RidableHorse2;
                }
            }

            return closestHorse;
        }

        private static BaseEntity GetVehicleFromEntity(BaseEntity entity, BasePlayer basePlayer)
        {
            if (entity == null)
                return null;

            var module = entity as BaseVehicleModule;
            if (module != null)
                return module.Vehicle;

            var carLift = entity as ModularCarGarage;
            if ((object)carLift != null)
                return carLift.carOccupant;

            var hitchTrough = entity as HitchTrough;
            if ((object)hitchTrough != null)
                return GetClosestHorse(hitchTrough, basePlayer);

            return entity;
        }

        private object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (info == null || info.HitEntity == null || player == null)
                return null;

            var rhEntity = info.HitEntity;
            if (rhEntity.name.Contains("module_entities"))
                rhEntity = rhEntity.parentEntity.Get(true);
            if (rhEntity == null || rhEntity.OwnerID != player.userID)
                return null;

            var product = _config.Vehicles.FirstOrDefault(z =>
                z.Value.Prefab == rhEntity.PrefabName && z.Value.Skin == rhEntity.skinID);
            if (product.Equals(default(KeyValuePair<string, VehicleInfoConfig>)) || !product.Value.CanPickup)
                return null;

            if (player.inventory.containerMain.IsFull())
            {
                player.ChatMessage("Inventory is full. Cannot pick up the vehicle.");
                return null;
            }

            if (!GiveVehicle(player, product.Value, false))
            {
                player.ChatMessage("Unable to give vehicle to player.");
                return null;
            }

            if (rhEntity.TryGetComponent<ModularCar>(out var component))
                GetOutParts(component);

            var baseVehicle = rhEntity.GetComponent<BaseVehicle>();
            if (baseVehicle != null)
            {
                var fuelSystem = baseVehicle.GetFuelSystem();
                if (fuelSystem != null)
                {
                    var fuelAmount = fuelSystem.GetFuelAmount();
                    if (fuelAmount > 0)
                    {
                        var fuelItem = ItemManager.CreateByName("lowgradefuel", fuelAmount);
                        if (fuelItem != null && fuelItem.amount > 0)
                            if (!player.inventory.GiveItem(fuelItem))
                            {
                                player.ChatMessage($"{fuelItem.amount} fuel was dropped at your feet");
                                fuelItem.Drop(player.inventory.containerMain.dropPosition,
                                    player.inventory.containerMain.dropVelocity);
                            }
                    }
                }
            }

            rhEntity.Kill();
            player.ChatMessage($"Vehicle {product.Value.Name} was picked up");

            return false;
        }

        private void SpawnRecycler(BaseEntity entity, BasePlayer player, Vector3 position, Quaternion rotation,
            string prefab, ulong skin)
        {
            var recycler =
                GameManager.server.CreateEntity("assets/bundled/prefabs/static/recycler_static.prefab", position,
                    rotation) as Recycler;
            recycler.OwnerID = player.userID.Get();
            recycler.skinID = skin;
            recycler.Spawn();
            recycler._maxHealth = 1000;
            recycler.health = recycler.MaxHealth();
            NextFrame(() => { entity?.Kill(); });
        }

        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            var entity = gameObject?.ToBaseEntity();
            if (entity == null || entity.skinID <= 0) return;

            var item = planner.GetItem();
            if (item == null)
                return;

            var player = planner.GetOwnerPlayer();
            if (player == null) return;

            var vehicleSettings = _config.Vehicles.FirstOrDefault(x =>
                    x.Value.Skin == entity.skinID &&
                    item.name.Contains(x.Value.Name, StringComparison.OrdinalIgnoreCase))
                .Value;

            if (vehicleSettings == null)
                return;

            var rot = entity.transform.rotation;
            var pos = entity.transform.position;
            var prefab = vehicleSettings.Prefab;

            if (prefab.Contains("recycler_static"))
            {
                if (CanPlaceRecycler(entity, player))
                {
                    SpawnRecycler(entity, player, pos, rot, prefab, vehicleSettings.Skin);
                    return;
                }

                GiveVehicle(player, vehicleSettings, false);
                entity.Kill();
                player
                    .ChatMessage("Recycler cannot be placed here, it has been returned to your inventory.");
                return;
            }

            NextFrame(() => { entity?.Kill(); });

            if (!CanPlaceVehicle(pos))
                pos = GetPositionFromPlayer(player, vehicleSettings.SpawnDistance);

            var newEntity = GameManager.server.CreateEntity(prefab, pos, rot);

            if (newEntity == null)
            {
                GiveVehicle(player, vehicleSettings);
                return;
            }

            newEntity.OwnerID = player.userID;
            newEntity.