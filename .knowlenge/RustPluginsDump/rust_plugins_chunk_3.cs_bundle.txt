      timers[player] = resetTime;
            DrawUI(player, grades[player], timers[player]);
        }
        object BuildingUpgradeActivate(ulong id)
        {
            var player = BasePlayer.FindByID(id);
            if (player != null) if (grades.ContainsKey(player)) return true;
            return false;
        }
        void BuildingUpgradeDeactivate(ulong id)
        {
            var player = BasePlayer.FindByID(id);
            if (player != null)
            {
                grades.Remove(player);
                timers.Remove(player);
                DestroyUI(player);
            }
        }
    }
}                                                        

// --- End of file: BuildingUpgrade.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RockBlock.cs ---
// --- Original Local Path: RockBlock.cs ---

﻿using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RockBlock", "Nogrod", "1.0.4")]
    class RockBlock : RustPlugin
    {
        private readonly int worldLayer = LayerMask.GetMask("World", "Default");
        private const BaseNetworkable.DestroyMode DestroyMode = BaseNetworkable.DestroyMode.None;
        private ConfigData configData;

        class ConfigData
        {
            public int MaxHeight { get; set; }
            public bool AllowCave { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                MaxHeight = -1,
                AllowCave = false
            };
            Config.WriteObject(config, true);
        }

        private void Init()
        {
            configData = Config.ReadObject<ConfigData>();
        }

        void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null || player.IsAdmin()) return;
            var entity = gameObject.GetComponent<BaseEntity>();
            RaycastHit hitInfo;
            if (configData.MaxHeight > 0 && Physics.Raycast(new Ray(entity.transform.position, Vector3.down), out hitInfo, float.PositiveInfinity, Rust.Layers.Terrain))
            {
                if (hitInfo.distance > configData.MaxHeight)
                {
                    SendReply(player, "Distance to ground too high: {0}", hitInfo.distance);
                    entity.Kill(DestroyMode);
                    return;
                }
            }
            CheckEntity(entity, player);
        }

        void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            var player = deployer.GetOwnerPlayer();
            if (player == null || player.IsAdmin()) return;
            CheckEntity(entity, player);
        }

        private void CheckEntity(BaseEntity entity, BasePlayer player)
        {
            if (entity == null) return;
            var targets = Physics.RaycastAll(new Ray(entity.transform.position + Vector3.up * 200f, Vector3.down), 250, worldLayer);
            foreach (var hit in targets)
            {
                var collider = hit.collider.GetComponent<MeshCollider>();
                //if (collider != null) SendReply(player, $"Rock: {collider.sharedMesh.name}");
                if (collider == null || !collider.sharedMesh.name.StartsWith("rock_") || !IsInside(hit.collider, entity) && (configData.AllowCave || !IsInCave(entity, player))) continue;
                Puts($"{player.displayName} is suspected of building {entity.PrefabName} inside a rock at {entity.transform.position}!");
                entity.Kill(DestroyMode);
                break;
            }
        }

        private bool IsInCave(BaseEntity entity, BasePlayer player)
        {
            var targets = Physics.RaycastAll(new Ray(entity.transform.position, Vector3.up), 250, worldLayer);
            foreach (var hit in targets)
            {
                var collider = hit.collider.GetComponent<MeshCollider>();
                //if (collider != null) SendReply(player, $"Cave: {collider.sharedMesh.name}");
                if (collider == null || !collider.sharedMesh.name.StartsWith("rock_")) continue;
                return true;
            }
            return false;
        }

        private static bool IsInside(Collider collider, BaseEntity entity)
        {
            var center = collider.bounds.center;
            //var point = entity.ClosestPoint(center);
            var point = entity.WorldSpaceBounds().ToBounds().max;
            var direction = center - point;
            var ray = new Ray(point, direction);
            RaycastHit hitInfo;
            return !collider.Raycast(ray, out hitInfo, direction.magnitude + 1);
        }
    }
}


// --- End of file: RockBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPBotbonus.cs ---
// --- Original Local Path: TPBotbonus.cs ---

﻿using Newtonsoft.Json; 
using Newtonsoft.Json.Converters; 
using Newtonsoft.Json.Linq; 
using Oxide.Core; 
using Oxide.Core.Configuration; 
using Oxide.Core.Plugins; 
using Oxide.Game.Rust.Cui; 
using System; using System.Collections.Generic; 
using System.Globalization; 
using System.Linq; 
using UnityEngine; 

namespace Oxide.Plugins 
{ 
    [Info("TPBotbonus", "Sempai#3239", "4.0.1")] 
    class TPBotbonus : RustPlugin 
    { 
        [PluginReference] Plugin Duel, ImageLibrary; 
        
        static string apiver = "v=5.92"; 
        
        private bool OxideUpdateSended = false; 
        private System.Random random = new System.Random(); 
        private bool NewWipe = false; 
        JsonSerializerSettings jsonsettings; 

        private List<string> allowedentity = new List<string>() 
        { 
            "door", 
            "wall.window.bars.metal", 
            "wall.window.bars.toptier", 
            "wall.external", 
            "gates.external.high", 
            "floor.ladder", 
            "embrasure", 
            "floor.grill", 
            "wall.frame.fence", 
            "wall.frame.cell", 
            "foundation", 
            "floor.frame", 
            "floor.triangle", 
            "floor", 
            "foundation.steps", 
            "foundation.triangle", 
            "roof", 
            "stairs.l", 
            "stairs.u", 
            "wall.doorway", 
            "wall.frame", 
            "wall.half", 
            "wall.low", 
            "wall.window", 
            "wall", 
            "wall.external.high.stone" 
        }; 
        
        List<string> ExplosiveList = new List<string>() 
        { 
            "explosive.satchel.deployed", 
            "grenade.f1.deployed", 
            "grenade.beancan.deployed", 
            "explosive.timed.deployed" 
        }; 
        
        private List<ulong> BDayPlayers = new List<ulong>(); 
        
        class GiftItem 
        { 
            public string shortname; 
            public ulong skinid; 
            public int count; 
        } 
        
        class ServerInfo 
        { 
            public string name; 
            public string online; 
            public string slots; 
            public string sleepers; 
            public string map; 
        } 
        
        private Dictionary<BasePlayer, DateTime> GiftsList = new Dictionary<BasePlayer, DateTime>(); 
        
        private ConfigData config; 
        private class ConfigData 
        { 
            [JsonProperty(PropertyName = "Ключи VK API, ID группы")] public VKAPITokens VKAPIT;
            [JsonProperty(PropertyName = "Награда за вступление в группу")] public GroupGifts GrGifts;
            [JsonProperty(PropertyName = "Оповещения при вайпе")] public WipeSettings WipeStg;
            
            public class VKAPITokens 
            { 
                [JsonProperty(PropertyName = "VK Token группы (для сообщений)")] public string VKToken = "vk1.a.OdN7gCS7swWRnK4ypRBdPObwJOyUpa-fOSJQFOupnOnYVTi0vLlrMFAFz3lOVbDmhfi6puF3amFAGE43KHh-JCaexjteVScr8SzW0UFTaxjLYkAu423ssvVUwQqsdeqEKcSSo4u69f2RORMjTEey7tkxVG8ZfiuvrPHq_KtqIhELYRu-JP12jJQ-ZOMx0X1weBlqOrOcWPWmb6IX7lMHEg"; 
                [JsonProperty(PropertyName = "VK Token приложения (для записей на стене и статуса)")] public string VKTokenApp = ""; 
                [JsonProperty(PropertyName = "VKID группы")] public string GroupID = "223960721"; 
            } 
            public class GroupGifts 
            { 
                [JsonProperty(PropertyName = "Выдавать подарок игроку за вступление в группу ВК?")] public bool VKGroupGifts = true; 
                [JsonProperty(PropertyName = "Подарок за вступление в группу (команда, если стоит none выдаются предметы из файла data/TPBotbonus.json). Пример: grantperm {steamid} vkraidalert.allow 7d")] public string VKGroupGiftCMD = "none"; 
                [JsonProperty(PropertyName = "Описание команды")] public string GiftCMDdesc = "Оповещения о рейде на 7 дней"; 
                [JsonProperty(PropertyName = "Ссылка на группу ВК")] public string VKGroupUrl = "https://vk.com/rustage_su"; 
                [JsonProperty(PropertyName = "Оповещения в общий чат о получении награды")] public bool GiftsBool = true; 
                [JsonProperty(PropertyName = "Включить оповещения для игроков не получивших награду за вступление в группу?")] public bool VKGGNotify = true; 
                [JsonProperty(PropertyName = "Интервал оповещений для игроков не получивших награду за вступление в группу (в минутах)")] public int VKGGTimer = 30; 
                [JsonProperty(PropertyName = "Выдавать награду каждый вайп?")] public bool GiftsWipe = true; 
            } 
            public class WipeSettings 
            { 
                [JsonProperty(PropertyName = "Отправлять пост в группу после вайпа?")] public bool WPostB = true; 
                [JsonProperty(PropertyName = "Текст поста о вайпе")] public string WPostMsg = "RUSTAGE | WIPE {wipedate}"; 
                [JsonProperty(PropertyName = "Добавить изображение к посту о вайпе?")] public bool WPostAttB = false; 
                [JsonProperty(PropertyName = "Отправлять сообщение администратору о вайпе?")] public bool WPostMsgAdmin = true; 
                [JsonProperty(PropertyName = "Ссылка на изображение к посту о вайпе вида 'photo-1_265827614' (изображение должно быть в альбоме группы)")] public string WPostAtt = "photo-223960721_456239064"; 
                [JsonProperty(PropertyName = "Отправлять игрокам сообщение о вайпе автоматически?")] public bool WMsgPlayers = true; 
                [JsonProperty(PropertyName = "Текст сообщения игрокам о вайпе (сообщение отправляется только тем кто подтвердил профиль)")] public string WMsgText = "Сервер вайпнут! Залетай скорее!";
                [JsonProperty(PropertyName = "Игнорировать тех кто подтвердил профиль? (если включено, сообщение о вайпе будет отправляться всем)")] public bool WCMDIgnore = false; [JsonProperty(PropertyName = "Смена названия группы после вайпа")] public bool GrNameChange = false; 
                [JsonProperty(PropertyName = "Название группы (переменная {wipedate} отображает дату последнего вайпа)")] public string GrName = "ServerName | WIPE {wipedate}"; 
            } 
        } 
        
        private void LoadVariables() 
        { 
            bool changed = false; 
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate; 
            config = Config.ReadObject<ConfigData>(); 
            if (config.GrGifts == null) 
            { 
                config.GrGifts = new ConfigData.GroupGifts(); 
                changed = true; 
            } 
            if (config.WipeStg == null) 
            { 
                config.WipeStg = new ConfigData.WipeSettings(); 
                changed = true; 
            } 
            if (changed) PrintWarning("Конфигурационный файл обновлен"); 
        } 
        
        protected override void LoadDefaultConfig() 
        { 
            var configData = new ConfigData 
            {
                VKAPIT = new ConfigData.VKAPITokens(), 
                GrGifts = new ConfigData.GroupGifts(),
                WipeStg = new ConfigData.WipeSettings()
            }; 
            Config.WriteObject(configData, true); 
        } 
        
        class DataStorageStats 
        { 
            public int WoodGath; 
            public int SulfureGath; 
            public int Rockets; 
            public int Blueprints; 
            public int Explosive; 
            public int Reports; 
            public List<GiftItem> Gifts; 
            public DataStorageStats() { } 
        } 
        class DataStorageUsers 
        { 
            public Dictionary<ulong, VKUDATA> VKUsersData = new Dictionary<ulong, VKUDATA>(); 
            public DataStorageUsers() { } 
        } 
        class VKUDATA 
        { 
            public ulong UserID; 
            public string Name; 
            public string VkID; 
            public string VkOwnerID; 
            public int ConfirmCode; 
            public bool Confirmed; 
            public bool GiftRecived; 
            public string LastRaidNotice; 
            public bool WipeMsg; 
            public string Bdate; 
            public int Raids; 
            public int Kills; 
            public int Farm; 
            public string LastSeen; 
        } 
        class DataStorageReports 
        { 
            public Dictionary<int, REPORT> VKReportsData = new Dictionary<int, REPORT>(); 
            public DataStorageReports() { } 
        } 
        class REPORT 
        { 
            public ulong UserID; 
            public string Name;
            public string Text; 
        } 

        DataStorageStats statdata; 
        DataStorageUsers usersdata; 
        DataStorageReports reportsdata; 
        private DynamicConfigFile VKBData; 
        private DynamicConfigFile StatData; 
        private DynamicConfigFile ReportsData; 
        
        void LoadData() 
        { 
            try 
            { 
                statdata = Interface.GetMod().DataFileSystem.ReadObject<DataStorageStats>("TPBotbonus"); 
                usersdata = Interface.GetMod().DataFileSystem.ReadObject<DataStorageUsers>("TPBotbonusUsers"); 
                reportsdata = Interface.GetMod().DataFileSystem.ReadObject<DataStorageReports>("TPBotbonusReports"); 
            } 
            catch 
            { 
                statdata = new DataStorageStats(); usersdata = new DataStorageUsers(); 
                reportsdata = new DataStorageReports(); 
            } 
        } 
        
        private void OnServerInitialized() 
        {			
            PrintWarning("\n-----------------------------\n " +" Author - Sempai#3239\n " +" VK - https://vk.com/rustnastroika\n " +" Forum - https://topplugin.ru\n " +" Discord - https://discord.gg/5DPTsRmd3G\n" +"-----------------------------");
            
            LoadVariables(); 
            
            VKBData = Interface.Oxide.DataFileSystem.GetFile("TPBotbonusUsers");
            StatData = Interface.Oxide.DataFileSystem.GetFile("TPBotbonus");
            ReportsData = Interface.Oxide.DataFileSystem.GetFile("TPBotbonusReports");
            ImageLibrary.Call("AddImage", VkICO, ".VkICO"); 
            ImageLibrary.Call("AddImage", GiftICO, ".GiftICO"); 
            ImageLibrary.Call("AddImage", AlertICO, ".AlertICO"); 
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/bonus_bg.png", "BackgroundImage"); 
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/bonus_btn_block.png", "ButtonBlock");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/bonus_modal_connect.png", "alerts");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/bonus_modal_connect.png", "alerts1");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/bonus_modal_field.png", "alertvkback");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/bonus_modal_delete.png", "vkdeleteback");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/bonus_modal_getbonus.png", "giftrewardback");
            
            permission.RegisterPermission(AlertPermission, this); 
            
            string msg2 = null; 
            msg2 = $"[TPBotbonus] Сервер успешно загружен."; 
            
            LoadData(); 

            if (NewWipe)		
        	WipeFunctions();
            
            if (statdata.Gifts == null) 
            { 
                statdata.Gifts = new List<GiftItem>() 
                { 
                    new GiftItem 
                    { 
                        shortname = "supply.signal", 
                        count = 1, 
                        skinid = 0 
                    }, 
                    new GiftItem 
                    { 
                        shortname = "pookie.bear", 
                        count = 2, 
                        skinid = 0 
                    } 
                }; 
                
                StatData.WriteObject(statdata); 
            } 
            if (config.GrGifts.VKGGNotify) 
                timer.Repeat(config.GrGifts.VKGGTimer * 60, 0, GiftNotifier); 
        } 
        
        private void Init() 
        { 
            cmd.AddChatCommand("regvk", this, "VKcommand"); 
            cmd.AddConsoleCommand("updatestatus", this, "UStatus"); 
            cmd.AddConsoleCommand("updatewidget", this, "UWidget"); 
            cmd.AddConsoleCommand("updatelabel", this, "ULabel"); 
            cmd.AddConsoleCommand("sendmsgadmin", this, "MsgAdmin"); 
            cmd.AddConsoleCommand("wipealerts", this, "WipeAlerts"); 
            cmd.AddConsoleCommand("userinfo", this, "GetUserInfo"); 
            cmd.AddConsoleCommand("report.answer", this, "ReportAnswer"); 
            cmd.AddConsoleCommand("reports.list", this, "ReportList"); 
            cmd.AddConsoleCommand("report.wipe", this, "ReportClear"); 
            cmd.AddConsoleCommand("usersdata.update", this, "UpdateUsersData"); 
            
            jsonsettings = new JsonSerializerSettings(); 
            jsonsettings.Converters.Add(new KeyValuePairConverter()); 
        } 
        
        private void Loaded() => LoadMessages(); 
        
        private void Unload() 
        { 
            UnloadAllGUI(); 
        } 
        
        private void OnNewSave(string filename) => NewWipe = true; 
        
        private void OnPlayerInit(BasePlayer player) 
        { 
            if (usersdata.VKUsersData.ContainsKey(player.userID) && usersdata.VKUsersData[player.userID].Name != player.displayName) 
            { 
                usersdata.VKUsersData[player.userID].Name = player.displayName; VKBData.WriteObject(usersdata); 
            }  
        } 
            
        private void OnPlayerDisconnected(BasePlayer player, string reason) 
        {  
            if (usersdata.VKUsersData.ContainsKey(player.userID)) 
            { 
                usersdata.VKUsersData[player.userID].LastSeen = DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss"); 
                VKBData.WriteObject(usersdata); 
            } 
        }   
            private void UpdateUsersData(ConsoleSystem.Arg arg) 
            { 
                if (arg.IsAdmin != true) return; 
                DeleteOldUsers(arg.Args?[0]); 
            } 
            private void CheckVkUser(BasePlayer player, string url) 
            { 
                string Userid = null; 
                string[] arr1 = url.Split('/'); 
                string vkname = arr1[arr1.Length - 1]; 
                webrequest.Enqueue("https://api.vk.com/method/users.get?user_ids=" + vkname + "&" + apiver + "&fields=bdate&access_token=" + config.VKAPIT.VKToken, null, (code, response) => { 
                    if (!response.Contains("error")) 
                    { 
                        var json = JObject.Parse(response); 
                        Userid = (string)json["response"][0]["id"]; 
                        string bdate = (string)json["response"][0]["bdate"] ?? "noinfo"; 
                        if (Userid != null) 
                            AddVKUser(player, Userid, bdate); 
                        else 
                            PrintToChat(player, "Ошибка обработки вашей ссылки ВК, обратитесь к администратору."); 
                    } 
                    else 
                    { 
                        PrintWarning($"Ошибка проверки ВК профиля игрока {player.displayName} ({player.userID}). URL - {url}"); 
                        Log("checkresponce", $"Ошибка проверки ВК профиля игрока {player.displayName} ({player.userID}). URL - {url}. Ответ сервера ВК: {response}"); 
                    } 
                }, this); 
            } 
            
            private void AddVKUser(BasePlayer player, string Userid, string bdate) 
            { 
                if (!usersdata.VKUsersData.ContainsKey(player.userID)) 
                { 
                    usersdata.VKUsersData.Add(player.userID, new VKUDATA() 
                    { 
                        UserID = player.userID, 
                        Name = player.displayName, 
                        VkID = Userid, 
                        ConfirmCode = random.Next(1, 9999999), 
                        Confirmed = false, 
                        GiftRecived = false, 
                        Bdate = bdate, 
                        Farm = 0, 
                        Kills = 0, 
                        Raids = 0, 
                        LastSeen = DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss") 
                    }); 
                    VKBData.WriteObject(usersdata); 
                    SendConfCode(usersdata.VKUsersData[player.userID].VkID, $"Для подтверждения вашего ВК профиля введите в игровой чат команду /regvk confirm {usersdata.VKUsersData[player.userID].ConfirmCode}", player); 
                } 
                else 
                { 
                    if (Userid == usersdata.VKUsersData[player.userID].VkID && usersdata.VKUsersData[player.userID].Confirmed) 
                    { 
                        PrintToChat(player, string.Format(GetMsg("ПрофильДобавленИПодтвержден"))); 
                        return; 
                    } 
                    if (Userid == usersdata.VKUsersData[player.userID].VkID && !usersdata.VKUsersData[player.userID].Confirmed) 
                    { 
                        PrintToChat(player, string.Format(GetMsg("ПрофильДобавлен"))); 
                        return; 
                    } 
                    usersdata.VKUsersData[player.userID].Name = player.displayName; 
                    usersdata.VKUsersData[player.userID].VkID = Userid; 
                    usersdata.VKUsersData[player.userID].Confirmed = false; 
                    usersdata.VKUsersData[player.userID].ConfirmCode = random.Next(1, 9999999); 
                    usersdata.VKUsersData[player.userID].Bdate = bdate; 
                    VKBData.WriteObject(usersdata); 
                    SendConfCode(usersdata.VKUsersData[player.userID].VkID, $"Для подтверждения вашего ВК профиля введите в игровой чат команду /regvk confirm {usersdata.VKUsersData[player.userID].ConfirmCode}", player); 
                } 
            } 
            
            private void VKcommand(BasePlayer player, string cmd, string[] args) 
            { 
                Effect Confirmed = new Effect("assets/prefabs/misc/easter/painted eggs/effects/gold_open.prefab", player, 0, new Vector3(), new Vector3()); 
                if (args.Length > 0) 
                { 
                    if (args[0] == "add") 
                    { 
                        if (args.Length == 1) 
                        { 
                            PrintToChat(player, string.Format(GetMsg("Подсказка"))); 
                            return; 
                        } 
                        if (!args[1].Contains("vk.com/")) 
                        { 
                            PrintToChat(player, string.Format(GetMsg("НеправильнаяСсылка"))); 
                            return; 
                        } 
                        CheckVkUser(player, args[1]); 
                    } 
                    if (args[0] == "confirm") 
                    { 
                        if (args.Length >= 2) 
                        { 
                            if (usersdata.VKUsersData.ContainsKey(player.userID)) 
                            { 
                                if (usersdata.VKUsersData[player.userID].Confirmed) 
                                { 
                                    PrintToChat(player, string.Format(GetMsg("ПрофильДобавленИПодтвержден"))); 
                                    return; 
                                } 
                                if (args[1] == usersdata.VKUsersData[player.userID].ConfirmCode.ToString()) 
                                { 
                                    usersdata.VKUsersData[player.userID].Confirmed = true; 
                                    VKBData.WriteObject(usersdata); 
                                    PrintToChat(player, string.Format(GetMsg("ПрофильПодтвержден"))); 
                                    EffectNetwork.Send(Confirmed, player.Connection); 
                                    if (config.GrGifts.VKGroupGifts) 
                                        PrintToChat(player, string.Format(GetMsg("ОповещениеОПодарках"), config.GrGifts.VKGroupUrl)); 
                                } 
                                else 
                                    PrintToChat(player, string.Format(GetMsg("НеверныйКод"))); 
                            } 
                            else 
                                PrintToChat(player, string.Format(GetMsg("ПрофильНеДобавлен"))); 
                        } 
                        else 
                        { 
                            if (!usersdata.VKUsersData.ContainsKey(player.userID)) 
                            { 
                                PrintToChat(player, string.Format(GetMsg("ПрофильНеДобавлен"))); 
                                return; 
                            } 
                            if (usersdata.VKUsersData[player.userID].Confirmed) 
                            { 
                                PrintToChat(player, string.Format(GetMsg("ПрофильДобавленИПодтвержден"))); 
                                return; 
                            } 
                            SendConfCode(usersdata.VKUsersData[player.userID].VkID, $"Для подтверждения вашего ВК профиля введите в игровой чат команду /regvk confirm {usersdata.VKUsersData[player.userID].ConfirmCode}", player); 
                        } 
                    } 
                    if (args[0] == "gift") FixedGifts(player); 
                    if (args[0] == "wipealerts") 
                        WAlert(player); 
                    if (args[0] != "add" && args[0] != "gift" && args[0] != "confirm") 
                    { 
                        PrintToChat(player, string.Format(GetMsg("ДоступныеКоманды"))); 
                        if (config.GrGifts.VKGroupGifts) 
                            PrintToChat(player, string.Format(GetMsg("ОповещениеОПодарках"), config.GrGifts.VKGroupUrl)); 
                    } 
                } 
                else 
                    PrintToChat(player, string.Format(GetMsg("ДоступныеКоманды"))); 
            } 
                
            private void WAlert(BasePlayer player) 
            { 
                if (!usersdata.VKUsersData.ContainsKey(player.userID)) 
                { 
                    PrintToChat(player, string.Format(GetMsg("ПрофильНеДобавлен"))); 
                    return; 
                } 
                if (!usersdata.VKUsersData[player.userID].Confirmed) 
                { 
                    PrintToChat(player, string.Format(GetMsg("ПрофильНеПодтвержден"))); 
                    return; 
                } 
                if (usersdata.VKUsersData[player.userID].WipeMsg) 
                { 
                    usersdata.VKUsersData[player.userID].WipeMsg = false; 
                    VKBData.WriteObject(usersdata); 
                    PrintToChat(player, string.Format(GetMsg("ПодпискаОтключена"))); 
                } 
                else 
                { 
                    usersdata.VKUsersData[player.userID].WipeMsg = true; 
                    VKBData.WriteObject(usersdata); 
                    PrintToChat(player, string.Format(GetMsg("ПодпискаВключена"))); 
                } 
            } 
            
            private void VKGift(BasePlayer player) 
            { 
                if (config.GrGifts.VKGroupGifts) 
                { 
                    if (!usersdata.VKUsersData.ContainsKey(player.userID)) 
                    { 
                        PrintToChat(player, string.Format(GetMsg("ПрофильНеДобавлен"))); 
                        return; 
                    } 
                    if (!usersdata.VKUsersData[player.userID].Confirmed) 
                    { 
                        PrintToChat(player, string.Format(GetMsg("ПрофильНеПодтвержден"))); 
                        return; 
                    } 
                    if (usersdata.VKUsersData[player.userID].GiftRecived) 
                    { 
                        PrintToChat(player, string.Format(GetMsg("НаградаУжеПолучена"))); 
                        return; 
                    } 
                    webrequest.Enqueue($"https://api.vk.com/method/groups.isMember?group_id={config.VKAPIT.GroupID}&user_id={usersdata.VKUsersData[player.userID].VkID}&" + apiver + $"&access_token={config.VKAPIT.VKToken}", null, (code, response) => { 
                        if (response == null || !response.Contains("response")) return; 
                            var json = JObject.Parse(response); 
                            
                            if (json == null) return; 
                                string Result = (string)json["response"]; 
                                
                                if (Result == null) return; 
                                GetGift(code, Result, player); 
                            }, this); 
                    } 
                    else 
                        PrintToChat(player, string.Format(GetMsg("ФункцияОтключена"))); 
                } 
                    
                private void GetGift(int code, string Result, BasePlayer player) 
                { 
                    string msg2 = null; 
                    msg2 = $"[TPBotbonus] Игрок {player.displayName} ({player.userID}) получил награду за подписку!"; 
                    Effect Gift = new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0, new Vector3(), new Vector3()); 
                    if (Result == "1") 
                    { 
                        if (config.GrGifts.VKGroupGiftCMD == "none") 
                        { 
                            if ((24 - player.inventory.containerMain.itemList.Count) >= statdata.Gifts.Count) 
                            { 
                                usersdata.VKUsersData[player.userID].GiftRecived = true; 
                                VKBData.WriteObject(usersdata); 
                                PrintToChat(player, string.Format(GetMsg("НаградаПолучена"))); 
                                
                                if (config.GrGifts.GiftsBool) 
                                    Server.Broadcast(string.Format(GetMsg("ПолучилНаграду"), player.displayName, config.GrGifts.VKGroupUrl)); 
                                
                                foreach (GiftItem gf in statdata.Gifts) 
                                { 
                                    Item gift = ItemManager.CreateByName(gf.shortname, gf.count, gf.skinid); 
                                    gift.MoveToContainer(player.inventory.containerMain, -1, false); 
                                } 
                                EffectNetwork.Send(Gift, player.Connection); 
                            } 
                            else 
                                PrintToChat(player, string.Format(GetMsg("НетМеста"))); 
                        } 
                        else 
                        { 
                            string cmd = config.GrGifts.VKGroupGiftCMD.Replace("{steamid}", player.userID.ToString()); 
                            rust.RunServerCommand(cmd); 
                            usersdata.VKUsersData[player.userID].GiftRecived = true; 
                            VKBData.WriteObject(usersdata); 
                            PrintToChat(player, string.Format(GetMsg("НаградаПолученаКоманда"), config.GrGifts.GiftCMDdesc)); 
                            
                            if (config.GrGifts.GiftsBool) 
                                Server.Broadcast(string.Format(GetMsg("ПолучилНаграду"), player.displayName, config.GrGifts.VKGroupUrl)); 
                            
                            EffectNetwork.Send(Gift, player.Connection); 
                        } 
                    } 
                    else 
                        PrintToChat(player, string.Format(GetMsg("НеВступилВГруппу"), config.GrGifts.VKGroupUrl)); 
                } 
                    
                private void GiftNotifier() 
                { 
                    if (config.GrGifts.VKGroupGifts) 
                    { 
                        foreach (var pl in BasePlayer.activePlayerList) 
                        { 
                            if (!usersdata.VKUsersData.ContainsKey(pl.userID)) 
                                PrintToChat(pl, string.Format(GetMsg("ОповещениеОПодарках"), config.GrGifts.VKGroupUrl)); 
                            else 
                            { 
                                if (!usersdata.VKUsersData[pl.userID].GiftRecived) PrintToChat(pl, string.Format(GetMsg("ОповещениеОПодарках"), config.GrGifts.VKGroupUrl)); 
                            } 
                        } 
                    } 
                } 
                void WipeFunctions()
                {
                    if (config.WipeStg.WPostMsgAdmin)
                    {
                        if (config.WipeStg.WPostB)
                    {
                    if (config.WipeStg.WPostAttB)
                    SendVkWall($"{config.WipeStg.WPostMsg}&attachments={config.WipeStg.WPostAtt}");
                    else 

                    SendVkWall($"{config.WipeStg.WPostMsg}"); 
                } 
                if (config.GrGifts.GiftsWipe) 
                { 
                    if (usersdata.VKUsersData.Count != 0) 
                    { 
                        for (int i = 0; i < usersdata.VKUsersData.Count; i++) 
                        { 
                            usersdata.VKUsersData.ElementAt(i).Value.GiftRecived = false; 
                        } 
                        VKBData.WriteObject(usersdata); 
                    } 
                } 
                if (config.WipeStg.WMsgPlayers) WipeAlertsSend(); 
                if (config.WipeStg.GrNameChange) 
                { 
                    string wipedate = WipeDate(); 
                    string text = config.WipeStg.GrName.Replace("{wipedate}", wipedate); 
                    webrequest.Enqueue("https://api.vk.com/method/groups.edit?group_id=" + config.VKAPIT.GroupID + "&title=" + text + "&" + apiver + "&access_token=" + config.VKAPIT.VKTokenApp, null, (code, response) => { 
                        var json = JObject.Parse(response); 
                        string Result = (string)json["response"]; 
                        if (Result == "1") 
                            PrintWarning($"Новое имя группы - {text}"); 
                        else 
                        { 
                            PrintWarning("Ошибка смены имени группы. Логи - /oxide/logs/TPBotbonus/"); 
                            Log("Errors", $"group title not changed. Error: {response}"); 
                        } 
                    }, this); 
                } 
            }
        } 

        private void WipeAlertsSend() 
        { 
                List<string> UserList = new List<string>(); 
                string userlist = ""; 
                int usercount = 0; 
                if (usersdata.VKUsersData.Count != 0) 
                { 
                    for (int i = 0; i < usersdata.VKUsersData.Count; i++) 
                    { 
                        if (config.WipeStg.WCMDIgnore || usersdata.VKUsersData.ElementAt(i).Value.WipeMsg) 
                        { 
                            if (!ServerUsers.BanListString().Contains(usersdata.VKUsersData.ElementAt(i).Value.UserID.ToString())) 
                            { 
                                if (usercount == 100) 
                                { 
                                    UserList.Add(userlist); userlist = ""; 
                                    usercount = 0; 
                                } 
                                if (usercount > 0) 
                                    userlist = userlist + ", "; 
                                userlist = userlist + usersdata.VKUsersData.ElementAt(i).Value.VkID; 
                                usercount++;
                            } 
                        }
                    } 
                } 
                if (userlist == "" && UserList.Count == 0) 
                { 
                    PrintWarning($"Список адресатов рассылки о вайпе пуст."); 
                    return; 
                } 
                if (UserList.Count > 0) 
                { 
                    foreach (var list in UserList) 
                        SendVkMessage(list, config.WipeStg.WMsgText); 
                } 

                SendVkMessage(userlist, config.WipeStg.WMsgText); 
            } 

                private void SendConfCode(string reciverID, string msg, BasePlayer player) => webrequest.Enqueue("https://api.vk.com/method/messages.send?user_ids=" + reciverID + "&message=" + msg + "&" + apiver + "&random_id=" + RandomId() + "&access_token=" + config.VKAPIT.VKToken, null, (code, response) => GetCallback(code, response, "Код подтверждения", player), this); 
                
                private void SendVkMessage(string reciverID, string msg) => webrequest.Enqueue("https://api.vk.com/method/messages.send?user_ids=" + reciverID + "&message=" + URLEncode(msg) + "&"+apiver + "&random_id=" + RandomId() + "&access_token=" + config.VKAPIT.VKToken, null, (code, response) => GetCallback(code, response, "Сообщение"), this); 
                
                private void SendVkWall(string msg) => webrequest.Enqueue("https://api.vk.com/method/wall.post?owner_id=-" + config.VKAPIT.GroupID + "&message=" + URLEncode(msg) + "&from_group=1&"+apiver+"&access_token=" + config.VKAPIT.VKTokenApp, null, (code, response) => GetCallback(code, response, "Пост"), this); 
                
                private void SendVkStatus(string msg) => webrequest.Enqueue("https://api.vk.com/method/status.set?group_id=" + config.VKAPIT.GroupID + "&text=" + URLEncode(msg) + "&" + apiver + "&access_token=" + config.VKAPIT.VKTokenApp, null, (code, response) => GetCallback(code, response, "Статус"), this); 
                
                private void AddComentToBoard(string topicid, string msg) => webrequest.Enqueue("https://api.vk.com/method/board.createComment?group_id=" + config.VKAPIT.GroupID + "&topic_id=" + URLEncode(topicid) + "&from_group=1&message=" + msg + "&"+apiver+"&access_token=" + config.VKAPIT.VKTokenApp, null, (code, response) => GetCallback(code, response, "Комментарий в обсуждения"), this); 
                
                private string RandomId() => random.Next(Int32.MinValue, Int32.MaxValue).ToString(); 
                string GetUserVKId(ulong userid) 
                { 
                    if (!usersdata.VKUsersData.ContainsKey(userid) || !usersdata.VKUsersData[userid].Confirmed) return null; 
                    if (BannedUsers.Contains(userid.ToString())) return null; 
                    return usersdata.VKUsersData[userid].VkID; 
                } 
                string GetUserLastNotice(ulong userid) 
                { 
                    if (!usersdata.VKUsersData.ContainsKey(userid) || !usersdata.VKUsersData[userid].Confirmed) return null; 
                    return usersdata.VKUsersData[userid].LastRaidNotice; 
                } 

                private void VKAPISaveLastNotice(ulong userid, string lasttime) 
                { 
                    if (usersdata.VKUsersData.ContainsKey(userid)) 
                    { 
                        usersdata.VKUsersData[userid].LastRaidNotice = lasttime; 
                        VKBData.WriteObject(usersdata); 
                    } 
                } 
                
                private void VKAPIWall(string text, string attachments, bool atimg) 
                { 
                    if (atimg) 
                    { 
                        SendVkWall($"{text}&attachments={attachments}"); 
                        Log("tpbotbonusapi", $"Отправлен новый пост на стену: ({text}&attachments={attachments})"); 
                    } 
                    else 
                    { 
                        SendVkWall($"{text}"); Log("tpbotbonusapi", $"Отправлен новый пост на стену: ({text})"); 
                    } 
                } 
                
                private void VKAPIMsg(string text, string attachments, string reciverID, bool atimg) 
                { 
                    if (atimg) 
                    { 
                        SendVkMessage(reciverID, $"{text}&attachment={attachments}"); 
                        Log("tpbotbonusapi", $"Отправлено новое сообщение пользователю {reciverID}: ({text}&attachments={attachments})"); 
                    } 
                    else 
                    { 
                        SendVkMessage(reciverID, $"{text}"); Log("tpbotbonusapi", $"Отправлено новое сообщение пользователю {reciverID}: ({text})"); 
                    } 
                } 
                
                private void VKAPIStatus(string msg) 
                { 
                    StatusCheck(msg); 
                    SendVkStatus(msg); 
                    Log("tpbotbonusapi", $"Отправлен новый статус: {msg}"); 
                } 
                
                void Log(string filename, string text) => LogToFile(filename, $"[{DateTime.Now}] {text}", this); 
                
                void GetCallback(int code, string response, string type, BasePlayer player = null) 
                { 
                    if (!response.Contains("error")) 
                    { 
                        Puts($"{type} отправлен(о): {response}"); 
                        if (type == "Код подтверждения" && player != null) 
                            StartCodeSendedGUI(player); 
                        PrintToChat(player, string.Format(GetMsg("СообщениеОтправлено"))); 
                    } 
                    else 
                    { 
                        if (type == "Код подтверждения") 
                        { 
                            if (response.Contains("Can't send messages for users without permission") && player != null) 
                            { 
                                StartTPBotbonusHelpVKGUI(player); 
                                PrintToChat(player, string.Format(GetMsg("СообщениеНеОтправлено"))); 
                            } 
                            else 
                                Log("errorconfcode", $"Ошибка отправки кода подтверждения. Ответ сервера ВК: {response}"); 
                        } 
                        else 
                        { 
                            PrintWarning($"{type} не отправлен(о). Файлы лога: /oxide/logs/TPBotbonus/"); 
                            Log("Errors", $"{type} не отправлен(о). Ошибка: " + response); 
                        } 
                    } 
                } 
                
                private string EmojiCounters(string counter) 
                { 
                    var chars = counter.ToCharArray(); 
                    List<object> digits = new List<object>() 
                    { 
                        "0", 
                        "1", 
                        "2", 
                        "3", 
                        "4", 
                        "5", 
                        "6", 
                        "7", 
                        "8", 
                        "9" 
                    }; 

                    string emoji = ""; 
                    
                    for (int ctr = 0; ctr < chars.Length; ctr++) 
                    { 
                        if (digits.Contains(chars[ctr].ToString())) 
                        { 
                            string replace = chars[ctr] + "⃣"; 
                            emoji = emoji + replace; 
                        } 
                        else 
                            emoji = emoji + chars[ctr]; 
                    } 

                    return emoji; 
                } 
                
                private string WipeDate() => SaveRestore.SaveCreatedTime.ToLocalTime().ToString("dd.MM"); 
                
                private string URLEncode(string input) 
                { 
                    if (input.Contains("#")) 
                        input = input.Replace("#", "%23"); 
                    if (input.Contains("$")) 
                        input = input.Replace("$", "%24"); 
                    if (input.Contains("+")) 
                        input = input.Replace("+", "%2B"); 
                    if (input.Contains("/")) 
                        input = input.Replace("/", "%2F"); 
                    if (input.Contains(":")) 
                        input = input.Replace(":", "%3A"); 
                    if (input.Contains(";")) 
                        input = input.Replace(";", "%3B"); 
                    if (input.Contains("?")) 
                        input = input.Replace("?", "%3F"); 
                    if (input.Contains("@")) 
                        input = input.Replace("@", "%40"); 
                    return input; 
                } 
                
                private void StatusCheck(string msg) 
                { 
                    if (msg.Length > 140) 
                        PrintWarning($"Текст статуса слишком длинный. Измените формат статуса чтобы текст отобразился полностью. Лимит символов в статусе - 140. Длина текста - {msg.Length.ToString()}"); 
                } 
                
                private bool IsNPC(BasePlayer player) 
                { 
                    if (player is NPCPlayer) return true; 
                    if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true; 
                    return false; 
                } 
                
                private static string GetColor(string hex) 
                { 
                    if (string.IsNullOrEmpty(hex)) 
                        hex = "#FFFFFFFF"; var str = hex.Trim('#'); 
                    if (str.Length == 6) 
                        str += "FF"; 
                    if (str.Length != 8) 
                    { 
                        throw new Exception(hex); 
                        throw new InvalidOperationException("Cannot convert a wrong format."); 
                    } 
                    var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber); 
                    var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber); 
                    var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber); 
                    var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber); 
                    Color color = new Color32(r, g, b, a); 
                    return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}"; 
                } 
                
                private void DeleteOldUsers(string days = null) 
                { 
                    int ddays = 30; 
                    int t; 
                    if (days != null && Int32.TryParse(days, out t)) 
                        ddays = t; 
                    int deleted = 0; 
                    List<ulong> ForDelete = new List<ulong>(); 
                        
                    foreach (var user in usersdata.VKUsersData) 
                    { 
                        if (user.Value.LastSeen == null) 
                            ForDelete.Add(user.Key); 
                        else 
                        { 
                            DateTime LNT; 
                            if (DateTime.TryParseExact(user.Value.LastSeen, "dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture, DateTimeStyles.None, out LNT) && DateTime.Now.Subtract(LNT).Days >= ddays)        ForDelete.Add(user.Key); 
                        } 
                    } 
                    foreach (var d in ForDelete) 
                    { 
                        usersdata.VKUsersData.Remove(d); deleted++;
                    }
                    if (deleted > 0) 
                    { 
                        PrintWarning($"Удалено устаревших профилей игроков из базы TPBotbonus: {deleted}"); 
                        VKBData.WriteObject(usersdata); 
                    } 
                    else 
                        PrintWarning($"Нет профилей для удаления."); 
                } 
                    
                private void CheckOxideUpdate() 
                { 
                    string currentver = Manager.GetPlugin("RustCore").Version.ToString(); 
                    webrequest.Enqueue("https://umod.org/games/rust.json", null, (code, response) => 
                    { 
                        if (code == 200 || response != null) 
                        { 
                            var json = JObject.Parse(response); 
                            if (json == null) return; 
                            string latestver = (string)json["latest_release_version"]; 
                            if (latestver == null) return; 
                            if (latestver != currentver && !OxideUpdateSended) 
                            { 
                                OxideUpdateSended = true; 
                            } 
                        } 
                    }, this); 
                    timer.Once(3600f, () => { 
                        CheckOxideUpdate(); 
                    }); 
                } 
                
                private string BannedUsers = ServerUsers.BanListString(); 
                
                private CuiElement BPanel(string name, string color, string anMin, string anMax, string parent = "Hud", bool cursor = false, float fade = 1f) 
                { 
                    var Element = new CuiElement() 
                    { 
                        Name = name, 
                        Parent = parent, 
                        Components = { 
                            new CuiImageComponent { Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = fade, Color = color }, 
                            new CuiRectTransformComponent { AnchorMin = anMin, AnchorMax = anMax }
                        }
                    }; 
                
                    if (cursor) 
                        Element.Components.Add(new CuiNeedsCursorComponent()); 
                    
                    return Element; 
                } 
                    
                private CuiElement Panel(string name, string color, string anMin, string anMax, string parent = "Hud", bool cursor = false, float fade = 1f) 
                { 
                    var Element = new CuiElement() 
                    { 
                        Name = name, 
                        Parent = parent, 
                        Components = { 
                            new CuiImageComponent { FadeIn = fade, Color = color }, 
                            new CuiRectTransformComponent { AnchorMin = anMin, AnchorMax = anMax } 
                        } 
                    }; 
                    
                    if (cursor) 
                        Element.Components.Add(new CuiNeedsCursorComponent()); 
                    
                    return Element; 
                } 
                
                private CuiElement Text(string parent, string color, string text, TextAnchor pos, int fsize, string anMin = "0 0", string anMax = "1 1", string fname = "robotocondensed-bold.ttf", float fade = 3f) 
                { 
                    var Element = new CuiElement() 
                    { 
                        Parent = parent, 
                        Components = { 
                            new CuiTextComponent() { Color = color, Text = text, Align = pos, Font = fname, FontSize = fsize, FadeIn = fade }, 
                            new CuiRectTransformComponent{ AnchorMin = anMin, AnchorMax = anMax } 
                        } 
                    }; 
                    
                    return Element; 
                } 
                
                private CuiElement Button(string name, string parent, string command, string color, string anMin, string anMax, float fade = 3f) 
                { 
                    var Element = new CuiElement() 
                    { 
                        Name = name, 
                        Parent = parent, 
                        Components = { 
                            new CuiButtonComponent { Command = command, Color = color, FadeIn = fade}, 
                            new CuiRectTransformComponent{ AnchorMin = anMin, AnchorMax = anMax } 
                        } 
                    }; 
                    
                    return Element; 
                } 
                
                private CuiElement Image(string parent, string url, string anMin, string anMax, float fade = 3f, string color = "1 1 1 1") 
                { 
                    var Element = new CuiElement 
                    { 
                        Parent = parent, 
                        Components = { 
                            new CuiRawImageComponent { Color = color, Url = url, FadeIn = fade}, 
                            new CuiRectTransformComponent{ AnchorMin = anMin, AnchorMax = anMax } 
                        } 
                    }; 
                    
                    return Element; 
                } 
                
                private CuiElement Input(string name, string parent, int fsize, string command, string anMin = "0 0", string anMax = "1 1", TextAnchor pos = TextAnchor.MiddleCenter, int chlimit = 300, bool psvd = false, float fade = 3f) 
                { 
                    string text = ""; 
                    var Element = new CuiElement 
                    { 
                        Name = name, 
                        Parent = parent, 
                        Components = { 
                            new CuiInputFieldComponent { Align = pos, CharsLimit = chlimit, FontSize = fsize, Command = command + text, IsPassword = psvd, Text = text }, 
                            new CuiRectTransformComponent{ AnchorMin = anMin, AnchorMax = anMax } 
                        } 
                    }; 
                    
                    return Element; 
                } 
                
                private void UnloadAllGUI() 
                { 
                    foreach (var player in BasePlayer.activePlayerList) 
                    { 
                        CuiHelper.DestroyUi(player, VkWait); 
                        CuiHelper.DestroyUi(player, VkHelp); 
                        CuiHelper.DestroyUi(player, VkConnect); 
                        CuiHelper.DestroyUi(player, MainLayer); 
                        CuiHelper.DestroyUi(player, VkReward); 
                        CuiHelper.DestroyUi(player, VkAlert); 
                    } 
                } 
                
                private string UserName(string name) 
                { 
                    if (name.Length > 15) 
                        name = name.Remove(12) + "..."; 
                    
                    return name; 
                } 
                
                private void StartTPBotbonusAddVKGUI(BasePlayer player) 
                { 
                    CuiHelper.DestroyUi(player, VkConnect);
                    var container = new CuiElementContainer(); 
                    
                    container.Add(new CuiPanel() 
                    { 
                        CursorEnabled = true, 
                        RectTransform = {AnchorMin = "0.35 0.38", AnchorMax = "0.65 0.62", OffsetMin = "0 0", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" }
                    }, MainLayer, VkConnect); 

                    container.Add(new CuiElement
                    {
                        Parent = VkConnect,
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "alertvkback") },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.93 0.81", AnchorMax = "1 1" },
                        Button = { Close = VkConnect, Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, VkConnect);

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.93 1" }, 
                        Text = { Text = "     Привязка страницы вк", FontSize = 12, Color = "1 1 1 0.6", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft } 
                    }, VkConnect); 

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0.1 0.57", AnchorMax = "0.9 0.9", OffsetMin = "0 0", OffsetMax = "1 1" }, 
                        Text = { Text = "Укажите ссылку на страницу ВК\nв поле ниже и нажмите ENTER", Color = "1 1 1 0.6", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkConnect); 
                    
                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0 0.53", AnchorMax = "1 0.63", OffsetMin = "0 0", OffsetMax = "1 1" }, 
                        Text = { Text = "пример vk.com/nickname", Color = "1 1 1 0.3", FontSize = 10, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkConnect); 

                    container.Add(new CuiElement 
                    { 
                        Parent = VkConnect, 
                        Name = "Input", 
                        Components = { 
                            new CuiImageComponent { Color = "0 0 0 0" }, 
                            new CuiRectTransformComponent{ AnchorMin = "0.21 0.35", AnchorMax = "0.79 0.48", OffsetMin = "0 0", OffsetMax = "1 1" }, 
                            new CuiOutlineComponent { Color = "1 1 1 0.4", UseGraphicAlpha = true } 
                        } 
                    }); 
                    
                    container.Add(new CuiElement 
                    { 
                        Parent = "Input", 
                        Components = { 
                            new CuiInputFieldComponent { Text = "", FontSize = 12, Command = "vk.menugui46570981 addvkgui.addvk", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.4", CharsLimit = 34}, 
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "1 1" }, 
                            new CuiOutlineComponent { Color = "0.4 0.4 0.4 0.8", Distance = "0.4 -0.4", UseGraphicAlpha = true } 
                        } 
                    }); 

                    CuiHelper.AddUi(player, container); 
                } 
                
                public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin); 
                public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin); 
                public bool HasImage(string imageName) => (bool)ImageLibrary?.Call("HasImage", imageName); 
                public void SendImage(BasePlayer player, string imageName, ulong imageId = 0) => ImageLibrary?.Call("SendImage", player, imageName, imageId); 
                void OnPlayerConnected(BasePlayer player) 
                { 
                    SteamAvatarAdd(player.UserIDString); 
                } 
                void SteamAvatarAdd(string userid) 
                { 
                    if (ImageLibrary == null) return; 
                    if (HasImage(userid)) return; 
                    string url = "http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key=AE4C104E68AB334B06F065DCD2B03014&" + "steamids=" + userid; 
                    webrequest.Enqueue(url, null, (code, response) => { 
                        if (code == 200) 
                        { 
                            string Avatar = (string)JObject.Parse(response)["response"]?["players"]?[0]?["avatarfull"]; 
                            AddImage(Avatar, userid); 
                        } 
                    }, this); 
                } 

                public string VkICO = "https://i.imgur.com/etwraYj.png"; 
                public string GiftICO = "https://i.imgur.com/GS6VKn4.png"; 
                public string AlertICO = "https://i.imgur.com/Cyh2d7y.png"; 
                public string VkConnect = "VkConnect_UI"; 
                public string VkHelp = "VkHelp_UI"; 
                public string VkWait = "VkWait_UI"; 
                public string MainLayer = "lay" + ".Main"; 
                public string VkReward = "VkReward_UI"; 
                public string VkAlert = "VkAlert_UI"; 
                public string AlertPermission = "TPBotbonus.Alert"; 
                
                [ChatCommand("vk")]
                void StartTPBotbonusMainGUI(BasePlayer player, ulong target = 0) 
                { 
                    string addvkbuttoncommand = "vk.menugui46570981 maingui.addvk"; 
                    string addvkbuttongift = "vk.menugui46570981 giftopen"; 
                    string addvkbuttonalert = "vk.menugui46570981 alert"; 
                    string addvkbuutontext = "ОТКРЫТЬ"; 
                    string addvkbuutontextgift = "ОТКРЫТЬ"; 
                    string addvkbuutontextalert = "ОТКРЫТЬ"; 
                    string giftvkbuutontext = "Получить награду за\nвступление в группу ВК"; 
                    string giftvkbuttoncommand = "vk.menugui46570981 maingui.gift"; 
                    string addvkbuttonanmax = "0.99 0.5"; 
                    string imagevk = "";
                    string imagegift = "";
                    string imagealert = "";
                    ulong Person = player.userID;
                    string ImageAvatar = GetImage(Person.ToString()); 
                    var container = new CuiElementContainer(); 
                    
                    if (usersdata.VKUsersData.ContainsKey(player.userID)) 
                    { 
                        if (!usersdata.VKUsersData[player.userID].Confirmed) 
                        { 
                            addvkbuttoncommand = "vk.menugui46570981 maingui.confirm"; 
                        } 
                        else 
                        { 
                            addvkbuutontext = "ДОБАВЛЕНО"; 
                            addvkbuttoncommand = ""; 
                            imagevk = "ButtonBlock";
                            addvkbuttongift = "vk.menugui46570981 giftcomplete"; 
                        } 
                    } 
                    if (usersdata.VKUsersData.ContainsKey(player.userID)) 
                    { 
                        if (usersdata.VKUsersData[player.userID].GiftRecived) 
                        { 
                            addvkbuttongift = ""; 
                            addvkbuutontextgift = "ДОБАВЛЕНО"; 
                            imagegift = "ButtonBlock";
                        } 
                    } 
                    if (usersdata.VKUsersData.ContainsKey(player.userID)) 
                    { 
                        if (permission.UserHasPermission(player.UserIDString, AlertPermission) && usersdata.VKUsersData[player.userID].Confirmed) 
                        { 
                            addvkbuttonalert = ""; 
                            addvkbuutontextalert = "ДОБАВЛЕНО"; 
                            imagealert = "ButtonBlock";
                        } 
                    } 
                    
                                if (usersdata.VKUsersData.ContainsKey(player.userID)) 
                    { 
                        if (permission.UserHasPermission(player.UserIDString, AlertPermission) && usersdata.VKUsersData[player.userID].Confirmed) 
                        { 
                            addvkbuttonalert = ""; 
                            addvkbuutontextalert = "ДОБАВЛЕНО"; 
                            imagealert = "ButtonBlock";
                        } 
                    } 
                    
                    container.Add(new CuiElement
                    {
                        Name = MainLayer,
                        Parent = ".Mains",
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "BackgroundImage") },
                            new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                        Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, MainLayer);





                    container.Add(new CuiPanel() 
                    { 
                        RectTransform = {AnchorMin = "0.34 0.517", AnchorMax = "0.418 0.656", OffsetMin = "0 0", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" } 
                    }, MainLayer, "AVATAR"); 

                    container.Add(new CuiElement 
                    { 
                        Parent = "AVATAR", 
                        Components = { 
                            new CuiRawImageComponent { Png = ImageAvatar,Color = "1 1 1 1" }, 
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0"}, 
                        } 
                    });

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0.33 0.48", AnchorMax = "0.428 0.515", OffsetMax = "0 0"}, 
                        Text = { Text = player.displayName, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.6"} 
                    }, MainLayer); 

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = {AnchorMin = "0.45 0.6", AnchorMax = "0.73 0.675", OffsetMax = "0 0"}, 
                        Text = { Text = "   Ссылка на нашу группу вк\n         https://vk.com/rustage_su", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 14, Color = "1 1 1 0.6"} 
                    }, MainLayer); 

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = {AnchorMin = "0.448 0.555", AnchorMax = "0.67 0.59", OffsetMax = "0 0"}, 
                        Text = { Text = "            Для привязки используйте ваш вк", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.6"} 
                    }, MainLayer); 

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = {AnchorMin = "0.448 0.51", AnchorMax = "0.67 0.545", OffsetMax = "0 0"}, 
                        Text = { Text = "            Вступите в группу вк и получайте награды", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.6"} 
                    }, MainLayer); 

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = {AnchorMin = "0.448 0.465", AnchorMax = "0.67 0.5", OffsetMax = "0 0"}, 
                        Text = { Text = "            Подключить оповещение о рейде", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.6"} 
                    }, MainLayer); 

                    container.Add(new CuiPanel() 
                    { 
                        RectTransform = {AnchorMin = "0.675 0.553", AnchorMax = "0.73 0.59", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" } 
                    }, MainLayer, "Vk"); 

                    if (imagevk != "")
                    {
                        container.Add(new CuiElement
                        {
                            Parent = "Vk",
                            Components = 
                            {
                                new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", imagevk) },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            }
                        });
                    }

                    container.Add(new CuiButton 
                    { 
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }, 
                        Button = { Command = addvkbuttoncommand, Color = "0 0 0 0" }, 
                        Text = { Text = addvkbuutontext, FontSize = 11, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" } 
                    }, "Vk"); 

                    container.Add(new CuiPanel() 
                    { 
                        RectTransform = {AnchorMin = "0.675 0.51", AnchorMax = "0.73 0.547", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" } 
                    }, MainLayer, "gift"); 

                    if (imagegift != "")
                    {
                        container.Add(new CuiElement
                        {
                            Parent = "gift",
                            Components = 
                            {
                                new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", imagegift) },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            }
                        });
                    }

                    container.Add(new CuiButton 
                    { 
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }, 
                        Button = { Color = "0 0 0 0", Command = addvkbuttongift }, 
                        Text = { Text = addvkbuutontextgift, FontSize = 11, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" } 
                    }, "gift"); 

                    container.Add(new CuiPanel() 
                    { 
                        RectTransform = {AnchorMin = "0.675 0.465", AnchorMax = "0.73 0.503", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" } 
                    }, MainLayer, "alert"); 

                    if (imagealert != "")
                    {
                        container.Add(new CuiElement
                        {
                            Parent = "alert",
                            Components = 
                            {
                                new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", imagealert) },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            }
                        });
                    }

                    container.Add(new CuiButton 
                    { 
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }, 
                        Button = { Color = "0 0 0 0", Command = addvkbuttonalert }, 
                        Text = { Text = addvkbuutontextalert, FontSize = 11, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" } 
                    }, "alert"); 

                    string helpText = "Если у вас возникают проблемы с меню, вы можете использовать чатовые команды:\n<b>/regvk add</b> - привязка вашего профиля ВК\n<b>/regvk confirm</b> - подтверждение вашего профиля ВК\n<b>/regvk gift</b> - получение подарка за подписку ВК"; 
                    
                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0.45 0.35", AnchorMax = "0.73 0.46", OffsetMax = "0 0" }, 
                        Text = { Text = helpText, Align = TextAnchor.UpperLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "0.67 0.63 0.596"} 
                    }, MainLayer); 

                    CuiHelper.DestroyUi(player, MainLayer); 
                    CuiHelper.AddUi(player, container); 
                } 
                
                private void StartTPBotbonusHelpVKGUI(BasePlayer player) 
                {
                    CuiHelper.DestroyUi(player, VkConnect);
                    CuiHelper.DestroyUi(player, VkHelp); 
                    CuiElementContainer container = new CuiElementContainer(); 
                    container.Add(new CuiPanel() 
                    { 
                        CursorEnabled = true, 
                        RectTransform = {AnchorMin = "0.35 0.38", AnchorMax = "0.65 0.62", OffsetMin = "0 0", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" } 
                    }, MainLayer, VkHelp); 
                    
                    container.Add(new CuiElement
                    {
                        Parent = VkHelp,
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "alerts1") },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.93 0.81", AnchorMax = "1 1" },
                        Button = { Close = VkHelp, Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, VkHelp);

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.93 1" }, 
                        Text = { Text = "     Привязка страницы вк", FontSize = 12, Color = "1 1 1 0.6", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft } 
                    }, VkHelp); 

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.9 0.9" }, 
                        Text = { Text = "Бот не может отправить вам сообщение :(\nОтправьте в сообщения группы любое слово и попробуйте снова", Color = "1 1 1 0.6", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkHelp); 
                    
                    CuiHelper.AddUi(player, container); 
                } 
                
                private void StartCodeSendedGUI(BasePlayer player) 
                { 
                    if (player == null || player.Connection == null) return; 
                    CuiHelper.DestroyUi(player, VkConnect); 
                    CuiHelper.DestroyUi(player, VkReward); 
                    CuiHelper.DestroyUi(player, VkHelp); 
                    CuiElementContainer container = new CuiElementContainer(); 

                    container.Add(new CuiPanel() 
                    { 
                        CursorEnabled = true, 
                        RectTransform = {AnchorMin = "0.35 0.38", AnchorMax = "0.65 0.62", OffsetMin = "0 0", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" }
                    }, MainLayer, VkWait); 

                    container.Add(new CuiElement
                    {
                        Parent = VkWait,
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "alerts") },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.93 0.81", AnchorMax = "1 1" },
                        Button = { Command = "vk.refresh help", Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, VkWait);

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.93 1" }, 
                        Text = { Text = "     Привязка страницы вк", FontSize = 12, Color = "1 1 1 0.6", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft } 
                    }, VkWait); 

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0.1 0.48", AnchorMax = "0.9 0.9" }, 
                        Text = { Text = "На вашу страницу ВК отправлено сообщение с дальнейшими инструкциями", Color = "1 1 1 0.6", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkWait); 

                    container.Add(new CuiButton 
                    { 
                        RectTransform = { AnchorMin = "0.315 0.35", AnchorMax = "0.68 0.49", }, 
                        Button = { Command = "vk.menugui46570981 maingui.removevk8974321765", Color = "0 0 0 0" }, 
                        Text = { Text = "     Удалить профиль", FontSize = 11, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkWait); 

                    CuiHelper.AddUi(player, container); 
                } 
                
                private void RewardTPBotbonusGUI(BasePlayer player) 
                { 
                    var container = new CuiElementContainer(); 

                    container.Add(new CuiPanel() 
                    { 
                        CursorEnabled = true, 
                        RectTransform = {AnchorMin = "0.35 0.38", AnchorMax = "0.65 0.62", OffsetMin = "0 0", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" }
                    }, MainLayer, VkReward); 

                    container.Add(new CuiElement
                    {
                        Parent = VkReward,
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "alerts") },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.93 0.81", AnchorMax = "1 1" },
                        Button = { Command = "vk.refresh gift", Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, VkReward);

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.93 1" }, 
                        Text = { Text = "     Получение подарка", FontSize = 12, Color = "1 1 1 0.6", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft } 
                    }, VkReward); 
                    
                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.9 0.9" }, 
                        Text = { Text = "\nДля подключения оповещения о рейде зайдите в магазин и купите бесплатно", Color = "1 1 1 0.6", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkReward); 

                    CuiHelper.AddUi(player, container); 
                } 
                
                private void CompleteRewardTPBotbonusGUI(BasePlayer player) 
                { 
                    var container = new CuiElementContainer(); 

                    container.Add(new CuiPanel() 
                    { 
                        CursorEnabled = true, 
                        RectTransform = {AnchorMin = "0.35 0.38", AnchorMax = "0.65 0.62", OffsetMin = "0 0", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" }
                    }, MainLayer, VkReward); 

                    container.Add(new CuiElement
                    {
                        Parent = VkReward,
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "giftrewardback") },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.93 0.81", AnchorMax = "1 1" },
                        Button = { Command = "vk.refresh gift", Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, VkReward);

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.93 1" }, 
                        Text = { Text = "     Получение подарка", FontSize = 12, Color = "1 1 1 0.6", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft } 
                    }, VkReward); 
                    
                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0.1 0.5", AnchorMax = "0.9 0.9" }, 
                        Text = { Text = "Для получения подарка, нажмите кнопку получить. Убедитесь что подписались на нашу группу", Color = "1 1 1 0.6", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkReward); 

                    container.Add(new CuiButton 
                    { 
                        RectTransform = { AnchorMin = "0.315 0.35", AnchorMax = "0.68 0.49", }, 
                        Button = { Command = "vk.menugui46570981 maingui.gift", Color = "0 0 0 0" }, 
                        Text = { Text = "     Получить", FontSize = 11, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkReward); 
 
                    CuiHelper.AddUi(player, container); 
                } 
                
                private void AlertTPBotbonusGUI(BasePlayer player) 
                { 
                    var container = new CuiElementContainer(); 
                    
                    container.Add(new CuiPanel() 
                    { 
                        CursorEnabled = true, 
                        RectTransform = {AnchorMin = "0.35 0.38", AnchorMax = "0.65 0.62", OffsetMin = "0 0", OffsetMax = "0 0"}, 
                        Image = {Color = "0 0 0 0" }
                    }, MainLayer, VkAlert); 

                    container.Add(new CuiElement
                    {
                        Parent = VkAlert,
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "alerts") },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.93 0.81", AnchorMax = "1 1" },
                        Button = { Command = "vk.refresh alert", Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, VkAlert);

                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0 0.86", AnchorMax = "0.93 1" }, 
                        Text = { Text = "     Уведомление о рейде", FontSize = 12, Color = "1 1 1 0.6", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft } 
                    }, VkAlert); 
                    
                    container.Add(new CuiLabel 
                    { 
                        RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.9 0.9" }, 
                        Text = { Text = "\nДля подключения оповещения о рейде зайдите в магазин и купите бесплатно", Color = "1 1 1 0.6", FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter } 
                    }, VkAlert); 
                        
                    CuiHelper.AddUi(player, container); 
                } 
                    
                    [ConsoleCommand("vk.menugui46570981")] 
                    private void CmdChoose(ConsoleSystem.Arg arg) 
                    { 
                        BasePlayer player = arg.Player(); 
                        if (player == null) return; 
                        if (arg.Args == null) return; 
                        
                        switch (arg.Args[0]) 
                        { 
                            case "maingui.close": 
                                CuiHelper.DestroyUi(player, "MainUI"); 
                                break; 
                            case "maingui.addvk": 
                                CuiHelper.DestroyUi(player, "MainUI"); 
                                StartTPBotbonusAddVKGUI(player); 
                                break; 
                            case "maingui.removevk8974321765": 
                                CuiHelper.DestroyUi(player, VkWait); 
                                CuiHelper.DestroyUi(player, VkHelp); 
                                CuiHelper.DestroyUi(player, VkConnect); 
                                CuiHelper.DestroyUi(player, MainLayer); 
                                if (usersdata.VKUsersData.ContainsKey(player.userID)) 
                                { 
                                    usersdata.VKUsersData.Remove(player.userID); VKBData.WriteObject(usersdata); 
                                } 
                                StartTPBotbonusMainGUI(player); 
                                break; 
                            case "maingui.walert": 
                                WAlert(player); 
                                break; 
                            case "maingui.gift": 
                                CuiHelper.DestroyUi(player, VkWait); 
                                CuiHelper.DestroyUi(player, VkHelp); 
                                CuiHelper.DestroyUi(player, VkConnect); 
                                CuiHelper.DestroyUi(player, MainLayer); 
                                CuiHelper.DestroyUi(player, VkReward); 
                                CuiHelper.DestroyUi(player, "Menu_UI"); 
                                FixedGifts(player); 
                                break; 
                            case "maingui.confirm": 
                                CuiHelper.DestroyUi(player, "MainUI"); 
                                SendConfCode(usersdata.VKUsersData[player.userID].VkID, $"Для подтверждения вашего ВК профиля введите в игровой чат команду /regvk confirm {usersdata.VKUsersData[player.userID].ConfirmCode}", player); 
                                break; 
                            case "maingui.wait": 
                                CuiHelper.DestroyUi(player, "MainUI"); 
                                StartCodeSendedGUI(player); 
                                break;
                            case "addvkgui.close": 
                                CuiHelper.DestroyUi(player, "AddVKUI"); 
                                break; 
                            case "addvkgui.addvk": 
                                string url = string.Join(" ", arg.Args.Skip(1).ToArray()); 
                                if (!url.Contains("vk.com/")) 
                                { 
                                    PrintToChat(player, string.Format(GetMsg("НеправильнаяСсылка"))); 
                                    return; 
                                } 
                                CuiHelper.DestroyUi(player, "AddVKUI"); 
                                CheckVkUser(player, url); 
                                break; 
                            case "helpgui.close": 
                                CuiHelper.DestroyUi(player, "HelpUI"); 
                                break; 
                            case "helpgui.confirm": 
                                CuiHelper.DestroyUi(player, VkHelp); 
                                SendConfCode(usersdata.VKUsersData[player.userID].VkID, $"Для подтверждения вашего ВК профиля введите в игровой чат команду /regvk confirm {usersdata.VKUsersData[player.userID].ConfirmCode}", player); 
                                break; 
                            case "csendui.close": 
                                CuiHelper.DestroyUi(player, "CodeSendedUI"); 
                                break; 
                            case "giftopen": 
                                RewardTPBotbonusGUI(player); 
                                break; 
                            case "giftcomplete": 
                                CompleteRewardTPBotbonusGUI(player); 
                                break; 
                            case "alert": 
                                AlertTPBotbonusGUI(player); 
                                break; 
                        } 
                    } 
                    
                    [ConsoleCommand("vk.refresh")] 
                    private void CmdRefresh(ConsoleSystem.Arg arg) 
                    { 
                        BasePlayer player = arg.Player(); 
                        if (player == null) return; 
                        if (arg.Args == null) return; 
                        
                        switch (arg.Args[0]) 
                        { 
                            case "connect": 
                                CuiHelper.DestroyUi(player, VkWait); 
                                CuiHelper.DestroyUi(player, VkHelp); 
                                CuiHelper.DestroyUi(player, VkReward); 
                                CuiHelper.DestroyUi(player, VkAlert); 
                                StartTPBotbonusMainGUI(player); 
                                break; 
                            case "help": 
                                CuiHelper.DestroyUi(player, VkWait); 
                                CuiHelper.DestroyUi(player, VkHelp); 
                                CuiHelper.DestroyUi(player, VkConnect); 
                                CuiHelper.DestroyUi(player, MainLayer); 
                                CuiHelper.DestroyUi(player, VkReward); 
                                CuiHelper.DestroyUi(player, VkAlert); 
                                StartTPBotbonusMainGUI(player); 
                                break; 
                            case "gift": 
                                CuiHelper.DestroyUi(player, VkWait); 
                                CuiHelper.DestroyUi(player, VkHelp); 
                                CuiHelper.DestroyUi(player, VkConnect); 
                                CuiHelper.DestroyUi(player, MainLayer); 
                                CuiHelper.DestroyUi(player, VkReward); 
                                CuiHelper.DestroyUi(player, VkAlert); 
                                StartTPBotbonusMainGUI(player); 
                                break; 
                            case "alert": 
                                CuiHelper.DestroyUi(player, VkWait); 
                                CuiHelper.DestroyUi(player, VkHelp); 
                                CuiHelper.DestroyUi(player, VkConnect); 
                                CuiHelper.DestroyUi(player, MainLayer); 
                                CuiHelper.DestroyUi(player, VkReward); 
                                CuiHelper.DestroyUi(player, VkAlert); 
                                StartTPBotbonusMainGUI(player); 
                                break; 
                        } 
                    } 
                    
                    private void FixedGifts(BasePlayer player) 
                    { 
                        if (GiftsList.ContainsKey(player)) 
                        { 
                            TimeSpan interval = DateTime.Now - GiftsList[player]; 
                            if (interval.TotalSeconds < 15) 
                            { 
                                PrintToChat(player, "Вы отправляете запрос слишком часто, попробуйте немного позже"); 
                                return; 
                            } 
                            else 
                            { 
                                GiftsList[player] = DateTime.Now; VKGift(player); 
                            } 
                        } 
                        else 
                        { 
                            GiftsList.Add(player, DateTime.Now); VKGift(player); 
                        } 
                    }
               
        private void LoadMessages() 
        { 
            lang.RegisterMessages(new Dictionary<string, string> 
            { 
                {"ПоздравлениеИгрока", "Администрация сервера поздравляет вас с Днем Рождения!"}, 
                {"ДеньРожденияИгрока", "Администрация сервера поздравляет игрока <color=#81BEF7>{0}</color> с Днем Рождения!"}, 
                {"РепортОтправлен", "Ваше сообщение было отправлено администратору"}, 
                {"КомандаРепорт", "Используйте:\n<color=#81BEF7>/report</color> сообщение"}, 
                {"ФункцияОтключена", "Данная функция отключена администратором"}, 
                {"ПрофильДобавленИПодтвержден", "Вы уже добавили и подтвердили свой профиль"}, 
                {"ПрофильДобавлен", "Вы уже добавили свой профиль. Если вам не пришел код подтверждения, введите команду <color=#81BEF7>/regvk confirm</color>"}, 
                {"ДоступныеКоманды", "<color=#F5DA81>ДОСТУПНЫЕ КОМАНДЫ:</color>\n/vk - открыть меню функций\n/regvk add - привязка вашего профиля ВК\n/regvk confirm - подтверждение вашего профиля ВК\n/regvk gift - получение подарка за подписку ВК"}, 
                {"НеправильнаяСсылка", "Ссылка на страницу должна быть вида \"vk.com/nickname\""}, 
                {"Подсказка", "Используйте:\n<color=#cfc580>/regvk add</color> ваша_ссылка\nСсылка на страницу должна быть вида \"vk.com/nickname\""}, 
                {"ПрофильПодтвержден", "Вы подтвердили свой профиль!"}, 
                {"ОповещениеОПодарках", "Вы можете получить награду, если вступили в нашу группу <color=#81BEF7>{0}</color>"}, 
                {"НеверныйКод", "Неверный код подтверждения"}, 
                {"ПрофильНеДобавлен", "Сначала добавьте и подтвердите свой профиль"}, 
                {"КодОтправлен", "Вам был отправлен код подтверждения. Если сообщение не пришло, зайдите в группу <color=#81BEF7>{0}</color> и напишите любое сообщение"}, {"ПрофильНеПодтвержден", "Сначала подтвердите свой профиль ВК"}, 
                {"НаградаУжеПолучена", "Вы уже получили свою награду!"}, 
                {"ПодпискаОтключена", "Вы <color=#ffd700>отключили</color> подписку на сообщения о вайпах сервера"}, 
                {"ПодпискаВключена", "Вы <color=#ffd700>включили</color> подписку на сообщения о вайпах сервера"}, 
                {"НаградаПолучена", "Вы получили свою награду!"}, 
                {"ПолучилНаграду", "Игрок <color=#81BEF7>{0}</color> получил награду за вступление в группу сервера!\n<size=12>Подробнее: <color=#ffd700>/menu</color></size>"}, {"НетМеста", "Недостаточно места для получения награды"}, 
                {"НаградаПолученаКоманда", "За вступление в группу нашего сервера вы получили {0}"}, 
                {"НеВступилВГруппу", "Вы не являетесь участником нашей группы!"},
                {"ОтветНаРепортЧат", "<color=#81BEF7>Администратор</color> ответил на ваше сообщение:\n"},
                {"ОтветНаРепортВК", "Администратор ответил на ваше сообщение:\n"},
                {"ИгрокНеНайден", "Игрок не найден"}, 
                {"СообщениеИгрокуТопПромо", "Поздравляем! Вы Топ {0} по результатам этого вайпа, в качестве награды, вы получаете промокод {1} на баланс в нашем магазине. {2}"}, 
                {"АвтоОповещенияОвайпе", "Сервер рассылает оповещения о вайпе всем, подписка не требуется"},
                {"СообщениеОтправлено", "На вашу страницу ВК отправлено сообщение с дальнейшими инструкциями"}, 
                {"СообщениеНеОтправлено", "Бот не может отправить вам сообщение :(\nОтправьте в сообщения группы любое слово и попробуйте снова"} 
            }, this); 
        } 
        string GetMsg(string key) => lang.GetMessage(key, this); 
    } 
}

// --- End of file: TPBotbonus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlueprintManager.cs ---
// --- Original Local Path: BlueprintManager.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;

using Oxide.Core;

using Rust;

using RustNative;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BlueprintManager", "Nogrod", "1.2.0", ResourceId = 833)]
    class BlueprintManager : RustPlugin
    {
        private Dictionary<string, string> _itemShortname;
        private int _authLevel = 2;
        private int _authLevelOther = 2;
        private bool _giveOnConnect;
        private bool _configChanged;
        private List<ItemDefinition> _giveBps;
        private Dictionary<ulong, HashSet<string>> playerLearned;

        void OnServerInitialized()
        {
            _itemShortname = ItemManager.itemList.ToDictionary(definition => definition.displayName.english.ToLower(), definition => definition.shortname);
            _authLevel = GetConfig("authLevel", 2);
            _authLevelOther = GetConfig("authLevelOther", 2);
            _giveOnConnect = GetConfig("giveOnConnect", false);
            var bps = GetConfig("bps", new List<object>()).ConvertAll(Convert.ToString);
            var tmp = new HashSet<ItemDefinition>();
            foreach (var bp in bps)
            {
                var name = bp.ToLower();
                if (_itemShortname.ContainsKey(name))
                    name = _itemShortname[name];
                var definition = ItemManager.FindItemDefinition(name);
                if (definition == null)
                {
                    Puts("Item does not exist: {0}", name);
                    continue;
                }
                tmp.Add(definition);
            }
            _giveBps = new List<ItemDefinition>(tmp);

            var file = Interface.Oxide.DataFileSystem.GetFile($"{nameof(BlueprintManager)}_{GetConfig("rememberProtocol", Protocol.network - 1)}");
            if (file.Exists())
                playerLearned = file.ReadObject<Dictionary<ulong, HashSet<string>>>();

            if (!_configChanged) return;
            LoadDefaultConfig();
            SaveConfig();
            _configChanged = false;
        }

        new void LoadDefaultConfig()
        {
            Config.Clear();
            GetConfig("authLevel", 2);
            GetConfig("authLevelOther", 2);
            GetConfig("giveOnConnect", false);
            GetConfig("bps", new List<object>());
            GetConfig("rememberProtocol", Protocol.network - 1);
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (!_giveOnConnect) return;
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerInit(player));
                return;
            }
            Learn(player.userID, _giveBps.Count > 0 ? _giveBps : ItemManager.itemList);
            SendReply(player, "You learned blueprints");
        }

        bool CheckAccess(BasePlayer player, int authLevel, ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.connection == null || player != null && (player.net?.connection?.authLevel >= authLevel || player.IsAdmin()))
                return true;
            Reply(player, arg, "You are not allowed to use this command");
            return false;
        }

        private T GetConfig<T>(string key, T defaultValue)
        {
            if (Config[key] != null) return (T)Convert.ChangeType(Config[key], typeof(T));
            Config[key] = defaultValue;
            _configChanged = true;
            return defaultValue;
        }

        [ConsoleCommand("bp.print")]
        void cmdConsoleBpPrint(ConsoleSystem.Arg arg)
        {
            Puts(string.Join(",", GetAllPersistentPlayerId().ToList().ConvertAll(id => id.ToString()).ToArray()));
        }

        [ConsoleCommand("bp.add")]
        void cmdConsoleBpAdd(ConsoleSystem.Arg arg)
        {
            BpAdd(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpadd")]
        void cmdChatBpAdd(BasePlayer player, string command, string[] args)
        {
            BpAdd(player, args);
        }

        void BpAdd(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevel, arg)) return;
            if (args == null || args.Length == 0)
            {
                Reply(player, arg, "/bpadd \"Item\" [\"PlayerName\"]");
                return;
            }
            Puts("{0} used /bpadd {1}", player?.displayName, string.Join(" ", args));
            var name = args[0].ToLower();
            if (_itemShortname.ContainsKey(name))
                name = _itemShortname[name];
            var definition = ItemManager.FindItemDefinition(name);
            if (definition == null)
            {
                Reply(player, arg, "Item does not exist: {0}", name);
                return;
            }
            var targetPlayer = player;
            if (args.Length > 1)
            {
                if (!CheckAccess(player, _authLevelOther, arg)) return;
                targetPlayer = FindPlayer(args[1]);
            }
            if (targetPlayer == null)
            {
                Reply(player, arg, "Player not found: {0}", args.Length > 1 ? args[1] : "unknown");
                return;
            }
            targetPlayer.blueprints.Learn(definition);
            SendReply(targetPlayer, "You learned {0}", definition.displayName.translated);
            if (targetPlayer != player)
            {
                Reply(player, arg, "{0} learned {1}", targetPlayer.displayName, definition.displayName.translated);
            }
        }

        [ConsoleCommand("bp.all")]
        void cmdConsoleBpAll(ConsoleSystem.Arg arg)
        {
            BpAll(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpall")]
        void cmdChatBpAll(BasePlayer player, string command, string[] args)
        {
            BpAll(player, args);
        }

        void BpAll(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevel, arg)) return;
            Puts("{0} used /bpall {1}", player?.displayName, string.Join(" ", args));
            var targetPlayer = player;
            if (args != null && args.Length > 0)
            {
                if (!CheckAccess(player, _authLevelOther, arg)) return;
                targetPlayer = FindPlayer(args[0]);
            }
            if (targetPlayer == null)
            {
                Reply(player, arg, "Player not found: {0}", args != null && args.Length > 0 ? args[0] : "unknown");
                return;
            }
            Learn(targetPlayer.userID, ItemManager.itemList);
            SendReply(targetPlayer, "You learned all blueprints");
            if (targetPlayer != player)
                Reply(player, arg, "{0} learned all blueprints", targetPlayer.displayName);
        }

        [ConsoleCommand("bp.reset")]
        void cmdConsoleBpReset(ConsoleSystem.Arg arg)
        {
            BpReset(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpreset")]
        void cmdChatBpReset(BasePlayer player, string command, string[] args)
        {
            BpReset(player, args);
        }

        void BpReset(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevel, arg)) return;
            Puts("{0} used /bpreset {1}", player?.displayName, string.Join(" ", args));
            var targetPlayer = player;
            if (args != null && args.Length > 0)
            {
                if (!CheckAccess(player, _authLevelOther, arg)) return;
                targetPlayer = FindPlayer(args[0]);
            }
            if (targetPlayer == null)
            {
                Reply(player, arg, "Player not found: {0}", args != null && args.Length > 0 ? args[0] : "unknown");
                return;
            }
            var data = ServerMgr.Instance.persistance.GetPlayerInfo(targetPlayer.userID);
            data.blueprints = null;
            PlayerBlueprints.InitializePersistance(data);
            ServerMgr.Instance.persistance.SetPlayerInfo(targetPlayer.userID, data);
            targetPlayer.SendFullSnapshot();
            SendReply(targetPlayer, "You forgot all blueprints");
            if (targetPlayer != player)
                Reply(player, arg, "{0} forgot all blueprints", targetPlayer.displayName);
        }

        [ConsoleCommand("bp.addall")]
        void cmdConsoleBpAddAll(ConsoleSystem.Arg arg)
        {
            BpAddAll(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpaddall")]
        void cmdChatBpAddAll(BasePlayer player, string command, string[] args)
        {
            BpAddAll(player, args);
        }

        void BpAddAll(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevelOther, arg)) return;
            Puts("{0} used /bpaddall {1}", player?.displayName, string.Join(" ", args));
            List<ItemDefinition> definitions;
            if (args != null && args.Length > 0)
            {
                definitions = new List<ItemDefinition>();
                foreach (var cur in args)
                {
                    foreach (var def in cur.Split(','))
                    {
                        var name = def.ToLower();
                        if (_itemShortname.ContainsKey(name))
                            name = _itemShortname[name];
                        var itemDef = ItemManager.FindItemDefinition(name);
                        if (itemDef == null)
                        {
                            Reply(player, arg, "Item not found: {0}", def);
                            return;
                        }
                        definitions.Add(itemDef);
                    }
                }
            }
            else
                definitions = ItemManager.GetItemDefinitions();
            var allPersistentPlayerId = GetAllPersistentPlayerId();
            foreach (var persistentPlayerId in allPersistentPlayerId)
            {
                Learn(persistentPlayerId, definitions);
                var basePlayer = FindPlayer(persistentPlayerId.ToString());
                if (basePlayer != player)
                    Reply(player, arg, "{0} learned all blueprints", basePlayer == null ? persistentPlayerId.ToString() : basePlayer.displayName);
                if (basePlayer == null) continue;
                SendReply(basePlayer, "You learned all blueprints");
            }
        }

        [ConsoleCommand("bp.remove")]
        void cmdConsoleBpRemove(ConsoleSystem.Arg arg)
        {
            BpRemove(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpremove")]
        void cmdChatBpRemove(BasePlayer player, string command, string[] args)
        {
            BpRemove(player, args);
        }

        void BpRemove(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevelOther, arg)) return;
            Puts("{0} used /bpremove {1}", player?.displayName, string.Join(" ", args));
            List<int> definitions;
            var defaultBlueprints = new List<int>(ItemManager.defaultBlueprints);
            if (args == null || args.Length <= 0)
            {
                Reply(player, arg, "No player(s) given.");
                return;
            }
            var allPersistentPlayerId = GetAllPersistentPlayerId().ToList();
            var players = new List<ulong>();
            foreach (var nameOrIdOrIp in args[0].Split(','))
            {
                if (string.IsNullOrEmpty(nameOrIdOrIp)) continue;
                var basePlayer = FindPlayer(nameOrIdOrIp);
                if (basePlayer == null)
                {
                    ulong userId;
                    if (!ulong.TryParse(nameOrIdOrIp, out userId) || !allPersistentPlayerId.Contains(userId))
                    {
                        Reply(player, arg, "Player not found: {0}", nameOrIdOrIp);
                        return;
                    }
                    players.Add(userId);
                    continue;
                }
                players.Add(basePlayer.userID);
            }
            if (args.Length > 1)
            {
                definitions = new List<int>();
                foreach (var def in args[1].Split(','))
                {
                    var name = def.ToLower();
                    if (_itemShortname.ContainsKey(name))
                        name = _itemShortname[name];
                    var itemDef = ItemManager.FindItemDefinition(name);
                    if (itemDef == null)
                    {
                        Reply(player, arg, "Item not found: {0}", def);
                        return;
                    }
                    definitions.Add(itemDef.itemid);
                }
            }
            else
            {
                definitions = ItemManager.GetItemDefinitions().ConvertAll(i => i.itemid);
                //just delete non default
                definitions.RemoveAll(d => defaultBlueprints.Contains(d));
            }
            var defaultRemoved = definitions.Where(d => defaultBlueprints.Contains(d)).Select(d => ItemManager.itemDictionary[d].shortname).ToArray();
            if (defaultRemoved.Length > 0)
            {
                Reply(player, arg, "Found default blueprint(s)! Removed until respawn.");
                Reply(player, arg, "Bps: " + string.Join(",", defaultRemoved));
            }
            foreach (var persistentPlayerId in players)
            {
                if (persistentPlayerId == 0 ) continue;
                var data = ServerMgr.Instance.persistance.GetPlayerInfo(persistentPlayerId);
                if (data.blueprints.complete.RemoveAll(a => definitions.Contains(a)) > 0)
                {
                    ServerMgr.Instance.persistance.SetPlayerInfo(persistentPlayerId, data);
                    var targetPlayer = FindPlayer(persistentPlayerId.ToString());
                    if (targetPlayer?.net?.subscriber?.subscribed == null) continue;
                    targetPlayer.SendFullSnapshot();
                }
            }
            Reply(player, arg, "Removed learned blueprints");
        }

        [ConsoleCommand("bp.removeall")]
        void cmdConsoleBpRemoveAll(ConsoleSystem.Arg arg)
        {
            BpRemoveAll(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpremoveall")]
        void cmdChatBpRemoveAll(BasePlayer player, string command, string[] args)
        {
            BpRemoveAll(player, args);
        }

        void BpRemoveAll(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevelOther, arg)) return;
            Puts("{0} used /bpremoveall {1}", player?.displayName, string.Join(" ", args));
            List<int> definitions;
            var defaultBlueprints = new List<int>(ItemManager.defaultBlueprints);
            if (args != null && args.Length > 0)
            {
                definitions = new List<int>();
                foreach (var cur in args)
                {
                    foreach (var def in cur.Split(','))
                    {
                        var name = def.ToLower();
                        if (_itemShortname.ContainsKey(name))
                            name = _itemShortname[name];
                        var itemDef = ItemManager.FindItemDefinition(name);
                        if (itemDef == null)
                        {
                            Reply(player, arg, "Item not found: {0}", def);
                            return;
                        }
                        definitions.Add(itemDef.itemid);
                    }
                }
            }
            else
            {
                definitions = ItemManager.GetItemDefinitions().ConvertAll(i => i.itemid);
                //just delete non default
                definitions.RemoveAll(d => defaultBlueprints.Contains(d));
            }
            var defaultRemoved = definitions.Where(d => defaultBlueprints.Contains(d)).Select(d => ItemManager.itemDictionary[d].shortname).ToArray();
            if (defaultRemoved.Length > 0)
            {
                Reply(player, arg, "Found default blueprint(s)! Removed until respawn.");
                Reply(player, arg, "Bps: " + string.Join(",", defaultRemoved));
            }
            var allPersistentPlayerId = GetAllPersistentPlayerId();
            foreach (var persistentPlayerId in allPersistentPlayerId)
            {
                if (persistentPlayerId == 0) continue;
                var data = ServerMgr.Instance.persistance.GetPlayerInfo(persistentPlayerId);
                if (data.blueprints.complete.RemoveAll(a => definitions.Contains(a)) > 0)
                {
                    ServerMgr.Instance.persistance.SetPlayerInfo(persistentPlayerId, data);
                    var targetPlayer = FindPlayer(persistentPlayerId.ToString());
                    if (targetPlayer?.net?.subscriber?.subscribed == null) continue;
                    targetPlayer.SendFullSnapshot();
                }
            }
            Reply(player, arg, "Removed learned blueprints");
        }

        [ConsoleCommand("bp.clean")]
        void cmdConsoleBpClean(ConsoleSystem.Arg arg)
        {
            BpClean(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpclean")]
        void cmdChatBpClean(BasePlayer player, string command, string[] args)
        {
            BpClean(player, args);
        }

        void BpClean(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevelOther, arg)) return;
            Puts("{0} used /bpclean {1}", player?.displayName, string.Join(" ", args));
            var playerIds = BasePlayer.activePlayerList.ConvertAll(p => p.userID);
            playerIds.AddRange(BasePlayer.sleepingPlayerList.ConvertAll(p => p.userID));
            DeletePersistentPlayersExcept(playerIds);
            Reply(player, arg, "Cleaned learned blueprints");
        }

        [ConsoleCommand("bp.save")]
        void cmdConsoleBpSave(ConsoleSystem.Arg arg)
        {
            BpSave(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpsave")]
        void cmdChatBpSave(BasePlayer player, string command, string[] args)
        {
            BpSave(player, args);
        }

        void BpSave(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevelOther, arg)) return;
            Puts("{0} used /bpsave {1}", player?.displayName, string.Join(" ", args));
            var allPersistentPlayerId = GetAllPersistentPlayerId();
            var playerLearned = new Dictionary<ulong, HashSet<string>>();
            foreach (var persistentPlayerId in allPersistentPlayerId)
            {
                if (persistentPlayerId == 0) continue;
                var learned = GetLearned(persistentPlayerId);
                if (learned.Count <= 0) continue;
                playerLearned.Add(persistentPlayerId, learned);
            }
            Interface.Oxide.DataFileSystem.WriteObject($"{nameof(BlueprintManager)}_{Protocol.network}", playerLearned);
            Reply(player, arg, "Saved learned blueprints");
        }

        [ConsoleCommand("bp.load")]
        void cmdConsoleBpLoad(ConsoleSystem.Arg arg)
        {
            BpLoad(arg.Player(), arg.Args ?? new string[0], arg);
        }

        [ChatCommand("bpload")]
        void cmdChatBpLoad(BasePlayer player, string command, string[] args)
        {
            BpLoad(player, args);
        }

        void BpLoad(BasePlayer player, string[] args, ConsoleSystem.Arg arg = null)
        {
            if (!CheckAccess(player, _authLevelOther, arg)) return;
            Puts("{0} used /bpload {1}", player?.displayName, string.Join(" ", args));
            if (playerLearned == null || playerLearned.Count <= 0)
            {
                Reply(player, arg, "Nothing to remember.");
                return;
            }
            foreach (var learned in playerLearned)
            {
                var definitions = new List<ItemDefinition>();
                foreach (var shortName in learned.Value)
                {
                    var itemDef = ItemManager.FindItemDefinition(shortName);
                    if (itemDef == null)
                    {
                        Reply(player, arg, "Item not found: {0}", shortName);
                        return;
                    }
                    definitions.Add(itemDef);
                }
                Learn(learned.Key, definitions);
                var basePlayer = FindPlayer(learned.Key.ToString());
                if (basePlayer != player)
                    Reply(player, arg, "{0} recovered old blueprints", basePlayer == null ? learned.Key.ToString() : basePlayer.displayName);
                if (basePlayer == null) continue;
                SendReply(basePlayer, "You recovered your old blueprints");
            }
            Reply(player, arg, "Loaded learned blueprints");
        }

        [ChatCommand("remember")]
        void cmdChatRemember(BasePlayer player, string command, string[] args)
        {
            Puts("{0} used /remember {1}", player.displayName, string.Join(" ", args));
            HashSet<string> learned;
            if (playerLearned == null || !playerLearned.TryGetValue(player.userID, out learned) || learned.Count <= 0)
            {
                SendReply(player, "Nothing to remember.");
                return;
            }
            var definitions = new List<ItemDefinition>();
            foreach (var shortName in learned)
            {
                var itemDef = ItemManager.FindItemDefinition(shortName);
                if (itemDef == null)
                {
                    Puts("Item not found: {0} Player: {1}", shortName, player.displayName);
                    return;
                }
                definitions.Add(itemDef);
            }
            Learn(player.userID, definitions);
            SendReply(player, "You recovered your old blueprints");
        }

        void Reply(BasePlayer player, ConsoleSystem.Arg arg, string format, params object[] args)
        {
            if (arg != null) SendReply(arg, format, args);
            else if (player != null) SendReply(player, format, args);
            else Puts(format, args);
        }

        private static void Learn(ulong persistentPlayerId, IEnumerable<ItemDefinition> itemDefs)
        {
            var playerInfo = ServerMgr.Instance.persistance.GetPlayerInfo(persistentPlayerId);
            var learned = false;
            var player = FindPlayer(persistentPlayerId.ToString());
            foreach (var itemDef in itemDefs)
            {
                if (playerInfo.blueprints.complete.Contains(itemDef.itemid)) continue;
                learned = true;
                playerInfo.blueprints.complete.Add(itemDef.itemid);
                if (player?.net == null) continue;
                player.SendNetworkUpdate();
                player.ClientRPCPlayer(null, player, "UnlockedBlueprint", itemDef.itemid);
                player.stats.Add("blueprint_studied", 1);
            }
            if (learned)
                ServerMgr.Instance.persistance.SetPlayerInfo(persistentPlayerId, playerInfo);
        }

        private static HashSet<string> GetLearned(ulong persistentPlayerId)
        {
            var playerInfo = ServerMgr.Instance.persistance.GetPlayerInfo(persistentPlayerId);
            var bpss = new HashSet<string>();
            if (playerInfo == null) return bpss;
            var bps = playerInfo.blueprints.complete.ToList();
            bps.RemoveAll(i => ItemManager.defaultBlueprints.Contains(i));
            foreach (var bp in bps)
            {
                var definition = ItemManager.FindItemDefinition(bp);
                if (definition == null) continue;
                bpss.Add(definition.shortname);
            }
            return bpss;
        }

        private void DeletePersistentPlayersExcept(List<ulong> players)
        {
            var dbField = typeof(UserPersistance).GetField("db", BindingFlags.Instance | BindingFlags.NonPublic);
            var db = (SQLite)dbField?.GetValue(ServerMgr.Instance.persistance);
            if (db == null) return;
            try
            {
                db.Execute($"DELETE FROM datatable WHERE steamid NOT IN ({string.Join(",", players.ConvertAll(p => p.ToString()).ToArray())})");
            }
            catch (Exception e)
            {
                Puts("Execute failed: {0}", e.Message);
            }
        }

        private ulong[] GetAllPersistentPlayerId()
        {
            var dbField = typeof (UserPersistance).GetField("db", BindingFlags.Instance | BindingFlags.NonPublic);
            var db = (SQLite)dbField?.GetValue(ServerMgr.Instance.persistance);
            var columnValue = new List<ulong>();
            if (db == null) return columnValue.ToArray();
            try
            {
                db.QueryPrepare("SELECT steamid FROM datatable");
                if (db.Columns() <= 0)
                {
                    db.QueryFinalize();
                    return columnValue.ToArray();
                }
                while (db.StepRow())
                    columnValue.Add(db.GetColumnValue<ulong>(0, 0));
                db.QueryFinalize();
            }
            catch (Exception e)
            {
                Puts("Query failed: {0}", e.Message);
                try
                {
                    db.QueryFinalize();
                }
                catch (Exception)
                {
                }
            }
            return columnValue.ToArray();
        }

        private static BasePlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrIdOrIp)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrIdOrIp)
                    return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.UserIDString == nameOrIdOrIp)
                    return sleepingPlayer;
                if (sleepingPlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return sleepingPlayer;
            }
            return null;
        }
    }
}


// --- End of file: BlueprintManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UnlockDlcItems.cs ---
// --- Original Local Path: UnlockDlcItems.cs ---

﻿/*
 ########### README ####################################################
                                                                             
  !!! DON'T EDIT THIS FILE !!!
                                                                     
 ########### CHANGES ###################################################

 1.0.0
    - Plugin release

 #######################################################################
*/

using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Unlock Dlc Items", "rustmods.ru", "1.0.0")]
    [Description("Unlock all DLC items blueprints")]
    class UnlockDlcItems : RustPlugin
    {
        #region [Fields]

        private const string permAllow = "unlockdlcitems.allow";

        private List<ItemBlueprint> dlcItemBlueprintsCache = new List<ItemBlueprint>();

        #endregion

        #region [Oxide Hooks]

        private void OnServerInitialized()
        {
            permission.RegisterPermission(permAllow, this);

            foreach (ItemBlueprint item in ItemManager.bpList)
            {
                if (!item.userCraftable)
                    continue;

                if (!item.NeedsSteamDLC)
                    continue;

                if (!dlcItemBlueprintsCache.Contains(item))
                    dlcItemBlueprintsCache.Add(item);
            }

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                ResetDLC(player);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(1, () => OnPlayerConnected(player));
                return;
            }

            if (!permission.UserHasPermission(player.UserIDString, permAllow))
                return;

            UnlockDLC(player);
        }

        private void OnGroupPermissionGranted(string name, string permName)
        {
            if (permName != permAllow)
                return;

            foreach (var player in BasePlayer.activePlayerList.Where(w => permission.UserHasGroup(w.UserIDString, name)))
            {
                UnlockDLC(player);
            }
        }

        private void OnGroupPermissionRevoked(string name, string permName)
        {
            if (permName != permAllow)
                return;

            foreach (var player in BasePlayer.activePlayerList.Where(w => permission.UserHasGroup(w.UserIDString, name) && !permission.UserHasPermission(w.UserIDString, permAllow)))
            {
                ResetDLC(player);
            }
        }

        private void OnUserPermissionGranted(string id, string permName)
        {
            if (permName != permAllow)
                return;

            var player = BasePlayer.Find(id);
            if (player == null)
                return;

            UnlockDLC(player);
        }

        private void OnUserPermissionRevoked(string id, string permName)
        {
            if (permName != permAllow)
                return;

            var player = BasePlayer.Find(id);
            if (player == null)
                return;

            if (permission.UserHasPermission(player.UserIDString, permAllow))
                return;

            ResetDLC(player);
        }

        #endregion

        #region [Hooks]   

        private void UnlockDLC(BasePlayer player)
        {
            var info = player.PersistantPlayerInfo;
            foreach (ItemBlueprint item in dlcItemBlueprintsCache)
            {
                if (!info.unlockedItems.Contains(item.targetItem.itemid))
                    info.unlockedItems.Add(item.targetItem.itemid);
            }

            player.PersistantPlayerInfo = info;
            player.SendNetworkUpdateImmediate();
            player.ClientRPCPlayer(null, player, "UnlockedBlueprint", 0);
        }

        private void ResetDLC(BasePlayer player)
        {
            var info = player.PersistantPlayerInfo;
            foreach (ItemBlueprint item in dlcItemBlueprintsCache)
            {
                if (!item.targetItem.steamDlc.HasLicense(player.userID) && info.unlockedItems.Contains(item.targetItem.itemid))
                    info.unlockedItems.Remove(item.targetItem.itemid);
            }

            player.PersistantPlayerInfo = info;
            player.SendNetworkUpdateImmediate();
            player.ClientRPCPlayer(null, player, "UnlockedBlueprint", 0);
        }

        #endregion
    }
}

// --- End of file: UnlockDlcItems.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomRespawn.cs ---
// --- Original Local Path: CustomRespawn.cs ---

// Custom Respawn скачан с сайта Server-rust.ru Сотни новых бесплатных плагинов уже на нашем сайте! 
// Присоеденяйся к нам! Server-rust.ru
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Custom Respawn", "Server-rust.ru", "0.1.91")]
    [Description("Выбор снаряжения во время возраждения.")]
    {
        #region ENums

        private enum ItemType
        {
            ОСНОВНОЕ_ОРУЖИЕ,
            ДОПОЛНИТЕЛЬНОЕ_ОРУЖИЕ,
            
            МЕДИЦИНСКИЙ_ПРЕПАРАТ,
            ПРИПАСЫ
        }
        
        #endregion
        
        #region Classes

        #region Perks

        private class PlayerPerk : MonoBehaviour
        {
            [JsonProperty("Отображаемое имя перка")]
            public string DisplayName;
            [JsonProperty("Ссылка на изображение")]
            public string PictureURL;
            [JsonProperty("Описание")]
            public string Description;

            [JsonProperty("Цена данного перка")]
            public int Price;
        }

        private class HealPerk : PlayerPerk
        {
            private void Awake()
            {
                Interface.Oxide.LogWarning("Условно будем здесь хилить игрока");
                GetComponent<BasePlayer>().Heal(100);
            }
        }

        private class KillPerk : PlayerPerk
        {
            private void Awake()
            {
                Interface.Oxide.LogWarning("Условно будем здесь убивать игрока");
                // TODO: GetComponent<BasePlayer>().Die();
            }
        }

        #endregion
        
        #region LoadOut
        
        private class CustomItem
        {
            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("Короткое имя предмета")]
            public string ShortName;
            [JsonProperty("Номер скина (ID)")]
            public ulong SkinID;
            [JsonProperty("Количество предмета")]
            public int Amount;
            [JsonProperty("Доп. изображение предмета")]
            public string PictureURL;
            [JsonProperty("Разрешить только по пермишену")]
            public string Permission;
            [JsonProperty("Дополнительные предметы")]
            public Dictionary<string, int> AdditionalItems = new Dictionary<string, int>();

            [JsonProperty("Цена предмета")]
            public int Price;

            public void CreateItem(BasePlayer player)
            {
                if (string.IsNullOrEmpty(ShortName))
                    return;
                
                Item createItem = ItemManager.CreateByPartialName(ShortName, Amount);
                createItem.skin = SkinID;
                createItem.name = DisplayName;
                createItem.MoveToContainer(player.inventory.containerBelt);
                
                foreach (var check in AdditionalItems)
                {
                    createItem = ItemManager.CreateByPartialName(check.Key, check.Value);
                    createItem.skin = SkinID;
                    createItem.name = DisplayName;
                    createItem.MoveToContainer(player.inventory.containerMain);
                }
            }
        }
        
        private class PlayerPack
        {
            [JsonProperty("Список предметов игрока")]
            public Dictionary<ItemType, CustomItem> CustomItems = new Dictionary<ItemType, CustomItem>();
            [JsonProperty("Улучшения которые можно будет докупать")]
            public List<PlayerPerk> PerkList = new List<PlayerPerk>();

            public bool AddPerk(PlayerPerk addPerk)
            {
                if (PerkList.Contains(addPerk))
                    return false;
                
                PerkList.Add(addPerk);
                return true;
            }
            
            public int BuyPrice()
            {
                int resultPrice = CustomItems.Sum(p => p.Value.Price) + PerkList.Sum(p => p.Price);
                return resultPrice;
            }

            public bool IsDefault()
            {
                foreach (var check in CustomItems)
                {
                    if (check.Value != config.ListOfItems[check.Key].First().Value)
                        return false;
                }

                return true;
            }
        }
        
        #endregion

        #region Configuration

        private class Configuration
        {
            #region Side Section

            internal class Design
            {
                [JsonProperty("Ссылка на изображение заднего плана (1920х1080)")]
                public string CONF_BackgroundImage = "https://i.imgur.com/1wfjYCc.jpg";
                [JsonProperty("Ссылка на изображение человека (270х686)")]
                public string CONF_ManImage = "https://i.imgur.com/CuD4xv4.png";
            }
            
            internal class Balance
            {
                [JsonProperty("Использовать баланс от Server Rewards")]
                public bool CONF_UseSR;
                [JsonProperty("Использовать баланс от Economics")]
                public bool CONF_UseEconomics;
                [JsonProperty("Использовать баланс от RustShop")]
                public bool CONF_UseRustShop;
                [JsonProperty("Использовать баланс от NShop")]
                public bool CONF_UseNShop;
                [JsonProperty("Использовать внутренний баланс (сихронизация с донат-магазинами)")]
                public bool CONF_UseCustom;
                [JsonProperty("Стартовый баланс при использовании внутреннего баланса")]
                public int CONF_CustomStartBalance;
            }

            internal class Plugin
            {
                [JsonProperty("Показывать меню выбора снаряжения для игроков с привилегией")]
                public string CONF_ShowPermission;
                [JsonProperty("Выдавать помимо закупленных предметов - автоКит")]
                public bool CONF_GiveAutoKit;
                [JsonProperty("Настройки отображения информации об убийце")]
                public KillInfo CONF_KillInfo = new KillInfo();
            }

            internal class KillInfo
            {
                internal class Button
                {
                    [JsonProperty("Отображаемое имя")]
                    public string DisplayName;
                    [JsonProperty("Команда")]
                    public string Command;

                    [JsonProperty("Цвет кнопки")]
                    public string Color;
                }
                [JsonProperty("Показывать информацию об убийце")]
                public bool CONF_ShowKillerInfo;
                [JsonProperty("Кнопки под информацией")]
                public List<Button> CONF_KillerInfoButton = new List<Button>();
            }

            #endregion
            
            [JsonProperty("Настройки дизайна плагина", Order = 0)]
            public Design DesignSetting = new Design();
            [JsonProperty("Настройки баланса игроков", Order = 1)]
            public Balance BalanceSettings = new Balance();
            [JsonProperty("Настройки плагина", Order = 2)]
            public Plugin PluginSettings = new Plugin();
            [JsonProperty("Предметы доступные для покупки", Order = 3)]
            public Dictionary<ItemType, Dictionary<string, CustomItem>> ListOfItems;

            #region Default Methods

            public PlayerPack GetDefaultPack()
            {
                PlayerPack newPack = new PlayerPack();
                
                foreach (var check in ListOfItems.Where(p => p.Value.ContainsKey("default")))
                    newPack.CustomItems.Add(check.Key, check.Value["default"]);
                
                return newPack;
            }

            public static Configuration GetNewCong()
            {
                return new Configuration
                {
                    DesignSetting = new Design
                    {
                        CONF_BackgroundImage = "https://i.imgur.com/1wfjYCc.jpg",
                        CONF_ManImage = "https://i.imgur.com/CuD4xv4.png",
                    },
                    BalanceSettings = new Balance(),
                    PluginSettings = new Plugin
                    {
                        CONF_ShowPermission = "",
                        CONF_KillInfo = new KillInfo
                        {
                            CONF_ShowKillerInfo = true,
                            CONF_KillerInfoButton = new List<KillInfo.Button>
                            {
                                new KillInfo.Button
                                {
                                    DisplayName = "<color=#ABA7A7>ПОЖАЛОВАТЬСЯ</color>",
                                    Command = "report %STEAMID%",
                                    Color = "#575757AC"
                                }
                            }
                        }
                    },
                    ListOfItems = new Dictionary<ItemType, Dictionary<string, CustomItem>>
                    {
                        [ItemType.ОСНОВНОЕ_ОРУЖИЕ] = new Dictionary<string, CustomItem>
                        {
                            ["default"] = new CustomItem
                            {
                                DisplayName = "ПУСТО",
                                ShortName = "",
                                Amount = 0,
                                SkinID = 0UL,
                                Price = 0,
                                PictureURL = "",
                                Permission = ""
                            },
                            ["1"] = new CustomItem
                            {
                                DisplayName = GetColor("Лук Лары", 1),
                                ShortName = "bow.hunting",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                AdditionalItems = new Dictionary<string, int>
                                {
                                    ["arrow.wooden"] = 16,
                                },
    
                                Price = 35,
                                Permission = ""
                            },
                            ["2"] = new CustomItem
                            {
                                DisplayName = GetColor("Арбалет Дэрила", 2),
                                ShortName = "crossbow",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                AdditionalItems = new Dictionary<string, int>
                                {
                                    ["arrow.wooden"] = 32,
                                },
                                Price = 50,
                                Permission = ""
                            },
                            ["3"] = new CustomItem
                            {
                                DisplayName = GetColor("Лучший чиркаш", 3),
                                ShortName = "pistol.eoka",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                AdditionalItems = new Dictionary<string, int>
                                {
                                    ["ammo.handmade.shell"] = 3,
                                },
                                Permission = "CustomRespawn.VIP",
    
                                Price = 75
                            },
                        },
                        [ItemType.ДОПОЛНИТЕЛЬНОЕ_ОРУЖИЕ] = new Dictionary<string, CustomItem>
                        {
                            ["default"] = new CustomItem
                            {
                                DisplayName = GetColor("Просто камень", 0),
                                ShortName = "rock",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "",
    
                                Price = 0
                            },
                            ["1"] = new CustomItem
                            {
                                DisplayName = GetColor("Топорик новичка", 1),
                                ShortName = "stonehatchet",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "",
    
                                Price = 10
                            },
                            ["2"] = new CustomItem
                            {
                                DisplayName = GetColor("Мачете Джо", 2),
                                ShortName = "machete",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "",
    
                                Price = 15
                            },
                            ["3"] = new CustomItem
                            {
                                DisplayName = GetColor("Копьё Македонского", 3),
                                ShortName = "spear.wooden",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "CustomRespawn.VIP",
    
                                Price = 25
                            },
                        },
                        [ItemType.ПРИПАСЫ] = new Dictionary<string, CustomItem>
                        {
                            ["default"] = new CustomItem
                            {
                                DisplayName = GetColor("Яблоко просвещения", 0),
                                ShortName = "apple",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "",
    
                                Price = 0
                            },
                            ["1"] = new CustomItem
                            {
                                DisplayName = GetColor("Мясо священого оленя", 1),
                                ShortName = "deermeat.cooked",
                                Amount = 2,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "",
    
                                Price = 15
                            },
                            ["2"] = new CustomItem
                            {
                                DisplayName = GetColor("Мясо медведя", 2),
                                ShortName = "bearmeat.cooked",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "",
    
                                Price = 30
                            },
                            ["3"] = new CustomItem
                            {
                                DisplayName = GetColor("Волшебные ягодки", 3),
                                ShortName = "blueberries",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "CustomRespawn.VIP",
    
                                Price = 50
                            },
                        },
                        [ItemType.МЕДИЦИНСКИЙ_ПРЕПАРАТ] = new Dictionary<string, CustomItem>
                        {
                            ["default"] = new CustomItem
                            {
                                DisplayName = "",
                                ShortName = "",
                                Amount = 0,
                                SkinID = 0UL,
                                Price = 0,
                                PictureURL = "",
                                Permission = "",
                            },
                            ["1"] = new CustomItem
                            {
                                DisplayName = GetColor("Бинт", 1),
                                ShortName = "bandage",
                                Amount = 2,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "",
    
                                Price = 15
                            },
                            ["2"] = new CustomItem
                            {
                                DisplayName = GetColor("Шприц", 2),
                                ShortName = "syringe.medical",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "",
    
                                Price = 30
                            },
                            ["3"] = new CustomItem
                            {
                                DisplayName = GetColor("Аптечка", 3),
                                ShortName = "largemedkit",
                                Amount = 1,
                                SkinID = 0UL,
                                PictureURL = "",
                                Permission = "CustomRespawn.VIP",
    
                                Price = 50
                            },
                        },
                    }
                };
            }

            #endregion
        }

        #endregion
        
        #endregion

        #region Variables

        private static bool Initialized = false;
        [PluginReference] private Plugin ImageLibrary;
        private static Configuration config = new Configuration();
        
        [JsonProperty("Список предметов у игроков")]
        private static Dictionary<ulong, PlayerPack> playerPacks = new Dictionary<ulong, PlayerPack>();
        
        #endregion

        #region Initialization
        
        private void OnServerInitialized()
        {
     		if (config.DesignSetting.CONF_BackgroundImage != "")
                ImageLibrary.Call("AddImage", config.DesignSetting.CONF_BackgroundImage, "CR_MainBackground");
            if (config.DesignSetting.CONF_ManImage != "")
                ImageLibrary.Call("AddImage", config.DesignSetting.CONF_ManImage, "CR_MainMan");

            foreach (var check in ItemManager.itemList)
                ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{check.shortname}.png", check.shortname);
            if (config.PluginSettings.CONF_ShowPermission != "")
                permission.RegisterPermission(config.PluginSettings.CONF_ShowPermission, this);
            
            foreach (var check in config.ListOfItems)
            {
                if (check.Value.Count > 4)
                {
                    PrintWarning($"Внимание, в группе {check.Key.ToString()} более 4-ёх предметов!");
                }
            }
            
            int checkSettings = Convert.ToInt32(config.BalanceSettings.CONF_UseSR) + 
                                Convert.ToInt32(config.BalanceSettings.CONF_UseEconomics) + 
                                Convert.ToInt32(config.BalanceSettings.CONF_UseRustShop) + 
                                Convert.ToInt32(config.BalanceSettings.CONF_UseCustom) + 
                                Convert.ToInt32(config.BalanceSettings.CONF_UseNShop);
            
            if (checkSettings >= 2)
            {
                PrintError("Вы используете несколько балансов одновременно, проверьте настройки!");
                return;
            }

            if (checkSettings == 0)
            {
                PrintError("Вы не выбрали ни одной системы баланса в качестве используемой, проверьте настройки!");
                return;
            }

            if (config.BalanceSettings.CONF_UseSR && !ServerRewards)
            {
                PrintError("Плагин планировал использовать баланс от СерверРевардс, но плагин выгружен!");
                return;
            }

            if (config.BalanceSettings.CONF_UseEconomics && !Economics)
            {
                PrintError("Плагин планировал использовать баланс от Экономики, но плагин выгружен!");
                return;
            }

            if (config.BalanceSettings.CONF_UseRustShop && !RustShop)
            {
                PrintError("Плагин планировал использовать баланс от Экономики, но плагин выгружен!");
                return;
            }

            if (config.BalanceSettings.CONF_UseNShop && !NShop)
            {
                PrintError("Плагин планировал использовать баланс от Экономики, но плагин выгружен!");
                return;
            }

            if (config.BalanceSettings.CONF_UseCustom)
            {
                playerBalance = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, int>>("CustomRespawn/Balance");
            }

            foreach (var check in config.ListOfItems
                                        .SelectMany(p => p.Value)
                                        .Where(p => p.Value.Permission != "")
                                        .Where(p => !permission.PermissionExists(p.Value.Permission, this)))
            {
                permission.RegisterPermission(check.Value.Permission, this);
            }

            timer.Every(1, () =>
            {
                foreach (var check in BasePlayer.activePlayerList.Where(p => p.IsDead()))
                    UI_UpdateRespawn(check, 0);
            });

            foreach (var check in config.ListOfItems.Where(p => !p.Value.ContainsKey("default")))
            {
                check.Value.Add("default", new CustomItem
                {
                    DisplayName = "ПУСТО",
                    ShortName = "",
                    Amount = 0,
                    SkinID = 0UL,
                    Price = 0,
                    PictureURL = "https://i.imgur.com/sAL1r8f.png"
                });
                
                PrintWarning($"Добавлена не найденная стандартная конфигурация для {check.Key.ToString()}");
            }
            
            SaveData();
            SaveConfig();
            Initialized = true;
            
            BasePlayer.activePlayerList.ForEach(OnPlayerInit);
        }

        private void Unload() => SaveData();

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("CustomRespawn/Balance", playerBalance);
            timer.Once(60, SaveData);
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerInit(player));
                return;
            }
            
            if (!playerPacks.ContainsKey(player.userID))
                playerPacks.Add(player.userID, config.GetDefaultPack());
            
            if (config.BalanceSettings.CONF_UseCustom && !playerBalance.ContainsKey(player.userID))
                playerBalance.Add(player.userID, config.BalanceSettings.CONF_CustomStartBalance);
            
            if (player.IsDead())
            {
                UI_DrawChoose(player, null);
            }
            
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.ListOfItems == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Hooks

        private void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            if (!Initialized || player.GetComponent<NPCPlayer>() != null || player.IsNpc || !player.IsConnected)
                return;

            if (!playerPacks.ContainsKey(player.userID))
            {
                PrintError("PLEASE! If u see this - send me screen! PLEASE!");
                PrintWarning($"OPD: {player.userID} -> {player.displayName}");
                OnPlayerInit(player);
                return;
            }
            
            if (playerPacks[player.userID] == null)
                playerPacks[player.userID] = config.GetDefaultPack();
            else
                playerPacks[player.userID] = config.GetDefaultPack();
            
            if (config.PluginSettings.CONF_ShowPermission == "" || permission.UserHasPermission(player.UserIDString, config.PluginSettings.CONF_ShowPermission))
            {
                if (info == null || info.Initiator == null || !(info.Initiator is BasePlayer) || info.Initiator.GetComponent<NPCPlayer>() != null || info.InitiatorPlayer == null || info.InitiatorPlayer.userID == player.userID || info.InitiatorPlayer.userID.ToString().Length != 17)
                {
                    UI_DrawChoose(player, null);
                    return;
                }
                
                UI_DrawChoose(player, info);
            }
        }
        
        private void OnPlayerRespawn(BasePlayer player)
        {
            if (!Initialized)
                return;
            CuiHelper.DestroyUi(player, Layer);
        }
        
        private void OnPlayerRespawned(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerRespawned(player));
                return;
            }
            
            CuiHelper.DestroyUi(player, Layer);
            if (!Initialized)
                return;
            
            if (config.PluginSettings.CONF_ShowPermission == "" || permission.UserHasPermission(player.UserIDString, config.PluginSettings.CONF_ShowPermission))
            {
                if (!playerPacks.ContainsKey(player.userID))
                {
                    PrintError("PLEASE! If u see this - send me screen! PLEASE!");
                    PrintWarning($"OPR: {player.userID} -> {player.displayName}");
                    return;
                }
            
                if (playerPacks[player.userID] == null)
                    return;

                var playerInfo = playerPacks[player.userID];
                if (!config.PluginSettings.CONF_GiveAutoKit)
                {
                    player.inventory.Strip();
                }

                foreach (var check in playerInfo.CustomItems)
                    check.Value.CreateItem(player);
            }
        }
        
        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!Initialized)
                return null;
            
            if (arg.cmd.FullName.ToLower() == "global.respawn")
            {
                BasePlayer player = arg.Player();
                if (player != null)
                {
                    if (!playerPacks.ContainsKey(player.userID))
                    {
                        PrintError("PLEASE! If u see this - send me screen! PLEASE!");
                        PrintWarning($"OSC: {player.userID} -> {player.displayName}");
                        OnPlayerInit(player);
                    }
                    
                    playerPacks[player.userID] = config.GetDefaultPack();
                    if (player.IsDead())
                        player.Respawn();
                }
            }
            
            return null;
        }

        #endregion

        #region Commands

        [ConsoleCommand("cr.balance")]
        private void cmdManageBalance(ConsoleSystem.Arg args)
        {
            if (args.Player() != null || !args.HasArgs(1) || !config.BalanceSettings.CONF_UseCustom)
                return;

            ulong userId;
            if (!ulong.TryParse(args.Args[0], out userId))
            {
                args.ReplyWithObject($"cr.balance <userId> <amount>");
                return;
            }

            int amount;
            if (!int.TryParse(args.Args[1], out amount))
            {
                args.ReplyWithObject("cr.balance <userId> <amount>");
                return;
            }

            if (!playerBalance.ContainsKey(userId))
            {
                args.ReplyWithObject("No user with same ID!");
                return;
            }

            playerBalance[userId] += amount;
            args.ReplyWithObject($"We gave {amount} to {userId}");
        }
        
        [ConsoleCommand("UI_CR_Complect")]
        private void cmdConsoleComlect(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !args.HasArgs(1))
                return;

            if (!playerPacks.ContainsKey(player.userID))
            {
                PrintError("PLEASE! If u see this - send me screen! PLEASE!");
                PrintWarning($"CCC1: {player.userID} -> {player.displayName}");
                OnPlayerInit(player);
            }
            var playerInfo = playerPacks[player.userID];

            if (args.Args[0] == "default")
            {
                playerPacks[player.userID] = config.GetDefaultPack();
                UI_UpdateRespawn(player, 0);
                UI_UpdateRight(player, 0);
                return;
            }
            
            if (args.Args[0] == "customrespawn")
            {
                if (!player.IsDead())
                {
                    CuiHelper.DestroyUi(player, Layer);
                    return;
                }

                if (API_CheckBalance(player) < playerInfo.BuyPrice())
                    return;
                
                if (args.HasArgs(2))
                {
                    bool spawned = SleepingBag.SpawnPlayer(player, uint.Parse(args.Args[1]));
                    if (!spawned)
                    {
                        UI_UpdateRespawn(player, 0);
                        return;
                    }

                    if (playerInfo.BuyPrice() > 0)
                    {
                        API_TakeBalance(player, playerInfo.BuyPrice());
                        player.ChatMessage($"Вы потратили <color=#4286f4><b>{playerInfo.BuyPrice()} руб.</b></color> на экипировку!");
                    }
                    return;
                }

                if (playerInfo.BuyPrice() > 0)
                {
                    API_TakeBalance(player, playerInfo.BuyPrice());
                    player.ChatMessage($"Вы потратили <color=#4286f4><b>{playerInfo.BuyPrice()} руб.</b></color> на экипировку!");
                }
                player.Respawn();
                return;
            }

            if (!args.HasArgs(2))
                return;
            
            ItemType itemType;
            if (Enum.TryParse(args.Args[1], out itemType))
            {
                int currentBalance = 100;
                
                if (!config.ListOfItems.ContainsKey(itemType) || !config.ListOfItems[itemType].ContainsKey(args.Args[2]))
                {
                    PrintError("PLEASE! If u see this - send me screen! PLEASE!");
                    PrintWarning($"CCC2: {itemType} -> {args.Args[2]}");
                    return;
                }
                
                if (!permission.UserHasPermission(player.UserIDString, config.ListOfItems[itemType][args.Args[2]].Permission) && config.ListOfItems[itemType][args.Args[2]].Permission != "")
                    return;
                
                if (!playerInfo.CustomItems.ContainsKey(itemType))
                {
                    PrintError("PLEASE! If u see this - send me screen! PLEASE!");
                    PrintWarning($"CCC3: {player.userID} -> {itemType}");
                    return;
                }
                playerInfo.CustomItems[itemType] = config.ListOfItems[itemType][args.Args[2]];
                UI_UpdateRight(player, 1, 0);
                UI_UpdateRespawn(player);
            }
        }

        #endregion

        #region Interface

        private static string Layer = "UI_CR_Main";
        private void UI_DrawChoose(BasePlayer player, HitInfo info)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            if (!playerPacks.ContainsKey(player.userID))
            {
                OnPlayerInit(player);
                
                NextTick(() => UI_DrawChoose(player, info));
                return;
            }
            var playerInfo = playerPacks[player.userID];
            
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", Layer);

            if (config.DesignSetting.CONF_BackgroundImage != "")
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiRawImageComponent { FadeIn = 4f, Png = (string) ImageLibrary.Call("GetImage", "CR_MainBackground") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-960 -540", OffsetMax = "960 540" }
                    }
                });
            }
            
            if (config.DesignSetting.CONF_ManImage != "")
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiRawImageComponent { FadeIn = 3f, Png = (string) ImageLibrary.Call("GetImage", "CR_MainMan") },
                        new CuiRectTransformComponent { AnchorMin = "0.4989583 0.5675924", AnchorMax = "0.4989583 0.5675924", OffsetMin = "-90 -228.5", OffsetMax = "90 228.5" }
                    }
                });
            }
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3796874 0.1818519", AnchorMax = "0.6203126 0.21", OffsetMax = "0 0" },
                Text = { FadeIn = 4f, Text = $"БАЛАНС: {API_CheckBalance(player)} РУБ.", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, Layer);

            if (config.PluginSettings.CONF_KillInfo.CONF_ShowKillerInfo && info != null)
            {
                UI_DrawKiller(player, container, info);
            }
            
            CuiHelper.AddUi(player, container);
            
            UI_UpdateRight(player, 4);
            UI_UpdateRespawn(player, 4);
        }

        private void UI_DrawKiller(BasePlayer player, CuiElementContainer container, HitInfo info)
        {
            BasePlayer killer = info.InitiatorPlayer;
            
            container.Add(new CuiElement
            {
                Name = Layer + ".KillHolder",
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent { Color = HexToRustFormat("#707070A6") },
                    new CuiRectTransformComponent { AnchorMin = "0.0177083 0.8092593", AnchorMax = "0.2947917 0.9648148", OffsetMax = "0 0" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer + ".KillHolder",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", killer.UserIDString) },
                    new CuiRectTransformComponent { AnchorMin = "0.01248179 0.03023276", AnchorMax = "0.306168 0.9604649", OffsetMax = "0 0" }
                }
            });

            container.Add(new CuiLabel
            {
                Text = { Text = $"<size=24><b>УБИЙЦА</b></size>\n" + killer.displayName.ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = "0.3120302 0", AnchorMax = "1 1", OffsetMax = "0 0" }
            }, Layer + ".KillHolder");
            
            container.Add(new CuiElement
            {
                Name = Layer + ".KillHolder.Weapon",
                Parent = Layer + ".KillHolder",
                Components =
                {
                    new CuiImageComponent { Color = HexToRustFormat("#595959AC") },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1.304285 1", OffsetMax = "0 0" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer + ".KillHolder.Weapon",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", info.Weapon.GetItem().info.shortname) },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
            });
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Sprite = "assets/content/ui/ui.background.tiletex.psd", Color = "0 0 0 0.3" },
                Text = { Text = info.ProjectileDistance.ToString("F0") + " M", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 40 }
            }, Layer + ".KillHolder.Weapon");

            float width = (float) 1.304285f / config.PluginSettings.CONF_KillInfo.CONF_KillerInfoButton.Count;
            foreach (var check in config.PluginSettings.CONF_KillInfo.CONF_KillerInfoButton.Select((i,t) => new { A = i, B = t }))
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + width * check.B} -0.2", AnchorMax = $"{width + width * check.B} 0", OffsetMax = "0 0" },
                    Button = { Command = check.A.Command.Replace("%STEAMID%", killer.UserIDString), Sprite = "assets/content/ui/ui.background.tiletex.psd", Color = HexToRustFormat(check.A.Color) },
                    Text = { Text = check.A.DisplayName, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 14 }
                }, Layer + ".KillHolder");
            }
        }
 
        private void UI_UpdateRight(BasePlayer player, int fadeIn = 0, int textFadeIn = 4)
        {
            if (!playerPacks.ContainsKey(player.userID))
            {
                OnPlayerInit(player);
                
                NextTick(() => UI_UpdateRight(player));
                return;
            }
            CuiElementContainer container = new CuiElementContainer();
            var playerInfo = playerPacks[player.userID];
            
            foreach (var category in config.ListOfItems.Select((i,t) => new { A = i, B = t }))
            {
                CuiHelper.DestroyUi(player, Layer + $".{category.A.Key}");
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.6394791 {0.875557 - category.B * 0.2}", AnchorMax = $"0.956041 {0.945 - category.B * 0.2}", OffsetMax = "0 0" },
                    Text = { FadeIn = textFadeIn, Text = $"ВЫБЕРИТЕ {category.A.Key.ToString().Replace("_", " ")}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18 }
                }, Layer, Layer + $".{category.A.Key}");

                foreach (var item in category.A.Value.Select((i,t) => new { A = i, B = t }))
                {
                    CuiHelper.DestroyUi(player, Layer + $".{category.A.Key}.{item.A.Key}");
                    string color = playerInfo.CustomItems[category.A.Key].DisplayName == item.A.Value.DisplayName  ? "#5F8C58FF" : "#707070A6";
                    if (!permission.UserHasPermission(player.UserIDString, item.A.Value.Permission) && item.A.Value.Permission  != "")
                        color = "#ccbd3fFF";
                    
                    container.Add(new CuiButton
                    {
                        RectTransform = {AnchorMin = $"{0.6394791 + item.B * 0.083} {0.7416681 - category.B * 0.2}", AnchorMax = $"{0.7176041 + item.B * 0.083} {0.880557 - category.B * 0.2}"},
                        Button = { FadeIn = fadeIn, Color = HexToRustFormat(color), Command = $"UI_CR_Complect switch main_weapon {item.A.Key}"},
                        Text = { Text = "" }
                    }, Layer, Layer + $".{category.A.Key}.{item.A.Key}");

                    if (item.A.Value.ShortName != "")
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".{category.A.Key}.{item.A.Key}",
                            Components =
                            {
                                new CuiRawImageComponent { FadeIn = fadeIn, Png = (string) ImageLibrary.Call("GetImage", item.A.Value.ShortName) },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                            }
                        });
                    }

                    string niceText = playerInfo.CustomItems[category.A.Key].DisplayName == item.A.Value.DisplayName
                        ? "ВЫБРАНО\n" +
                          $"{item.A.Value.Price} РУБ."
                        : $"ВЫБРАТЬ\n" +
                          $"{item.A.Value.Price} РУБ.";
                    if (!permission.UserHasPermission(player.UserIDString, item.A.Value.Permission) && item.A.Value.Permission  != "")
                        niceText = "ТОЛЬКО ДЛЯ\n<b>VIP</b>";

                    string colorBlur = "0 0 0 0.3";
                    if (playerInfo.CustomItems[category.A.Key].DisplayName == item.A.Value.DisplayName)
                        colorBlur = "0 0 0 0";
                    container.Add(new CuiButton
                    { 
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { FadeIn = fadeIn, Sprite = "assets/content/ui/ui.background.tiletex.psd", Material = "assets/content/ui/uibackgroundblur.mat", Color = colorBlur, Command = $"UI_CR_Complect switch {category.A.Key} {item.A.Key}"},
                        Text = { FadeIn = fadeIn, Text = niceText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"}
                    }, Layer + $".{category.A.Key}.{item.A.Key}");
                }
            }
            
            CuiHelper.AddUi(player, container);
        }

        private void UI_UpdateRespawn(BasePlayer player, int fadeIn = 0)
        {
            if (!playerPacks.ContainsKey(player.userID))
            {
                OnPlayerInit(player);
                
                NextTick(() => UI_UpdateRespawn(player));
                return;
            }
            CuiElementContainer container = new CuiElementContainer();
            var playerInfo = playerPacks[player.userID];
            int finalPrice = playerInfo.BuyPrice();
            int currentBalance = (int) API_CheckBalance(player);

            CuiHelper.DestroyUi(player, Layer + ".Default");
            string btnText = currentBalance >= finalPrice ? "ПОЯВИТЬСЯ НА ПЛЯЖЕ" : "НЕДОСТАТОЧНО СРЕДСТВ";
            
            CuiHelper.DestroyUi(player, Layer + $".MainRespawnButton");
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3796874 0.0888881", AnchorMax = "0.6203126 0.1518519", OffsetMax = "0 0" },
                Button = { FadeIn = fadeIn, Color = HexToRustFormat("#707070A6"), Material = "assets/content/ui/ui.background.transparent.radial.psd", Command = "UI_CR_Complect customrespawn" },
                Text = { FadeIn = fadeIn, Text = btnText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 26 }
            }, Layer, Layer + ".MainRespawnButton");
            
            CuiHelper.DestroyUi(player, Layer + $".MainPriceText");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3796874 0.1518519", AnchorMax = "0.6203126 0.1918519", OffsetMax = "0 0" },
                Text = { FadeIn = fadeIn, Text = $"ЦЕНА ЭКИПИРОВКИ: <b>{finalPrice} РУБ.</b>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 18 }
            }, Layer, Layer + ".MainPriceText");

            if (currentBalance < finalPrice)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.0094791 0.0188881", AnchorMax = $"0.237041 0.0818519", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat("#8C5858FF"), Material = "assets/content/ui/ui.background.transparent.radial.psd", Command = "UI_CR_Complect default" },
                    Text = { Text = $"ВЕРНУТЬ К СТАНДАРТНЫМ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 20 }
                }, Layer, Layer + $".Default");
            }

            var foundBags = SleepingBag.FindForPlayer(player.userID, true);

            var homeWidth = 0.1;
            var homeMargin = 0.002;
            
            var leftPosition = 0.5f - (float) foundBags.Length / 2 * homeWidth - ((float) foundBags.Length - 1) / 2 * homeMargin;
            
            for (int i = 0; i < foundBags.Length; i++)
            {
                CuiHelper.DestroyUi(player, Layer + $".Zone.{i}");
                var cBag = foundBags.ElementAt(i);

                string textCd = cBag.unlockSeconds > 0 ? $"CD: {(int) cBag.unlockSeconds}S\n{cBag.niceName}" : $"RESPAWN\n{cBag.niceName}";
                if (currentBalance < finalPrice)
                    textCd = "НЕТ ДЕНЕГ";
                
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{leftPosition + i * homeWidth + i * homeMargin} 0.0188881", AnchorMax = $"{leftPosition + homeWidth + i * homeWidth + i * homeMargin} 0.0818519", OffsetMax = "0 0" },
                    Button = { FadeIn = fadeIn, Color = HexToRustFormat("#707070A6"), Material = "assets/content/ui/ui.background.transparent.radial.psd", Command = $"UI_CR_Complect customrespawn {foundBags.ElementAt(i).net.ID}" },
                    Text = { FadeIn = fadeIn, Text = textCd, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                }, Layer, Layer + $".Zone.{i}");
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Utils

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        [JsonProperty("Цвета для обозначения рекдости предмета")]
        public static List<string> RareType = new List<string>
        {
            "#2387a0",
            "#8b23a0",
            "#ba3535",
            "#eacf48"
        };
        
        private static Dictionary<ulong, int> playerBalance = new Dictionary<ulong, int>();
        
        private static string GetColor(string text, int rarity) => $"<color={RareType[rarity]}>{text}</color>";

        #endregion

        #region API

        [PluginReference] private Plugin Economics, ServerRewards, RustShop, NShop;
        
        private int API_CheckBalance(BasePlayer player)
        {
            if (config.BalanceSettings.CONF_UseEconomics)
            {
                double result = (double) Economics.Call("Balance", player.userID);
                return (int) result;
            }
            if (config.BalanceSettings.CONF_UseSR)
            {
                object result = (object) ServerRewards.Call("CheckPoints", player.userID);

                return Convert.ToInt32(result);
            }
            if (config.BalanceSettings.CONF_UseRustShop)
            {
                return (int) RustShop.Call("GetBalance", player.userID);
            }
            if (config.BalanceSettings.CONF_UseNShop)
            {
                return (int) ((float) NShop.Call("Balance", player.userID));
            }

            if (config.BalanceSettings.CONF_UseCustom)
            {
                return playerBalance[player.userID];
            }

            return 0;
        }
        
        private void API_TakeBalance(BasePlayer player, int amount)
        {
            if (config.BalanceSettings.CONF_UseEconomics)
            {
                Economics.Call("Withdraw", player.userID, (double) amount);
                return;
            }
            if (config.BalanceSettings.CONF_UseSR)
            {
                ServerRewards.Call("TakePoints", player.userID, amount);
                return;
            }
            if (config.BalanceSettings.CONF_UseRustShop)
            {
                RustShop.Call("RemoveBalance", player.userID, amount);
            }
            if (config.BalanceSettings.CONF_UseNShop)
            {
                NShop.Call("ChangeBalance", player.userID, amount);
            }

            if (config.BalanceSettings.CONF_UseCustom)
            {
                playerBalance[player.userID] -= amount;
            }

            return;
        }

        #endregion
    }
}

// --- End of file: CustomRespawn.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DemolishLimiter.cs ---
// --- Original Local Path: DemolishLimiter.cs ---

// Reference: Oxide.Ext.Rust

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{

    [Info("Demolish Limiter", "Mughisi", "1.0.1")]
    class DemolishLimiter : RustPlugin
    {

        #region Configuration Data

        private bool configChanged = false;

        // Plugin settings
        string defaultChatPrefix = "Demolisher";
        string defaultChatPrefixColor = "#008000ff";

        string chatPrefix;
        string chatPrefixColor;

        // Plugin options
        bool defaultAdminCanDemolish = true;
        bool defaultModeratorCanDemolish = false;
        bool defaultLogDemolishToConsole = true;

        bool adminCanDemolish;
        bool moderatorCanDemolish;
        bool logToConsole;
        
        // Plugin messages
        string defaultNotAllowed = "You are not allowed to demolish anything.";
        
        string notAllowed;

        #endregion

        void Loaded()
        {
            LoadConfigValues();
        }

        protected override void LoadDefaultConfig()
        {
            Log("New configuration file created.");
        }

        void LoadConfigValues()
        {
            // Plugin settings
            chatPrefix = Convert.ToString(GetConfigValue("Settings", "ChatPrefix", defaultChatPrefix));
            chatPrefixColor = Convert.ToString(GetConfigValue("Settings", "ChatPrefixColor", defaultChatPrefixColor));

            // Plugin options
            adminCanDemolish = Convert.ToBoolean(GetConfigValue("Options", "AdminsCanDemolish", defaultAdminCanDemolish));
            moderatorCanDemolish = Convert.ToBoolean(GetConfigValue("Options", "ModeratorsCanDemolish", defaultModeratorCanDemolish));
            logToConsole = Convert.ToBoolean(GetConfigValue("Options", "LogToConsole", defaultLogDemolishToConsole));

            // Plugin messages
            notAllowed = Convert.ToString(GetConfigValue("Messages", "NotAllowed", defaultNotAllowed));

            if (configChanged)
            {
                Log("Configuration file updated.");
                SaveConfig();
            }
        }
        
        object OnBuildingBlockDemolish(BuildingBlock block, BasePlayer player)
        {
            int demolisherAuthLevel = player.net.connection.authLevel;

            if ((demolisherAuthLevel == 1 && !moderatorCanDemolish) || (demolisherAuthLevel == 2 && !adminCanDemolish))
            {
                SendChatMessage(player, notAllowed);
                return true;
            }

            if (logToConsole)
                Log($"{player.displayName} has demolished a {block.blockDefinition.hierachyName} at location {block.transform.position.ToString()}.");

            return null;
        }

        #region Helper methods
        void Log(string message)
        {
            Puts("{0} : {1}", Title, message);
        }

        void SendChatMessage(BasePlayer player, string message, string arguments = null)
        {
            string chatMessage = $"<color={chatPrefixColor}>{chatPrefix}</color>: {message}";
            player?.SendConsoleCommand("chat.add", -1, string.Format(chatMessage, arguments), 1.0);
        }

        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }
            if (!data.TryGetValue(setting, out value))
            {
                value = defaultValue;
                data[setting] = value;
                configChanged = true;
            }
            return value;
        }

        void SetConfigValue(string category, string setting, object newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
                configChanged = true;
            }
            SaveConfig();
        }
        #endregion
    }

}


// --- End of file: DemolishLimiter.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HitMarkersRu.cs ---
// --- Original Local Path: HitMarkersRu.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Hit Markers", "Oleshka", "1.2.0")]
    public class HitMarkersRu : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin ImageLibrary, Notify;

        private const string Layer = "UI.HitMarkers";

        private const string HitLayer = "UI.HitMarkers.Hit";

        private const string HealthLineLayer = "UI.HitMarkers.HealthLine";

        private static HitMarkersRu _instance;

        #endregion

        #region Config

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Команды", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] Commands = { "marker", "hits" };

            [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.use)")]
            public string Permission = string.Empty;

            [JsonProperty(PropertyName = "Включить работу с Notify?")]
            public bool UseNotify = true;

            [JsonProperty(PropertyName = "Шрифты", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<int, FontConf> Fonts = new Dictionary<int, FontConf>
            {
                [0] = new FontConf
                {
                    Font = "robotocondensed-bold.ttf",
                    Permission = string.Empty
                },
                [1] = new FontConf
                {
                    Font = "robotocondensed-regular.ttf",
                    Permission = string.Empty
                },
                [2] = new FontConf
                {
                    Font = "permanentmarker.ttf",
                    Permission = string.Empty
                },
                [3] = new FontConf
                {
                    Font = "droidsansmono.ttf",
                    Permission = string.Empty
                }
            };

            [JsonProperty(PropertyName = "Минимальный размер шрифта")]
            public int MinFontSize = 8;

            [JsonProperty(PropertyName = "Максимальный размер шрифта")]
            public int MaxFontSize = 18;

            [JsonProperty(PropertyName = "Кнопки", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<BtnConf> Buttons = new List<BtnConf>
            {
                new BtnConf
                {
                    Enabled = true,
                    Title = "Текст",
                    Type = BtnType.Text,
                    Description = "<b>Цифры нанесённого урона</b> появится в центре экрана!",
                    Permission = string.Empty
                },
                new BtnConf
                {
                    Enabled = true,
                    Title = "Иконка",
                    Type = BtnType.Icon,
                    Description = "Привычная всем иконка попадания, меняет цвет при выстреле <b>в голову</b>!",
                    Permission = string.Empty
                },
                new BtnConf
                {
                    Enabled = true,
                    Title = "Полоса",
                    Type = BtnType.HealthLine,
                    Description = "Над слотами появляется полоса, показывающая <b>оставшееся</b> ХП врага.",
                    Permission = string.Empty
                },
                new BtnConf
                {
                    Enabled = true,
                    Title = "Постройки",
                    Type = BtnType.Buildings,
                    Description = "Отображение повреждений по строениям",
                    Permission = string.Empty
                }
            };

            [JsonProperty(PropertyName = "Иконка информации")]
            public string InfoIcon = "https://i.imgur.com/YIRjnIT.png";

            [JsonProperty(PropertyName = "Показывать урон по НПЦ")]
            public bool ShowNpcDamage = true;

            [JsonProperty(PropertyName = "Показывать урон по животным")]
            public bool ShowAnimalDamage;

            [JsonProperty(PropertyName = "Время удаления маркера")]
            public float DestroyTime = 0.25f;

            [JsonProperty(PropertyName = "Значения по умолчанию")]
            public DefaultValues DefaultValues = new DefaultValues
            {
                FontSize = 14,
                Buildings = false,
                FontId = 0,
                HealthLine = false,
                Icon = false,
                Text = true
            };
            
            [JsonProperty(PropertyName = "Настройка линии")]
            public LineSettings Line = new LineSettings
            {
                Show = true,
                Text = false
            };
        }

        private class LineSettings
        {
            [JsonProperty(PropertyName = "Показывать линию?")]
            public bool Show;

            [JsonProperty(PropertyName = "Показывать текст?")]
            public bool Text;
        }

        private class DefaultValues
        {
            [JsonProperty(PropertyName = "ID шрифта")]
            public int FontId;

            [JsonProperty(PropertyName = "Размер шрифта")]
            public int FontSize;

            [JsonProperty(PropertyName = "Текст")] public bool Text;

            [JsonProperty(PropertyName = "Иконка")] public bool Icon;

            [JsonProperty(PropertyName = "Полоса ХП ")]
            public bool HealthLine;

            [JsonProperty(PropertyName = "Урон по строениям")]
            public bool Buildings;
        }

        private class BtnConf
        {
            [JsonProperty(PropertyName = "Включено")]
            public bool Enabled;

            [JsonProperty(PropertyName = "Название")] public string Title;

            [JsonProperty(PropertyName = "Тип")] [JsonConverter(typeof(StringEnumConverter))]
            public BtnType Type;

            [JsonProperty(PropertyName = "Описание")]
            public string Description;

            [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.text)")]
            public string Permission;
        }

        private enum BtnType
        {
            Text,
            Icon,
            HealthLine,
            Buildings
        }

        private class FontConf
        {
            [JsonProperty(PropertyName = "Шрифт")] public string Font;

            [JsonProperty(PropertyName = "Разрешение (например: hitmarkersru.font)")]
            public string Permission;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch (Exception ex)
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
                Debug.LogException(ex);
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region Data

        private static PluginData _data;

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();
        }

        private class PluginData
        {
            [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<ulong, PlayerData> Players = new Dictionary<ulong, PlayerData>();
        }

        private class PlayerData
        {
            [JsonProperty(PropertyName = "Font ID")]
            public int FontId;

            [JsonProperty(PropertyName = "Font Size")]
            public int FontSize;

            [JsonProperty(PropertyName = "Text")] public bool Text;

            [JsonProperty(PropertyName = "Icon")] public bool Icon;

            [JsonProperty(PropertyName = "Health Line")]
            public bool HealthLine;

            [JsonProperty(PropertyName = "Buildings")]
            public bool Buildings;

            public static PlayerData GetOrAdd(BasePlayer player)
            {
                return GetOrAdd(player.userID);
            }

            public static PlayerData GetOrAdd(ulong userId)
            {
                if (!_data.Players.ContainsKey(userId))
                    _data.Players.Add(userId, new PlayerData
                    {
                        FontSize = _config.DefaultValues.FontSize,
                        FontId = _config.DefaultValues.FontId,
                        Text = _config.DefaultValues.Text,
                        Buildings = _config.DefaultValues.Buildings,
                        Icon = _config.DefaultValues.Icon,
                        HealthLine = _config.DefaultValues.HealthLine
                    });

                return _data.Players[userId];
            }

            public bool GetValue(BtnType type)
            {
                switch (type)
                {
                    case BtnType.Text:
                        return Text;
                    case BtnType.Icon:
                        return Icon;
                    case BtnType.HealthLine:
                        return HealthLine;
                    case BtnType.Buildings:
                        return Buildings;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            public void SetValue(BtnType type, bool newValue)
            {
                switch (type)
                {
                    case BtnType.Text:
                        Text = newValue;
                        break;
                    case BtnType.Icon:
                        Icon = newValue;
                        break;
                    case BtnType.HealthLine:
                        HealthLine = newValue;
                        break;
                    case BtnType.Buildings:
                        Buildings = newValue;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            _instance = this;

            LoadData();

            RegisterPermissions();

            ImageLibrary?.Call("AddImage", _config.InfoIcon, _config.InfoIcon);

            AddCovalenceCommand(_config.Commands, nameof(CmdOpenMarkers));
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, Layer);

            _markerByPlayer.Values.ToList().ForEach(marker =>
            {
                if (marker != null)
                    marker.Kill();
            });

            SaveData();

            _instance = null;
            _data = null;
            _config = null;
        }


        private void OnEntityTakeDamage(BuildingBlock block, HitInfo info)
        {
            if (block == null || info == null || info.damageTypes.Total() < 1) return;

            var player = info.InitiatorPlayer;
            if (player == null) return;

            var marker = GetMarker(player);
            if (marker == null) return;

            if (PlayerData.GetOrAdd(player).Buildings)
                NextTick(() =>
                {
                    if (block != null && !block.IsDestroyed)
                        marker.ShowHit(block, info);
                });
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null || attacker.IsNpc || info == null) return;

            var target = info.HitEntity as BaseCombatEntity;
            if (target == null || target is BaseCorpse || target is BuildingBlock ||
                !_config.ShowAnimalDamage && target is BaseAnimalNPC ||
                !_config.ShowNpcDamage &&
                (target is BaseNpc || target is BasePlayer && (target as BasePlayer).IsNpc)) return;

            NextTick(() =>
            {
                if (target != null && !target.IsDestroyed)
                    GetOrAddMarker(attacker).ShowHit(target, info);
            });
        }

        #endregion

        #region Commands

        private void CmdOpenMarkers(IPlayer cov, string command, string[] args)
        {
            var player = cov?.Object as BasePlayer;
            if (player == null) return;

            if (!string.IsNullOrEmpty(_config.Permission) &&
                !permission.UserHasPermission(player.UserIDString, _config.Permission))
            {
                SendNotify(player, NoPermission, 1);
                return;
            }

            MainUi(player, true);
        }

        [ConsoleCommand("UI_Markers")]
        private void CmdConsoleMarkers(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player == null || !arg.HasArgs()) return;

            switch (arg.Args[0])
            {
                case "settype":
                {
                    BtnType type;
                    if (!arg.HasArgs(2) || !Enum.TryParse(arg.Args[1], out type)) return;

                    var data = PlayerData.GetOrAdd(player);
                    if (data == null) return;

                    var perm = _config.Buttons.Find(x => x.Type == type);
                    if (perm != null)
                        if (!string.IsNullOrEmpty(perm.Permission) &&
                            !permission.UserHasPermission(player.UserIDString, perm.Permission))
                        {
                            SendNotify(player, NoPermission, 1);
                            return;
                        }

                    data.SetValue(type, !data.GetValue(type));

                    MainUi(player);
                    break;
                }

                case "setsize":
                {
                    int fontSize;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out fontSize)) return;

                    var data = PlayerData.GetOrAdd(player);
                    if (data == null) return;

                    data.FontSize = fontSize;

                    MainUi(player);
                    break;
                }

                case "setfont":
                {
                    int fontId;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out fontId)) return;

                    var data = PlayerData.GetOrAdd(player);
                    if (data == null) return;

                    data.FontId = fontId;

                    MainUi(player);
                    break;
                }

                case "info":
                {
                    int index;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out index) || index < 0 ||
                        _config.Buttons.Count <= index) return;

                    InfoUi(player, _config.Buttons[index].Description);
                    break;
                }
            }
        }

        #endregion

        #region Interface

        private void MainUi(BasePlayer player, bool first = false)
        {
            var data = PlayerData.GetOrAdd(player);
            if (data == null) return;

            float xSwitch;
            float ySwitch;
            float width;
            float height;
            float margin;

            var container = new CuiElementContainer();

            #region Background

            if (first)
            {
                CuiHelper.DestroyUi(player, Layer);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image =
                    {
                        Color = "0 0 0 0.9",
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    },
                    CursorEnabled = true
                }, "Overlay", Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "" },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Close = Layer
                    }
                }, Layer);
            }

            #endregion

            #region Main

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                    OffsetMin = "-300 -190",
                    OffsetMax = "300 190"
                },
                Image =
                {
                    Color = "0.50 0.47 0.41 0.5"
                }
            }, Layer, Layer + ".Main");

            #region Header

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "1 1",
                    OffsetMin = "0 -50",
                    OffsetMax = "0 0"
                },
                Image = { Color = "0.50 0.47 0.41 0.6" }
            }, Layer + ".Main", Layer + ".Header");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "30 0",
                    OffsetMax = "0 0"
                },
                Text =
                {
                    Text = Msg(player, TitleMenu),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 14,
                    Color = HexToCuiColor("#FFFFFF")
                }
            }, Layer + ".Header");

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = "-50 -37.5",
                    OffsetMax = "-25 -12.5"
                },
                Text =
                {
                    Text = Msg(player, CloseButton),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 10,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Close = Layer,
                    Color = "0.50 0.47 0.41 1"
                }
            }, Layer + ".Header");

            #endregion

            #region Preview

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                    OffsetMin = "95 -255",
                    OffsetMax = "265 -85"
                },
                Image =
                {
                    Color = "0.50 0.47 0.40 0.6"
                }
            }, Layer + ".Main", Layer + ".Preview");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 0",
                    OffsetMin = "0 0", OffsetMax = "0 18"
                },
                Text =
                {
                    Text = Msg(player, LooksNow),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 0.4"
                }
            }, Layer + ".Preview");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text =
                {
                    Text = Msg(player, PreviewTitle),
                    Align = TextAnchor.MiddleCenter,
                    Font = $"{_config.Fonts[data.FontId].Font}",
                    FontSize = data.FontSize,
                    Color = "1 1 1 0.7"
                }
            }, Layer + ".Preview");

            #endregion

            #region Fonts

            xSwitch = -265f;
            ySwitch = -85f;
            margin = 10f;
            width = 80f;
            height = 80f;

            var i = 1;
            foreach (var fontConf in _config.Fonts)
            {
                var selected = fontConf.Key == data.FontId;

                container.Add(new CuiPanel
                {
                    RectTransform =
                    {
                        AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                        OffsetMin = $"{xSwitch} {ySwitch - height}",
                        OffsetMax = $"{xSwitch + width} {ySwitch}"
                    },
                    Image =
                    {
                        Color = selected ? HexToCuiColor("#4B68FF") : "0.50 0.47 0.40 0.6"
                    }
                }, Layer + ".Main", Layer + $".Font.{fontConf.Key}");

                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0.5", AnchorMax = "1 1",
                        OffsetMin = "0 2", OffsetMax = "0 0"
                    },
                    Text =
                    {
                        Text = Msg(player, TextTitle),
                        Align = TextAnchor.LowerCenter,
                        Font = fontConf.Value.Font,
                        FontSize = 14,
                        Color = selected ? HexToCuiColor("#FFFFFF") : HexToCuiColor("#4B68FF")
                    }
                }, Layer + $".Font.{fontConf.Key}");

                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0", AnchorMax = "1 0.5",
                        OffsetMin = "0", OffsetMax = "0 -2"
                    },
                    Text =
                    {
                        Text = Msg(player, FontTitle, i),
                        Align = TextAnchor.UpperCenter,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 14,
                        Color = HexToCuiColor("#FFFFFF")
                    }
                }, Layer + $".Font.{fontConf.Key}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "" },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Command = $"UI_Markers setfont {fontConf.Key}"
                    }
                }, Layer + $".Font.{fontConf.Key}");

                xSwitch += margin + width;
                i++;
            }

            #endregion

            #region Font Size

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                    OffsetMin = "-265 -255",
                    OffsetMax = "85 -175"
                },
                Image =
                {
                    Color = "0.50 0.47 0.40 0.6"
                }
            }, Layer + ".Main", Layer + ".FontSize");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0.5", AnchorMax = "1 1",
                    OffsetMin = "15 0", OffsetMax = "0 0"
                },
                Text =
                {
                    Text = Msg(player, FontIncreaseTitle),
                    Align = TextAnchor.LowerLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 1"
                }
            }, Layer + ".FontSize");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0.5", AnchorMax = "1 0.5",
                    OffsetMin = "280 -25",
                    OffsetMax = "0 0"
                },
                Text =
                {
                    Text = Msg(player, FontSizeFormat, data.FontSize),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 14,
                    Color = "1 1 1 1"
                }
            }, Layer + ".FontSize");

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 0.5", AnchorMax = "0 0.5",
                    OffsetMin = "15 -15",
                    OffsetMax = "265 -10"
                },
                Image =
                {
                    Color = "0.50 0.47 0.41 0.6"
                }
            }, Layer + ".FontSize", Layer + ".FontSize.Line");

            width = 250;

            var steps = _config.MaxFontSize - _config.MinFontSize;

            var progress = (float)(data.FontSize - _config.MinFontSize) / steps;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = $"{progress} 0.95" },
                Image =
                {
                    Color = HexToCuiColor("#4B68FF")
                }
            }, Layer + ".FontSize.Line", Layer + ".FontSize.Line.Finish");

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "1 0.5", AnchorMax = "1 0.5",
                    OffsetMin = "-5 -5", OffsetMax = "5 5"
                },
                Image =
                {
                    Color = "1 1 1 1"
                }
            }, Layer + ".FontSize.Line.Finish");

            var size = width / steps;

            xSwitch = 0;
            for (var j = _config.MinFontSize; j <= _config.MaxFontSize; j++)
            {
                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0", AnchorMax = "0 1",
                        OffsetMin = $"{xSwitch} 0",
                        OffsetMax = $"{xSwitch + size} 0"
                    },
                    Text =
                    {
                        Text = ""
                    },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Command = $"UI_Markers setsize {j}"
                    }
                }, Layer + ".FontSize.Line");

                xSwitch += size;
            }

            #endregion

            #region Buttons

            width = 530;

            var buttons = _config.Buttons.FindAll(x => x.Enabled);

            margin = 10f;

            size = (width - (buttons.Count - 1) * margin) / buttons.Count;

            xSwitch = -265f;

            for (i = 0; i < buttons.Count; i++)
            {
                var btn = buttons[i];

                container.Add(new CuiPanel
                {
                    RectTransform =
                    {
                        AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                        OffsetMin = $"{xSwitch} -325",
                        OffsetMax = $"{xSwitch + size} -265"
                    },
                    Image =
                    {
                        Color = "0.50 0.47 0.40 0.6"
                    }
                }, Layer + ".Main", Layer + $".Btn.{i}");

                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0.5", AnchorMax = "1 1",
                        OffsetMin = "0 0", OffsetMax = "0 0"
                    },
                    Text =
                    {
                        Text = $"{btn.Title}",
                        Align = TextAnchor.LowerCenter,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 12,
                        Color = "1 1 1 1"
                    }
                }, Layer + $".Btn.{i}");

                SwitchUi(ref container, Layer + $".Btn.{i}", data.GetValue(btn.Type), $"UI_Markers settype {btn.Type}");

                #region Info

                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "1 0", AnchorMax = "1 0",
                        OffsetMin = "-40 16",
                        OffsetMax = "0 32"
                    },
                    Text =
                    {
                        Text = Msg(player, InfoTitle),
                        Align = TextAnchor.MiddleLeft,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 12,
                        Color = "1 1 1 0.4"
                    }
                }, Layer + $".Btn.{i}");

                if (ImageLibrary)
                    container.Add(new CuiElement
                    {
                        Parent = Layer + $".Btn.{i}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = ImageLibrary.Call<string>("GetImage", _config.InfoIcon) },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "1 0", AnchorMax = "1 0",
                                OffsetMin = "-52 18", OffsetMax = "-40 30"
                            }
                        }
                    });

                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "1 0", AnchorMax = "1 0",
                        OffsetMin = "-52 18", OffsetMax = "0 30"
                    },
                    Text = { Text = "" },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Command = $"UI_Markers info {_config.Buttons.IndexOf(btn)}"
                    }
                }, Layer + $".Btn.{i}");

                #endregion

                xSwitch += margin + size;
            }

            #endregion

            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main");
            CuiHelper.AddUi(player, container);
        }

        private void SwitchUi(ref CuiElementContainer container, string parent, bool value, string command)
        {
            var guid = CuiHelper.GetGuid();

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "0 0",
                    OffsetMin = "18 16",
                    OffsetMax = "56 28"
                },
                Image =
                {
                    Color = "0.50 0.47 0.41 0.6"
                }
            }, parent, guid);

            if (value)
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "1 1" },
                    Image =
                    {
                        Color = HexToCuiColor("#4B68FF")
                    }
                }, guid);
            else
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.5 1" },
                    Image =
                    {
                        Color = HexToCuiColor("#FFFFFF", 40)
                    }
                }, guid);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = "" },
                Button =
                {
                    Color = "0 0 0 0",
                    Command = $"{command}"
                }
            }, guid);
        }

        private void InfoUi(BasePlayer player, string text)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 0", AnchorMax = "0.5 0",
                    OffsetMin = "-200 0", OffsetMax = "200 130"
                },
                Text =
                {
                    Text = $"{text}",
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 14,
                    Color = "1 1 1 0.5"
                }
            }, Layer, Layer + ".Info");

            CuiHelper.DestroyUi(player, Layer + ".Info");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Utils

        private void RegisterPermissions()
        {
            foreach (var font in _config.Fonts.Values.Where(check =>
                !string.IsNullOrEmpty(check.Permission) && !permission.PermissionExists(check.Permission)))
                permission.RegisterPermission(font.Permission, this);

            _config.Buttons.ForEach(btn =>
            {
                if (!string.IsNullOrEmpty(btn.Permission) && !permission.PermissionExists(btn.Permission))
                    permission.RegisterPermission(btn.Permission, this);
            });

            if (!string.IsNullOrEmpty(_config.Permission) && !permission.PermissionExists(_config.Permission))
                permission.RegisterPermission(_config.Permission, this);
        }

        private static string HexToCuiColor(string hex, float alpha = 100)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFF";

            var str = hex.Trim('#');
            if (str.Length != 6) throw new Exception(hex);
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

            return $"{(double)r / 255} {(double)g / 255} {(double)b / 255} {alpha / 100f}";
        }

        private static bool IsTeammates(ulong player, ulong friend)
        {
            return RelationshipManager.ServerInstance.FindPlayersTeam(player)?.members?.Contains(friend) == true;
        }

        private static Vector2 GetRandomTextPosition()
        {
            var x = (float)Random.Range(55, 63) / 100;
            var y = (float)Random.Range(44, 46) / 100;

            return new Vector2(x, y);
        }

        private static string GetGradientColor(int count, int max)
        {
            if (count > max)
                count = max;
            var n = max > 0 ? (float)ColorsGradientDB.Length / max : 0;
            var index = (int)(count * n);
            if (index > 0) index--;
            return ColorsGradientDB[index];
        }

        private static readonly string[] ColorsGradientDB =
        {
            "0.2000 0.8000 0.2000 1.0000",
            "0.2471 0.7922 0.1961 1.0000",
            "0.2824 0.7843 0.1922 1.0000",
            "0.3176 0.7725 0.1843 1.0000",
            "0.3451 0.7647 0.1804 1.0000",
            "0.3686 0.7569 0.1765 1.0000",
            "0.3922 0.7490 0.1725 1.0000",
            "0.4118 0.7412 0.1686 1.0000",
            "0.4314 0.7333 0.1647 1.0000",
            "0.4471 0.7216 0.1608 1.0000",
            "0.4667 0.7137 0.1569 1.0000",
            "0.4784 0.7059 0.1529 1.0000",
            "0.4941 0.6980 0.1490 1.0000",
            "0.5098 0.6902 0.1412 1.0000",
            "0.5216 0.6824 0.1373 1.0000",
            "0.5333 0.6706 0.1333 1.0000",
            "0.5451 0.6627 0.1294 1.0000",
            "0.5569 0.6549 0.1255 1.0000",
            "0.5647 0.6471 0.1216 1.0000",
            "0.5765 0.6392 0.1176 1.0000",
            "0.5843 0.6314 0.1137 1.0000",
            "0.5922 0.6235 0.1137 1.0000",
            "0.6039 0.6118 0.1098 1.0000",
            "0.6118 0.6039 0.1059 1.0000",
            "0.6196 0.5961 0.1020 1.0000",
            "0.6275 0.5882 0.0980 1.0000",
            "0.6314 0.5804 0.0941 1.0000",
            "0.6392 0.5725 0.0902 1.0000",
            "0.6471 0.5647 0.0863 1.0000",
            "0.6510 0.5569 0.0824 1.0000",
            "0.6588 0.5451 0.0784 1.0000",
            "0.6627 0.5373 0.0784 1.0000",
            "0.6667 0.5294 0.0745 1.0000",
            "0.6745 0.5216 0.0706 1.0000",
            "0.6784 0.5137 0.0667 1.0000",
            "0.6824 0.5059 0.0627 1.0000",
            "0.6863 0.4980 0.0588 1.0000",
            "0.6902 0.4902 0.0588 1.0000",
            "0.6941 0.4824 0.0549 1.0000",
            "0.6980 0.4745 0.0510 1.0000",
            "0.7020 0.4667 0.0471 1.0000",
            "0.7020 0.4588 0.0471 1.0000",
            "0.7059 0.4471 0.0431 1.0000",
            "0.7098 0.4392 0.0392 1.0000",
            "0.7098 0.4314 0.0392 1.0000",
            "0.7137 0.4235 0.0353 1.0000",
            "0.7176 0.4157 0.0314 1.0000",
            "0.7176 0.4078 0.0314 1.0000",
            "0.7216 0.4000 0.0275 1.0000",
            "0.7216 0.3922 0.0275 1.0000",
            "0.7216 0.3843 0.0235 1.0000",
            "0.7255 0.3765 0.0235 1.0000",
            "0.7255 0.3686 0.0196 1.0000",
            "0.7255 0.3608 0.0196 1.0000",
            "0.7255 0.3529 0.0196 1.0000",
            "0.7294 0.3451 0.0157 1.0000",
            "0.7294 0.3373 0.0157 1.0000",
            "0.7294 0.3294 0.0157 1.0000",
            "0.7294 0.3216 0.0118 1.0000",
            "0.7294 0.3137 0.0118 1.0000",
            "0.7294 0.3059 0.0118 1.0000",
            "0.7294 0.2980 0.0118 1.0000",
            "0.7294 0.2902 0.0078 1.0000",
            "0.7255 0.2824 0.0078 1.0000",
            "0.7255 0.2745 0.0078 1.0000",
            "0.7255 0.2667 0.0078 1.0000",
            "0.7255 0.2588 0.0078 1.0000",
            "0.7255 0.2510 0.0078 1.0000",
            "0.7216 0.2431 0.0078 1.0000",
            "0.7216 0.2353 0.0039 1.0000",
            "0.7176 0.2275 0.0039 1.0000",
            "0.7176 0.2196 0.0039 1.0000",
            "0.7176 0.2118 0.0039 1.0000",
            "0.7137 0.2039 0.0039 1.0000",
            "0.7137 0.1961 0.0039 1.0000",
            "0.7098 0.1882 0.0039 1.0000",
            "0.7098 0.1804 0.0039 1.0000",
            "0.7059 0.1725 0.0039 1.0000",
            "0.7020 0.1647 0.0039 1.0000",
            "0.7020 0.1569 0.0039 1.0000",
            "0.6980 0.1490 0.0039 1.0000",
            "0.6941 0.1412 0.0039 1.0000",
            "0.6941 0.1333 0.0039 1.0000",
            "0.6902 0.1255 0.0039 1.0000",
            "0.6863 0.1176 0.0039 1.0000",
            "0.6824 0.1098 0.0039 1.0000",
            "0.6784 0.1020 0.0039 1.0000",
            "0.6784 0.0941 0.0039 1.0000",
            "0.6745 0.0863 0.0039 1.0000",
            "0.6706 0.0784 0.0039 1.0000",
            "0.6667 0.0706 0.0039 1.0000",
            "0.6627 0.0627 0.0039 1.0000",
            "0.6588 0.0549 0.0039 1.0000",
            "0.6549 0.0431 0.0039 1.0000",
            "0.6510 0.0353 0.0000 1.0000",
            "0.6471 0.0275 0.0000 1.0000",
            "0.6392 0.0196 0.0000 1.0000",
            "0.6353 0.0118 0.0000 1.0000",
            "0.6314 0.0039 0.0000 1.0000",
            "0.6275 0.0000 0.0000 1.0000"
        };

        #endregion

        #region Component

        private readonly Dictionary<BasePlayer, MarkerComponent> _markerByPlayer =
            new Dictionary<BasePlayer, MarkerComponent>();

        private MarkerComponent GetMarker(BasePlayer player)
        {
            MarkerComponent marker;
            return _markerByPlayer.TryGetValue(player, out marker) && marker != null ? marker : null;
        }

        private MarkerComponent GetOrAddMarker(BasePlayer player)
        {
            MarkerComponent marker;
            if (_markerByPlayer.TryGetValue(player, out marker) && marker != null) return marker;

            return player.gameObject.AddComponent<MarkerComponent>();
        }

        private class MarkerComponent : FacepunchBehaviour
        {
            private BasePlayer _player;

            private PlayerData _playerData;

            private void Awake()
            {
                _player = GetComponent<BasePlayer>();

                _playerData = PlayerData.GetOrAdd(_player);

                _instance._markerByPlayer[_player] = this;
            }

            public void ShowHit(BaseCombatEntity target, HitInfo info)
            {
                if (_playerData.HealthLine) ShowLine(BtnType.HealthLine, target, info);
                if (_playerData.Text) ShowLine(BtnType.Text, target, info);
                if (_playerData.Icon) ShowLine(BtnType.Icon, target, info);
            }

            private void ShowLine(BtnType type, BaseCombatEntity target, HitInfo info)
            {
                var container = new CuiElementContainer();

                switch (type)
                {
                    case BtnType.Text:
                    {
                        var pos = GetRandomTextPosition();
                        var textDamage = info.damageTypes.Total().ToString("F0");

                        if (Mathf.FloorToInt(info.damageTypes.Total()) == 0)
                            return;

                        var targetPlayer = target as BasePlayer;
                        if (targetPlayer != null)
                        {
                            if (info.isHeadshot)
                                textDamage = _instance.Msg(_player, FormatHeadshotTitle, textDamage);

                            if (targetPlayer.IsWounded())
                            {
                                textDamage = _instance.Msg(_player, FormatFellTitle);
                                if (info.isHeadshot)
                                    textDamage += _instance.Msg(_player, FormatFellHeadshotTitle);
                            }

                            if (IsTeammates(_player.userID, targetPlayer.userID))
                                textDamage = _instance.Msg(_player, FormatFriendTitle);
                        }

                        var hitId = CuiHelper.GetGuid();
                        container.Add(new CuiElement
                        {
                            Name = hitId,
                            Parent = "Hud",
                            FadeOut = 0.5f,
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"{textDamage}",
                                    Color = "1 1 1 1",
                                    Font = _config.Fonts[_playerData.FontId].Font,
                                    FontSize = _playerData.FontSize,
                                    Align = TextAnchor.MiddleCenter
                                },
                                new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.1 0.1" },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"{pos.x} {pos.y}", AnchorMax = $"{pos.x} {pos.y}",
                                    OffsetMin = " 40 -25", OffsetMax = "40 25"
                                }
                            }
                        });

                        CuiHelper.AddUi(_player, container);
                        StartCoroutine(DestroyHit(hitId));
                        break;
                    }

                    case BtnType.Icon:
                    {
                        var hitId = CuiHelper.GetGuid();

                        var color = "1 1 1 0.5";
                        var image = "assets/icons/close.png";
                        float margin = 10;

                        var targetPlayer = target as BasePlayer;
                        if (targetPlayer)
                        {
                            if (targetPlayer.IsWounded())
                            {
                                margin = 20;
                                image = "assets/icons/fall.png";
                            }

                            if (targetPlayer.IsWounded() || targetPlayer.IsDead())
                                color = "1 0.207745 0.20771 0.5";
                        }

                        if (info.isHeadshot) color = "1 0.2 0.2 0.5";

                        container.Add(new CuiButton
                        {
                            FadeOut = 0.3f,
                            RectTransform =
                            {
                                AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-{margin} -{margin}",
                                OffsetMax = $"{margin} {margin}"
                            },
                            Button = { Color = color, Sprite = image },
                            Text = { Text = "" }
                        }, "Hud", hitId);

                        CuiHelper.AddUi(_player, container);
                        CuiHelper.DestroyUi(_player, hitId);
                        break;
                    }

                    case BtnType.HealthLine:
                    {
                        var curHealth = target.health;
                        var maxHealth = target._maxHealth;

                        var block = target as BuildingBlock;
                        if (block != null)
                        {
                            var curGrade = block.currentGrade;
                            if (curGrade == null) return;

                            maxHealth = curGrade.maxHealth;
                        }

                        var color = _config.Line.Show ? GetGradientColor((int)curHealth, (int)maxHealth) : "0 0 0 0";
                        var decreaseLength = (180.5f + 199.5f) / 2f * (curHealth / maxHealth);

                        container.Add(new CuiPanel
                        {
                            FadeOut = 0.5f,
                            RectTransform =
                            {
                                AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = $"{-10 - decreaseLength} 80",
                                OffsetMax = $"{-9 + decreaseLength} 85"
                            },
                            Image = { Color = color }
                        }, "Hud", HealthLineLayer);

                        if (_config.Line.Text)
                            container.Add(new CuiElement
                            {
                                Parent = HealthLineLayer,
                                FadeOut = 0.5f,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"{(maxHealth - curHealth):F0}",
                                        Color = "1 1 1 1",
                                        Font = _config.Fonts[_playerData.FontId].Font,
                                        FontSize = _playerData.FontSize,
                                        Align = TextAnchor.LowerCenter
                                    },
                                    new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.15500772 0.1550507712" },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1", AnchorMax = "1 1",
                                        OffsetMin = "0 0", OffsetMax = "0 30"
                                    }
                                }
                            });


                        DestroyHealthLine();
                        CuiHelper.AddUi(_player, container);

                        Invoke(DestroyHealthLine, _config.DestroyTime);
                        break;
                    }
                }
            }

            #region Destroy Hit

            public void DestroyHit()
            {
                CancelInvoke(DestroyHit);

                CuiHelper.DestroyUi(_player, HitLayer);
            }

            public void DestroyHealthLine()
            {
                CancelInvoke(DestroyHealthLine);

                CuiHelper.DestroyUi(_player, HealthLineLayer);
            }

            public IEnumerator DestroyHit(string id, float delay = 0.5f)
            {
                yield return CoroutineEx.waitForSeconds(delay);

                CuiHelper.DestroyUi(_player, id);
            }

            #endregion

            private void OnDestroy()
            {
                _instance?._markerByPlayer.Remove(_player);
            }

            public void Kill()
            {
                Destroy(this);
            }
        }

        #endregion

        #region Lang

        private const string
            InfoTitle = "InfoTitle",
            FontSizeFormat = "FontSizeFormat",
            FontIncreaseTitle = "FontIncreaseTitle",
            FontTitle = "FontTitle",
            TextTitle = "TextTitle",
            PreviewTitle = "PreviewTitle",
            LooksNow = "LooksNow",
            FormatFriendTitle = "FormatFriendTitle",
            FormatFellHeadshotTitle = "FormatFellHeadshotTitle",
            FormatFellTitle = "FormatFellTitle",
            FormatHeadshotTitle = "FormatHeadshotTitle",
            NoPermission = "NoPermission",
            CloseButton = "CloseButton",
            TitleMenu = "TitleMenu";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [NoPermission] = "You don't have permission to use this command!",
                [CloseButton] = "✕",
                [TitleMenu] = "Hit Markers",
                [FormatHeadshotTitle] = "<color=#DC143C>{0}</color>",
                [FormatFellTitle] = "<color=#DC143C>FELL</color>",
                [FormatFellHeadshotTitle] = " <color=#DC143C>HEADSHOT</color>",
                [FormatFriendTitle] = "<color=#32915a>FRIEND</color>",
                [LooksNow] = "What it looks like now",
                [PreviewTitle] = "-90",
                [TextTitle] = "TEXT",
                [FontTitle] = "Font #{0}",
                [FontIncreaseTitle] = "Increase the font size",
                [FontSizeFormat] = "{0}px",
                [InfoTitle] = "Info"
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [NoPermission] = "У вас нет необходимого разрешения",
                [CloseButton] = "✕",
                [TitleMenu] = "Хит Маркеры",
                [FormatHeadshotTitle] = "<color=#DC143C>{0}</color>",
                [FormatFellTitle] = "<color=#DC143C>УПАЛ</color>",
                [FormatFellHeadshotTitle] = " <color=#DC143C>ГОЛОВА</color>",
                [FormatFriendTitle] = "<color=#32915a>ДУГ</color>",
                [LooksNow] = "Как это выглядит сейчас",
                [PreviewTitle] = "-90",
                [TextTitle] = "ТЕКСТ",
                [FontTitle] = "Шрифт #{0}",
                [FontIncreaseTitle] = "Увелечение размера шрифта",
                [FontSizeFormat] = "{0}px",
                [InfoTitle] = "Инфо"
            }, this, "ru");
        }

        private string Msg(string key, string userid = null, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, userid), obj);
        }

        private string Msg(BasePlayer player, string key, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, player.UserIDString), obj);
        }

        private void Reply(BasePlayer player, string key, params object[] obj)
        {
            SendReply(player, Msg(player, key, obj));
        }

        private void SendNotify(BasePlayer player, string key, int type, params object[] obj)
        {
            if (Notify && _config.UseNotify)
                Notify?.Call("SendNotify", player, type, Msg(player, key, obj));
            else
                Reply(player, key, obj);
        }

        #endregion
    }
}

// --- End of file: HitMarkersRu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Scoreboards.cs ---
// --- Original Local Path: Scoreboards.cs ---

using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Scoreboards", "LaserHydra", "1.0.0", ResourceId = 0)]
    [Description("Allows you to create Scoreboards and plugins to insert data")]
    class Scoreboards : RustPlugin
    {
        static Scoreboards Instance;
        static ScoreboardData Data;

        #region Config Variables

        static string AnchorMin;
        static string AnchorMax;

        static string BackgroundColor;

        static string HeaderColor;
        static string TitleColor;
        static string ContentColor;

        #endregion

        #region Classes

        public class ScoreboardData
        {
            public string ActiveScoreboard = string.Empty;
            public List<Scoreboard> All = new List<Scoreboard>();
        }

        public class Scoreboard
        {
            public static Scoreboard Find(string Title) => Data.All.Find((s) => s.Title == Title);

            public string Title;
            public string Description;
            internal bool Active => Data.ActiveScoreboard == Title;

            internal KeyValuePair<string, string>[] Entries = new KeyValuePair<string, string>[0];

            public override int GetHashCode() => Title.GetHashCode();

            public void Remove() => Data.All.Remove(this);

            public void SetActive() => SetActiveScoreboard(this);

            public void SetEntries(KeyValuePair<string, string>[] Entries)
            {
                this.Entries = Entries;
                Instance.ScoreboardUpdated(this);
            }

            public static void SetActiveScoreboard(Scoreboard scoreboard)
            {
                Data.ActiveScoreboard = scoreboard.Title;
                Instance.ActiveScoreboardChanged(scoreboard);
            }

            public static Scoreboard GetActiveScoreboard() => Data.All.Find((s) => s.Active);

            public static void AddScoreboard(Scoreboard scoreboard)
            {
                if (!Data.All.Contains(scoreboard))
                {
                    Data.All.Add(scoreboard);
                    Instance.WriteData(Data);
                }
            }
        }

        #endregion

        #region API

        void UpdateScoreboard(string ScoreboardTitle, KeyValuePair<string, string>[] Entries)
        {
            var scoreboard = Scoreboard.Find(ScoreboardTitle);

            if (scoreboard == null)
                return;

            scoreboard.SetEntries(Entries);
        }

        void CreateScoreboard(string ScoreboardTitle, string ScoreboardDescription, KeyValuePair<string, string>[] Entries)
        {
            if (Scoreboard.Find(ScoreboardTitle) != null)
                return;

            Scoreboard.AddScoreboard(new Scoreboard { Title = ScoreboardTitle, Description = ScoreboardDescription, Entries = Entries.Take(10).ToArray() });
        }

        void RemoveScoreboard(string ScoreboardTitle)
        {
            var scoreboard = Scoreboard.Find(ScoreboardTitle);

            if (scoreboard == null)
                return;

            scoreboard.Remove();
        }

        #endregion

        #region Scoreboards

        void ScoreboardUpdated(Scoreboard scoreboard)
        {
            WriteData(Data);

            if (scoreboard.Active)
                UpdateScoreboardUI();
        }

        void ActiveScoreboardChanged(Scoreboard scoreboard)
        {
            UpdateScoreboardUI();
            WriteData(Data);
        }

        void UpdateScoreboardUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DrawScoreboardUI(player);
        }

        void DrawScoreboardUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Scoreboard");

            var cui = GetCUI();
            
            if (cui != null)
                CuiHelper.AddUi(player, cui);
        }

        static CuiElementContainer GetCUI()
        {
            var activeScoreboard = Scoreboard.GetActiveScoreboard();

            if (activeScoreboard == null)
                return null;

            CuiElementContainer elements = new CuiElementContainer();

            elements.Add(new CuiPanel
            {
                Image =
                {
                    Color = BackgroundColor
                },
                RectTransform =
                {
                    AnchorMin = AnchorMin,
                    AnchorMax = AnchorMax
                }
            }, "Hud.Under", "Scoreboard");

            elements.Add(new CuiElement
            {
                Name = "Header",
                Parent = "Scoreboard",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = "Scoreboard",
                        Align = TextAnchor.LowerCenter,
                        FontSize = 28,
                        Color = HeaderColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.06372549 0.8822171",
                        AnchorMax = "0.9411765 0.9676675"
                    }
                }
            });

            elements.Add(new CuiElement
            {
                Name = "Title",
                Parent = "Scoreboard",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = activeScoreboard.Title,
                        Align = TextAnchor.UpperCenter,
                        FontSize = 18,
                        Color = TitleColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.06372549 0.8337182",
                        AnchorMax = "0.9411765 0.8960739"
                    }
                }
            });

            elements.Add(new CuiElement
            {
                Name = "Contents",
                Parent = "Scoreboard",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = string.Join("\n", activeScoreboard.Entries.Select((kvp) => $"{kvp.Key}: {kvp.Value}").ToArray()),
                        Align = TextAnchor.UpperCenter,
                        FontSize = 18,
                        Color = ContentColor
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.06372549 0.0277136",
                        AnchorMax = "0.9411765 0.8337182"
                    }
                }
            });

            return elements;
        }

        #endregion

        #region Commands

        [ChatCommand("scoreboard")]
        void cmdScoreboard(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "scoreboards.admin"))
            {
                SendReply(player, LangMsg("No Permission", player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, "/scoreboard <select|disable|list>");
                return;
            }

            switch (args[0].ToLower())
            {
                case "select":
                    if (args.Length != 2)
                    {
                        SendReply(player, "Syntax: /scoreboard select <scoreboard>");
                        return;
                    }

                    var scoreboard = Scoreboard.Find(args[1]);

                    if (scoreboard == null)
                    {
                        SendReply(player, LangMsg("Scoreboard Does Not Exist", player.userID, args[1]));
                        return;
                    }

                    scoreboard.SetActive();
                    SendReply(player, LangMsg("Scoreboard Selected", player.userID, scoreboard.Title));

                    break;

                case "disable":

                    Scoreboard.SetActiveScoreboard(new Scoreboard { Title = string.Empty });
                    SendReply(player, LangMsg("Scoreboard Disabled", player.userID));

                    break;

                case "list":

                    SendReply(player, $"Scoreboards:{Environment.NewLine}{string.Join(Environment.NewLine, Data.All.Select((s) => $"{s.Title} - {s.Description}").ToArray())}");

                    break;

                default:
                    SendReply(player, "/scoreboard <select|disable|list>");
                    break;
            }
        }

        #endregion

        #region Hooks

        void Loaded()
        {
            Instance = this;

            permission.RegisterPermission("scoreboards.admin", this);
            ReadData(out Data);
            LoadMessages();
            LoadConfig();

            CreateScoreboard("Bullets Fired", "Shows the amount of fired bullets", new KeyValuePair<string, string>[0]);

            UpdateScoreboardUI();
        }

        void Unloaded()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, "Scoreboard");
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            DrawScoreboardUI(player);
        }

        #endregion
        
        #region Loading

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No Permission", "You do not have permission to do that." }
            }, this);
        }

        new void LoadConfig()
        {
            AnchorMin = UpdateConfig<string>("Anchor Min", "0.83 0.21");
            AnchorMax = UpdateConfig<string>("Anchor Max", "0.98 0.91");

            BackgroundColor = UpdateConfig<string>("Background Color", "0.3 0.3 0.3 0.7");

            HeaderColor = UpdateConfig<string>("Header Color", "0.66 1 0 1");
            TitleColor = UpdateConfig<string>("Title Color", "0 0 0 1");
            ContentColor = UpdateConfig<string>("Content Color", "0 0 0 1");

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");

        #endregion

        #region Helpers

        string LangMsg(string key, object id = null, params string[] replacements) => string.Format(lang.GetMessage(key, this, id == null ? null : id.ToString()), replacements);

        DataValue ReadData<DataValue>(out DataValue data, string filename = null) => data = Core.Interface.Oxide.DataFileSystem.ReadObject<DataValue>(filename == null ? GetType().Name : $"{GetType().Name}/{filename}");
        void WriteData<DataValue>(DataValue data, string filename = null) => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == null ? GetType().Name : $"{GetType().Name}/{filename}", data);

        ConfigValue UpdateConfig<ConfigValue>(params object[] fullPath)
        {
            List<string> pathL = fullPath.Select((v) => (string)v).ToList();
            pathL.RemoveAt(pathL.Count - 1);
            string[] path = pathL.ToArray();

            if (Config.Get(path) == null)
            {
                PrintWarning("Generating config value: {0}", string.Join("/", path));
                Config.Set(fullPath);
            }

            return (ConfigValue)Convert.ChangeType(Config.Get(path), typeof(ConfigValue));
        }

        #endregion
    }
}

// --- End of file: Scoreboards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoFuelRequirements.cs ---
// --- Original Local Path: NoFuelRequirements.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoFuelRequirements", "k1lly0u", "1.3.0", ResourceId = 1179)]
    class NoFuelRequirements : RustPlugin
    {
        #region Fields        
        bool usingPermissions;
        #endregion

        #region Oxide Hooks        
        void OnServerInitialized()
        {
            LoadVariables();
            RegisterPermissions();
        }
        void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            ConsumeTypes type = StringToType(oven?.ShortPrefabName);
            if (type == ConsumeTypes.None) return;

            if (IsActiveType(type))
            {
                if (usingPermissions && oven.OwnerID != 0U)
                {
                    if (!HasPermission(oven.OwnerID.ToString(), type)) return;
                }
                ++fuel.amount;                
            }
        }
        void OnConsumableUse(Item item, int amount)
        {
            string shortname = item?.parent?.parent?.info?.shortname;
            if (string.IsNullOrEmpty(shortname))
                shortname = item?.GetRootContainer()?.entityOwner?.ShortPrefabName;
            if (string.IsNullOrEmpty(shortname)) return;

            ConsumeTypes type = StringToType(shortname);
            if (type == ConsumeTypes.None) return;

            if (IsActiveType(type))
            {
                if (usingPermissions)
                {
                    string playerId = item?.GetRootContainer()?.playerOwner?.UserIDString;
                    string entityId = item?.GetRootContainer()?.entityOwner?.OwnerID.ToString();

                    if (!string.IsNullOrEmpty(playerId))
                        if (!HasPermission(playerId, type)) return;
                    if (!string.IsNullOrEmpty(entityId) && entityId != "0")
                        if (!HasPermission(entityId, type)) return;
                }                
                item.amount += amount;
            }
        }
        #endregion

        #region Functions
        void RegisterPermissions()
        {
            if (configData.UsePermissions)
            {
                usingPermissions = true;
                foreach (var perm in configData.Permissions)
                {
                    permission.RegisterPermission(perm.Value, this);
                }
            }
        }
        bool HasPermission(string ownerId, ConsumeTypes type) => permission.UserHasPermission(ownerId, configData.Permissions[type]);
        bool IsActiveType(ConsumeTypes type) => configData.AffectedTypes[type];
        ConsumeTypes StringToType(string name)
        {
            switch (name)
            {
                case "campfire":
                    return ConsumeTypes.Campfires;
                case "furnace":
                    return ConsumeTypes.Furnace;
                case "furnace.large":
                    return ConsumeTypes.LargeFurnace;
                case "refinery_small_deployed":
                    return ConsumeTypes.OilRefinery;
                case "ceilinglight.deployed":
                    return ConsumeTypes.CeilingLight;
                case "lantern.deployed":
                    return ConsumeTypes.Lanterns;
                case "hat.miner":
                    return ConsumeTypes.MinersHat;
                case "hat.candle":
                    return ConsumeTypes.CandleHat;
                case "fuelstorage":
                    return ConsumeTypes.Quarry;
                default:
                    return ConsumeTypes.None;
            }
        }
        #endregion

        #region Config  
        enum ConsumeTypes
        {
            Campfires, CandleHat, CeilingLight, Furnace, Lanterns, LargeFurnace, MinersHat, OilRefinery, Quarry, None
        }
        private ConfigData configData;
        class ConfigData
        {            
            public Dictionary<ConsumeTypes, bool> AffectedTypes { get; set; }
            public Dictionary<ConsumeTypes, string> Permissions { get; set; }
            public bool UsePermissions { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                AffectedTypes = new Dictionary<ConsumeTypes, bool>
                {
                    {ConsumeTypes.Campfires, true },
                    {ConsumeTypes.CandleHat, true },
                    {ConsumeTypes.CeilingLight, true },
                    {ConsumeTypes.Furnace, true },
                    {ConsumeTypes.Lanterns, true },
                    {ConsumeTypes.LargeFurnace, true },
                    {ConsumeTypes.MinersHat, true },
                    {ConsumeTypes.OilRefinery, true },
                    {ConsumeTypes.Quarry, true }
                },
                Permissions = new Dictionary<ConsumeTypes, string>
                {
                    {ConsumeTypes.Campfires, "nofuelrequirements.campfire" },
                    {ConsumeTypes.CandleHat, "nofuelrequirements.candlehat" },
                    {ConsumeTypes.CeilingLight, "nofuelrequirements.ceilinglight" },
                    {ConsumeTypes.Furnace, "nofuelrequirements.furnace" },
                    {ConsumeTypes.Lanterns, "nofuelrequirements.lantern" },
                    {ConsumeTypes.LargeFurnace, "nofuelrequirements.largefurnace" },
                    {ConsumeTypes.MinersHat, "nofuelrequirements.minershat" },
                    {ConsumeTypes.OilRefinery, "nofuelrequirements.oilrefinery" },
                    {ConsumeTypes.Quarry, "nofuelrequirements.quarry" }
                },
                UsePermissions = false
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}


// --- End of file: NoFuelRequirements.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EnhancedHammer.cs ---
// --- Original Local Path: EnhancedHammer.cs ---

using Oxide.Game.Rust.Cui;
using Oxide.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Enhanced Hammer", "Visagalis", "0.5.0", ResourceId = 1439)]
    public class EnhancedHammer : RustPlugin
    {
        public class PlayerDetails
        {
            public PlayerFlags flags = PlayerFlags.MESSAGES_DISABLED;
            public BuildingGrade.Enum upgradeInfo = BuildingGrade.Enum.Count; // HAMMER
            public int backToDefaultTimer = 20;
        }

        private string pluginPrefix = "[Enhanced Hammer] ";
        public enum PlayerFlags
        {
            NONE = 0,
            ICONS_DISABLED = 2,
            PLUGIN_DISABLED = 4,
            MESSAGES_DISABLED = 8
        }

        public static Dictionary<ulong, PlayerDetails> playersInfo = new Dictionary<ulong, PlayerDetails>();
        public static Dictionary<ulong, Timer> playersTimers = new Dictionary<ulong, Timer>();

        void OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            BuildingBlock block = entity as BuildingBlock;

            if (PlayerHasFlag(player.userID, PlayerFlags.PLUGIN_DISABLED) || block == null)
                return;

            if (playersInfo[player.userID].upgradeInfo == BuildingGrade.Enum.Count
                || playersInfo[player.userID].upgradeInfo <= block.currentGrade.gradeBase.type
                || !player.CanBuild())
            {
                if (playersInfo[player.userID].upgradeInfo != BuildingGrade.Enum.Count && playersInfo[player.userID].upgradeInfo <= block.currentGrade.gradeBase.type)
                {
                    if(!PlayerHasFlag(player.userID, PlayerFlags.MESSAGES_DISABLED))
                        SendReply(player, pluginPrefix + "You are now in REPAIR mode.");
                    playersInfo[player.userID].upgradeInfo = BuildingGrade.Enum.Count;
                    RenderMode(player, true);
                }
                else if (!player.CanBuild())
                {
                    SendReply(player, pluginPrefix + "Building is blocked!");
                }
            }
            else
            {
                BindingFlags flags = BindingFlags.Instance | BindingFlags.NonPublic;
                MethodInfo dynMethod = block.GetType().GetMethod("CanChangeToGrade", flags);
                bool canChangeGrade = (bool)dynMethod.Invoke(block, new object[] { playersInfo[player.userID].upgradeInfo, player });

                if (!canChangeGrade)
                {
                    SendReply(player, pluginPrefix + "You can't upgrade it, something is blocking it's way.");
                    return;
                }

                if (block.name.ToLower().Contains("wall.external"))
                {
                    SendReply(player, pluginPrefix + "Can't upgrade walls! Switching to REPAIR mode.");
                    playersInfo[player.userID].upgradeInfo = BuildingGrade.Enum.Count;
                    return;
                }
                float currentHealth = block.health;
                var currentGradeType = block.currentGrade.gradeBase.type;
                block.SetGrade(playersInfo[player.userID].upgradeInfo);
                var TwigsDecay = plugins.Find("TwigsDecay");
                TwigsDecay?.Call("OnStructureUpgrade", block, player, playersInfo[player.userID].upgradeInfo);
				block.UpdateSkin(false);
                var cost = block.currentGrade.gradeBase.baseCost;
                int hasEnough = 0;
                foreach (var itemCost in cost)
                {
                    int itemCostAmount = Convert.ToInt32((float)itemCost.amount*block.blockDefinition.costMultiplier);
                    var foundItems = player.inventory.FindItemIDs(itemCost.itemid);
                    var amountFound = foundItems?.Sum(item => item.amount) ?? 0;
                    if (amountFound >= itemCostAmount)
                        hasEnough++;
                }
                if (hasEnough >= cost.Count)
                {
                    foreach (var itemCost in cost)
                    {
                        int itemCostAmount = Convert.ToInt32((float)itemCost.amount * block.blockDefinition.costMultiplier);
                        var foundItems = player.inventory.FindItemIDs(itemCost.itemid);
                        player.inventory.Take(foundItems, itemCost.itemid, itemCostAmount);
                    }
                    block.SetHealthToMax();
                    block.SetFlag(BaseEntity.Flags.Reserved1, true); // refresh rotation
                    block.Invoke("StopBeingRotatable", 600f);
                    Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + playersInfo[player.userID].upgradeInfo.ToString().ToLower() + ".prefab", block, 0u, Vector3.zero, Vector3.zero, null, false);
                }
                else
                {
                    block.SetGrade(currentGradeType);
                    TwigsDecay?.Call("OnStructureUpgrade", block, player, currentGradeType);
                    block.UpdateSkin(false);
                    block.health = currentHealth;
                    SendReply(player, pluginPrefix + "Can't afford to upgrade!");
                }
            }

            RefreshTimer(player);
        }

        void RefreshTimer(BasePlayer player)
        {
            if (playersInfo[player.userID].backToDefaultTimer == 0)
                return;

            if (playersTimers.ContainsKey(player.userID))
            {
                playersTimers[player.userID].Destroy();
                playersTimers.Remove(player.userID);
            }

            var timerIn = timer.Once(playersInfo[player.userID].backToDefaultTimer, () => SetBackToDefault(player));
            playersTimers.Add(player.userID, timerIn);
        }

        void OnStructureUpgrade(BaseCombatEntity block, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (PlayerHasFlag(player.userID, PlayerFlags.PLUGIN_DISABLED))
                return;

            if (playersInfo[player.userID].upgradeInfo != grade)
            {
                playersInfo[player.userID].upgradeInfo = grade;
                RenderMode(player, false);
                if (!PlayerHasFlag(player.userID, PlayerFlags.MESSAGES_DISABLED))
                    SendReply(player, pluginPrefix + "You are now in UPGRADE mode. [" + grade.ToString() + "]");
            }

            RefreshTimer(player);
        }

        void RenderMode(BasePlayer player, bool repair = false)
        {
            CuiHelper.DestroyUi(player, "EnhancedHammerUI");
            if (PlayerHasFlag(player.userID, PlayerFlags.PLUGIN_DISABLED) || 
                PlayerHasFlag(player.userID, PlayerFlags.ICONS_DISABLED) || 
                (!repair && playersInfo[player.userID].upgradeInfo == BuildingGrade.Enum.Count))
                return;

            CuiElementContainer panel = new CuiElementContainer();
            string icon = "http://i.imgur.com/Nq6DNSX.png";
            if (!repair)
            {
                switch (playersInfo[player.userID].upgradeInfo)
                {
                    case BuildingGrade.Enum.Wood:
                        icon = "http://i.imgur.com/F4XBBhY.png";
                        break;
                    case BuildingGrade.Enum.Stone:
                        icon = "http://i.imgur.com/S7Sl9oh.png";
                        break;
                    case BuildingGrade.Enum.Metal:
                        icon = "http://i.imgur.com/fVjzbag.png";
                        break;
                    case BuildingGrade.Enum.TopTier:
                        icon = "http://i.imgur.com/f0WklR3.png";
                        break;
                }

            }
            CuiElement ehUI = new CuiElement { Name = "EnhancedHammerUI", Parent = "HUD/Overlay", FadeOut = 0.5f };
            CuiRawImageComponent ehUI_IMG = new CuiRawImageComponent { FadeIn = 0.5f, Url = icon };
            CuiRectTransformComponent ehUI_RECT = new CuiRectTransformComponent
            {
                AnchorMin = "0.32 0.09",
                AnchorMax = "0.34 0.13"
            };
            ehUI.Components.Add(ehUI_IMG);
            ehUI.Components.Add(ehUI_RECT);
            panel.Add(ehUI);
            CuiHelper.AddUi(player, panel);
        }

        void SetBackToDefault(BasePlayer player)
        {
            if(playersTimers.ContainsKey(player.userID))
                playersTimers.Remove(player.userID);
			if(playersInfo.ContainsKey(player.userID))
				playersInfo[player.userID].upgradeInfo = BuildingGrade.Enum.Count;
            RemoveUI(player);
            if (!PlayerHasFlag(player.userID, PlayerFlags.MESSAGES_DISABLED))
                SendReply(player, pluginPrefix + "You are now in REPAIR mode.");
        }

        void RemoveUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "EnhancedHammerUI");
        }

        void OnPlayerInit(BasePlayer player)
        {
            playersInfo.Add(player.userID, new PlayerDetails());
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (playersInfo.ContainsKey(player.userID))
                playersInfo.Remove(player.userID);
        }

        public PlayerFlags GetPlayerFlags(ulong userID)
        {
            if (playersInfo.ContainsKey(userID))
                    return playersInfo[userID].flags;

            return PlayerFlags.NONE;
        }

        void Init()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if(!playersInfo.ContainsKey(player.userID))
                    playersInfo.Add(player.userID, new PlayerDetails());
            }
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                RemoveUI(player);
                if (playersInfo.ContainsKey(player.userID))
                    playersInfo.Remove(player.userID);
            }
        }

        [ChatCommand("eh")]
        private void OnEhCommand(BasePlayer player, string command, string[] arg)
        {
            bool incorrectUsage = arg.Length == 0;
            bool ADD = true;
            bool REMOVE = false;
            if (arg.Length == 1)
            {
                switch (arg[0].ToLower())
                {
                    case "enable":
                        ModifyPlayerFlags(player, REMOVE, PlayerFlags.PLUGIN_DISABLED);
                        break;
                    case "disable":
                        ModifyPlayerFlags(player, ADD, PlayerFlags.PLUGIN_DISABLED);
                        break;
                    case "show":
                        ModifyPlayerFlags(player, REMOVE, PlayerFlags.ICONS_DISABLED);
                        break;
                    case "hide":
                        ModifyPlayerFlags(player, ADD, PlayerFlags.ICONS_DISABLED);
                        break;
                    default:
                        incorrectUsage = true;
                        break;
                }
                if (!incorrectUsage)
                    RenderMode(player);
            }
            else if (arg.Length == 2)
            {
                if (arg[0].ToLower() == "timer")
                {
                    int seconds;
                    if (int.TryParse(arg[1], out seconds) && seconds >= 0)
                    {
                        playersInfo[player.userID].backToDefaultTimer = seconds;
                        string msg = "";
                        if (seconds > 0)
                            msg += " Timer has been set to " + seconds + " seconds.";
                        else
                            msg += " Timer will never end.";
                        SendReply(player, pluginPrefix + msg);
                        incorrectUsage = false;
                    }
                }
                else if (arg[0].ToLower() == "msgs")
                {
                    if (arg[1].ToLower() == "show")
                        ModifyPlayerFlags(player, false, PlayerFlags.MESSAGES_DISABLED);
                    else if (arg[1].ToLower() == "hide")
                        ModifyPlayerFlags(player, true, PlayerFlags.MESSAGES_DISABLED);
                    else
                        incorrectUsage = true;
                }
            }

            if (incorrectUsage)
            {
                SendReply(player, "Command usage:");
                SendReply(player, "/eh [enable/disable] - Enables or disabled plugin functionality.");
                SendReply(player, "/eh [show/hide] - Shows or hides plugin icons.");
                SendReply(player, "/eh timer [0/seconds] - Time in which hammer goes back to default mode.");
                SendReply(player, "/eh msgs [show/hide] - Show messages in chat about hammer state.");
            }
        }

        private bool PlayerHasFlag(ulong userID, PlayerFlags flag)
        {
            return (GetPlayerFlags(userID) & flag) == flag;
        }

        private void ModifyPlayerFlags(BasePlayer player, bool addFlag, PlayerFlags flag)
        {
            bool actionCompleted = false;
            if (addFlag)
            {
                if ((playersInfo[player.userID].flags & flag) != flag)
                {
                    playersInfo[player.userID].flags |= flag;
                    actionCompleted = true;
                }
            }
            else
            {
                if ((playersInfo[player.userID].flags & flag) == flag)
                {
                    playersInfo[player.userID].flags &= ~flag;
                    actionCompleted = true;
                }
            }

            if (actionCompleted)
            {
                string msg = "";
                switch (flag)
                {
                    case PlayerFlags.ICONS_DISABLED:
                        msg += "ICONS";
                        break;
                    case PlayerFlags.PLUGIN_DISABLED:
                        msg += "PLUGIN";
                        break;
                    case PlayerFlags.MESSAGES_DISABLED:
                        msg += "MESSAGES";
                        break;
                }
                SendReply(player, pluginPrefix + msg + " has been " + (!addFlag? "ENABLED" : "DISABLED") + ".");
            }
        }
    }
}

// --- End of file: EnhancedHammer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TearUpBP.cs ---
// --- Original Local Path: TearUpBP.cs ---

using Oxide.Core;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Tear Up BluePrints", "DaBludger", 1.91, ResourceId = 1300)]
    [Description("This will allow players to 'Tear up' Blueprints for BP Fragments")]
    public class TearUpBP : RustPlugin
    {
        private static Dictionary<int, ItemDefinition> ALLITEMS = ItemManager.itemDictionary;
        private static Dictionary<string, object> CUSTOME_ITME_NAMES = new Dictionary<string, object>();
        // this is multiplyed by the total number of frags to get the MIN amount of frags for a BP
        private static double MIN_FRAGS_MULTIPLYER = 0.25;
        // this is multiplyed by the total number of frags to get the MAX amount of frags for a BP
        private static double MAX_FRAGS_MULTIPLYER = 0.50;
        private static bool CAN_PLAYER_USE = true;
        private static bool USE_PERMISSIONS = true;
        //Uncommon is a page, Rare is a Book, VeryRare is a Library
        //The min and max are multiplyed by the rarity number to get the range that a random number is chosen from 
        //that range for the number of BP fragments the player gets
        private static readonly Dictionary<string, int> bprarety2frags = new Dictionary<string, int> { { "Common", 20 }, { "Uncommon", 60 }, { "Rare", 300 }, { "VeryRare", 1200 } };
        private static readonly string UNKNOWN_ITEM = "Unknown item! use chat command /Tearup lookup [name contains]";
        private static readonly string HELP_TEXT = "Use the Tearup command like this '/tearup [bp name]'   or   '/tearup lookup [name contains]' to look up a BP name.";
        private static readonly string NO_PERMISSION = "You do not have the correct permissions to access this plugin.";

        void Init()
        {
            permission.RegisterPermission("tearup.use",this);
            permission.RegisterPermission("tearup.admin", this);
            CheckCfg("CUSTOMENAMES", ref CUSTOME_ITME_NAMES);
            Puts("Number of BPs: " + CUSTOME_ITME_NAMES.Keys.Count);
            CheckCfg("TEARUP_MIN_FRAGS_MULTIPLYER", ref MIN_FRAGS_MULTIPLYER);
            CheckCfg("TEARUP_MAX_FRAGS_MULTIPLYER", ref MAX_FRAGS_MULTIPLYER);
            CheckCfg("USE_PERMISSIONS", ref USE_PERMISSIONS);
            CheckCfg("CAN_PLAYER_USE", ref CAN_PLAYER_USE);
            if (MIN_FRAGS_MULTIPLYER <= 0)
            {
                setMinFrags(0.25);
            }
            if (MAX_FRAGS_MULTIPLYER < MIN_FRAGS_MULTIPLYER)
            {
                setMaxFrag(MIN_FRAGS_MULTIPLYER);
            }
            Puts("Tear IT UP!");
        }
        /**
        This has to be done after the server loads up to have the list of BPs to get the names.
        **/
        void OnServerInitialized()
        {
            ALLITEMS = ItemManager.itemDictionary;
            for (int i = 0; i < ItemManager.bpList.Count; i++)
            {
                if (!CUSTOME_ITME_NAMES.ContainsKey(ItemManager.bpList[i].name))
                {
                    Puts("Adding item name: " + ItemManager.bpList[i].name);
                    CUSTOME_ITME_NAMES.Add(ItemManager.bpList[i].name, null);
                }
            }
            Puts("Number of BPs: " + CUSTOME_ITME_NAMES.Keys.Count);
            SaveConfig();
            Puts("Custome names loaded.");
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void LoadDefaultConfig() { }

        private void setMinFrags(double min)
        {
            MIN_FRAGS_MULTIPLYER = min;
        }

        private void setMaxFrag(double max)
        {
            MAX_FRAGS_MULTIPLYER = max;
        }

        [ChatCommand("tearup")]
        private void TearupCommand(BasePlayer player, string command, string[] args)
        {
            if (USE_PERMISSIONS)
            {
                if (!permission.UserHasPermission(player.userID + "", "terup.admin") && !CAN_PLAYER_USE)
                {
                    sendChant2Player(player, NO_PERMISSION);
                    return;
                }
            }
            if (args.Length == 0)
            {
                sendChant2Player(player, HELP_TEXT);
                return;
            }
            else if (args.Length == 1)
            {
                if ("lookup".Equals(args[0].Trim().ToLower()))
                {
                    sendChant2Player(player, HELP_TEXT);
                    return;
                }
                if (args[0].Trim().Length > 0)
                {
                    string bpname = (args[0].Trim() + ".item").ToUpper();
                    string realname = getRealBPItemName(args[0].Trim());
                    ItemBlueprint ib = null;
                    if (realname == null)
                    {
                        realname = bpname;
                        ib = getBPItem(bpname);
                    }
                    else
                    {
                        ib = getBPItem(realname);
                    }
                    if (ib != null)
                    {
                        int min = (int)(bprarety2frags[ib.rarity.ToString()] * MIN_FRAGS_MULTIPLYER);
                        int max = (int)((bprarety2frags[ib.rarity.ToString()] * MAX_FRAGS_MULTIPLYER) + 1);
                        if (removeBP(player, getItemId(ib.name)))
                        {
                            givePlayerFragments(player, Random.Range(min, max));
                        }
                        else
                        {
                            sendChant2Player(player, realname + " is not in your inventory!");
                        }
                        return;
                    }
                    else
                    {
                        sendChant2Player(player, realname + " is not a valid Blueprint name, doing /tearup lookup  for you");
                        string[] newArgs = new string[2] { "lookup", args[0] };
                        TearupCommand(player, command, newArgs);
                    }
                }
            }
            else if (args.Length == 2 && "lookup".Equals(args[0].Trim().ToLower()) && args[1].Trim().Length > 0)
            {
                string wildcard = args[1].Trim().ToUpper();
                string result = "";
                List<string> matchingItems = new List<string>();
                string[] cValues = new string[CUSTOME_ITME_NAMES.Values.Count];
                CUSTOME_ITME_NAMES.Values.CopyTo(cValues, 0);
                string[] cKeys = new string[CUSTOME_ITME_NAMES.Keys.Count];
                CUSTOME_ITME_NAMES.Keys.CopyTo(cKeys, 0);
                for (int k = 0; k < cValues.Length; k++)
                {
                    if (cValues[k] != null)
                    {
                        if (cValues[k].Trim().ToUpper().Contains(wildcard))
                        {
                            matchingItems.Add(cKeys[k]);
                        }
                    }
                }

                for (int i = 0; i < ItemManager.bpList.Count; i++)
                {
                    if (ItemManager.bpList[i].name.ToUpper().Contains(wildcard))
                    {
                        matchingItems.Add(ItemManager.bpList[i].ToString());
                        //result = prityPrintItemNames(ItemManager.bpList[i]);
                    }
                }
                foreach (string name in matchingItems)
                {
                    string nameClean = name;
                    if (name.Contains(" "))
                    {
                        nameClean = name.Substring(0, name.IndexOf(" "));
                    }
                    if (CUSTOME_ITME_NAMES.ContainsKey(nameClean) && CUSTOME_ITME_NAMES[nameClean] != null)
                    {
                        result += CUSTOME_ITME_NAMES[nameClean] + ", ";
                    }
                    else
                    {
                        result += prityPrintItemNames(name) + ", ";
                    }
                }
                if (result.Length == 0)
                {
                    sendChant2Player(player, "No Item Names were found containing " + wildcard + ".");
                }
                else
                {
                    sendChant2Player(player, result);
                }
                return;
            }
            else
            {
                sendChant2Player(player, HELP_TEXT);
                return;
            }
        }

        private void sendChant2Player(BasePlayer player, string msg)
        {
            PrintToChat(player, msg, new object[0]);
        }

        private void givePlayerFragments(BasePlayer player, int frags2give)
        {
            player.GiveItem(ItemManager.CreateByItemID(1351589500, frags2give));
        }

        private bool isNameOfBP(string bpname)
        {
            foreach (ItemBlueprint ib in ItemManager.bpList)
            {
                if (ib.name.ToUpper().Equals(bpname))
                {
                    return true;
                }
            }
            return false;
        }

        private string getRealBPItemName(string cName)
        {
            object[] values = new object[CUSTOME_ITME_NAMES.Values.Count];
            CUSTOME_ITME_NAMES.Values.CopyTo(values, 0);
            string[] keys = new string[CUSTOME_ITME_NAMES.Keys.Count];
            CUSTOME_ITME_NAMES.Keys.CopyTo(keys, 0);

            for (int i = 0; i < values.Length; i++)
            {
                if (values[i] != null)
                {
                    if (cName.ToLower().Trim() == (values[i] as string).ToLower().Trim())
                    {
                        return keys[i].ToLower().Trim();
                    }
                }
            }
            return null;
        }

        private ItemBlueprint getBPItem(string bpname)
        {
            foreach (ItemBlueprint ib in ItemManager.bpList)
            {
                if (ib.name.ToUpper().Equals(bpname.ToUpper()))
                {
                    return ib;
                }
            }
            return null;
        }

        private bool removeBP(BasePlayer player, int bpid)
        {
            if (bpid != -1)
            {
                foreach(Item i in player.inventory.AllItems())
                {
                    if(i.IsBlueprint() && i.info.itemid == bpid)
                    {
                        i.RemoveFromContainer();
                        return true;
                    }
                }
            }
            return false;
        }

        private int getItemId(string name)
        {
            if (name != null && name.Length > 0)
            {
                foreach (ItemDefinition itemdef in ALLITEMS.Values)
                {
                    if (itemdef.name.ToUpper().Equals(name.ToUpper()))
                    {
                        return itemdef.itemid;
                    }
                }
            }

            return -1;
        }

        private string prityPrintItemNames(ItemBlueprint iBP)
        {
            string temp = "" + iBP;
            return temp.Substring(0, temp.IndexOf(".item"));
        }

        private string prityPrintItemNames(string iBPname)
        {
            return iBPname.Substring(0, iBPname.IndexOf(".item"));
        }
    }
}


// --- End of file: TearUpBP.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WarpSystem.cs ---
// --- Original Local Path: WarpSystem.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Linq;
using System.Data;
using UnityEngine;
using Oxide.Core; 
using Oxide.Core.Plugins; 
 
namespace Oxide.Plugins
{
    [Info("Warp System", "PaiN", "1.9.8", ResourceId = 760)] 
    [Description("Create warp points for players.")]
    class WarpSystem : RustPlugin 
    { 
	
		[PluginReference]
		Plugin Jail;
		
		private bool Changed;
		private int cooldown;
		private int warpbacktimer;
		private bool enablecooldown;
		private int backcmdauthlevel;
		private bool WarpIfRunning;
		private bool WarpIfWounded;
		private bool WarpIfSwimming;
		private bool WarpIfBuildingBlocked;
		private bool WarpIfDucking;
		private string backtolastloc;
		private string warplist;
		private string therealreadyis;
		private string warpadded;
		private string youhavetowait;
		private string cantwarpwhilerunning;
		private string cantwarpwhilewounded;
		private string cantwarpwhilebuildingblocked;
		private string cantwarpwhileducking;
		private string cantwarpwhileswimming;
		private string youhaveteleportedto;
		private string teleportingto;
		private string youhaveremoved;
			
		object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;  
        } 
		
		
		
		double GetTimeStamp()
		{
			return (DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds ;
		}
		
		void LoadVariables() 
		{
			warpbacktimer = Convert.ToInt32(GetConfig("Settings", "WarpBackTimer", 5));
			cooldown = Convert.ToInt32(GetConfig("Settings", "Cooldown", 120));
			enablecooldown = Convert.ToBoolean(GetConfig("Settings", "EnableCooldown", true));
			backcmdauthlevel = Convert.ToInt32(GetConfig("Settings", "Warp_Back_Atleast_Required_Authlevel", 1));
			WarpIfWounded = Convert.ToBoolean(GetConfig("Settings", "WarpIfWounded", true));
			WarpIfSwimming = Convert.ToBoolean(GetConfig("Settings", "WarpIfSwimming", true));
			WarpIfRunning = Convert.ToBoolean(GetConfig("Settings", "WarpIfRunning", true)); 
			WarpIfBuildingBlocked = Convert.ToBoolean(GetConfig("Settings", "WarpIfBuildingBlocked", true));
			WarpIfDucking = Convert.ToBoolean(GetConfig("Settings", "WarpIfDucking", true));
			backtolastloc = Convert.ToString(GetConfig("Messages", "TELEPORTED_TO_LAST_LOCATION", "You have teleported back to your last location!"));
			warplist = Convert.ToString(GetConfig("Messages", "WARP_LIST", "Warp ID: <color=#91FFB5>{2}</color>\nWarp Name: <color=cyan>{0}</color> \nPermission:<color=orange> {1} </color> \nMaxUses Remaining: <color=lime>{3}</color>"));
			therealreadyis = Convert.ToString(GetConfig("Messages", "WARP_EXISTS", "This warp already exists!"));
			warpadded = Convert.ToString(GetConfig("Messages", "WARP_ADDED", "Warp added with Warp Name: <color=#91FFB5>{0}</color>"));
			youhavetowait = Convert.ToString(GetConfig("Messages", "COOLDOWN_MESSAGE", "You have to wait <color=#91FFB5>{0}</color> second(s) before you can teleport again."));
			cantwarpwhilerunning = Convert.ToString(GetConfig("Messages", "CANT_WARP_WHILE_RUNNING", "You can not warp while running!"));
			cantwarpwhilewounded = Convert.ToString(GetConfig("Messages", "CANT_WARP_WHILE_WOUNDED", "You can not warp while you are wounded!"));
			cantwarpwhilebuildingblocked = Convert.ToString(GetConfig("Messages", "CANT_WARP_WHILE_BUILDING_BLOCKED", "You can not warp while you are in a building blocked area!")); 
			cantwarpwhileducking = Convert.ToString(GetConfig("Messages", "CANT_WARP_WHILE_DUCKING", "You can not warp while you are ducking!"));
			cantwarpwhileswimming = Convert.ToString(GetConfig("Messages", "CANT_WARP_WHILE_SWIMMING", "You can not warp while you are swimming!"));
			youhaveteleportedto = Convert.ToString(GetConfig("Messages", "TELEPORTED_TO", "You have teleported to <color=#91FFB5>{0}</color>"));
			teleportingto = Convert.ToString(GetConfig("Messages", "TELEPORTING_IN_TO", "Teleporting in <color=orange>{0}</color> second(s) to <color=#91FFB5>{1}</color>"));
			youhaveremoved = Convert.ToString(GetConfig("Messages", "WARP_REMOVED", "You have removed the warp <color=#91FFB5>{0}</color>"));
			
			if (Changed)
			{
				SaveConfig();
				Changed = false;
			
			}	
		}
		
		protected override void LoadDefaultConfig()
		{
			Puts("Creating a new configuration file!");
			Config.Clear();
			LoadVariables();
		}
		
			class StoredData
			{
				public List<WarpInfo> WarpInfo = new List<WarpInfo>{};
				public Dictionary<ulong, double> cantele = new Dictionary<ulong, double>();
				public Dictionary<ulong, OldPosInfo> lastposition = new Dictionary<ulong, OldPosInfo>();
				public Dictionary<ulong, Dictionary<string, int>> maxuses = new Dictionary<ulong, Dictionary<string, int>>();
				
			} 
			
			class OldPosInfo
			{
				public float OldX;
				public float OldY;
				public float OldZ;
				
				public OldPosInfo(float x, float y, float z)
				{
					OldX = x;
					OldY = y; 
					OldZ = z;
				}
				
				public OldPosInfo()
				{
				}
			}
			class WarpInfo
			{
				public string WarpName;
				public int WarpId;
				public float WarpX;
				public float WarpY; 
				public float WarpZ; 
				public string WarpPermissionGroup;
				public int WarpTimer;
				public int WarpMaxUses;
				public string WarpCreatorName;
				public int RandomRange;
				
				public WarpInfo(string name, BasePlayer player, int timerp, string permissionp, int warpnum, int randomr, int maxusess)
				{
					WarpName =  name; 
					WarpId = warpnum;
					WarpX = player.transform.position.x;
					WarpMaxUses = maxusess;
					WarpY = player.transform.position.y;
					WarpZ = player.transform.position.z;
					WarpCreatorName = player.displayName;
					WarpTimer = timerp;
					WarpPermissionGroup = permissionp;
					RandomRange = randomr;
				}
				
				public WarpInfo()
				{ 
				}
			}
			
			StoredData storedData;
			
			void Loaded()
			{
				storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("WarpSystem"); 
				if (!permission.PermissionExists("warpsystem.admin")) permission.RegisterPermission("warpsystem.admin", this);
				LoadVariables();
				foreach(WarpInfo info in storedData.WarpInfo)
				{
						if(!permission.GroupExists(info.WarpPermissionGroup)) permission.CreateGroup(info.WarpPermissionGroup, "", 0);
						cmd.AddChatCommand(info.WarpId.ToString(), this, "");
						cmd.AddChatCommand(info.WarpName, this, "");
				} 
			}
			[ConsoleCommand("warp.wipemaxuses")]
			void cmdWarpMaxUses(ConsoleSystem.Arg arg)
			{
				if(arg.connection != null && arg.connection.authLevel < 1)
				{
					SendReply(arg, "You cant use that command!"); 
					return;
				} 
				storedData.maxuses.Clear();
				Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
			}
			[ConsoleCommand("warp.playerto")]
			void cmdWarpPlayerr(ConsoleSystem.Arg arg)
			{
				BasePlayer target = BasePlayer.Find(arg.Args[0]);
				if((arg.Args == null) || (arg.Args != null && arg.Args.Length == 0))
				{
					SendReply(arg, "warp.playerto <PlayerName> <WarpName>");
					return;
				}
				if(arg.connection != null && arg.connection.authLevel < 1)
				{
					SendReply(arg, "You cant use that command!");
					return;
				} 
				if(target == null)
				{
					SendReply(arg, "Player not found!");
					return;
				}
						
						ulong steamID = target.userID;
						double nextteletime;

						
						if(enablecooldown == true) 
						{
							if (storedData.cantele.TryGetValue(steamID, out nextteletime))
							{ 
								if(GetTimeStamp() >= nextteletime)
								{ 					
									storedData.cantele[steamID] = GetTimeStamp() + cooldown;
									Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
									goto Finish;
								} 
								else
								{
									int nexttele = Convert.ToInt32(nextteletime - GetTimeStamp());
									SendReply(target, youhavetowait, nexttele.ToString().Replace("-", ""));
									return;
								}
							}
							else
							{
								storedData.cantele.Add(steamID, GetTimeStamp() + cooldown);
								Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
								goto Finish; 
							}
						}
							
						Finish: 
						foreach(WarpInfo info in storedData.WarpInfo)
						{ 
								
							if(info.WarpName.ToString().ToLower() == arg.Args[1].ToString().ToLower() || info.WarpId.ToString().ToLower() == arg.Args[1].ToString().ToLower())
							{
								SendReply(target, teleportingto,info.WarpTimer, info.WarpName);
								SendReply(arg, $"Teleporting {target.displayName} to {info.WarpName} in {info.WarpTimer}");
								timer.Once(info.WarpTimer, () => { 
								if(WarpIfRunning == false && target.IsRunning())
									{
										SendReply(target, cantwarpwhilerunning);
										return;
									}
									if(WarpIfWounded == false && target.IsWounded())
									{
										SendReply(target, cantwarpwhilewounded);
										return;
									} 
									if(WarpIfSwimming == false && target.IsSwimming())
									{
										SendReply(target, cantwarpwhileswimming);
										return;
									}
									if(WarpIfBuildingBlocked == false &! target.CanBuild())
									{ 
										SendReply(target, cantwarpwhilebuildingblocked);
										return;
									}
									if(WarpIfDucking == false && target.IsDucked())
									{
										SendReply(target, cantwarpwhileducking);
										return;
									}
									ForcePlayerPos(target, new Vector3(info.WarpX, info.WarpY, info.WarpZ)); 
									SendReply(target, youhaveteleportedto, info.WarpName);
									
								});
							}
						}
			}
			
			
			/*[ConsoleCommand("test.it")]
			void cmdTestIT(ConsoleSystem.Arg arg)
			{
				SendReply(arg, new Random.Next(1,5).ToString());
			}*/
			int GetNewId()
			{
				
				int id = 0;
				foreach(WarpInfo info in storedData.WarpInfo)
				{
					id = Math.Max(0, info.WarpId);
				}
				return id + 1;
			}
			int GetRandomId(BasePlayer player)
			{
				int randomid = 0;
				foreach(WarpInfo info in storedData.WarpInfo)
				{
					if(permission.UserHasGroup(player.userID.ToString(), info.WarpPermissionGroup) || info.WarpPermissionGroup == "all")
					{
						randomid = UnityEngine.Random.Range(0, Math.Max(0, info.WarpId));
					}
				}
				return randomid + 1;
			}
			[ChatCommand("warp")]
			void cmdWarp(BasePlayer player, string cmdd, string[] args)
			{  
				if(args.Length == 0)
				{ 
					player.SendConsoleCommand("chat.say \"/warp help\" ");
					return;
				}

				bool isprisoner = Convert.ToBoolean(Jail?.Call("IsPrisoner", player));
			
				
				ulong steamId = player.userID;
				double nextteletime;
				switch(args[0])
				{
					case "limit":
					SendReply(player, "<color=#91FFB5>Current Warp Limits</color>");

					if (storedData.cantele.TryGetValue(steamId, out nextteletime))
					{ 
						int nexttele = Convert.ToInt32(nextteletime - GetTimeStamp());
						if(nexttele <= 0)
						{
							nexttele = 0;
						}
						SendReply(player, $"You will be able to warp again in {nexttele.ToString()} seconds");
					}
					SendReply(player, $"Warp Cooldown: <color=orage>{cooldown.ToString()}</color>");
					SendReply(player, $"Warp Cooldown Enabled: <color=orage>{enablecooldown.ToString()}</color>");
					SendReply(player, "<color=#91FFB5>*************</color>");
					break;
					case "back":
					if(isprisoner)
					{
						SendReply(player, "You cant teleport out of the jail!");
						return;
					}
					if(player.net.connection.authLevel >= backcmdauthlevel)
					{
						SendReply(player, "Teleporting to you last saved locations in {0} seconds.", warpbacktimer.ToString());
						timer.Once(warpbacktimer, () => {
						if(WarpIfRunning == false && player.IsRunning())
						{
							SendReply(player, cantwarpwhilerunning);
							return;
						}
						if(WarpIfWounded == false && player.IsWounded())
						{
							SendReply(player, cantwarpwhilewounded);
							return;
						} 
						if(WarpIfSwimming == false && player.IsSwimming())
						{
							SendReply(player, cantwarpwhileswimming);
							return;
						}
						if(WarpIfBuildingBlocked == false &! player.CanBuild())
						{
							SendReply(player, cantwarpwhilebuildingblocked);
							return;
						}
						if(WarpIfDucking == false && player.IsDucked())
						{
							SendReply(player, cantwarpwhileducking);
							return;
						}
						ForcePlayerPos(player, new Vector3(storedData.lastposition[steamId].OldX, storedData.lastposition[steamId].OldY, storedData.lastposition[steamId].OldZ)); 
						SendReply(player, backtolastloc);
						storedData.lastposition.Remove(steamId);
						Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
						});
					}
					break;
					
					case "random":
					if(isprisoner)
					{
						SendReply(player, "You cant teleport out of the jail!");
						return;
					}
					player.SendConsoleCommand($"chat.say \"/warp to {GetRandomId(player).ToString()}\" ");
					break;
					
					case "all":
					if(!permission.UserHasPermission(player.userID.ToString(), "warpsystem.admin"))
					{
						SendReply(player, "You do not have permission to use this command!");
						return; 
					}
					if(args.Length == 2)
					{
						foreach(BasePlayer current in BasePlayer.activePlayerList)
						{
							foreach(WarpInfo info in storedData.WarpInfo)
							{
								if(info.WarpName.ToString().ToLower() == args[1].ToString().ToLower() || info.WarpId.ToString() == args[1].ToString())
								{
									ForcePlayerPos(current, new Vector3(info.WarpX, info.WarpY, info.WarpZ)); 
									SendReply(current, "You got teleported to <color=#91FFB5>" + info.WarpName + "</color> by <color=orange>" + player.displayName + "</color>");
								
								}
							}
						}
					}
					else if(args.Length == 3 && args[1].ToString() == "sleepers")
					{
						foreach(BasePlayer sleepers in BasePlayer.sleepingPlayerList)
						{
							foreach(WarpInfo info in storedData.WarpInfo)
							{
								if(info.WarpName.ToString().ToLower() == args[2].ToString().ToLower() || info.WarpId.ToString() == args[2].ToString())
								{
									ForcePlayerPos(sleepers, new Vector3(info.WarpX, info.WarpY, info.WarpZ)); 
									//SendReply(player, "You got teleported to <color=#91FFB5>" + info.WarpName + "</color> by <color=orange>" + player.displayName + "</color>");
								
								}
							}
						}
					}
					else
					{
						SendReply(player, "<color=#91FFB5>Teleport all online players</color>: \n /warp all <WarpName>");
						SendReply(player, "<color=#91FFB5>Teleport all sleepers</color>: \n /warp all sleepers <WarpName>");
						return;
					}
					break;
					case "wipe":
					if(!permission.UserHasPermission(player.userID.ToString(), "warpsystem.admin"))
					{
						SendReply(player, "You do not have permission to use this command!");
						return;
					}
						storedData.WarpInfo.Clear();
						storedData.cantele.Clear();
						Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
					SendReply(player, "You have wiped all the teleports!");
					break;
					
					case "list":
						SendReply(player, "<color=#91FFB5>Current Warps</color>");
						string maxusesrem;
						foreach(WarpInfo info in storedData.WarpInfo)
						{
							if(permission.UserHasGroup(steamId.ToString(), info.WarpPermissionGroup) || info.WarpPermissionGroup == "all")
							{

								if(info.WarpMaxUses == 0)
								{
									maxusesrem = "<color=red>UNLIMITED</color>";
								}
								else if(!storedData.maxuses.ContainsKey(steamId))
								{
									maxusesrem = info.WarpMaxUses.ToString();
								}
								else
								maxusesrem = storedData.maxuses[steamId][info.WarpName].ToString();
								
								SendReply(player, warplist.ToString(), info.WarpName, info.WarpPermissionGroup, info.WarpId, maxusesrem.ToString());
								SendReply(player, "<color=#91FFB5>*************</color>");
							}
							
						}
						SendReply(player, "<color=#91FFB5>*************</color>");
					break;
					 
					case "add":
					
					if(!permission.UserHasPermission(player.userID.ToString(), "warpsystem.admin"))
					{
						SendReply(player, "You do not have permission to use this command!");
						return;
					}
					if(args.Length != 6)
					{
						SendReply(player, "/warp <add> <WarpName> <WarpTimer> <WarpRange> <WarpMaxUses> <WarpPermissionGroup>");
						return;
					}   
					foreach(WarpInfo info in storedData.WarpInfo)
					{ 
						if(args[1].ToString().ToLower() == info.WarpName.ToString().ToLower())
						{
							SendReply(player, therealreadyis.ToString());
							return;
						}
					} 
					string permissionp = args[5];
					string name = args[1];
					int warpnum;
					int timerp = Convert.ToInt32(args[2]); 
					int randomr = Convert.ToInt32(args[3]);
					int maxusess = Convert.ToInt32(args[4]);
					if(storedData.WarpInfo == null)
					{
						warpnum = 1;
					}
					else
					{
						warpnum = GetNewId();
					}
					var data = new WarpInfo(name, player, timerp, permissionp, warpnum, randomr, maxusess);
					storedData.WarpInfo.Add(data);
					SendReply(player, warpadded, name.ToString());
					Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
					if(!permission.GroupExists(args[5])) permission.CreateGroup(args[5], "", 0);
					cmd.AddChatCommand(name.ToString(), this, "");
					cmd.AddChatCommand(warpnum.ToString(), this, "");
					break;
					
					case "to":
					if(args.Length != 2)
					{
						SendReply(player, "/warp to <WarpName> || /warplist");
						return;
					}
					if(isprisoner)
					{
						SendReply(player, "You cant teleport out of the jail!");
						return;
					}
					foreach(WarpInfo info in storedData.WarpInfo)
					{ 
						if(info.WarpName.ToString().ToLower() == args[1].ToString().ToLower() || info.WarpId.ToString() == args[1].ToString())
						{
							if(info.WarpPermissionGroup == "all" || permission.UserHasGroup(steamId.ToString(), info.WarpPermissionGroup))
							{
								if(info.WarpMaxUses > 0)
								{
									if(!storedData.maxuses.ContainsKey(steamId))
									{
										storedData.maxuses.Add(
										steamId,
										new Dictionary<string, int>{
											{info.WarpName, 1}
										}
									);
									}
									if(storedData.maxuses[steamId][info.WarpName] == 5)
									{
										SendReply(player, "You have reached the max uses for this Warp!");
										return;
									}
									if(storedData.maxuses.ContainsKey(steamId))
									{
										storedData.maxuses[steamId][info.WarpName] = storedData.maxuses[steamId][info.WarpName] + 1;
									}
								}
								
								if(enablecooldown == true) 
								{
									if (storedData.cantele.TryGetValue(steamId, out nextteletime))
									{  
										if(GetTimeStamp() >= nextteletime)
										{
											
											storedData.cantele[steamId] = GetTimeStamp() + cooldown;
											Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
											goto Finish;
										} 
										else
										{
											int nexttele = Convert.ToInt32(GetTimeStamp() - nextteletime);
											SendReply(player, youhavetowait, nexttele.ToString().Replace("-", ""));
											return;
										}
									}
									else
									{
										storedData.cantele.Add(steamId, GetTimeStamp() + cooldown);
										Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
										goto Finish;
									}
								}
								Finish: 
								if(storedData.lastposition.ContainsKey(steamId) |! storedData.lastposition.ContainsKey(steamId))
								{
									storedData.lastposition.Remove(steamId);
									Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
									float x = player.transform.position.x; 
									float y = player.transform.position.y;
									float z = player.transform.position.z;
									var oldinfo = new OldPosInfo(x, y, z);
									storedData.lastposition.Add(steamId, oldinfo);
									Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
									
								}
									
								SendReply(player, teleportingto,info.WarpTimer, info.WarpName);
								timer.Once(info.WarpTimer, () => { 
								if(WarpIfRunning == false && player.IsRunning())
								{
									SendReply(player, cantwarpwhilerunning);
									return;
								}
								if(WarpIfWounded == false && player.IsWounded())
								{
									SendReply(player, cantwarpwhilewounded);
									return;
								} 
								if(WarpIfSwimming == false && player.IsSwimming())
								{
									SendReply(player, cantwarpwhileswimming);
									return;
								}
								if(WarpIfBuildingBlocked == false &! player.CanBuild())
								{
									SendReply(player, cantwarpwhilebuildingblocked);
									return;
								}
								if(WarpIfDucking == false && player.IsDucked())
								{
									SendReply(player, cantwarpwhileducking);
									return;
								}
								int posx = UnityEngine.Random.Range(Convert.ToInt32(info.WarpX), info.RandomRange);
								int posz = UnityEngine.Random.Range(Convert.ToInt32(info.WarpZ), info.RandomRange);
								if(info.RandomRange == 0)
								{
									ForcePlayerPos(player, new Vector3(info.WarpX, info.WarpY, info.WarpZ));
								}
								else
									ForcePlayerPos(player, new Vector3(posx, info.WarpY, posz)); 
									SendReply(player, youhaveteleportedto, info.WarpName);
								});												 
							}
							else
							{
								SendReply(player, "You are not allowed to use this warp!");
								return; 
							}
						}
					}
					break;
					case "help":
					if(permission.UserHasPermission(player.userID.ToString(), "warpsystem.admin"))
					{
						SendReply(player, "<color=#91FFB5>Available Commands</color>");
						SendReply(player, "<color=#91FFB5>-</color> /warp <add> <WarpName> <WarpTimer> <WarpRange> <WarpMaxUses> <WarpPermissionGroup>");
						SendReply(player, "<color=#91FFB5>-</color> /warp limit");
						SendReply(player, "<color=#91FFB5>-</color> /warp random");
						SendReply(player, "<color=#91FFB5>-</color> /warp remove <WarpName>");
						SendReply(player, "<color=#91FFB5>-</color> /warp wipe");
						SendReply(player, "<color=#91FFB5>-</color> /warp list");
						SendReply(player, "<color=#91FFB5>-</color> /warp to <WarpName> || /warp list");
						SendReply(player, "<color=#91FFB5>-</color> /<WarpName> => A shorter version of /warp to <WarpName> || /warp list");
						SendReply(player, "<color=#91FFB5>Teleport all online players</color>: \n<color=#91FFB5>-</color> /warp all <WarpName>");
						SendReply(player, "<color=#91FFB5>Teleport all sleepers</color>: \n<color=#91FFB5>-</color> /warp all sleepers <WarpName>");
					}
					else
					{
						SendReply(player, "<color=#91FFB5>Available Commands</color>");
						SendReply(player, "<color=#91FFB5>-</color> /warp list");
						SendReply(player, "<color=#91FFB5>-</color> /warp limit");
						SendReply(player, "<color=#91FFB5>-</color> /warp random");
						SendReply(player, "<color=#91FFB5>-</color> /warp to <WarpName> || /warp list");
						SendReply(player, "<color=#91FFB5>-</color> /<WarpName> => A shorter version of /warp to <WarpName> || /warp list");
					}
					break;
					case "remove":
					if(!permission.UserHasPermission(player.userID.ToString(), "warpsystem.admin"))
					{
						SendReply(player, "You do not have permission to use this command!");
						return;
					}
					if(args.Length != 2) 
					{
						SendReply(player, "/warp remove <WarpName>");
						return;
					}
					foreach(WarpInfo info in storedData.WarpInfo)
					{
						if(info.WarpName.ToString() == args[1].ToString())
						{
							storedData.WarpInfo.Remove(info);
							SendReply(player, youhaveremoved, info.WarpName);
							Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
							break;
						}
					}
					break;
					
				}
			}
			
			/*void Unloaded()
			{
				storedData.cantele.Clear();
				Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
			}*/
			void OnServerCommand(ConsoleSystem.Arg arg)
			{
				if(arg == null) return;
				if(arg.connection == null) return; 
				if(arg.connection.player == null) return;
				if(arg.cmd == null) return; 
				if(arg.cmd.name == null) return;
				BasePlayer player = (BasePlayer)arg.connection.player;
				ulong steamId = player.userID;
				double nextteletime;
				string cmd = arg.cmd.namefull;
				string text = arg.GetString(0, "text");

				
				if(cmd == "chat.say" && text.StartsWith("/"))
				{
					foreach(WarpInfo info in storedData.WarpInfo)
					{ 
						if(text == "/"+info.WarpName || text == "/"+info.WarpId)
						{
							if(info.WarpPermissionGroup == "all" || permission.UserHasGroup(steamId.ToString(), info.WarpPermissionGroup))
							{
								
								if(enablecooldown == true) 
								{
									if (storedData.cantele.TryGetValue(steamId, out nextteletime))
									{  
										if(GetTimeStamp() > nextteletime)
										{
											
											storedData.cantele[steamId] = GetTimeStamp() + cooldown;
											Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
											goto Finish;
										} 
										else
										{
											int nexttele = Convert.ToInt32(GetTimeStamp() - nextteletime);
											SendReply(player, youhavetowait, nexttele.ToString().Replace("-", ""));
											return;
										}
									}
									else
									{
										storedData.cantele.Add(steamId, GetTimeStamp() + cooldown);
										Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
										goto Finish;
									}
								}
								Finish: 
								if(storedData.lastposition.ContainsKey(steamId) |! storedData.lastposition.ContainsKey(steamId))
								{
									storedData.lastposition.Remove(steamId);
									Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
									float x = player.transform.position.x; 
									float y = player.transform.position.y;
									float z = player.transform.position.z;
									var oldinfo = new OldPosInfo(x, y, z);
									storedData.lastposition.Add(steamId, oldinfo);
									Interface.GetMod().DataFileSystem.WriteObject("WarpSystem", storedData);
									
								}
									
								SendReply(player, teleportingto,info.WarpTimer, info.WarpName);
								timer.Once(info.WarpTimer, () => { 
								if(WarpIfRunning == false && player.IsRunning())
								{
									SendReply(player, cantwarpwhilerunning);
									return;
								}
								if(WarpIfWounded == false && player.IsWounded())
								{
									SendReply(player, cantwarpwhilewounded);
									return;
								} 
								if(WarpIfSwimming == false && player.IsSwimming())
								{
									SendReply(player, cantwarpwhileswimming);
									return;
								}
								if(WarpIfBuildingBlocked == false &! player.CanBuild())
								{
									SendReply(player, cantwarpwhilebuildingblocked);
									return;
								}
								if(WarpIfDucking == false && player.IsDucked())
								{
									SendReply(player, cantwarpwhileducking);
									return;
								}
									ForcePlayerPos(player, new Vector3(info.WarpX, info.WarpY, info.WarpZ)); 
									SendReply(player, youhaveteleportedto, info.WarpName);
								});												 
							}
							else
							{
								SendReply(player, "You are not allowed to use this warp!");
								return; 
							}
						}
					}
				}
				
			}
			void ForcePlayerPos(BasePlayer player, Vector3 xyz)
			{
				player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
				if(!BasePlayer.sleepingPlayerList.Contains(player))	BasePlayer.sleepingPlayerList.Add(player);
				
				player.CancelInvoke("InventoryUpdate");
				player.inventory.crafting.CancelAll(true);
				
				player.MovePosition(xyz);
				player.ClientRPCPlayer(null, player, "ForcePositionTo", xyz, null, null, null, null);
				player.TransformChanged();
				player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
				player.UpdateNetworkGroup();
				
				player.SendNetworkUpdateImmediate(false);
				player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
				player.SendFullSnapshot();
			}
	}
}

// --- End of file: WarpSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Clans (2).cs ---
// --- Original Local Path: Clans (2).cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using Rust;
using ProtoBuf;
using Facepunch.Extend;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Clans", "FuJiCuRa", "2.14.4", ResourceId = 14)]
    [Description("Clans plugin with Allies, inbuilt FriendlyFire and much more...")]
    public class Clans : RustPlugin
    {
        private bool Changed;
        private bool Initialized;
        private static Clans cc = null;
        private bool newSaveDetected = false;
        private List<ulong> manuallyEnabledBy = new List<ulong>();
        private HashSet<ulong> bypass = new HashSet<ulong>();
        private Dictionary<string, DateTime> notificationTimes = new Dictionary<string, DateTime>();
        private List<int> creationTimes = new List<int>();
        private static DateTime Epoch = new DateTime(1970, 1, 1);
        private static double MaxUnixSeconds = (DateTime.MaxValue - Epoch).TotalSeconds;
        public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
        public Dictionary<string, string> clansSearch = new Dictionary<string, string>();
        private List<string> purgedClans = new List<string>();
        private Dictionary<string, List<string>> pendingPlayerInvites = new Dictionary<string, List<string>>();
        private Regex tagReExt;
        private Dictionary<string, Clan> clanCache = new Dictionary<string, Clan>();

        private List<object> filterDefaults()
        {
            List<object> dp = new List<object>();
            dp.Add("admin");
            dp.Add("mod");
            dp.Add("owner");
            return dp;
        }

        public int limitMembers;
        private int limitModerators;
        public int limitAlliances;
        private int tagLengthMin;
        private int tagLengthMax;
        private int inviteValidDays;
        private int friendlyFireNotifyTimeout;
        private string allowedSpecialChars;
        public bool enableFFOPtion;
        private bool enableAllyFFOPtion;
        private bool enableWordFilter;
        private bool enableClanTagging;
        public bool enableClanAllies;
        private bool forceAllyFFNoDeactivate;
        private bool forceClanFFNoDeactivate;
        private bool enableWhoIsOnlineMsg;
        private bool enableComesOnlineMsg;
        private bool forceNametagsOnTagging;
        private int authLevelRename;
        private int authLevelDisband;
        private int authLevelInvite;
        private int authLevelKick;
        private int authLevelCreate;
        private int authLevelPromoteDemote;
        private int authLevelClanInfo;
        private bool purgeOldClans;
        private int notUpdatedSinceDays;
        private bool listPurgedClans;
        private bool wipeClansOnNewSave;
        private bool useProtostorageClandata;
        private string consoleName;
        private string broadcastPrefix;
        private string broadcastPrefixAlly;
        private string broadcastPrefixColor;
        private string broadcastPrefixFormat;
        private string broadcastMessageColor;
        private string colorCmdUsage;
        private string colorTextMsg;
        private string colorClanNamesOverview;
        private string colorClanFFOff;
        private string colorClanFFOn;
        private string pluginPrefix;
        private string pluginPrefixColor;
        private string pluginPrefixREBORNColor;
        private bool pluginPrefixREBORNShow;
        private string pluginPrefixFormat;
        private string clanServerColor;
        private string clanOwnerColor;
        private string clanCouncilColor;
        private string clanModeratorColor;
        private string clanMemberColor;
        private bool setHomeOwner;
        private bool setHomeModerator;
        private bool setHomeMember;
        private string chatCommandClan;
        private string chatCommandFF;
        private string chatCommandAllyChat;
        private string chatCommandClanChat;
        private string chatCommandClanInfo;
        private string subCommandClanHelp;
        private string subCommandClanAlly;
        private bool usePermGroups;
        private string permGroupPrefix;
        private bool usePermToCreateClan;
        private string permissionToCreateClan;
        private bool usePermToJoinClan;
        private string permissionToJoinClan;
        private string clanTagColorBetterChat;
        private int clanTagSizeBetterChat;
        private string clanTagOpening;
        private string clanTagClosing;
        private bool clanChatDenyOnMuted;
        public static bool useRelationshipManager;
        private bool teamUiWasDisabled;
        private bool useRankColorsPanel;
        private bool disableManageFunctions;
        private bool allowButtonLeave;
        private bool allowButtonKick;
        private bool allowDirectInvite;
        private bool allowPromoteLeader;
        private bool logClanChanges;

        private List<object> wordFilter = new List<object>();

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string, object> data = Config[menu] as Dictionary<string,
                object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        private void LoadVariables()
        {
            bool configremoval = false;
            wordFilter = (List<object>) GetConfig("WordFilter", "Words", filterDefaults());
            limitMembers = Convert.ToInt32(GetConfig("Limits", "limitMembers", 8));
            limitModerators = Convert.ToInt32(GetConfig("Limits", "limitModerators", 2));
            limitAlliances = Convert.ToInt32(GetConfig("Limits", "limitAlliances", 2));
            tagLengthMin = Convert.ToInt32(GetConfig("Limits", "tagLengthMin", 2));
            tagLengthMax = Convert.ToInt32(GetConfig("Limits", "tagLengthMax", 6));
            inviteValidDays = Convert.ToInt32(GetConfig("Limits", "inviteValidDays", 1));
            friendlyFireNotifyTimeout = Convert.ToInt32(GetConfig("Limits", "friendlyFireNotifyTimeout", 5));
            allowedSpecialChars = Convert.ToString(GetConfig("Limits", "allowedSpecialChars", "!²³"));
            enableFFOPtion = Convert.ToBoolean(GetConfig("Settings", "enableFFOPtion", true));
            enableAllyFFOPtion = Convert.ToBoolean(GetConfig("Settings", "enableAllyFFOPtion", true));
            forceAllyFFNoDeactivate = Convert.ToBoolean(GetConfig("Settings", "forceAllyFFNoDeactivate", true));
            forceClanFFNoDeactivate = Convert.ToBoolean(GetConfig("Settings", "forceClanFFNoDeactivate", false));
            enableWordFilter = Convert.ToBoolean(GetConfig("Settings", "enableWordFilter", true));
            enableClanTagging = Convert.ToBoolean(GetConfig("Settings", "enableClanTagging", true));
            forceNametagsOnTagging = Convert.ToBoolean(GetConfig("Settings", "forceNametagsOnTagging", false));
            enableClanAllies = Convert.ToBoolean(GetConfig("Settings", "enableClanAllies", false));
            enableWhoIsOnlineMsg = Convert.ToBoolean(GetConfig("Settings", "enableWhoIsOnlineMsg", true));
            enableComesOnlineMsg = Convert.ToBoolean(GetConfig("Settings", "enableComesOnlineMsg", true));
            logClanChanges = Convert.ToBoolean(GetConfig("Settings", "logClanChanges", false));
            useProtostorageClandata = Convert.ToBoolean(GetConfig("Storage", "useProtostorageClandata", false));
            setHomeOwner = Convert.ToBoolean(GetConfig("NTeleportation", "setHomeOwner", true));
            setHomeModerator = Convert.ToBoolean(GetConfig("NTeleportation", "setHomeModerator", true));
            setHomeMember = Convert.ToBoolean(GetConfig("NTeleportation", "setHomeMember", true));
            authLevelRename = Convert.ToInt32(GetConfig("Permission", "authLevelRename", 1));
            authLevelDisband = Convert.ToInt32(GetConfig("Permission", "authLevelDisband", 2));
            authLevelInvite = Convert.ToInt32(GetConfig("Permission", "authLevelInvite", 1));
            authLevelKick = Convert.ToInt32(GetConfig("Permission", "authLevelKick", 2));
            authLevelCreate = Convert.ToInt32(GetConfig("Permission", "authLevelCreate", 2));
            authLevelPromoteDemote = Convert.ToInt32(GetConfig("Permission", "authLevelPromoteDemote", 1));
            authLevelClanInfo = Convert.ToInt32(GetConfig("Permission", "authLevelClanInfo", 0));
            usePermGroups = Convert.ToBoolean(GetConfig("Permission", "usePermGroups", false));
            permGroupPrefix = Convert.ToString(GetConfig("Permission", "permGroupPrefix", "clan_"));
            usePermToCreateClan = Convert.ToBoolean(GetConfig("Permission", "usePermToCreateClan", false));
            permissionToCreateClan = Convert.ToString(GetConfig("Permission", "permissionToCreateClan", "clans.cancreate"));
            usePermToJoinClan = Convert.ToBoolean(GetConfig("Permission", "usePermToJoinClan", false));
            permissionToJoinClan = Convert.ToString(GetConfig("Permission", "permissionToJoinClan", "clans.canjoin"));
            purgeOldClans = Convert.ToBoolean(GetConfig("Purge", "purgeOldClans", false));
            notUpdatedSinceDays = Convert.ToInt32(GetConfig("Purge", "notUpdatedSinceDays", 14));
            listPurgedClans = Convert.ToBoolean(GetConfig("Purge", "listPurgedClans", false));
            wipeClansOnNewSave = Convert.ToBoolean(GetConfig("Purge", "wipeClansOnNewSave", false));
            consoleName = Convert.ToString(GetConfig("Formatting", "consoleName", "ServerOwner"));
            broadcastPrefix = Convert.ToString(GetConfig("Formatting", "broadcastPrefix", "(CLAN)"));
            broadcastPrefixAlly = Convert.ToString(GetConfig("Formatting", "broadcastPrefixAlly", "(ALLY)"));
            broadcastPrefixColor = Convert.ToString(GetConfig("Formatting", "broadcastPrefixColor", "#a1ff46"));
            broadcastPrefixFormat = Convert.ToString(GetConfig("Formatting", "broadcastPrefixFormat", "<color={0}>{1}</color> "));
            broadcastMessageColor = Convert.ToString(GetConfig("Formatting", "broadcastMessageColor", "#e0e0e0"));
            colorCmdUsage = Convert.ToString(GetConfig("Formatting", "colorCmdUsage", "#ffd479"));
            colorTextMsg = Convert.ToString(GetConfig("Formatting", "colorTextMsg", "#e0e0e0"));
            colorClanNamesOverview = Convert.ToString(GetConfig("Formatting", "colorClanNamesOverview", "#b2eece"));
            colorClanFFOff = Convert.ToString(GetConfig("Formatting", "colorClanFFOff", "#00ff00"));
            colorClanFFOn = Convert.ToString(GetConfig("Formatting", "colorClanFFOn", "#ff0000"));
            pluginPrefix = Convert.ToString(GetConfig("Formatting", "pluginPrefix", "CLANS"));
            pluginPrefixColor = Convert.ToString(GetConfig("Formatting", "pluginPrefixColor", "#ffa500"));
            pluginPrefixREBORNColor = Convert.ToString(GetConfig("Formatting", "pluginPrefixREBORNColor", "#ce422b"));
            pluginPrefixREBORNShow = Convert.ToBoolean(GetConfig("Formatting", "pluginPrefixREBORNShow", true));
            pluginPrefixFormat = Convert.ToString(GetConfig("Formatting", "pluginPrefixFormat", "<color={0}>{1}</color>: "));
            clanServerColor = Convert.ToString(GetConfig("Formatting", "clanServerColor", "#ff3333"));
            clanOwnerColor = Convert.ToString(GetConfig("Formatting", "clanOwnerColor", "#a1ff46"));
            clanCouncilColor = Convert.ToString(GetConfig("Formatting", "clanCouncilColor", "#b573ff"));
            clanModeratorColor = Convert.ToString(GetConfig("Formatting", "clanModeratorColor", "#74c6ff"));
            clanMemberColor = Convert.ToString(GetConfig("Formatting", "clanMemberColor", "#fcf5cb"));
            clanTagColorBetterChat = Convert.ToString(GetConfig("BetterChat", "clanTagColorBetterChat", "#aaff55"));
            clanTagSizeBetterChat = Convert.ToInt32(GetConfig("BetterChat", "clanTagSizeBetterChat", 15));
            clanTagOpening = Convert.ToString(GetConfig("BetterChat", "clanTagOpening", "["));
            clanTagClosing = Convert.ToString(GetConfig("BetterChat", "clanTagClosing", "]"));
            clanChatDenyOnMuted = Convert.ToBoolean(GetConfig("BetterChat", "clanChatDenyOnMuted", false));
            chatCommandClan = Convert.ToString(GetConfig("Commands", "chatCommandClan", "clan"));
            chatCommandFF = Convert.ToString(GetConfig("Commands", "chatCommandFF", "cff"));
            chatCommandAllyChat = Convert.ToString(GetConfig("Commands", "chatCommandAllyChat", "a"));
            chatCommandClanChat = Convert.ToString(GetConfig("Commands", "chatCommandClanChat", "c"));
            chatCommandClanInfo = Convert.ToString(GetConfig("Commands", "chatCommandClanInfo", "cinfo"));
            subCommandClanHelp = Convert.ToString(GetConfig("Commands", "subCommandClanHelp", "help"));
            subCommandClanAlly = Convert.ToString(GetConfig("Commands", "subCommandClanAlly", "ally"));
            useRelationshipManager = Convert.ToBoolean(GetConfig("Teaming", "useRelationshipManager", false));
            useRankColorsPanel = Convert.ToBoolean(GetConfig("Teaming", "useRankColorsPanel", true));
            disableManageFunctions = Convert.ToBoolean(GetConfig("Teaming", "disableManageFunctions", false));
            allowButtonLeave = Convert.ToBoolean(GetConfig("Teaming", "allowButtonLeave", true));
            allowButtonKick = Convert.ToBoolean(GetConfig("Teaming", "allowButtonKick", true));
            allowDirectInvite = Convert.ToBoolean(GetConfig("Teaming", "allowDirectInvite", true));
            allowPromoteLeader = Convert.ToBoolean(GetConfig("Teaming", "allowPromoteLeader", true));

            if ((Config.Get("Permission") as Dictionary<string, object>).ContainsKey("authLevelDelete"))
            {
                (Config.Get("Permission") as Dictionary<string, object>).Remove("authLevelDelete");
                configremoval = true;
            }

            SaveConf();

            if (!Changed && !configremoval)
                return;

            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {
                    "nopermtocreate",
                    "You got no rights to create a clan"
                },
                {
                    "nopermtojoin",
                    "You got no rights to join a clan"
                },
                {
                    "nopermtojoinbyinvite",
                    "The player {0} has no rights to join a clan"
                },
                {
                    "claninvite",
                    "You have been invited to join the clan: [{0}] '{1}'\nTo join, type: <color={2}>/clan join {0}</color>"
                },
                {
                    "comeonline",
                    "{0} has come online!"
                },
                {
                    "goneoffline",
                    "{0} has gone offline!"
                },
                {
                    "friendlyfire",
                    "{0} is a clan member and cannot be hurt.\nTo toggle clan friendlyfire type: <color={1}>/clan ff</color>"
                },
                {
                    "allyfriendlyfire",
                    "{0} is an ally member and cannot be hurt"
                },
                {
                    "notmember",
                    "You are currently not a member of a clan"
                },
                {
                    "youareownerof",
                    "You are the owner of:"
                },
                {
                    "youaremodof",
                    "You are a moderator of:"
                },
                {
                    "youarecouncilof",
                    "You are a council of:"
                },
                {
                    "youarememberof",
                    "You are a member of:"
                },
                {
                    "claninfo",
                    " [{0}] {1}"
                },
                {
                    "memberon",
                    "Members online: "
                },
                {
                    "overviewnamecolor",
                    "<color={0}>{1}</color>"
                },
                {
                    "memberoff",
                    "Members offline: "
                },
                {
                    "notmoderator",
                    "You need to be a moderator of your clan to use this command"
                },
                {
                    "pendinvites",
                    "Pending invites: "
                },
                {
                    "bannedwords",
                    "The clan tag contains banned words"
                },
                {
                    "viewthehelp",
                    "To view more commands, type: <color={0}>/{1} help</color>"
                },
                {
                    "usagecreate",
                    "Usage - <color={0}>/clan create \"TAG\" \"Description\"</color>"
                },
                {
                    "hintlength",
                    "Clan tags must be {0} to {1} characters long"
                },
                {
                    "hintchars",
                    "Clan tags must contain only 'a-z' 'A-Z' '0-9' '{0}'"
                },
                {
                    "providedesc",
                    "Please provide a short description of your clan (No RichText allowed)"
                },
                {
                    "tagblocked",
                    "There is already a clan with this tag"
                },
                {
                    "nownewowner",
                    "You are now the owner of the clan [{0}] \"{1}\""
                },
                {
                    "inviteplayers",
                    "To invite new members, type: <color={0}>/clan invite <partialNameOrId></color>"
                },
                {
                    "usageinvite",
                    "Usage - <color={0}>/clan invite <partialNameOrId></color>"
                },
                {
                    "nosuchplayer",
                    "No such player|id or name not unique: {0}"
                },
                {
                    "alreadymember",
                    "This player is already a member of your clan: {0}"
                },
                {
                    "alreadyinvited",
                    "This player has already been invited to your clan: {0}"
                },
                {
                    "alreadyinclan",
                    "This player is already in a clan: {0}"
                },
                {
                    "invitebroadcast",
                    "{0} invited {1} to the clan"
                },
                {
                    "usagewithdraw",
                    "Usage: <color={0}>/clan withdraw <partialNameOrId></color>"
                },
                {
                    "notinvited",
                    "This player has not been invited to your clan: {0}"
                },
                {
                    "canceledinvite",
                    "{0} canceled the invitation of {1}"
                },
                {
                    "usagejoin",
                    "Usage: <color={0}>/clan join \"clantag\"</color>"
                },
                {
                    "youalreadymember",
                    "You are already a member of a clan"
                },
                {
                    "younotinvited",
                    "You have not been invited to join this clan"
                },
                {
                    "reachedmaximum",
                    "This clan has already reached the maximum number of members"
                },
                {
                    "broadcastformat",
                    "<color={0}>{1}</color>: {2}"
                },
                {
                    "allybroadcastformat",
                    "[{0}] <color={1}>{2}</color>: {3}"
                },
                {
                    "clanrenamed",
                    "{0} renamed your clan to: [{1}]"
                },
                {
                    "yourenamed",
                    "You have renamed the clan [{0}] to [{1}]"
                },
                {
                    "youcreated",
                    "You have created the clan [{0}]"
                },
                {
                    "clandeleted",
                    "{0} deleted your clan"
                },
                {
                    "youdeleted",
                    "You have deleted the clan [{0}]"
                },
                {
                    "noclanfound",
                    "There is no clan with that tag [{0}]"
                },
                {
                    "renamerightsowner",
                    "You need to be a server owner to rename clans"
                },
                {
                    "deleterightsowner",
                    "You need to be a server owner to delete clans"
                },
                {
                    "clandisbanded",
                    "Your current clan has been disbanded forever"
                },
                {
                    "needclanowner",
                    "You need to be the owner of your clan to use this command"
                },
                {
                    "needclanownercouncil",
                    "You need to be the owner or a council to use this command"
                },
                {
                    "usagedisband",
                    "Usage: <color={0}>/clan disband forever</color>"
                },
                {
                    "usagepromote",
                    "Usage: <color={0}>/clan promote <partialNameOrId></color>"
                },
                {
                    "playerjoined",
                    "{0} has joined the clan!"
                },
                {
                    "waskicked",
                    "{0} kicked {1} from the clan"
                },
                {
                    "werekicked",
                    "{0} kicked you from the clan"
                },
                {
                    "modownercannotkicked",
                    "The player {0} is an owner or moderator and cannot be kicked"
                },
                {
                    "ownercannotbepromoted",
                    "The player {0} is the owner and cannot be promoted"
                },
                {
                    "ownercannotbedemoted",
                    "The player {0} is the owner and cannot be demoted"
                },
                {
                    "notmembercannotkicked",
                    "The player {0} is not a member of your clan"
                },
                {
                    "usageff",
                    "Usage: <color={0}>/clan ff</color> toggles your current FriendlyFire status"
                },
                {
                    "usagekick",
                    "Usage: <color={0}>/clan kick <partialNameOrId></color>"
                },
                {
                    "playerleft",
                    "{0} has left the clan"
                },
                {
                    "youleft",
                    "You have left your current clan"
                },
                {
                    "usageleave",
                    "Usage: <color={0}>/clan leave</color>"
                },
                {
                    "notaclanmember",
                    "The player {0} is not a member of your clan"
                },
                {
                    "alreadyowner",
                    "The player {0} is already the owner of your clan"
                },
                {
                    "alreadyamod",
                    "The player {0} is already a moderator of your clan"
                },
                {
                    "alreadyacouncil",
                    "The player {0} is already a council of your clan"
                },
                {
                    "alreadyacouncilset",
                    "The position of the council is already awarded"
                },
                {
                    "maximummods",
                    "This clan has already reached the maximum number of moderators"
                },
                {
                    "playerpromoted",
                    "{0} promoted {1} to moderator"
                },
                {
                    "playerpromotedcouncil",
                    "{0} promoted {1} to council"
                },
                {
                    "playerpromotedowner",
                    "{0} promoted {1} to new owner"
                },
                {
                    "usagedemote",
                    "Usage: <color={0}>/clan demote <name></color>"
                },
                {
                    "notamoderator",
                    "The player {0} is not a moderator of your clan"
                },
                {
                    "notpromoted",
                    "The player {0} is not a moderator or council of your clan"
                },
                {
                    "playerdemoted",
                    "{0} demoted {1} to a member"
                },
                {
                    "councildemoted",
                    "{0} demoted {1} to a moderator"
                },
                {
                    "noactiveally",
                    "Your clan has no current alliances"
                },
                {
                    "yourffstatus",
                    "Your FriendlyFire:"
                },
                {
                    "yourclanallies",
                    "Your Clan allies:"
                },
                {
                    "allyinvites",
                    "Ally invites:"
                },
                {
                    "allypending",
                    "Ally requests:"
                },
                {
                    "allyReqHelp",
                    "Offer an alliance to another clan"
                },
                {
                    "allyAccHelp",
                    "Accept an alliance from another clan"
                },
                {
                    "allyDecHelp",
                    "Decline an alliance from another clan"
                },
                {
                    "allyCanHelp",
                    "Cancel an alliance with another clan"
                },
                {
                    "reqAlliance",
                    "[{0}] has requested a clan alliance"
                },
                {
                    "invitePending",
                    "You already have a pending alliance invite for [{0}]"
                },
                {
                    "clanNoExist",
                    "The clan [{0}] does not exist"
                },
                {
                    "alreadyAllies",
                    "You are already allied with"
                },
                {
                    "allyProvideName",
                    "You need to provide a Clan name"
                },
                {
                    "allyLimit",
                    "You already have the maximum allowed ally limit"
                },
                {
                    "allyAccLimit",
                    "You can not accept the alliance with {0}. You reached the limit"
                },
                {
                    "allyCancel",
                    "You have cancelled your alliance with [{0}]"
                },
                {
                    "allyCancelSucc",
                    "{0} has cancelled your clan alliance"
                },
                {
                    "noAlly",
                    "Your clans have no alliance with each other"
                },
                {
                    "noAllyInv",
                    "You do not have a alliance invite from [{0}]"
                },
                {
                    "allyInvWithdraw",
                    "You have cancelled your request to [{0}]"
                },
                {
                    "allyDeclined",
                    "You have declined the clan alliance from [{0}]"
                },
                {
                    "allyDeclinedSucc",
                    "[{0}] has declined your alliance request"
                },
                {
                    "allyReq",
                    "You have requested a clan alliance from [{0}]"
                },
                {
                    "allyAcc",
                    "You have accepted the clan alliance from [{0}]"
                },
                {
                    "allyAccSucc",
                    "[{0}] has accepted your alliance request"
                },
                {
                    "allyPendingInfo",
                    "Your clan has pending ally request(s). Check those in the clan overview"
                },
                {
                    "clanffdisabled",
                    "You have <color={0}>disabled</color> friendly fire for your clan.\nThey are safe!"
                },
                {
                    "clanffenabled",
                    "You have <color={0}>enabled</color> friendly fire for your clan.\nTake care!"
                },
                {
                    "yourname",
                    "YOU"
                },
                {
                    "helpavailablecmds",
                    "Available commands:"
                },
                {
                    "helpinformation",
                    "Display your clan information"
                },
                {
                    "helpmessagemembers",
                    "Send a message to all members"
                },
                {
                    "helpmessageally",
                    "Send a message to all allied members"
                },
                {
                    "helpcreate",
                    "Create a new clan"
                },
                {
                    "helpjoin",
                    "Join a clan by invitation"
                },
                {
                    "helpleave",
                    "Leave your clan"
                },
                {
                    "helptoggleff",
                    "Toggle friendlyfire status"
                },
                {
                    "helpinvite",
                    "Invite a player"
                },
                {
                    "helpwithdraw",
                    "Cancel an invite"
                },
                {
                    "helpkick",
                    "Kick a member"
                },
                {
                    "helpallyoptions",
                    "Lists the ally options"
                },
                {
                    "helppromote",
                    "Promote a member"
                },
                {
                    "helpdemote",
                    "Demote a member"
                },
                {
                    "helpdisband",
                    "Disband your clan (no undo)"
                },
                {
                    "helpmoderator",
                    "Moderator"
                },
                {
                    "helpowner",
                    "Owner"
                },
                {
                    "helpcommands",
                    "commands:"
                },
                {
                    "helpconsole",
                    "Open F1 console and type:"
                },
                {
                    "clanArgCreate",
                    "create"
                },
                {
                    "clanArgInvite",
                    "invite"
                },
                {
                    "clanArgLeave",
                    "leave"
                },
                {
                    "clanArgWithdraw",
                    "withdraw"
                },
                {
                    "clanArgJoin",
                    "join"
                },
                {
                    "clanArgPromote",
                    "promote"
                },
                {
                    "clanArgDemote",
                    "demote"
                },
                {
                    "clanArgFF",
                    "ff"
                },
                {
                    "clanArgAlly",
                    "ally"
                },
                {
                    "clanArgHelp",
                    "help"
                },
                {
                    "clanArgKick",
                    "kick"
                },
                {
                    "clanArgDisband",
                    "disband"
                },
                {
                    "clanArgForever",
                    "forever"
                },
                {
                    "clanArgNameId",
                    "<partialNameOrId>"
                },
                {
                    "allyArgRequest",
                    "request"
                },
                {
                    "allyArgRequestShort",
                    "req"
                },
                {
                    "allyArgAccept",
                    "accept"
                },
                {
                    "allyArgAcceptShort",
                    "acc"
                },
                {
                    "allyArgDecline",
                    "decline"
                },
                {
                    "allyArgDeclineShort",
                    "dec"
                },
                {
                    "allyArgCancel",
                    "cancel"
                },
                {
                    "allyArgCancelShort",
                    "can"
                },
                {
                    "clanchatmuted",
                    "You may not clanchat, you are muted"
                },
            }, this);
        }

        private void Init()
        {
            LoadVariables();
            if (clanTagOpening == null || clanTagOpening.Length > 1 || clanTagOpening == "<" || clanTagOpening == ">")
                clanTagOpening = "[";

            if (clanTagClosing == null || clanTagClosing.Length > 1 || clanTagClosing == "<" || clanTagClosing == ">")
                clanTagClosing = "]";

            LoadDefaultMessages();

            Initialized = false;

            permission.RegisterPermission(permissionToCreateClan, this);
            permission.RegisterPermission(permissionToJoinClan, this);

            cmd.AddChatCommand(chatCommandFF, this, "cmdChatClanFF");
            cmd.AddChatCommand(chatCommandClan, this, "cmdChatClan");
            cmd.AddConsoleCommand(chatCommandClan, this, "ccmdChatClan");
            cmd.AddChatCommand(chatCommandClanChat, this, "cmdChatClanchat");
            cmd.AddChatCommand(chatCommandAllyChat, this, "cmdChatAllychat");
            cmd.AddChatCommand(chatCommandClanInfo, this, "cmdChatClanInfo");
            cmd.AddChatCommand(chatCommandClan + subCommandClanHelp, this, "cmdChatClanHelp");
            cmd.AddChatCommand(chatCommandClan + subCommandClanAlly, this, "cmdChatClanAlly");

            if (enableClanTagging)
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }

        private void Loaded()
        {
            cc = this;
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void OnNewSave()
        {
            if (wipeClansOnNewSave)
                newSaveDetected = true;
        }

        private void Unload()
        {
            if (!Initialized)
                return;

            SaveData();

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                DoCleanUp(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                DoCleanUp(player);

            foreach (KeyValuePair<string, Clan> clan in clans.ToList())
            {
                clans[clan.Key].OnUnload();
                clans[clan.Key] = null;
            }

            cc = null;
        }

        private void OnServerInitialized()
        {
            teamUiWasDisabled = false;
            if (useRelationshipManager)
            {
                Subscribe(nameof(OnServerCommand));
                if (!RelationshipManager.TeamsEnabled())
                {
                    teamUiWasDisabled = true;
                    PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{RelationshipManager.maxTeamSize}'");
                }
            }
            else
            {
                Unsubscribe(nameof(OnServerCommand));
            }

            if (enableClanTagging)
                Subscribe(nameof(OnPluginLoaded));
            else Unsubscribe(nameof(OnPluginLoaded));

            object obj = LoadData();

            Rust.Global.Runner.StartCoroutine(ServerInitialized(obj));
        }

        private IEnumerator ServerInitialized(object obj)
        {
            if (obj != null)
                InitializeClans((bool) obj);

            if (purgeOldClans)
                Puts($"Valid clans loaded: '{clans.Count}'");

            if (purgeOldClans && purgedClans.Count() > 0)
            {
                Puts($"Old Clans purged: '{purgedClans.Count}'");
                if (listPurgedClans)
                {
                    foreach (string purged in purgedClans)
                        Puts($"Purged > {purged}");
                }
            }

            yield return CoroutineEx.waitForSeconds(2f);

            AllyRemovalCheck();


            tagReExt = new Regex("[^a-zA-Z0-9" + allowedSpecialChars + "]");
                        
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                SetupPlayer(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                SetupPlayer(player);

            foreach (KeyValuePair<string, Clan> clan in clans)
                clan.Value.OnUpdate(true);

            Initialized = true;
            yield return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (useRelationshipManager && arg != null && arg.cmd != null)
            {
                if (RelationshipManager.TeamsEnabled() || teamUiWasDisabled)
                {
                    if (arg.cmd.Name.ToLower() == "maxteamsize" && arg.FullString != string.Empty)
                    {
                        int i = arg.GetInt(0, 0);
                        if (i > 0 && teamUiWasDisabled)
                        {
                            teamUiWasDisabled = false;
                            Puts($"TeamUI functions full activated");
                            return null;
                        }
                        else if (i < 1)
                        {
                            teamUiWasDisabled = true;
                            PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{i}'");
                            return null;
                        }
                    }

                    Clan obj;
                    if (!RelationshipManager.TeamsEnabled())
                        return null;

                    if (arg.Connection != null && clanCache.TryGetValue(arg.Connection.userid.ToString(), out obj) && arg.cmd.Parent.ToLower() == "relationshipmanager")
                    {
                        if (disableManageFunctions)
                            return false;

                        if (arg.cmd.Name.ToLower() == "leaveteam" && allowButtonLeave)
                        {
                            LeaveClan(arg.Player());
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "kickmember" && allowButtonKick)
                        {
                            KickPlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "sendinvite" && allowDirectInvite)
                        {
                            InvitePlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "promote" && allowPromoteLeader)
                        {
                            BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(arg.Player());
                            if (lookingAtPlayer == null || lookingAtPlayer.IsDead() || lookingAtPlayer == arg.Player())
                                return false;

                            if (lookingAtPlayer.currentTeam == arg.Player().currentTeam)
                            {
                                bool wasCouncil = obj.IsCouncil(lookingAtPlayer.UserIDString);
                                bool wasMod = obj.IsModerator(lookingAtPlayer.UserIDString);

                                if (wasCouncil && !wasMod)
                                    obj.council = arg.Player().UserIDString;

                                if (wasMod && !wasCouncil)
                                {
                                    obj.RemoveModerator(lookingAtPlayer);
                                    obj.SetModerator(arg.Player());
                                }

                                obj.owner = lookingAtPlayer.UserIDString;
                                obj.BroadcastLoc("playerpromotedowner", obj.GetColoredName(arg.Player().UserIDString, arg.Connection.username), obj.GetColoredName(lookingAtPlayer.UserIDString, obj.FindClanMember(lookingAtPlayer.UserIDString).Name));
                                obj.OnUpdate(true);
                            }
                            return false;
                        }
                    }
                }
            }

            return null;
        }

        private void SaveConf()
        {
            if (Author != r("ShWvPhEn"))
                Author = r("Cvengrq Sebz ShWvPhEn");
        }

        private static string r(string i)
        {
            return !string.IsNullOrEmpty(i) ? new string(i.Select(x => x >= 'a' && x <= 'z' ? (char) ((x - 'a' + 13) % 26 + 'a') : x >= 'A' && x <= 'Z' ? (char) ((x - 'A' + 13) % 26 + 'A') : x).ToArray()) : i;
        }

        private object LoadData()
        {
            StoredData protoStorage = new StoredData();
            StoredData jsonStorage = new StoredData();
            StoredData oldStorage = new StoredData();
            bool protoFileFound = ProtoStorage.Exists(new string[] {Title});
            bool jsonFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile(Title);
            bool oldFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile("rustio_clans");
            if (!protoFileFound && !jsonFileFound)
            {
                oldStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");
            }
            else
            {
                if (jsonFileFound)
                    jsonStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);

                if (protoFileFound)
                {
                    protoStorage = ProtoStorage.Load<StoredData>(new string[]
                      {
                        Title
                      });
                }
            }

            bool lastwasProto = protoStorage.lastStorage == "proto" && (protoStorage.saveStamp > jsonStorage.saveStamp || protoStorage.saveStamp > oldStorage.saveStamp);

            if (useProtostorageClandata)
            {
                if (lastwasProto)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] {Title}) ?? new StoredData();
                }
                else
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
            }
            else
            {
                if (!lastwasProto)
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
                else if (protoFileFound)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] {Title}) ?? new StoredData();
                }
            }

            if (wipeClansOnNewSave && newSaveDetected)
            {
                if (useProtostorageClandata)
                    ProtoStorage.Save<StoredData>(clanSaves, new string[] {Title + ".bak"});
                else Interface.Oxide.DataFileSystem.WriteObject(Title + ".bak", clanSaves);

                Puts("New save detected > Created backup of clans and wiped datafile");
                clans = new Dictionary<string, Clan>();
                clansSearch = new Dictionary<string, string>();
                return null;
            }

            clans = new Dictionary<string, Clan>();
            clansSearch = new Dictionary<string, string>();

            if (clanSaves.clans == null || clanSaves.clans.Count == 0)
                return null;

            clans = clanSaves.clans;
            return !jsonFileFound && !protoFileFound;
        }

        private void InitializeClans(bool newFileFound)
        {
            Puts("Loading clans data");
            Dictionary<string, int> clanDuplicates = new Dictionary<string, int>();
            List<string> clanDuplicateCount = new List<string>();
            foreach (KeyValuePair<string, Clan> _clan in clans.ToList())
            {
                Clan clan = _clan.Value;
                if (purgeOldClans && UnixTimeStampUTC() - clan.updated > notUpdatedSinceDays * 86400)
                {
                    purgedClans.Add($"[{clan.tag}] | {clan.description} | Owner: {clan.owner} | LastUpd: {UnixTimeStampToDateTime(clan.updated)}");

                    if (permission.GroupExists(permGroupPrefix + clan.tag))
                    {
                        foreach (string member in clan.members.ToList())
                        {
                            if (permission.UserHasGroup(member, permGroupPrefix + clan.tag))
                                permission.RemoveUserGroup(member, permGroupPrefix + clan.tag);
                        }
                        permission.RemoveGroup(permGroupPrefix + clan.tag);
                    }

                    RemoveClan(clan.tag);
                    clan = null;
                    continue;
                }

                foreach (string member in clan.members.ToList())
                {
                    IPlayer p = covalence.Players.FindPlayerById(member);

                    if (!(p is IPlayer) || p == null || p.Name == "")
                        clan.RemoveMember(member);
                    else clan.AddIPlayer(p);
                }

                if (clan.members.Count() < 1)
                {
                    RemoveClan(clan.tag);
                    clan = null;
                    continue;
                }

                clan.created = TakeCreatedTime(clan.created);

                if (clan.updated == 0 || clan.updated < clan.created)
                    clan.updated = clan.created;

                clansSearch[clan.tag.ToLower()] = clan.tag;
                clan.ValidateOwner();

                if (!enableClanAllies || enableClanAllies && clan.council != null && !clan.IsMember(clan.council))
                    clan.council = null;

                if (usePermGroups && !permission.GroupExists(permGroupPrefix + clan.tag))
                    permission.CreateGroup(permGroupPrefix + clan.tag, "Clan " + clan.tag, 0);

                foreach (string member in clan.members.ToList())
                {
                    if (usePermGroups && !permission.UserHasGroup(member, permGroupPrefix + clan.tag))
                        permission.AddUserGroup(member, permGroupPrefix + clan.tag);
                }

                foreach (KeyValuePair<string, int> invited in clan.invites.ToList())
                {
                    if (UnixTimeStampUTC() - (int)invited.Value > inviteValidDays * 86400)
                        clan.RemoveInvite(invited.Key);
                }

                clanCache[clan.owner] = clan;

                foreach (string member in clan.members.ToList())
                {
                    if (!clanDuplicates.ContainsKey(member))
                    {
                        clanDuplicates.Add(member, 1);
                        clanCache[member] = clan;
                        continue;
                    }
                    else
                    {
                        clanDuplicates[member] += 1;
                        if (!clanDuplicateCount.Contains(member)) clanDuplicateCount.Add(member);
                    }

                    clanCache[member] = clan;
                }

                foreach (KeyValuePair<string, int> invite in clan.invites)
                {
                    if (!pendingPlayerInvites.ContainsKey(invite.Key))
                        pendingPlayerInvites.Add(invite.Key, new List<string>());
                    pendingPlayerInvites[invite.Key].Add(clan.tag);
                }
            }

            if (clanDuplicateCount.Count > 0)
                PrintWarning($"Found '{clanDuplicateCount.Count()}' player(s) in multiple clans. Check `clans.showduplicates`");

            Puts($"Loaded data with '{clans.Count}' valid Clans and overall '{clanCache.Count}' Members");

            if (newFileFound)
                SaveData(true);

            if (enableClanTagging && !forceNametagsOnTagging)
                Puts($"'forceNametagsOnTagging' is disabled. Clan TAG's might not instant update for sleepers/off-liners");
        }

        public static int TakeCreatedTime(int stamp)
        {
            if (stamp == 0)
                stamp = UnixTimeStampUTC();

            while (cc.creationTimes.Contains(stamp))
                stamp += 1;

            cc.creationTimes.Add(stamp);
            return stamp;
        }

        private void SaveData(bool force = false)
        {
            if (!Initialized && !force)
                return;

            clanSaves.clans = clans;
            clanSaves.saveStamp = UnixTimeStampUTC();
            clanSaves.lastStorage = useProtostorageClandata ? "proto" : "json";

            if (useProtostorageClandata)
                ProtoStorage.Save<StoredData>(clanSaves, new string[] {Title});
            else Interface.Oxide.DataFileSystem.WriteObject(Title, clanSaves);
        }

        public Clan findClan(string tag)
        {
            Clan clan;
            if (tag.Length > 0 && TryGetClan(tag, out clan))
                return clan;
            return null;
        }

        public Clan findClanByUser(string userId)
        {
            Clan clan;
            if (clanCache.TryGetValue(userId, out clan))
                return clan;
            return null;
        }

        private Clan SetupPlayer(BasePlayer player, IPlayer current = null, bool hasLeft = false, Clan clan = null, bool teamForced = false, string oldTag = null)
        {
            if (player == null)
                return null;

            if (current == null)
                current = covalence.Players.FindPlayerById(player.UserIDString);

            if (current == null)
                return null;

            bool prevName = false;

            if (clan == null && !hasLeft)
                clan = findClanByUser(current.Id);

            bool flag = false;
            string oldName = player.displayName;

            if (clan == null || hasLeft)
            {
                if (enableClanTagging && hasLeft && oldTag != null)
                {
                    string name = player.displayName.Replace($"[{oldTag}] ", "");
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                if (useRelationshipManager)
                    flag = NullClanTeam(player);
                clan = null;
            }
            else
            {
                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"[{(oldTag != null ? oldTag : clan.tag)}] ", "");
                    name = $"[{clan.tag}] {name}";
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                clan.AddIPlayer(current);
                clan.AddBasePlayer(player);
            }

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = true;

            if (flag || prevName)
                player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = false;

            return clan;
        }

        private bool NullClanTeam(BasePlayer player)
        {
            bool flag = false;
            if (player.currentTeam != 0UL)
            {
                RelationshipManager.PlayerTeam team = RelationshipManager.Instance.FindTeam(player.currentTeam);
                if (team == null)
                {
                    player.currentTeam = 0UL;
                    player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                    flag = true;
                }
            }
            else if (player.currentTeam == 0UL)
            {
                player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                flag = true;
            }

            return flag;
        }

        private void DoCleanUp(BasePlayer player)
        {
            if (player == null)
                return;

            Clan clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (useRelationshipManager)
                {
                    RelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindTeam(player.currentTeam);
                    playerTeam?.RemovePlayer(player.userID);

                    player.ClearTeam();
                    RelationshipManager.Instance.playerToTeam.Remove(player.userID);
                }

                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"[{clan.tag}] ", "");
                    player.displayName = name;

                    if (player.net != null)
                        player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                }

                if (!Interface.Oxide.IsShuttingDown)
                {                    
                    if (forceNametagsOnTagging)
                        player.limitNetworking = true;

                    player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                    if (forceNametagsOnTagging)
                        player.limitNetworking = false;
                }
            }
        }

        private void setupPlayers(List<string> playerIds, bool isDisband = false, Clan oldClan = null, string tag = null)
        {
            foreach (string playerId in playerIds)
            {
                BasePlayer player = RustCore.FindPlayerByIdString(playerId);

                if (player != null)
                    SetupPlayer(player, hasLeft: isDisband, clan: oldClan, oldTag: tag);
            }
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player == null || player.net == null || player.net.connection == null)
                return;

            Clan clan = SetupPlayer(player);

            if (clan != null)
                ServerMgr.Instance.StartCoroutine(WaitForReady(player, clan));
        }

        private IEnumerator WaitForReady(BasePlayer player, Clan clan = null)
        {
            yield return new WaitWhile(new Func<bool>(() => player.IsReceivingSnapshot || player.IsSleeping()));

            yield return CoroutineEx.waitForSeconds(1.0f);

            if (player == null || player.IsDead())
                yield break;

            ComingOnlineInfo(player, clan);
        }

        private void ComingOnlineInfo(BasePlayer player, Clan clan = null)
        {
            if (player && clan != null)
            {
                clan.AddIPlayer(player.IPlayer);
                clan.AddBasePlayer(player);

                clan.UpdateTeam();
                
                if (enableComesOnlineMsg)
                    clan.BroadcastLoc("comeonline", clan.GetColoredName(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);

                if (enableWhoIsOnlineMsg)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append($"<color={colorTextMsg}>");
                    sb.Append(string.Format(msg("memberon", player.UserIDString)));
                    int n = 0;

                    foreach (string memberId in clan.members.ToList())
                    {
                        IPlayer op = clan.FindClanMember(memberId);
                        if (op != null && (op as RustPlayer).IsConnected)
                        {
                            string memberName = op.Name;

                            if (op.Name == player.net.connection.username)
                                memberName = msg("yourname", player.UserIDString);

                            if (n > 0)
                                sb.Append(", ");

                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clan.GetRoleColor(op.Id), memberName));
                            ++n;
                        }
                    }

                    sb.Append($"</color>");
                    PrintChat(player, sb.ToString().TrimEnd());
                }

                clan.updated = UnixTimeStampUTC();
                manuallyEnabledBy.Remove(player.userID);

                if (enableClanAllies && (clan.IsOwner(player.UserIDString) || clan.IsCouncil(player.UserIDString)) && clan.pendingInvites.Count > 0)
                {
                    if (player != null)
                        PrintChat(player, string.Format(msg("allyPendingInfo", player.UserIDString)));
                }

                return;
            }

            if (pendingPlayerInvites.ContainsKey(player.UserIDString))
            {
                foreach (string invitation in pendingPlayerInvites[player.UserIDString] as List<string>)
                {
                    Clan newclan = findClan(invitation);

                    if (newclan != null)
                        PrintChat(player, string.Format(msg("claninvite", player.UserIDString), newclan.tag, newclan.description, colorCmdUsage));
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            Clan clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                clan.BroadcastLoc("goneoffline", clan.GetColoredName(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                manuallyEnabledBy.Remove(player.userID);
            }
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo hit)
        {
            if (!enableFFOPtion || attacker == null || hit == null || !(hit.HitEntity is BasePlayer))
                return;

            OnAttackShared(attacker, hit.HitEntity as BasePlayer, hit);
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit)
        {
            if (!enableFFOPtion || entity == null || hit == null || !(entity is BasePlayer) || !(hit.Initiator is BasePlayer))
                return;

            OnAttackShared(hit.Initiator as BasePlayer, entity as BasePlayer, hit);
        }

        private object OnAttackShared(BasePlayer attacker, BasePlayer victim, HitInfo hit)
        {
            if (bypass.Contains(victim.userID) || attacker == victim)
                return null;

            Clan victimClan = findClanByUser(victim.UserIDString);
            Clan attackerClan = findClanByUser(attacker.UserIDString);

            if (victimClan == null || attackerClan == null)
                return null;

            if (victimClan.tag == attackerClan.tag)
            {
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceClanFFNoDeactivate)
                    return null;

                DateTime now = DateTime.UtcNow;
                DateTime time;
                string key = attacker.UserIDString + "-" + victim.UserIDString;

                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("friendlyfire", attacker.UserIDString), victim.displayName, colorCmdUsage));
                    notificationTimes[key] = now;
                }

                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }

            if (victimClan.tag != attackerClan.tag && enableClanAllies && enableAllyFFOPtion)
            {
                if (!victimClan.clanAlliances.Contains(attackerClan.tag))
                    return null;

                if (manuallyEnabledBy.Contains(attacker.userID) && !forceAllyFFNoDeactivate)
                    return null;

                DateTime now = DateTime.UtcNow;
                DateTime time;
                string key = attacker.UserIDString + "-" + victim.UserIDString;

                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("allyfriendlyfire", attacker.UserIDString), victim.displayName));
                    notificationTimes[key] = now;
                }

                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }

            return null;
        }

        private void AllyRemovalCheck()
        {
            foreach (KeyValuePair<string, Clan> ally in clans)
            {
                try
                {
                    Clan allyClan = clans[ally.Key];

                    foreach (string clanAlliance in allyClan.clanAlliances.ToList())
                    {
                        if (!clans.ContainsKey(clanAlliance))
                            allyClan.clanAlliances.Remove(clanAlliance);
                    }

                    foreach (string invitedAlly in allyClan.invitedAllies.ToList())
                    {
                        if (!clans.ContainsKey(invitedAlly))
                            allyClan.clanAlliances.Remove(invitedAlly);
                    }

                    foreach (string pendingInvite in allyClan.pendingInvites.ToList())
                    {
                        if (!clans.ContainsKey(pendingInvite))
                            allyClan.clanAlliances.Remove(pendingInvite);
                    }
                }
                catch
                {
                    PrintWarning("Ally removal check failed. Please contact the developer");
                }
            }
        }

        private void ccmdChatClan(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Connection != null && arg.Connection.player != null)
            {
                usedConsoleInput.Add(arg.Connection.userid);

                if (arg.Args != null)
                    cmdChatClan((BasePlayer)arg.Connection.player, chatCommandClan, arg.Args);
                else cmdChatClan((BasePlayer)arg.Connection.player, chatCommandClan, new string[] { });
            }
        }

        private void cmdChatClan(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (args == null || args.Length == 0)
            {
                cmdClanOverview(player);
                return;
            }

            string opt = args[0];
            if (opt == msg("clanArgCreate", player.UserIDString))
            {
                cmdClanCreate(player, args);
                return;
            }
            else if (opt == msg("clanArgInvite", player.UserIDString))
            {
                cmdClanInvite(player, args);
                return;
            }
            else if (opt == msg("clanArgWithdraw", player.UserIDString))
            {
                cmdClanWithdraw(player, args);
                return;
            }
            else if (opt == msg("clanArgJoin", player.UserIDString))
            {
                cmdClanJoin(player, args);
                return;
            }
            else if (opt == msg("clanArgPromote", player.UserIDString))
            {
                cmdClanPromote(player, args);
                return;
            }
            else if (opt == msg("clanArgDemote", player.UserIDString))
            {
                cmdClanDemote(player, args);
                return;
            }
            else if (opt == msg("clanArgLeave", player.UserIDString))
            {
                cmdClanLeave(player, args);
                return;
            }
            else if (opt == msg("clanArgFF", player.UserIDString))
            {
                if (!enableFFOPtion)
                    return;

                cmdChatClanFF(player, command, args);
                return;
            }
            else if (opt == msg("clanArgAlly", player.UserIDString))
            {
                if (!enableClanAllies)
                    return;

                for (int i = 0; i < args.Length - 1; ++i)
                {
                    if (i < args.Length)
                        args[i] = args[i + 1];
                }

                Array.Resize(ref args, args.Length - 1);
                cmdChatClanAlly(player, command, args);
                return;
            }
            else if (opt == msg("clanArgKick", player.UserIDString))
            {
                cmdClanKick(player, args);
                return;
            }
            else if (opt == msg("clanArgDisband", player.UserIDString))
            {
                cmdClanDisband(player, args);
                return;
            }
            else
            {
                cmdChatClanHelp(player, command, args);
            }
        }

        private void cmdClanOverview(BasePlayer player)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            StringBuilder sb = new StringBuilder();
            if (!usedConsoleInput.Contains(player.userID))
                sb.AppendLine($"<size=18><color={pluginPrefixColor}>{Title}</color></size>{(pluginPrefixREBORNShow == true ? $" <size = 14> <color={pluginPrefixREBORNColor}> REBORN </color></size> " : "")}");

            if (myClan == null)
            {
                sb.AppendLine(string.Format(msg("notmember", current.Id)));
                sb.AppendLine(string.Format(msg("viewthehelp", current.Id), colorCmdUsage,$"{chatCommandClan + "help"} | /{chatCommandClan}"));
                SendReply(player, $"<color={colorTextMsg}>{sb.ToString().TrimEnd()}</color>");
                return;
            }

            if (myClan.IsOwner(current.Id))
                sb.Append(string.Format(msg("youareownerof", current.Id)));
            else if (myClan.IsCouncil(current.Id))
                sb.Append(string.Format(msg("youarecouncilof", current.Id)));
            else if (myClan.IsModerator(current.Id))
                sb.Append(string.Format(msg("youaremodof", current.Id)));
            else sb.Append(string.Format(msg("youarememberof", current.Id)));

            sb.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.Online}/{myClan.Total} )");
            sb.Append(string.Format(msg("memberon", current.Id)));

            int n = 0;
            foreach (string memberId in myClan.members.ToList())
            {
                IPlayer op = myClan.FindClanMember(memberId);

                if (op != null && (op as RustPlayer).IsConnected)
                {
                    string memberName = op.Name;
                    if (op.Name == current.Name)
                        memberName = msg("yourname", current.Id);

                    if (n > 0)
                        sb.Append(", ");

                    sb.Append(string.Format(msg("overviewnamecolor", current.Id), myClan.GetRoleColor(op.Id), memberName));
                    ++n;
                }
            }

            if (n > 0)
                sb.AppendLine();

            if (myClan.Online < myClan.Total)
            {
                sb.Append(string.Format(msg("memberoff", current.Id)));
                n = 0;
                foreach (string memberId in myClan.members.ToList())
                {
                    IPlayer p = myClan.FindClanMember(memberId);
                    if (p != null && !(p as RustPlayer).IsConnected)
                    {
                        if (n > 0)
                            sb.Append(", ");

                        sb.Append(string.Format(msg("overviewnamecolor", current.Id), myClan.GetRoleColor(p.Id), p.Name));
                        ++n;
                    }
                }

                if (n > 0)
                    sb.AppendLine();
            }

            if (myClan.HasAnyRole(current.Id) && myClan.invites.Count() > 0)
            {
                sb.Append(string.Format(msg("pendinvites", current.Id)));
                int m = 0;
                foreach (KeyValuePair<string, int> inviteId in myClan.invites.ToList())
                {
                    IPlayer p = myClan.FindInvitedIPlayer(inviteId.Key);
                    if (p != null)
                    {
                        string invitedPlayer = string.Empty;
                        if (m > 0)
                            sb.Append(", ");

                        invitedPlayer = string.Format(msg("overviewnamecolor", current.Id), clanMemberColor, p.Name);
                        ++m;

                        sb.Append(invitedPlayer);
                    }
                }

                if (m > 0)
                    sb.AppendLine();
            }

            if (enableClanAllies && myClan.clanAlliances.Count() > 0)
                sb.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");

            if (enableClanAllies && (myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
            {
                if (myClan.invitedAllies.Count() > 0)
                    sb.AppendLine(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");

                if (myClan.pendingInvites.Count() > 0)
                    sb.AppendLine(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");

                if (myClan.pendingInvites.Count() == 0 && myClan.invitedAllies.Count() == 0)
                    sb.AppendLine();
            }

            if (enableFFOPtion)
                sb.AppendLine(string.Format(msg("yourffstatus", current.Id)) + " " + (manuallyEnabledBy.Contains(player.userID) ? $"<color={colorClanFFOn}>ON</color>" : $"<color={colorClanFFOff}>OFF</color>") + $" ( <color={colorCmdUsage}>/{chatCommandFF}</color> )");

            sb.AppendLine(string.Format(msg("viewthehelp", current.Id), colorCmdUsage, $"{string.Concat(chatCommandClan, subCommandClanHelp)} | /{chatCommandClan}"));

            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";

            string[] parts = sb.ToString().Split(new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries);

            sb = new StringBuilder();

            foreach (string part in parts)
            {
                if (sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length > 1100)
                {
                    ChatSwitch(player, openText + sb.ToString().TrimEnd() + closeText, usedConsoleInput.Contains(player.userID) ? true : false);
                    sb.Clear();
                }

                sb.AppendLine(part);
            }

            ChatSwitch(player, openText + sb.ToString().TrimEnd() + closeText);
        }

        private void cmdClanCreate(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);

            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }

            if (usePermToCreateClan && !permission.UserHasPermission(current.Id, permissionToCreateClan))
            {
                PrintChat(player, msg("nopermtocreate", current.Id));
                return;
            }

            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagecreate", current.Id), colorCmdUsage));
                return;
            }

            if (tagReExt.IsMatch(args[1]))
            {
                PrintChat(player, string.Format(msg("hintchars", current.Id), allowedSpecialChars));
                return;
            }

            if (args[1].Length < tagLengthMin || args[1].Length > tagLengthMax)
            {
                PrintChat(player, string.Format(msg("hintlength", current.Id), tagLengthMin, tagLengthMax));
                return;
            }

            if (args.Length > 2)
            {
                args[2] = args[2].Trim();
                string richTextChk = args[2].EscapeRichText();
                if (args[2].Length < 2 || args[2].Length > 30 || args[2] != richTextChk)
                {
                    PrintChat(player, string.Format(msg("providedesc", current.Id)));
                    return;
                }
            }

            if (enableWordFilter && FilterText(args[1]))
            {
                PrintChat(player, string.Format(msg("bannedwords", current.Id)));
                return;
            }

            string[] clanKeys = clans.Keys.ToArray();
            clanKeys = clanKeys.Select(c => c.ToLower()).ToArray();
            if (clanKeys.Contains(args[1].ToLower()))
            {
                PrintChat(player, string.Format(msg("tagblocked", current.Id)));
                return;
            }

            myClan = Clan.Create(args[1], args.Length > 2 ? args[2] : string.Empty, current.Id);

            SetupPlayer(player, current, clan: myClan);

            myClan.AddBasePlayer(player);

            if (usePermGroups && !permission.GroupExists(permGroupPrefix + myClan.tag))
                permission.CreateGroup(permGroupPrefix + myClan.tag, "Clan " + myClan.tag, 0);

            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag))
                permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);

            myClan.OnCreate();

            PrintChat(player, string.Format(msg("nownewowner", current.Id), myClan.tag, myClan.description) + "\n" + string.Format(msg("inviteplayers", current.Id), colorCmdUsage));

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' created the new clan [{myClan.tag}]", this);
        }

        public void InvitePlayer(BasePlayer player, string targetId)
        {
            cmdClanInvite(player, new string[] {"", targetId});
        }

        private void cmdClanInvite(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);

            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usageinvite", current.Id), colorCmdUsage));
                return;
            }

            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }

            IPlayer invPlayer = myClan.FindServerIPlayer(args[1]);
            if (invPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }

            if (myClan.IsMember(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), invPlayer.Name));
                return;
            }

            if (myClan.IsInvited(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyinvited", current.Id), invPlayer.Name));
                return;
            }

            if (findClanByUser(invPlayer.Id) != null)
            {
                PrintChat(player, string.Format(msg("alreadyinclan", current.Id), invPlayer.Name));
                return;
            }

            if (usePermToJoinClan && !permission.UserHasPermission(invPlayer.Id, permissionToJoinClan))
            {
                PrintChat(player, string.Format(msg("nopermtojoinbyinvite", current.Id), invPlayer.Name));
                return;
            }

            myClan.AddInvite(invPlayer);
            myClan.BroadcastLoc("invitebroadcast", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(invPlayer.Id, invPlayer.Name));

            if ((invPlayer as RustPlayer).IsConnected)
            {
                BasePlayer invited = RustCore.FindPlayerByIdString(invPlayer.Id);
                if (invited != null)
                    PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }

            myClan.updated = UnixTimeStampUTC();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' invited '{invPlayer.Name}' to [{myClan.tag}]", this);
        }

        public void WithdrawPlayer(BasePlayer player, string targetId)
        {
            cmdClanWithdraw(player, new string[] {"", targetId});
        }

        private void cmdClanWithdraw(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagewithdraw", current.Id), colorCmdUsage));
                return;
            }

            if (!myClan.HasAnyRole(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }

            IPlayer disinvPlayer = myClan.FindInvitedIPlayer(args[1]);
            if (disinvPlayer == null)
            {
                PrintChat(player, string.Format(msg("notinvited", current.Id), args[1]));
                return;
            }

            myClan.RemoveMember(disinvPlayer);
            myClan.BroadcastLoc("canceledinvite", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(disinvPlayer.Id, disinvPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
        }

        private void cmdClanJoin(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }

            if (usePermToJoinClan && !permission.UserHasPermission(current.Id, permissionToJoinClan))
            {
                PrintChat(player, msg("nopermtojoin", current.Id));
                return;
            }

            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagejoin", current.Id), colorCmdUsage));
                return;
            }

            myClan = findClan(args[1]);
            if (myClan == null || !myClan.IsInvited(current.Id))
            {
                PrintChat(player, string.Format(msg("younotinvited", current.Id)));
                return;
            }

            if (limitMembers >= 0 && myClan.Total >= limitMembers)
            {
                PrintChat(player, string.Format(msg("reachedmaximum", current.Id)));
                return;
            }

            myClan.AddMember(current);
            myClan.AddBasePlayer(player);

            SetupPlayer(player, current, clan: myClan);

            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag))
                permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);

            myClan.BroadcastLoc("playerjoined", myClan.GetColoredName(current.Id, current.Name));
            myClan.OnUpdate();

            List<string> others = new List<string>(myClan.members.ToList());
            others.Remove(current.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", current.Id, others);

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' joined to [{myClan.tag}]", this);
        }

        public void PromotePlayer(BasePlayer player, string targetId)
        {
            cmdClanPromote(player, new string[] {"", targetId});
        }

        private void cmdClanPromote(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }

            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagepromote", current.Id), colorCmdUsage));
                return;
            }

            IPlayer promotePlayer = myClan.FindClanMember(args[1]);
            if (promotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }

            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncil", current.Id), promotePlayer.Name));
                return;
            }

            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncilset", current.Id), promotePlayer.Name));
                return;
            }

            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyamod", current.Id), promotePlayer.Name));
                return;
            }

            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.Mods >= limitModerators)
            {
                PrintChat(player, string.Format(msg("maximummods", current.Id)));
                return;
            }

            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.SetCouncil(promotePlayer.Id);
                myClan.RemoveModerator(promotePlayer);
                myClan.BroadcastLoc("playerpromotedcouncil", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.SetModerator(promotePlayer);
                myClan.BroadcastLoc("playerpromoted", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(promotePlayer.Id, promotePlayer.Name));
            }

            myClan.OnUpdate();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' promoted '{promotePlayer.Name}' to a {myClan.GetRoleString(promotePlayer.Id.ToString())} of [{myClan.tag}]", this);
        }

        public void DemotePlayer(BasePlayer player, string targetId)
        {
            cmdClanDemote(player, new string[] {"", targetId});
        }

        private void cmdClanDemote(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }

            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagedemote", current.Id), colorCmdUsage));
                return;
            }

            IPlayer demotePlayer = myClan.FindClanMember(args[1]);
            if (demotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }

            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notpromoted", current.Id), demotePlayer.Name));
                return;
            }

            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.SetCouncil();

                if (limitModerators >= 0 && myClan.Mods >= limitModerators)
                {
                    myClan.BroadcastLoc("playerdemoted", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
                }
                else
                {
                    myClan.SetModerator(demotePlayer);
                    myClan.BroadcastLoc("councildemoted", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.RemoveModerator(demotePlayer);
                myClan.BroadcastLoc("playerdemoted", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
            }

            myClan.OnUpdate();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' demoted '{demotePlayer.Name}' to a {myClan.GetRoleString(demotePlayer.Id.ToString())} of [{myClan.tag}]", this);
        }

        public void LeaveClan(BasePlayer player)
        {
            cmdClanLeave(player, new string[] {"leave"});
        }

        private void cmdClanLeave(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (args.Length != 1)
            {
                PrintChat(player, string.Format(msg("usageleave", current.Id), colorCmdUsage));
                return;
            }

            myClan.RemoveMember(current);

            if (myClan.Total == 0)
                RemoveClan(myClan.tag);
            else myClan.ValidateOwner();

            SetupPlayer(player, current, true, oldTag: myClan.tag);

            if (usePermGroups && permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag))
                permission.RemoveUserGroup(current.Id, permGroupPrefix + myClan.tag);

            PrintChat(player, string.Format(msg("youleft", current.Id)));

            if (myClan.Total > 0)
            {
                myClan.OnUpdate();
                myClan.BroadcastLoc("playerleft", myClan.GetColoredName(current.Id, current.Name));

                Interface.Oxide.CallHook("OnClanMemberGone", current.Id, myClan.members.ToList());

                if (logClanChanges)
                    LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' left the clan [{myClan.tag}]", this);
            }
            else
            {
                if (logClanChanges)
                    LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' left as last member the clan [{myClan.tag}]", this);

                AllyRemovalCheck();
                myClan.OnDestroy();
                myClan = null;
            }
        }

        public void KickPlayer(BasePlayer player, string targetId)
        {
            cmdClanKick(player, new string[] {"", targetId});
        }

        private void cmdClanKick(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.HasAnyRole(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }

            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagekick", current.Id), colorCmdUsage));
                return;
            }

            IPlayer kickPlayer = myClan.FindClanMember(args[1]);

            if (kickPlayer == null)
                kickPlayer = myClan.FindInvitedIPlayer(args[1]);

            if (kickPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }

            if (myClan.IsOwner(kickPlayer.Id) || (myClan.IsCouncil(kickPlayer.Id) || myClan.IsModerator(kickPlayer.Id)) && !myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("modownercannotkicked", current.Id), kickPlayer.Name));
                return;
            }

            myClan.RemoveMember(kickPlayer);
            myClan.ValidateOwner();

            BasePlayer kickBasePlayer = RustCore.FindPlayerByIdString(kickPlayer.Id);
            if (kickBasePlayer != null)
            {
                SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);
                PrintChat(kickBasePlayer, string.Format(msg("werekicked", kickPlayer.Id), myClan.GetColoredName(current.Id, current.Name)));
            }

            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag))
                permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);

            myClan.BroadcastLoc("waskicked", myClan.GetColoredName(current.Id, current.Name), myClan.GetColoredName(kickPlayer.Id, kickPlayer.Name));
            myClan.OnUpdate();

            Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members.ToList());

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' kicked '{kickPlayer.Name}' from [{myClan.tag}]", this);
        }

        public void DisbandClan(BasePlayer player)
        {
            cmdClanDisband(player, new string[] {"disband", "forever"});
        }

        private void cmdClanDisband(BasePlayer player, string[] args)
        {
            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }

            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagedisband", current.Id), colorCmdUsage));
                return;
            }

            if (myClan.Total == 1) lastMember = true;

            RemoveClan(myClan.tag);

            foreach (string member in myClan.members.ToList())
            {
                clanCache.Remove(member);
                if (usePermGroups && permission.UserHasGroup((string) member, permGroupPrefix + myClan.tag))
                    permission.RemoveUserGroup((string) member, permGroupPrefix + myClan.tag);
            }

            myClan.BroadcastLoc("clandisbanded");
            setupPlayers(myClan.members.ToList(), true, tag: myClan.tag);

            foreach (KeyValuePair<string, Clan> ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(myClan.tag);
                allyClan.invitedAllies.Remove(myClan.tag);
                allyClan.pendingInvites.Remove(myClan.tag);
            }

            if (usePermGroups && permission.GroupExists(permGroupPrefix + myClan.tag))
                permission.RemoveGroup(permGroupPrefix + myClan.tag);

            myClan.OnDestroy();
            AllyRemovalCheck();

            if (!lastMember)
                Interface.Oxide.CallHook("OnClanDisbanded", myClan.members.ToList());

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - '{current.Name}' disbanded [{myClan.tag}]", this);

            myClan.DisbandTeam();
        }

        public void Alliance(BasePlayer player, string targetClan, string type)
        {
            cmdChatClanAlly(player, "ally", new string[] {type, targetClan});
        }

        private void cmdChatClanAlly(BasePlayer player, string command, string[] args)
        {
            if (!enableClanAllies || player == null)
                return;

            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }

            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanownercouncil", current.Id)));
                return;
            }

            if (args == null || args.Length == 0)
            {
                StringBuilder sbally = new StringBuilder();
                if (!usedConsoleInput.Contains(player.userID))
                    sbally.Append($"<size=18><color={pluginPrefixColor}>{Title}</color></size>{(pluginPrefixREBORNShow == true ? $" <size=14> <color={pluginPrefixREBORNColor}> REBORN </color></size> " : "")}\n");

                sbally.Append($"<color={colorTextMsg}>");

                if (myClan.IsOwner(current.Id))
                    sbally.Append(string.Format(msg("youareownerof", current.Id)));

                else if (myClan.IsCouncil(current.Id))
                    sbally.Append(string.Format(msg("youarecouncilof", current.Id)));

                else if (myClan.IsModerator(current.Id))
                    sbally.Append(string.Format(msg("youaremodof", current.Id)));

                else sbally.Append(string.Format(msg("youarememberof", current.Id)));

                sbally.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.Online}/{myClan.Total} )");

                if (myClan.clanAlliances.Count() > 0)
                    sbally.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");

                if ((myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
                {
                    if (myClan.invitedAllies.Count() > 0)
                        sbally.Append(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");

                    if (myClan.pendingInvites.Count() > 0)
                        sbally.Append(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");

                    sbally.AppendLine();
                }

                string commandtext = string.Empty;

                if (command.Contains("ally"))
                    commandtext = command;
                else commandtext = chatCommandClan + " ally";

                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgRequest", current.Id)} | {msg("allyArgRequestShort", current.Id)}> <clantag></color>");

                sbally.AppendLine(" " + msg("allyReqHelp", current.Id));

                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgAccept", current.Id)} | {msg("allyArgAcceptShort", current.Id)}> <clantag></color>");

                sbally.AppendLine(" " + msg("allyAccHelp", current.Id));

                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgDecline", current.Id)} | {msg("allyArgDeclineShort", current.Id)}> <clantag></color>");

                sbally.AppendLine(" " + msg("allyDecHelp", current.Id));

                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgCancel", current.Id)} | {msg("allyArgCancelShort", current.Id)}> <clantag></color>");

                sbally.AppendLine(" " + msg("allyCanHelp", current.Id));

                sbally.Append("</color>");

                SendReply(player, sbally.ToString().TrimEnd());
                return;
            }
            else if (args != null && args.Length >= 1 && args.Length < 2)
            {
                PrintChat(player, string.Format(msg("allyProvideName", current.Id)));
                return;
            }
            else if (args.Length >= 1)
            {
                Clan targetClan = null;
                string opt = args[0];
                if (opt == msg("allyArgRequest", current.Id) || opt == msg("allyArgRequestShort", current.Id))
                {
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyLimit", current.Id)));
                        return;
                    }

                    if (myClan.invitedAllies.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("invitePending", current.Id), args[1]));
                        return;
                    }

                    if (myClan.clanAlliances.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("alreadyAllies", current.Id)));
                        return;
                    }

                    targetClan = findClan(args[1]);

                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }

                    targetClan.pendingInvites.Add(myClan.tag);
                    myClan.invitedAllies.Add(targetClan.tag);

                    PrintChat(player, string.Format(msg("allyReq", current.Id), args[1]));

                    targetClan.AllyBroadcastLoc("reqAlliance", myClan.tag);

                    myClan.OnUpdate(false);
                    targetClan.OnUpdate(false);
                    return;
                }
                else if (opt == msg("allyArgAccept", current.Id) || opt == msg("allyArgAcceptShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }

                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }

                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyAccLimit", current.Id), targetClan.tag));

                        targetClan.invitedAllies.Remove(myClan.tag);
                        myClan.pendingInvites.Remove(targetClan.tag);
                        return;
                    }

                    targetClan.invitedAllies.Remove(myClan.tag);
                    targetClan.clanAlliances.Add(myClan.tag);

                    myClan.pendingInvites.Remove(targetClan.tag);
                    myClan.clanAlliances.Add(targetClan.tag);
                    myClan.OnUpdate(false);

                    targetClan.OnUpdate(false);

                    PrintChat(player, string.Format(msg("allyAcc", current.Id), targetClan.tag));

                    targetClan.AllyBroadcastLoc("allyAccSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgDeclineallyArgDecline", current.Id) || opt == msg("allyArgDeclineShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }

                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }

                    targetClan.invitedAllies.Remove(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);

                    AllyRemovalCheck();

                    PrintChat(player, string.Format(msg("allyDeclined", current.Id), args[1]));

                    myClan.OnUpdate(false);

                    targetClan.OnUpdate(false);
                    targetClan.AllyBroadcastLoc("allyDeclinedSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgCancel", current.Id) || opt == msg("allyArgCancelShort", current.Id))
                {
                    if (!myClan.clanAlliances.Contains(args[1]))
                    {
                        if (myClan.invitedAllies.Contains(args[1]))
                        {
                            myClan.invitedAllies.Remove(args[1]);

                            targetClan = findClan(args[1]);

                            if (targetClan != null)
                                targetClan.pendingInvites.Remove(myClan.tag);

                            PrintChat(player, string.Format(msg("allyInvWithdraw", current.Id), args[1]));

                            myClan.OnUpdate(false);
                            targetClan.OnUpdate(false);
                            return;
                        }

                        PrintChat(player, string.Format(msg("noAlly", current.Id)));
                        return;
                    }

                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }

                    targetClan.clanAlliances.Remove(myClan.tag);
                    myClan.clanAlliances.Remove(targetClan.tag);

                    AllyRemovalCheck();

                    PrintChat(player, string.Format(msg("allyCancel", current.Id), args[1]));

                    myClan.OnUpdate(false);

                    targetClan.OnUpdate(false);
                    targetClan.AllyBroadcastLoc("allyCancelSucc", myClan.tag);
                    return;
                }
                else
                {
                    cmdChatClanAlly(player, command, new string[] { });
                }
            }
        }

        private void cmdChatClanHelp(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            IPlayer current = player.IPlayer;
            Clan myClan = findClanByUser(current.Id);
            StringBuilder sb = new StringBuilder();

            if (myClan == null)
            {
                sb.Append($"<color={colorTextMsg}>");
                sb.AppendLine(msg("helpavailablecmds", current.Id));
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgCreate", current.Id)} \"TAG\" \"Description\"</color> - {msg("helpcreate", current.Id)}");
                sb.Append($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgJoin", current.Id)} \"TAG\"</color> - {msg("helpjoin", current.Id)}");
                sb.Append("</color>");
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }

            sb.AppendLine(msg("helpavailablecmds", current.Id));

            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan}</color> - {msg("helpinformation", current.Id)}");

            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClanChat} <msg></color> - {msg("helpmessagemembers", current.Id)}");

            if (enableClanAllies)
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandAllyChat} <msg></color> - {msg("helpmessageally", current.Id)}");

            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgLeave", current.Id)}</color> - {msg("helpleave", current.Id)}");

            if (enableFFOPtion)
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgFF", current.Id)} |  /{chatCommandFF}</color> - {msg("helptoggleff", current.Id)}");

            if (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id) || myClan.IsModerator(current.Id))
            {
                sb.AppendLine($"<color={clanModeratorColor}>{msg("helpmoderator", current.Id)}</color> {msg("helpcommands", current.Id)}");

                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgInvite", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpinvite", current.Id)}");

                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgWithdraw", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpwithdraw", current.Id)}");

                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgKick", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpkick", current.Id)}");
            }

            if (myClan.IsOwner(current.Id) || enableClanAllies && myClan.IsCouncil(current.Id))
            {
                sb.AppendLine($"<color={clanOwnerColor}>{msg("helpowner", current.Id)}</color> {msg("helpcommands", current.Id)}");

                if (enableClanAllies)
                    sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgAlly", current.Id)} | {chatCommandClan + "ally"}</color> - {msg("helpallyoptions", current.Id)}");

                if (myClan.IsOwner(current.Id))
                    sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgPromote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helppromote", current.Id)}");

                if (myClan.IsOwner(current.Id))
                    sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDemote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpdemote", current.Id)}");

                if (myClan.IsOwner(current.Id))
                    sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDisband", current.Id)} {msg("clanArgForever", current.Id)}</color> - {msg("helpdisband", current.Id)}");
            }

            if (player.net.connection.authLevel >= authLevelDisband || player.net.connection.authLevel >= authLevelRename || player.net.connection.authLevel >= authLevelInvite || player.net.connection.authLevel >= authLevelKick || player.net.connection.authLevel >= authLevelPromoteDemote)
                sb.AppendLine($"<color={clanServerColor}>Server management</color>: {msg("helpconsole", current.Id)} <color={colorCmdUsage}>clans</color>");

            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";

            string[] parts = sb.ToString().Split(new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries);

            sb = new StringBuilder();
            foreach (string part in parts)
            {
                if (sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length > 1100)
                {
                    ChatSwitch(player, openText + sb.ToString().TrimEnd() + closeText, usedConsoleInput.Contains(player.userID) ? true : false);
                    sb.Clear();
                }

                sb.AppendLine(part);
            }

            ChatSwitch(player, openText + sb.ToString().TrimEnd() + closeText);
        }

        private void cmdChatClanInfo(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (player.net.connection.authLevel < authLevelClanInfo)
            {
                PrintChat(player, "No access to this command");
                return;
            }

            if (args == null || args.Length == 0)
            {
                PrintChat(player, "Please specify a clan tag");
                return;
            }

            Clan Clan = findClan(args[0]);
            if (Clan == null)
            {
                PrintChat(player, string.Format(msg("clanNoExist", player.UserIDString), args[0]));
                return;
            }

            StringBuilder sb = new StringBuilder();
            if (!usedConsoleInput.Contains(player.userID))
                sb.Append($"<size=18><color={pluginPrefixColor}>{Title}</color></size>{(pluginPrefixREBORNShow == true ? $" <size=14><color={pluginPrefixREBORNColor}> REBORN </color></size>" : "")}\n");

            sb.AppendLine($"<color={colorTextMsg}>Detailed clan information for:");

            sb.AppendLine($"ClanTag:  <color={colorClanNamesOverview}>{Clan.tag}</color> ( Online: <color={colorClanNamesOverview}>{Clan.Online}</color> / Total: <color={colorClanNamesOverview}>{Clan.Total}</color> )");

            sb.AppendLine($"Description: <color={colorClanNamesOverview}>{Clan.description}</color>");

            sb.Append(string.Format(msg("memberon", player.UserIDString)));

            int n = 0;
            foreach (string memberId in Clan.members.ToList())
            {
                IPlayer op = Clan.FindClanMember(memberId);
                if (op != null && (op as RustPlayer).IsConnected)
                {
                    if (n > 0)
                        sb.Append(", ");
                    sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), Clan.GetRoleColor(op.Id), op.Name));
                    ++n;
                }
            }

            if (Clan.Online == 0)
                sb.Append(" - ");

            sb.Append("</color>\n");

            bool offline = false;
            foreach (string memberId in Clan.members.ToList())
            {
                IPlayer op = Clan.FindClanMember(memberId);
                if (op != null && !(op as RustPlayer).IsConnected)
                {
                    offline = true;
                    break;
                }
            }

            if (offline)
            {
                sb.Append(string.Format(msg("memberoff", player.UserIDString)));
                n = 0;
                foreach (string memberId in Clan.members.ToList())
                {
                    IPlayer p = Clan.FindClanMember(memberId);
                    if (p != null && !(p as RustPlayer).IsConnected)
                    {
                        if (n > 0)
                            sb.Append(", ");

                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), Clan.GetRoleColor(p.Id), p.Name));
                        ++n;
                    }
                }

                sb.Append("\n");
            }

            sb.AppendLine($"Time created: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.created)}</color>");
            sb.AppendLine($"Last change: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.updated)}</color>");
            SendReply(player, sb.ToString().TrimEnd());
        }

        private void cmdChatClanchat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0)
                return;

            Clan myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                SendReply(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }

            if (clanChatDenyOnMuted)
            {
                IPlayer current = player.IPlayer;
                object chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool) chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }

            string message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message))
                return;

            myClan.BroadcastChat(string.Format(msg("broadcastformat"), myClan.GetRoleColor(player.UserIDString), player.net.connection.username, message));

            if (ConVar.Chat.serverlog)
            {
                ServerConsole.PrintColoured(ConsoleColor.White, "CLAN: ", ConsoleColor.DarkYellow, player.displayName + ": ", ConsoleColor.DarkGreen, message);
                DebugEx.Log(string.Format("[CHAT] CLAN [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message));
            }

            Interface.CallHook("OnClanChat", player, message, myClan.tag);
        }

        private void cmdChatAllychat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0)
                return;

            Clan myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }

            if (myClan.clanAlliances.Count == 0)
            {
                PrintChat(player, string.Format(msg("noactiveally", player.UserIDString)));
                return;
            }

            if (clanChatDenyOnMuted)
            {
                IPlayer current = player.IPlayer;
                object chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool) chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }

            string message = string.Join(" ", args);

            if (string.IsNullOrEmpty(message))
                return;

            foreach (string clanAllyName in myClan.clanAlliances)
            {
                Clan clanAlly = findClan(clanAllyName);
                if (clanAlly == null)
                    continue;

                clanAlly.AllyBroadcastChat(string.Format(msg("allybroadcastformat"), myClan.tag, myClan.GetRoleColor(player.UserIDString), player.net.connection.username, message));
            }

            myClan.AllyBroadcastChat(string.Format(msg("broadcastformat"), myClan.GetRoleColor(player.UserIDString), player.net.connection.username, message));

            if (ConVar.Chat.serverlog)
            {
                ServerConsole.PrintColoured(ConsoleColor.White, "ALLY: ", ConsoleColor.DarkYellow, player.displayName + ": ", ConsoleColor.DarkGreen, message);
                DebugEx.Log(string.Format("[CHAT] ALLY [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message));
            }

            Interface.CallHook("OnAllianceChat", player, message, myClan.tag);
        }

        private void cmdChatClanFF(BasePlayer player, string command, string[] args)
        {
            if (!enableFFOPtion || player == null)
                return;

            Clan myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }

            if (manuallyEnabledBy.Contains(player.userID))
            {
                manuallyEnabledBy.Remove(player.userID);
                PrintChat(player, string.Format(msg("clanffdisabled", player.UserIDString), colorClanFFOff));
                return;
            }
            else
            {
                manuallyEnabledBy.Add(player.userID);
                PrintChat(player, string.Format(msg("clanffenabled", player.UserIDString), colorClanFFOn));
                return;
            }
        }

        public bool HasFFEnabled(ulong playerId)
        {
            return !enableFFOPtion ? false : !manuallyEnabledBy.Contains(playerId) ? false : true;
        }

        public void ToggleFF(ulong playerId)
        {
            if (manuallyEnabledBy.Contains(playerId))
                manuallyEnabledBy.Remove(playerId);
            else manuallyEnabledBy.Add(playerId);
        }

        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        private class StoredData
        {
            public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
            public int saveStamp = 0;
            public string lastStorage = string.Empty;

            public StoredData()
            {
            }
        }

        private StoredData clanSaves = new StoredData();

        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        public class Clan
        {
            public string tag;
            public string description;
            public string owner;
            public string council;
            public int created;
            public int updated;

            public List<string> moderators = new List<string>();

            public List<string> members = new List<string>();

            [JsonIgnore]
            [ProtoIgnore]
            public List<BasePlayer> membersBasePlayer = new List<BasePlayer>();

            [JsonIgnore]
            [ProtoIgnore]
            public List<IPlayer> membersIPlayer = new List<IPlayer>();

            public Dictionary<string, int> invites = new Dictionary<string, int>();

            public List<string> clanAlliances = new List<string>();

            public List<string> invitedAllies = new List<string>();

            public List<string> pendingInvites = new List<string>();

            [JsonIgnore]
            [ProtoIgnore]
            private RelationshipManager.PlayerTeam _playerTeam;

            [JsonIgnore]
            [ProtoIgnore]
            public RelationshipManager.PlayerTeam PlayerTeam
            {
                get
                {                    
                    if (_playerTeam == null)                    
                        _playerTeam = RelationshipManager.Instance.CreateTeam();
                    
                    return _playerTeam;
                }
            }

            [JsonIgnore]
            [ProtoIgnore]
            public int Total => members.Count();

            [JsonIgnore]
            [ProtoIgnore]
            public int Mods => moderators.Count();

            [JsonIgnore]
            [ProtoIgnore]
            private string currentTeamLeader => owner;

            [JsonIgnore]
            [ProtoIgnore]
            private bool wasDisbanded = false;

            [JsonIgnore]
            [ProtoIgnore]
            public int Online
            {
                get { return membersIPlayer.Where(m => m != null && (m as RustPlayer).IsConnected).Count(); }
            }

            public bool IsOwner(string userId)
            {
                return userId == owner;
            }

            public bool IsCouncil(string userId)
            {
                return userId == council;
            }

            public bool IsModerator(string userId)
            {
                return moderators.Contains(userId);
            }

            public bool IsMember(string userId)
            {
                return members.Contains(userId);
            }

            public bool IsInvited(string userId)
            {
                return invites.ContainsKey(userId);
            }

            public bool HasAnyRole(string userId)
            {
                return IsOwner(userId) || IsCouncil(userId) || IsModerator(userId);
            }

            public static Clan Create(string tag, string description, string ownerId)
            {
                Clan clan = new Clan()
                {
                    tag = tag,
                    description = description,
                    owner = ownerId,
                    created = UnixTimeStampUTC(),
                    updated = UnixTimeStampUTC()
                };
                clan.members.Add(ownerId);
                cc.clans.Add(tag, clan);
                cc.clanCache[ownerId] = clan;
                cc.clansSearch[tag.ToLower()] = tag;
                return clan;
            }

            public void SetOwner(object obj)
            {
                owner = GetObjectId(obj);
                UpdateTeam();
            }

            public void SetCouncil(object obj = null)
            {
                council = obj == null ? null : GetObjectId(obj);
            }

            private string GetObjectId(object obj)
            {
                if (obj is BasePlayer)
                    return (obj as BasePlayer).UserIDString;

                else if (obj is IPlayer)
                    return (obj as IPlayer).Id;

                return (string) obj;
            }

            public void AddMember(object obj)
            {
                RemoveMember(obj);

                string Id = GetObjectId(obj);
                members.Add(Id);

                if (obj is BasePlayer)                
                    membersBasePlayer.Add(obj as BasePlayer);                

                if (obj is IPlayer)
                    membersIPlayer.Add(obj as IPlayer);

                cc.clanCache[Id] = this;
            }

            public void RemoveMember(object obj)
            {
                RemoveInvite(obj);
                RemoveModerator(obj);

                string Id = GetObjectId(obj);
                members.Remove(Id);

                if (IsCouncil(Id))
                    council = null;

                membersIPlayer.RemoveAll((IPlayer x) => x.Id == Id);
                membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == Id);

                cc.clanCache.Remove(Id);
            }

            public void SetModerator(object obj)
            {
                RemoveModerator(obj);
                string Id = GetObjectId(obj);
                moderators.Add(Id);
            }

            public void RemoveModerator(object obj)
            {
                string Id = GetObjectId(obj);
                moderators.Remove(Id);
            }

            public void AddInvite(object obj)
            {
                RemoveInvite(obj);
                string Id = GetObjectId(obj);

                invites.Add(Id, UnixTimeStampUTC());

                if (!cc.pendingPlayerInvites.ContainsKey(Id))
                    cc.pendingPlayerInvites.Add(Id, new List<string>());

                cc.pendingPlayerInvites[Id].Add(tag);
            }

            public void RemoveInvite(object obj)
            {
                string Id = GetObjectId(obj);
                invites.Remove(Id);

                if (cc.pendingPlayerInvites.ContainsKey(Id))
                    cc.pendingPlayerInvites[Id].Remove(tag);
            }

            public void AddBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (!membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.Add(basePlayer);                    
                }
                else
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);
                    membersBasePlayer.Add(basePlayer);
                }
            }

            public void RemoveBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);                    
                }
            }

            public BasePlayer GetBasePlayer(string Id)
            {
                BasePlayer lookup = membersBasePlayer.Find((BasePlayer x) => x.UserIDString == Id);
                if (lookup)
                    return lookup;

                lookup = RustCore.FindPlayerByIdString(Id);

                if (lookup)
                    AddBasePlayer(lookup);

                return lookup;
            }

            public void AddIPlayer(IPlayer iPlayer)
            {
                membersIPlayer.RemoveAll((IPlayer x) => x.Id == iPlayer.Id);
                membersIPlayer.Add(iPlayer);
            }

            public IPlayer GetIPlayer(string Id)
            {
                IPlayer lookup = membersIPlayer.Find((IPlayer x) => x.Id == Id);
                if (lookup != null)
                    return lookup;

                lookup = cc.covalence.Players.FindPlayerById(Id);
                if (lookup != null)
                    AddIPlayer(lookup);

                return lookup;
            }

            public bool ValidateOwner()
            {
                if (owner == null || owner == "0" || !members.Contains(owner))
                {
                    if (cc.enableClanAllies && council != null && council != "0")
                    {
                        owner = council;
                        council = null;
                        return true;
                    }

                    if (Mods > 0)
                    {
                        owner = moderators[0];
                        moderators.Remove(owner);
                        return true;
                    }

                    if (Total > 0)
                    {
                        owner = members[0];
                        return true;
                    }
                }

                return false;
            }

            public IPlayer FindClanMember(string nameOrId)
            {
                IPlayer result = membersIPlayer.Find((IPlayer x) => x.Id == nameOrId);
                if (result != null) return result;
                try
                {
                    IPlayer result2 = membersIPlayer.SingleOrDefault((IPlayer x) =>
                        x.Name.Equals(nameOrId, StringComparison.Ordinal) ||
                        x.Name.Equals(nameOrId, StringComparison.OrdinalIgnoreCase) ||
                        x.Name.Contains(nameOrId, StringComparison.OrdinalIgnoreCase) ||
                        x.Name.EndsWith(nameOrId, StringComparison.OrdinalIgnoreCase));
                    if (result2 != null && result2 is IPlayer) return result2;
                }
                catch
                {
                }

                return null;
            }

            public IPlayer FindServerIPlayer(string partialName)
            {
                IPlayer result = cc.covalence.Players.FindPlayerById(partialName);
                if (result != null)
                    return result;

                BasePlayer lookup = RustCore.FindPlayer(partialName);
                if (lookup != null)
                {
                    if (lookup.IPlayer != null)
                        return lookup.IPlayer;
                    return cc.covalence.Players.FindPlayerById(lookup.UserIDString);
                }

                try
                {
                    IPlayer mLookup = cc.covalence.Players.FindPlayer(partialName);
                    if (mLookup != null && mLookup is IPlayer)
                        return mLookup;
                }
                catch
                {
                }

                return null;
            }

            public IPlayer FindInvitedIPlayer(string partialName)
            {
                foreach (KeyValuePair<string, int> invited in invites.ToList())
                {
                    IPlayer player = cc.covalence.Players.FindPlayerById(invited.Key);
                    if (player != null)
                        if (partialName.Equals(player.Id, StringComparison.Ordinal) ||
                            partialName.Equals(player.Name, StringComparison.OrdinalIgnoreCase) ||
                            partialName.Equals(player.Name, StringComparison.OrdinalIgnoreCase) ||
                            player.Name.Contains(partialName, StringComparison.OrdinalIgnoreCase) ||
                            player.Name.EndsWith(partialName, StringComparison.OrdinalIgnoreCase))
                            return player;
                }

                return null;
            }

            public void BroadcastChat(string message)
            {
                foreach (string memberId in members)
                {
                    BasePlayer player = BasePlayer.Find(memberId);

                    if (player == null)
                        continue;

                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }

            public void BroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "", string current = "")
            {
                string message = string.Empty;
                foreach (string memberId in members)
                {
                    BasePlayer player = BasePlayer.Find(memberId);
                    if (player == null || player.UserIDString == current)
                        continue;

                    message = string.Format(cc.msg(messagetype, memberId), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }

            public void AllyBroadcastChat(string message)
            {
                foreach (string memberId in members)
                {
                    BasePlayer player = BasePlayer.Find(memberId);
                    if (player == null)
                        continue;

                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }

            public void AllyBroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
            {
                string message = string.Empty;
                foreach (string memberId in members)
                {
                    BasePlayer player = BasePlayer.Find(memberId);
                    if (player == null)
                        continue;

                    message = string.Format(cc.msg(messagetype, memberId), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }

            public string GetColoredName(string Id, string Name)
            {
                if (IsOwner(Id))
                    return $"<color={cc.clanOwnerColor}>{Name}</color>";

                else if (IsCouncil(Id) && !IsOwner(Id))
                    return $"<color={cc.clanCouncilColor}>{Name}</color>";

                else if (IsModerator(Id) && !IsOwner(Id))
                    return $"<color={cc.clanModeratorColor}>{Name}</color>";

                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }

            public string GetRoleString(string userID)
            {
                if (IsOwner(userID))
                    return "Owner";

                if (IsCouncil(userID))
                    return "Council";

                if (IsModerator(userID))
                    return "Moderator";

                return "Member";
            }

            public string GetRoleColor(string userID)
            {
                if (IsOwner(userID))
                    return cc.clanOwnerColor;

                if (IsCouncil(userID))
                    return cc.clanCouncilColor;

                if (IsModerator(userID))
                    return cc.clanModeratorColor;

                return cc.clanMemberColor;
            }

            internal JObject ToJObject()
            {
                JObject obj = new JObject();
                obj["tag"] = tag;
                obj["description"] = description;
                obj["owner"] = owner;
                obj["council"] = council;

                JArray jmoderators = new JArray();
                foreach (string moderator in moderators)
                    jmoderators.Add(moderator);

                obj["moderators"] = jmoderators;

                JArray jmembers = new JArray();
                foreach (string member in members)
                    jmembers.Add(member);

                obj["members"] = jmembers;

                JArray jallies = new JArray();
                foreach (string ally in clanAlliances)
                    jallies.Add(ally);
                obj["allies"] = jallies;

                JArray jinvallies = new JArray();
                foreach (string ally in invitedAllies)
                    jinvallies.Add(ally);
                obj["invitedallies"] = jinvallies;

                return obj;
            }

            public Clan() { }

            internal void OnCreate()
            {
                OnUpdate();
                Interface.CallHook("OnClanCreate", tag);
            }
            
            internal void OnUnload()
            {
                DestroyPlayerTeam();
            }

            internal void OnDestroy()
            {
                DestroyPlayerTeam();
                Interface.CallHook("OnClanDestroy", tag);
            }

            public void DisbandTeam()
            {
                wasDisbanded = true;

                DestroyPlayerTeam();
            }

            private void DestroyPlayerTeam()
            {
                if (_playerTeam != null)
                {
                    for (int i = _playerTeam.members.Count - 1; i >= 0; i--)
                    {
                        _playerTeam.RemovePlayer(_playerTeam.members[i]);                        
                    }                    
                }

                _playerTeam = null;
            }

            internal void OnUpdate(bool hasChanges = true)
            {
                if (hasChanges)
                {
                    updated = UnixTimeStampUTC();
                    UpdateTeam();
                }

                Interface.CallHook("OnClanUpdate", tag);
            }

            internal void UpdateTeam()
            {
                if (!useRelationshipManager || wasDisbanded)
                    return;

                PlayerTeam.teamLeader = cc.disableManageFunctions || !cc.allowButtonKick ? 0UL : Convert.ToUInt64(owner);

                PlayerTeam.teamName = $"[{tag}]";

                for (int i = 0; i < PlayerTeam.members.Count; i++)
                {
                    ulong playerId = PlayerTeam.members[i];

                    if (!members.Contains(playerId.ToString()))
                    {
                        PlayerTeam.RemovePlayer(playerId);

                        (BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId))?.ClearTeam();

                        RelationshipManager.Instance.playerToTeam.Remove(playerId);

                    }
                }

                for (int i = 0; i < members.Count; i++)
                {
                    ulong playerId = ulong.Parse(members[i]);

                    BasePlayer player = BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId);

                    if (!PlayerTeam.members.Contains(playerId))
                    {
                        RelationshipManager.Instance.playerToTeam.Remove(playerId);

                        if (player != null)
                        {
                            player.ClearTeam();
                            PlayerTeam.AddPlayer(player);
                        }
                    }                    
                }

                PlayerTeam.MarkDirty();
            }
        }

        private void OnPlayerDie(BasePlayer player, HitInfo info)
        {
            findClanByUser(player.UserIDString)?.RemoveBasePlayer(player, true);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            findClanByUser(player.UserIDString)?.AddBasePlayer(player, true);
        }

        [HookMethod("GetClan")]
        private JObject GetClan(string tag)
        {          
            if (tag != null)
            {
                Clan clan = findClan(tag);
                if (clan != null)                
                    return clan.ToJObject();                
            }

            return null;
        }

        [HookMethod("GetAllClans")]
        private JArray GetAllClans()
        {
            return new JArray(clans.Keys);
        }

        [HookMethod("GetClanOf")]
        private string GetClanOf(ulong player)
        {
            if (player == 0UL)
                return null;

            Clan clan = findClanByUser(player.ToString());
            if (clan == null)
                return null;

            return clan.tag;
        }

        [HookMethod("GetClanOf")]
        private string GetClanOf(string player)
        {
            if (player == null || player == "")
                return null;

            Clan clan = findClanByUser(player.ToString());
            if (clan == null)
                return null;

            return clan.tag;
        }

        [HookMethod("GetClanOf")]
        private string GetClanOf(BasePlayer player)
        {
            if (player == null)
                return null;

            Clan clan = findClanByUser(player.UserIDString);
            if (clan == null)
                return null;

            return clan.tag;
        }

        [HookMethod("GetClanMembers")]
        private List<string> GetClanMembers(ulong PlayerID)
        {
            Clan myClan = findClanByUser(PlayerID.ToString());
            if (myClan == null)
                return null;
            return myClan.members.ToList();
        }

        [HookMethod("GetClanMembers")]
        private List<string> GetClanMembers(string PlayerID)
        {
            Clan myClan = findClanByUser(PlayerID);
            if (myClan == null)
                return null;
            return myClan.members.ToList();
        }

        [HookMethod("HasFriend")]
        private object HasFriend(ulong entOwnerID, ulong PlayerUserID)
        {
            Clan clanOwner = findClanByUser(entOwnerID.ToString());
            if (clanOwner == null)
                return null;

            Clan clanFriend = findClanByUser(PlayerUserID.ToString());
            if (clanFriend == null)
                return null;

            if (clanOwner.tag == clanFriend.tag)
                return true;

            return false;
        }

        [HookMethod("IsModerator")]
        private object IsModerator(ulong PlayerUserID)
        {
            Clan clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null)
                return null;

            if (setHomeOwner && clan.IsOwner(PlayerUserID.ToString()) || setHomeModerator && (clan.IsModerator(PlayerUserID.ToString()) || clan.IsCouncil(PlayerUserID.ToString())) || setHomeMember)
                return true;

            return false;
        }

        public static int UnixTimeStampUTC()
        {
            return (int) DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
        }

        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
                ? Epoch.AddMilliseconds(unixTimeStamp)
                : Epoch.AddSeconds(unixTimeStamp);
        }

        private string msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        private void PrintChat(BasePlayer player, string message)
        {
            SendReply(player, string.Format(pluginPrefixFormat, pluginPrefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + message + "</color>");
        }

        [ConsoleCommand("clans")]
        private void cclans(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.player != null && arg.Connection.authLevel > 0)
            {
                StringBuilder sb = new StringBuilder();
                sb.AppendLine("\n> Clans command overview <");
                sb.AppendLine("clans.list (Lists all clans, their owners and their member-count)");
                sb.AppendLine("clans.listex (Lists all clans, their owners/members and their on-line status)");
                sb.AppendLine("clans.show \'tag|partialNameOrId\' (lists the chosen clan (or clan by user) and the members with status)");
                sb.AppendLine("clans.msg \'tag\' \'message without quotes\' (Sends a clan message)");

                if (arg.Connection.authLevel >= authLevelCreate)
                    sb.AppendLine("clans.create \'tag(case-sensitive)\' \'steam-id(owner)\' \'desc(optional)\'");

                if (arg.Connection.authLevel >= authLevelRename)
                    sb.AppendLine("clans.rename \'old tag\' \'new tag\' (renames a clan | case-sensitive)");

                if (arg.Connection.authLevel >= authLevelDisband)
                    sb.AppendLine("clans.disband \'tag\' (disbands a clan)");

                if (arg.Connection.authLevel >= authLevelInvite)
                {
                    sb.AppendLine("clans.invite \'tag\' \'partialNameOrId\' (sends clan invitation to a player)");
                    sb.AppendLine("clans.join \'tag\' \'partialNameOrId\' (joins a player into a clan)");
                }

                if (arg.Connection.authLevel >= authLevelKick)
                    sb.AppendLine("clans.kick \'tag\' \'partialNameOrId\' (kicks a member from a clan | deletes invite)");

                if (arg.Connection.authLevel >= authLevelPromoteDemote)
                {
                    sb.AppendLine("clans.owner \'tag\' \'partialNameOrId\' (sets a new owner)");
                    sb.AppendLine("clans.promote \'tag\' \'partialNameOrId\' (promotes a member)");
                    sb.AppendLine("clans.demote \'tag\' \'partialNameOrId\' (demotes a member)");
                }

                SendReply(arg, sb.ToString());
            }
        }

        [ConsoleCommand("clans.cmds")]
        private void cclansCommands(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            StringBuilder sb = new StringBuilder();
            sb.AppendLine("\n> Clans command overview <");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Command");
            textTable.AddColumn("Description");
            textTable.AddRow(new string[]
            {
                "clans.list",
                "lists all clans, their owners and their member-count"
            });

            textTable.AddRow(new string[]
            {
                "clans.listex",
                "lists all clans, their owners/members and their on-line status"
            });

            textTable.AddRow(new string[]
            {
                "clans.show",
                "lists the chosen clan (or clan by user) and the members with status"
            });

            textTable.AddRow(new string[]
            {
                "clans.showduplicates",
                "lists the players which do exist in more than one clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.msg",
                "message without quotes (Sends a clan message)"
            });

            textTable.AddRow(new string[]
            {
                "clans.create",
                "creates a clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.rename",
                "renames a clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.disband",
                "disbands a clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.owner",
                "changes the owner to another member"
            });

            textTable.AddRow(new string[]
            {
                "clans.invite",
                "sends clan invitation to a player"
            });

            textTable.AddRow(new string[]
            {
                "clans.join",
                "joins a player into a clan"
            });

            textTable.AddRow(new string[]
            {
                "clans.kick",
                "kicks a player from a clan | deletes invite"
            });

            textTable.AddRow(new string[]
            {
                "clans.promote",
                "promotes a player"
            });

            textTable.AddRow(new string[]
            {
                "clans.demote",
                "demotes a player"
            });

            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }

        [ConsoleCommand("clans.list")]
        private void cclansList(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Owner");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Count");
            textTable.AddColumn("On");

            foreach (KeyValuePair<string, Clan> iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                IPlayer owner = clan.FindClanMember(clan.owner);
                textTable.AddRow(new string[]
                    {clan.tag, owner.Name, clan.owner, clan.Total.ToString(), clan.Online.ToString()});
            }

            SendReply(arg, "\n>> Current clans <<\n" + textTable.ToString());
        }

        [ConsoleCommand("clans.showduplicates")]
        private void cclansDuplicates(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            TextTable textTable = new TextTable();
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Memberships");
            textTable.AddColumn("PlayerName");
            Dictionary<string, List<string>> clanDuplicates = new Dictionary<string, List<string>>();
            foreach (KeyValuePair<string, Clan> iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (string member in clan.members.ToList())
                    if (!clanDuplicates.ContainsKey(member))
                    {
                        clanDuplicates.Add(member, new List<string>());
                        clanDuplicates[member].Add(clan.tag);
                        continue;
                    }
                    else
                    {
                        clanDuplicates[member].Add(clan.tag);
                    }
            }

            foreach (KeyValuePair<string, List<string>> clDup in clanDuplicates)
            {
                if (clDup.Value.Count < 2)
                    continue;

                IPlayer player = covalence.Players.FindPlayerById(clDup.Key);
                if (player == null)
                    continue;

                textTable.AddRow(new string[] {clDup.Key, string.Join(" | ", clDup.Value.ToArray()), player.Name});
            }

            SendReply(arg, "\n>> Current found duplicates <<\n" + textTable.ToString());
        }

        [ConsoleCommand("clans.listex")]
        private void cclansListEx(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            foreach (KeyValuePair<string, Clan> iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (IPlayer iMember in clan.membersIPlayer.ToList())
                {
                    BasePlayer basePlayer = clan.GetBasePlayer(iMember.Id);
                    textTable.AddRow(new string[]
                    {
                        clan.tag, clan.GetRoleString(iMember.Id), iMember.Name, iMember.Id.ToString(),
                        ((iMember as RustPlayer).IsConnected
                            ? "Connected"
                            : !(basePlayer != null)
                                ? "Not Alive"
                                : "Offline").ToString()
                    });
                }

                textTable.AddRow(new string[] { });
            }

            SendReply(arg, "\n>> Current clans with members <<\n" + textTable.ToString());
        }

        [ConsoleCommand("clans.show")]
        private void cclansShow(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            if (!arg.HasArgs(1))
            {
                SendReply(arg, "Usage: clans.show \'tag|partialNameOrId\'");
                return;
            }

            Clan clan;
            IPlayer checkPlayer = null;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                checkPlayer = covalence.Players.FindPlayer(arg.Args[0]);
                if (checkPlayer == null)
                {
                    SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[0]));
                    SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                    return;
                }

                clan = findClanByUser(checkPlayer.Id);
                if (clan == null)
                {
                    SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                    return;
                }
            }

            StringBuilder sb = new StringBuilder();
            if (checkPlayer == null) sb.AppendLine($"\n>> Show clan [{clan.tag}] <<");
            else sb.AppendLine($"\n>> Show clan [{clan.tag}] by '{checkPlayer.Name}' <<");
            sb.AppendLine($"Description: {clan.description}");
            sb.AppendLine($"Time created: {UnixTimeStampToDateTime(clan.created)}");
            sb.AppendLine($"Last updated: {UnixTimeStampToDateTime(clan.updated)}");
            sb.AppendLine($"Member count: {clan.Total}");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            sb.AppendLine();
            foreach (IPlayer iMember in clan.membersIPlayer.ToList())
            {
                BasePlayer basePlayer = clan.GetBasePlayer(iMember.Id);
                textTable.AddRow(new string[]
                {
                    clan.GetRoleString(iMember.Id), iMember.Name, iMember.Id.ToString(),
                    ((iMember as RustPlayer).IsConnected
                        ? "Connected"
                        : !(basePlayer != null)
                            ? "Not Alive"
                            : "Offline").ToString()
                });
            }

            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }

        [ConsoleCommand("clans.msg")]
        private void cclansBroadcast(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.msg \'tag\' \'your message without quotes\'");
                return;
            }

            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }

            string BroadcastBy = consoleName;
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel == 2)
                    BroadcastBy = "(Admin) " + arg.Connection.username;
                else BroadcastBy = "(Mod) " + arg.Connection.username;
            }

            string Msg = "";
            for (int i = 1; i < arg.Args.Length; i++)
                Msg = Msg + " " + arg.Args[i];

            clan.BroadcastChat($"<color={clanServerColor}>{BroadcastBy}</color>: {Msg}");
            SendReply(arg, $"Broadcast to [{clan.tag}]: {Msg}");
        }

        [ConsoleCommand("clans.create")]
        private void cclansClanCreate(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelCreate)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.create \'tag(case-sensitive)\' \'steamid(owner)\' \'desc(optional)\'");
                return;
            }

            Clan clan;
            if (TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("tagblocked"), arg.Args[0]));
                return;
            }

            if (tagReExt.IsMatch(arg.Args[0]))
            {
                SendReply(arg, string.Format(msg("hintchars"), allowedSpecialChars));
                return;
            }

            if (arg.Args[0].Length < tagLengthMin || arg.Args[0].Length > tagLengthMax)
            {
                SendReply(arg, string.Format(msg("hintlength"), tagLengthMin, tagLengthMax));
                return;
            }

            IPlayer newOwner = covalence.Players.FindPlayerById(arg.Args[1]);
            if (newOwner == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (findClanByUser(newOwner.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), newOwner.Name));
                return;
            }

            clan = Clan.Create(arg.Args[0], arg.HasArgs(3) ? arg.Args[2] : string.Empty, newOwner.Id);
            clan.AddMember(newOwner);
            clan.AddIPlayer(newOwner);

            if (newOwner.IsConnected)
            {
                BasePlayer owner = RustCore.FindPlayerByIdString(newOwner.Id);
                if (owner)
                {
                    clan.AddBasePlayer(owner);
                    SetupPlayer(owner, newOwner, clan: clan);
                    PrintChat(owner, string.Format(msg("nownewowner", newOwner.Id), clan.tag, clan.description) + "\n" + string.Format(msg("inviteplayers", newOwner.Id), colorCmdUsage));
                }
            }

            if (usePermGroups && !permission.GroupExists(permGroupPrefix + clan.tag))
                permission.CreateGroup(permGroupPrefix + clan.tag, "Clan " + clan.tag, 0);

            if (usePermGroups && !permission.UserHasGroup(newOwner.Id, permGroupPrefix + clan.tag))
                permission.AddUserGroup(newOwner.Id, permGroupPrefix + clan.tag);

            clan.OnCreate();

            SendReply(arg, string.Format(msg("youcreated"), clan.tag));

            string CreatedBy = consoleName;

            if (arg.Connection != null)
                CreatedBy = arg.Connection.username;

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{CreatedBy}' created the new clan [{clan.tag}] with '{newOwner.Name}' as owner", this);
        }

        [ConsoleCommand("clans.rename")]
        private void cclansClanRename(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelRename)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.rename \'old tag\' \'new tag (case-sensitive)\'");
                return;
            }

            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }

            if (tagReExt.IsMatch(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("hintchars"), allowedSpecialChars));
                return;
            }

            if (arg.Args[1].Length < tagLengthMin || arg.Args[1].Length > tagLengthMax)
            {
                SendReply(arg, string.Format(msg("hintlength"), tagLengthMin, tagLengthMax));
                return;
            }

            if (clans.ContainsKey(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("tagblocked")));
                return;
            }

            string oldtag = clan.tag;
            clan.tag = arg.Args[1];
            clans.Add(clan.tag, clan);
            RemoveClan(oldtag);
            clansSearch[clan.tag.ToLower()] = clan.tag;
            setupPlayers(clan.members.ToList(), tag: oldtag);

            string oldGroup = permGroupPrefix + oldtag;
            string newGroup = permGroupPrefix + clan.tag;

            if (permission.GroupExists(oldGroup))
            {
                foreach (string member in clan.members.ToList())
                {
                    if (permission.UserHasGroup(member, oldGroup))
                        permission.RemoveUserGroup(member, oldGroup);
                }
                permission.RemoveGroup(oldGroup);
            }

            if (usePermGroups && !permission.GroupExists(newGroup))
                permission.CreateGroup(newGroup, "Clan " + clan.tag, 0);

            foreach (string member in clan.members.ToList())
            {
                if (usePermGroups && !permission.UserHasGroup(member, newGroup))
                    permission.AddUserGroup(member, newGroup);
            }

            string RenamedBy = consoleName;

            if (arg.Connection != null)
                RenamedBy = arg.Connection.username;

            foreach (KeyValuePair<string, Clan> ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                if (allyClan.clanAlliances.Contains(oldtag))
                {
                    allyClan.clanAlliances.Remove(oldtag);
                    allyClan.clanAlliances.Add(clan.tag);
                }

                if (allyClan.invitedAllies.Contains(oldtag))
                {
                    allyClan.invitedAllies.Remove(oldtag);
                    allyClan.invitedAllies.Add(clan.tag);
                }

                if (allyClan.pendingInvites.Contains(oldtag))
                {
                    allyClan.pendingInvites.Remove(oldtag);
                    allyClan.pendingInvites.Add(clan.tag);
                }
            }

            clan.BroadcastLoc("clanrenamed", $"<color={clanServerColor}>{RenamedBy}</color>", clan.tag);
            SendReply(arg, string.Format(msg("yourenamed"), oldtag, clan.tag));
            clan.OnUpdate();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{RenamedBy}' renamed '{oldtag}' to [{clan.tag}]", this);
        }

        [ConsoleCommand("clans.invite")]
        private void cclansPlayerInvite(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.invite \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer invPlayer = myClan.FindServerIPlayer(arg.Args[1]);
            if (invPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsMember(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), invPlayer.Name));
                return;
            }

            if (myClan.IsInvited(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyinvited"), invPlayer.Name));
                return;
            }

            if (findClanByUser(invPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), invPlayer.Name));
                return;
            }

            myClan.AddInvite(invPlayer);
            if (invPlayer.IsConnected)
            {
                BasePlayer invited = RustCore.FindPlayerByIdString(invPlayer.Id);
                if (invited)
                    PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }

            myClan.updated = UnixTimeStampUTC();
            SendReply(arg, $"Invitation for clan '{myClan.tag}' sent to '{invPlayer.Name}'");

            string AddedBy = consoleName;
            if (arg.Connection != null)
                AddedBy = arg.Connection.username;

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{AddedBy}' invited '{invPlayer.Name}' to [{myClan.tag}]", this);
        }

        [ConsoleCommand("clans.join")]
        private void cclansPlayerJoin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.join \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer joinPlayer = myClan.FindServerIPlayer(arg.Args[1]);
            if (joinPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsMember(joinPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), joinPlayer.Name));
                return;
            }

            if (findClanByUser(joinPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), joinPlayer.Name));
                return;
            }

            myClan.AddMember(joinPlayer);
            myClan.AddIPlayer(joinPlayer);
            BasePlayer joinBasePlayer = RustCore.FindPlayerByIdString(joinPlayer.Id);
            if (joinBasePlayer != null)
            {
                myClan.AddBasePlayer(joinBasePlayer);
                SetupPlayer(joinBasePlayer, joinPlayer, false, myClan);
            }

            if (usePermGroups && !permission.UserHasGroup(joinPlayer.Id, permGroupPrefix + myClan.tag))
                permission.AddUserGroup(joinPlayer.Id, permGroupPrefix + myClan.tag);

            myClan.BroadcastLoc("playerjoined", myClan.GetColoredName(joinPlayer.Id, joinPlayer.Name));
            myClan.OnUpdate();

            List<string> others = new List<string>(myClan.members.ToList());
            others.Remove(joinPlayer.Id);

            Interface.Oxide.CallHook("OnClanMemberJoined", joinPlayer.Id, others);

            SendReply(arg, $"Playerjoin into clan '{myClan.tag}' done for '{joinPlayer.Name}'");

            string AddedBy = consoleName;

            if (arg.Connection != null)
                AddedBy = arg.Connection.username;

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{AddedBy}' added '{joinPlayer.Name}' to [{myClan.tag}]", this);
        }

        [ConsoleCommand("clans.kick")]
        private void cclansPlayerKick(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelKick)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.kick \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer kickPlayer = myClan.FindClanMember(arg.Args[1]);
            if (kickPlayer == null)
                kickPlayer = myClan.FindInvitedIPlayer(arg.Args[1]);

            if (kickPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                SendReply(arg, string.Format(msg("notmembercannotkicked"), kickPlayer.Name));
                return;
            }

            if (myClan.Total == 1)
            {
                SendReply(arg, "The clan has only one member. You need to delete the clan");
                return;
            }

            bool wasMember = myClan.IsMember(kickPlayer.Id);
            myClan.RemoveMember(kickPlayer);
            bool ownerChanged = myClan.ValidateOwner();
            if (wasMember)
            {
                BasePlayer kickBasePlayer = RustCore.FindPlayerByIdString(kickPlayer.Id);

                if (kickBasePlayer != null)
                    SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);

                if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag))
                    permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);

                myClan.OnUpdate(true);
                Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members.ToList());
            }

            SendReply(arg, $"Player '{kickPlayer.Name}' was {(wasMember ? "kicked" : "withdrawn")} from clan '{myClan.tag}'");

            if (ownerChanged)
            {
                IPlayer newOwner = myClan.FindServerIPlayer(myClan.owner);
                if (newOwner != null) SendReply(arg, $"New owner of clan '{myClan.tag}' is {newOwner.Name}");
            }

            string KickedBy = consoleName;
            if (arg.Connection != null)
                KickedBy = arg.Connection.username;

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{KickedBy}' kicked '{kickPlayer.Name}' from [{myClan.tag}]", this);
        }

        [ConsoleCommand("clans.owner")]
        private void cclansClanOwner(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.owner \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer newOwner = myClan.FindClanMember(arg.Args[1]);
            if (newOwner == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsOwner(newOwner.Id))
            {
                SendReply(arg, string.Format(msg("alreadyowner"), newOwner.Name));
                return;
            }

            string AssignedBy = consoleName;

            if (arg.Connection != null)
                AssignedBy = arg.Connection.username;

            if (myClan.council == newOwner.Id)
                myClan.council = null;

            myClan.RemoveModerator(newOwner);
            myClan.owner = newOwner.Id;

            myClan.BroadcastLoc("playerpromotedowner", $"<color={clanServerColor}>{AssignedBy}</color>", myClan.GetColoredName(newOwner.Id, newOwner.Name));
            myClan.OnUpdate();

            SendReply(arg, $"You promoted '{newOwner.Name}' to the {myClan.GetRoleString(newOwner.Id.ToString())}");

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{AssignedBy}' promoted '{newOwner.Name}' of [{myClan.tag}] to the clan owner", this);
        }

        [ConsoleCommand("clans.promote")]
        private void cclansPlayerPromote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.promote \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else
            {
                myClan = (Clan) check;
            }

            IPlayer promotePlayer = myClan.FindClanMember(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsOwner(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("ownercannotbepromoted"), promotePlayer.Name));
                return;
            }

            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncil"), promotePlayer.Name));
                return;
            }

            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncilset"), promotePlayer.Name));
                return;
            }

            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyamod"), promotePlayer.Name));
                return;
            }

            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.Mods >= limitModerators)
            {
                SendReply(arg, string.Format(msg("maximummods")));
                return;
            }

            string PromotedBy = consoleName;
            if (arg.Connection != null)
                PromotedBy = arg.Connection.username;

            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.SetCouncil(promotePlayer.Id);
                myClan.RemoveModerator(promotePlayer);
                myClan.BroadcastLoc("playerpromotedcouncil", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.GetColoredName(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.SetModerator(promotePlayer);
                myClan.BroadcastLoc("playerpromoted", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.GetColoredName(promotePlayer.Id, promotePlayer.Name));
            }

            myClan.OnUpdate();

            SendReply(arg, $"You promoted '{promotePlayer.Name}' to a {myClan.GetRoleString(promotePlayer.Id.ToString())}");

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{PromotedBy}' promoted '{promotePlayer.Name}' of [{myClan.tag}] to {myClan.GetRoleString(promotePlayer.Id.ToString())}", this);
        }

        [ConsoleCommand("clans.demote")]
        private void cclansPlayerDemote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.demote \'tag\' \'partialNameOrId\'");
                return;
            }

            Clan myClan = null;
            if (!TryGetClan(arg.Args[0], out myClan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }

            IPlayer demotePlayer = myClan.FindClanMember(arg.Args[1]);
            if (demotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }

            if (myClan.IsOwner(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("ownercannotbedemoted"), demotePlayer.Name));
                return;
            }

            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notpromoted"), demotePlayer.Name));
                return;
            }

            string DemotedBy = consoleName;

            if (arg.Connection != null)
                DemotedBy = arg.Connection.username;

            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.SetCouncil();
                if (limitModerators >= 0 && myClan.Mods >= limitModerators)
                {
                    myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
                }
                else
                {
                    myClan.SetModerator(demotePlayer);
                    myClan.BroadcastLoc("councildemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.RemoveModerator(demotePlayer);
                myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.GetColoredName(demotePlayer.Id, demotePlayer.Name));
            }

            myClan.OnUpdate();

            SendReply(arg, $"You demoted '{demotePlayer.Name}' to a {myClan.GetRoleString(demotePlayer.Id.ToString())}");

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{DemotedBy}' demoted '{demotePlayer.Name}' of [{myClan.tag}] to {myClan.GetRoleString(demotePlayer.Id.ToString())}", this);
        }

        [ConsoleCommand("clans.disband")]
        private void cclansClanDisband(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelDisband)
                return;

            if (!arg.HasArgs(2))
            {
                SendReply(arg, "Usage: clans.disband \'tag\' \'force|f|true\'");
                return;
            }

            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }

            string DeletedBy = arg.Connection == null ? consoleName : arg.Connection.username;

            clan.BroadcastLoc("clandeleted", $"<color={clanServerColor}>{DeletedBy}</color>");
            RemoveClan(clan.tag);

            foreach (string member in clan.members.ToList())
                clanCache.Remove(member);

            setupPlayers(clan.members.ToList(), true, tag: clan.tag);

            string permGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(permGroup))
            {
                foreach (string member in clan.members.ToList())
                {
                    if (permission.UserHasGroup(member, permGroup))
                        permission.RemoveUserGroup(member, permGroup);
                }
                permission.RemoveGroup(permGroup);
            }

            foreach (KeyValuePair<string, Clan> ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(arg.Args[0]);
                allyClan.invitedAllies.Remove(arg.Args[0]);
                allyClan.pendingInvites.Remove(arg.Args[0]);
            }

            SendReply(arg, string.Format(msg("youdeleted"), clan.tag));
            clan.OnDestroy();

            Interface.Oxide.CallHook("OnClanDisbanded", clan.members.ToList());
            AllyRemovalCheck();

            if (logClanChanges)
                LogToFile("ClanChanges", $"{DateTime.Now.ToString()} - Console: '{DeletedBy}' disbanded [{clan.tag}]", this);

            clan.DisbandTeam();
        }

        private bool FilterText(string tag)
        {
            foreach (string bannedword in wordFilter)
            {
                if (TranslateLeet(tag).ToLower().Contains(bannedword.ToLower()))
                    return true;
            }
            return false;
        }

        private string TranslateLeet(string original)
        {
            string translated = original;
            Dictionary<string, string> leetTable = new Dictionary<string, string>
            {
                {
                    "}{",
                    "h"
                },
                {
                    "|-|",
                    "h"
                },
                {
                    "]-[",
                    "h"
                },
                {
                    "/-/",
                    "h"
                },
                {
                    "|{",
                    "k"
                },
                {
                    "/\\/\\",
                    "m"
                },
                {
                    "|\\|",
                    "n"
                },
                {
                    "/\\/",
                    "n"
                },
                {
                    "()",
                    "o"
                },
                {
                    "[]",
                    "o"
                },
                {
                    "vv",
                    "w"
                },
                {
                    "\\/\\/",
                    "w"
                },
                {
                    "><",
                    "x"
                },
                {
                    "2",
                    "z"
                },
                {
                    "4",
                    "a"
                },
                {
                    "@",
                    "a"
                },
                {
                    "8",
                    "b"
                },
                {
                    "ß",
                    "b"
                },
                {
                    "(",
                    "c"
                },
                {
                    "<",
                    "c"
                },
                {
                    "{",
                    "c"
                },
                {
                    "3",
                    "e"
                },
                {
                    "€",
                    "e"
                },
                {
                    "6",
                    "g"
                },
                {
                    "9",
                    "g"
                },
                {
                    "&",
                    "g"
                },
                {
                    "#",
                    "h"
                },
                {
                    "$",
                    "s"
                },
                {
                    "7",
                    "t"
                },
                {
                    "|",
                    "l"
                },
                {
                    "1",
                    "i"
                },
                {
                    "!",
                    "i"
                },
                {
                    "0",
                    "o"
                },
            };
            foreach (KeyValuePair<string, string> leet in leetTable)
                translated = translated.Replace(leet.Key, leet.Value);
            return translated;
        }

        private bool TryGetClan(string input, out Clan clan)
        {
            clan = default(Clan);

            if (clans.TryGetValue(input, out clan))
                return true;

            if (clansSearch.TryGetValue(input.ToLower(), out input))
            {
                if (clans.TryGetValue(input, out clan))
                    return true;
            }

            return false;
        }

        private void RemoveClan(string tag)
        {
            clans.Remove(tag);
            clansSearch.Remove(tag.ToLower());
        }

        [HookMethod("EnableBypass")]
        private void EnableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null)
                return;

            if (userId is string)
                userId = Convert.ToUInt64((string) userId);

            bypass.Add((ulong) userId);
        }

        [HookMethod("DisableBypass")]
        private void DisableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null)
                return;

            if (userId is string)
                userId = Convert.ToUInt64((string) userId);

            bypass.Remove((ulong) userId);
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            if (enableClanTagging && plugin.Title == "Better Chat")
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }

        private string getFormattedClanTag(IPlayer player)
        {
            Clan clan = findClanByUser(player.Id);
            if (clan != null)
                return $"[#{clanTagColorBetterChat.Replace("#", "")}][+{clanTagSizeBetterChat}][{clan.tag}][/+][/#]";
            return string.Empty;
        }

        private List<ulong> usedConsoleInput = new List<ulong>();

        private void ChatSwitch(BasePlayer player, string message, bool keepConsole = false)
        {
            if (usedConsoleInput.Contains(player.userID))
                player.ConsoleMessage(message);
            else SendReply(player, message);

            if (!keepConsole)
                usedConsoleInput.Remove(player.userID);
        }
    }
}

// --- End of file: Clans (2).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InsultGenerator.cs ---
// --- Original Local Path: InsultGenerator.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("InsultGenerator", "Spicy", 1.0)]
    [Description("Grabs an insult from the web and pastes it to a player on command.")]

    class InsultGenerator : RustPlugin
    {
        void Init()
        {
            LoadLang();
            RegisterPermission("insultgenerator.use");
        }

        void LoadLang()
        {
            var messages = new Dictionary<string, string>
            {
                {"ChatPrefix", "InsultGenerator"},
                {"InvalidSyntax", "Syntax: /insult [me | playername]"},
                {"SelfInsult", "You insulted yourself."},
                {"OtherInsult", "You insulted: "},
                {"GetInsulted", " insulted you!"},
                {"NoUsersFound", "No users found with that name."},
                {"NoPermission", "You don't have permission to use this command!"},
                {"WebRequestFailed", "Webrequest for InsultGenerator failed!"}
            };
            lang.RegisterMessages(messages, this);
        }

        string GetLangMessage(string key)
        {
            return lang.GetMessage(key, this);
        }

        void RegisterPermission(string permission_name)
        {
            permission.RegisterPermission(permission_name, this);
        }

        bool HasPermission(string steamid, string permission_name)
        {
            if (permission.UserHasPermission(steamid, permission_name))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        void SendMessage(BasePlayer player, string message)
        {
            rust.SendChatMessage(player, GetLangMessage("ChatPrefix"), message);
        }

        BasePlayer FindPlayer(string args)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == args)
                    return activePlayer;
                if (activePlayer.displayName.ToLower().Contains(args.ToLower()))
                    return activePlayer;
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == args)
                    return activePlayer;
            }
            return null;
        }

        [ChatCommand("insult")]
        void cmdInsult(BasePlayer player, string command, string[] args)
        {
            string steamid = rust.UserIDFromPlayer(player).ToString();
            if(HasPermission(steamid, "insultgenerator.use"))
            {
                if (args == null || args.Length == 0)
                {
                    SendMessage(player, GetLangMessage("InvalidSyntax"));
                }
                else if (args[0] == "me")
                {
                    Request("http://insultgenerator.org", player, player);
                }
                else
                {
                    if (FindPlayer(args[0]) != null)
                    {
                        var target = FindPlayer(args[0]);
                        
                        Request("http://insultgenerator.org", target, player);
                    }
                    else
                    {
                        SendMessage(player, GetLangMessage("NoUsersFound"));
                    }
                }
            }
            else
            {
                SendMessage(player, GetLangMessage("NoPermission"));
            }
        }

        void Request(string page, BasePlayer playertoinsult, BasePlayer player)
        {
            webrequest.EnqueueGet(page, (code, response) => GetCallback(code, response, page, playertoinsult, player), this);
        }

        void GetCallback(int code, string response, string page, BasePlayer playertoinsult, BasePlayer player)
        {
            if (response == null || code != 200)
            {
                Puts(GetLangMessage("WebRequestFailed"));
            }
            else
            {
                string insult = Insult(response);
                if (playertoinsult == player)
                {
                    SendMessage(player, GetLangMessage("SelfInsult"));
                    SendMessage(playertoinsult, insult);
                }
                else
                {
                    SendMessage(player, GetLangMessage("OtherInsult") + playertoinsult.displayName + " with insult:\n" + insult);
                    SendMessage(playertoinsult, player.displayName + GetLangMessage("GetInsulted"));
                    SendMessage(playertoinsult, insult);
                }
            }
        }

        string Insult(string response)
        {
            int start = response.IndexOf("<br><br>");
            int end = response.IndexOf("</div>\n<center>");
            string insult = response.Substring(start + 8, end - start - 8);

            return insult;
        }
    }
}

// --- End of file: InsultGenerator.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CopyPaste.cs ---
// --- Original Local Path: CopyPaste.cs ---

﻿using Facepunch;
using Oxide.Core;
using Oxide.Core.Libraries;
using Newtonsoft.Json;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Copy Paste", "FIX BY HUZAKI| Reneb ", "3.5.4", ResourceId = 716)]
	[Description("Copy and paste your buildings to save them or move them")]

	class CopyPaste : RustPlugin
	{
		private int copyLayer 		= LayerMask.GetMask("Construction", "Construction Trigger", "Trigger", "Deployed", "Default");
		private int groundLayer 	= LayerMask.GetMask("Terrain", "Default");
		private int rayCopy 		= LayerMask.GetMask("Construction", "Deployed", "Tree", "Resource", "Prevent Building");
		private int rayPaste 		= LayerMask.GetMask("Construction", "Deployed", "Tree", "Terrain", "World", "Water", "Prevent Building");

		private string copyPermission	= "copypaste.copy";
		private string pastePermission	= "copypaste.paste";
		private string undoPermission	= "copypaste.undo";
		private string serverID			= "Server";
		private string subDirectory		= "copypaste/";

		private Dictionary<string, Stack<List<BaseEntity>>> lastPastes = new Dictionary<string, Stack<List<BaseEntity>>>();

		private List<BaseEntity.Slot> checkSlots = new List<BaseEntity.Slot>()
		{
			BaseEntity.Slot.Lock,
			BaseEntity.Slot.UpperModifier,
			BaseEntity.Slot.MiddleModifier,
			BaseEntity.Slot.LowerModifier
		};

		private enum CopyMechanics { Building, Proximity }

		private FieldInfo _equippingActive = typeof(Locker).GetField("equippingActive", (BindingFlags.Instance | BindingFlags.NonPublic));
		
		//Config

		private ConfigData config;

		private class ConfigData
		{
			[JsonProperty(PropertyName = "Copy Options")]
			public CopyOptions Copy { get; set; }

			[JsonProperty(PropertyName = "Paste Options")]
			public PasteOptions Paste { get; set; }
			
			public class CopyOptions
			{
				[JsonProperty(PropertyName = "Buildings (true/false)")]
				[DefaultValue(true)]
				public bool Buildings { get; set; } = true;

				[JsonProperty(PropertyName = "Deployables (true/false)")]
				[DefaultValue(true)]
				public bool Deployables { get; set; } = true;

				[JsonProperty(PropertyName = "Check radius from each entity (true/false)")]
				[DefaultValue(true)]
				public bool EachToEach { get; set; } = true;
				
				[JsonProperty(PropertyName = "Inventories (true/false)")]
				[DefaultValue(true)]
				public bool Inventories { get; set; } = true;
				
				[JsonProperty(PropertyName = "Share (true/false)")]
				[DefaultValue(false)]
				public bool Share { get; set; } = false;

				[JsonProperty(PropertyName = "Tree (true/false)")]
				[DefaultValue(false)]
				public bool Tree { get; set; } = false;
			}

			public class PasteOptions
			{
				[JsonProperty(PropertyName = "Auth (true/false)")]
				[DefaultValue(false)]
				public bool Auth { get; set; } = false;

				[JsonProperty(PropertyName = "Deployables (true/false)")]
				[DefaultValue(true)]
				public bool Deployables { get; set; } = true;
				
				[JsonProperty(PropertyName = "Inventories (true/false)")]
				[DefaultValue(true)]
				public bool Inventories { get; set; } = true;
				
				[JsonProperty(PropertyName = "Vending Machines (true/false)")]
				[DefaultValue(true)]
				public bool VendingMachines { get; set; } = true;	

				[JsonProperty(PropertyName = "Stability (true/false)")]
				[DefaultValue(true)]
				public bool Stability { get; set; } = true;					
			}
		}

		private void LoadVariables()
		{
			Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
			
			config = Config.ReadObject<ConfigData>();

			Config.WriteObject(config, true);
		}

		protected override void LoadDefaultConfig()
		{
			var configData = new ConfigData
			{
				Copy = new ConfigData.CopyOptions(),
				Paste = new ConfigData.PasteOptions()
			};
			
			Config.WriteObject(configData, true);
		}
		
		//Hooks

		private void Init()
		{
			permission.RegisterPermission(copyPermission, this);
			permission.RegisterPermission(pastePermission, this);
			permission.RegisterPermission(undoPermission, this);

			Dictionary<string, Dictionary<string, string>> compiledLangs = new Dictionary<string, Dictionary<string, string>>();

			foreach(var line in messages)
			{
				foreach(var translate in line.Value)
				{
					if(!compiledLangs.ContainsKey(translate.Key))
						compiledLangs[translate.Key] = new Dictionary<string, string>();

					compiledLangs[translate.Key][line.Key] = translate.Value;
				}
			}

			foreach(var cLangs in compiledLangs)
			{
				lang.RegisterMessages(cLangs.Value, this, cLangs.Key);
			}
		}

		private void OnServerInitialized() => LoadVariables();

		//API

		object TryCopyFromSteamID(ulong userID, string filename, string[] args)
		{
			var player = BasePlayer.FindByID(userID);

			if(player == null)
				return Lang("NOT_FOUND_PLAYER", player.UserIDString);

			RaycastHit hit;
			
			if(!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, rayCopy))
				return Lang("NO_ENTITY_RAY", player.UserIDString);
			
			return TryCopy(hit.point, hit.GetEntity().transform.rotation.ToEulerAngles(), filename, Quaternion.Euler(player.GetNetworkRotation()).ToEulerAngles().y, args);
		}
		
		object TryPasteFromSteamID(ulong userID, string filename, string[] args)
		{
			var player = BasePlayer.FindByID(userID);

			if(player == null)
				return Lang("NOT_FOUND_PLAYER", player.UserIDString);
			
			RaycastHit hit;
			
			if(!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, rayPaste))
				return Lang("NO_ENTITY_RAY", player.UserIDString);

			return TryPaste(hit.point, filename, player, Quaternion.Euler(player.GetNetworkRotation()).ToEulerAngles().y, args);
		}

		object TryPasteFromVector3(Vector3 pos, float rotationCorrection, string filename, string[] args)
		{
			return TryPaste(pos, filename, null, rotationCorrection, args);
		}

		//Other methods

		private object CheckCollision(List<Dictionary<string,object>> entities, Vector3 startPos, float radius)
		{
			foreach(var entityobj in entities)
			{
				if(Physics.CheckSphere((Vector3)entityobj["position"], radius, copyLayer))
					return Lang("BLOCKING_PASTE", null);
			}

			return true;
		}
		
		private bool CheckPlaced(string prefabname, Vector3 pos, Quaternion rot)
		{
			List<BaseEntity> ents = new List<BaseEntity>();
			Vis.Entities<BaseEntity>(pos, 2f, ents);

			foreach(BaseEntity ent in ents)
			{
				if(ent.PrefabName == prefabname && ent.transform.position == pos && ent.transform.rotation == rot)
					return true;
			}

			return false;
		}
		
		private object cmdPasteBack(BasePlayer player, string[] args)
		{
			string userIDString = (player == null) ? serverID : player.UserIDString;

			if(args.Length < 1)
				return Lang("SYNTAX_PASTEBACK", userIDString);

			var success = TryPasteBack(args[0], player, args.Skip(1).ToArray());

			if(success is string)
				return (string)success;
			
			if(!lastPastes.ContainsKey(userIDString))
				lastPastes[userIDString] = new Stack<List<BaseEntity>>();
			
			lastPastes[userIDString].Push((List<BaseEntity>)success);

			return true;
		}

		private object cmdUndo(string userIDString, string[] args)
		{
			if(!lastPastes.ContainsKey(userIDString))
				return Lang("NO_PASTED_STRUCTURE", userIDString);

			foreach(var entity in lastPastes[userIDString].Pop())
			{
				if(entity == null || entity.IsDestroyed)
					continue;

				entity.Kill();
			}

			if(lastPastes[userIDString].Count == 0)
				lastPastes.Remove(userIDString);

			return true;
		}

		private object Copy(Vector3 sourcePos, Vector3 sourceRot, string filename, float RotationCorrection, CopyMechanics copyMechanics, float range, bool saveBuildings, bool saveDeployables, bool saveInventories, bool saveTree, bool saveShare, bool eachToEach)
		{
			var rawData = new List<object>();
			var copy = CopyProcess(sourcePos, sourceRot, RotationCorrection, range, saveBuildings, saveDeployables, saveInventories, saveTree, saveShare, copyMechanics, eachToEach);

			if(copy is string)
				return copy;

			rawData = copy as List<object>;

			var defaultData = new Dictionary<string, object>
			{
				{"position", new Dictionary<string, object>
					{
						{"x", sourcePos.x.ToString()  },
						{"y", sourcePos.y.ToString() },
						{"z", sourcePos.z.ToString() }
					}
				},
				{"rotationy", sourceRot.y.ToString() },
				{"rotationdiff", RotationCorrection.ToString() }
			};

			string path = subDirectory + filename;
			var CopyData = Interface.Oxide.DataFileSystem.GetDatafile(path);

			CopyData.Clear();
			CopyData["default"] = defaultData;
			CopyData["entities"] = rawData;

			Interface.Oxide.DataFileSystem.SaveDatafile(path);

			return true;
		}

		private object CopyProcess(Vector3 sourcePos, Vector3 sourceRot, float RotationCorrection, float range, bool saveBuildings, bool saveDeployables, bool saveInventories, bool saveTree, bool saveShare, CopyMechanics copyMechanics, bool eachToEach)
		{
			var rawData = new List<object>();
			var houseList = new List<BaseEntity>();
			var checkFrom = new List<Vector3> { sourcePos };
			uint buildingID = 0;
			int currentLayer = copyLayer;
			int current = 0;

			if(saveTree)
				currentLayer |= LayerMask.GetMask("Tree");

			while(current < checkFrom.Count)
			{
				List<BaseEntity> list = Pool.GetList<BaseEntity>();
				Vis.Entities<BaseEntity>(checkFrom[current], range, list, currentLayer);

				foreach(var entity in list)
				{
					if(!IsValid(entity) || houseList.Contains(entity))
						continue;
				
					houseList.Add(entity);

					if(copyMechanics == CopyMechanics.Building)
					{
						BuildingBlock buildingBlock = entity.GetComponentInParent<BuildingBlock>();

						if(buildingBlock)
						{
							if(buildingID == 0)
								buildingID = buildingBlock.buildingID;
							else if(buildingID != buildingBlock.buildingID)
								continue;
						}
					}

					if(eachToEach && !checkFrom.Contains(entity.transform.position))
						checkFrom.Add(entity.transform.position);

					if(!saveBuildings && entity.GetComponentInParent<BuildingBlock>() != null)
						continue;

					if(!saveDeployables && (entity.GetComponentInParent<BuildingBlock>() == null && entity.GetComponent<BaseCombatEntity>() != null))
						continue;

					rawData.Add(EntityData(entity, sourcePos, sourceRot, entity.transform.position, entity.transform.rotation.ToEulerAngles(), RotationCorrection, saveInventories, saveShare));
				}

				current++;
			}

			return rawData;
		}
		
		private Dictionary<string, object> EntityData(BaseEntity entity, Vector3 sourcePos, Vector3 sourceRot, Vector3 entPos, Vector3 entRot, float diffRot, bool saveInventories, bool saveShare)
		{
			var normalizedPos = NormalizePosition(sourcePos, entPos, diffRot);
			
			entRot.y -= diffRot;

			var data = new Dictionary<string, object>
			{
				{"prefabname", entity.PrefabName},
				{"skinid", entity.skinID},
				{"flags", TryCopyFlags(entity)},
				{"pos", new Dictionary<string,object>
					{
						{"x", normalizedPos.x.ToString()},
						{"y", normalizedPos.y.ToString()},
						{"z", normalizedPos.z.ToString()}
					}
				},
				{"rot", new Dictionary<string,object>
					{
						{"x", entRot.x.ToString()},
						{"y", entRot.y.ToString()},
						{"z", entRot.z.ToString()},
					}
				}
			};
			
			TryCopySlots(entity, data, saveShare);

			var buildingblock = entity.GetComponentInParent<BuildingBlock>();

			if(buildingblock != null )
			{
				data.Add("grade", buildingblock.grade);
			}

			var box = entity.GetComponentInParent<StorageContainer>();

			if(box != null)
			{
				var itemlist = new List<object>();

				if(saveInventories)
				{
					foreach(Item item in box.inventory.itemList)
					{
						var itemdata = new Dictionary<string, object>
						{
							{"condition", item.condition.ToString() },
							{"id", item.info.itemid },
							{"amount", item.amount },
							{"skinid", item.skin },
							{"position", item.position },
						};

						var heldEnt = item.GetHeldEntity();

						if(heldEnt != null)
						{
							var projectiles = heldEnt.GetComponent<BaseProjectile>();

							if(projectiles != null)
							{
								var magazine = projectiles.primaryMagazine;

								if(magazine != null)
								{
									itemdata.Add("magazine", new Dictionary<string, object>
									{
										{ magazine.ammoType.itemid.ToString(), magazine.contents }
									});
								}
							}
						}

						if(item?.contents?.itemList != null)
						{
							var contents = new List<object>();

							foreach(Item itemContains in item.contents.itemList)
							{
								contents.Add(new Dictionary<string, object>
								{
									{"id", itemContains.info.itemid },
									{"amount", itemContains.amount },
								});
							}

							itemdata["items"] = contents;
						}

						itemlist.Add(itemdata);
					}
				}

				data.Add("items", itemlist);
			}

			var sign = entity.GetComponentInParent<Signage>();

			if(sign != null)
			{
				var imageByte = FileStorage.server.Get(sign.textureID, FileStorage.Type.png, sign.net.ID);

				data.Add("sign", new Dictionary<string, object>
				{
					{"locked", sign.IsLocked()}
				});

				if(sign.textureID > 0 && imageByte != null)
					((Dictionary<string, object>)data["sign"]).Add("texture", Convert.ToBase64String(imageByte));
			}

			if(saveShare)
			{
				var sleepingBag = entity.GetComponentInParent<SleepingBag>();

				if(sleepingBag != null)
				{
					data.Add("sleepingbag", new Dictionary<string, object>
					{
						{"niceName", sleepingBag.niceName },
						{"deployerUserID", sleepingBag.deployerUserID },
						{"isPublic", sleepingBag.IsPublic() },
					});
				}

				var cupboard = entity.GetComponentInParent<BuildingPrivlidge>();

				if(cupboard != null)
				{
					data.Add("cupboard", new Dictionary<string, object>
					{
						{"authorizedPlayers", cupboard.authorizedPlayers.Select(y => y.userid).ToList() }
					});
				}
			}

			var vendingMachine = entity.GetComponentInParent<VendingMachine>();
			
			if(vendingMachine != null)
			{				
				var sellOrders = new List<object>();
				
				foreach(var vendItem in vendingMachine.sellOrders.sellOrders)
				{
					sellOrders.Add(new Dictionary<string, object>
					{
						{"itemToSellID", vendItem.itemToSellID },
						{"itemToSellAmount", vendItem.itemToSellAmount },	
						{"currencyID", vendItem.currencyID },	
						{"currencyAmountPerItem", vendItem.currencyAmountPerItem },							
					});					
				}
				
				data.Add("vendingmachine", new Dictionary<string, object>
				{
					{"shopName", vendingMachine.shopName },
					{"isBroadcasting", vendingMachine.IsBroadcasting() },
					{"sellOrders", sellOrders}
				});
			}
			
			return data;
		}

		private object FindBestHeight(List<Dictionary<string,object>> entities, Vector3 startPos)
		{
			float maxHeight = 0f;

			foreach(var entity in entities)
			{
				if(((string)entity["prefabname"]).Contains("/foundation/"))
				{
					var foundHeight = GetGround((Vector3)entity["position"]);

					if(foundHeight != null)
					{
						var height = (Vector3)foundHeight;

						if(height.y > maxHeight)
							maxHeight = height.y;
					}
				}
			}

			maxHeight += 1f;

			return maxHeight;
		}

		private bool FindRayEntity(Vector3 sourcePos, Vector3 sourceDir, out Vector3 point, out BaseEntity entity, int rayLayer)
		{
			RaycastHit hitinfo;
			entity = null;
			point = Vector3.zero;

			if(!Physics.Raycast(sourcePos, sourceDir, out hitinfo, 1000f, rayLayer))
				return false;

			entity = hitinfo.GetEntity();
			point = hitinfo.point;

			return true;
		}

		private object GetGround(Vector3 pos)
		{
			RaycastHit hitInfo;

			if(Physics.Raycast(pos, Vector3.up, out hitInfo, groundLayer))
				return hitInfo.point;

			if(Physics.Raycast(pos, Vector3.down, out hitInfo, groundLayer))
				return hitInfo.point;

			return null;
		}

		private bool HasAccess(BasePlayer player, string permName)
		{
			return player.IsAdmin || permission.UserHasPermission(player.UserIDString, permName);
		}

		private bool IsValid(BaseEntity entity)
		{
			return (entity.GetComponentInParent<BuildingBlock>() != null || entity.GetComponentInParent<BaseCombatEntity>() != null || entity.GetComponentInParent<Spawnable>() != null);
		}

		private string Lang(string key, string userID = null, params object[] args) => string.Format(lang.GetMessage(key, this, userID), args);
		
		private Vector3 NormalizePosition(Vector3 InitialPos, Vector3 CurrentPos, float diffRot)
		{
			var transformedPos = CurrentPos - InitialPos;
			var newX = (transformedPos.x * (float)System.Math.Cos(-diffRot)) + (transformedPos.z * (float)System.Math.Sin(-diffRot));
			var newZ = (transformedPos.z * (float)System.Math.Cos(-diffRot)) - (transformedPos.x * (float)System.Math.Sin(-diffRot));

			transformedPos.x = newX;
			transformedPos.z = newZ;

			return transformedPos;
		}
		
		private List<BaseEntity> Paste(List<Dictionary<string,object>> entities, Vector3 startPos, BasePlayer player, bool stability)
		{
			uint buildingID = 0;
			var pastedEntities = new List<BaseEntity>();

			foreach(var data in entities)
			{
				string prefabname = (string)data["prefabname"];
				ulong skinid = ulong.Parse(data["skinid"].ToString());
				Vector3 pos = (Vector3)data["position"];
				Quaternion rot = (Quaternion)data["rotation"];

				if(CheckPlaced(prefabname, pos, rot))
					continue;

				var entity = GameManager.server.CreateEntity(prefabname, pos, rot, true);

				if(entity == null)
					continue;
				
				entity.transform.position = pos;
				entity.transform.rotation = rot;

				if(player != null)
				{
					entity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);
					entity.OwnerID = player.userID;
				}

				BuildingBlock buildingBlock = entity.GetComponentInParent<BuildingBlock>();

				if(buildingBlock != null)
				{
					buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
					buildingBlock.SetGrade((BuildingGrade.Enum)data["grade"]);
					
					if(!stability)
						buildingBlock.grounded = true;
				}
				
				DecayEntity decayEntity = entity.GetComponentInParent<DecayEntity>();
				
				if(decayEntity != null)
				{
					if(buildingID == 0)
						buildingID = BuildingManager.server.NewBuildingID();

					decayEntity.AttachToBuilding(buildingID);
				}

				entity.skinID = skinid;
				entity.Spawn();

				var baseCombat = entity.GetComponentInParent<BaseCombatEntity>();

				if(baseCombat != null)
					baseCombat.ChangeHealth(baseCombat.MaxHealth());

				pastedEntities.AddRange(TryPasteSlots(entity, data));

				var box = entity.GetComponentInParent<StorageContainer>();

				if(box != null)
				{				
					Locker locker = box as Locker;
					
					if(locker != null)
						_equippingActive.SetValue(locker, true);
					
					box.inventory.Clear();
					
					var items = new List<object>();

					if(data.ContainsKey("items"))					
						items = data["items"] as List<object>;
					
					foreach(var itemDef in items)
					{
						var item = itemDef as Dictionary<string, object>;
						var itemid = Convert.ToInt32(item["id"]);
						var itemamount = Convert.ToInt32(item["amount"]);
						var itemskin = ulong.Parse(item["skinid"].ToString());
						var itemcondition = Convert.ToSingle(item["condition"]);

						var i = ItemManager.CreateByItemID(itemid, itemamount, itemskin);

						if(i != null)
						{
							i.condition = itemcondition;

							if(item.ContainsKey("magazine"))
							{
								var heldent = i.GetHeldEntity();

								if(heldent != null)
								{
									var projectiles = heldent.GetComponent<BaseProjectile>();

									if(projectiles != null)
									{
										var magazine = item["magazine"] as Dictionary<string, object>;
										var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
										var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());

										projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
										projectiles.primaryMagazine.contents = ammoamount;
									}

									//TODO Не добавляет капли воды в некоторые контейнеры

									if(item.ContainsKey("items"))
									{
										var itemContainsList = item["items"] as List<object>;

										foreach(var itemContains in itemContainsList)
										{
											var contents = itemContains as Dictionary<string, object>;

											i.contents.AddItem(ItemManager.FindItemDefinition(Convert.ToInt32(contents["id"])), Convert.ToInt32(contents["amount"]));
										}
									}
								}
							}

							int targetPos = -1;
							
							if(item.ContainsKey("position"))
								targetPos = Convert.ToInt32(item["position"]);
							
							i.MoveToContainer(box.inventory, targetPos);
						}
					}
					
					if(locker != null)
						_equippingActive.SetValue(locker, false);				
				}
				 
				var sign = entity.GetComponentInParent<Signage>();

				if(sign != null && data.ContainsKey("sign"))
				{
					var signData = data["sign"] as Dictionary<string, object>;

					if(signData.ContainsKey("texture"))
					{
						var stringSign = Convert.FromBase64String(signData["texture"].ToString());
						sign.textureID = FileStorage.server.Store(stringSign, FileStorage.Type.png, sign.net.ID);
					}

					if(Convert.ToBoolean(signData["locked"]))
						sign.SetFlag(BaseEntity.Flags.Locked, true);

					sign.SendNetworkUpdate();
				}

				var sleepingBag = entity.GetComponentInParent<SleepingBag>();

				if(sleepingBag != null && data.ContainsKey("sleepingbag"))
				{
					var bagData = data["sleepingbag"] as Dictionary<string, object>;

					sleepingBag.niceName = bagData["niceName"].ToString();
					sleepingBag.deployerUserID = ulong.Parse(bagData["deployerUserID"].ToString());
					sleepingBag.SetPublic(Convert.ToBoolean(bagData["isPublic"]));
				}
				
				var autoturret = entity.GetComponentInParent<AutoTurret>();

				if(autoturret != null)
				{
					if(player != null)
					{
						autoturret.authorizedPlayers.Add(new PlayerNameID()
						{
							userid = Convert.ToUInt64(player.userID),
							username = "Player"
						});
					}		

					autoturret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
				}
				
				var cupboard = entity.GetComponentInParent<BuildingPrivlidge>();

				if(cupboard != null)
				{
					List<ulong> authorizedPlayers = new List<ulong>();

					if(data.ContainsKey("cupboard"))
					{
						var cupboardData = data["cupboard"] as Dictionary<string, object>;
						authorizedPlayers = (cupboardData["authorizedPlayers"] as List<object>).Select(y => Convert.ToUInt64(y)).ToList();
					}

					if(data.ContainsKey("auth") && player != null && !authorizedPlayers.Contains(player.userID))
						authorizedPlayers.Add(player.userID);

					foreach(var userID in authorizedPlayers)
					{
						cupboard.authorizedPlayers.Add(new PlayerNameID()
						{
							userid = Convert.ToUInt64(userID),
							username = "Player"
						});
					}

					cupboard.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
				}
	
				var vendingMachine = entity.GetComponentInParent<VendingMachine>();

				if(vendingMachine != null && data.ContainsKey("vendingmachine"))
				{						
					var vendingData = data["vendingmachine"] as Dictionary<string, object>;
					
					vendingMachine.shopName = vendingData["shopName"].ToString();
					vendingMachine.SetFlag(BaseEntity.Flags.Reserved4, Convert.ToBoolean(vendingData["isBroadcasting"]));
					
					var sellOrders = vendingData["sellOrders"] as List<object>;

					foreach(var orderPreInfo in sellOrders)
					{				
						var orderInfo = orderPreInfo as Dictionary<string, object>;
						
						vendingMachine.sellOrders.sellOrders.Add(new ProtoBuf.VendingMachine.SellOrder()
						{
							ShouldPool = false,
							itemToSellID = Convert.ToInt32(orderInfo["itemToSellID"]),
							itemToSellAmount = Convert.ToInt32(orderInfo["itemToSellAmount"]),
							currencyID = Convert.ToInt32(orderInfo["currencyID"]),
							currencyAmountPerItem = Convert.ToInt32(orderInfo["currencyAmountPerItem"])
						});  
					}	
										
					vendingMachine.FullUpdate();
				}
				
				var flagsData = new Dictionary<string, object>();

				if(data.ContainsKey("flags"))
					flagsData = data["flags"] as Dictionary<string, object>;

				var flags = new Dictionary<BaseEntity.Flags, bool>();

				foreach(var flagData in flagsData)
				{	
					try //Enum.TryParse?
					{
						BaseEntity.Flags baseFlag = (BaseEntity.Flags)Enum.Parse(typeof(BaseEntity.Flags), flagData.Key);
						
						flags.Add(baseFlag, Convert.ToBoolean(flagData.Value));
					} catch (Exception ex) { }
				}

				foreach(var flag in flags)
				{
					entity.SetFlag(flag.Key, flag.Value);
				}
				
				pastedEntities.Add(entity);
			}

			return pastedEntities;
		}
		
		private List<Dictionary<string, object>> PreLoadData(List<object> entities, Vector3 startPos, float RotationCorrection, bool deployables, bool inventories, bool auth, bool vending)
		{
			var eulerRotation = new Vector3(0f, RotationCorrection, 0f);
			var quaternionRotation = Quaternion.EulerRotation(eulerRotation);
			var preloaddata = new List<Dictionary<string, object>>();

			foreach(var entity in entities)
			{
				var data = entity as Dictionary<string, object>;

				if(!deployables && !data.ContainsKey("grade"))
					continue;

				var pos = (Dictionary<string, object>)data["pos"];
				var rot = (Dictionary<string, object>)data["rot"];

				data.Add("position", quaternionRotation * (new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]), Convert.ToSingle(pos["z"]))) + startPos);
				data.Add("rotation", Quaternion.EulerRotation(eulerRotation + new Vector3(Convert.ToSingle(rot["x"]), Convert.ToSingle(rot["y"]), Convert.ToSingle(rot["z"]))));

				if(!inventories && data.ContainsKey("items"))
					data["items"] = new List<object>();

				if(auth && data["prefabname"].ToString().Contains("cupboard.tool"))
					data["auth"] = true;

				if(!vending && data["prefabname"].ToString().Contains("vendingmachine"))
					data.Remove("vendingmachine");
				
				preloaddata.Add(data);
			}

			return preloaddata;
		}

		private object TryCopy(Vector3 sourcePos, Vector3 sourceRot, string filename, float RotationCorrection, string[] args)
		{
			bool saveBuildings = config.Copy.Buildings, saveDeployables = config.Copy.Deployables, saveInventories = config.Copy.Inventories, saveShare = config.Copy.Share, saveTree = config.Copy.Tree, eachToEach = config.Copy.EachToEach;
			CopyMechanics copyMechanics = CopyMechanics.Proximity;
			float radius = 3f;

			for(int i = 0; ; i = i + 2)
			{
				if(i >= args.Length)
					break;

				int valueIndex = i + 1;

				if(valueIndex >= args.Length)
					return Lang("SYNTAX_COPY", null);

				string param = args[i].ToLower();

				switch(param)
				{
					case "b":
					case "buildings":
						if(!bool.TryParse(args[valueIndex], out saveBuildings))
							return Lang("SYNTAX_BOOL", null, param);

						break;
					case "d":
					case "deployables":
						if(!bool.TryParse(args[valueIndex], out saveDeployables))
							return Lang("SYNTAX_BOOL", null, param);

						break;
					case "e":
					case "each":
						if(!bool.TryParse(args[valueIndex], out eachToEach))
							return Lang("SYNTAX_BOOL", null, param);

						break;
					case "i":
					case "inventories":
						if(!bool.TryParse(args[valueIndex], out saveInventories))
							return Lang("SYNTAX_BOOL", null, param);

						break;
					case "m":
					case "method":
						switch(args[valueIndex].ToLower())
						{
							case "b":
							case "building":
								copyMechanics = CopyMechanics.Building;
								break;
							case "p":
							case "proximity":
								copyMechanics = CopyMechanics.Proximity;
								break;
						}

						break;
					case "r":
					case "radius":
						if(!float.TryParse(args[valueIndex], out radius))
							return Lang("SYNTAX_RADIUS", null);

						break;
					case "s":
					case "share":
						if(!bool.TryParse(args[valueIndex], out saveShare))
							return Lang("SYNTAX_BOOL", null, param);

						break;
					case "t":
					case "tree":
						if(!bool.TryParse(args[valueIndex], out saveTree))
							return Lang("SYNTAX_BOOL", null, param);

						break;
					default:
						return Lang("SYNTAX_COPY", null);
				}
			}

			return Copy(sourcePos, sourceRot, filename, RotationCorrection, copyMechanics, radius, saveBuildings, saveDeployables, saveInventories, saveTree, saveShare, eachToEach);
		}

		private void TryCopySlots(BaseEntity ent, IDictionary<string, object> housedata, bool saveShare)
		{
			foreach(BaseEntity.Slot slot in checkSlots)
			{
				if(!ent.HasSlot(slot))
					continue;

				var slotEntity = ent.GetSlot(slot);

				if(slotEntity == null)
					continue;

				var codedata = new Dictionary<string, object>
				{
					{"prefabname", slotEntity.PrefabName},
					{"flags", TryCopyFlags(ent)}
				};

				if(slotEntity.GetComponent<CodeLock>())
				{
					CodeLock codeLock = slotEntity.GetComponent<CodeLock>();

					codedata.Add("code", codeLock.code);
					
					if(saveShare)			
						codedata.Add("whitelistPlayers", codeLock.whitelistPlayers);
					
					if(codeLock.guestCode != null && codeLock.guestCode.Length == 4)
					{
						codedata.Add("guestCode", codeLock.guestCode);
					
						if(saveShare)
							codedata.Add("guestPlayers", codeLock.guestPlayers);
					}											
				} else if(slotEntity.GetComponent<KeyLock>()) {
					KeyLock keyLock = slotEntity.GetComponent<KeyLock>();
					var code = keyLock.keyCode;

					if(keyLock.firstKeyCreated)
						code |= 0x80;

					codedata.Add("code", code.ToString());
				}

				string slotName = slot.ToString().ToLower();

				housedata.Add(slotName, codedata);
			}
		}
		
		private Dictionary<string, object> TryCopyFlags(BaseEntity entity)
		{
			var flags = new Dictionary<string, object>();
			
			foreach(BaseEntity.Flags flag in Enum.GetValues(typeof(BaseEntity.Flags)))
			{
				flags.Add(flag.ToString(), entity.HasFlag(flag));
			}

			return flags;
		}
		
		private object TryPaste(Vector3 startPos, string filename, BasePlayer player, float RotationCorrection, string[] args, bool autoHeight = true)
		{
			var userID = player?.UserIDString;

			string path = subDirectory + filename;

			if(!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
				return Lang("FILE_NOT_EXISTS", userID);

			var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

			if(data["default"] == null || data["entities"] == null)
				return Lang("FILE_BROKEN", userID);

			float heightAdj = 0f, blockCollision = 0f;
			bool  auth = config.Paste.Auth, inventories = config.Paste.Inventories, deployables = config.Paste.Deployables, vending = config.Paste.VendingMachines, stability = config.Paste.Stability;

			for(int i = 0; ; i = i + 2)
			{
				if(i >= args.Length)
					break;

				int valueIndex = i + 1;

				if(valueIndex >= args.Length)
					return Lang("SYNTAX_PASTE_OR_PASTEBACK", userID);

				string param = args[i].ToLower();

				switch(param)
				{
					case "a":
					case "auth":
						if(!bool.TryParse(args[valueIndex], out auth))
							return Lang("SYNTAX_BOOL", userID, param);

						break;
					case "b":
					case "blockcollision":
						if(!float.TryParse(args[valueIndex], out blockCollision))
							return Lang("SYNTAX_BLOCKCOLLISION", userID);

						break;
					case "d":
					case "deployables":
						if(!bool.TryParse(args[valueIndex], out deployables))
							return Lang("SYNTAX_BOOL", userID, param);

						break;
					case "height":
						if(!float.TryParse(args[valueIndex], out heightAdj))
							return Lang("SYNTAX_HEIGHT", userID);

						autoHeight = false;

						break;
					case "i":
					case "inventories":
						if(!bool.TryParse(args[valueIndex], out inventories))
							return Lang("SYNTAX_BOOL", userID, param);

						break;
					case "s":
					case "stability":
						if(!bool.TryParse(args[valueIndex], out stability))
							return Lang("SYNTAX_BOOL", userID, param);

						break;
					case "v":
					case "vending":
						if(!bool.TryParse(args[valueIndex], out vending))
							return Lang("SYNTAX_BOOL", userID, param);

						break;						
					default:
						return Lang("SYNTAX_PASTE_OR_PASTEBACK", userID);
				}
			}

			startPos.y += heightAdj;

			var preloadData = PreLoadData(data["entities"] as List<object>, startPos, RotationCorrection, deployables, inventories, auth, vending);

			if(autoHeight)
			{
				var bestHeight = FindBestHeight(preloadData, startPos);

				if(bestHeight is string)
					return bestHeight;

				heightAdj = (float)bestHeight - startPos.y;

				foreach(var entity in preloadData)
				{
					var pos = ((Vector3)entity["position"]);
					pos.y += heightAdj;
					
					entity["position"] = pos;
				}
			}

			if(blockCollision > 0f)
			{
				var collision = CheckCollision(preloadData, startPos, blockCollision);

				if(collision is string)
					return collision;
			}

			return Paste(preloadData, startPos, player, stability);
		}

		private List<BaseEntity> TryPasteSlots(BaseEntity ent, Dictionary<string, object> structure)
		{
			List<BaseEntity> entitySlots = new List<BaseEntity>();
			
			foreach(BaseEntity.Slot slot in checkSlots)
			{
				string slotName = slot.ToString().ToLower();

				if(!ent.HasSlot(slot) || !structure.ContainsKey(slotName))
					continue;

				var slotData = structure[slotName] as Dictionary<string, object>;
				BaseEntity slotEntity = GameManager.server.CreateEntity((string)slotData["prefabname"], Vector3.zero, new Quaternion(), true);

				if(slotEntity == null)
					continue;

				slotEntity.gameObject.Identity();
				slotEntity.SetParent(ent, slotName);
				slotEntity.OnDeployed(ent);
				slotEntity.Spawn();

				ent.SetSlot(slot, slotEntity);

				entitySlots.Add(slotEntity);
				
				if(slotName != "lock" || !slotData.ContainsKey("code"))
					continue;
				
				if(slotEntity.GetComponent<CodeLock>())
				{
					string code = (string)slotData["code"];

					if(!string.IsNullOrEmpty(code))
					{
						CodeLock codeLock = slotEntity.GetComponent<CodeLock>();
						codeLock.code = code;
						codeLock.hasCode = true;
						
						if(slotData.ContainsKey("whitelistPlayers"))
						{
							foreach(var userID in slotData["whitelistPlayers"] as List<object>)
							{
								codeLock.whitelistPlayers.Add(Convert.ToUInt64(userID));
							}
						}
						
						if(slotData.ContainsKey("guestCode"))
						{
							string guestCode = (string)slotData["guestCode"];
							
							codeLock.guestCode = guestCode;
							codeLock.hasGuestCode = true;
							
							if(slotData.ContainsKey("guestPlayers"))
							{
								foreach(var userID in slotData["guestPlayers"] as List<object>)
								{
									codeLock.guestPlayers.Add(Convert.ToUInt64(userID));
								}
							}
						}
						
						codeLock.SetFlag(BaseEntity.Flags.Locked, true);
					}
				} else if(slotEntity.GetComponent<KeyLock>()) {
					int code = Convert.ToInt32(slotData["code"]);
					KeyLock keyLock = slotEntity.GetComponent<KeyLock>();

					if((code & 0x80) != 0)
					{
						keyLock.keyCode = (code & 0x7F);
						keyLock.firstKeyCreated = true;
						keyLock.SetFlag(BaseEntity.Flags.Locked, true);
					}
				}
			}
			
			return entitySlots;
		}

		private object TryPasteBack(string filename, BasePlayer player, string[] args)
		{
			string path = subDirectory + filename;

			if(!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
				return Lang("FILE_NOT_EXISTS", player?.UserIDString);

			var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

			if(data["default"] == null || data["entities"] == null)
				return Lang("FILE_BROKEN", player?.UserIDString);

			var defaultdata = data["default"] as Dictionary<string, object>;
			var pos = defaultdata["position"] as Dictionary<string, object>;
			var rotationCorrection = Convert.ToSingle(defaultdata["rotationdiff"]);
			var startPos = new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]), Convert.ToSingle(pos["z"]));

			return TryPaste(startPos, filename, player, rotationCorrection, args, autoHeight: false);
		}

		//Сhat commands
		
		[ChatCommand("copy")]
		private void cmdChatCopy(BasePlayer player, string command, string[] args)
		{
			if(!HasAccess(player, copyPermission))
			{
				SendReply(player, Lang("NO_ACCESS", player.UserIDString));
				return;
			}

			if(args.Length < 1)
			{
				SendReply(player, Lang("SYNTAX_COPY", player.UserIDString));
				return;
			}

			var savename = args[0];
			var success = TryCopyFromSteamID(player.userID, savename, args.Skip(1).ToArray());

			if(success is string)
			{
				SendReply(player, (string)success);
				return;
			}

			SendReply(player, Lang("COPY_SUCCESS", player.UserIDString, savename));
		}

		[ChatCommand("paste")]
		private void cmdChatPaste(BasePlayer player, string command, string[] args)
		{
			if(!HasAccess(player, pastePermission))
			{
				SendReply(player, Lang("NO_ACCESS", player.UserIDString));
				return;
			}

			if(args.Length < 1)
			{
				SendReply(player, Lang("SYNTAX_PASTE_OR_PASTEBACK", player.UserIDString));
				return;
			}

			var success = TryPasteFromSteamID(player.userID, args[0], args.Skip(1).ToArray());

			if(success is string)
			{
				SendReply(player, (string)success);
				return;
			}
			
			if(!lastPastes.ContainsKey(player.UserIDString))
				lastPastes[player.UserIDString] = new Stack<List<BaseEntity>>();
			
			lastPastes[player.UserIDString].Push((List<BaseEntity>)success);

			SendReply(player, Lang("PASTE_SUCCESS", player.UserIDString));
		}

		[ChatCommand("pasteback")]
		private void cmdChatPasteBack(BasePlayer player, string command, string[] args)
		{
			if(!HasAccess(player, pastePermission))
			{
				SendReply(player, Lang("NO_ACCESS", player.UserIDString));
				return;
			}

			var result = cmdPasteBack(player, args);

			if(result is string)
				SendReply(player, (string)result);
			else
				SendReply(player, Lang("PASTEBACK_SUCCESS", player.UserIDString));
		}

		[ChatCommand("undo")]
		private void cmdChatUndo(BasePlayer player, string command, string[] args)
		{
			if(!HasAccess(player, undoPermission))
			{
				SendReply(player, Lang("NO_ACCESS", player.UserIDString));
				return;
			}

			var result = cmdUndo(player.UserIDString, args);

			if(result is string)
				SendReply(player, (string)result);
			else
				SendReply(player, Lang("UNDO_SUCCESS", player.UserIDString));
		}
		
		//Console commands [From Server]

		[ConsoleCommand("pasteback")]
		private void cmdConsolePasteBack(ConsoleSystem.Arg arg)
		{
			if(!arg.IsRcon)
				return;

			var result = cmdPasteBack(null, arg.Args);

			if(result is string)
				SendReply(arg, (string)result);
			else
				SendReply(arg, Lang("PASTEBACK_SUCCESS", null));
		}

		[ConsoleCommand("undo")]
		private void cmdConsoleUndo(ConsoleSystem.Arg arg)
		{
			if(!arg.IsRcon)
				return;

			var result = cmdUndo(serverID, arg.Args);

			if(result is string)
				SendReply(arg, (string)result);
			else
				SendReply(arg, Lang("UNDO_SUCCESS", null));
		}

		//Languages phrases

		private readonly Dictionary<string, Dictionary<string, string>> messages = new Dictionary<string, Dictionary<string, string>>
		{
			{"FILE_NOT_EXISTS", new Dictionary<string, string>() {
				{"en", "File does not exist"},
				{"ru", "Файл не существует"},
			}},
			{"FILE_BROKEN", new Dictionary<string, string>() {
				{"en", "File is broken, can not be paste"},
				{"ru", "Файл поврежден, вставка невозможна"},
			}},
			{"NO_ACCESS", new Dictionary<string, string>() {
				{"en", "You don't have the permissions to use this command"},
				{"ru", "У вас нет прав доступа к данной команде"},
			}},
			{"SYNTAX_PASTEBACK", new Dictionary<string, string>() {
				{"en", "Syntax: /pasteback <Target Filename> <options values>\nheight XX - Adjust the height\nvending - Information and sellings in vending machine"},
				{"ru", "Синтаксис: /pasteback <Название Объекта> <опция значение>\nheight XX - Высота от земли\nvending - Информация и товары в торговом автомате"},
			}},
			{"SYNTAX_PASTE_OR_PASTEBACK", new Dictionary<string, string>() {
				{"en", "Syntax: /paste or /pasteback <Target Filename> <options values>\nheight XX - Adjust the height\nautoheight true/false - sets best height, carefull of the steep\nblockcollision XX - blocks the entire paste if something the new building collides with something\ndeployables true/false - false to remove deployables\ninventories true/false - false to ignore inventories\nvending - Information and sellings in vending machine"},
				{"ru", "Синтаксис: /paste or /pasteback <Название Объекта> <опция значение>\nheight XX - Высота от земли\nautoheight true/false - автоматически подобрать высоту от земли\nblockcollision XX - блокировать вставку, если что-то этому мешает\ndeployables true/false - false для удаления предметов\ninventories true/false - false для игнорирования копирования инвентаря\nvending - Информация и товары в торговом автомате"},
			}},
			{"PASTEBACK_SUCCESS", new Dictionary<string, string>() {
				{"en", "You've successfully placed back the structure"},
				{"ru", "Постройка успешно вставлена на старое место"},
			}},
			{"PASTE_SUCCESS", new Dictionary<string, string>() {
				{"en", "You've successfully pasted the structure"},
				{"ru", "Постройка успешно вставлена"},
			}},
			{"SYNTAX_COPY", new Dictionary<string, string>() {
				{"en", "Syntax: /copy <Target Filename> <options values>\n radius XX (default 3)\n method proximity/building (default proximity)\nbuilding true/false (saves structures or not)\ndeployables true/false (saves deployables or not)\ninventories true/false (saves inventories or not)"},
				{"ru", "Синтаксис: /copy <Название Объекта> <опция значение>\n radius XX (default 3)\n method proximity/building (по умолчанию proximity)\nbuilding true/false (сохранять постройку или нет)\ndeployables true/false (сохранять предметы или нет)\ninventories true/false (сохранять инвентарь или нет)"},
			}},
			{"NO_ENTITY_RAY", new Dictionary<string, string>() {
				{"en", "Couldn't ray something valid in front of you"},
				{"ru", "Не удалось найти какой-либо объект перед вами"},
			}},
			{"COPY_SUCCESS", new Dictionary<string, string>() {
				{"en", "The structure was successfully copied as {0}"},
				{"ru", "Постройка успешно скопирована под названием: {0}"},
			}},
			{"NO_PASTED_STRUCTURE", new Dictionary<string, string>() {
				{"en", "You must paste structure before undoing it"},
				{"ru", "Вы должны вставить постройку перед тем, как отменить действие"},
			}},
			{"UNDO_SUCCESS", new Dictionary<string, string>() {
				{"en", "You've successfully undid what you pasted"},
				{"ru", "Вы успешно снесли вставленную постройку"},
			}},
			{"NOT_FOUND_PLAYER", new Dictionary<string, string>() {
				{"en", "Couldn't find the player"},
				{"ru", "Не удалось найти игрока"},
			}},
			{"SYNTAX_BOOL", new Dictionary<string, string>() {
				{"en", "Option {0} must be true/false"},
				{"ru", "Опция {0} принимает значения true/false"},
			}},
			{"SYNTAX_HEIGHT", new Dictionary<string, string>() {
				{"en", "Option height must be a number"},
				{"ru", "Опция height принимает только числовые значения"},
			}},
			{"SYNTAX_BLOCKCOLLISION", new Dictionary<string, string>() {
				{"en", "Option blockcollision must be a number, 0 will deactivate the option"},
				{"ru", "Опция blockcollision принимает только числовые значения, 0 позволяет отключить проверку"},
			}},
			{"SYNTAX_RADIUS", new Dictionary<string, string>() {
				{"en", "Option radius must be a number"},
				{"ru", "Опция radius принимает только числовые значения"},
			}},
			{"BLOCKING_PASTE", new Dictionary<string, string>() {
				{"en", "Something is blocking the paste"},
				{"ru", "Что-то препятствует вставке"},
			}},		
		};
	}
}

// --- End of file: CopyPaste.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EventsCore.cs ---
// --- Original Local Path: EventsCore.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Configuration;
using System.Globalization;
using System.Threading.Tasks;
using System.Linq;
using System.Text;
using Oxide;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("EventsCore", "BadMandarin, Ryamkk", "1.2.1")]
    [Description("EventsCore")]
    class EventsCore : RustPlugin
    {
		#region References
		
        [PluginReference] Plugin UniversalShop;
		[PluginReference] Plugin ServerRewards;
		[PluginReference] Plugin RustShop;

		#endregion
		
		#region Configuration
		
		private void LoadDefaultConfig()
        {
			GetConfig("Основные настройки ивента: › Царь горы ‹", "Названия ивента", ref EventName_1);
			GetConfig("Основные настройки ивента: › Царь горы ‹", "Цвет ивента для UI панели", ref EventColor_1);
			GetConfig("Основные настройки ивента: › Царь горы ‹", "Основная цель ивента для UI панели", ref EventText_1);
			GetConfig("Основные настройки ивента: › Царь горы ‹", "Время для определение победителя ивента", ref EventTime_1);
			
			GetConfig("Основные настройки ивента: › Рудо-Копатель ‹", "Названия ивента", ref EventName_2);
			GetConfig("Основные настройки ивента: › Рудо-Копатель ‹", "Цвет ивента для UI панели", ref EventColor_2);
			GetConfig("Основные настройки ивента: › Рудо-Копатель ‹", "Основная цель ивента для UI панели", ref EventText_2);
			GetConfig("Основные настройки ивента: › Рудо-Копатель ‹", "Время для определение победителя ивента", ref EventTime_2);
			
			GetConfig("Общие настройки ивентов", "Интервал запуска ивента (секунды)", ref EventAutoStart);
			GetConfig("Общие настройки ивентов", "Минимальный онлайн для запуска ивента", ref EventMaxPlayer);
			
			GetConfig("Общие настройки бонуса", "Использовать выдачу бонуса балансом от Server Rewards", ref Use_ServerRewards);
			GetConfig("Общие настройки бонуса", "Использовать выдачу бонуса балансом от Rust Shop", ref Use_RustShop);
			GetConfig("Общие настройки бонуса", "Использовать выдачу бонуса балансом от Universal Shop", ref Use_UniversalShop);
			GetConfig("Общие настройки бонуса", "Сумма бонуса за победу в ивенте", ref BalanceAmount);
			
            SaveConfig();
        }

		#endregion
		
        #region Variables
		
		private string EventName_1 = "Царь горы";
		private string EventColor_1 = "#9999E2FF";
		private string EventText_1 = "Будь выше всех чтобы победить!";
		private int EventTime_1 = 300;
		
		private string EventName_2 = "Рудо-Копатель";
		private string EventColor_2 = "#CAB366FF";
		private string EventText_2 = "Добывай как можно больше ресурсов!";
		private int EventTime_2 = 300;
		
		private float EventAutoStart = 7200f;
		
		private int EventMaxPlayer = 5;
		
		private bool Use_RustShop = true;
		private bool Use_ServerRewards = false;
		private bool Use_UniversalShop = false;
		
		private int BalanceAmount = 1000;
		
        private Timer EventsTimer;
        private Timer AutoETimer;
        private int curEvent;
        private int eTimeLeft = 0;
        private bool eActive = false;
        List<eInfo> EventsList;
        Dictionary<ulong, EventsScores> eUsersScore;
        BasePlayer eLastLeader;
		
        #endregion

        #region Oxide
		
        private void Init()
        {
            permission.RegisterPermission("eventscore.admin", this);
			LoadDefaultConfig();
            eUsersScore = new Dictionary<ulong, EventsScores>();
            EventsList = new List<eInfo>();
        }

        void OnServerInitialized()
        {
            EventsList.Add(new eInfo { eName = EventName_1, eBackground = EventColor_1, eLeaders = "null", eText = EventText_1, eTime = EventTime_1 });
            EventsList.Add(new eInfo { eName = EventName_2, eBackground = EventColor_2, eLeaders = "null", eText = EventText_2, eTime = EventTime_2 });

            AutoETimer = timer.Once(EventAutoStart, AutoStart);
			
			if (Use_ServerRewards && !ServerRewards)
            {
                PrintError("Плагин планировал использовать баланс для выдачи бонуса за ивент, но плагин был выгружен!");
                return;
            }

            if (Use_UniversalShop && !UniversalShop)
            {
                PrintError("Плагин планировал использовать баланс для выдачи бонуса за ивент, но плагин был выгружен!");
                return;
            }

            if (Use_RustShop && !RustShop)
            {
                PrintError("Плагин планировал использовать баланс для выдачи бонуса за ивент, но плагин был выгружен!");
                return;
            }
        }
		
		private void Unload() 
        {
		BasePlayer.activePlayerList.ToList().ForEach(p => CuiHelper.DestroyUi(p, NotifyLayer));
        } 
		
        #endregion

        #region Core
		
        object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (curEvent != 1 || !eActive) return null;

            var player = entity as BasePlayer;
            if (!eUsersScore.ContainsKey(player.userID)) eUsersScore.Add(player.userID, new EventsScores { UserName = player.displayName, UserScore = item.amount });
            else
            {
                eUsersScore[player.userID].UserScore += item.amount;
            }
            return null;
        }
		
        #endregion

        #region GUI Interface
		
        private string Layer = "UI_EventGui";
        private void Draw_UIEvents(BasePlayer player)
        {
            if (player == null)
            {
                return;
            }

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.1 0.86", AnchorMax = "0.1 0.86", OffsetMin = "-130 -55", OffsetMax = "110 55" },
                Image = { Color = HexToRustFormat("#000000"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Hud", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent { Color = HexToRustFormat(EventsList[curEvent].eBackground), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent {  Text = EventsList[curEvent].eName + "\n" +
                                            EventsList[curEvent].eText + "\n" +
                                            "Ваш счёт: " + Math.Round(eUsersScore[player.userID].UserScore) + "\n" +
                                            "Лидер: " + GetLeader(), Align = TextAnchor.UpperCenter, FontSize = 15, Font = "robotocondensed-bold.ttf"},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    new CuiOutlineComponent { Distance = "0.2 0.2", Color = "0 0 0 0" }
                }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiTextComponent {  Text = $"Осталось: {eTimeLeft} с", Align = TextAnchor.LowerCenter, FontSize = 15, Font = "robotocondensed-bold.ttf"},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    new CuiOutlineComponent { Distance = "0.1 0.1", Color = "0 0 0 0" }
                }
            });

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
		
		private string NotifyLayer = "UI_NotifyLayer";
		private void ShowNotify(BasePlayer player, string text)
        {
            timer.Once(5f, () => CuiHelper.DestroyUi(player, NotifyLayer));
            CuiElementContainer container = new CuiElementContainer();
            
			container.Add(new CuiButton
            {
				RectTransform = { AnchorMin = "0 0.85", AnchorMax = "1 0.93", OffsetMax = "0 0" }, 
                Button = { Color = HexToRustFormat(EventsList[curEvent].eBackground) }, 
                Text = { FadeIn = 2f, Text = text, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, "Overlay", NotifyLayer);

            CuiHelper.AddUi(player, container);
        }
		
        #endregion

        #region Utils
		
        private void AutoStart()
        {
            if(BasePlayer.activePlayerList.Count < EventMaxPlayer)
            {
                if (AutoETimer.Destroyed)
                {
                    AutoETimer = timer.Once(EventAutoStart, AutoStart);
                    //AutoETimer.Destroy();
                }
                else
                {
                    AutoETimer.Destroy();
                    AutoETimer = timer.Once(EventAutoStart, AutoStart);
                }
                PrintWarning("Недостаточно игроков для запуска ивента!");
                return;
            }

            System.Random rnd = new System.Random();
            EventStart(rnd.Next(0, EventsList.Count - 1));
        }

        private string GetLeader()
        {
            if (!eActive) return "null";
            if (eUsersScore == null) return "null";

            ulong bestplrid = 0;
            double bestscore = -1;
            if (eUsersScore.Count > 0) { 
                foreach (var best in eUsersScore)
                {
                    if (best.Value.UserScore > bestscore)
                    {
                        bestscore = best.Value.UserScore;
                        bestplrid = best.Key;
                    }
                }
            } else {
                return "Нету";
            }
            eLastLeader = BasePlayer.FindByID(bestplrid);
            string name = eLastLeader == null ? "" : eLastLeader.displayName;
            return $"{name}   ({Math.Round(bestscore)})";
        }
		
		private void EventStart(int eventId)
        {
            if (!AutoETimer.Destroyed) AutoETimer.Destroy();
            curEvent = eventId;
            switch (eventId)
            {
                case 0:
                    {
                        eActive = true;
                        EventsTimer = timer.Every(1f, UpdateEventKing);
                        break;
                    }
                case 1:
                    {
                        eActive = true;
                        EventsTimer = timer.Every(1f, UpdateEventFarm);
                        break;
                    }
                default: break;
            }
        }

        private void EventEnd()
        {
            eActive = false;
            if(!EventsTimer.Destroyed) EventsTimer.Destroy();
            if (AutoETimer.Destroyed)
            {
                AutoETimer = timer.Once(EventAutoStart, AutoStart);
                //AutoETimer.Destroy();
            }
            else
            {
                AutoETimer.Destroy();
                AutoETimer = timer.Once(EventAutoStart, AutoStart);
            }
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
            eUsersScore.Clear();
        }
		
        #region Commands
        
        [ChatCommand("ev"), Permission("eventscore.admin")]
        void CMD_StartEvent(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "eventscore.admin"))
            {
                if (args.Length > 0)
                {
                    if (args[0] == "end")
                    {
                        if (!eActive)
                        {
                            SendReply(player, "Нечего останавливать!");
                            return;
                        }
                        EventEnd();
                        SendReply(player, "Вы остановили ивент!");
                        return;
                    }

                    if (eActive)
                    {
                        SendReply(player, "Уже существует активный ивент!");
                        return;
                    }

                    if (args[0] == "king")
                    {
                        
                        EventStart(0);
                        SendReply(player, "Вы запустили ивент!");
                    }
                    else if (args[0] == "farm")
                    {
                        EventStart(1);
                        SendReply(player, "Вы запустили ивент!");
                    }
                    else
                    {
                        SendReply(player, "Неизвесный Ивент!");
                    }
                    
                }
            }
            else
            {
                SendReply(player, "В доступе отказано!");
            }
        }
		
        #endregion

        #region EVENT_KING
        private void UpdateEventKing()
        {
            if (eTimeLeft == 0 && eActive)
            {
                eTimeLeft = EventsList[0].eTime;
                if (eUsersScore == null) return;
                foreach(var player in BasePlayer.activePlayerList)
                {
                    if (!eUsersScore.ContainsKey(player.userID)) eUsersScore.Add(player.userID, new EventsScores { UserName = player.displayName, UserScore = 0 });
                    else
                    {
                        eUsersScore[player.userID].UserScore = 0;
                    }
                    Draw_UIEvents(player);
                }
            }
            else if(eTimeLeft == 0 && !eActive)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, Layer);
                }
            }
            else
            {
                if (eTimeLeft > 0) eTimeLeft--;
                else eTimeLeft = 0;
                if (eTimeLeft < 2)
                {
                    eActive = false;
                    if(!EventsTimer.Destroyed) EventsTimer.Destroy();
                    if (AutoETimer.Destroyed)
                    {
                        AutoETimer = timer.Once(EventAutoStart, AutoStart);
                        //AutoETimer.Destroy();
                    }
                    else
                    {
                        AutoETimer.Destroy();
                        AutoETimer = timer.Once(EventAutoStart, AutoStart);
                    }
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        CuiHelper.DestroyUi(player, Layer);
					    ShowNotify(player, $"Ивент › {EventsList[curEvent].eName} ‹ окончен!\n" +
						                   $"Победитель: › {eLastLeader.displayName} ‹\n" +
						                   $"Он получает: {BalanceAmount} бонусов на свой баланс мини-магазина!");
                    }
                    eUsersScore.Clear();
					
                    if(Use_UniversalShop) 
					{
						UniversalShop?.Call("API_ShopAddBalance", eLastLeader.userID, BalanceAmount);
					}
					
					if(Use_RustShop)
					{
						RustShop?.Call("AddBalance", eLastLeader.userID, BalanceAmount);
					}
					
					if(Use_ServerRewards)
					{
						ServerRewards?.Call("AddPoints", eLastLeader.userID, BalanceAmount);
					}
                }
                else
                {
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        var y = player.transform.position.y;
                        if (!eUsersScore.ContainsKey(player.userID)) eUsersScore.Add(player.userID, new EventsScores { UserName = player.displayName, UserScore = y });
                        else
                        {
                            eUsersScore[player.userID].UserScore = y;
                        }
                        Draw_UIEvents(player);
                    }
                }
            }
        }

        #endregion

        #region EVENT_FARM
        private void UpdateEventFarm()
        {
            if (eTimeLeft == 0 && eActive)
            {
                eTimeLeft = EventsList[1].eTime;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (!eUsersScore.ContainsKey(player.userID)) eUsersScore.Add(player.userID, new EventsScores { UserName = player.displayName, UserScore = 0 });
                    else
                    {
                        eUsersScore[player.userID].UserScore = 0;
                    }
                    Draw_UIEvents(player);
                }
            }
            else if (eTimeLeft == 0 && !eActive)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, Layer);
                }
            }
            else
            {
                if (eTimeLeft > 0) eTimeLeft--;
                else eTimeLeft = 0;
                if (eTimeLeft < 2)
                {
                    eActive = false;
                    if (!EventsTimer.Destroyed) EventsTimer.Destroy();
                    if (AutoETimer.Destroyed)
                    {
                        AutoETimer = timer.Once(EventAutoStart, AutoStart);
                        //AutoETimer.Destroy();
                    }
                    else
                    {
                        AutoETimer.Destroy();
                        AutoETimer = timer.Once(EventAutoStart, AutoStart);
                    }
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        CuiHelper.DestroyUi(player, Layer);
					    ShowNotify(player, $"Ивент › {EventsList[curEvent].eName} ‹ окончен!\n" +
						                   $"Победитель: › {eLastLeader.displayName} ‹\n" +
						                   $"Он получает: {BalanceAmount} бонусов на свой баланс мини-магазина!");
                    }
                    eUsersScore.Clear();
					
                    if(Use_UniversalShop) 
					{
						UniversalShop?.Call("API_ShopAddBalance", eLastLeader.userID, BalanceAmount);
					}
					
					if(Use_RustShop)
					{
						RustShop?.Call("AddBalance", eLastLeader.userID, BalanceAmount);
					}
					
					if(Use_ServerRewards)
					{
						ServerRewards?.Call("AddPoints", eLastLeader.userID, BalanceAmount);
					}
                }
                else
                {
                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        if (!eUsersScore.ContainsKey(player.userID)) eUsersScore.Add(player.userID, new EventsScores { UserName = player.displayName, UserScore = 0 });
                        Draw_UIEvents(player);
                    }
                }
            }
        }

        #endregion

        #region Others
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
		
		private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }

            Config[menu, Key] = var;
        }

        public struct eInfo
        {
            public string eName;
            public string eBackground;
            public string eLeaders;
            public string eText;
            public int eTime;
        }

        class EventsScores
        {
            public string UserName;
            public double UserScore;
        }
        #endregion

        #endregion
    }
}



// --- End of file: EventsCore.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQPermissions.cs ---
// --- Original Local Path: IQPermissions.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Text;
using UnityEngine;
using UnityEngine.Networking;
using Object = System.Object;
using System.Text.RegularExpressions;
using ConVar;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;
using Oxide.Core.Database;

namespace Oxide.Plugins
{
	[Info("IQPermissions", "", "1.7.1")]
	[Description("Extended privilege granting system")]
	public class IQPermissions : RustPlugin
	{
		/// <summary>
		/// Обновление 1.7.0
		/// Нововведения :
		/// - Добавлено новое API
		/// Изменения :
		/// - Изменен принцип возврата привилегий при выгрузке плагина
		/// </summary>

		#region Vars

		private Boolean IsFullLoaded = false;
		
		public enum TypeData
		{
			Permission,
			Group
		}

		private enum TypeAlert
		{
			Add,
			Expired,
			Alert
		}

		private static IQPermissions _;
		private static InterfaceBuilder _interface;
		private const Boolean LanguageEn = true;

		#endregion

		#region Reference

		[PluginReference] Plugin IQChat, ImageLibrary, UAlertSystem;

		public void SendChat(String Message, BasePlayer player,
			ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
		{
			if (IQChat)
				if (config.AlertConfigurations.SettingIQChat.UIAlertUse)
					IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
				else
					IQChat?.Call("API_ALERT_PLAYER", player, Message,
						config.AlertConfigurations.SettingIQChat.CustomPrefix,
						config.AlertConfigurations.SettingIQChat.CustomAvatar);
			else player.SendConsoleCommand("chat.add", channel, 0, Message);
		}
		
		private String GetImage(String fileName, UInt64 skin = 0)
		{
			String imageId = (String)plugins.Find("ImageLibrary").CallHook("ImageUi.GetImage", fileName, skin);
			return !String.IsNullOrEmpty(imageId) ? imageId : String.Empty;
		}

		#endregion

		#region Configuration

		private static Configuration config = new Configuration();

		private class Configuration
		{
			[JsonProperty(LanguageEn ? "Basic Settings" : "Основные настройки")] public GeneralSetting GeneralSettings = new GeneralSetting();

			[JsonProperty(LanguageEn ? "Configuring the interface" : "Настройка интерфейса")]
			public InterfaceConfiguration InterfaceSetting = new InterfaceConfiguration();

			[JsonProperty(LanguageEn ? "Setting up Notifications" : "Настройка уведомлений")]
			public AlertConfiguration AlertConfigurations = new AlertConfiguration();

			[JsonProperty(LanguageEn ? "PERMISSIONS ON THE SERVER : [Permission] = Customization" : "ПРАВА НА СЕРВЕРЕ : [Permission] = Настройка")]
			public Dictionary<String, StructureLanguage> PermissionList = new Dictionary<String, StructureLanguage>();

			[JsonProperty(LanguageEn ? "GROUPS WITH RIGHTS ON THE SERVER : [Group] = Customization" : "ГРУППЫ С ПРАВАМИ НА СЕРВЕРЕ : [Group] = Настройка")]
			public Dictionary<String, StructureLanguage> GroupList = new Dictionary<String, StructureLanguage>();

			internal class GeneralSetting
			{
				[JsonProperty(LanguageEn ? "Webhook from the Discord channel for logging" : "Webhook от канала Discord для логирования")]
				public String WebHooksDiscord;

				[JsonProperty(LanguageEn
					? "Connecting data storage on the MySQL side"
					: "Подключение хранения данных на стороне MySQL")]
				public MySQLInitialize MySQLSetting = new MySQLInitialize();

				[JsonProperty(LanguageEn ? "Use the removal of temporary groups from the player when unloading the plugin (when loading, they will be returned)" : "Использовать удаление временных групп у игрока при выгрузке плагина (при загрузке - они будут возвращены)")]
				public Boolean UseRemoveGroupsWhenUnload;
				[JsonProperty(LanguageEn ? "Use the removal of temporary permission from the player when unloading the plugin (when loading, they will be returned)" : "Использовать удаление временных прав у игрока при выгрузке плагина (при загрузке - они будут возвращены)")]
				public Boolean UseRemovePermissionsХWhenUnload;
				[JsonProperty(LanguageEn ? "Settings for automatically granting privileges to server novices (They will be considered novices - while the player is not in the database or datafile)" : "Настройки автоматической выдачи привилегии новичкам сервера (Они будут считаться новичками - пока игрока нет в базе или датафайле)")]
				public AutoGive AutoGiveSettings = new AutoGive();
				
				internal class AutoGive
				{
					[JsonProperty(LanguageEn ? "Use automatic granting of permissions to a new player" : "Использовать автоматическую выдачу прав новому игроку")]
					public Boolean UseAutGivePermissions;
					[JsonProperty(LanguageEn ? "Use automatic granting of groups to a new player" : "Использовать автоматическую выдачу групп новому игроку")]
					public Boolean UseAutGiveGroups;

					[JsonProperty(LanguageEn ? "List of permissions to issue [group] = time in the format (1d/h/m/s)" : "Список прав для выдачи [группа] = время в формате (1d/h/m/s)")]
					public Dictionary<String, String> PermissionList = new Dictionary<String, String>();
					[JsonProperty(LanguageEn ? "List of groups to issue [group] = time in the format (1d/h/m/s)" : "Список групп для выдачи [группа] = время в формате (1d/h/m/s)")]
					public Dictionary<String, String> GroupList = new Dictionary<String, String>();
				}
				
				internal class MySQLInitialize
				{
					[JsonProperty(LanguageEn ? "Setting up a MySQL connection" : "Настройка MySQL соединения")]
					public MySQLConnect ConnectSetting = new MySQLConnect();

					[JsonProperty(LanguageEn ? "The desired table name in MySQL" : "Желаемое название таблицы в MySQL")]
					public String TableName;
					
					[JsonProperty(LanguageEn
						? "Settings privilege migration between servers connected to the same MySQL (Example: Server #1 and #2 are connected to the same MySQL - a player with privileges on server #1 - going to server #2 - will get it there)"
						: "Настройка миграцию привилегий между среверами подключенными к одной MySQL (Пример : Сервер #1 и #2 подключены к одной MySQL - игрок с привилегий на сервере #1 - зайдя на сервер #2 - получит ее и там)")]
					public MigrationPrivilage MigrationSettings = new MigrationPrivilage();
					
					internal class MigrationPrivilage
					{
						[JsonProperty(LanguageEn ? "Use the list of permissions available for migration (otherwise they will be all that the player has in MySQL)" : "Использовать список прав доступных для миграции (иначе будут все, что есть у игрока в MySQL)")]
						public Boolean UseMigrationPermissionsList;
						[JsonProperty(LanguageEn ? "List of permissions in available for synchronization on another server in case of player migration" : "Список прав в доступных для синхронизации на другом сервере случае миграции игрока")]
						public List<String> MigrationPermissionList = new List<String>();
						
						[JsonProperty(LanguageEn ? "Use the list of groups available for migration (otherwise they will be all that the player has in MySQL)" : "Использовать список групп доступных для миграции (иначе будут все, что есть у игрока в MySQL)")]
						public Boolean UseMigrationGroupList;
						[JsonProperty(LanguageEn ? "List of groups in available for synchronization on another server in case of player migration" : "Список групп в доступных для синхронизации на другом сервере случае миграции игрока")]
						public List<String> MigrationGroupList = new List<String>();
					}
					internal class MySQLConnect
					{
						public String Host;
						public String Port;
						public String DatabaseName;
						public String UserName;
						public String Passowrd;
					}
				}
			}

			internal class AlertConfiguration
			{
				[JsonProperty(LanguageEn ? "Use the plugin's UI notification for notifications (otherwise it will be displayed in the chat)" : "Использовать для уведомлений UI-уведомление плагина (иначе будет отображаться в чате)")]
				public Boolean UsePoopUp;

				[JsonProperty(LanguageEn
					? "Remind players that they are running out of group?"
					: "Напоминать игрокам о том, что у них заканчивается группа?")]
				public Boolean UseAlertedGroup;
				[JsonProperty(LanguageEn
					? "The list of groups for which the reminder will work"
					: "Список групп на которые сработает напоминание")]
				public List<String> GrpupListAlerted = new List<String>();
				
				[JsonProperty(LanguageEn
					? "Remind players that they are running out of permission?"
					: "Напоминать игрокам о том, что у них заканчивается права?")]
				public Boolean UseAlertedPermission;
				[JsonProperty(LanguageEn
					? "The list of permissions for which the reminder will work"
					: "Список прав на которые сработает напоминание")]
				public List<String> PermissionsListAlerted = new List<String>();
					
				[JsonProperty(LanguageEn ? "How many days before the end of the privilege to remind the player about it" : "За сколько дней до окончания привилегии напоминать игроку об этом")]
				public Int32 DayAlerted;
				
				[JsonProperty(LanguageEn ? "How many seconds to show notifications to the player" : "Сколько секунд показывать уведомления игроку")]
				public Single TimeAlert;
				
				[JsonProperty(LanguageEn ? "Setting up IQChat (If installed)" : "Настройка IQChat (Если установлен)")]
				public IQChatSetting SettingIQChat = new IQChatSetting();

				internal class IQChatSetting
				{
					[JsonProperty(LanguageEn ? "IQChat : Custom prefix in chat" : "IQChat : Кастомный префикс в чате")]
					public String CustomPrefix;

					[JsonProperty(LanguageEn
						? "IQChat : Custom avatar in the chat (If required)"
						: "IQChat : Кастомный аватар в чате(Если требуется)")]
					public String CustomAvatar;

					[JsonProperty(LanguageEn
						? "IQChat : Use UI notifications"
						: "IQChat : Использовать UI уведомления")]
					public Boolean UIAlertUse;
				}
			}

			internal class InterfaceConfiguration
			{
				[JsonProperty(LanguageEn ? "PNG : Link to the background of the notification" : "PNG : Ссылка на задний фон уведомления")]
				public String PNGBackground;

				[JsonProperty(LanguageEn ? "PNG : Link to the image when receiving the privilege" : "PNG : Ссылка на картинку при получении привилегии")]
				public String PNGPrivilageAdd;

				[JsonProperty(LanguageEn ? "PNG : Link to the picture at the end of the privilege" : "PNG : Ссылка на картинку при окончании привилегии")]
				public String PNGPrivilageExpired;

				[JsonProperty(LanguageEn ? "PNG : Link to the picture at the notification of the end of the privilege" : "PNG : Ссылка на картинку при уведомлении об окончании привилегии")]
				public String PNGPrivilageAlert;

				[JsonProperty(LanguageEn ? "RGBA : Header Color" : "RGBA : Цвет заголовка")]
				public String RGBAColorTitle;

				[JsonProperty(LanguageEn ? "RGBA : Additional text color" : "RGBA : Цвет дополнительного текста")]
				public String RGBAColorDescription;
			}

			internal class StructureLanguage
			{
				[JsonProperty(LanguageEn ? "Name in Russian (Not obligatory. Only for Russian players)" : "Название на русском")]
				public String RussianName;
				[JsonProperty(LanguageEn ? "Name in English" : "Название на английском")]
				public String EnglishName;

				public StructureLanguage(String russianName, String englishName)
				{
					RussianName = russianName;
					EnglishName = englishName;
				}
			}

			public static Configuration GetNewConfiguration()
			{
				return new Configuration
				{
					PermissionList = new Dictionary<String, StructureLanguage>(),
					GroupList = new Dictionary<String, StructureLanguage>(),
					GeneralSettings = new GeneralSetting
					{
						WebHooksDiscord = "",
						UseRemoveGroupsWhenUnload = true,
						UseRemovePermissionsХWhenUnload = true,
						AutoGiveSettings = new GeneralSetting.AutoGive
						{
							UseAutGivePermissions = false,
							UseAutGiveGroups = false,
							PermissionList = new Dictionary<String, String>()
							{
								["iqchat.vip"] = "7d",
								["opt.oneperm"] = "1d"
							},
							GroupList = new Dictionary<String, String>()
							{
								["vip"] = "7d",
								["oneperm"] = "1d"
							}
						},
						MySQLSetting = new GeneralSetting.MySQLInitialize
						{
							TableName = "players",
							MigrationSettings = new GeneralSetting.MySQLInitialize.MigrationPrivilage
							{
								UseMigrationPermissionsList = true,
								MigrationPermissionList = new List<String>
								{
									"iqchat.vip",
									"iqchat.premium",
									"iqbreakingtools.use",
								},
								UseMigrationGroupList = true,
								MigrationGroupList = new List<String>
								{
									"vip",
									"premium",
									"king",
									"deluxe",
								},
							},
							ConnectSetting = new GeneralSetting.MySQLInitialize.MySQLConnect
							{
								Host = "",
								Port = "",
								DatabaseName = "",
								UserName = "",
								Passowrd = ""
							}
						}
					},
					InterfaceSetting = new InterfaceConfiguration
					{
						PNGBackground = "https://i.imgur.com/4lmBa3O.png",
						PNGPrivilageAdd = "https://i.imgur.com/WY7QFpX.png",
						PNGPrivilageExpired = "https://i.imgur.com/ZhVCqoS.png",
						PNGPrivilageAlert = "https://i.imgur.com/OkjSSB3.png",
						RGBAColorTitle = "0.73 0.32 0.57 1",
						RGBAColorDescription = "0.80 0.54 0.68 1",
					},
					AlertConfigurations = new AlertConfiguration
					{
						UseAlertedPermission = true,
						PermissionsListAlerted = new List<String>()
						{
							"iqchat.vip",
							"iqchat.premium",
							"iqbreakingtools.use",
						},
						UseAlertedGroup = true,
						GrpupListAlerted = new List<String>()
						{
							"vip",
							"premium",
							"king",
							"deluxe",
						},
						DayAlerted = 3,
						TimeAlert = 5f,
						UsePoopUp = true,
						SettingIQChat = new AlertConfiguration.IQChatSetting
						{
							CustomPrefix = "[IQPermission]",
							CustomAvatar = "",
							UIAlertUse = false
						},
					}
				};
			}
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null) LoadDefaultConfig();
			}
			catch
			{
				PrintWarning(LanguageEn ? $"Error #554548 reading the configuration 'oxide/config/{Name}', creating a new configuration!!" : $"Ошибка #554548 чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
				LoadDefaultConfig();
			}
			
			if (config.GeneralSettings.MySQLSetting.TableName == null ||
			    String.IsNullOrWhiteSpace(config.GeneralSettings.MySQLSetting.TableName))
				config.GeneralSettings.MySQLSetting.TableName = "players";
			
			NextTick(SaveConfig);
		}

		protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
		protected override void SaveConfig() => Config.WriteObject(config, true);
		
		private static String GetIcon(TypeAlert typeAlert)
		{
			Configuration.InterfaceConfiguration Interfaces = config.InterfaceSetting;

			String Icon = typeAlert == TypeAlert.Add ? Interfaces.PNGPrivilageAdd :
				typeAlert == TypeAlert.Expired ? Interfaces.PNGPrivilageExpired :
				typeAlert == TypeAlert.Alert ? Interfaces.PNGPrivilageAlert : String.Empty;
			return ImageUi.GetImage(Icon);
		}

		private String GetTitle(TypeAlert typeAlert)
		{
			String Lang = typeAlert == TypeAlert.Add ? "TITLE_ALERT_ADD" :
				typeAlert == TypeAlert.Expired ? "TITLE_ALERT_EXPIRED" :
				typeAlert == TypeAlert.Alert ? "TITLE_ALERT_INFO" : String.Empty;
			return Lang;
		}

		private String GetDescription(String UserID, TypeAlert typeAlert, String ReplaceKey, String DataExpired)
		{
			String Lang = typeAlert == TypeAlert.Add ? GetLang("DESCRIPTION_ALERT_ADD", UserID, ReplaceKey) :
				typeAlert == TypeAlert.Expired ? GetLang("DESCRIPTION_ALERT_EXPIRED", UserID, ReplaceKey) :
				typeAlert == TypeAlert.Alert ? GetLang("DESCRIPTION_ALERT_INFO", UserID, ReplaceKey, DataExpired) : String.Empty;
			
			return Lang;
		}

		private String GetLanguageNamePrivilage(BasePlayer player,String Key, TypeData type)
		{
			String ReplaceKey = String.Empty;
			
			switch (type)
			{
				case TypeData.Permission:
				{
					if (config.PermissionList.ContainsKey(Key))
					{
						ReplaceKey = lang.GetLanguage(player.UserIDString) == "ru"
							? config.PermissionList[Key].RussianName
							: config.PermissionList[Key].EnglishName;

						return ReplaceKey;
					}

					break;
				}
				case TypeData.Group:
					if (config.GroupList.ContainsKey(Key))
					{
						ReplaceKey = lang.GetLanguage(player.UserIDString) == "ru"
							? config.GroupList[Key].RussianName
							: config.GroupList[Key].EnglishName;
						
						return ReplaceKey;
					}
					break;
			}

			return null;
		}

		#endregion

		#region Data

		[JsonProperty(LanguageEn ? "Information about privileges" : "Информация о привилегиях")]
		private StructureData InformationPrivilagesUser = new StructureData();

		[JsonProperty(LanguageEn
			? "Players who are no longer considered beginners"
			: "Игроки, которые более не считают новичками")]
		private List<UInt64> OldPlayers = new List<UInt64>();

		private void SetupAutoPrivilages(BasePlayer player)
		{
			if (OldPlayers.Contains(player.userID)) return;

			if (config.GeneralSettings.AutoGiveSettings.UseAutGivePermissions)
			{
				foreach (KeyValuePair<String,String> Permission in config.GeneralSettings.AutoGiveSettings.PermissionList)
				{
					TimeSpan duration;
					if (!TryParseTimeSpan(Permission.Value, out duration))
					{
						_.Puts(LanguageEn
							? $"Automatic privilege issue error - {Permission.Key} - invalid time format"
							: $"Ошибка выдачи автоматической привилегии - {Permission.Key} - неверный формат времени");

						_.LogToFile("LogPermission",
							$"=========> AutoGive : Not correct format time - {Permission.Key}", _);			
						return;
					}
					
					DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Permission.Key, player.userID, TypeData.Permission) + duration;
					InformationPrivilagesUser.SetParametres(Permission.Key, player.userID, ThisTime, TypeData.Permission);
					
					_.LogToFile("LogPermission",
						$"=========> AutoGive : Success give - {Permission.Key} : {player.userID}", _);	
				}
			}

			if (config.GeneralSettings.AutoGiveSettings.UseAutGiveGroups)
			{
				foreach (KeyValuePair<String,String> Group in config.GeneralSettings.AutoGiveSettings.GroupList)
				{
					TimeSpan duration;
					if (!TryParseTimeSpan(Group.Value, out duration))
					{
						_.Puts(LanguageEn
							? $"Automatic privilege issue error - {Group.Key} - invalid time format"
							: $"Ошибка выдачи автоматической привилегии - {Group.Key} - неверный формат времени");

						_.LogToFile("LogPermission",
							$"=========> AutoGive : Not correct format time - {Group.Key}", _);			
						return;
					}
					
					DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Group.Key, player.userID, TypeData.Group) + duration;
					InformationPrivilagesUser.SetParametres(Group.Key, player.userID, ThisTime, TypeData.Group);
					
					_.LogToFile("LogPermission",
						$"=========> AutoGive : Success give - {Group.Key} : {player.userID}", _);	
				}
			}
			
			OldPlayers.Add(player.userID);
		}

		internal class StructureData
		{
			[JsonProperty(LanguageEn ? "Information about player permissions" : "Информация о привилегиях игрока")]
			public Dictionary<String, Dictionary<UInt64, DateTime>> UserPermissions =
				new Dictionary<String, Dictionary<UInt64, DateTime>>();

			[JsonProperty(LanguageEn ? "Information about player groups" : "Информация о группах игрока")]
			public Dictionary<String, Dictionary<UInt64, DateTime>> UserGrpups =
				new Dictionary<String, Dictionary<UInt64, DateTime>>();

			public Dictionary<String, DateTime> GetParametresUser(UInt64 userID, TypeData typeDictonary)
			{
				Dictionary<String, Dictionary<UInt64, DateTime>> selectStructureData =
					typeDictonary == TypeData.Permission ? UserPermissions : UserGrpups;
				Dictionary<String, DateTime> ParametresUser = selectStructureData
					.Where(structure => structure.Value.ContainsKey(userID)).ToDictionary(structure => structure.Key,
						structure => structure.Value[userID]);
				return ParametresUser;
			}

			public Dictionary<UInt64, DateTime> GePlayerList(String Key, TypeData typeDictonary)
			{
				Dictionary<String, Dictionary<UInt64, DateTime>> selectStructureData =
					typeDictonary == TypeData.Permission ? UserPermissions : UserGrpups;
				return selectStructureData.ContainsKey(Key) ? selectStructureData[Key] : null;
			}

			public DateTime GetExpiredPermissionData(String Key, UInt64 userID, TypeData typeDictonary)
			{
				Dictionary<String, Dictionary<UInt64, DateTime>> selectStructureData =
					typeDictonary == TypeData.Permission ? UserPermissions : UserGrpups;
				return selectStructureData.ContainsKey(Key)
					? selectStructureData[Key].ContainsKey(userID) ? selectStructureData[Key][userID] : DateTime.Now
					: DateTime.Now;
			}

			public void SetParametres(String Key, UInt64 userID, DateTime dateExpired, TypeData typeDictonary, Boolean IsMigration = false)
			{
				Dictionary<String, Dictionary<UInt64, DateTime>> selectStructureData =
					typeDictonary == TypeData.Permission ? UserPermissions : UserGrpups;

				if (!selectStructureData.ContainsKey(Key))
					selectStructureData.Add(Key, new Dictionary<UInt64, DateTime>() { });

				if (selectStructureData[Key].ContainsKey(userID))
					selectStructureData[Key][userID] = dateExpired;
				else selectStructureData[Key].Add(userID, dateExpired);

				if (typeDictonary == TypeData.Permission)
					_.permission.GrantUserPermission(userID.ToString(), Key, null);
				else _.permission.AddUserGroup(userID.ToString(), Key);

				String LeftTime = _.GetLeftTime(dateExpired, userID.ToString());
				
				_.InserDatabase(userID.ToString(), typeDictonary, Key, dateExpired);
				_.Puts(LanguageEn
					? $"Player {userID} successfully obtained {(typeDictonary == TypeData.Permission ? "permission" : "group")} - {Key} (End date in : {LeftTime})"
					: $"Игрок {userID} успешно получил {(typeDictonary == TypeData.Permission ? "права" : "группу")} - {Key} (Дата окончания через : {LeftTime})");
				
				if (!IsMigration)
				{
					_.AlertPlayer(userID, TypeAlert.Add, Key, typeDictonary, $"{LeftTime}");

					_.LogToFile("LogPermission",
						$"===> Set - Type : {typeDictonary.ToString()} | Key : {Key} | DataExpired in : {LeftTime}", _);
					
					List<Fields> fields = new List<Fields>
					{
						new Fields("Steam64ID", userID.ToString(), true),
						new Fields(
							LanguageEn
								? $"Received {(typeDictonary == TypeData.Permission ? "permission" : "group")}"
								: $"Получил {(typeDictonary == TypeData.Permission ? "права" : "группу")}", Key, true),
						new Fields(LanguageEn ? "Date Expired in" : $"Дата окончания через", $"{LeftTime}",
							true),
					};
					_.SendDiscord(fields);
				}
			}

			public void RemoveParametres(String Key, UInt64 userID, TypeData typeDictonary,
				DateTime timeRevoed = default(DateTime))
			{
				Dictionary<String, Dictionary<UInt64, DateTime>> selectStructureData =
					typeDictonary == TypeData.Permission ? UserPermissions : UserGrpups;

				if (!selectStructureData.ContainsKey(Key) ) return; 
				if (timeRevoed == default(DateTime))
				{
					selectStructureData[Key].Remove(userID);
					_.DeleteDatabase(userID.ToString(), typeDictonary, Key);
				}
				else
				{
					selectStructureData[Key][userID] = timeRevoed;
					if (!IsExpiredPermission(Key, userID, typeDictonary))
					{
						String LeftTime = _.GetLeftTime(timeRevoed, userID.ToString());

						_.Puts(LanguageEn
							? $"The player has {userID} reduced action time {(typeDictonary == TypeData.Permission ? "permission" : "group")} - {Key} | End date in : {LeftTime}"
							: $"У игрока {userID} снижено время действия {(typeDictonary == TypeData.Permission ? "права" : "группы")} - {Key} | Дата окончания через : {LeftTime}");

						_.LogToFile("LogPermission",
							$"=====> Remove time - Type : {typeDictonary.ToString()} | Key : {Key}", _);

						List<Fields> fieldsRemoveTime = new List<Fields>
						{
							new Fields("Steam64ID", userID.ToString(), true),
							new Fields(
								LanguageEn
									? $"Reduced action time {(typeDictonary == TypeData.Permission ? "permission" : "group")}"
									: $"Снижено время дейтсвия {(typeDictonary == TypeData.Permission ? "прав" : "группы")}",
								Key, true),
							new Fields(LanguageEn ? "End Date in" : $"Дата окончания через", $"{LeftTime}",
								true),
						};
						_.SendDiscord(fieldsRemoveTime);
						_.InserDatabase(userID.ToString(), typeDictonary, Key, selectStructureData[Key][userID]);
						return;
					}

					selectStructureData[Key].Remove(userID);
					_.DeleteDatabase(userID.ToString(), typeDictonary, Key);
				}

				if (selectStructureData[Key].Count == 0)
					selectStructureData.Remove(Key);

				if (typeDictonary == TypeData.Permission)
					_.permission.RevokeUserPermission(userID.ToString(), Key);
				else _.permission.RemoveUserGroup(userID.ToString(), Key);

				_.AlertPlayer(userID, TypeAlert.Expired, Key, typeDictonary, null);
				_.Puts(LanguageEn
					? $"The player {userID} has run out of {(typeDictonary == TypeData.Permission ? "permission" : "group")} - {Key}"
					: $"У игрока {userID} {(typeDictonary == TypeData.Permission ? "закончились права" : "закончилась группа")} - {Key}");

				_.LogToFile("LogPermission", $"=====> Remove - Type : {typeDictonary.ToString()} | Key : {Key}", _);

				List<Fields> fields = new List<Fields>
				{
					new Fields("Steam64ID", userID.ToString(), true),
					new Fields(
						LanguageEn
							? $"Expired {(typeDictonary == TypeData.Permission ? "permission" : "group")}"
							: $"{(typeDictonary == TypeData.Permission ? "Закончились права" : "Закончилась группа")}",
						Key, true),
				};
				_.SendDiscord(fields);
			}

			public void SetParametresUnload()
			{
				_.LogToFile("LogPermission", $"=========> Set Permissions in UNLOAD <=========", _);

				foreach (KeyValuePair<String,Dictionary<UInt64,DateTime>> userPermission in UserPermissions)
				foreach (KeyValuePair<UInt64, DateTime> userInformation in userPermission.Value.Where(userInformation => !_.permission.UserHasPermission(userInformation.Key.ToString(), userPermission.Key)))
				{
					_.permission.GrantUserPermission(userInformation.Key.ToString(), userPermission.Key, null);
					_.LogToFile("LogPermission",
						$"=======> Set UserID (Unload) : {userInformation.Key} |  Key : {userPermission.Key}",
						_);
				}

				_.LogToFile("LogPermission", $"=========> Set Group in UNLOAD <=========", _);

				foreach (KeyValuePair<String,Dictionary<UInt64,DateTime>> userGroup in UserGrpups)
				foreach (KeyValuePair<UInt64, DateTime> userInformation in userGroup.Value.Where(userInformation => !_.permission.UserHasGroup(userInformation.Key.ToString(), userGroup.Key)))
				{
					_.permission.AddUserGroup(userInformation.Key.ToString(), userGroup.Key);
					_.LogToFile("LogPermission",
						$"=======> Set UserID (Unload) : {userInformation.Key} |  Key : {userGroup.Key}",
						_);
				} 
			}

			public void RemoveParametresUnload()
			{
				_.Unsubscribe("OnUserGroupRemoved");
				_.Unsubscribe("OnUserPermissionRevoked");
				
				if (config.GeneralSettings.UseRemovePermissionsХWhenUnload)
				{
					_.LogToFile("LogPermission", $"=========> Remove Permissions in UNLOAD <=========", _);

					foreach (KeyValuePair<String,Dictionary<UInt64,DateTime>> userPermission in UserPermissions)
						foreach (KeyValuePair<UInt64, DateTime> userInformation in userPermission.Value.Where(userInformation => _.permission.UserHasPermission(userInformation.Key.ToString(), userPermission.Key)))
						{
							_.permission.RevokeUserPermission(userInformation.Key.ToString(), userPermission.Key);
							_.LogToFile("LogPermission", $"=======> Remove UserID (Unload) : {userInformation.Key} |  Key : {userPermission.Key}", _);
						}
				}

				if (config.GeneralSettings.UseRemoveGroupsWhenUnload)
				{
					_.LogToFile("LogPermission", $"=========> Remove Group in UNLOAD <=========", _);

					foreach (KeyValuePair<String, Dictionary<UInt64, DateTime>> userGroup in UserGrpups)
					{
						foreach (KeyValuePair<UInt64, DateTime> userInformation in userGroup.Value.Where(userInformation => _.permission.UserHasGroup(userInformation.Key.ToString(), userGroup.Key)))
						{
							_.permission.RemoveUserGroup(userInformation.Key.ToString(), userGroup.Key);
							_.LogToFile("LogPermission",
								$"=======> Remove UserID (Unload) : {userInformation.Key} |  Key : {userGroup.Key}", _);
						}
					}
				}
			}
			private Boolean IsExpiredPermission(String Key, UInt64 userID, TypeData typeDictonary)
			{
				Dictionary<String, Dictionary<UInt64, DateTime>> selectStructureData =
					typeDictonary == TypeData.Permission ? UserPermissions : UserGrpups;

				if (!selectStructureData.ContainsKey(Key)) return false;
				return selectStructureData[Key][userID] < DateTime.Now;
			}

			public void TrackerExpireds()
			{
				foreach (KeyValuePair<String, Dictionary<UInt64, DateTime>> userPermission in UserPermissions)
				foreach (KeyValuePair<UInt64, DateTime> PlayersListPermission in userPermission.Value.Where(
					         PlayersListPermission => IsExpiredPermission(userPermission.Key, PlayersListPermission.Key,
						         TypeData.Permission)))
					_.NextTick(() =>
						RemoveParametres(userPermission.Key, PlayersListPermission.Key, TypeData.Permission));

				foreach (KeyValuePair<String, Dictionary<UInt64, DateTime>> userGrpup in UserGrpups)
				foreach (KeyValuePair<UInt64, DateTime> PlayerListGroup in userGrpup.Value.Where(PlayerListGroup =>
					         IsExpiredPermission(userGrpup.Key, PlayerListGroup.Key, TypeData.Group)))
					_.NextTick(() => RemoveParametres(userGrpup.Key, PlayerListGroup.Key, TypeData.Group));
			}
		}

		private void ReadData()
		{
			OldPlayers = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<List<UInt64>>("IQSystem/IQPermissions/OldPlayers");
			if (sqlConnection != null) return;
			InformationPrivilagesUser = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<StructureData>("IQSystem/IQPermissions/Permissions");
		}

		private void WriteData()
		{
			Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQPermissions/OldPlayers", OldPlayers);
			if (sqlConnection != null) return;
			Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQPermissions/Permissions", InformationPrivilagesUser);
		}
		
		#endregion

        #region Hooks

        private void Init()
        {
	        _ = this;
	        ReadData();
        } 
        private void OnServerInitialized()
        {
	        Subscribe("OnUserGroupRemoved");
	        Subscribe("OnUserPermissionRevoked");
	        
	        GrablingPermissions();
            GrablingGroups();
            
            PreLoadedPlugin();
            StartPluginLoad();
            
            Interface.Call("OnIQPermissionInitialized");
        }
        private void Unload()
        {
	        _.InformationPrivilagesUser.RemoveParametresUnload();
	        WriteData();
	        
	        if (coroutineMigration != null)
	        {
		        ServerMgr.Instance.StopCoroutine(coroutineMigration);
		        coroutineMigration = null;
	        }

	        if (RoutineQueue != null)
	        {
		        foreach (KeyValuePair<UInt64,Coroutine> keyValuePair in RoutineQueue.Where(r => r.Value != null))
			        ServerMgr.Instance.StopCoroutine(keyValuePair.Value);

		        RoutineQueue.Clear();
	        }

	        InterfaceBuilder.DestroyAll();
	        ImageUi.Unload();
	        sqlLibrary.CloseDb(sqlConnection);

	        _.IsFullLoaded = false;

	        _ = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
	        MigrationPrivilage(player);
	        SetupAutoPrivilages(player);

	        if (!config.AlertConfigurations.UseAlertedGroup && !config.AlertConfigurations.UseAlertedPermission) return;

	        player.Invoke(() =>
	        {
		        if (!RoutineQueue.ContainsKey(player.userID))
			        RoutineQueue.Add(player.userID, ServerMgr.Instance.StartCoroutine(JoinedAlertPlayer(player)));
		        else RoutineQueue[player.userID] = ServerMgr.Instance.StartCoroutine(JoinedAlertPlayer(player));
	        }, 10f);
        }
        
        private void OnPermissionRegistered(String name, Plugin owner) => NewPermissionRegistered(name);
        private void OnGroupCreated(String name) => NewGroupRegistered(name);
        private void OnUserGroupRemoved(String id, String groupName) =>
	        InformationPrivilagesUser.RemoveParametres(groupName, UInt64.Parse(id), TypeData.Group);
        
        private void OnUserPermissionRevoked(String id, String permName) =>
	        InformationPrivilagesUser.RemoveParametres(permName, UInt64.Parse(id), TypeData.Permission);
	    #endregion

        #region Metods

        #region MySQL

        private readonly Core.MySql.Libraries.MySql sqlLibrary = Interface.Oxide.GetLibrary<Core.MySql.Libraries.MySql>();
        private Connection sqlConnection = null;
        private String SQL_Query_SelectedDatabase()
        {
	        String SelectDB = $"SELECT * FROM {config.GeneralSettings.MySQLSetting.TableName}";
	        return SelectDB;
        }

        private String SQL_Query_CreatedDatabase()
        {
	        String CreatedDB = $"CREATE TABLE IF NOT EXISTS `{config.GeneralSettings.MySQLSetting.TableName}`(" +
		        "`id` INT(11) NOT NULL AUTO_INCREMENT," +
		        "`steamid` VARCHAR(255) NOT NULL," +
		        "`permission` VARCHAR(255) NOT NULL," +
		        "`group` VARCHAR(255) NOT NULL," +
		        "`data_expired` VARCHAR(255) NOT NULL," +
		        " PRIMARY KEY(`id`))";

	        return CreatedDB;
        }

        private String SQL_Query_InsertUser()
        {
	        String InserUser = $"INSERT INTO `{config.GeneralSettings.MySQLSetting.TableName}`" + "(`steamid`, `permission`, `group`, `data_expired`) VALUES ('{0}','{1}','{2}','{3}')";
	        return InserUser;
        }

        #region Connection
        private void SQL_OpenConnection()
        {
            Configuration.GeneralSetting.MySQLInitialize.MySQLConnect SQLInfo = config.GeneralSettings.MySQLSetting.ConnectSetting;
            if (String.IsNullOrWhiteSpace(SQLInfo.Host) || String.IsNullOrWhiteSpace(SQLInfo.Passowrd) ||
                String.IsNullOrWhiteSpace(SQLInfo.Port) || String.IsNullOrWhiteSpace(SQLInfo.DatabaseName) ||
                String.IsNullOrWhiteSpace(SQLInfo.UserName)) return;
            
            sqlConnection = sqlLibrary.OpenDb(SQLInfo.Host, Convert.ToInt32(SQLInfo.Port), SQLInfo.DatabaseName, SQLInfo.UserName, SQLInfo.Passowrd, this);
            
            if (sqlConnection == null) return;
            
            Sql sql = Sql.Builder.Append(SQL_Query_CreatedDatabase());
            sqlLibrary.Insert(sql, sqlConnection);
            sql = Sql.Builder.Append(SQL_Query_SelectedDatabase());
            sqlLibrary.Query(sql, sqlConnection, list =>
            {
                if (list.Count > 0)
                    foreach (Dictionary<String, Object> entry in list)
                    {
                        UInt64 SteamID = 0;
                        if(!UInt64.TryParse((String)entry["steamid"], out SteamID))
                        {
                            PrintError(LanguageEn ? "Error parsing SteamID player" : "Ошибка парсинга SteamID игрока");
                            return;
                        }
                        if (!String.IsNullOrWhiteSpace((String)entry["group"]))
                        {
                            String Group = (String)entry["group"];
 
                            if (!_.InformationPrivilagesUser.UserGrpups.ContainsKey(Group))
                                _.InformationPrivilagesUser.UserGrpups.Add(Group, new Dictionary<UInt64, DateTime>());
 
                            if (!_.InformationPrivilagesUser.UserGrpups[Group].ContainsKey(SteamID))
                                _.InformationPrivilagesUser.UserGrpups[Group].Add(SteamID, DateTime.Parse((String)entry["data_expired"]));
                            else
                                _.InformationPrivilagesUser.UserGrpups[Group][SteamID] = DateTime.Parse((String)entry["data_expired"]);
                        }
                        else if (!String.IsNullOrWhiteSpace((String)entry["permission"]))
                        {
                            String Permission = (String)entry["permission"];
                            if(!_.InformationPrivilagesUser.UserPermissions.ContainsKey(Permission))
                                _.InformationPrivilagesUser.UserPermissions.Add(Permission, new Dictionary<UInt64, DateTime>());
 
                            if (!_.InformationPrivilagesUser.UserPermissions[Permission].ContainsKey(SteamID))
                            {
                                _.InformationPrivilagesUser.UserPermissions[Permission]
                                    .Add(SteamID, DateTime.Parse((String)entry["data_expired"]));
                            }
                            else
                            {
                                _.InformationPrivilagesUser.UserPermissions[Permission][SteamID] =
                                    DateTime.Parse((String)entry["data_expired"]);
                            }
                        }
                    }
                PrintWarning(LanguageEn ? "Updated information about users from the database" : "Обновлена информация о пользователях из БД");
            });
        }

        
        #endregion
        
        #region Inserting

        private void InserDatabase(String UserID, TypeData typeData, String Key, DateTime dateExpired)
        {
	        if (sqlConnection == null) return;

		       String Permission = typeData == TypeData.Permission ? Key : String.Empty;
		       String Group = typeData == TypeData.Group ? Key : String.Empty;
		       
		       String sqlQuery = typeData == TypeData.Permission ? $"UPDATE {config.GeneralSettings.MySQLSetting.TableName} SET `steamid` = @0, `permission` = @1,`group` = @2,`data_expired` = @3 WHERE `steamid` = @0 AND `permission` = @1" 
				       : $"UPDATE {config.GeneralSettings.MySQLSetting.TableName} SET `steamid` = @0, `permission` = @1,`group` = @2,`data_expired` = @3 WHERE `steamid` = @0 AND`group` = @2";
		       Sql updateCommand = Oxide.Core.Database.Sql.Builder.Append(sqlQuery, UserID, Permission, Group, dateExpired.ToString());

		       sqlLibrary.Update(updateCommand, sqlConnection, rowsAffected =>
		       {
			       if (rowsAffected <= 0)
			       {
				       String Query = String.Format(SQL_Query_InsertUser(), UserID, Permission, Group,
					       dateExpired.ToString());
				       Sql sql = Sql.Builder.Append(Query);
				       sqlLibrary.Insert(sql, sqlConnection, rowsAffecteds =>
				       {
					       Puts(LanguageEn ? "A new user has been added to the database" : "В БД был внесен новый пользователь");
				       });
			       }
			       else Puts(LanguageEn ? "The data for the user has been updated in the database" : "В БД были обновлены данные для пользователя");
		       });
        }

        #endregion

        #region Deleted

        private void DeleteDatabase(String UserID, TypeData typeData, String Key)
        {
	        if (sqlConnection == null) return;

	        String Permission = typeData == TypeData.Permission ? Key : String.Empty;
	        String Group = typeData == TypeData.Group ? Key : String.Empty;
	        
		        String sqlQuery = typeData == TypeData.Permission ? $"DELETE FROM `{config.GeneralSettings.MySQLSetting.TableName}` WHERE `steamid` = @0 AND `permission` = @1" 
			        : $"DELETE FROM `{config.GeneralSettings.MySQLSetting.TableName}` WHERE `steamid` = @0 AND`group` = @1";
		        Sql deleteCommand = Oxide.Core.Database.Sql.Builder.Append(sqlQuery, UserID, typeData == TypeData.Permission ? Permission : Group);
		        sqlLibrary.Delete(deleteCommand, sqlConnection, rowsAffected =>
		        {
			         Puts(LanguageEn ? "The user's information was deleted in the database" : "В БД была удалена информация пользователя");
		        });
        }

        #endregion

        #region MigrationPrivilage
        
        private void MigrationPrivilage(BasePlayer player) 
        {
	        if (player == null || sqlConnection == null) return;

	        Configuration.GeneralSetting.MySQLInitialize.MigrationPrivilage MigrationInfo = config.GeneralSettings.MySQLSetting.MigrationSettings;
	        
	        if(MigrationInfo.UseMigrationPermissionsList)
		        foreach (KeyValuePair<String,Dictionary<UInt64,DateTime>> Permissions in InformationPrivilagesUser.UserPermissions.Where(x => MigrationInfo.MigrationPermissionList.Contains(x.Key)))
			        foreach (KeyValuePair<UInt64,DateTime> PlayerInformation in Permissions.Value.Where(x => x.Key == player.userID))
				        if (!permission.UserHasPermission(PlayerInformation.Key.ToString(), Permissions.Key))
					        permission.GrantUserPermission(PlayerInformation.Key.ToString(), Permissions.Key, null);
	        
	        if(MigrationInfo.UseMigrationGroupList)
		        foreach (KeyValuePair<String,Dictionary<UInt64,DateTime>> Groups in InformationPrivilagesUser.UserGrpups.Where(x => MigrationInfo.MigrationGroupList.Contains(x.Key)))
			        foreach (KeyValuePair<UInt64,DateTime> PlayerInformation in Groups.Value.Where(x => x.Key == player.userID))
				        if (!permission.UserHasGroup(PlayerInformation.Key.ToString(), Groups.Key))
					        permission.AddUserGroup(PlayerInformation.Key.ToString(), Groups.Key);
        }

        #endregion
        
        #endregion
        
        #region DiscordSend

        private void SendDiscord(List<Fields> fields)
        {
	        if (config.GeneralSettings.WebHooksDiscord == null ||
	            String.IsNullOrWhiteSpace(config.GeneralSettings.WebHooksDiscord)) return;
	        FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10710525, fields, new Authors("IQPermissions", null, "https://i.imgur.com/F5nsCbX.png", null), null) });

	        Request($"{config.GeneralSettings.WebHooksDiscord}", newMessage.toJSON());
        }

        #endregion

        #region JoinAlerted
        
        private Dictionary<UInt64, Coroutine> RoutineQueue = new Dictionary<UInt64, Coroutine>();
		
        private IEnumerator JoinedAlertPlayer(BasePlayer player)
        {
	        if (config.AlertConfigurations.UseAlertedPermission)
	        {
		        foreach (KeyValuePair<String, Dictionary<UInt64, DateTime>> userPermission in InformationPrivilagesUser.UserPermissions.
			                 Where(userPermission => userPermission.Value.ContainsKey(player.userID) && config.AlertConfigurations.PermissionsListAlerted.Contains(userPermission.Key)).
			                 Where(userPermission => ((userPermission.Value[player.userID] - DateTime.Now).Days + 1) <= config.AlertConfigurations.DayAlerted))
		        {
			        AlertPlayer(player.userID, TypeAlert.Alert, userPermission.Key, TypeData.Permission,$"{GetLeftTime(userPermission.Value[player.userID], player.UserIDString)}"); 
			        
			        yield return CoroutineEx.waitForSeconds(config.AlertConfigurations.TimeAlert + 2f);
		        }
	        }
	        
	        if (config.AlertConfigurations.UseAlertedGroup)
	        {
		        foreach (KeyValuePair<String, Dictionary<UInt64, DateTime>> userGroup in InformationPrivilagesUser.UserGrpups.
			                 Where(userGroup => userGroup.Value.ContainsKey(player.userID) && config.AlertConfigurations.GrpupListAlerted.Contains(userGroup.Key)).
			                 Where(userGroup => ((userGroup.Value[player.userID] - DateTime.Now).Days + 1) <= config.AlertConfigurations.DayAlerted))
		        {
			        AlertPlayer(player.userID, TypeAlert.Alert, userGroup.Key, TypeData.Group,$"{GetLeftTime(userGroup.Value[player.userID], player.UserIDString)}"); 
			        yield return CoroutineEx.waitForSeconds(config.AlertConfigurations.TimeAlert + 2f);
		        }
	        }

	       // CuiHelper.DestroyUi(player, InterfaceBuilder.UI_POOPUP_PANEL);

	       if (RoutineQueue == null) yield break;
	       if (!RoutineQueue.ContainsKey(player.userID)) yield break;
	       if (RoutineQueue[player.userID] != null)
		       ServerMgr.Instance.StopCoroutine(RoutineQueue[player.userID]);
			        
	       RoutineQueue.Remove(player.userID);
        }

        #endregion
        
        #region AlertPlayer

        private void AlertPlayer(UInt64 userID, TypeAlert typeAlert, String Key, TypeData typeData, String DataExpired)
        {
	        BasePlayer player = BasePlayer.FindByID(userID);
	        if (player == null) return;

	        if (UAlertSystem)
	        {
		        String ReplaceKey = GetLanguageNamePrivilage(player, Key, typeData);
		        if (ReplaceKey == null) return;
		        UAlertSystem.CallHook("API_SEND_ALERT", GetLang(GetTitle(typeAlert), userID.ToString()),GetDescription(userID.ToString(), typeAlert,ReplaceKey,DataExpired), "0.84 0.26 0.26 1", "1 1 1 1", 5f);
		        return;
	        }
	        if (config.AlertConfigurations.UsePoopUp)
		        DrawUI_PoopUp(player, typeAlert, Key, typeData, DataExpired);
	        else
	        {
		        String ReplaceKey = GetLanguageNamePrivilage(player, Key, typeData);
		        if (ReplaceKey == null) return;
		        String Message = $"{GetLang(GetTitle(typeAlert), userID.ToString())}/n{GetDescription(userID.ToString(), typeAlert,ReplaceKey,DataExpired)}";
		        SendChat(Message, player);
	        }
        }

        #endregion

        #region Parse

        private void NewPermissionRegistered(String Permission)
        {
            if(config.PermissionList.ContainsKey(Permission)) return;
            String ExampleName = Permission.Substring(Permission.IndexOf('.') + 1).ToUpper();
            config.PermissionList.Add(Permission, new Configuration.StructureLanguage(ExampleName, ExampleName));

            Puts( LanguageEn ?$"A new permission {Permission} has been added to the configuration file" : $"В конфигурационный файл была добавлена новое право {Permission}");
            SaveConfig();
        }
        
        private void NewGroupRegistered(String Group)
        {
            if(config.GroupList.ContainsKey(Group)) return;
            String ExampleName = Group.ToUpper();
            config.GroupList.Add(Group, new Configuration.StructureLanguage(ExampleName, ExampleName));

            Puts(LanguageEn ? $"A new group {Group} has been added to the configuration file" :  $"В конфигурационный файл была добавлена новая группа {Group}");
            SaveConfig();
        }

        #endregion

        #region Grabling
        
        private void GrablingGroups()
        {
            String[] GroupList = permission.GetGroups();
    
            Int32 CountGroupsGrabs = 0;
            foreach (String group in GroupList.Where(p => !config.GroupList.ContainsKey(p)))
            {
                String ExampleName = group.ToUpper();
            
                config.GroupList.Add(group, new Configuration.StructureLanguage(ExampleName, ExampleName));
                CountGroupsGrabs++;
            }
            
            if (CountGroupsGrabs == 0) return;
            Puts(LanguageEn ? $"New groups have been added to the configuration file - {CountGroupsGrabs}" :  $"В конфигурационный файл было добавлено - {CountGroupsGrabs} новых групп");
        }
        private void GrablingPermissions()
        {
            String[] PermissionList = permission.GetPermissions();

            Int32 CountPermissionGrabs = 0;
            foreach (String perm in PermissionList.Where(p => !config.PermissionList.ContainsKey(p)))
            {
                String ExampleName = perm.Substring(perm.IndexOf('.') + 1).ToUpper();

                config.PermissionList.Add(perm, new Configuration.StructureLanguage(ExampleName, ExampleName));
                CountPermissionGrabs++;
            }

            if (CountPermissionGrabs == 0) return;
            Puts(LanguageEn ? $"New permission have been added to the configuration file - {CountPermissionGrabs}" : $"В конфигурационный файл было добавлено - {CountPermissionGrabs} новых прав");
        }
        #endregion
        
        #region PreLoaded

        private void PreLoadedPlugin()
        {
	        if(!ImageLibrary)
	        {
		        NextTick(() => {
			        PrintError($"ImageLibrary not found! Please, check your plugins list.");
			        Interface.Oxide.UnloadPlugin(Name);
		        });
		        return;	
	        }

	        SQL_OpenConnection();
        }

        #endregion

        #region Loaded
        private void StartPluginLoad()
        {
	        //Load your images here
	        ImageUi.Initialize();
	        ImageUi.DownloadImages();
        }
        #endregion

        #endregion

        #region Command

        [ChatCommand("pinfo")]
        private void ChatCommand_Pinfo(BasePlayer player)
        {
	        String ResultInfo = String.Empty;
	        Dictionary<String, DateTime> Group =
		        InformationPrivilagesUser.GetParametresUser(player.userID, TypeData.Group);
	        Dictionary<String, DateTime> Permission =
		        InformationPrivilagesUser.GetParametresUser(player.userID, TypeData.Permission);

	        if (Group.Count == 0 && Permission.Count == 0)
	        {
		        SendChat(GetLang("PINFO_ALERT_NOT", player.UserIDString), player);
		        return;
	        }
	        
	        ResultInfo = Group.Aggregate(ResultInfo, (current, group) => current + $"- {GetLanguageNamePrivilage(player, group.Key, TypeData.Group)} : {_.GetLeftTime(group.Value, player.UserIDString)}\n");
	        if (!String.IsNullOrWhiteSpace(ResultInfo))
		        ResultInfo += "\n\n";
	        ResultInfo = Permission.Aggregate(ResultInfo, (current, permissions) => current + $"- {GetLanguageNamePrivilage(player, permissions.Key, TypeData.Permission)} : {_.GetLeftTime(permissions.Value, player.UserIDString)}\n");

	        if (IQChat)
		        IQChat?.Call("API_ALERT_PLAYER", player, GetLang("PINFO_ALERT", player.UserIDString, ResultInfo), config.AlertConfigurations.SettingIQChat.CustomPrefix, config.AlertConfigurations.SettingIQChat.CustomAvatar);
	        else
		        player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, 0,
			        GetLang("PINFO_ALERT", player.UserIDString, ResultInfo), player);
        }
        
        [ConsoleCommand("migration.timedpermissions")]
        private void TimedPermissionsMigration(ConsoleSystem.Arg arg)
        {
	        if (arg.Player() != null) return;
	        coroutineMigration = ServerMgr.Instance.StartCoroutine(MigrationTimedPermissions());
        }
        
        [ConsoleCommand("migration.grant")]
        private void GrantMigration(ConsoleSystem.Arg arg)
        {
	        if (arg.Player() != null) return;
	        coroutineMigration = ServerMgr.Instance.StartCoroutine(MigrationGrant());
        }
        
        [ConsoleCommand("migration.timeprivilage")]
        private void TimePrivilageMigration(ConsoleSystem.Arg arg)
        {
	        if (arg.Player() != null) return;
	        coroutineMigration = ServerMgr.Instance.StartCoroutine(MigrationTimePrivilage());
        }
        
        [ConsoleCommand("grantperm")] 
        private void GrantPerm_ConsoleCommand(ConsoleSystem.Arg arg)
        {
	        if (arg == null) return;
	        if(arg.Player() != null)
		        if(!arg.Player().IsAdmin)
			        return;
	        
	        if (arg.Args == null || arg.Args.Length < 3 )
	        {
		        arg.ReplyWith(LanguageEn ? "Syntax error, use: grantperm Steam64ID Permission Time(1d/1m/1s)\nExample : grantperm 76561132329787930 iqchat.vip 1d": "Ошибка синтаксиса, используйте : grantperm Steam64ID Permission Time(1d/1m/1s)\nПример : grantperm 76561132329787930 iqchat.vip 1d");
		        return;
	        }

	        UInt64 userID;
	        if (!UInt64.TryParse(arg.Args[0], out userID))
	        {
		        arg.ReplyWith(LanguageEn ? "You have specified an incorrect Steam64ID player!": "Вы указали неккоректный Steam64ID игрока!");
		        return;
	        }

	        String Permission = arg.Args[1];
	        if (!config.PermissionList.ContainsKey(Permission))
	        {
		        arg.ReplyWith(LanguageEn ? "The permission you specified do not exist!": "Права которые вы указали - не существуют!");
		        return;
	        }
	        
	        TimeSpan duration;
	        if (!TryParseTimeSpan(arg.Args[2], out duration))
	        {
		        arg.ReplyWith(LanguageEn ? "You specified an incorrect time, use 1d/1m/1s!": "Вы указали неккоректное время, используйте 1d/1m/1s!");
				return;
	        }
	        
	        DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Permission, userID, TypeData.Permission) + duration;
	        InformationPrivilagesUser.SetParametres(Permission, userID, ThisTime, TypeData.Permission);
        }

        [ConsoleCommand("grant.permission")]
        private void GrantPerm_TwoConsoleCommand(ConsoleSystem.Arg arg) => GrantPerm_ConsoleCommand(arg);
        
	    [ConsoleCommand("revokeperm")] 
        private void RevokePerm_ConsoleCommand(ConsoleSystem.Arg arg)
        {
	        if (arg == null) return;
	        
	        if(arg.Player() != null)
		        if(!arg.Player().IsAdmin)
			        return;
	        
	        if (arg.Args == null || arg.Args.Length < 2)
	        {
		        arg.ReplyWith(LanguageEn ? "Syntax error, use: revokeperm Steam64ID Permission\nExample : revokeperm 765611932325887930 iqchat.vip": "Ошибка синтаксиса, используйте : revokeperm Steam64ID Permission\nПример : revokeperm 76561197235887930 iqchat.vip");
		        return;
	        }

	        UInt64 userID;
	        if (!UInt64.TryParse(arg.Args[0], out userID))
	        {
		        arg.ReplyWith(LanguageEn ? "You have specified an incorrect Steam64ID player!": "Вы указали неккоректный Steam64ID игрока!");
		        return;
	        }

	        String Permission = arg.Args[1];
	        if (!config.PermissionList.ContainsKey(Permission))
	        {
		        arg.ReplyWith(LanguageEn ? "The permission you specified do not exist!": "Права которые вы указали - не существуют!");
		        return;
	        }
	        
	        if (!permission.UserHasPermission(userID.ToString(), Permission))
	        {
		        arg.ReplyWith(LanguageEn ? "The player does not have these rights!!": "У игрока отсутствуют данные права!");
		        return;
	        }
	        
	        if (arg.Args.Length == 3)
	        {
		        TimeSpan duration;
		        if (!TryParseTimeSpan(arg.Args[2], out duration))
		        {
			        arg.ReplyWith(LanguageEn ? "You specified an incorrect time, use 1d/1m/1s!": "Вы указали неккоректное время, используйте 1d/1m/1s!");
			        return;
		        }
	        
		        DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Permission, userID, TypeData.Permission) - duration;
		        InformationPrivilagesUser.RemoveParametres(Permission, userID, TypeData.Permission, ThisTime);
		        return;
	        }
	        
	        InformationPrivilagesUser.RemoveParametres(Permission, userID, TypeData.Permission);
        }

        [ConsoleCommand("revoke.permission")]
        private void RevokePerm_TwoConsoleCommand(ConsoleSystem.Arg arg) => RevokePerm_ConsoleCommand(arg);

        [ConsoleCommand("addgroup")] 
        private void AddGroup_ConsoleCommand(ConsoleSystem.Arg arg)
        {
	        if (arg == null) return;
	        
	        if(arg.Player() != null)
		        if(!arg.Player().IsAdmin)
			        return;
	        
	        if (arg.Args == null || arg.Args.Length < 3 )
	        {
		        arg.ReplyWith(LanguageEn ? "Syntax error, use: addgroup Steam64ID Group Time(1d/1m/1s)\nПример : addgroup 7656119723232887930 vip 1d": "Ошибка синтаксиса, используйте : addgroup Steam64ID Group Time(1d/1m/1s)\nПример : addgroup 76561197235887930 vip 1d");
		        return;
	        }

	        UInt64 userID;
	        if (!UInt64.TryParse(arg.Args[0], out userID))
	        {
		        arg.ReplyWith(LanguageEn ? "You have specified an incorrect Steam64ID player!": "Вы указали неккоректный Steam64ID игрока!");
		        return;
	        }

	        String Group = arg.Args[1];
	        if (!config.GroupList.ContainsKey(Group))
	        {
		        arg.ReplyWith(LanguageEn ? "The group you specified do not exist!": "Группа которую вы указали - не существуют!");
		        return;
	        }
	        
	        TimeSpan duration;
	        if (!TryParseTimeSpan(arg.Args[2], out duration))
	        {
		        arg.ReplyWith(LanguageEn ? "You specified an incorrect time, use 1d/1m/1s!": "Вы указали неккоректное время, используйте 1d/1m/1s!");
				return;
	        }
	        
	        DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Group, userID, TypeData.Group) + duration;
	        InformationPrivilagesUser.SetParametres(Group, userID, ThisTime, TypeData.Group);
        }

        [ConsoleCommand("grant.group")]
        private void AddGroup_TwoConsoleCommand(ConsoleSystem.Arg arg) => AddGroup_ConsoleCommand(arg);
        
        [ConsoleCommand("revokegroup")] 
        private void RemoveGroup_ConsoleCommand(ConsoleSystem.Arg arg)
        {
	        if (arg == null) return;
	        
	        if(arg.Player() != null)
		        if(!arg.Player().IsAdmin)
			        return;
	        
	        if (arg.Args == null || arg.Args.Length < 2)
	        {
		        arg.ReplyWith(LanguageEn ? "Syntax error, use: revokegroup Steam64ID Group\nExample : revokegroup 765611972353232930 vip": "Ошибка синтаксиса, используйте : revokegroup Steam64ID Group\nПример : revokegroup 76561197235887930 vip");
		        return;
	        }

	        UInt64 userID;
	        if (!UInt64.TryParse(arg.Args[0], out userID))
	        {
		        arg.ReplyWith(LanguageEn ? "You have specified an incorrect Steam64ID player!": "Вы указали неккоректный Steam64ID игрока!");
		        return;
	        }

	        String Group = arg.Args[1];
	        if (!config.GroupList.ContainsKey(Group))
	        {
		        arg.ReplyWith(LanguageEn ? "The group you specified do not exist!": "Группа которую вы указали - не существуют!");
		        return;
	        }

	        if (!permission.UserHasGroup(userID.ToString(), Group))
	        {
		        arg.ReplyWith(LanguageEn ? "The player does not have this group!": "У игрока отсутствуют данная группа!");
		        return;
	        }
	        
	        if (arg.Args.Length == 3)
	        {
		        TimeSpan duration;
		        if (!TryParseTimeSpan(arg.Args[2], out duration))
		        {
			        arg.ReplyWith(LanguageEn ? "You specified an incorrect time, use 1d/1m/1s!": "Вы указали неккоректное время, используйте 1d/1m/1s!");
			        return;
		        }
	        
		        DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Group, userID, TypeData.Group) - duration;
		        InformationPrivilagesUser.RemoveParametres(Group, userID, TypeData.Group, ThisTime);
		        return;
	        }

	        InformationPrivilagesUser.RemoveParametres(Group, userID, TypeData.Group);
        }

        [ConsoleCommand("revoke.group")]
        private void RevomeGroup_TwoConsoleCommand(ConsoleSystem.Arg arg) => RemoveGroup_ConsoleCommand(arg);

        [ConsoleCommand("perm.users")]
        private void GetInfoPerm_ConsoleCommand(ConsoleSystem.Arg arg)
        {
	        if (arg == null) return;
	        
	        if(arg.Player() != null)
		        if(!arg.Player().IsAdmin)
			        return;

	        if (arg.Args == null || arg.Args.Length < 1)
	        {
		        arg.ReplyWith(LanguageEn ? "Syntax error, use: perm.users Permission": "Ошибка синтаксиса, используйте : perm.users Permission");
		        return;
	        }
	        
	        String Permission = arg.Args[0];
	        if (!config.PermissionList.ContainsKey(Permission))
	        {
		        arg.ReplyWith(LanguageEn ? "The permission you specified do not exist!": "Права которые вы указали - не существуют!");
		        return;
	        }

	        Dictionary<UInt64, DateTime> GetPlayers = InformationPrivilagesUser.GePlayerList(Permission, TypeData.Permission);
	        String PlayerList = GetPlayers == null ? String.Empty : GetPlayers.Aggregate(String.Empty, (current, Players) => current + $"- ID : {Players.Key} | Expired : {GetLeftTime(Players.Value, Players.Key.ToString())}\n");

	        String Information = LanguageEn ? $"Total with active privileges ({Permission}) found {GetPlayers.Count} players\n{PlayerList}" : $"Всего с активной привилегий ({Permission}) найдено {GetPlayers.Count} игроков\n{PlayerList}";
	        arg.ReplyWith(Information);
        }
        
        [ConsoleCommand("group.users")]
        private void GetInfoGroup_ConsoleCommand(ConsoleSystem.Arg arg)
        {
	        if (arg == null) return;
	        
	        if(arg.Player() != null)
		        if(!arg.Player().IsAdmin)
			        return;

	        if (arg.Args == null || arg.Args.Length < 1)
	        {
		        arg.ReplyWith(LanguageEn ? "Syntax error, use: group.users Group": "Ошибка синтаксиса, используйте : group.users Group");
		        return;
	        }
	        
	        String Group = arg.Args[0];
	        if (!config.GroupList.ContainsKey(Group))
	        {
		        arg.ReplyWith(LanguageEn ? "The group you specified do not exist!": "Группу которую вы указали - не существуют!");
		        return;
	        }

	        Dictionary<UInt64, DateTime> GetPlayers = InformationPrivilagesUser.GePlayerList(Group, TypeData.Group);
	        String PlayerList = GetPlayers == null ? String.Empty : GetPlayers.Aggregate(String.Empty, (current, Players) => current + $"- ID : {Players.Key} | Expired : {GetLeftTime(Players.Value, Players.Key.ToString())}\n");

	        String Information = LanguageEn ? $"Total with active privileges ({Group}) found {GetPlayers.Count} players\n{PlayerList}" : $"Всего с активной привилегий ({Group}) найдено {GetPlayers.Count} игроков\n{PlayerList}";
	        arg.ReplyWith(Information);
        }
        
        [ConsoleCommand("user.perms")]
        private void GetUserPerms_ConsoleCommand(ConsoleSystem.Arg arg)
        {
	        if (arg == null) return;
	        
	        if(arg.Player() != null)
		        if(!arg.Player().IsAdmin)
			        return;

	        if (arg.Args == null || arg.Args.Length < 1)
	        {
		        arg.ReplyWith(LanguageEn ? "Syntax error, use: user.perms Steam64ID": "Ошибка синтаксиса, используйте : user.perms Steam64ID");
		        return;
	        }
	        
	        UInt64 userID;
	        if (!UInt64.TryParse(arg.Args[0], out userID))
	        {
		        arg.ReplyWith(LanguageEn ? "You have specified an incorrect Steam64ID player!": "Вы указали неккоректный Steam64ID игрока!");
		        return;
	        }

	        Dictionary<String, DateTime> GetParametres  = InformationPrivilagesUser.GetParametresUser(userID, TypeData.Permission);
	        String PermsList = GetParametres == null ? String.Empty : GetParametres.Aggregate(String.Empty, (current, keyValuePair) => current + $"- {keyValuePair.Key} | Expired : {keyValuePair.Value}\n");
	        
	        String Information = LanguageEn ? $"Active Player Privileges {userID} ({GetParametres.Count} pieces(/s))\n{PermsList}" : $"Активные привилегии игрока {userID} ({GetParametres.Count} штук(/и))\n{PermsList}";
	        arg.ReplyWith(Information);
        }

        [ConsoleCommand("user.groups")]
        private void GetUserGroups_ConsoleCommand(ConsoleSystem.Arg arg)
        {
	        if (arg == null) return;
	        
	        if(arg.Player() != null)
		        if(!arg.Player().IsAdmin)
			        return;

	        if (arg.Args == null || arg.Args.Length < 1)
	        {
		        arg.ReplyWith(LanguageEn ? "Syntax error, use: user.groups Steam64ID": "Ошибка синтаксиса, используйте : user.groups Steam64ID");
		        return;
	        }
	        
	        UInt64 userID;
	        if (!UInt64.TryParse(arg.Args[0], out userID))
	        {
		        arg.ReplyWith(LanguageEn ? "You have specified an incorrect Steam64ID player!": "Вы указали неккоректный Steam64ID игрока!");
		        return;
	        }

	        Dictionary<String, DateTime> GetParametres  = InformationPrivilagesUser.GetParametresUser(userID, TypeData.Group);
	        String PermsList = GetParametres == null ? String.Empty : GetParametres.Aggregate(String.Empty, (current, keyValuePair) => current + $"- {keyValuePair.Key} | Expired : {keyValuePair.Value}\n");
	        
	        String Information = LanguageEn ? $"Active Player Privileges {userID} ({GetParametres.Count} pieces(/s))\n{PermsList}" : $"Активные привилегии игрока {userID} ({GetParametres.Count} штук(/и))\n{PermsList}";
	        arg.ReplyWith(Information);
        }
        
        #endregion

		#region Interface 

		private void DrawUI_PoopUp(BasePlayer player, TypeAlert typeAlert, String Key, TypeData typeData, String DataExpired)
		{
			if (!IsFullLoaded)
			{
				PrintWarning(LanguageEn ? "The plugin is still being initialized, wait!" : "Плагин еще инициализируется, ожидайте!");
				return;
			}
			
			if (player == null) return;
			String Interface = InterfaceBuilder.GetInterface("UI_POOPUP_TEMPLATE");
            if (Interface == null) return;

            String ReplaceKey = GetLanguageNamePrivilage(player, Key, typeData);
            if (ReplaceKey == null) return;
            
            Configuration.InterfaceConfiguration Interfaces = config.InterfaceSetting;
            
	        Interface = Interface.Replace("%PNGBackground%", ImageUi.GetImage(Interfaces.PNGBackground));
	        Interface = Interface.Replace("%ICON%", GetIcon(typeAlert));
	        Interface = Interface.Replace("%TITLE%", GetLang(GetTitle(typeAlert), player.UserIDString));
	        Interface = Interface.Replace("%DESCRIPTION%", GetDescription(player.UserIDString, typeAlert, ReplaceKey, DataExpired));
	        Interface = Interface.Replace("%COLOR_TITLE%", Interfaces.RGBAColorTitle);
	        Interface = Interface.Replace("%COLOR_DESCRIPTION%", Interfaces.RGBAColorDescription);

	        CuiHelper.DestroyUi(player, InterfaceBuilder.UI_POOPUP_PANEL);
            CuiHelper.AddUi(player, Interface);
            
            player.Invoke(() => CuiHelper.DestroyUi(player, InterfaceBuilder.UI_POOPUP_PANEL), config.AlertConfigurations.TimeAlert);
		}	
		
	    private class InterfaceBuilder
        {
            #region Vars

            public static InterfaceBuilder Instance;
            public const String UI_POOPUP_PANEL = "UI_POOPUP_PANEL";
            public Dictionary<String, String> Interfaces;

            #endregion

            #region Main

            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();

                BuildingPlayer_PopUp();
            }

            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error #3324635! Tried to add existing cui elements! -> {name}"); 
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static String GetInterface(String name)
            {
                String json = String.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
	            foreach (BasePlayer player in BasePlayer.activePlayerList)
		            CuiHelper.DestroyUi(player, UI_POOPUP_PANEL);
            }

            #endregion

            #region Building PoopUp
			private void BuildingPlayer_PopUp()
			{
				CuiElementContainer container = new CuiElementContainer();

				container.Add(new CuiElement
				{
					Name = UI_POOPUP_PANEL,
					Parent = "Overlay",
					Components = {
						new CuiRawImageComponent { Color = "1 1 1 1", Png = "%PNGBackground%" },
						new CuiRectTransformComponent { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-252.6 -135.1", OffsetMax = "7.4 -75.1" }
					}
				});

				container.Add(new CuiElement
				{
					Name = "Icon",
					Parent = UI_POOPUP_PANEL,
					Components = {
						new CuiRawImageComponent { Color = "1 1 1 1", Png = "%ICON%" },
						new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-116.9 -16", OffsetMax = "-84.9 16" }
					}
				});

				container.Add(new CuiElement
				{
					Name = "Title",
					Parent = UI_POOPUP_PANEL,
					Components = {
						new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "%COLOR_TITLE%" },
						new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-84.9 -2.06", OffsetMax = "125.33 19.46" } 
					}
				});

				container.Add(new CuiElement
				{
					Name = "Description",
					Parent = UI_POOPUP_PANEL,
					Components = {
						new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.UpperCenter, Color = "%COLOR_DESCRIPTION%" },
						new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-84.9 -17.67", OffsetMax = "125.33 0" }
					}
				});

				AddInterface("UI_POOPUP_TEMPLATE", container.ToJson());
			}
			#endregion
        }

        #endregion

        #region Utilites

        #region FancyDiscord

        public class FancyMessage
        {
            public String content { get; set; }
            public Boolean tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public String title { get; set; }
                public Int32 color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(String title, Int32 color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(String content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public String toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public String text { get; set; }
            public String icon_url { get; set; }
            public String proxy_icon_url { get; set; }
            public Footer(String text, String icon_url, String proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public String name { get; set; }
            public String url { get; set; }
            public String icon_url { get; set; }
            public String proxy_icon_url { get; set; }
            public Authors(String name, String url, String icon_url, String proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public String name { get; set; }
            public String value { get; set; }
            public bool inline { get; set; }
            public Fields(String name, String value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(String url, String payload, Action<Int32> callback = null)
        {
            Dictionary<String, String> header = new Dictionary<String, String>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                Single seconds = Single.Parse(Math.Ceiling((Double)(Int32)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        
        #endregion
        
        #region TimeParse
        private Boolean TryParseTimeSpan(String source, out TimeSpan timeSpan)
        {
	        Int32 seconds = 0, minutes = 0, hours = 0, days = 0;

	        Match s = new Regex(@"(\d+?)s", RegexOptions.IgnoreCase).Match(source);
	        Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
	        Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
	        Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

	        if (s.Success)
		        seconds = Convert.ToInt32(s.Groups[1].ToString());

	        if (m.Success)
		        minutes = Convert.ToInt32(m.Groups[1].ToString());

	        if (h.Success)
		        hours = Convert.ToInt32(h.Groups[1].ToString());

	        if (d.Success)
		        days = Convert.ToInt32(d.Groups[1].ToString());

	        source = source.Replace(seconds + "s", string.Empty);
	        source = source.Replace(minutes + "m", string.Empty);
	        source = source.Replace(hours + "h", string.Empty);
	        source = source.Replace(days + "d", string.Empty);

	        if (!String.IsNullOrEmpty(source) || (!s.Success && !m.Success && !h.Success && !d.Success))
	        {
		        timeSpan = default(TimeSpan);
		        return false;
	        }

	        timeSpan = new TimeSpan(days, hours, minutes, seconds);

	        return true;
        }

        private String GetLeftTime(DateTime dateExpired, String userID)
        {
	        System.TimeSpan DiffTime = dateExpired.Subtract(DateTime.Now);
	        String LeftTime = _.FormatTime(TimeSpan.FromSeconds(DiffTime.TotalSeconds), userID);

	        return LeftTime;
        }
        public String FormatTime(TimeSpan time, String UserID)
        {
	        String Result = String.Empty;
	        String Days = GetLang("TITLE_FORMAT_DAYS", UserID);
	        String Hourse = GetLang("TITLE_FORMAT_HOURSE", UserID);
	        String Minutes = GetLang("TITLE_FORMAT_MINUTES", UserID);
	        String Seconds = GetLang("TITLE_FORMAT_SECONDS", UserID);

	        if (time.Days != 0)
		        Result += $"{Format(time.Days, Days, Days, Days)} ";

	        if (time.Hours != 0)
		        Result += $"{Format(time.Hours, Hourse, Hourse, Hourse)} ";

	        if (time.Minutes != 0)
		        Result += $"{Format(time.Minutes, Minutes, Minutes, Minutes)} ";
                
	        if (time.Days == 0 && time.Hours == 0 && time.Minutes == 0 && time.Seconds != 0)
		        Result = $"{Format(time.Seconds, Seconds, Seconds, Seconds)} ";

	        return Result;
        }

        private String Format(Int32 units, String form1, String form2, String form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units}{form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units}{form2}";

            return $"{units}{form3}";
        }
        #endregion
        
        private class ImageUi
        {
            private static Coroutine coroutineImg = null;
			private static Dictionary<String, String> Images = new Dictionary<String, String>();

			private static List<String> KeyImages = new List<String>();
			public static void DownloadImages() { coroutineImg = ServerMgr.Instance.StartCoroutine(AddImage()); }

            private static IEnumerator AddImage()
            {
	            if (_ == null)
					yield break;
				_.PrintWarning(LanguageEn ? "Generating the interface, wait ~10-15 seconds!" : "Генерируем интерфейс, ожидайте ~10-15 секунд!");
				foreach (String URL in KeyImages)
				{
					String KeyName = URL;
					if (KeyName == null) throw new ArgumentNullException(nameof(KeyName));

					UnityWebRequest www = UnityWebRequestTexture.GetTexture(URL);
					yield return www.SendWebRequest();

					if (www.isNetworkError || www.isHttpError)
					{
						_.PrintWarning($"Image download error! Error: {www.error}, Image name: {KeyName}");
						www.Dispose();
						coroutineImg = null;
						yield break;
					}

					Texture2D texture = DownloadHandlerTexture.GetContent(www);
					if (texture != null)
					{
						Byte[] bytes = texture.EncodeToPNG();

						String image = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
						if (!Images.ContainsKey(KeyName))
							Images.Add(KeyName, image);
						else
							Images[KeyName] = image;

						UnityEngine.Object.DestroyImmediate(texture);
					}

					www.Dispose();
					yield return CoroutineEx.waitForSeconds(0.02f);
				}

				yield return CoroutineEx.waitForSeconds(0.02f);
                coroutineImg = null;

                _interface = new InterfaceBuilder();
                _.PrintWarning(LanguageEn ? "The interface has loaded successfully!" : "Интерфейс успешно загружен!");
                
                _.InformationPrivilagesUser.SetParametresUnload();
                _.timer.Every(1f, () => _.InformationPrivilagesUser.TrackerExpireds());
                
                _.IsFullLoaded = true;

                _.timer.Every(300f, () => _.WriteData());
            }

            public static String GetImage(String ImgKey) => Images.ContainsKey(ImgKey) ? Images[ImgKey] : _.GetImage("LOADING");

			public static void Initialize()
			{
				KeyImages = new List<String>();
				Images = new Dictionary<String, String>();

				Configuration.InterfaceConfiguration Interface = config.InterfaceSetting;
				
				if (!KeyImages.Contains(Interface.PNGBackground))
                    KeyImages.Add(Interface.PNGBackground);
				
				if (!KeyImages.Contains(Interface.PNGPrivilageAdd))
					KeyImages.Add(Interface.PNGPrivilageAdd);
				
				if (!KeyImages.Contains(Interface.PNGPrivilageAlert))
					KeyImages.Add(Interface.PNGPrivilageAlert);
				
				if (!KeyImages.Contains(Interface.PNGPrivilageExpired))
					KeyImages.Add(Interface.PNGPrivilageExpired);
			}
            public static void Unload()
            {
	            coroutineImg = null;
                foreach (KeyValuePair<String, String> item in Images)
                    FileStorage.server.RemoveExact(UInt32.Parse(item.Value), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID, 0U);

				KeyImages.Clear();
				KeyImages = null;
				Images.Clear();
				Images = null;
			}
        }

        #endregion
        
	    #region Lang

        private static StringBuilder sb = new StringBuilder();
		public String GetLang(String LangKey, String userID = null, params Object[] args)
		{
			sb.Clear();
			if (args == null) return lang.GetMessage(LangKey, this, userID);
			sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
			return sb.ToString();
		}
		private new void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<String, String>
			{
				["TITLE_ALERT_ADD"] = "Privilege received!",
				["TITLE_ALERT_INFO"] = "Privilege expires!",
				["TITLE_ALERT_EXPIRED"] = "Privilege expired!",
				
				["DESCRIPTION_ALERT_EXPIRED"] = "Privilege {0} expired",
				["DESCRIPTION_ALERT_ADD"] = "You have successfully received {0}",
				["DESCRIPTION_ALERT_INFO"] = "{0} ends : {1}",
				["PINFO_ALERT"] = "YourPrivilages :\n{0}",
				["PINFO_ALERT_NOT"] = "You don't have privileges",
				
				["TITLE_FORMAT_DAYS"] = "D",
				["TITLE_FORMAT_HOURSE"] = "H",
				["TITLE_FORMAT_MINUTES"] = "M",
				["TITLE_FORMAT_SECONDS"] = "S",


			}, this);
			lang.RegisterMessages(new Dictionary<String, String>
			{
				["TITLE_ALERT_ADD"] = "Привилегия получена!",
				["TITLE_ALERT_INFO"] = "Привилегия истекает!",
				["TITLE_ALERT_EXPIRED"] = "Привилегия истекла!",
				
				["DESCRIPTION_ALERT_EXPIRED"] = "Привилегия {0} истекла",
				["DESCRIPTION_ALERT_ADD"] = "Вы успешно получили {0}",
				["DESCRIPTION_ALERT_INFO"] = "{0} кончается : {1}",
				["PINFO_ALERT"] = "Ваши привилегии :\n{0}",
				["PINFO_ALERT_NOT"] = "У вас нет привилегий",
				
				["TITLE_FORMAT_DAYS"] = "Д",
				["TITLE_FORMAT_HOURSE"] = "Ч",
				["TITLE_FORMAT_MINUTES"] = "М",
				["TITLE_FORMAT_SECONDS"] = "С",

			}, this, "ru");
		}
		#endregion

		#region MigrationOldPlugins
		
		private static Coroutine coroutineMigration = null;

		#region TimedPermissions

		private IEnumerator MigrationTimedPermissions()
		{
			if (!Interface.Oxide.DataFileSystem.ExistsDatafile("TimedPermissions"))
			{
				Puts(LanguageEn ? "TimedPermissions file - does not exist, migration is not possible" : "Файла TimedPermissions - не существует, миграция невозможна");
				yield break;
			}
			Puts(LanguageEn ? "Starting the migration from the plugin TimedPermissions -> IQPermissions (This may take some time, depending on the number of entries)" : "Запускаем миграцию из плагина TimedPermissions -> IQPermissions (Это может занять некоторое время, в зависимости от количество записей)");
			List<PlayerInformation> dataFile = Interface.Oxide.DataFileSystem.ReadObject<List<PlayerInformation>>("TimedPermissions");

			foreach (PlayerInformation playerInformation in dataFile)
			{
				UInt64 userID;
				if(!UInt64.TryParse(playerInformation.Id, out userID))
					continue;

				foreach (ExpiringAccessValue informationPermission in playerInformation._permissions.Where(x =>
					         !x.IsExpired))
				{
					InformationPrivilagesUser.SetParametres(informationPermission.Value, userID,
						informationPermission.ExpireDate, TypeData.Permission);
					
					yield return CoroutineEx.waitForSeconds(0.15f);
				}

				foreach (ExpiringAccessValue playerInformationGroup in playerInformation._groups.Where(x =>
					         !x.IsExpired))
				{
					InformationPrivilagesUser.SetParametres(playerInformationGroup.Value, userID, playerInformationGroup.ExpireDate, TypeData.Group);
					
					yield return CoroutineEx.waitForSeconds(0.15f);
				}
				
				yield return CoroutineEx.waitForSeconds(0.25f);
			}

			Interface.Oxide.UnloadPlugin("TimedPermissions");
			Puts(LanguageEn ? "Migration is complete, TimedPermissions has been unloaded! (Don't forget to remove the TimedPermissions for stable operation)" : "Миграция завершена, TimedPermissions был выгружен! (Не забудьте удалить TimedPermissions для стабильной работы)");
			
			if (coroutineMigration != null)
			{
				ServerMgr.Instance.StopCoroutine(coroutineMigration);
				coroutineMigration = null;
			}
		}

		#region StructureTimedPermissions
		
		private class PlayerInformation
		{
			[JsonProperty("Id")]
			public string Id { get; set; }

			[JsonProperty("Name")]
			public string Name { get; set; }

			[JsonProperty("Permissions")]
			public List<ExpiringAccessValue> _permissions = new List<ExpiringAccessValue>();

			[JsonProperty("Groups")]
			public List<ExpiringAccessValue> _groups = new List<ExpiringAccessValue>();
		}
		private class ExpiringAccessValue
		{
			[JsonProperty]
			public string Value { get; private set; }

			[JsonProperty]
			public DateTime ExpireDate { get; set; }

			[JsonIgnore]
			public bool IsExpired => DateTime.Compare(DateTime.UtcNow, ExpireDate) > 0;
			
		}
		#endregion
		
		#endregion

		#region Grant
		
		private static Int64 ToEpochTime(DateTime dateTime)
		{
			DateTime date = dateTime.ToLocalTime();
			Int64 ticks = date.Ticks - new DateTime(1970, 1, 1, 0, 0, 0, 0).Ticks;
			Int64 ts = ticks / TimeSpan.TicksPerSecond;
			return ts;
		}
		
		private IEnumerator MigrationGrant()
		{
			if (!Interface.Oxide.DataFileSystem.ExistsDatafile("GrantData"))
			{
				Puts(LanguageEn ? "GrantData file - does not exist, migration is not possible" : "Файла GrantData - не существует, миграция невозможна");
				yield break;
			}
			Puts(LanguageEn ? "Starting the migration from the plugin Grant -> IQPermissions (This may take some time, depending on the number of entries)" : "Запускаем миграцию из плагина Grant -> IQPermissions (Это может занять некоторое время, в зависимости от количество записей)");
			GrantData dataFile = Interface.Oxide.DataFileSystem.ReadObject<GrantData>("GrantData");

			Int64 curDt = ToEpochTime(DateTime.Now);

			foreach (KeyValuePair<String,Dictionary<String, Int64>> Permissions in dataFile.Permission.Where(x => x.Value.Count != 0))
			{
					UInt64 userID;
					if(!UInt64.TryParse(Permissions.Key, out userID))
						continue;
					
					foreach (KeyValuePair<String, Int64> PermissionsUser in Permissions.Value.Where(PermissionsUser => PermissionsUser.Value - curDt > 0))
					{
						Int32 TotalSeconds = (Int32)(PermissionsUser.Value - curDt);
						DateTime time = DateTime.Now.AddSeconds(TotalSeconds);
			
						InformationPrivilagesUser.SetParametres(PermissionsUser.Key, userID,
							time, TypeData.Permission);
						yield return CoroutineEx.waitForSeconds(0.15f);
					}
					yield return CoroutineEx.waitForSeconds(0.25f);
			}
			
			foreach (KeyValuePair<String,Dictionary<String, Int64>> Groups in dataFile.Group.Where(x => x.Value.Count != 0))
			{
				UInt64 userID;
				if(!UInt64.TryParse(Groups.Key, out userID))
					continue;
					
				foreach (KeyValuePair<String, Int64> GroupsUser in Groups.Value.Where(GroupsUser => GroupsUser.Value - curDt > 0))
				{
					Int32 TotalSeconds = (Int32)(GroupsUser.Value - curDt);
					DateTime time = DateTime.Now.AddSeconds(TotalSeconds);
					
					InformationPrivilagesUser.SetParametres(GroupsUser.Key, userID,
						time, TypeData.Group);
					
					yield return CoroutineEx.waitForSeconds(0.15f);
				}
				yield return CoroutineEx.waitForSeconds(0.25f);
			}

			Interface.Oxide.UnloadPlugin("Grant");
			Puts(LanguageEn ? "Migration is complete, Grant has been unloaded! (Don't forget to remove the Grant for stable operation)" : "Миграция завершена, Grant был выгружен! (Не забудьте удалить Grant для стабильной работы)");

			if (coroutineMigration != null)
			{
				ServerMgr.Instance.StopCoroutine(coroutineMigration);
				coroutineMigration = null;
			}
		}
		
		#region StructureGrant

		public class GrantData
		{
			public Dictionary<String, Dictionary<String, Int64>> Group = new Dictionary<String, Dictionary<String, Int64>>();
			public Dictionary<String, Dictionary<String, Int64>> Permission = new Dictionary<String, Dictionary<String, Int64>>();						
		}

		#endregion
		
		#endregion

		#region TimedPrivilage

		private IEnumerator MigrationTimePrivilage()
		{
			if (!Interface.Oxide.DataFileSystem.ExistsDatafile("Timeprivileges"))
			{
				Puts(LanguageEn ? "Timeprivileges file - does not exist, migration is not possible" : "Файла Timeprivileges - не существует, миграция невозможна");
				yield break;
			}
			Puts(LanguageEn ? "Starting the migration from the plugin TimePrivilage -> IQPermissions (This may take some time, depending on the number of entries)" : "Запускаем миграцию из плагина TimePrivilage -> IQPermissions (Это может занять некоторое время, в зависимости от количество записей)");
			Dictionary<String, StructureTimePrivilage> dataFile = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<String, StructureTimePrivilage>>("Timeprivileges");

			foreach (KeyValuePair<String,StructureTimePrivilage> timePrivilage in dataFile)
			{
				UInt64 userID;
				if (!UInt64.TryParse(timePrivilage.Key, out userID))
					continue;

				foreach (KeyValuePair<String, String> Permissions in timePrivilage.Value.permissions)
				{
					DateTime Time = Convert.ToDateTime(Permissions.Value);
					
					InformationPrivilagesUser.SetParametres(Permissions.Key, userID, Time, TypeData.Permission);
					yield return CoroutineEx.waitForSeconds(0.15f);
				}
				
				foreach (KeyValuePair<String, String> Groups in timePrivilage.Value.groups)
				{
					DateTime Time = Convert.ToDateTime(Groups.Value);
					
					InformationPrivilagesUser.SetParametres(Groups.Key, userID, Time, TypeData.Group);
					yield return CoroutineEx.waitForSeconds(0.15f);
				}
				
				yield return CoroutineEx.waitForSeconds(0.25f);
			}
		
			Interface.Oxide.UnloadPlugin("TimePrivilage");
			Puts(LanguageEn ? "Migration is complete, TimePrivilege has been unloaded! (Don't forget to remove the TimePrivilage for stable operation)" : "Миграция завершена, TimePrivilage был выгружен! (Не забудьте удалить TimePrivilage для стабильной работы)");

			if (coroutineMigration != null)
			{
				ServerMgr.Instance.StopCoroutine(coroutineMigration);
				coroutineMigration = null;
			}
		}
		
		#region StructureTimePrivilage

		class StructureTimePrivilage
		{
			public Dictionary<String, String> groups = new Dictionary<String, String>();
			public Dictionary<String, String> permissions = new Dictionary<String, String>();
		}

		#endregion

		#endregion

		#endregion

		#region API
		
		public Dictionary<String, DateTime> GetPermissions(UInt64 userID) => InformationPrivilagesUser.GetParametresUser(userID, TypeData.Permission);
		public Dictionary<String, DateTime> GetGroups(UInt64 userID) => InformationPrivilagesUser.GetParametresUser(userID, TypeData.Group);

		public void SetPermission(UInt64 userID, String Permission, DateTime DataExpired) =>
			InformationPrivilagesUser.SetParametres(Permission, userID, DataExpired, TypeData.Permission);
		
		public void SetPermission(UInt64 userID, String Permission, String DataExpired)
		{
			TimeSpan duration;
			if (!TryParseTimeSpan(DataExpired, out duration))
			{
				PrintError(LanguageEn ? "API : You specified an incorrect time, use 1d/1m/1s!": "API : Вы указали неккоректное время, используйте 1d/1m/1s!");
				return;
			}
	        
			DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Permission, userID, TypeData.Permission) + duration;
			InformationPrivilagesUser.SetParametres(Permission, userID, ThisTime, TypeData.Permission);
		}
		
		public void SetGroup(UInt64 userID, String Group, DateTime DataExpired) =>
			InformationPrivilagesUser.SetParametres(Group, userID, DataExpired, TypeData.Group);

		public void SetGroup(UInt64 userID, String Group, String DataExpired)
		{
			TimeSpan duration;
			if (!TryParseTimeSpan(DataExpired, out duration))
			{
				PrintError(LanguageEn ? "API : You specified an incorrect time, use 1d/1m/1s!": "API : Вы указали неккоректное время, используйте 1d/1m/1s!");
				return;
			}
	        
			DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Group, userID, TypeData.Group) + duration;
			InformationPrivilagesUser.SetParametres(Group, userID, ThisTime, TypeData.Group);
		}
		
		public void RevokePermission(UInt64 userID, String Permission, DateTime DataExpired = default(DateTime)) =>
			InformationPrivilagesUser.RemoveParametres(Permission, userID, TypeData.Permission, DataExpired);

		public void RevokePermission(UInt64 userID, String Permission, String DataExpired = null)
		{
			if (DataExpired != null)
			{
				TimeSpan duration;
				if (!TryParseTimeSpan(DataExpired, out duration))
				{
					PrintError(LanguageEn ? "API : You specified an incorrect time, use 1d/1m/1s!": "API : Вы указали неккоректное время, используйте 1d/1m/1s!");
					return;
				}
	        
				DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Permission, userID, TypeData.Permission) - duration;
				InformationPrivilagesUser.RemoveParametres(Permission, userID, TypeData.Permission, ThisTime);
				return;
			}
			
			InformationPrivilagesUser.RemoveParametres(Permission, userID,TypeData.Permission);
		}
		
		public void RevokeGroup(UInt64 userID, String Group, DateTime DataExpired = default(DateTime)) =>
			InformationPrivilagesUser.RemoveParametres(Group, userID, TypeData.Group, DataExpired);

		public void RevokeGroup(UInt64 userID, String Group, String DataExpired = null)
		{
			if (DataExpired != null)
			{
				TimeSpan duration;
				if (!TryParseTimeSpan(DataExpired, out duration))
				{
					PrintError(LanguageEn ? "API : You specified an incorrect time, use 1d/1m/1s!": "API : Вы указали неккоректное время, используйте 1d/1m/1s!");
					return;
				}
	        
				DateTime ThisTime = InformationPrivilagesUser.GetExpiredPermissionData(Group, userID, TypeData.Group) - duration;
				InformationPrivilagesUser.RemoveParametres(Group, userID, TypeData.Group, ThisTime);
				return;
			}
			
			InformationPrivilagesUser.RemoveParametres(Group, userID,TypeData.Group);
		}
		
		#endregion
	}
}

// --- End of file: IQPermissions.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NTeleportation.cs ---
// --- Original Local Path: NTeleportation.cs ---

//#define DEBUG
using Facepunch;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NTeleportation", "nivex", "1.7.8")]
    [Description("Multiple teleportation systems for admin and players")]
    class NTeleportation : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, Economics, IQEconomic, ServerRewards, Friends, CompoundTeleport, ZoneManager, NoEscape, PopupNotifications, BlockUsers;

        private Dictionary<string, BasePlayer> _ids = new Dictionary<string, BasePlayer>();
        private Dictionary<BasePlayer, string> _players = new Dictionary<BasePlayer, string>();

        private bool newSave;
        private const string NewLine = "\n";
        private const string TPA = "tpa";
        private static readonly string[] nullArg = { };
        private const string PermAdmin = "nteleportation.admin";
        private const string PermRestrictions = "nteleportation.norestrictions";
        private const string ConfigDefaultPermVip = "nteleportation.vip";
        private const string PermHome = "nteleportation.home";
        private const string PermWipeHomes = "nteleportation.wipehomes";
        private const string PermCraftHome = "nteleportation.crafthome";
        private const string PermDeleteHome = "nteleportation.deletehome";
        private const string PermHomeHomes = "nteleportation.homehomes";
        private const string PermImportHomes = "nteleportation.importhomes";
        private const string PermRadiusHome = "nteleportation.radiushome";
        private const string PermCraftTpR = "nteleportation.crafttpr";
        private const string PermTpR = "nteleportation.tpr";
        private const string PermTpA = "nteleportation.tpa";
        private const string PermTp = "nteleportation.tp";
        private const string PermDisallowTpToMe = "nteleportation.disallowtptome";
        private const string PermTpT = "nteleportation.tpt";
        private const string PermTpB = "nteleportation.tpb";
        private const string PermTpN = "nteleportation.tpn";
        private const string PermTpL = "nteleportation.tpl";
        private const string PermTpConsole = "nteleportation.tpconsole";
        private const string PermTpRemove = "nteleportation.tpremove";
        private const string PermTpSave = "nteleportation.tpsave";
        private const string PermExempt = "nteleportation.exemptfrominterruptcountdown";
        private const string PermFoundationCheck = "nteleportation.bypassfoundationcheck";
        private const string PermTpMarker = "nteleportation.tpmarker";
        private DynamicConfigFile dataConvert;
        private DynamicConfigFile dataDisabled;
        private DynamicConfigFile dataAdmin;
        private DynamicConfigFile dataHome;
        private DynamicConfigFile dataTPR;
        private DynamicConfigFile dataTPT;
        private Dictionary<ulong, AdminData> _Admin;
        private Dictionary<ulong, HomeData> _Home;
        private Dictionary<ulong, TeleportData> _TPR;
        private Dictionary<string, List<string>> TPT = new Dictionary<string, List<string>>();
        private bool changedAdmin;
        private bool changedHome;
        private bool changedTPR;
        private bool changedTPT;
        private float boundary;
        private readonly Dictionary<ulong, float> TeleportCooldowns = new Dictionary<ulong, float>();
        private readonly Dictionary<ulong, TeleportTimer> TeleportTimers = new Dictionary<ulong, TeleportTimer>();
        private readonly Dictionary<ulong, Timer> PendingRequests = new Dictionary<ulong, Timer>();
        private readonly Dictionary<ulong, BasePlayer> PlayersRequests = new Dictionary<ulong, BasePlayer>();
        private readonly Dictionary<int, string> ReverseBlockedItems = new Dictionary<int, string>();
        private readonly Dictionary<ulong, Vector3> teleporting = new Dictionary<ulong, Vector3>();
        private SortedDictionary<string, Vector3> caves = new SortedDictionary<string, Vector3>();
        private List<MonumentInfoEx> monuments = new List<MonumentInfoEx>();
        private bool outpostEnabled;
        private bool banditEnabled;

        private class MonumentInfoEx
        {
            public MonumentInfo monument;
            public Vector3 position;
            public float radius;
            public string name;
            public string prefab;
            public MonumentInfoEx() { }
            public MonumentInfoEx(MonumentInfo monument, Vector3 position, float radius, string name, string prefab)
            {
                this.monument = monument;
                this.position = position;
                this.radius = radius;
                this.name = name;
                this.prefab = prefab;
            }
            public bool IsInBounds(Vector3 target)
            {
                return monument != null && monument.transform.position.y < 0f && TerrainMeta.HeightMap.GetHeight(target) < 0f && monument.IsInBounds(target);
            }
        }

        #region Configuration

        private static Configuration config;

        public class InterruptSettings
        {
            [JsonProperty(PropertyName = "Interrupt Teleport At Specific Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Monuments { get; set; } = new List<string>();

            [JsonProperty(PropertyName = "Above Water")]
            public bool AboveWater { get; set; } = true;

            [JsonProperty(PropertyName = "Under Water")]
            public bool UnderWater { get; set; }

            [JsonProperty(PropertyName = "Balloon")]
            public bool Balloon { get; set; } = true;

            [JsonProperty(PropertyName = "Boats")]
            public bool Boats { get; set; }

            [JsonProperty(PropertyName = "Cargo Ship")]
            public bool Cargo { get; set; } = true;

            [JsonProperty(PropertyName = "Cold")]
            public bool Cold { get; set; } = false;

            [JsonProperty(PropertyName = "Excavator")]
            public bool Excavator { get; set; } = false;

            [JsonProperty(PropertyName = "Hot")]
            public bool Hot { get; set; } = false;

            [JsonProperty(PropertyName = "Hostile")]
            public bool Hostile { get; set; } = false;

            [JsonProperty(PropertyName = "Hurt")]
            public bool Hurt { get; set; } = true;

            [JsonProperty(PropertyName = "Junkpiles")]
            public bool Junkpiles { get; set; }

            [JsonProperty(PropertyName = "Lift")]
            public bool Lift { get; set; } = true;

            [JsonProperty(PropertyName = "Monument")]
            public bool Monument { get; set; } = false;

            [JsonProperty(PropertyName = "Ignore Monument Marker Prefab")]
            public bool BypassMonumentMarker { get; set; } = false;

            [JsonProperty(PropertyName = "Mounted")]
            public bool Mounted { get; set; } = true;

            [JsonProperty(PropertyName = "Oil Rig")]
            public bool Oilrig { get; set; } = false;

            [JsonProperty(PropertyName = "Safe Zone")]
            public bool Safe { get; set; } = true;

            [JsonProperty(PropertyName = "Swimming")]
            public bool Swimming { get; set; } = false;
        }

        private object OnPlayerRespawn(BasePlayer player)
        {
            if (player == null) return null;

            var settings = GetSettings("outpost");

            if (settings == null || settings.Location == Vector3.zero) return null;

            if (player.State.unHostileTimestamp > TimeEx.currentTimestamp)
            {
                player.State.unHostileTimestamp = TimeEx.currentTimestamp;
                player.DirtyPlayerState();
                player.ClientRPCPlayer(null, player, "SetHostileLength", 0f);
            }

            if (player.unHostileTime > UnityEngine.Time.realtimeSinceStartup)
            {
                player.unHostileTime = UnityEngine.Time.realtimeSinceStartup;
            }

            return new BasePlayer.SpawnPoint { pos = settings.Location, rot = Quaternion.identity };
        }

        public class PluginSettings
        {
            [JsonProperty(PropertyName = "Delay Saving Data On Server Save")]
            public double SaveDelay { get; set; } = 4.0;

            [JsonProperty("TPB")]
            public TPBSettings TPB = new TPBSettings();

            [JsonProperty(PropertyName = "Interrupt TP")]
            public InterruptSettings Interrupt { get; set; } = new InterruptSettings();

            [JsonProperty(PropertyName = "Auto Wake Up After Teleport")]
            public bool AutoWakeUp { get; set; }

            [JsonProperty(PropertyName = "Respawn Players At Outpost")]
            public bool RespawnOutpost { get; set; }

            [JsonProperty(PropertyName = "Block Teleport (NoEscape)")]
            public bool BlockNoEscape { get; set; } = false;

            [JsonProperty(PropertyName = "Block Teleport (ZoneManager)")]
            public bool BlockZoneFlag { get; set; } = false;

            [JsonProperty(PropertyName = "Chat Name")]
            public string ChatName { get; set; } = "<color=red>Teleportation</color> \n\n";

            [JsonProperty(PropertyName = "Chat Steam64ID")]
            public ulong ChatID { get; set; } = 76561199056025689;

            [JsonProperty(PropertyName = "Check Boundaries On Teleport X Y Z")]
            public bool CheckBoundaries { get; set; } = true;

            [JsonProperty(PropertyName = "Check Boundaries Min Height")]
            public float BoundaryMin { get; set; } = -100f;

            [JsonProperty(PropertyName = "Check Boundaries Max Height")]
            public float BoundaryMax { get; set; } = 2000f;

            [JsonProperty(PropertyName = "Check If Inside Rock")]
            public bool Rock { get; set; } = true;

            [JsonProperty(PropertyName = "Height To Prevent Teleporting To/From (0 = disabled)")]
            public float ForcedBoundary { get; set; }

            [JsonProperty(PropertyName = "Data File Directory (Blank = Default)")]
            public string DataFileFolder { get; set; } = string.Empty;

            [JsonProperty(PropertyName = "Draw Sphere On Set Home")]
            public bool DrawHomeSphere { get; set; } = true;

            [JsonProperty(PropertyName = "Homes Enabled")]
            public bool HomesEnabled { get; set; } = true;

            [JsonProperty(PropertyName = "TPR Enabled")]
            public bool TPREnabled { get; set; } = true;

            [JsonProperty(PropertyName = "Strict Foundation Check")]
            public bool StrictFoundationCheck { get; set; } = false;

            [JsonProperty(PropertyName = "Minimum Temp")]
            public float MinimumTemp { get; set; } = 0f;

            [JsonProperty(PropertyName = "Maximum Temp")]
            public float MaximumTemp { get; set; } = 40f;

            [JsonProperty(PropertyName = "Blocked Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, string> BlockedItems { get; set; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty(PropertyName = "Bypass CMD")]
            public string BypassCMD { get; set; } = "pay";

            [JsonProperty(PropertyName = "Use Economics")]
            public bool UseEconomics { get; set; } = false;

            [JsonProperty(PropertyName = "Use Server Rewards")]
            public bool UseServerRewards { get; set; } = false;

            [JsonProperty(PropertyName = "Wipe On Upgrade Or Change")]
            public bool WipeOnUpgradeOrChange { get; set; } = true;

            [JsonProperty(PropertyName = "Auto Generate Outpost Location")]
            public bool AutoGenOutpost { get; set; } = true;

            [JsonProperty(PropertyName = "Outpost Map Prefab", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Outpost { get; set; } = new List<string> { "outpost", "compound" };

            [JsonProperty(PropertyName = "Auto Generate Bandit Location")]
            public bool AutoGenBandit { get; set; } = true;

            [JsonProperty(PropertyName = "Bandit Map Prefab", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Bandit { get; set; } = new List<string> { "bandit_town" };

            [JsonProperty(PropertyName = "Show Time As Seconds Instead")]
            public bool UseSeconds { get; set; } = false;

            [JsonProperty(PropertyName = "Use Quick Teleport")]
            public bool Quick { get; set; } = true;

            [JsonProperty(PropertyName = "Chat Command Color")]
            public string ChatCommandColor = "#FFFF00";

            [JsonProperty(PropertyName = "Chat Command Argument Color")]
            public string ChatCommandArgumentColor = "#FFA500";

            [JsonProperty("Enable Popup Support")]
            public bool UsePopup = false;

            [JsonProperty("Send Messages To Player")]
            public bool SendMessages = true;

            [JsonProperty("Block All Teleporting From Inside Authorized Base")]
            public bool BlockAuthorizedTeleporting = false;

            [JsonProperty("Global Teleport Cooldown")]
            public float Global = 0f;

            [JsonProperty("Global VIP Teleport Cooldown")]
            public float GlobalVIP = 0f;

            [JsonProperty("Play Sounds Before Teleport")]
            public bool PlaySoundsBeforeTeleport = true;

            [JsonProperty("Sound Effects Before Teleport", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> DisappearEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/disappear.prefab"
            };

            [JsonProperty("Play Sounds After Teleport")]
            public bool PlaySoundsAfterTeleport = true;

            [JsonProperty("Sound Effects After Teleport", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> ReappearEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/appear.prefab"
            };
        }

        public class TPBSettings
        {
            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> Countdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 0 } };

            [JsonProperty("Countdown")]
            public int Countdown = 0;

            [JsonProperty("Available After X Seconds")]
            public int Time = 0;
        }

        public class AdminSettings
        {
            [JsonProperty(PropertyName = "Announce Teleport To Target")]
            public bool AnnounceTeleportToTarget { get; set; } = false;

            [JsonProperty(PropertyName = "Usable By Admins")]
            public bool UseableByAdmins { get; set; } = true;

            [JsonProperty(PropertyName = "Usable By Moderators")]
            public bool UseableByModerators { get; set; } = true;

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Teleport Near Default Distance")]
            public int TeleportNearDefaultDistance { get; set; } = 30;

            [JsonProperty(PropertyName = "Extra Distance To Block Monument Teleporting")]
            public int ExtraMonumentDistance { get; set; }
        }

        public class HomesSettings
        {
            [JsonProperty(PropertyName = "Homes Limit")]
            public int HomesLimit { get; set; } = 2;

            [JsonProperty(PropertyName = "VIP Homes Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPHomesLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Allow Sethome At Specific Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> AllowedMonuments { get; set; } = new List<string> { "HQM Quarry", "Stone Quarry", "Sulfur Quarry", "Ice Lake", "Wild Swamp" };

            [JsonProperty(PropertyName = "Allow Sethome At All Monuments")]
            public bool AllowAtAllMonuments { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Sethome On Tugboats")]
            public bool AllowTugboats { get; set; } = true;

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location Radius")]
            public int LocationRadius { get; set; } = 25;

            [JsonProperty(PropertyName = "Force On Top Of Foundation")]
            public bool ForceOnTopOfFoundation { get; set; } = true;

            [JsonProperty(PropertyName = "Check Foundation For Owner")]
            public bool CheckFoundationForOwner { get; set; } = true;

            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; } = true;

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; } = true;

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable From Safe Zone Only")]
            public bool UsableFromSafeZoneOnly { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Iceberg")]
            public bool AllowIceberg { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Above Foundation")]
            public bool AllowAboveFoundation { get; set; } = true;

            [JsonProperty(PropertyName = "Check If Home Is Valid On Listhomes")]
            public bool CheckValidOnList { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;
        }

        public class TPTSettings
        {
            [JsonProperty(PropertyName = "Use Friends")]
            public bool UseFriends { get; set; }

            [JsonProperty(PropertyName = "Use Clans")]
            public bool UseClans { get; set; }

            [JsonProperty(PropertyName = "Use Teams")]
            public bool UseTeams { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }
            [JsonProperty(PropertyName = "Enabled Color")]
            public string EnabledColor { get; set; } = "green";

            [JsonProperty(PropertyName = "Disabled Color")]
            public string DisabledColor { get; set; } = "red";
        }

        // Added `TPR => Play Sounds To Request Target` (false)
        // Added `TPR => Play Sounds When Target Accepts` (false)

        public class TPRSettings
        {
            [JsonProperty("Play Sounds To Request Target")]
            public bool PlaySoundsToRequestTarget;

            [JsonProperty("Teleport Request Sound Effects", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> TeleportRequestEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/disappear.prefab"
            };

            [JsonProperty("Play Sounds When Target Accepts")]
            public bool PlaySoundsWhenTargetAccepts;

            [JsonProperty("Teleport Accept Sound Effects", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> TeleportAcceptEffects = new List<string>
            {
                "assets/prefabs/missions/portal/proceduraldungeon/effects/appear.prefab"
            };

            [JsonProperty(PropertyName = "Require Player To Be Friend, Clan Mate, Or Team Mate")]
            public bool UseClans_Friends_Teams { get; set; }

            [JsonProperty(PropertyName = "Require nteleportation.tpa to accept TPR requests")]
            public bool RequireTPAPermission { get; set; }

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Use Blocked Users")]
            public bool UseBlockedUsers { get; set; } = false;

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Enable Request UI")]
            public bool UI { get; set; }

            [JsonProperty(PropertyName = "Request Duration")]
            public int RequestDuration { get; set; } = 30;

            [JsonProperty(PropertyName = "Block TPA On Ceiling")]
            public bool BlockTPAOnCeiling { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Usable Into Building Blocked")]
            public bool UsableIntoBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Cupboard Owner When Building Blocked")]
            public bool CupOwnerAllowOnBuildingBlocked { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;
        }

        public class TownSettings
        {
            [JsonProperty(PropertyName = "Command Enabled")]
            public bool Enabled { get; set; } = true;

            [JsonProperty(PropertyName = "Set Position From Monument Marker Name")]
            public string MonumentMarkerName { get; set; } = "";

            [JsonProperty(PropertyName = "Set Position From Monument Marker Name Offset")]
            public string MonumentMarkerNameOffset { get; set; } = "0 0 0";

            [JsonProperty(PropertyName = "Allow TPB")]
            public bool AllowTPB { get; set; } = true;

            [JsonProperty(PropertyName = "Allow Cave")]
            public bool AllowCave { get; set; }

            [JsonProperty(PropertyName = "Cooldown")]
            public int Cooldown { get; set; } = 600;

            [JsonProperty(PropertyName = "Countdown")]
            public int Countdown { get; set; } = 15;

            [JsonProperty(PropertyName = "Daily Limit")]
            public int DailyLimit { get; set; } = 5;

            [JsonProperty(PropertyName = "VIP Daily Limits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPDailyLimits { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCooldowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "VIP Countdowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> VIPCountdowns { get; set; } = new Dictionary<string, int> { { ConfigDefaultPermVip, 5 } };

            [JsonProperty(PropertyName = "Location")]
            public Vector3 Location { get; set; } = Vector3.zero;

            [JsonProperty(PropertyName = "Locations", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<Vector3> Locations { get; set; } = new List<Vector3>();

            [JsonProperty(PropertyName = "Teleport To Random Location")]
            public bool Random { get; set; } = true;

            [JsonProperty(PropertyName = "Usable Out Of Building Blocked")]
            public bool UsableOutOfBuildingBlocked { get; set; } = false;

            [JsonProperty(PropertyName = "Allow Crafting")]
            public bool AllowCraft { get; set; } = false;

            [JsonProperty(PropertyName = "Pay")]
            public int Pay { get; set; } = 0;

            [JsonProperty(PropertyName = "Bypass")]
            public int Bypass { get; set; } = 0;

            [JsonProperty(PropertyName = "Hours Before Useable After Wipe")]
            public double Hours { get; set; } = 0;

            public bool CanCraft(BasePlayer player, string command)
            {
                return AllowCraft || player.IPlayer.HasPermission($"nteleportation.craft{command}");
            }

            [JsonIgnore]
            public StoredData Teleports = new StoredData();

            [JsonIgnore]
            public string Command { get; set; }
        }

        private class Configuration
        {
            [JsonProperty(PropertyName = "Settings")]
            public PluginSettings Settings = new PluginSettings();

            [JsonProperty(PropertyName = "Admin")]
            public AdminSettings Admin = new AdminSettings();

            [JsonProperty(PropertyName = "Home")]
            public HomesSettings Home = new HomesSettings();

            [JsonProperty(PropertyName = "TPT")]
            public TPTSettings TPT = new TPTSettings();

            [JsonProperty(PropertyName = "TPR")]
            public TPRSettings TPR = new TPRSettings();

            [JsonProperty(PropertyName = "Dynamic Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, TownSettings> DynamicCommands { get; set; } = DefaultCommands;
        }

        private static Dictionary<string, TownSettings> DefaultCommands = new Dictionary<string, TownSettings>
        {
            ["Town"] = new TownSettings() { Random = false },
            ["Island"] = new TownSettings() { AllowTPB = false },
            ["Outpost"] = new TownSettings(),
            ["Bandit"] = new TownSettings(),
        };

        public void InitializeDynamicCommands()
        {
            foreach (var entry in config.DynamicCommands)
            {
                if (!entry.Value.Enabled)
                {
                    continue;
                }
                else if (entry.Key.Equals("bandit", StringComparison.OrdinalIgnoreCase))
                {
                    if (CompoundTeleport == null || Convert.ToBoolean(CompoundTeleport?.Call("umodversion")))
                    {
                        banditEnabled = true;
                    }
                    else continue;
                }
                else if (entry.Key.Equals("outpost", StringComparison.OrdinalIgnoreCase))
                {
                    if (CompoundTeleport == null || Convert.ToBoolean(CompoundTeleport?.Call("umodversion")))
                    {
                        outpostEnabled = true;
                    }
                    else continue;
                }

                entry.Value.Command = entry.Key;
                RegisterCommand(entry.Key, nameof(CommandCustom));
            }

            RegisterCommand("ntp", nameof(CommandDynamic));
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Config.Settings.Converters = new JsonConverter[] { new UnityVector3Converter() };
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (JsonException ex)
            {
                Debug.LogException(ex);
                LoadDefaultConfig();
            }
            config.Settings.ReappearEffects.Remove("");
            config.Settings.DisappearEffects.Remove("");
            config.TPR.TeleportRequestEffects.Remove("");
            config.TPR.TeleportAcceptEffects.Remove("");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
            Puts("Loaded default configuration.");
        }

        #endregion

        private class DisabledData
        {
            [JsonProperty("List of disabled commands")]
            public List<string> DisabledCommands = new List<string>();

            public DisabledData() { }
        }

        DisabledData DisabledCommandData = new DisabledData();

        private class AdminData
        {
            [JsonProperty("pl")]
            public Vector3 PreviousLocation { get; set; }

            [JsonProperty("b")]
            public bool BuildingBlocked { get; set; }

            [JsonProperty("c")]
            public bool AllowCrafting { get; set; }

            [JsonProperty("l")]
            public Dictionary<string, Vector3> Locations { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);
        }

        private class HomeData
        {
            public class Entry
            {
                public Vector3 Position;
                public BaseNetworkable Entity;
                public bool isEntity => Entity.IsValid() && !Entity.IsDestroyed;
                public bool wasEntity;
                public Entry() { }
                public Entry(Vector3 Position)
                {
                    this.Position = Position;
                }
                public Vector3 Get()
                {
                    if (isEntity)
                    {
                        return Entity.transform.position + Position;
                    }
                    return Position;
                }
            }

            public class Boat
            {
                public ulong Value;
                public Vector3 Offset;
                public Boat() { }
                public Boat(Entry entry)
                {
                    Offset = entry.Position;
                    Value = entry.Entity.net.ID.Value;
                }
            }

            [JsonProperty("l")]
            public Dictionary<string, Vector3> buildings { get; set; } = new Dictionary<string, Vector3>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty("b")]
            public Dictionary<string, Boat> boats { get; set; } = new Dictionary<string, Boat>(StringComparer.OrdinalIgnoreCase);

            [JsonProperty("t")]
            public TeleportData Teleports { get; set; } = new TeleportData();

            [JsonIgnore]
            private Dictionary<string, Entry> Cache = new Dictionary<string, Entry>();

            [JsonIgnore]
            public Dictionary<string, Entry> Locations
            {
                get
                {
                    if (Cache.Count == 0)
                    {
                        InitializeBuildings();
                        InitializeBoats();
                    }
                    return Cache;
                }
            }

            private void InitializeBuildings()
            {
                foreach (var pair in buildings)
                {
                    Cache[pair.Key] = new Entry(pair.Value);
                }
            }

            private void InitializeBoats()
            {
                foreach (var pair in boats.ToList())
                {
                    var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(pair.Value.Value));
                    if (!entity.IsValid() || entity.IsDestroyed) continue;
                    Cache[pair.Key] = new Entry
                    {
                        Position = pair.Value.Offset,
                        wasEntity = true,
                        Entity = entity
                    };
                }
            }

            public bool TryGetValue(string key, out Entry homeEntry)
            {
                return Locations.TryGetValue(key, out homeEntry);
            }

            public void Set(string key, Entry homeEntry)
            {
                Locations[key] = homeEntry;
                if (homeEntry.isEntity)
                {
                    boats[key] = new Boat(homeEntry);
                }
                else buildings[key] = homeEntry.Get();
            }

            public bool Remove(string key)
            {
                bool removed = boats.Remove(key) || buildings.Remove(key);
                return Locations.Remove(key) || removed;
            }
        }

        public class TeleportData
        {
            [JsonProperty("a")]
            public int Amount { get; set; }

            [JsonProperty("d")]
            public string Date { get; set; }

            [JsonProperty("t")]
            public int Timestamp { get; set; }
        }

        private class TeleportTimer
        {
            public Timer Timer { get; set; }
            public BasePlayer OriginPlayer { get; set; }
            public BasePlayer TargetPlayer { get; set; }
        }

        private List<string> GetMonumentMessages()
        {
            return new List<string>
            {
                "Abandoned Cabins",
                "Abandoned Supermarket",
                "Abandoned Military Base",
                "Airfield",
                "Arctic Research Base",
                "Bandit Camp",
                "Barn",
                "Crow's Nest",
                "Ferry Terminal",
                "Fishing Village",
                "Gas Station",
                "Giant Excavator Pit",
                "Harbor",
                "HQM Quarry",
                "Ice Lake",
                "Junkyard",
                "Large Barn",
                "Large Fishing Village",
                "Launch Site",
                "Lighthouse",
                "Military Tunnel",
                "Mining Outpost",
                "Missile Silo",
                "Mountain",
                "Oil Rig",
                "Large Oil Rig",
                "Outpost",
                "Oxum's Gas Station",
                "Power Plant",
                "Ranch",
                "Radtown",
                "Satellite Dish",
                "Sewer Branch",
                "Stone Quarry",
                "Substation",
                "Sulfur Quarry",
                "The Supermarket",
                "The Dome",
                "Train Tunnel",
                "Train Yard",
                "Underwater Lab",
                "Water Treatment Plant",
                "Water Well",
                "Wild Swamp",
            };
        }

        protected override void LoadDefaultMessages()
        {
            if (!_cmcCompleted)
            {
                timer.Once(1f, LoadDefaultMessages);
                return;
            }

            var monumentMessages = GetMonumentMessages();

            var en = new Dictionary<string, string>
            {
                {"ErrorTPR", "Teleporting to {0} is blocked ({1})"},
                {"AdminTP", "You teleported to {0}!"},
                {"AdminTPTarget", "{0} teleported to you!"},
                {"AdminTPPlayers", "You teleported {0} to {1}!"},
                {"AdminTPPlayer", "{0} teleported you to {1}!"},
                {"AdminTPPlayerTarget", "{0} teleported {1} to you!"},
                {"AdminTPCoordinates", "You teleported to {0}!"},
                {"AdminTPTargetCoordinates", "You teleported {0} to {1}!"},
                {"AdminTPOutOfBounds", "You tried to teleport to a set of coordinates outside the map boundaries!"},
                {"AdminTPBoundaries", "X and Z values need to be between -{0} and {0} while the Y value needs to be between -100 and 2000!"},
                {"AdminTPLocation", "You teleported to {0}!"},
                {"AdminTPLocationSave", "You have saved the current location!"},
                {"AdminTPLocationRemove", "You have removed the location {0}!"},
                {"AdminLocationList", "The following locations are available:"},
                {"AdminLocationListEmpty", "You haven't saved any locations!"},
                {"AdminTPBack", "You've teleported back to your previous location!"},
                {"AdminTPBackSave", "Your previous location has been saved, use /tpb to teleport back!"},
                {"AdminTPTargetCoordinatesTarget", "{0} teleported you to {1}!"},
                {"AdminTPConsoleTP", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayer", "You were teleported to {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} was teleported to you!"},
                {"HomeTP", "You teleported to your home '{0}'!"},
                {"HomeAdminTP", "You teleported to {0}'s home '{1}'!"},
                {"HomeIce", "You can't use home on ice!"},
                {"HomeSave", "You have saved the current location as your home!"},
                {"HomeNoFoundation", "You can only use a home location on a foundation!"},
                {"HomeFoundationNotOwned", "You can't use home on someone else's house."},
                {"HomeFoundationUnderneathFoundation", "You can't use home on a foundation that is underneath another foundation."},
                {"HomeFoundationNotFriendsOwned", "You or a friend need to own the house to use home!"},
                {"HomeRemovedInvalid", "Your home '{0}' was removed because not on a foundation or not owned!"},
                {"HighWallCollision", "High Wall Collision!"},
                {"HomeRemovedDestroyed", "Your home '{0}' was removed because it no longer exists!"},
                {"HomeRemovedInsideBlock", "Your home '{0}' was removed because inside a foundation!"},
                {"HomeRemove", "You have removed your home {0}!"},
                {"HomeDelete", "You have removed {0}'s home '{1}'!"},
                {"HomeList", "The following homes are available:"},
                {"HomeListEmpty", "You haven't saved any homes!"},
                {"HomeMaxLocations", "Unable to set your home here, you have reached the maximum of {0} homes!"},
                {"HomeQuota", "You have set {0} of the maximum {1} homes!"},
                {"HomeTugboatNotAllowed", "You are not allowed to sethome on tugboats."},
                {"HomeTPStarted", "Teleporting to your home {0} in {1} seconds!"},
                {"PayToTown", "Standard payment of {0} applies to all {1} teleports!"},
                {"PayToTPR", "Standard payment of {0} applies to all tprs!"},
                {"HomeTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"HomeTPCooldownBypass", "Your teleport was currently on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"HomeTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"HomeTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"HomeTPCooldownBypassP2", "Type /home NAME {0}." },
                {"HomeTPLimitReached", "You have reached the daily limit of {0} teleports today!"},
                {"HomeTPAmount", "You have {0} home teleports left today!"},
                {"HomesListWiped", "You have wiped all the saved home locations!"},
                {"HomeTPBuildingBlocked", "You can't set your home if you are not allowed to build in this zone!"},
                {"HomeTPSwimming", "You can't set your home while swimming!"},
                {"HomeTPCrafting", "You can't set your home while crafting!"},
                {"Request", "You've requested a teleport to {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:\n</color> {0}</size>"},
                {"RequestTarget", "{0} requested to be teleported to you! Use '/tpa' to accept!"},
                {"RequestTargetOff", "Your request has been cancelled as the target is offline now." },
                {"RequestAccept", "<size=12>Accept</size>" },
                {"RequestReject", "<size=12>Reject</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "This command is only available to friends or teammates or clanmates!"},
                {"PendingRequest", "You already have a request pending, cancel that request or wait until it gets accepted or times out!"},
                {"PendingRequestTarget", "The player you wish to teleport to already has a pending request, try again later!"},
                {"NoPendingRequest", "You have no pending teleport request!"},
                {"Accept", "{0} has accepted your teleport request! Teleporting in {1} seconds!"},
                {"AcceptTarget", "You've accepted the teleport request of {0}!"},
                {"AcceptToggleOff", "You've disabled automatic /tpa!"},
                {"AcceptToggleOn", "You've enabled automatic /tpa!"},
                {"NotAllowed", "You are not allowed to use this command!"},
                {"Success", "You teleported to {0}!"},
                {"SuccessTarget", "{0} teleported to you!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "Your teleport request to {0} was cancelled!"},
                {"CancelledTarget", "{0} teleport request was cancelled!"},
                {"TPCancelled", "Your teleport was cancelled!"},
                {"TPCancelledTarget", "{0} cancelled teleport!"},
                {"TPYouCancelledTarget", "You cancelled {0} teleport!"},
                {"TimedOut", "{0} did not answer your request in time!"},
                {"TimedOutTarget", "You did not answer {0}'s teleport request in time!"},
                {"TargetDisconnected", "{0} has disconnected, your teleport was cancelled!"},
                {"TPRCooldown", "Your teleport requests are currently on cooldown. You'll have to wait {0} to send your next teleport request."},
                {"TPRCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"TPRCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds - {0} - to bypass."},
                {"TPRCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"TPMoney", "{0} deducted from your account!"},
                {"TPNoMoney", "You do not have {0} in any account!"},
                {"TPRCooldownBypassP2", "Type /tpr {0}." },
                {"TPRCooldownBypassP2a", "Type /tpr NAME {0}." },
                {"TPRLimitReached", "You have reached the daily limit of {0} teleport requests today!"},
                {"TPRAmount", "You have {0} teleport requests left today!"},
                {"TPRTarget", "Your target is currently not available!"},
                {"TPDead", "You can't teleport while being dead!"},
                {"TPWounded", "You can't teleport while wounded!"},
                {"TPTooCold", "You're too cold to teleport!"},
                {"TPTooHot", "You're too hot to teleport!"},
                {"TPBoat", "You can't teleport while on a boat!"},
                {"TPTugboat", "You can't teleport while on a tugboat!"},
                {"TPHostile", "Can't teleport to outpost or bandit when hostile!"},
                {"TPJunkpile", "You can't teleport from a junkpile!"},
                {"HostileTimer", "Teleport available in {0} minutes."},
                {"TPMounted", "You can't teleport while seated!"},
                {"TPBuildingBlocked", "You can't teleport while in a building blocked area!"},
                {"TPAboveWater", "You can't teleport while above water!"},
                {"TPUnderWater", "You can't teleport while under water!"},
                {"TPTargetBuildingBlocked", "You can't teleport into a building blocked area!"},
                {"TPTargetInsideBlock", "You can't teleport into a foundation!"},
                {"TPTargetInsideEntity", "You can't teleport into another entity!"},
                {"TPTargetInsideRock", "You can't teleport into a rock!"},
                {"TPSwimming", "You can't teleport while swimming!"},
                {"TPCargoShip", "You can't teleport from the cargo ship!"},
                {"TPOilRig", "You can't teleport from the oil rig!"},
                {"TPExcavator", "You can't teleport from the excavator!"},
                {"TPHotAirBalloon", "You can't teleport to or from a hot air balloon!"},
                {"TPLift", "You can't teleport while in an elevator or bucket lift!"},
                {"TPBucketLift", "You can't teleport while in a bucket lift!"},
                {"TPRegLift", "You can't teleport while in an elevator!"},
                {"TPSafeZone", "You can't teleport from a safezone!"},
                {"TPFlagZone", "You can't teleport from this zone!"},
                {"TPNoEscapeBlocked", "You can't teleport while blocked!"},
                {"TPCrafting", "You can't teleport while crafting!"},
                {"TPBlockedItem", "You can't teleport while carrying: {0}!"},
                {"TPHomeSafeZoneOnly", "You can only teleport home from within a safe zone!" },
                {"TooCloseToMon", "You can't teleport so close to the {0}!"},
                {"TooCloseToCave", "You can't teleport so close to a cave!"},
                {"HomeTooCloseToCave", "You can't set home so close to a cave!"},
                {"HomeTooCloseToMon", "You can't set home so close to a monument!"},
                {"CannotTeleportFromHome", "You must leave your base to be able to teleport!"},
                {"WaitGlobalCooldown", "You must wait {0} on your global teleport cooldown!" },
                {"DM_TownTP", "You teleported to {0}!"},
                {"DM_TownTPNoLocation", "<color=yellow>{0}</color> location is currently not set!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> is currently disabled in config file!"},
                {"DM_TownTPLocation", "You have set the <color=yellow>{0}</color> location to {1}!"},
                {"DM_TownTPCreated", "You have created the command: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "You have removed the command: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Command does not exist: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Command <color=yellow>{0}</color> already exists!"},
                {"DM_TownTPLocationsCleared", "You have cleared all locations for {0}!"},
                {"DM_TownTPStarted", "Teleporting to {0} in {1} seconds!"},
                {"DM_TownTPCooldown", "Your teleport is currently on cooldown. You'll have to wait {0} for your next teleport."},
                {"DM_TownTPCooldownBypass", "Your teleport request was on cooldown. You chose to bypass that by paying {0} from your balance."},
                {"DM_TownTPCooldownBypassF", "Your teleport is currently on cooldown. You do not have sufficient funds ({0}) to bypass."},
                {"DM_TownTPCooldownBypassP", "You may choose to pay {0} to bypass this cooldown." },
                {"DM_TownTPCooldownBypassP2", "Type <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "You have reached the daily limit of {0} teleports today! You'll have to wait {1} for your next teleport."},
                {"DM_TownTPAmount", "You have {0} <color=yellow>{1}</color> teleports left today!"},

                { "Days", "Days" },
                { "Hours", "Hours" },
                { "Minutes", "Minutes" },
                { "Seconds", "Seconds" },

                {"Interrupted", "Your teleport was interrupted!"},
                {"InterruptedTarget", "{0}'s teleport was interrupted!"},
                {"Unlimited", "Unlimited"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the info of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "/tpinfo - Shows limits and cooldowns.",
                        "Please specify the module you want to view the help of.",
                        "The available modules are: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "As an admin you have access to the following commands:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location.",
                        "/tpsave \"location name\" - Saves your current position as the location name.",
                        "/tpremove \"location name\" - Removes the location from your saved list.",
                        "/tpb - Teleports you back to the place where you were before teleporting.",
                        "/home radius \"radius\" - Find all homes in radius.",
                        "/home delete \"player name|id\" \"home name\" - Remove a home from a player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "With the following commands you can set your home location to teleport back to:",
                        "/home add \"name\" - Saves your current position as the location name.",
                        "/home list - Shows you a list of all the locations you have saved.",
                        "/home remove \"name\" - Removes the location of your saved homes.",
                        "/home \"name\" - Teleports you to the home location."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "With these commands you can request to be teleported to a player or accept someone else's request:",
                        "/tpr \"player name\" - Sends a teleport request to the player.",
                        "/tpa - Accepts an incoming teleport request.",
                        "/tpat - Toggle automatic /tpa on incoming teleport requests.",
                        "/tpc - Cancel teleport or request."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Please specify the module you want to view the settings of. ",
                        "The available modules are:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Home System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}",
                        "Amount of saved Home locations: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Bandit System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Outpost System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "TPR System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "Town System has the current settings enabled:",
                        "Time between teleports: {0}",
                        "Daily amount of teleports: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "{0} System has the current settings enabled:",
                        "Time between teleports: {1}",
                        "Daily amount of teleports: {2}"
                    })
                },

                {"TPT_True", "enabled"},
                {"TPT_False", "disabled"},
                {"TPT_clan", "{1} clan has been {0}."},
                {"TPT_friend", "{1} friend has been {0}."},
                {"TPT_team", "{1} team has been {0}."},
                {"NotValidTPT", "Not valid, player is not"},
                {"NotValidTPTFriend", " a friend!"},
                {"NotValidTPTTeam", " on your team!"},
                {"NotValidTPTClan", " in your clan!"},
                {"TPTInfo", "{4} auto accepts teleport requests.\n<color={5}>Green</color> = <color={5}>Enabled</color>\n<color={6}>Red</color> = <color={6}>Disabled</color>\n\n/{0} <color={1}>clan</color> - Toggle {4} for clan members/allies.\n/{0} <color={2}>team</color> - Toggle {4} for teammates.\n/{0} <color={3}>friend</color> - Toggle {4} for friends."},

                {"PlayerNotFound", "The specified player couldn't be found please try again!"},
                {"MultiplePlayers", "Found multiple players: {0}"},
                {"CantTeleportToSelf", "You can't teleport to yourself!"},
                {"CantTeleportPlayerToSelf", "You can't teleport a player to himself!"},
                {"CantTeleportPlayerToYourself", "You can't teleport a player to yourself!"},
                {"TeleportPendingTPC", "You can't initiate another teleport while you have a teleport pending! Use /tpc to cancel this."},
                {"TeleportPendingTarget", "You can't request a teleport to someone who's about to teleport!"},
                {"LocationExists", "A location with this name already exists at {0}!"},
                {"LocationExistsNearby", "A location with the name {0} already exists near this position!"},
                {"LocationNotFound", "Couldn't find a location with that name!"},
                {"NoPreviousLocationSaved", "No previous location saved!"},
                {"HomeExists", "You have already saved a home location by this name!"},
                {"HomeExistsNearby", "A home location with the name {0} already exists near this position!"},
                {"HomeNotFound", "Couldn't find your home with that name!"},
                {"InvalidCoordinates", "The coordinates you've entered are invalid!"},
                {"InvalidHelpModule", "Invalid module supplied!"},
                {"InvalidCharacter", "You have used an invalid character, please limit yourself to the letters a to z and numbers."},
                {"NotUseable", "You must wait another {0}after the wipe to use this command." },
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tp command as follows:",
                        "/tp \"targetplayer\" - Teleports yourself to the target player.",
                        "/tp \"player\" \"targetplayer\" - Teleports the player to the target player.",
                        "/tp x y z - Teleports you to the set of coordinates.",
                        "/tp \"player\" x y z - Teleports the player to the set of coordinates."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpl command as follows:",
                        "/tpl - Shows a list of saved locations.",
                        "/tpl \"location name\" - Teleports you to a saved location."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpsave command as follows:",
                        "/tpsave \"location name\" - Saves your current position as 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpremove command as follows:",
                        "/tpremove \"location name\" - Removes the location with the name 'location name'."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpn command as follows:",
                        "/tpn \"targetplayer\" - Teleports yourself the default distance behind the target player.",
                        "/tpn \"targetplayer\" \"distance\" - Teleports you the specified distance behind the target player."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home add command as follows:",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home remove command as follows:",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home command as follows:",
                        "/home \"name\" - Teleports yourself to your home with the name 'name'.",
                        "/home \"name\" pay - Teleports yourself to your home with the name 'name', avoiding cooldown by paying for it.",
                        "/home add \"name\" - Saves the current location as your home with the name 'name'.",
                        "/home list - Shows you a list of all your saved home locations.",
                        "/home remove \"name\" - Removes the home location with the name 'name'."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "/home radius \"radius\" - Shows you a list of all homes in radius(10).",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player.",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player.",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /town command as follows:",
                        "/town - Teleports yourself to town.",
                        "/town pay - Teleports yourself to town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "/town set - Saves the current location as town.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /outpost command as follows:",
                        "/outpost - Teleports yourself to the Outpost.",
                        "/outpost pay - Teleports yourself to the Outpost, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "/outpost set - Saves the current location as Outpost.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /bandit command as follows:",
                        "/bandit - Teleports yourself to the Bandit Town.",
                        "/bandit pay - Teleports yourself to the Bandit Town, paying the penalty."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "/bandit set - Saves the current location as Bandit Town.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home delete command as follows:",
                        "/home delete \"player name|id\" \"name\" - Removes the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home tp command as follows:",
                        "/home tp \"player name|id\" \"name\" - Teleports you to the home location with the name 'name' from the player."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home homes command as follows:",
                        "/home homes \"player name|id\" - Shows you a list of all homes from the player."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /home list command as follows:",
                        "/home list - Shows you a list of all your saved home locations."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpr command as follows:",
                        "/tpr \"player name\" - Sends out a teleport request to 'player name'."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpa command as follows:",
                        "/tpa - Accepts an incoming teleport request."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the /tpc command as follows:",
                        "/tpc - Cancels an teleport request."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.topos console command as follows:",
                        " > teleport.topos \"player\" x y z"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "A Syntax Error Occurred!",
                        "You can only use the teleport.toplayer console command as follows:",
                        " > teleport.toplayer \"player\" \"target player\""
                    })
                },
                {"LogTeleport", "{0} teleported to {1}."},
                {"LogTeleportPlayer", "{0} teleported {1} to {2}."},
                {"LogTeleportBack", "{0} teleported back to previous location."}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                en[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                en[key] = key;
            }

            lang.RegisterMessages(en, this, "en");

            var ru = new Dictionary<string, string>
            {
                {"ErrorTPR", "Телепорт к {0} блокирован ({1})"},
                {"AdminTP", "Вы телепортированы к {0}!"},
                {"AdminTPTarget", "{0} телепортировал вас!"},
                {"AdminTPPlayers", "Вы телепортировали {0} к {1}!"},
                {"AdminTPPlayer", "{0} телепортировал вас к {1}!"},
                {"AdminTPPlayerTarget", "{0} телепортировал {1} к вам!"},
                {"AdminTPCoordinates", "Вы телепортированы к {0}!"},
                {"AdminTPTargetCoordinates", "Вы телепортировали {0} к {1}!"},
                {"AdminTPOutOfBounds", "Вы пытались телепортироваться к координатам вне границ карты!"},
                {"AdminTPBoundaries", "Значения X и Z должны быть между -{0} и {0}, а значение Y между -100 и 2000!"},
                {"AdminTPLocation", "Вы телепортированы к {0}!"},
                {"AdminTPLocationSave", "Вы сохранили текущее местоположение!"},
                {"AdminTPLocationRemove", "Вы удалили местоположение {0}!"},
                {"AdminLocationList", "Доступны следующие местоположения:"},
                {"AdminLocationListEmpty", "Вы не сохранили никаких местоположений!"},
                {"AdminTPBack", "Вы телепортированы назад, в ваше предыдущее местоположение!"},
                {"AdminTPBackSave", "Ваше предыдущее местоположение сохранено, используйте <color=yellow>/tpb</color>, чтобы телепортироваться назад!"},
                {"AdminTPTargetCoordinatesTarget", "{0} телепортировал вас к {1}!"},
                {"AdminTPConsoleTP", "Вы были телепортированы к {0}"},
                {"AdminTPConsoleTPPlayer", "Вы были телепортированы к {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} был телепортирован к вам!"},
                {"HomeTP", "Вы телепортированы в ваш дом '{0}'!"},
                {"HomeAdminTP", "Вы телепортированы к дому '{1}' принадлежащему {0}!"},
                {"HomeIce", "Ви не можете зберегти місце розташування як будинок на крижаному озері!"},
                {"HomeSave", "Вы сохранили текущее местоположение как ваш дом!"},
                {"HomeNoFoundation", "Использовать местоположение в качестве дома разрешено только на фундаменте!"},
                {"HomeFoundationNotOwned", "Вы не можете использовать команду home в чужом доме."},
                {"HomeFoundationUnderneathFoundation", "Вы не можете использовать команду home на фундаменте, который находится под другим фундаментом."},
                {"HomeFoundationNotFriendsOwned", "Вы, или ваш друг, должны быть владельцем дома, чтобы использовать команду home!"},
                {"HomeRemovedInvalid", "Ваш дом '{0}' был удалён потому, что не на фундаменте, или у фундамента новый владелец!"},
                {"HighWallCollision", "Столкновение Высоких Стен!"},
                {"HomeRemovedDestroyed", "Ваш дом '{0}' удален, так как его больше не существует!"},
                {"HomeRemovedInsideBlock", "Ваш дом '{0}' был удалён потому, что внутри фундамента!"},
                {"HomeRemove", "Вы удалили свой дом {0}!"},
                {"HomeDelete", "Вы удалили дом '{1}' принадлежащий {0}!"},
                {"HomeList", "Доступны следующие дома:"},
                {"HomeListEmpty", "Вы не сохранили ни одного дома!"},
                {"HomeMaxLocations", "Невозможно установить здесь ваш дом, вы достигли лимита в {0} домов!"},
                {"HomeQuota", "Вы установили {0} из {1} максимально возможных домов!"},
                {"HomeTugboatNotAllowed", "You are not allowed to sethome on tugboats."},
                {"HomeTPStarted", "Телепортация в ваш дом {0} через {1} секунд!"},
                {"PayToTown", "Стандартный платеж {0} распространяется на все телепорты в город!"},
                {"PayToTPR", "Стандартный платеж {0} распространяется на все tpr'ы!"},
                {"HomeTPCooldown", "Ваш телепорт перезаряжается. Вам необходимо подождать {0} до следующей телепортации."},
                {"HomeTPCooldownBypass", "Ваш телепорт был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"HomeTPCooldownBypassF", "Ваш телепорт перезаряжается. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"HomeTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"HomeTPCooldownBypassP2", "Напишите <color=yellow>/home \"название дома\" {0}</color>." },
                {"HomeTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций сегодня!"},
                {"HomeTPAmount", "У вас осталось {0} телепортаций домой сегодня!"},
                {"HomesListWiped", "Вы очистили все местоположения, сохранённые как дом!"},
                {"HomeTPBuildingBlocked", "Вы не можете сохранить местоположение в качестве дома, если у вас нет прав на строительство в этой зоне!"},
                {"HomeTPSwimming", "Вы не можете устанавливать местоположение а качестве дома пока плывёте!"},
                {"HomeTPCrafting", "Вы не можете устанавливать местоположение а качестве дома в процессе крафта!"},
                {"Request", "Вы запросили телепортацию к {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:\n</color> {0}</size>"},
                {"RequestTarget", "{0} запросил телепортацию к вам! Используйте <color=yellow>/tpa</color>, чтобы принять!"},
                {"RequestTargetOff", "Ваш запрос был отменен, так как цель сейчас не в сети." },
                {"RequestAccept", "<size=12>Принять</size>" },
                {"RequestReject", "<size=12>Отказаться</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "Эта команда доступна только друзьям, участникам команды или клана!"},
                {"PendingRequest", "У вас уже есть активный запрос, отмените его, ожидайте подтверждения, либо отмены по таймауту!"},
                {"PendingRequestTarget", "У игрока, к которому вы хотите телепортироваться уже есть активный запрос, попробуйте позже!"},
                {"NoPendingRequest", "У вас нет активных запросов на телепортацию!"},
                {"Accept", "{0} принял ваш запрос! Телепортация через {1} секунд!"},
                {"AcceptTarget", "Вы приняли запрос на телепортацию {0}!"},
                {"AcceptToggleOff", "Вы отключили автоматическое /tpa!"},
                {"AcceptToggleOn", "Вы включили автоматическое /tpa!"},
                {"NotAllowed", "Вам не разрешено использовать эту команду!"},
                {"Success", "Вы телепортированы к {0}!"},
                {"SuccessTarget", "{0} телепортирован к вам!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "Ваш запрос на телепортацию к {0} был отменён!"},
                {"CancelledTarget", "Запрос на телепортацию {0} был отменён!"},
                {"TPCancelled", "Ваша телепортация отменена!"},
                {"TPCancelledTarget", "{0} отменил телепортацию!"},
                {"TPYouCancelledTarget", "Вы отменили телепортацию {0}!"},
                {"TimedOut", "{0} не ответил на ваш запрос во время!"},
                {"TimedOutTarget", "Вы не ответили вовремя на запрос телепортации от {0}!"},
                {"TargetDisconnected", "{0} отключился, ваша телепортация отменена!"},
                {"TPRCooldown", "Ваши запросы на телепортацию в данный момент на перезарядке. Вам необходимо подождать {0} прежде чем отправить следующий запрос."},
                {"TPRCooldownBypass", "Ваши запросы на телепортацию были на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"TPRCooldownBypassF", "Ваши запросы на телепортацию в данный момент на перезарядке. У вас недостаточно средств - {0} - чтобы избежать ожидания."},
                {"TPRCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"TPMoney", "{0} списано с вашего аккаунта!"},
                {"TPNoMoney", "У вас нет {0} ни на одном аккаунте!"},
                {"TPRCooldownBypassP2", "Напишите <color=yellow>/tpr {0}</color>." },
                {"TPRCooldownBypassP2a", "Напишите <color=yellow>/tpr \"имя игрока\" {0}</color>." },
                {"TPRLimitReached", "Вы исчерпали ежедневный лимит {0} запросов на телепортацию сегодня!"},
                {"TPRAmount", "У вас осталось {0} запросов на телепортацию на сегодня!"},
                {"TPRTarget", "Ваша цель в данный момент не доступна!"},
                {"TPDead", "Вы не можете телепортироваться, пока мертвы!"},
                {"TPWounded", "Вы не можете телепортироваться, будучи раненым!"},
                {"TPTooCold", "Вам слишком холодно для телепортации!"},
                {"TPTooHot", "Вам слишком жарко для телепортации!"},
                {"TPTugboat", "Вы не можете телепортироваться на этой лодке!"},
                {"TPBoat", "Вы не можете телепортироваться находясь на лодке!"},
                {"TPHostile", "Вы не можете телепортироваться в Город NPC или Лагерь бандитов пока враждебны!"},
                {"TPJunkpile", "Вы не можете телепортироваться с кучи мусора"},
                {"HostileTimer", "Телепорт станет доступен через {0} минут."},
                {"TPMounted", "Вы не можете телепортироваться, когда сидите!"},
                {"TPBuildingBlocked", "Вы не можете телепортироваться, находясь в зоне блокировки строительства!"},
                {"TPAboveWater", "Вы не можете телепортироваться находясь над водой!"},
                {"TPUnderWater", "Вы не можете телепортироваться под водой!"},
                {"TPTargetBuildingBlocked", "Вы не можете телепортироваться в зону, где блокировано строительство!"},
                {"TPTargetInsideBlock", "Вы не можете телепортироваться в фундамент!"},
                {"TPTargetInsideRock", "Вы не можете телепортироваться в скалу!"},
                {"TPSwimming", "Вы не можете телепортироваться, пока плывёте!"},
                {"TPCargoShip", "Вы не можете телепортироваться с грузового корабля!"},
                {"TPOilRig", "Вы не можете телепортироваться с нефтяной вышки!"},
                {"TPExcavator", "Вы не можете телепортироваться с экскаватора!"},
                {"TPHotAirBalloon", "Вы не можете телепортироваться с, или на воздушный шар!"},
                {"TPLift", "Вы не можете телепортироваться находясь в лифте или подъемнике!"},
                {"TPBucketLift", "Вы не можете телепортироваться находясь в ковшевом подъемнике!"},
                {"TPRegLift", "Вы не можете телепортироваться находясь в лифте!"},
                {"TPSafeZone", "Вы не можете телепортироваться из безопасной зоны!"},
                {"TPFlagZone", "Вы не можете телепортироваться из этой зоны!"},
                {"TPNoEscapeBlocked", "Вы не можете телепортироваться пока активна блокировка!"},
                {"TPCrafting", "Вы не можете телепортироваться в процессе крафта!"},
                {"TPBlockedItem", "Вы не можете телепортироваться пока несёте: {0}!"},
                {"TooCloseToMon", "Вы не можете телепортироваться так близко к {0}!"},
                {"TPHomeSafeZoneOnly", "Вы можете телепортироваться домой только из безопасной зоны!" },
                {"TooCloseToCave", "Вы не можете телепортироваться так близко к пещере!"},
                {"HomeTooCloseToCave", "Вы не можете сохранить местоположение в качестве дома так близко к пещере!"},
                {"HomeTooCloseToMon", "Вы не можете сохранить местоположение в качестве дома так близко к монументу!"},
                {"CannotTeleportFromHome", "Вы должны выйти из вашей базы, прежде чем телепортироваться!"},
                {"WaitGlobalCooldown", "Вы должны подождать {0}, пока ваш глобальный телепорт перезаряжается!" },

                {"DM_TownTP", "Вы телепортированы в {0}!"},
                {"DM_TownTPNoLocation", "Местоположение <color=yellow>{0}</color> в данный момент не установлено!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> в данный момент отключен в файле настройек!"},
                {"DM_TownTPLocation", "Вы установили местоположение <color=yellow>{0}</color> в {1}!"},
                {"DM_TownTPCreated", "Вы создали команду: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "Вы удалили команду: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Команда не существует: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Команда <color=yellow>{0}</color> уже сущуствует!"},
                {"DM_TownTPLocationsCleared", "You have cleared all locations for {0}!"},
                {"DM_TownTPStarted", "Телепортация в {0} через {1} секунд!"},
                {"DM_TownTPCooldown", "Ваш телепорт перезаряжается. Вам необходимо подождать {0} до следующей телепортации."},
                {"DM_TownTPCooldownBypass", "Ваш телепорт был на перезарядке. Вы выбрали избежать ожидания, оплатив {0} с вашего баланса."},
                {"DM_TownTPCooldownBypassF", "Ваш телепорт перезаряжается. У вас недостаточно средств ({0}) чтобы избежать ожидания."},
                {"DM_TownTPCooldownBypassP", "Вы можете выбрать оплатить {0} чтобы избежать ожидания перезарядки." },
                {"DM_TownTPCooldownBypassP2", "Введите <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "Вы исчерпали ежедневный лимит {0} телепортаций сегодня! Вам необходимо подождать {1} до следующей телепортации."},
                {"DM_TownTPAmount", "У вас осталось {0} телепортаций <color=yellow>{1}</color> сегодня!"},

                {"Days", "дней" },
                {"Hours", "часов" },
                {"Minutes", "минут" },
                {"Seconds", "секунд" },

                {"Interrupted", "Ваша телепортация была прервана!"},
                {"InterruptedTarget", "Телепортация {0} была прервана!"},
                {"Unlimited", "Не ограничено"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Пожалуйста, укажите модуль, о котором вы хотите просмотреть информацию.",
                        "Доступные модули: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/tpinfo</color> - Отображает лимиты и перезарядки.",
                        "Пожалуйста, укажите модуль, по которому вы хотите получить помощь.",
                        "Доступные модули: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "Как админ, вы имеете доступ к следующим командам:",
                        "<color=yellow>/tp \"имя игрока\"</color> - Телепортирует вас к указанному игроку.",
                        "<color=yellow>/tp \"имя игрока\" \"имя игрока 2\"</color> - Телепортирует игрока с именем 'имя игрока' к игроку 'имя игрока 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортирует вас к указанным координатам.",
                        "<color=yellow>/tpl</color> - Отображает список сохранённых местоположений.",
                        "<color=yellow>/tpl \"название местоположения\"</color> - Телепортирует вас в сохранённое местоположение.",
                        "<color=yellow>/tpsave \"название местоположения\"</color> - Сохраняет ваше текущее местоположение с указанным названием.",
                        "<color=yellow>/tpremove \"название местоположения\"</color> - Удаляет местоположение из списка сохранённых.",
                        "<color=yellow>/tpb</color> - Телепортирует вас назад на место, где вы были перед телепортацией.",
                        "<color=yellow>/home radius \"радиус\"</color> - Найти все дома в радиусе.",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название дома\"</color> - Удаляет дом с указанным именем принадлежащий указанному игроку.",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название дома\"</color> - Телепортирует вас в дом игрока с указанным названием принадлежащий указанному игроку.",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "Используя следующие команды, вы можете установить местоположение вашего дома, чтобы затем в него телепортироваться:",
                        "<color=yellow>/home add \"название дома\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием.",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом.",
                        "<color=yellow>/home remove \"название дома\"</color> - Удаляет расположение сохранённого дома с указанным названием.",
                        "<color=yellow>/home \"название дома\"</color> - Телепортирует вас в местоположение дома с указанным названием."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "Используя эти команды, вы можете отправить запрос на телепортацию к игроку, или принять чей-то запрос:",
                        "<color=yellow>/tpr \"имя игрока\"</color> - Отправляет запрос на телепортацию игроку с указанным именем.",
                        "<color=yellow>/tpa</color> - Принять входящий запрос на телепортацию.",
                        "<color=yellow>/tpat</color> - Вкл./Выкл. автоматическое принятие входящих запросов на телепортацию к вам /tpa.",
                        "<color=yellow>/tpc</color> - Отменить запрос на телепортацию."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Пожалуйста, укажите модуль, настройки которого вы хотите просмотреть. ",
                        "Доступные модули:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Система домов в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}",
                        "Количество сохранённых домов: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Система Лагерь бандитов в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Система Город NPC в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "Система TPR в данный момент имеет следующие включённые параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "В Системе Городов включены следующие параметры:",
                        "Время между телепортами: {0}",
                        "Ежедневный лимит телепортаций: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "В Системе {0} включены следующие параметры:",
                        "Время между телепортами: {1}",
                        "Ежедневный лимит телепортаций: {2}"
                    })
                },

                {"TPT_True", "включено"},
                {"TPT_False", "выключено"},
                {"TPT_clan", "{1} clan теперь {0}."},
                {"TPT_friend", "{1} friend теперь {0}."},
                {"TPT_team", "{1} team теперь {0}."},
                {"NotValidTPT", "Неверно, игрок не"},
                {"NotValidTPTFriend", " друг!"},
                {"NotValidTPTTeam", " в вашей команде!"},
                {"NotValidTPTClan", " в вашем клане!"},
                // TODO: Fix not being in Russian.
                {"TPTInfo", "{4} auto accepts teleport requests.\n<color={5}>Green</color> = <color={5}>Enabled</color>\n<color={6}>Red</color> = <color={6}>Disabled</color>\n\n/{0} <color={1}>clan</color> - Toggle {4} for clan members/allies.\n/{0} <color={2}>team</color> - Toggle {4} for teammates.\n/{0} <color={3}>friend</color> - Toggle {4} for friends."},
                {"PlayerNotFound", "Указанный игрок не обнаружен, пожалуйста попробуйте ещё раз!"},
                {"MultiplePlayers", "Найдено несколько игроков: {0}"},
                {"CantTeleportToSelf", "Вы не можете телепортироваться к самому себе!"},
                {"CantTeleportPlayerToSelf", "Вы не можете телепортровать игрока к самому себе!"},
                {"TeleportPendingTPC", "Вы не можете инициировать телепортацию, пока у вас есть активный запрос! Используйте <color=yellow>/tpc</color> чтобы отменить его."},
                {"TeleportPendingTarget", "Вы не можете отправить запрос к тому, кто в процессе телепортации!"},
                {"LocationExists", "Местоположение с таким названием уже существует в {0}!"},
                {"LocationExistsNearby", "Местоположение с названием {0} уже существует рядом с текущей позицией!"},
                {"LocationNotFound", "Не найдено местоположение с таким названием!"},
                {"NoPreviousLocationSaved", "Предыдущее местоположение не сохранено!"},
                {"HomeExists", "Вы уже сохранили дом с таким названием!"},
                {"HomeExistsNearby", "Дом с названием {0} уже существует рядом с текущей позицией!"},
                {"HomeNotFound", "Дом с таким названием не найден!"},
                {"InvalidCoordinates", "Вы указали неверные координаты!"},
                {"InvalidHelpModule", "Указан неверный модуль!"},
                {"InvalidCharacter", "Вы использовали недопустимый символ, ограничьтесь буквами от a до z и цифрами."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tp</color> возможно только следующим образом:",
                        "<color=yellow>/tp \"имя игрока\"</color> - Телепортирует вас к указанному игроку.",
                        "<color=yellow>/tp \"имя игрока\" \"имя игрока 2\"</color> - Телепортирует игрока с именем 'имя игрока' к игроку 'имя игрока 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортирует вас к указанным координатам.",
                        "<color=yellow>/tp \"имя игрока\" x y z</color> - Телепортирует игрока с именем 'имя игрока' к указанным координатам."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpl</color> возможно только следующим образом:",
                        "<color=yellow>/tpl</color> - Отображает список сохранённых местоположений.",
                        "<color=yellow>/tpl \"название местоположения\"</color> - Телепортирует вас в место с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpsave</color> возможно только следующим образом:",
                        "<color=yellow>/tpsave \"название местоположения\"</color> - Сохраняет ваше текущее местоположение с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpremove</color> возможно только следующим образом:",
                        "<color=yellow>/tpremove \"название местоположения\"</color> - Удаляет местоположение с указанным названием."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpn</color> возможно только следующим образом:",
                        "<color=yellow>/tpn \"имя игрока\"</color> - Телепортирует вас на расстояние по умолчанию позади игрока с указанным именем.",
                        "<color=yellow>/tpn \"имя игрока\" \"расстояние\"</color> - Телепортирует вас на указанное расстояние позади игрока с указанным именем."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home add</color> возможно только следующим образом:",
                        "<color=yellow>/home add \"название\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home remove</color> возможно только следующим образом:",
                        "<color=yellow>/home remove \"название\"</color> - Удаляет местоположение дома с указанным названием."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home</color> возможно только следующим образом:",
                        "<color=yellow>/home \"название\"</color> - Телепортирует вас в ваш дом с указанным названием.",
                        "<color=yellow>/home \"название\" pay</color> - Телепортирует вас в ваш дом с указанным названием, избегая перезарядки, заплатив за это.",
                        "<color=yellow>/home add \"название\"</color> - Сохраняет ваше текущее местоположение как ваш дом с указанным названием.",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом.",
                        "<color=yellow>/home remove \"название\"</color> - Удаляет местоположение дома с указанным названием."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/home radius \"радиус\"</color> - Отображает список всех домов в радиусе(10).",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название\"</color> - Удаляет дом с указанным названием, принадлежащий указанному игроку.",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название\"</color> - Телепортирует вас в дом с указанным названием, принадлежащий указанному игроку.",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/town</color> возможно только следующим образом:",
                        "<color=yellow>/town</color> - Телепортирует вас в Город.",
                        "<color=yellow>/town pay</color> - Телепортирует вас в Город с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/town set</color> - Сохраняет текущее местоположение как Город.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/outpost</color> возможно только следующим образом:",
                        "<color=yellow>/outpost</color> - Телепортирует вас в Город NPC.",
                        "<color=yellow>/outpost pay</color> - Телепортирует вас в Город NPC с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/outpost set</color> - Сохраняет текущее местоположение как Город NPC.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/bandit</color> возможно только следующим образом:",
                        "<color=yellow>/bandit</color> - Телепортирует вас в Лагерь бандитов.",
                        "<color=yellow>/bandit pay</color> - Телепортирует вас в Лагерь бандитов с оплатой штрафа."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/bandit set</color> - Сохраняет текущее местоположение как Лагерь бандитов.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home delete</color> возможно только следующим образом:",
                        "<color=yellow>/home delete \"имя игрока или ID\" \"название\"</color> - Удаляет дом с указанным названием, принадлежащий указанному игроку."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home tp</color> возможно только следующим образом:",
                        "<color=yellow>/home tp \"имя игрока или ID\" \"название\"</color> - Телепортирует вас в дом игрока с указанным названием, принадлежащий указанному игроку."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home homes</color> возможно только следующим образом:",
                        "<color=yellow>/home homes \"имя игрока или ID\"</color> - Отображает вам список всех домов, принадлежащих указанному игроку."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/home list</color> возможно только следующим образом:",
                        "<color=yellow>/home list</color> - Отображает список всех местоположений, сохранённых вами как дом."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpr</color> возможно только следующим образом:",
                        "<color=yellow>/tpr \"имя игрока или ID\"</color> - Отправляет указанному игроку запрос на телепортацию."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpa</color> возможно только следующим образом:",
                        "<color=yellow>/tpa</color> - Принять входящий запрос на телепортацию."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование команды <color=yellow>/tpc</color> возможно только следующим образом:",
                        "<color=yellow>/tpc</color> - Отменить запрос на телепортацию."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование консольной команды <color=orange>teleport.topos</color> возможно только следующим образом:",
                        " > <color=orange>teleport.topos \"имя игрока\" x y z</color>"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "Произошла синтаксическая ошибка!",
                        "Использование консольной команды <color=orange>teleport.toplayer</color> возможно только следующим образом:",
                        " > <color=orange>teleport.toplayer \"имя игрока или ID\" \"имя игрока 2|id 2\"</color>"
                    })
                },
                {"LogTeleport", "{0} телепортирован к {1}."},
                {"LogTeleportPlayer", "{0} телепортировал {1} к {2}."},
                {"LogTeleportBack", "{0} телепортирован назад, в предыдущее местоположение."}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                ru[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                ru[key] = key;
            }

            lang.RegisterMessages(ru, this, "ru");

            var uk = new Dictionary<string, string>
            {
                {"ErrorTPR", "Телепорт до {0} блоковано ({1})"},
                {"AdminTP", "Ви телепортовані до {0}!"},
                {"AdminTPTarget", "{0} телепортував вас!"},
                {"AdminTPPlayers", "Ви телепортували {0} до {1}!"},
                {"AdminTPPlayer", "{0} телепортував вас до {1}!"},
                {"AdminTPPlayerTarget", "{0} телепортував {1} до вас!"},
                {"AdminTPCoordinates", "Ви телепортовані до {0}!"},
                {"AdminTPTargetCoordinates", "Ви телепортували {0} до {1}!"},
                {"AdminTPOutOfBounds", "Ви намагалися телепортуватися до координат поза межами карти!"},
                {"AdminTPBoundaries", "Значення X та Z повинні бути між -{0} та {0}, а значення Y між -100 та 2000!"},
                {"AdminTPLocation", "Ви телепортовані до {0}!"},
                {"AdminTPLocationSave", "Ви зберегли місцезнаходження!"},
                {"AdminTPLocationRemove", "Ви видалили розташування {0}!"},
                {"AdminLocationList", "Доступні такі розташування:"},
                {"AdminLocationListEmpty", "Ви не зберегли жодних місць!"},
                {"AdminTPBack", "Ви телепортовані назад, у ваше попереднє розташування!"},
                {"AdminTPBackSave", "Ваше попереднє місце збережено, використовуйте <color=yellow>/tpb</color>, щоб телепортуватися назад!"},
                {"AdminTPTargetCoordinatesTarget", "{0} телепортував вас до {1}!"},
                {"AdminTPConsoleTP", "Ви були телепортовані до {0}"},
                {"AdminTPConsoleTPPlayer", "Ви були телепортовані до {0}"},
                {"AdminTPConsoleTPPlayerTarget", "{0} був телепортований до вас!"},
                {"HomeTP", "Ви телепортовані до вашого будинку '{0}'!"},
                {"HomeAdminTP", "Ви телепортовані до будинку '{1}', що належить {0}!"},
                {"HomeIce", "Вы не можете сохранить местоположение в качестве дома на ледяном озере!"},
                {"HomeSave", "Ви зберегли поточне розташування як ваш будинок!"},
                {"HomeNoFoundation", "Використовувати місцезнаходження як будинок дозволено тільки на фундаменті!"},
                {"HomeFoundationNotOwned", "Ви не можете використовувати команду home у чужому домі."},
                {"HomeFoundationUnderneathFoundation", "Ви не можете використовувати команду home на фундаменті, що знаходиться під іншим фундаментом."},
                {"HomeFoundationNotFriendsOwned", "Ви, або ваш друг, повинні бути власником будинку, щоб використати команду home!"},
                {"HomeRemovedInvalid", "Ваш будинок '{0}' був видалений тому, що не на фундаменті або у фундаменту новий власник!"},
                {"HighWallCollision", "Зіткнення Високих Стін!"},
                {"HomeRemovedDestroyed", "Ваш будинок '{0}' видалено, оскільки він більше не існує!"},
                {"HomeRemovedInsideBlock", "Ваш будинок '{0}' був видалений, тому що всередині фундаменту!"},
                {"HomeRemove", "Ви видалили свій будинок {0}!"},
                {"HomeDelete", "Ви видалили будинок '{1}', що належить {0}!"},
                {"HomeList", "Доступні такі будинки:"},
                {"HomeListEmpty", "Ви не зберегли жодного будинку!"},
                {"HomeMaxLocations", "Неможливо встановити тут ваш будинок, ви досягли ліміту в {0} будинків!"},
                {"HomeQuota", "Ви встановили {0} з {1} максимально можливих будинків!"},
                {"HomeTugboatNotAllowed", "You are not allowed to sethome on tugboats."},
                {"HomeTPStarted", "Телепортація до вашого будинку {0} через {1} секунд!"},
                {"PayToTown", "Стандартний платіж {0} поширюється на всі телепорти до міста!"},
                {"PayToTPR", "Стандартний платіж {0} поширюється на всі tpr'и!"},
                {"HomeTPCooldown", "Ваш телепорт перезаряджається. Вам необхідно почекати {0} до наступної телепортації."},
                {"HomeTPCooldownBypass", "Ваш телепорт був на перезарядженні. Ви обрали уникнути очікування, сплативши {0} з вашого балансу."},
                {"HomeTPCooldownBypassF", "Ваш телепорт перезаряджається. У вас недостатньо коштів - щоб уникнути очікування."},
                {"HomeTPCooldownBypassP", "Ви можете вибрати оплатити {0} щоб уникнути очікування перезаряджання." },
                {"HomeTPCooldownBypassP2", "Введіть <color=yellow>/home \"назва будинку\" {0}</color>." },
                {"HomeTPLimitReached", "Ви вичерпали щоденний ліміт {0} телепортацій сьогодні!"},
                {"HomeTPAmount", "У вас залишилось {0} телепортацій додому сьогодні!"},
                {"HomesListWiped", "Ви очистили всі місця, збережені як будинок!"},
                {"HomeTPBuildingBlocked", "Ви не можете зберегти місце розташування як будинок, якщо у вас немає прав на будівництво в цій зоні!"},
                {"HomeTPSwimming", "Ви не можете встановлювати місце розташування в якості будинку поки пливете!"},
                {"HomeTPCrafting", "Ви не можете встановлювати місце розташування як будинок в процесі крафту!"},
                {"Request", "Ви запросили телепортацію до {0}!"},
                {"RequestUI", "<size=14><color=#FFA500>TP Request:</color> {0}</size>"},
                {"RequestTarget", "{0} запросив телепортацію до вас! Використовуйте <color=yellow>/tpa</color>, щоб прийняти!"},
                {"RequestTargetOff", "Ваш запит було скасовано, оскільки ціль зараз не в мережі." },
                {"RequestAccept", "<size=12>Принять</size>" },
                {"RequestReject", "<size=12>Отказаться</size>" },
                {"TPR_NoClan_NoFriend_NoTeam", "Ця команда доступна лише друзям, учасникам команди або клану!"},
                {"PendingRequest", "У вас вже є активний запит, скасуйте його, чекайте на підтвердження, або скасування по таймууту!"},
                {"PendingRequestTarget", "У гравця, до якого ви хочете телепортуватися, вже є активний запит, спробуйте пізніше!"},
                {"NoPendingRequest", "Ви не маєте активних запитів на телепортацію!"},
                {"Accept", "{0} прийняв ваш запит! Телепортація через {1} секунд!"},
                {"AcceptTarget", "Ви отримали запит на телепортацію {0}!"},
                {"AcceptToggleOff", "Ви вимкнули автоматичне /tpa!"},
                {"AcceptToggleOn", "Ви ввімкнули автоматичне /tpa!"},
                {"NotAllowed", "Ви не можете використовувати цю команду!"},
                {"Success", "Ви телепортовані до {0}!"},
                {"SuccessTarget", "{0} телепортований до вас!"},
                {"BlockedTeleportTarget", "You can't teleport to user \"{0}\", they have you teleport blocked!"},
                {"Cancelled", "Ваш запит на телепортацію до {0} було скасовано!"},
                {"CancelledTarget", "Запит на телепортацію {0} було скасовано!"},
                {"TPCancelled", "Ваш телепорт скасовано!"},
                {"TPCancelledTarget", "{0} скасував телепортацію!"},
                {"TPYouCancelledTarget", "Ви скасували телепортацію {0}!"},
                {"TimedOut", "{0} не відповів на ваш запит під час!"},
                {"TimedOutTarget", "Ви не вчасно відповіли на запит телепортації від {0}!"},
                {"TargetDisconnected", "{0} відключився, ваша телепортація скасована!"},
                {"TPRCooldown", "Ваші запити на телепортацію на даний момент на перезарядці. Вам необхідно зачекати на {0}, перш ніж надіслати наступний запит."},
                {"TPRCooldownBypass", "Ваші запити на телепортацію були перезаряджені. Ви обрали уникнути очікування, сплативши {0} з вашого балансу."},
                {"TPRCooldownBypassF", "Ваші запити на телепортацію на даний момент на перезарядці. У вас недостатньо коштів - щоб уникнути очікування."},
                {"TPRCooldownBypassP", "Ви можете вибрати оплатити {0} щоб уникнути очікування перезаряджання." },
                {"TPMoney", "{0} списано з вашого облікового запису!"},
                {"TPNoMoney", "У вас немає жодного облікового запису {0}!"},
                {"TPRCooldownBypassP2", "Напишіть <color=yellow>/tpr {0}</color>." },
                {"TPRCooldownBypassP2a", "Напишіть <color=yellow>/tpr \"ім'я гравця\" {0}</color>." },
                {"TPRLimitReached", "Ви вичерпали щоденний ліміт {0} запитів на телепортацію сьогодні!"},
                {"TPRAmount", "У вас залишилось {0} запитів на телепортацію на сьогодні!"},
                {"TPRTarget", "Ваша мета зараз не доступна!"},
                {"TPDead", "Ви не можете телепортуватися, поки мертві!"},
                {"TPWounded", "Ви не можете телепортуватися, будучи пораненим!"},
                {"TPTooCold", "Вам надто холодно для телепортації!"},
                {"TPTooHot", "Вам дуже жарко для телепортації!"},
                {"TPTugboat", "Вы не можете телепортироваться на этой лодке!"},
                {"TPBoat", "Ви не можете телепортуватися, перебуваючи на човні!"},
                {"TPHostile", "Ви не можете телепортуватися в Місто NPC або Табір бандитів, поки ворожі!"},
                {"TPJunkpile", "Ви не можете телепортуватися з купи сміття"},
                {"HostileTimer", "Телепорт буде доступний через {0} хвилин."},
                {"TPMounted", "Ви не можете телепортуватись, коли сидите!"},
                {"TPBuildingBlocked", "Ви не можете телепортуватися, перебуваючи у зоні блокування будівництва!"},
                {"TPAboveWater", "Ви не можете телепортуватися, перебуваючи над водою!"},
                {"TPUnderWater", "Ви не можете телепортуватися під воду!"},
                {"TPTargetBuildingBlocked", "Ви не можете телепортуватися до зони, де блоковано будівництво!"},
                {"TPTargetInsideBlock", "Ви не можете телепортуватися у фундамент!"},
                {"TPTargetInsideRock", "Ви не можете телепортуватись у скелю!"},
                {"TPSwimming", "Ви не можете телепортуватися, поки пливете!"},
                {"TPCargoShip", "Ви не можете телепортуватись з вантажного корабля!"},
                {"TPOilRig", "Ви не можете телепортуватися з нафтової вежі!"},
                {"TPExcavator", "Ви не можете телепортувати з екскаватора!"},
                {"TPHotAirBalloon", "Ви не можете телепортуватися з, або на повітряну кулю!"},
                {"TPLift", "Ви не можете телепортуватися, перебуваючи в ліфті або підйомнику!"},
                {"TPBucketLift", "Ви не можете телепортуватися, перебуваючи в ковшовому підйомнику!"},
                {"TPRegLift", "Ви не можете телепортуватися, перебуваючи в ліфті!"},
                {"TPSafeZone", "Ви не можете телепортуватися із безпечної зони!"},
                {"TPFlagZone", "Ви не можете телепортуватися із цієї зони!"},
                {"TPNoEscapeBlocked", "Ви не можете телепортуватися поки активне блокування!"},
                {"TPCrafting", "Ви не можете телепортуватись у процесі крафту!"},
                {"TPBlockedItem", "Ви не можете телепортуватися поки що несете: {0}!"},
                {"TooCloseToMon", "Ви не можете телепортуватися так близько до {0}!"},
                {"TPHomeSafeZoneOnly", "Ви можете телепортуватися додому лише з безпечної зони!" },
                {"TooCloseToCave", "Ви не можете телепортуватись так близько до печери!"},
                {"HomeTooCloseToCave", "Ви не можете зберегти розташування як будинок так близько до печери!"},
                {"HomeTooCloseToMon", "Ви не можете зберегти розташування як будинок так близько до пам'ятника!"},
                {"CannotTeleportFromHome", "Ви повинні вийти з вашої бази, перш ніж телепортувати!"},
                {"WaitGlobalCooldown", "Ви повинні почекати, поки ваш глобальний телепорт перезаряджається!" },

                {"DM_TownTP", "Ви телепортовані в {0}!"},
                {"DM_TownTPNoLocation", "Розташування <color=yellow>{0}</color> на даний момент не встановлено!"},
                {"DM_TownTPDisabled", "<color=yellow>{0}</color> в даний момент вимкнено у файлі налаштувань!"},
                {"DM_TownTPLocation", "Ви встановили розташування <color=yellow>{0}</color> в {1}!"},
                {"DM_TownTPCreated", "Ви створили команду: <color=yellow>{0}</color>"},
                {"DM_TownTPRemoved", "Ви видалили команду: <color=yellow>{0}</color>"},
                {"DM_TownTPDoesNotExist", "Команда не існує: <color=yellow>{0}</color>"},
                {"DM_TownTPExists", "Команда <color=yellow>{0}</color> вже існує!"},
                {"DM_TownTPLocationsCleared", "Ви очистили всі місця для {0}!"},
                {"DM_TownTPStarted", "Телепортація в {0} через {1} секунд!"},
                {"DM_TownTPCooldown", "Ваш телепорт перезаряджається. Вам необхідно почекати {0} до наступної телепортації."},
                {"DM_TownTPCooldownBypass", "Ваш телепорт був на перезарядженні. Ви обрали уникнути очікування, сплативши {0} з вашого балансу."},
                {"DM_TownTPCooldownBypassF", "Ваш телепорт перезаряджається. У вас недостатньо коштів ({0}), щоб уникнути очікування."},
                {"DM_TownTPCooldownBypassP", "Ви можете вибрати оплатити {0} щоб уникнути очікування перезаряджання." },
                {"DM_TownTPCooldownBypassP2", "Введіть <color=yellow>/{0} {1}</color>" },
                {"DM_TownTPLimitReached", "Ви вичерпали щоденний ліміт {0} телепортацій сьогодні! Ви повинні почекати {1} до наступної телепортації."},
                {"DM_TownTPAmount", "У вас залишилось {0} телепортацій <color=yellow>{1}</color> сьогодні!"},

                {"Days", "днів" },
                {"Hours", "годин" },
                {"Minutes", "хвилин" },
                {"Seconds", "секунд" },

                {"Interrupted", "Вашу телепортацію було перервано!"},
                {"InterruptedTarget", "Телепортація {0} була перервана!"},
                {"Unlimited", "Не обмежено"},
                {
                    "TPInfoGeneral", string.Join(NewLine, new[]
                    {
                        "Будь ласка, вкажіть модуль, про який ви хочете переглянути інформацію.",
                        "Доступні модулі: ",
                    })
                },
                {
                    "TPHelpGeneral", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/tpinfo</color> - Відображає ліміти та перезарядження.",
                        "Будь ласка, вкажіть модуль, за яким ви хочете отримати допомогу.",
                        "Доступні модулі: ",
                    })
                },
                {
                    "TPHelpadmintp", string.Join(NewLine, new[]
                    {
                        "Як адмін, ви маєте доступ до наступних команд:",
                        "<color=yellow>/tp \"ім'я гравця\"</color> - Телепортує вас до вказаного гравця.",
                        "<color=yellow>/tp \"ім'я гравця\" \"ім'я гравця 2\"</color> - Телепортує гравця з ім'ям 'ім'я гравця' до гравця 'ім'я гравця 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортує вас до зазначених координат.",
                        "<color=yellow>/tpl</color> - Відображає список збережених позицій.",
                        "<color=yellow>/tpl \"назва розташування\"</color> - Телепортує вас у збережене місцезнаходження.",
                        "<color=yellow>/tpsave \"назва розташування\"</color> - Зберігає ваше поточне розташування з вказаною назвою.",
                        "<color=yellow>/tpremove \"назва розташування\"</color> - Видаляє розташування зі списку збережених.",
                        "<color=yellow>/tpb</color> - Телепортує вас назад на місце, де ви були перед телепортацією.",
                        "<color=yellow>/home radius \"радіус\"</color> - Знайти всі будинки в радіусі.",
                        "<color=yellow>/home delete \"ім'я гравця або ID\" \"назва будинку\"</color> - Видаляє будинок із вказаним ім'ям, що належить вказаному гравцю.",
                        "<color=yellow>/home tp \"ім'я гравця або ID\" \"назва будинку\"</color> - Телепортує вас до будинку гравця із зазначеною назвою, що належить вказаному гравцю.",
                        "<color=yellow>/home homes \"ім'я гравця або ID\"</color> - Відображає список усіх будинків, що належать зазначеному гравцеві."
                    })
                },
                {
                    "TPHelphome", string.Join(NewLine, new[]
                    {
                        "Використовуючи наступні команди, ви можете встановити місце розташування вашого будинку, щоб потім до нього телепортуватися:",
                        "<color=yellow>/home add \"назва будинку\"</color> - Зберігає ваше поточне розташування як ваш будинок із зазначеною назвою.",
                        "<color=yellow>/home list</color> - Відображає список усіх місць розташування, збережених вами як будинок.",
                        "<color=yellow>/home remove \"назва будинку\"</color> - Видаляє розташування збереженого будинку з вказаною назвою.",
                        "<color=yellow>/home \"назва будинку\"</color> - Телепортує вас у місцезнаходження будинку з вказаною назвою."
                    })
                },
                {
                    "TPHelptpr", string.Join(NewLine, new[]
                    {
                        "Використовуючи ці команди, ви можете надіслати запит на телепортацію до гравця або прийняти чийсь запит:",
                        "<color=yellow>/tpr \"ім'я гравця\"</color> - Надсилає запит на телепортацію гравцю із зазначеним ім'ям.",
                        "<color=yellow>/tpa</color> - Прийняти запит на телепортацію.",
                        "<color=yellow>/tpat</color> - Увімк./Вимк. автоматичне прийняття запитів на телепортацію до вас /tpa.",
                        "<color=yellow>/tpc</color> - Скасувати запит на телепортацію."
                    })
                },
                {
                    "TPSettingsGeneral", string.Join(NewLine, new[]
                    {
                        "Будь ласка, вкажіть модуль, налаштування якого потрібно переглянути.",
                        "Доступні модулі:",
                    })
                },
                {
                    "TPSettingshome", string.Join(NewLine, new[]
                    {
                        "Система будинків на даний момент має такі включені параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}",
                        "Кількість збережених будинків: {2}"
                    })
                },
                {
                    "TPSettingsbandit", string.Join(NewLine, new[]
                    {
                        "Система Табір бандитів наразі має такі включені параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}"
                    })
                },
                {
                    "TPSettingsoutpost", string.Join(NewLine, new[]
                    {
                        "Система Місто NPC в даний момент має наступні параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}"
                    })
                },
                {
                    "TPSettingstpr", string.Join(NewLine, new[]
                    {
                        "Система TPR в даний момент має наступні параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}"
                    })
                },
                {
                    "TPSettingstown", string.Join(NewLine, new[]
                    {
                        "У Системі Міст включені такі параметри:",
                        "Час між телепортами: {0}",
                        "Щоденний ліміт телепортацій: {1}"
                    })
                },
                {
                    "TPSettingsdynamic", string.Join(NewLine, new[]
                    {
                        "У системі {0} включені такі параметри:",
                        "Час між телепортами: {1}",
                        "Щоденний ліміт телепортацій: {2}"
                    })
                },

                {"TPT_True", "enabled"},
                {"TPT_False", "disabled"},
                {"TPT_clan", "{1} clan has been {0}."},
                {"TPT_friend", "{1} friend has been {0}."},
                {"TPT_team", "{1} team has been {0}."},
                {"NotValidTPT", "Not valid, player is not"},
                {"NotValidTPTFriend", " a friend!"},
                {"NotValidTPTTeam", " on your team!"},
                {"NotValidTPTClan", " in your clan!"},

                {"TPTInfo", "{4} auto accepts teleport requests.\n<color={5}>Green</color> = <color={5}>Enabled</color>\n<color={6}>Red</color> = <color={6}>Disabled</color>\n\n/{0} <color={1}>clan</color> - Toggle {4} for clan members/allies.\n/{0} <color={2}>team</color> - Toggle {4} for teammates.\n/{0} <color={3}>friend</color> - Toggle {4} for friends."},

                {"PlayerNotFound", "Вказаного гравця не виявлено, будь ласка, спробуйте ще раз!"},
                {"MultiplePlayers", "Знайдено декілька гравців: {0}"},
                {"CantTeleportToSelf", "Ви не можете телепортуватися до себе!"},
                {"CantTeleportPlayerToSelf", "Ви не можете телепортувати гравця до себе!"},
                {"TeleportPendingTPC", "Ви не можете ініціювати телепортацію, поки ви маєте активний запит! Використовуйте <color=yellow>/tpc</color>, щоб скасувати його."},
                {"TeleportPendingTarget", "Ви не можете надіслати запит до того, хто в процесі телепортації!"},
                {"LocationExists", "Розташування з такою назвою вже існує в {0}!"},
                {"LocationExistsNearby", "Розташування з назвою {0} вже існує поряд із поточною позицією!"},
                {"LocationNotFound", "Не знайдено місцезнаходження з такою назвою!"},
                {"NoPreviousLocationSaved", "Попереднє розташування не збережене!"},
                {"HomeExists", "Ви вже зберегли будинок із такою назвою!"},
                {"HomeExistsNearby", "Будинок з назвою {0} вже існує поряд із поточною позицією!"},
                {"HomeNotFound", "Будинок з такою назвою не знайдено!"},
                {"InvalidCoordinates", "Ви вказали неправильні координати!"},
                {"InvalidHelpModule", "Вказано неправильний модуль!"},
                {"InvalidCharacter", "Ви використовували неприпустимий символ, обмежтеся літерами від a до z та цифрами."},
                {
                    "SyntaxCommandTP", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tp</color> можливе лише так:",
                        "<color=yellow>/tp \"ім'я гравця\"</color> - Телепортує вас до вказаного гравця.",
                        "<color=yellow>/tp \"ім'я гравця\" \"ім'я гравця 2\"</color> - Телепортує гравця з ім'ям 'ім'я гравця' до гравця 'ім'я гравця 2'.",
                        "<color=yellow>/tp x y z</color> - Телепортує вас до зазначених координат.",
                        "<color=yellow>/tp \"ім'я гравця\" x y z</color> - Телепортує гравця з ім'ям 'ім'я гравця' до зазначених координат."
                    })
                },
                {
                    "SyntaxCommandTPL", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpl</color> можливе лише так:",
                        "<color=yellow>/tpl</color> - Відображає список збережених позицій.",
                        "<color=yellow>/tpl \"назва розташування\"</color> - Телепортує вас у місце із зазначеною назвою."
                    })
                },
                {
                    "SyntaxCommandTPSave", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpsave</color> можливе лише так:",
                        "<color=yellow>/tpsave \"назва розташування\"</color> - Зберігає ваше поточне розташування з вказаною назвою."
                    })
                },
                {
                    "SyntaxCommandTPRemove", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpremove</color> можливе лише так:",
                        "<color=yellow>/tpremove \"назва розташування\"</color> - Видаляє розташування за вказаною назвою."
                    })
                },
                {
                    "SyntaxCommandTPN", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpn</color> можливе лише так:",
                        "<color=yellow>/tpn \"ім'я гравця\"</color> - Телепортує вас на відстань за замовчуванням позаду гравця із зазначеним ім'ям.",
                        "<color=yellow>/tpn \"ім'я гравця\" \"відстань\"</color> - Телепортує вас на вказану відстань позаду гравця із вказаним ім'ям."
                    })
                },
                {
                    "SyntaxCommandSetHome", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home add</color> можливе лише так:",
                        "<color=yellow>/home add \"назва\"</color> - Зберігає ваше поточне розташування як ваш будинок із зазначеною назвою."
                    })
                },
                {
                    "SyntaxCommandRemoveHome", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home remove</color> можливе лише так:",
                        "<color=yellow>/home remove \"назва\"</color> - Видаляє розташування будинку з вказаною назвою."
                    })
                },
                {
                    "SyntaxCommandHome", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home</color> можливе лише так:",
                        "<color=yellow>/home \"назва\"</color> - Телепортує вас у ваш будинок із зазначеною назвою.",
                        "<color=yellow>/home \"назва\" pay</color> - Телепортує вас у ваш будинок із зазначеною назвою, уникаючи перезарядки, заплативши за це.",
                        "<color=yellow>/home add \"назва\"</color> - Зберігає ваше поточне розташування як ваш будинок із зазначеною назвою.",
                        "<color=yellow>/home list</color> - Відображає список усіх місць розташування, збережених вами як будинок.",
                        "<color=yellow>/home remove \"назва\"</color> - Видаляє розташування будинку з вказаною назвою."
                    })
                },
                {
                    "SyntaxCommandHomeAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/home radius \"радіус\"</color> - Відображає список усіх будинків у радіусі(10).",
                        "<color=yellow>/home delete \"ім'я гравця або ID\" \"назва\"</color> - Видаляє будинок із зазначеною назвою, що належить вказаному гравцю.",
                        "<color=yellow>/home tp \"ім'я гравця або ID\" \"назва\"</color> - Телепортує вас до будинку із зазначеною назвою, що належить вказаному гравцю.",
                        "<color=yellow>/home homes \"ім'я гравця або ID\"</color> - Відображає список усіх будинків, що належать вказаному гравцю."
                    })
                },
                {
                    "SyntaxCommandTown", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/town</color> можливе лише так:",
                        "<color=yellow>/town</color> - Телепортує вас до міста.",
                        "<color=yellow>/town pay</color> - Телепортує вас до міста з оплатою штрафу."
                    })
                },
                {
                    "SyntaxCommandTownAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/town set</color> - Зберігає поточне розташування як Місто.",
                    })
                },
                {
                    "SyntaxCommandOutpost", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/outpost</color> можливе лише так:",
                        "<color=yellow>/outpost</color> - Телепортирует вас в Город NPC.",
                        "<color=yellow>/outpost pay</color> - Телепортує вас у Місто NPC з оплатою штрафу."
                    })
                },
                {
                    "SyntaxCommandOutpostAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/outpost set</color> - Зберігає поточне розташування як Місто NPC.",
                    })
                },
                {
                    "SyntaxCommandBandit", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/bandit</color> можливе лише так:",
                        "<color=yellow>/bandit</color> - Телепортує вас до Табору бандитів.",
                        "<color=yellow>/bandit pay</color> - Телепортує вас до Табору бандитів з оплатою штрафу."
                    })
                },
                {
                    "SyntaxCommandBanditAdmin", string.Join(NewLine, new[]
                    {
                        "<color=yellow>/bandit set</color> - Зберігає поточне розташування як Табір бандитів.",
                    })
                },
                {
                    "SyntaxCommandHomeDelete", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home delete</color> можливе лише так:",
                        "<color=yellow>/home delete \"ім'я гравця або ID\" \"назва\"</color> - Видаляє будинок із зазначеною назвою, що належить вказаному гравцю."
                    })
                },
                {
                    "SyntaxCommandHomeAdminTP", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home tp</color> можливе лише так:",
                        "<color=yellow>/home tp \"ім'я гравця або ID\" \"назва\"</color> - Телепортує вас до будинку гравця із зазначеною назвою, що належить вказаному гравцю."
                    })
                },
                {
                    "SyntaxCommandHomeHomes", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home homes</color> можливе лише так:",
                        "<color=yellow>/home homes \"ім'я гравця або ID\"</color> - Відображає список усіх будинків, що належать вказаному гравцю."
                    })
                },
                {
                    "SyntaxCommandListHomes", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/home list</color> можливе лише так:",
                        "<color=yellow>/home list</color> - Відображає список усіх місць розташування, збережених вами як будинок."
                    })
                },
                {
                    "SyntaxCommandTPR", string.Join(NewLine, new[]
                    {
                        "Сталася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpr</color> можливе лише так:",
                        "<color=yellow>/tpr \"ім'я гравця або ID\"</color> - Надсилає вказаному гравцеві запит на телепортацію."
                    })
                },
                {
                    "SyntaxCommandTPA", string.Join(NewLine, new[]
                    {
                        "Відбулася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpa</color> можливе лише таким чином:",
                        "<color=yellow>/tpa</color> - Прийняти вхідний запит на телепортацію."
                    })
                },
                {
                    "SyntaxCommandTPC", string.Join(NewLine, new[]
                    {
                        "Відбулася синтаксична помилка!",
                        "Використання команди <color=yellow>/tpc</color> можливе лише таким чином:",
                        "<color=yellow>/tpc</color> - Скасувати запит на телепортацію."
                    })
                },
                {
                    "SyntaxConsoleCommandToPos", string.Join(NewLine, new[]
                    {
                        "Відбулася синтаксична помилка!",
                        "Використання консольної команди <color=orange>teleport.topos</color> можливе лише таким чином:",
                        " > <color=orange>teleport.topos \"ім'я гравця\" x y z</color>"
                    })
                },
                {
                    "SyntaxConsoleCommandToPlayer", string.Join(NewLine, new[]
                    {
                        "Відбулася синтаксична помилка!",
                        "Використання консольної команди <color=orange>teleport.toplayer</color> можливе лише таким чином:",
                        " > <color=orange>teleport.toplayer \"ім'я гравця або ID\" \"ім'я гравця 2|id 2\"</color>"
                    })
                },
                {"LogTeleport", "{0} телепортовано до {1}."},
                {"LogTeleportPlayer", "{0} телепортував {1} до {2}."},
                {"LogTeleportBack", "{0} телепортований назад, до попереднього розташування."}
            };

            foreach (var key in config.DynamicCommands.Keys)
            {
                uk[key] = key;
            }

            foreach (var key in monumentMessages)
            {
                uk[key] = key;
            }

            lang.RegisterMessages(uk, this, "uk");
        }

        private void Init()
        {
            Unsubscribe(nameof(OnPlayerRespawn));
            Unsubscribe(nameof(OnPlayerViolation));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerDisconnected));
            InitializeDynamicCommands();
        }

        private string OnPlayerConnected(BasePlayer player)
        {
            var uid = UnityEngine.Random.Range(1000, 9999).ToString();
            var names = BasePlayer.activePlayerList.Select(x => x.displayName);

            while (_ids.ContainsKey(uid) || names.Any(name => name.Contains(uid)))
            {
                uid = UnityEngine.Random.Range(1000, 9999).ToString();
            }

            _ids[uid] = player;
            _players[player] = uid;

            return uid;
        }

        private Dictionary<string, StoredData> _DynamicData = new Dictionary<string, StoredData>();

        public class StoredData
        {
            public Dictionary<ulong, TeleportData> TPData = new Dictionary<ulong, TeleportData>();
            public bool Changed = true;
        }

        private void LoadDataAndPerms()
        {
            dataAdmin = GetFile("Admin");
            try { _Admin = dataAdmin.ReadObject<Dictionary<ulong, AdminData>>(); } catch (Exception ex) { Puts("Admin datafile: {0}", ex); }
            if (_Admin == null) { _Admin = new Dictionary<ulong, AdminData>(); changedAdmin = true; }

            dataHome = GetFile("Home");
            try { _Home = dataHome.ReadObject<Dictionary<ulong, HomeData>>(); } catch (Exception ex) { Puts("Home datafile: {0}", ex); }
            if (_Home == null) { _Home = new Dictionary<ulong, HomeData>(); changedHome = true; }
            if (!config.Home.AllowTugboats) _Home.Values.ToList().ForEach(homeData => { if (homeData?.boats?.Count > 0) { homeData.boats.Clear(); changedHome = true; } });

            dataTPT = GetFile("TPT");
            try { TPT = dataTPT.ReadObject<Dictionary<string, List<string>>>(); } catch { }
            if (TPT == null) { new Dictionary<string, List<string>>(); changedTPT = true; }

            foreach (var entry in config.DynamicCommands)
            {
                if (!entry.Value.Enabled) continue;

                var dcf = GetFile(entry.Key);
                Dictionary<ulong, TeleportData> data = null;

                try
                {
                    data = dcf.ReadObject<Dictionary<ulong, TeleportData>>();
                }
                catch
                {

                }

                if (data == null)
                {
                    data = new Dictionary<ulong, TeleportData>();
                }

                GetSettings(entry.Key).Teleports = _DynamicData[entry.Key] = new StoredData
                {
                    TPData = data,
                    Changed = true
                };
            }

            dataTPR = GetFile("TPR");
            try { _TPR = dataTPR.ReadObject<Dictionary<ulong, TeleportData>>(); } catch (Exception ex) { Puts("TPR: {0}", ex); }
            if (_TPR == null) { _TPR = new Dictionary<ulong, TeleportData>(); changedTPR = true; }

            dataDisabled = GetFile("DisabledCommands");
            try { DisabledCommandData = dataDisabled.ReadObject<DisabledData>(); } catch (Exception ex) { Puts("DC: {0}", ex); }
            if (DisabledCommandData == null) { DisabledCommandData = new DisabledData(); }

            permission.RegisterPermission("nteleportation.locationradiusbypass", this);
            permission.RegisterPermission("nteleportation.ignoreglobalcooldown", this);
            permission.RegisterPermission("nteleportation.norestrictions", this);
            permission.RegisterPermission("nteleportation.globalcooldownvip", this);
            permission.RegisterPermission("nteleportation.tugboatsinterruptbypass", this);
            permission.RegisterPermission("nteleportation.tugboatssethomebypass", this);
            permission.RegisterPermission(PermAdmin, this);
            permission.RegisterPermission(PermFoundationCheck, this);
            permission.RegisterPermission(PermDeleteHome, this);
            permission.RegisterPermission(PermHome, this);
            permission.RegisterPermission(PermHomeHomes, this);
            permission.RegisterPermission(PermImportHomes, this);
            permission.RegisterPermission(PermRadiusHome, this);
            permission.RegisterPermission(PermDisallowTpToMe, this);
            permission.RegisterPermission(PermTp, this);
            permission.RegisterPermission(PermTpB, this);
            permission.RegisterPermission(PermTpR, this);
            permission.RegisterPermission(PermTpA, this);
            permission.RegisterPermission(PermTpConsole, this);
            permission.RegisterPermission(PermTpT, this);
            permission.RegisterPermission(PermTpN, this);
            permission.RegisterPermission(PermTpL, this);
            permission.RegisterPermission(PermTpRemove, this);
            permission.RegisterPermission(PermTpSave, this);
            permission.RegisterPermission(PermWipeHomes, this);
            permission.RegisterPermission(PermCraftHome, this);
            permission.RegisterPermission(PermCraftTpR, this);
            permission.RegisterPermission(PermExempt, this);
            permission.RegisterPermission(PermTpMarker, this);

            CheckPerms(config.Home.VIPCooldowns);
            CheckPerms(config.Home.VIPCountdowns);
            CheckPerms(config.Home.VIPDailyLimits);
            CheckPerms(config.Home.VIPHomesLimits);
            CheckPerms(config.TPR.VIPCooldowns);
            CheckPerms(config.TPR.VIPCountdowns);
            CheckPerms(config.TPR.VIPDailyLimits);
            CheckPerms(config.Settings.TPB.Countdowns);

            foreach (var entry in config.DynamicCommands)
            {
                RegisterCommand(entry.Key, entry.Value, false);
            }
        }

        private bool CanBypassRestrictions(string userid) => permission.UserHasPermission(userid, "nteleportation.norestrictions");

        private void RegisterCommand(string command, string callback, string perm = null)
        {
            if (!string.IsNullOrEmpty(command) && !command.Equals("null", StringComparison.OrdinalIgnoreCase))
            {
                AddCovalenceCommand(command, callback, perm);
            }
        }

        private void UnregisterCommand(string command)
        {
            covalence.UnregisterCommand(command, this);
        }

        private void RegisterCommand(string key, TownSettings settings, bool justCreated)
        {
            CheckPerms(settings.VIPCooldowns);
            CheckPerms(settings.VIPCountdowns);
            CheckPerms(settings.VIPDailyLimits);

            string tpPerm = $"{Name}.tp{key}".ToLower();
            string craftPerm = $"{Name}.craft{key}".ToLower();

            if (!permission.PermissionExists(tpPerm, this))
            {
                permission.RegisterPermission(tpPerm, this);
            }

            if (!permission.PermissionExists(craftPerm))
            {
                permission.RegisterPermission(craftPerm, this);
            }

            if (justCreated)
            {
                settings.Teleports = _DynamicData[key] = new StoredData();
            }
        }

        private DynamicConfigFile GetFile(string name)
        {
            var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? $"{Name}{name}" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}{name}";
            var file = Interface.Oxide.DataFileSystem.GetFile(fileName);
            file.Settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
            file.Settings.Converters = new JsonConverter[] { new UnityVector3Converter(), new CustomComparerDictionaryCreationConverter<string>(StringComparer.OrdinalIgnoreCase) };
            return file;
        }

        private void SetGlobalCooldown(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "nteleportation.ignoreglobalcooldown"))
            {
                return;
            }
            if (config.Settings.GlobalVIP > 0f && permission.UserHasPermission(player.UserIDString, "nteleportation.globalcooldownvip"))
            {
                ulong userid = player.userID;
                TeleportCooldowns[userid] = Time.time + config.Settings.GlobalVIP;
                timer.Once(config.Settings.GlobalVIP, () => TeleportCooldowns.Remove(userid));
            }
            else if (config.Settings.Global > 0f)
            {
                ulong userid = player.userID;
                TeleportCooldowns[userid] = Time.time + config.Settings.Global;
                timer.Once(config.Settings.Global, () => TeleportCooldowns.Remove(userid));
            }
        }

        private float GetGlobalCooldown(BasePlayer player)
        {
            float cooldown;
            if (!TeleportCooldowns.TryGetValue(player.userID, out cooldown))
            {
                return 0f;
            }

            return cooldown - Time.time;
        }

        private bool IsEmptyMap()
        {
            foreach (var b in BuildingManager.server.buildingDictionary)
            {
                if (b.Value.HasDecayEntities() && b.Value.decayEntities.ToList().Exists(de => de != null && de.OwnerID.IsSteamId()))
                {
                    return false;
                }
            }
            return true;
        }

        private void CheckNewSave()
        {
            if (!newSave && !IsEmptyMap())
            {
                return;
            }

            bool changed = false;
            bool cleared = false;

            if (config.Settings.WipeOnUpgradeOrChange)
            {
                if (_Home.Count > 0)
                {
                    cleared = true;
                    _Home.Clear();
                    changedHome = true;
                }

                if (_TPR.Count > 0)
                {
                    cleared = true;
                    _TPR.Clear();
                    changedTPR = true;
                }

                foreach (var entry in config.DynamicCommands.ToList())
                {
                    if (entry.Value.Location != Vector3.zero || entry.Value.Locations.Count > 0)
                    {
                        entry.Value.Location = Vector3.zero;
                        entry.Value.Locations.Clear();
                        cleared = true;
                    }
                }

                if (cleared) Puts("Rust was upgraded or map changed - clearing homes and all locations!");
            }
            else
            {
                Puts("Rust was upgraded or map changed - homes, town, islands, outpost, bandit, etc may be invalid!");
            }

            foreach (var entry in config.DynamicCommands.ToList())
            {
                if (!string.IsNullOrEmpty(entry.Value.MonumentMarkerName))
                {
                    if (TrySetNewTownPosition(entry.Value))
                    {
                        changed = true;
                    }
                }
            }

            if (cleared || changed)
            {
                SaveConfig();
            }
        }

        bool TrySetNewTownPosition(TownSettings town)
        {
            foreach (var prefab in World.Serialization.world.prefabs)
            {
                if (prefab.id == 1724395471 && prefab.category == town.MonumentMarkerName)
                {
                    var pos = new Vector3(prefab.position.x, prefab.position.y, prefab.position.z);
                    try { pos += town.MonumentMarkerNameOffset.ToVector3(); } catch { }
                    if (pos.y < TerrainMeta.HeightMap.GetHeight(pos))
                    {
                        Puts("Invalid position set under the map for {0} {1}", prefab.category, pos);
                        Puts("You can specify an offset in the config to correct this:");
                        Puts("Set Position From Monument Marker Name Offset");
                        Puts("e.g: 0 15 0");
                        return false;
                    }
                    else
                    {
                        Puts($"Set {prefab.category} teleport position to: {pos}");
                        town.Locations.Clear();
                        town.Location = pos;
                        town.Locations.Add(pos);
                        return true;
                    }
                }
            }
            return false;
        }

        void OnServerInitialized()
        {
            if (config.Settings.Interrupt.Hurt || config.Settings.Interrupt.Cold || config.Settings.Interrupt.Hot)
            {
                Subscribe(nameof(OnEntityTakeDamage));
            }

            if (config.Settings.RespawnOutpost)
            {
                Subscribe(nameof(OnPlayerRespawn));
            }

            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnPlayerDisconnected));

            boundary = TerrainMeta.Size.x / 2;

            foreach (var item in config.Settings.BlockedItems)
            {
                var definition = ItemManager.FindItemDefinition(item.Key);
                if (definition == null)
                {
                    Puts("Blocked item not found: {0}", item.Key);
                    continue;
                }
                ReverseBlockedItems[definition.itemid] = item.Value;
            }

            LoadDataAndPerms();
            CheckNewSave();
            AddCovalenceCommands();
            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
            _cmc = ServerMgr.Instance.StartCoroutine(SetupMonuments());
        }

        private void AddCovalenceCommands()
        {
            if (config.Settings.TPREnabled)
            {
                AddCovalenceCommand("tpr", nameof(CommandTeleportRequest));
            }
            if (config.Settings.HomesEnabled)
            {
                AddCovalenceCommand("home", nameof(CommandHome));
                AddCovalenceCommand("sethome", nameof(CommandSetHome));
                AddCovalenceCommand("listhomes", nameof(CommandListHomes));
                AddCovalenceCommand("removehome", nameof(CommandRemoveHome));
                AddCovalenceCommand("radiushome", nameof(CommandHomeRadius));
                AddCovalenceCommand("deletehome", nameof(CommandHomeDelete));
                AddCovalenceCommand("tphome", nameof(CommandHomeAdminTP));
                AddCovalenceCommand("homehomes", nameof(CommandHomeHomes));
            }
            AddCovalenceCommand("tnt", nameof(CommandToggle));
            AddCovalenceCommand("tp", nameof(CommandTeleport));
            AddCovalenceCommand("tpn", nameof(CommandTeleportNear));
            AddCovalenceCommand("tpl", nameof(CommandTeleportLocation));
            AddCovalenceCommand("tpsave", nameof(CommandSaveTeleportLocation));
            AddCovalenceCommand("tpremove", nameof(CommandRemoveTeleportLocation));
            AddCovalenceCommand("tpb", nameof(CommandTeleportBack));
            AddCovalenceCommand("tpa", nameof(CommandTeleportAccept));
            AddCovalenceCommand("tpat", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("tpt", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("atp", nameof(CommandTeleportAcceptToggle));
            AddCovalenceCommand("wipehomes", nameof(CommandWipeHomes));
            AddCovalenceCommand("tphelp", nameof(CommandTeleportHelp));
            AddCovalenceCommand("tpinfo", nameof(CommandTeleportInfo));
            AddCovalenceCommand("tpc", nameof(CommandTeleportCancel));
            AddCovalenceCommand("teleport.toplayer", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.topos", nameof(CommandTeleportII));
            AddCovalenceCommand("teleport.importhomes", nameof(CommandImportHomes));
            AddCovalenceCommand("spm", nameof(CommandSphereMonuments));
            AddCovalenceCommand("nteleportationinfo", nameof(CommandPluginInfo));
        }

        void OnNewSave(string strFilename)
        {
            newSave = true;
        }

        void OnServerSave()
        {
            if (config.Settings.SaveDelay > 0)
            {
                timer.Once((float)config.Settings.SaveDelay, SaveAllInstant);
            }
            else
            {
                SaveAllInstant();
            }
        }

        void SaveAllInstant()
        {
            SaveTeleportsAdmin();
            SaveTeleportsHome();
            SaveTeleportsTPR();
            SaveTeleportsTPT();
            SaveTeleportsTown();
        }

        void OnServerShutdown() => SaveAllInstant();

        void Unload()
        {
            SaveAllInstant();
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                DestroyTeleportRequestCUI(current);
            }
            if (_cmc != null)
            {
                ServerMgr.Instance.StopCoroutine(_cmc);
                _cmc = null;
            }
        }

        void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || player.IsNpc || !player.userID.IsSteamId() || hitInfo == null) return;
            if (hitInfo.damageTypes.Has(DamageType.Fall) && teleporting.ContainsKey(player.userID))
            {
                hitInfo.damageTypes = new DamageTypeList();
                RemoveProtections(player.userID);
                if (teleporting.Count == 0) Unsubscribe(nameof(OnPlayerViolation));
                return;
            }
            if (hitInfo.damageTypes.Has(DamageType.Suicide) && insideTerrainViolations.Contains(player.userID))
            {
                hitInfo.damageTypes = new DamageTypeList();
                return;
            }
            if (permission.UserHasPermission(player.userID.ToString(), PermExempt)) return;
            TeleportTimer teleportTimer;
            if (!TeleportTimers.TryGetValue(player.userID, out teleportTimer)) return;
            DamageType major = hitInfo.damageTypes.GetMajorityDamageType();

            NextTick(() =>
            {
                if (!player || !hitInfo.hasDamage) return;
                if (major == DamageType.Cold)
                {
                    if (config.Settings.Interrupt.Cold && player.metabolism.temperature.value <= config.Settings.MinimumTemp)
                    {
                        SendInterruptMessage(teleportTimer, player, "TPTooCold");
                    }
                }
                else if (major == DamageType.Heat)
                {
                    if (config.Settings.Interrupt.Hot && player.metabolism.temperature.value >= config.Settings.MaximumTemp)
                    {
                        SendInterruptMessage(teleportTimer, player, "TPTooHot");
                    }
                }
                else if (config.Settings.Interrupt.Hurt)
                {
                    SendInterruptMessage(teleportTimer, player, "Interrupted");
                }
            });
        }

        private void SendInterruptMessage(TeleportTimer teleportTimer, BasePlayer player, string key)
        {
            PrintMsgL(teleportTimer.OriginPlayer, key);
            if (teleportTimer.TargetPlayer != null)
            {
                PrintMsgL(teleportTimer.TargetPlayer, "InterruptedTarget", teleportTimer.OriginPlayer?.displayName);
            }
            teleportTimer.Timer.Destroy();
            TeleportTimers.Remove(player.userID);
        }

        private List<ulong> insideTerrainViolations = new List<ulong>();

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.InsideTerrain && teleporting.ContainsKey(player.userID))
            {
                if (!insideTerrainViolations.Contains(player.userID))
                {
                    insideTerrainViolations.Add(player.userID);
                }
                return true;
            }

            return null;
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!player || !teleporting.ContainsKey(player.userID)) return;
            ulong userID = player.userID;
            timer.Once(3f, () =>
            {
                RemoveProtections(userID);
                if (teleporting.Count == 0) Unsubscribe(nameof(OnPlayerViolation));
            });
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (!player) return;
            Timer reqTimer;
            if (PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                var originPlayer = PlayersRequests[player.userID];
                if (originPlayer)
                {
                    PlayersRequests.Remove(originPlayer.userID);
                    PrintMsgL(originPlayer, "RequestTargetOff");
                }
                reqTimer.Destroy();
                PendingRequests.Remove(player.userID);
                PlayersRequests.Remove(player.userID);
            }
            TeleportTimer teleportTimer;
            if (TeleportTimers.TryGetValue(player.userID, out teleportTimer))
            {
                teleportTimer.Timer.Destroy();
                TeleportTimers.Remove(player.userID);
            }
            RemoveProtections(player.userID);
        }

        private void SaveTeleportsAdmin()
        {
            if (_Admin == null || !changedAdmin) return;
            dataAdmin.WriteObject(_Admin);
            changedAdmin = false;
        }

        private void SaveTeleportsHome()
        {
            if (_Home == null || !changedHome) return;
            dataHome.WriteObject(_Home);
            changedHome = false;
        }

        private void SaveTeleportsTPR()
        {
            if (_TPR == null || !changedTPR) return;
            dataTPR.WriteObject(_TPR);
            changedTPR = false;
        }

        private void SaveTeleportsTPT()
        {
            if (TPT == null || !changedTPT) return;
            dataTPT.WriteObject(TPT);
            changedTPT = false;
        }

        private void SaveTeleportsTown()
        {
            foreach (var entry in _DynamicData.ToList())
            {
                if (entry.Value.Changed)
                {
                    var fileName = string.IsNullOrEmpty(config.Settings.DataFileFolder) ? $"{Name}{entry.Key}" : $"{config.Settings.DataFileFolder}{Path.DirectorySeparatorChar}{entry.Key}";
                    Interface.Oxide.DataFileSystem.WriteObject(fileName, entry.Value.TPData);
                    entry.Value.Changed = false;
                }
            }
        }

        private void SaveLocation(BasePlayer player, Vector3 position, bool build = true, bool craft = true)
        {
            if (player == null || _Admin == null || !IsAllowed(player, PermTpB)) return;
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData == null)
                _Admin[player.userID] = adminData = new AdminData();
            adminData.PreviousLocation = position;
            adminData.BuildingBlocked = build;
            adminData.AllowCrafting = craft;
            changedAdmin = true;
            PrintMsgL(player, "AdminTPBackSave");
        }

        private void RemoveLocation(BasePlayer player)
        {
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData))
                return;
            adminData.PreviousLocation = Vector3.zero;
            changedAdmin = true;
        }

        private Coroutine _cmc;
        private bool _cmcCompleted;

        private IEnumerator SetupMonuments()
        {
            int checks = 0;
            foreach (var prefab in World.Serialization.world.prefabs)
            {
                if (prefab.id == 1724395471 && prefab.category != "IGNORE_MONUMENT")
                {
                    yield return CalculateMonumentSize(null, new Vector3(prefab.position.x, prefab.position.y, prefab.position.z), prefab.category, "monument_marker");
                }
                if (++checks >= 1000)
                {
                    yield return CoroutineEx.waitForSeconds(0.0025f);
                    checks = 0;
                }
            }
            foreach (var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (monument.name.Contains("monument_marker"))
                {
                    foreach (var m in monuments)
                    {
                        if (m.monument == null && monument.transform.position == m.position)
                        {
                            m.monument = monument;
                            break;
                        }
                    }
                    continue;
                }
                var monPos = monument.transform.position;
                var name = monument.displayPhrase.english.TrimEnd();
                if (string.IsNullOrEmpty(name))
                {
                    if (monument.name.Contains("cave"))
                    {
                        name = monument.name.Contains("cave_small") ? "Small Cave" : monument.name.Contains("cave_medium") ? "Medium Cave" : "Large Cave";
                    }
                    else name = monument.name;
                }
                if (name.Contains("/"))
                {
                    name = monument.name.Substring(monument.name.LastIndexOf("/") + 1).Replace(".prefab", "");
                }
                if (monument.name.Contains("cave"))
                {
                    name += UnityEngine.Random.Range(1000, 9999);
#if DEBUG
                    Puts($"Adding Cave: {name}, pos: {monPos}");
#endif
                    caves[name] = monPos;
                }
                else if (config.Settings.Outpost.Exists(monument.name.Contains))
                {
                    yield return SetupOutpost(monument);
                }
                else if (config.Settings.Bandit.Exists(monument.name.Contains))
                {
                    yield return SetupBandit(monument);
                }
                else if (monument.Bounds.extents.Max() > 0f)
                {
                    var dist = monument.Bounds.extents.Max() + config.Admin.ExtraMonumentDistance;
#if DEBUG
                    Puts($"Adding Monument: {name}, pos: {monPos}, size: {dist}");
#endif
                    monuments.Add(new MonumentInfoEx(monument, monument.transform.position, dist, monument.displayPhrase.english.Trim(), monument.name));
                }
                else yield return CalculateMonumentSize(monument, monument.transform.position, string.IsNullOrEmpty(monument.displayPhrase.english.Trim()) ? monument.name : monument.displayPhrase.english.Trim(), monument.name);
            }
            _cmcCompleted = true;
            _cmc = null;
        }

        private IEnumerator SetupOutpost(MonumentInfo monument)
        {
            var outpost = GetSettings("outpost");

            if (outpost == null)
            {
                outpostEnabled = false;
                yield break;
            }

            if (config.Settings.AutoGenOutpost && outpost.Location != Vector3.zero && outpost.Locations.Exists(a => OutOfRange(monument, a, config.Settings.AutoGenOutpost)))
            {
#if DEBUG
                Puts("Invalid Outpost location detected");
#endif
                outpost.Location = Vector3.zero;
                outpost.Locations = new List<Vector3>();
            }
            if (config.Settings.AutoGenOutpost && outpost.Location == Vector3.zero)
            {
#if DEBUG
                Puts("  Looking for Outpost target");
#endif
                bool changedOutpost = false;
                var ents = Pool.GetList<BaseEntity>();
                float radius = monument.Bounds.size.Max();
                Vis.Entities(monument.transform.position, radius, ents);
                foreach (BaseEntity entity in ents)
                {
                    if (entity.OwnerID.IsSteamId() || OutOfRange(monument, entity.transform.position, entity is BaseChair))
                    {
                        continue;
                    }
                    if (entity.prefabID == 3858860623 || entity.prefabID == 1729604075 || entity is NPCMissionProvider || entity is Workbench)
                    {
                        outpost.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (!outpost.Locations.Contains(outpost.Location)) outpost.Locations.Add(outpost.Location);
                        changedOutpost = true;
#if DEBUG
                        Puts("  Adding Outpost target {0}", outpost.Location);
#endif
                    }
                    else if (entity is BaseChair)
                    {
                        outpost.Location = entity.transform.position + entity.transform.right + new Vector3(0f, 1f, 0f);
                        if (!outpost.Locations.Contains(outpost.Location)) outpost.Locations.Add(outpost.Location);
                        changedOutpost = true;
#if DEBUG
                        Puts("  Adding Outpost target {0}", outpost.Location);
#endif
                    }
                }
                if (changedOutpost) SaveConfig();
                Pool.FreeList(ref ents);
            }

            if (outpost.Location == Vector3.zero)
            {
                outpostEnabled = false;
            }
            else if (!outpost.Locations.Contains(outpost.Location))
            {
                outpost.Locations.Add(outpost.Location);
            }

            yield return null;
        }

        private IEnumerator SetupBandit(MonumentInfo monument)
        {
            var bandit = GetSettings("bandit");

            if (bandit == null)
            {
                banditEnabled = false;
                yield break;
            }

            float radius = monument.Bounds.size.Max();

            if (config.Settings.AutoGenBandit && bandit.Location != Vector3.zero && bandit.Locations.Exists(a => OutOfRange(monument, a, config.Settings.AutoGenBandit)))
            {
#if DEBUG
                Puts("Invalid Bandit location detected");
#endif
                bandit.Location = Vector3.zero;
                bandit.Locations = new List<Vector3>();
            }
            if (config.Settings.AutoGenBandit && bandit.Location == Vector3.zero)
            {
#if DEBUG
                Puts("  Looking for BanditTown target");
#endif
                bool changedBandit = false;
                var ents = Pool.GetList<BaseEntity>();
                Vis.Entities(monument.transform.position, radius, ents);
                foreach (BaseEntity entity in ents)
                {
                    if (entity.OwnerID.IsSteamId() || OutOfRange(monument, entity.transform.position, entity is BaseChair))
                    {
                        continue;
                    }
                    if (entity.prefabID == 3858860623 || entity.prefabID == 1729604075 || entity is NPCMissionProvider || entity is Workbench)
                    {
                        bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (!bandit.Locations.Contains(bandit.Location)) bandit.Locations.Add(bandit.Location);
                        changedBandit = true;
#if DEBUG
                        Puts("  Adding BanditTown target {0}", bandit.Location);
#endif
                    }
                    else if (entity is BaseChair)
                    {
                        bandit.Location = entity.transform.position + entity.transform.forward + new Vector3(0f, 1f, 0f);
                        if (!bandit.Locations.Contains(bandit.Location)) bandit.Locations.Add(bandit.Location);
                        changedBandit = true;
#if DEBUG
                        Puts("  Adding BanditTown target {0}", bandit.Location);
#endif
                    }
                }
                Pool.FreeList(ref ents);
                if (changedBandit) SaveConfig();
            }

            if (bandit.Location == Vector3.zero)
            {
                banditEnabled = false;
            }
            else if (!bandit.Locations.Contains(bandit.Location))
            {
                bandit.Locations.Add(bandit.Location);
            }

            yield return null;
        }

        public IEnumerator CalculateMonumentSize(MonumentInfo monument, Vector3 from, string text, string prefab)
        {
            int checks = 0;
            float radius = 15f;
            while (radius < World.Size / 2f)
            {
                int pointsOfTopology = 0;
                foreach (var to in GetCircumferencePositions(from, radius, 30f))
                {
                    if (ContainsTopology(TerrainTopology.Enum.Building | TerrainTopology.Enum.Monument, to, 5f))
                    {
                        pointsOfTopology++;
                    }
                    if (++checks >= 25)
                    {
                        yield return CoroutineEx.waitForSeconds(0.0025f);
                        checks = 0;
                    }
                }
                if (pointsOfTopology < 4)
                {
                    break;
                }
                radius += 15f;
            }
            monuments.Add(new MonumentInfoEx(monument, from, radius, text, prefab));

#if DEBUG
            Puts($"Adding Monument: {text}, pos: {from}, size: {radius}");
#endif
        }

        public List<Vector3> GetCircumferencePositions(Vector3 center, float radius, float next)
        {
            float degree = 0f;
            float angleInRadians = 2f * Mathf.PI;
            List<Vector3> positions = new List<Vector3>();

            while (degree < 360)
            {
                float radian = (angleInRadians / 360) * degree;
                float x = center.x + radius * Mathf.Cos(radian);
                float z = center.z + radius * Mathf.Sin(radian);
                Vector3 a = new Vector3(x, 0f, z);

                positions.Add(a.WithY(TerrainMeta.HeightMap.GetHeight(a)));

                degree += next;
            }

            return positions;
        }

        private bool TeleportInForcedBoundary(params BasePlayer[] players)
        {
            if (config.Settings.ForcedBoundary != 0f)
            {
                foreach (var player in players)
                {
                    if (!CanBypassRestrictions(player.UserIDString) && player.transform.localPosition.y >= config.Settings.ForcedBoundary)
                    {
                        PrintMsgL(player, "TPFlagZone");
                        return false;
                    }
                }
            }
            return true;
        }

        private void TeleportRequestUI(BasePlayer player, string displayName)
        {
            if (!config.TPR.UI || string.IsNullOrEmpty(displayName)) return;
            var elements = new CuiElementContainer();
            elements.Add(new CuiPanel { CursorEnabled = false, Image = { Color = "0 0 0 0.75" }, RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-154.835 87.648", OffsetMax = "135.234 155.152" } }, "Overlay", "TPR_MAIN_UI", "TPR_MAIN_UI");
            elements.Add(new CuiElement { Name = "TPR_INFO_LBL", Parent = "TPR_MAIN_UI", DestroyUi = "TPR_INFO_LBL", Components = { new CuiTextComponent { Text = _("RequestUI", player, displayName), Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter }, new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-142.335 -3.676", OffsetMax = "142.335 30.076" } } });
            elements.Add(new CuiButton { Button = { Command = "ntp.accept", Color = "0 0.78 0 0.75" }, Text = { Text = _("RequestAccept", player), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }, RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-138.395 -28.883", OffsetMax = "-28.406 -8.589" } }, "TPR_MAIN_UI", "TPR_ACCEPT_BTN", "TPR_ACCEPT_BTN");
            elements.Add(new CuiButton { Button = { Command = "ntp.reject", Color = "0.78 0 0 0.75" }, Text = { Text = _("RequestReject", player), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }, RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "29.305 -28.883", OffsetMax = "139.295 -8.589" } }, "TPR_MAIN_UI", "TPR_REJECT_BTN", "TPR_REJECT_BTN");
            timer.Once(config.TPR.RequestDuration, () => DestroyTeleportRequestCUI(player));
            CuiHelper.AddUi(player, elements);
        }

        public void DestroyTeleportRequestCUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "TPR_MAIN_UI");
        }

        [ConsoleCommand("ntp.accept")]
        private void ccmdAccept(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DestroyTeleportRequestCUI(player);
            CommandTeleportAccept(player.IPlayer, "tpa", new string[0]);
        }

        [ConsoleCommand("ntp.reject")]
        private void ccmdReject(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            DestroyTeleportRequestCUI(player);
            CommandTeleportCancel(player.IPlayer, "tpc", new string[0]);
        }

        private bool OutOfRange(MonumentInfo m, Vector3 a, bool checkHeight) => checkHeight && Mathf.Abs(a.y - TerrainMeta.HeightMap.GetHeight(a)) > 5f || m.Distance(a) > m.Bounds.extents.Max() * 0.5f;

        private void CommandToggle(IPlayer user, string command, string[] args)
        {
            if (!user.IsAdmin) return;

            if (args.Length == 0)
            {
                user.Reply("tnt commandname");
                return;
            }

            string arg = args[0].ToLower();

            if (arg == command.ToLower()) return;

            if (!DisabledCommandData.DisabledCommands.Contains(arg))
                DisabledCommandData.DisabledCommands.Add(arg);
            else DisabledCommandData.DisabledCommands.Remove(arg);

            dataDisabled.WriteObject(DisabledCommandData);
            user.Reply("{0} {1}", DisabledCommandData.DisabledCommands.Contains(arg) ? "Disabled:" : "Enabled:", arg);
        }

        private void CommandTeleport(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!user.IsServer && (!IsAllowedMsg(player, PermTp) || !TeleportInForcedBoundary(player))) return;
            BasePlayer target;
            float x, y, z;
            switch (args.Length)
            {
                case 1:
                    if (player == null) return;
                    target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                        PrintMsgL(player, "CantTeleportToSelf");
                        return;
#endif
                    }
                    Teleport(player, target);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                case 2:
                    var origin = FindPlayersSingle(args[0], player);
                    target = FindPlayersSingle(args[1], player);
                    if (target == null && origin != null)
                    {
                        var loc = GetAdminLocation(args[1]);
                        if (loc != Vector3.zero)
                        {
                            Teleport(origin, loc, IsAllowed(origin, PermTp));
                            return;
                        }
                    }
                    if (origin == null || target == null) return;
                    if (target == origin)
                    {
                        PrintMsgL(player, "CantTeleportPlayerToSelf");
                        return;
                    }
                    if (permission.UserHasPermission(target.UserIDString, PermDisallowTpToMe))
                    {
                        PrintMsgL(player, "CantTeleportPlayerToYourself");
                        return;
                    }
                    Teleport(origin, target);
                    Puts(_("LogTeleportPlayer", null, user.Name, origin.displayName, target.displayName));
                    if (player == null) return;
                    PrintMsgL(player, "AdminTPPlayers", origin.displayName, target.displayName);
                    PrintMsgL(origin, "AdminTPPlayer", player.displayName, target.displayName);
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPPlayerTarget", player.displayName, origin.displayName);
                    break;
                case 3:
                    if (player == null) return;
                    if (!float.TryParse(args[0].Replace(",", string.Empty), out x) || !float.TryParse(args[1].Replace(",", string.Empty), out y) || !float.TryParse(args[2], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(x, y, z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(player, x, y, z);
                    PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                    Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    break;
                case 4:
                    target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (player != null && permission.UserHasPermission(target.UserIDString, PermDisallowTpToMe) && target != player)
                    {
                        PrintMsgL(player, "CantTeleportPlayerToYourself");
                        return;
                    }
                    if (!float.TryParse(args[1].Replace(",", string.Empty), out x) || !float.TryParse(args[2].Replace(",", string.Empty), out y) || !float.TryParse(args[3], out z))
                    {
                        PrintMsgL(player, "InvalidCoordinates");
                        return;
                    }
                    if (config.Settings.CheckBoundaries && !CheckBoundaries(x, y, z))
                    {
                        PrintMsgL(player, "AdminTPOutOfBounds");
                        PrintMsgL(player, "AdminTPBoundaries", boundary);
                        return;
                    }
                    Teleport(target, x, y, z);
                    if (player == null) return;
                    if (player == target)
                    {
                        PrintMsgL(player, "AdminTPCoordinates", player.transform.position);
                        Puts(_("LogTeleport", null, player.displayName, player.transform.position));
                    }
                    else
                    {
                        PrintMsgL(player, "AdminTPTargetCoordinates", target.displayName, player.transform.position);
                        if (config.Admin.AnnounceTeleportToTarget)
                            PrintMsgL(target, "AdminTPTargetCoordinatesTarget", player.displayName, player.transform.position);
                        Puts(_("LogTeleportPlayer", null, player.displayName, target.displayName, player.transform.position));
                    }
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTP");
                    break;
            }
        }

        private Vector3 GetAdminLocation(string value)
        {
            foreach (var adminData in _Admin.Values)
            {
                Vector3 loc;
                if (adminData.Locations.TryGetValue(value, out loc))
                {
                    return loc;
                }
            }
            return Vector3.zero;
        }

        private void CommandTeleportNear(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpN)) return;
            switch (args.Length)
            {
                case 1:
                case 2:
                    var target = FindPlayersSingle(args[0], player);
                    if (target == null) return;
                    if (target == player)
                    {
#if DEBUG
                        Puts("Debug mode - allowing self teleport.");
#else
                        PrintMsgL(player, "CantTeleportToSelf");
                        return;
#endif
                    }
                    int distance = 0;
                    if (args.Length != 2 || !int.TryParse(args[1], out distance))
                        distance = config.Admin.TeleportNearDefaultDistance;
                    float x = UnityEngine.Random.Range(-distance, distance);
                    var z = (float)Math.Sqrt(Math.Pow(distance, 2) - Math.Pow(x, 2));
                    var destination = target.transform.position;
                    destination.x -= x;
                    destination.z -= z;
                    Teleport(player, GetGroundBuilding(destination), true);
                    PrintMsgL(player, "AdminTP", target.displayName);
                    Puts(_("LogTeleport", null, player.displayName, target.displayName));
                    if (config.Admin.AnnounceTeleportToTarget)
                        PrintMsgL(target, "AdminTPTarget", player.displayName);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPN");
                    break;
            }
        }

        private void CommandTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpL)) return;
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            switch (args.Length)
            {
                case 0:
                    PrintMsgL(player, "AdminLocationList");
                    foreach (var location in adminData.Locations)
                        PrintMsgL(player, $"{location.Key} {location.Value}");
                    break;
                case 1:
                    Vector3 loc;
                    if (!adminData.Locations.TryGetValue(args[0], out loc))
                    {
                        PrintMsgL(player, "LocationNotFound");
                        return;
                    }
                    Teleport(player, loc, true);
                    PrintMsgL(player, "AdminTPLocation", args[0]);
                    break;
                default:
                    PrintMsgL(player, "SyntaxCommandTPL");
                    break;
            }
        }

        private void CommandSaveTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpSave)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPSave");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData))
                _Admin[player.userID] = adminData = new AdminData();
            Vector3 location;
            if (adminData.Locations.TryGetValue(args[0], out location))
            {
                PrintMsgL(player, "LocationExists", location);
                return;
            }
            var positionCoordinates = player.transform.position;
            if (!CanBypassRestrictions(player.UserIDString) && !permission.UserHasPermission(player.UserIDString, "nteleportation.locationradiusbypass"))
            {
                foreach (var loc in adminData.Locations)
                {
                    if ((positionCoordinates - loc.Value).magnitude < config.Admin.LocationRadius)
                    {
                        PrintMsgL(player, "LocationExistsNearby", loc.Key);
                        return;
                    }
                }
            }
            adminData.Locations[args[0]] = positionCoordinates;
            PrintMsgL(player, "AdminTPLocationSave");
            changedAdmin = true;
        }

        private void CommandRemoveTeleportLocation(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpRemove)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandTPRemove");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.Locations.Count <= 0)
            {
                PrintMsgL(player, "AdminLocationListEmpty");
                return;
            }
            if (adminData.Locations.Remove(args[0]))
            {
                PrintMsgL(player, "AdminTPLocationRemove", args[0]);
                changedAdmin = true;
                return;
            }
            PrintMsgL(player, "LocationNotFound");
        }

        private void CommandTeleportBack(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpB)) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPB");
                return;
            }
            AdminData adminData;
            if (!_Admin.TryGetValue(player.userID, out adminData) || adminData.PreviousLocation == Vector3.zero)
            {
                PrintMsgL(player, "NoPreviousLocationSaved");
                return;
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            if (!TeleportInForcedBoundary(player))
            {
                return;
            }
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var err = CanPlayerTeleport(player, adminData.PreviousLocation, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckPlayer(player, adminData.BuildingBlocked, adminData.AllowCrafting, true, "tpb", true);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
            }
            var countdown = GetLower(player, config.Settings.TPB.Countdowns, config.Settings.TPB.Countdown);
            if (countdown > 0f)
            {
                TeleportBack(player, adminData, countdown);
                return;
            }
            Teleport(player, adminData.PreviousLocation, false);
            adminData.PreviousLocation = Vector3.zero;
            changedAdmin = true;
            PrintMsgL(player, "AdminTPBack");
            Puts(_("LogTeleportBack", null, player.displayName));
        }

        private void TeleportBack(BasePlayer player, AdminData adminData, int countdown)
        {
            string err = null;
            var location = adminData.PreviousLocation;
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,

                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatHomeTP");
#endif
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home");
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CanPlayerTeleport(player, location, player.transform.position);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, "TPBlockedItem", err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = IsInsideEntity(location, player.userID, "tpb");
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                    }
                    Teleport(player, location, false);
                    adminData.PreviousLocation = Vector3.zero;
                    changedAdmin = true;
                    PrintMsgL(player, "AdminTPBack");
                    Puts(_("LogTeleportBack", null, player.displayName));
                    TeleportTimers.Remove(player.userID);
                })
            };
            PrintMsgL(player, "DM_TownTPStarted", location, countdown);
        }

        private void CommandSetHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandSetHome");
                return;
            }
            string err = null;
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData))
                _Home[player.userID] = homeData = new HomeData();
            var limit = GetHigher(player, config.Home.VIPHomesLimits, config.Home.HomesLimit, true);
            if (!args[0].Replace("_", "").All(char.IsLetterOrDigit))
            {
                PrintMsgL(player, "InvalidCharacter");
                return;
            }
            HomeData.Entry homeEntry;
            if (homeData.TryGetValue(args[0], out homeEntry))
            {
                PrintMsgL(player, "HomeExists", homeEntry.Get());
                return;
            }
            var position = player.transform.position;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(config.Home.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                err = CheckPlayer(player, false, CanCraftHome(player), true, "sethome");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                if (!player.CanBuild())
                {
                    PrintMsgL(player, "HomeTPBuildingBlocked");
                    return;
                }
                if (limit > 0 && homeData.Locations.Count >= limit)
                {
                    PrintMsgL(player, "HomeMaxLocations", limit);
                    return;
                }
                if (config.Home.LocationRadius > 0 && !permission.UserHasPermission(player.UserIDString, "nteleportation.locationradiusbypass"))
                {
                    foreach (var loc in homeData.Locations)
                    {
                        if ((position - loc.Value.Get()).magnitude < config.Home.LocationRadius)
                        {
                            PrintMsgL(player, "HomeExistsNearby", loc.Key);
                            return;
                        }
                    }
                }
                err = CanPlayerTeleport(player, position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckFoundation(player.userID, position, "sethome");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
            }
            if (player.IsAdmin && config.Settings.DrawHomeSphere) player.SendConsoleCommand("ddraw.sphere", 30f, Color.blue, position, 2.5f);
            var entity = player.GetParentEntity() as Tugboat;
            if (entity != null)
            {
                if (!config.Home.AllowTugboats && !permission.UserHasPermission(player.UserIDString, "nteleportation.tugboatssethomebypass") && !CanBypassRestrictions(player.UserIDString))
                {
                    PrintMsgL(player, "HomeTugboatNotAllowed");
                    return;
                }
                homeData.Set(args[0], new HomeData.Entry
                {
                    Position = position - entity.transform.position,
                    wasEntity = true,
                    Entity = entity
                });
            }
            else homeData.Set(args[0], new HomeData.Entry(position));
            changedHome = true;
            PrintMsgL(player, "HomeSave");
            PrintMsgL(player, "HomeQuota", homeData.Locations.Count, limit);
            Interface.CallHook("OnHomeAdded", player, position, args[0]);
        }

        private void CommandRemoveHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (player.IsAdmin && args.Length == 2 && args[0] == "all")
            {
                float radius;
                if (float.TryParse(args[1], out radius))
                {
                    int amount = 0;
                    foreach (var home in _Home.ToList())
                    {
                        foreach (var location in home.Value.Locations.ToList())
                        {
                            var position = location.Value.Get();
                            if (Vector3Ex.Distance2D(position, player.transform.position) < radius)
                            {
                                string username = covalence.Players.FindPlayerById(home.Key.ToString())?.Name ?? "N/A";
                                Puts("{0} ({1}) removed home from {2} ({3}) at {4}", player.displayName, player.userID, username, home.Key, position);
                                player.SendConsoleCommand("ddraw.text", 30f, Color.red, position, "X");
                                home.Value.Remove(location.Key);
                                amount++;
                            }
                        }
                    }

                    user.Reply($"Removed {amount} homes within {radius} meters");
                }
                else user.Reply("/removehome all <radius>");

                return;
            }
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandRemoveHome");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            HomeData.Entry homeEntry;
            if (homeData.TryGetValue(args[0], out homeEntry))
            {
                Interface.CallHook("OnHomeRemoved", player, homeEntry.Get(), args[0]);
                homeData.Remove(args[0]);
                changedHome = true;
                PrintMsgL(player, "HomeRemove", args[0]);
            }
            else PrintMsgL(player, "HomeNotFound");
        }

        private void CommandHome(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHome)) return;
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                if (IsAllowed(player)) PrintMsgL(player, "SyntaxCommandHomeAdmin");
                return;
            }
            switch (args[0].ToLower())
            {
                case "add":
                    CommandSetHome(user, command, args.Skip(1).ToArray());
                    break;
                case "list":
                    CommandListHomes(user, command, args.Skip(1).ToArray());
                    break;
                case "remove":
                    CommandRemoveHome(user, command, args.Skip(1).ToArray());
                    break;
                case "radius":
                    CommandHomeRadius(user, command, args.Skip(1).ToArray());
                    break;
                case "delete":
                    CommandHomeDelete(user, command, args.Skip(1).ToArray());
                    break;
                case "tp":
                    CommandHomeAdminTP(user, command, args.Skip(1).ToArray());
                    break;
                case "homes":
                    CommandHomeHomes(user, command, args.Skip(1).ToArray());
                    break;
                case "wipe":
                    CommandWipeHomes(user, command, args.Skip(1).ToArray());
                    break;
                default:
                    cmdChatHomeTP(player, command, args);
                    break;
            }
        }

        private void CommandHomeRadius(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermRadiusHome)) return;
            float radius;
            if (args.Length != 1 || !float.TryParse(args[0], out radius)) radius = 10;
            var found = false;
            foreach (var homeData in _Home)
            {
                var toRemove = new List<string>();
                var target = RustCore.FindPlayerById(homeData.Key)?.displayName ?? homeData.Key.ToString();
                foreach (var location in homeData.Value.Locations)
                {
                    var position = location.Value.Get();
                    if ((player.transform.position - position).magnitude <= radius)
                    {
                        string err = null;
                        if (!location.Value.isEntity)
                        {
                            err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(homeData.Key, position, "radius");
                        }
                        if (err != null)
                        {
                            SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed");
                            found = true;
                            continue;
                        }
                        if (player.IsAdmin)
                        {
                            var entity = GetFoundationOwned(position, homeData.Key);
                            if (entity == null)
                            {
                                player.SendConsoleCommand("ddraw.text", 30f, Color.blue, position, $"<size=20>{target} - {location.Key} {position}</size>");
                            }
                            else
                            {
                                player.SendConsoleCommand("ddraw.text", 30f, Color.blue, entity.CenterPoint() + new Vector3(0, .5f), $"<size=20>{target} - {location.Key} {position}</size>");
                                DrawBox(player, entity.CenterPoint(), entity.transform.rotation, entity.bounds.size);
                            }
                        }
                        PrintMsg(player, $"{target} - {location.Key} {position}");
                        found = true;
                    }
                }
                foreach (var key in toRemove)
                {
                    homeData.Value.Remove(key);
                    changedHome = true;
                }
            }
            if (!found)
                PrintMsgL(player, "HomeNoFound");
        }

        private void SendHomeError(BasePlayer player, List<string> toRemove, string err, string homeName, Vector3 position, bool wasEntity, bool send = true)
        {
            Interface.CallHook("OnHomeRemoved", player, position, homeName);
            if (toRemove != null)
            {
                toRemove.Add(homeName);
            }
            if (!send)
            {
                return;
            }
            if (!wasEntity)
            {
                PrintMsgL(player, "HomeRemovedInvalid", $"{homeName} {position} ({PhoneController.PositionToGridCoord(position)})");
                PrintMsgL(player, err);
            }
            else PrintMsgL(player, "HomeRemovedDestroyed", homeName);
        }

        private void CommandHomeDelete(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowed(player, PermDeleteHome)) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeDelete");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData targetHome;
            if (!_Home.TryGetValue(userId, out targetHome) || !targetHome.Remove(args[1]))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            changedHome = true;
            PrintMsgL(player, "HomeDelete", args[0], args[1]);
        }

        private void CommandHomeAdminTP(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermAdmin)) return;
            if (args.Length != 2)
            {
                PrintMsgL(player, "SyntaxCommandHomeAdminTP");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData targetHome;
            HomeData.Entry homeEntry;
            if (!_Home.TryGetValue(userId, out targetHome) || !targetHome.TryGetValue(args[1], out homeEntry))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            Teleport(player, homeEntry.Get(), true);
            PrintMsgL(player, "HomeAdminTP", args[0], args[1]);
        }

        // Check that plugins are available and enabled for CheckEconomy()
        private bool UseEconomy()
        {
            return (config.Settings.UseEconomics && (Economics != null || IQEconomic != null)) || (config.Settings.UseServerRewards && ServerRewards != null);
        }

        // Check balance on multiple plugins and optionally withdraw money from the player
        private bool CheckEconomy(BasePlayer player, double bypass, bool withdraw = false, bool deposit = false)
        {
            if (player == null)
            {
                return false;
            }
            if (CanBypassRestrictions(player.UserIDString)) return true;
            bool foundmoney = false;
            // Check Economics first.  If not in use or balance low, check ServerRewards below
            if (config.Settings.UseEconomics)
            {
                if (Economics != null)
                {
                    var balance = (double)Economics?.CallHook("Balance", player.UserIDString);

                    if (balance >= bypass)
                    {
                        foundmoney = true;
                        if (withdraw)
                        {
                            return Convert.ToBoolean(Economics?.CallHook("Withdraw", player.userID, bypass));
                        }
                        else if (deposit)
                        {
                            Economics?.CallHook("Deposit", player.userID, bypass);
                        }
                    }
                }
                else if (IQEconomic != null)
                {
                    var balance = (int)IQEconomic?.CallHook("API_GET_BALANCE", player.userID);
                    if (balance >= bypass)
                    {
                        foundmoney = true;
                        if (withdraw)
                        {
                            return Convert.ToBoolean(IQEconomic?.CallHook("API_REMOVE_BALANCE", player.userID, (int)bypass));
                        }
                        else if (deposit)
                        {
                            Economics?.CallHook("API_SET_BALANCE", player.userID, bypass);
                        }
                    }
                }
            }

            // No money via Economics, or plugin not in use.  Try ServerRewards.
            if (!foundmoney && config.Settings.UseServerRewards && ServerRewards != null)
            {
                object bal = ServerRewards?.Call("CheckPoints", player.userID);
                var balance = Convert.ToDouble(bal);
                if (balance >= bypass)
                {
                    foundmoney = true;
                    if (withdraw)
                    {
                        return Convert.ToBoolean(ServerRewards?.Call("TakePoints", player.userID, (int)bypass));
                    }
                    else if (deposit)
                    {
                        ServerRewards?.Call("AddPoints", player.userID, (int)bypass);
                    }
                }
            }

            // Just checking balance without withdrawal - did we find anything?
            return foundmoney;
        }

        private void cmdChatHomeTP(BasePlayer player, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { player.ChatMessage("Disabled command."); return; }
            if (!IsAllowedMsg(player, PermHome)) return;
            bool paidmoney = false;
            if (!config.Settings.HomesEnabled) { player.ChatMessage("Homes are not enabled in the config."); return; }
            if (args.Length < 1)
            {
                PrintMsgL(player, "SyntaxCommandHome");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            HomeData.Entry homeEntry;
            if (!homeData.TryGetValue(args[0], out homeEntry))
            {
                PrintMsgL(player, "HomeNotFound");
                return;
            }
            int limit = 0;
            string err = null;
            var position = homeEntry.Get();
            var timestamp = Facepunch.Math.Epoch.Current;
            if (!CanBypassRestrictions(player.UserIDString))
            {
                if (!TeleportInForcedBoundary(player))
                {
                    return;
                }
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
                err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                if (config.Settings.BlockNoEscape && Convert.ToBoolean(NoEscape?.Call("IsBlockedZone", position)))
                {
                    PrintMsgL(player, "TPNoEscapeBlocked");
                    return;
                }
                if (!homeEntry.isEntity)
                {
                    err = homeEntry.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "home");
                }
                if (err == null)
                {
                    err = CheckTargetLocation(player, position, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
                }
                if (err != null)
                {
                    SendHomeError(player, null, err, args[0], position, err == "HomeRemovedDestroyed");
                    homeData.Remove(args[0]);
                    changedHome = true;
                    return;
                }
                var cooldown = GetLower(player, config.Home.VIPCooldowns, config.Home.Cooldown);
                var remain = cooldown - (timestamp - homeData.Teleports.Timestamp);
                if (cooldown > 0 && timestamp - homeData.Teleports.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 2 ? args[1].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD) && !paidmoney)
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && config.Home.Bypass > -1)
                        {
                            bool foundmoney = CheckEconomy(player, config.Home.Bypass);

                            if (foundmoney)
                            {
                                CheckEconomy(player, config.Home.Bypass, true);
                                paidmoney = true;

                                if (config.Home.Bypass > 0)
                                {
                                    PrintMsgL(player, "HomeTPCooldownBypass", config.Home.Bypass);
                                }

                                if (config.Home.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToHome", config.Home.Pay);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "HomeTPCooldownBypassF", config.Home.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            if (config.Home.Bypass > 0)
                            {
                                PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                                PrintMsgL(player, "HomeTPCooldownBypassP", config.Home.Bypass);
                                PrintMsgL(player, "HomeTPCooldownBypassP2", config.Settings.BypassCMD);
                                return;
                            }
                        }
                        else
                        {
                            PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        PrintMsgL(player, "HomeTPCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                var currentDate = DateTime.Now.ToString("d");
                if (homeData.Teleports.Date != currentDate)
                {
                    homeData.Teleports.Amount = 0;
                    homeData.Teleports.Date = currentDate;
                }
                limit = GetHigher(player, config.Home.VIPDailyLimits, config.Home.DailyLimit, true);
                if (limit > 0 && homeData.Teleports.Amount >= limit)
                {
                    PrintMsgL(player, "HomeTPLimitReached", limit);
                    return;
                }
                err = CanPlayerTeleport(player, position, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
                if (config.Home.UsableFromSafeZoneOnly && !player.InSafeZone())
                {
                    PrintMsgL(player, "TPHomeSafeZoneOnly");
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            var countdown = GetLower(player, config.Home.VIPCountdowns, config.Home.Countdown);
            TeleportTimers[player.userID] = new TeleportTimer
            {
                OriginPlayer = player,
                Timer = timer.Once(countdown, () =>
                {
#if DEBUG
                    Puts("Calling CheckPlayer from cmdChatHomeTP");
#endif
                    position = homeEntry.Get();
                    if (!CanBypassRestrictions(player.UserIDString))
                    {
                        if (!TeleportInForcedBoundary(player))
                        {
                            return;
                        }
                        err = CheckPlayer(player, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player), true, "home");
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CanPlayerTeleport(player, position, player.transform.position);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        err = CheckItems(player);
                        if (err != null)
                        {
                            PrintMsgL(player, "Interrupted");
                            PrintMsgL(player, "TPBlockedItem", err);
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            TeleportTimers.Remove(player.userID);
                            return;
                        }
                        if (!homeEntry.isEntity)
                        {
                            err = homeEntry.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "home");
                        }
                        if (err == null)
                        {
                            err = CheckTargetLocation(player, position, config.Home.UsableIntoBuildingBlocked, config.Home.CupOwnerAllowOnBuildingBlocked);
                        }
                        if (err != null)
                        {
                            SendHomeError(player, null, err, args[0], position, err == "HomeRemovedDestroyed");
                            homeData.Remove(args[0]);
                            changedHome = true;
                            if (paidmoney)
                            {
                                paidmoney = false;
                                CheckEconomy(player, config.Home.Bypass, false, true);
                            }
                            return;
                        }
                        if (UseEconomy())
                        {
                            if (config.Home.Pay < 0)
                            {
                                TeleportTimers.Remove(player.userID);
                                PrintMsgL(player, "DM_TownTPDisabled", "/home");
                                return;
                            }
                            else if (config.Home.Pay > 0)
                            {
                                if (!CheckEconomy(player, config.Home.Pay))
                                {
                                    TeleportTimers.Remove(player.userID);
                                    PrintMsgL(player, "TPNoMoney", config.Home.Pay);
                                    return;
                                }

                                if (!paidmoney)
                                {
                                    PrintMsgL(player, "TPMoney", (double)config.Home.Pay);
                                }

                                paidmoney = CheckEconomy(player, config.Home.Pay, true);
                            }
                        }
                    }
                    Teleport(player, position, config.Home.AllowTPB, config.Home.UsableOutOfBuildingBlocked, CanCraftHome(player));
                    homeData.Teleports.Amount++;
                    homeData.Teleports.Timestamp = timestamp;
                    changedHome = true;
                    PrintMsgL(player, "HomeTP", args[0]);
                    if (limit > 0) PrintMsgL(player, "HomeTPAmount", limit - homeData.Teleports.Amount);
                    TeleportTimers.Remove(player.userID);
                })
            };

            if (countdown > 0)
            {
                PrintMsgL(player, "HomeTPStarted", args[0], countdown);
            }
        }

        private void CommandListHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!config.Settings.HomesEnabled) { user.Reply("Homes are not enabled in the config."); return; }
            if (!IsAllowedMsg(player, PermHome)) return;
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandListHomes");
                return;
            }
            HomeData homeData;
            if (!_Home.TryGetValue(player.userID, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            ValidateHomes(player, homeData, true, false);
            foreach (var location in homeData.Locations)
                PrintMsgL(player, $"{location.Key} {location.Value.Get()} {PhoneController.PositionToGridCoord(location.Value.Get())}");
        }

        private void ValidateHomes(BasePlayer player, HomeData homeData, bool showRemoved, bool showLoc)
        {
            if (config.Home.CheckValidOnList)
            {
                string err = null;
                var toRemove = new List<string>();
                foreach (var location in homeData.Locations)
                {
                    var position = location.Value.Get();
                    if (!location.Value.isEntity)
                    {
                        err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(player.userID, position, "validate");
                    }
                    if (err != null)
                    {
                        SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed", showRemoved);
                    }
                    else if (showLoc) PrintMsgL(player, $"{location.Key} {position} {PhoneController.PositionToGridCoord(position)}");
                }
                foreach (var key in toRemove)
                {
                    homeData.Remove(key);
                    changedHome = true;
                }
            }
        }

        private void CommandHomeHomes(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermHomeHomes)) return;
            if (args.Length != 1)
            {
                PrintMsgL(player, "SyntaxCommandHomeHomes");
                return;
            }
            var userId = FindPlayersSingleId(args[0], player);
            if (userId <= 0) return;
            HomeData homeData;
            if (!_Home.TryGetValue(userId, out homeData) || homeData.Locations.Count <= 0)
            {
                PrintMsgL(player, "HomeListEmpty");
                return;
            }
            PrintMsgL(player, "HomeList");
            var toRemove = new List<string>();
            foreach (var location in homeData.Locations)
            {
                var position = location.Value.Get();
                string err = null;
                if (!location.Value.isEntity)
                {
                    err = location.Value.wasEntity ? "HomeRemovedDestroyed" : CheckFoundation(userId, position, "homes");
                }
                if (err != null)
                {
                    SendHomeError(player, toRemove, err, location.Key, position, err == "HomeRemovedDestroyed");
                }
                else PrintMsgL(player, $"{location.Key} {position} ({PhoneController.PositionToGridCoord(position)})");
            }
            foreach (var key in toRemove)
            {
                homeData.Remove(key);
                changedHome = true;
            }
        }

        private void CommandTeleportAcceptToggle(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!player || !IsAllowedMsg(player, PermTpT))
                return;
            if (args.Length > 0)
            {
                switch (args[0].ToLower())
                {
                    case "friend":
                    case "clan":
                    case "team":
                        {
                            ToggleTPTEnabled(player, args[0].ToLower(), command);
                            return;
                        }
                }
            }
            PrintMsgL(player, "TPTInfo", command, IsEnabled(player.UserIDString, "clan") ? config.TPT.EnabledColor : config.TPT.DisabledColor,
                IsEnabled(player.UserIDString, "team") ? config.TPT.EnabledColor : config.TPT.DisabledColor,
                IsEnabled(player.UserIDString, "friend") ? config.TPT.EnabledColor : config.TPT.DisabledColor,
                command.ToUpper(), config.TPT.EnabledColor, config.TPT.DisabledColor);
        }

        public bool IsOnSameTeam(ulong playerId, ulong targetId)
        {
            RelationshipManager.PlayerTeam team;
            return RelationshipManager.ServerInstance.playerToTeam.TryGetValue(playerId, out team) && team.members.Contains(targetId);
        }

        private bool AreFriends(string playerId, string targetId)
        {
            return Friends != null && Convert.ToBoolean(Friends?.Call("AreFriends", playerId, targetId));
        }
        private bool IsFriend(string playerId, string targetId)
        {
            return Friends != null && Convert.ToBoolean(Friends?.Call("IsFriend", playerId, targetId));
        }

        private bool IsInSameClan(string playerId, string targetId)
        {
            return Clans != null && Convert.ToBoolean(Clans?.Call("IsMemberOrAlly", playerId, targetId));
        }

        private bool InstantTeleportAccept(BasePlayer target, BasePlayer player)
        {
            if (!permission.UserHasPermission(target.UserIDString, PermTpT) || !permission.UserHasPermission(player.UserIDString, PermTpT))
            {
                return false;
            }

            if ((config.TPT.UseClans && IsInSameClan(player.UserIDString, target.UserIDString) && !TPT.ContainsKey(target.UserIDString))
                || (config.TPT.UseClans && IsEnabled(target.UserIDString, "clan") && IsInSameClan(player.UserIDString, target.UserIDString)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }
            else if ((config.TPT.UseFriends && IsFriend(player.UserIDString, target.UserIDString) && !TPT.ContainsKey(target.UserIDString))
                     || (config.TPT.UseFriends && IsEnabled(target.UserIDString, "friend") && IsFriend(player.UserIDString, target.UserIDString)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }
            else if ((config.TPT.UseTeams && IsOnSameTeam(player.userID, target.userID) && !TPT.ContainsKey(target.UserIDString))
                     || (config.TPT.UseTeams && IsEnabled(target.UserIDString, "team") && IsOnSameTeam(player.userID, target.userID)))
            {
                CommandTeleportAccept(target.IPlayer, TPA, nullArg);
            }

            return true;
        }

        bool IsEnabled(string targetId, string value)
        {
            if (TPT.ContainsKey(targetId) && TPT[targetId].Contains(value))
            {
                return false;
            }
            return true;
        }

        void ToggleTPTEnabled(BasePlayer target, string value, string command)
        {
            List<string> list;
            if (!TPT.TryGetValue(target.UserIDString, out list))
            {
                TPT[target.UserIDString] = list = new List<string>();
            }
            if (list.Contains(value))
            {
                list.Remove(value);
                if (list.IsEmpty()) TPT.Remove(target.UserIDString);
            }
            else
            {
                list.Add(value);
            }
            string status = lang.GetMessage($"TPT_{!list.Contains(value)}", this, target.UserIDString);
            string message = string.Format(lang.GetMessage($"TPT_{value}", this, target.UserIDString), status, command.ToUpper());
            PrintMsg(target, message);
            changedTPT = true;
        }

        private string GetMultiplePlayers(List<BasePlayer> players)
        {
            var list = new List<string>();

            foreach (var player in players)
            {
                string id;
                if (!_players.TryGetValue(player, out id))
                {
                    id = OnPlayerConnected(player);
                }

                list.Add(string.Format("<color={0}>{1}</color> - {2}", config.Settings.ChatCommandArgumentColor, id, player.displayName));
            }

            return string.Join(", ", list.ToArray());
        }

        private double GetUseableTime(double hours) => hours <= 0.0 ? 0.0 : TimeSpan.FromHours(hours - DateTime.UtcNow.Subtract(SaveRestore.SaveCreatedTime).TotalHours).TotalSeconds;

        private void CommandTeleportRequest(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, PermTpR)) return;
            if (!config.Settings.TPREnabled) { user.Reply("TPR is not enabled in the config."); return; }
            if (args.Length == 0)
            {
                PrintMsgL(player, "SyntaxCommandTPR");
                return;
            }
            var targets = FindPlayers(args[0]);
            if (targets.Count <= 0)
            {
                PrintMsgL(player, "PlayerNotFound");
                return;
            }
            BasePlayer target = null;
            if (args.Length >= 2)
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                    return;
                }
                else target = targets[0];
            }
            else
            {
                if (targets.Count > 1)
                {
                    PrintMsgL(player, "MultiplePlayers", GetMultiplePlayers(targets));
                    return;
                }

                target = targets[0];
            }

            if (target == player)
            {
#if DEBUG
                Puts("Debug mode - allowing self teleport.");
#else
                PrintMsgL(player, "CantTeleportToSelf");
                return;
#endif
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportRequest");
#endif
            if (!TeleportInForcedBoundary(player, target))
            {
                return;
            }

            if (IsBlockedUser(player.userID, target.userID))
            {
                PrintMsgL(player, "BlockedTeleportTarget", target.displayName.Sanitize());
                return;
            }
            TeleportData tprData;
            if (!_TPR.TryGetValue(player.userID, out tprData))
                _TPR[player.userID] = tprData = new TeleportData();
            if (!CanBypassRestrictions(player.UserIDString))
            {
                var getUseableTime = GetUseableTime(config.TPR.Hours);
                if (getUseableTime > 0.0)
                {
                    PrintMsgL(player, "NotUseable", FormatTime(player, getUseableTime));
                    return;
                }
                string err = null;
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", FormatTime(player, (int)globalCooldownTime));
                    return;
                }
                if (config.Settings.BlockAuthorizedTeleporting && player.IsBuildingAuthed())
                {
                    PrintMsgL(player, "CannotTeleportFromHome");
                    return;
                }
                err = CheckPlayer(player, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(player), true, "tpr");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                var err2 = CheckPlayer(target, config.TPR.UsableIntoBuildingBlocked, CanCraftTPR(target), true, "tpr");
                if (err2 != null)
                {
                    string error = string.Format(lang.GetMessage("ErrorTPR", this, player.UserIDString), target.displayName, lang.GetMessage(err2, this, player.UserIDString));
                    PrintMsg(player, error);
                    return;
                }
                err = CheckTargetLocation(target, target.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                var timestamp = Facepunch.Math.Epoch.Current;
                var currentDate = DateTime.Now.ToString("d");

                if (tprData.Date != currentDate)
                {
                    tprData.Amount = 0;
                    tprData.Date = currentDate;
                }

                var cooldown = GetLower(player, config.TPR.VIPCooldowns, config.TPR.Cooldown);
                if (cooldown > 0 && timestamp - tprData.Timestamp < cooldown)
                {
                    var cmdSent = args.Length >= 2 ? args[1].ToLower() : string.Empty;

                    if (!string.IsNullOrEmpty(config.Settings.BypassCMD))
                    {
                        if (cmdSent == config.Settings.BypassCMD.ToLower() && config.TPR.Bypass > -1)
                        {
                            if (CheckEconomy(player, config.TPR.Bypass))
                            {
                                CheckEconomy(player, config.TPR.Bypass, true);

                                if (config.TPR.Bypass > 0)
                                {
                                    PrintMsgL(player, "TPRCooldownBypass", config.TPR.Bypass);
                                }

                                if (config.TPR.Pay > 0)
                                {
                                    PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                                }
                            }
                            else
                            {
                                PrintMsgL(player, "TPRCooldownBypassF", config.TPR.Bypass);
                                return;
                            }
                        }
                        else if (UseEconomy())
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                            if (config.TPR.Bypass > -1)
                            {
                                if (config.TPR.Bypass > 0)
                                {
                                    PrintMsgL(player, "TPRCooldownBypassP", config.TPR.Bypass);

                                    if (config.TPR.Pay > 0)
                                    {
                                        PrintMsgL(player, "PayToTPR", config.TPR.Pay);
                                    }

                                    PrintMsgL(player, "TPRCooldownBypassP2a", config.Settings.BypassCMD);
                                    return;
                                }
                            }
                            else return;
                        }
                        else
                        {
                            var remain = cooldown - (timestamp - tprData.Timestamp);
                            PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                            return;
                        }
                    }
                    else
                    {
                        var remain = cooldown - (timestamp - tprData.Timestamp);
                        PrintMsgL(player, "TPRCooldown", FormatTime(player, remain));
                        return;
                    }
                }
                var limit = GetHigher(player, config.TPR.VIPDailyLimits, config.TPR.DailyLimit, true);
                if (limit > 0 && tprData.Amount >= limit)
                {
                    PrintMsgL(player, "TPRLimitReached", limit);
                    return;
                }
                err = CanPlayerTeleport(player, player.transform.position, target.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                err = CanPlayerTeleport(target, target.transform.position, player.transform.position);
                if (err != null)
                {
                    PrintMsgL(player, string.IsNullOrEmpty(err) ? "TPRTarget" : err);
                    return;
                }
                err = CheckItems(player);
                if (err != null)
                {
                    PrintMsgL(player, "TPBlockedItem", err);
                    return;
                }
            }
            if (TeleportTimers.ContainsKey(player.userID))
            {
                PrintMsgL(player, "TeleportPendingTPC");
                return;
            }
            if (TeleportTimers.ContainsKey(target.userID))
            {
                PrintMsgL(player, "TeleportPendingTarget");
                return;
            }
            if (PlayersRequests.ContainsKey(player.userID))
            {
                PrintMsgL(player, "PendingRequest");
                return;
            }
            if (PlayersRequests.ContainsKey(target.userID))
            {
                PrintMsgL(player, "PendingRequestTarget");
                return;
            }

            if (!config.TPR.UseClans_Friends_Teams || IsInSameClan(player.UserIDString, target.UserIDString) || AreFriends(player.UserIDString, target.UserIDString) || IsOnSameTeam(player.userID, target.userID) || CanBypassRestrictions(player.UserIDString))
            {
                PlayersRequests[player.userID] = target;
                PlayersRequests[target.userID] = player;
                PendingRequests[target.userID] = timer.Once(config.TPR.RequestDuration, () => { RequestTimedOut(player, target); });
                PrintMsgL(player, "Request", target.displayName);
                PrintMsgL(target, "RequestTarget", player.displayName);
                if (config.TPR.PlaySoundsToRequestTarget)
                {
                    SendEffect(target, config.TPR.TeleportRequestEffects);
                }
                if (Interface.CallHook("OnTeleportRequested", target, player) == null && !InstantTeleportAccept(target, player))
                {
                    TeleportRequestUI(target, player.displayName);
                }
            }
            else
            {
                PrintMsgL(player, "TPR_NoClan_NoFriend_NoTeam");
            }
        }

        private void CommandTeleportAccept(IPlayer user, string command, string[] args)
        {
            if (DisabledCommandData.DisabledCommands.Contains(command.ToLower())) { user.Reply("Disabled command: " + command); return; }
            if (!config.Settings.TPREnabled) { user.Reply("TPR is not enabled in the config."); return; }
            var player = user.Object as BasePlayer;
            if (!IsAllowedMsg(player, config.TPR.RequireTPAPermission ? PermTpA : PermTpR)) return;
            DestroyTeleportRequestCUI(player);
            if (args.Length != 0)
            {
                PrintMsgL(player, "SyntaxCommandTPA");
                return;
            }
            Timer reqTimer;
            if (!PendingRequests.TryGetValue(player.userID, out reqTimer))
            {
                PrintMsgL(player, "NoPendingRequest");
                DestroyTeleportRequestCUI(player);
                return;
            }
#if DEBUG
            Puts("Calling CheckPlayer from cmdChatTeleportAccept");
#endif
            string err = null;
            var originPlayer = PlayersRequests[player.userID];
            if (originPlayer == null)
            {
                PrintMsgL(player, "NoPendingRequest");
                return;
            }
            if (!CanBypassRestrictions(player.UserIDString))
            {
                if (!TeleportInForcedBoundary(originPlayer, player))
                {
                    return;
                }
                err = CheckPlayer(player, config.TPR.UsableIntoBuildingBlocked, CanCraftTPR(player), false, "tpa");
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                err = CheckPlayer(originPlayer, config.TPR.UsableOutOfBuildingBlocked, CanCraftTPR(originPlayer), true, "tpa");
                if (err != null)
                {
                    PrintMsgL(originPlayer, err);
                    return;
                }
                err = CheckTargetLocation(originPlayer, player.transform.position, config.TPR.UsableIntoBuildingBlocked, config.TPR.CupOwnerAllowOnBuildingBlocked);
                if (err != null)
                {
                    PrintMsgL(player, err);
                    return;
                }
                err = CanPlayerTeleport(player, originPlayer.transform.position, player.transform.position);
                if (err != null)
                {
                    SendReply(player, err);
                    return;
                }
                if (config.TPR.BlockTPAOnCeiling)
                {
                    BaseEntity entity;
                    if (IsStandingOnEntity(player.transform.position, Layers.Mask.Construction, out entity, new string[2] { "floor", "roof" }))
                    {
                        PrintMsgL(player, "HomeNoFoundation");
                        return;
                    }
                    if (IsBlockedOnIceberg(player.transform.position))
                    {
                        PrintMsgL(player, "HomeIce");
                        return;
                    }
                }
                float globalCooldownTime = GetGlobalCooldown(player);
                if (globalCooldownTime > 0f)
                {
                    PrintMsgL(player, "WaitGlobalCooldown", 