50, new List<string> {"weather.fog 0.12" } },
						{370, new List<string> {"weather.fog 0.14" } },
						{390, new List<string> {"weather.fog 0.16" } },
						{410, new List<string> {"weather.fog 0.18", "weather.atmosphere_rayleigh 3.0" } },
						{430, new List<string> {"weather.fog 0.20" } },
						{450, new List<string> {"weather.fog 0.22" } },
						{470, new List<string> {"weather.fog 0.24" } },
						{490, new List<string> {"weather.fog 0.26" } },
						{510, new List<string> {"weather.fog 0.28" } },
						{530, new List<string> {"weather.fog 0.3", "weather.atmosphere_rayleigh 4.0" } },
						{2560, new List<string> {"weather.fog 0.28" } },
						{2580, new List<string> {"weather.fog 0.26" } },
						{2600, new List<string> {"weather.fog 0.24" } },
						{2620, new List<string> {"weather.fog 0.22" } },
						{2640, new List<string> {"weather.fog 0.2" } },
						{2660, new List<string> {"weather.fog 0.18", "weather.atmosphere_rayleigh 3.0" } },
						{2680, new List<string> {"weather.fog 0.16" } },
						{2700, new List<string> {"weather.fog 0.14" } },
						{2720, new List<string> {"weather.fog 0.12" } },
						{2740, new List<string> {"weather.fog 0.1" } },
						{2760, new List<string> {"weather.fog 0.08" } },
						{2780, new List<string> {"weather.fog 0.06" } },
						{2800, new List<string> {"weather.fog 0.04", "weather.atmosphere_rayleigh 2.0" } },
						{2820, new List<string> {"weather.fog 0.02" } },
						{2830, new List<string> {"weather.cloud_coverage 0.5" } },
						{2840, new List<string> {"weather.fog 0" } },
						{2850, new List<string> {"weather.cloud_coverage 0.48" } },
						{2860, new List<string> {"weather.cloud_coverage 0.46" } },
						{2870, new List<string> {"weather.cloud_coverage 0.44" } },
						{2880, new List<string> {"weather.cloud_coverage 0.42" } },
						{2890, new List<string> {"weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh 1.5", "weather.atmosphere_contrast 1.5" } },
						{2900, new List<string> {"weather.cloud_coverage 0.38" } },
						{2910, new List<string> {"weather.cloud_coverage 0.36" } },
						{2920, new List<string> {"weather.cloud_coverage 0.34" } },
						{2930, new List<string> {"weather.cloud_coverage 0.32" } },
						{2940, new List<string> {"weather.cloud_coverage 0.3", "weather.atmosphere_rayleigh -1", "weather.atmosphere_contrast -1", "weather.cloud_size 0.8" } },
						{2950, new List<string> {"weather.cloud_coverage 0.28" } },
						{2960, new List<string> {"weather.cloud_coverage 0.26" } },
						{2970, new List<string> {"weather.cloud_coverage 0.24" } },
						{2980, new List<string> {"weather.cloud_coverage 0.22" } },
						{2990, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_size 0.9" } },
						{3000, new List<string> {"weather.cloud_coverage 0.18" } },
						{3010, new List<string> {"weather.cloud_coverage 0.16" } },
						{3020, new List<string> {"weather.cloud_coverage 0.14" } },
						{3030, new List<string> {"weather.cloud_coverage 0.12" } },
						{3040, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_size -1" } },
						{3050, new List<string> {"weather.cloud_coverage 0.08" } },
						{3060, new List<string> {"weather.cloud_coverage 0.06" } },
						{3070, new List<string> {"weather.cloud_coverage 0.04" } },
						{3080, new List<string> {"weather.cloud_coverage 0.02" } },						
                        {3090, new List<string> {"weather.cloud_coverage 0", "weather.reset", "STOP" } },
                    }
                    },
					{"heavyfog", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.cloud_coverage 0.02" } },
						{10, new List<string> {"weather.cloud_coverage 0.04" } },
						{20, new List<string> {"weather.cloud_coverage 0.06" } },
						{30, new List<string> {"weather.cloud_coverage 0.08" } },
						{40, new List<string> {"weather.cloud_coverage 0.1" } },
						{50, new List<string> {"weather.cloud_coverage 0.12" } },
						{60, new List<string> {"weather.cloud_coverage 0.14" } },
						{70, new List<string> {"weather.cloud_coverage 0.16" } },
						{80, new List<string> {"weather.cloud_coverage 0.18" } },
						{90, new List<string> {"weather.cloud_coverage 0.2" } },
						{100, new List<string> {"weather.cloud_coverage 0.22" } },
						{110, new List<string> {"weather.cloud_coverage 0.24" } },
						{120, new List<string> {"weather.cloud_coverage 0.26" } },
						{130, new List<string> {"weather.cloud_coverage 0.28" } },
						{140, new List<string> {"weather.cloud_coverage 0.3", "weather.cloud_attenuation 1.125", "weather.atmosphere_contrast 0.9", "weather.cloud_coloring 0.8" } },
						{150, new List<string> {"weather.cloud_coverage 0.32" } },
						{160, new List<string> {"weather.cloud_coverage 0.34" } },
						{170, new List<string> {"weather.cloud_coverage 0.36" } },
						{180, new List<string> {"weather.cloud_coverage 0.38" } },
						{190, new List<string> {"weather.cloud_coverage 0.4" } },
						{200, new List<string> {"weather.cloud_coverage 0.42" } },
						{210, new List<string> {"weather.cloud_coverage 0.44" } },
						{220, new List<string> {"weather.cloud_coverage 0.46" } },
						{230, new List<string> {"weather.cloud_coverage 0.48" } },
						{240, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation 1.25", "weather.atmosphere_contrast 0.8", "weather.cloud_coloring 0.6" } },
						{250, new List<string> {"weather.fog 0.02" } },
						{260, new List<string> {"weather.cloud_coverage 0.52" } },
						{270, new List<string> {"weather.fog 0.04" } },
						{280, new List<string> {"weather.cloud_coverage 0.54" } },
						{290, new List<string> {"weather.fog 0.06" } },
						{300, new List<string> {"weather.cloud_coverage 0.56" } },
						{310, new List<string> {"weather.fog 0.08" } },
						{320, new List<string> {"weather.cloud_coverage 0.58" } },
						{330, new List<string> {"weather.fog 0.1" } },
						{340, new List<string> {"weather.cloud_coverage 0.6" } },
						{350, new List<string> {"weather.fog 0.12" } },
						{360, new List<string> {"weather.cloud_coverage 0.62" } },
						{370, new List<string> {"weather.fog 0.14" } },
						{380, new List<string> {"weather.cloud_coverage 0.64" } },
						{390, new List<string> {"weather.fog 0.16" } },
						{400, new List<string> {"weather.cloud_coverage 0.66" } },
						{410, new List<string> {"weather.fog 0.18" } },
						{420, new List<string> {"weather.cloud_coverage 0.68" } },
						{430, new List<string> {"weather.fog 0.20" } },
						{440, new List<string> {"weather.cloud_coverage 0.7" } },
						{450, new List<string> {"weather.fog 0.22" } },
						{460, new List<string> {"weather.cloud_coverage 0.72" } },
						{470, new List<string> {"weather.fog 0.24" } },
						{480, new List<string> {"weather.cloud_coverage 0.74", "weather.cloud_attenuation 1.5", "weather.atmosphere_contrast 0.4", "weather.cloud_coloring 0.4" } },
						{490, new List<string> {"weather.fog 0.26" } },
						{500, new List<string> {"weather.cloud_coverage 0.76" } },
						{510, new List<string> {"weather.fog 0.28" } },
						{520, new List<string> {"weather.cloud_coverage 0.78" } },
						{530, new List<string> {"weather.fog 0.3" } },
						{540, new List<string> {"weather.cloud_coverage 0.8" } },
						{550, new List<string> {"weather.fog 0.32" } },
						{560, new List<string> {"weather.cloud_coverage 0.82" } },
						{570, new List<string> {"weather.fog 0.34" } },
						{580, new List<string> {"weather.cloud_coverage 0.84" } },
						{590, new List<string> {"weather.fog 0.36" } },
						{600, new List<string> {"weather.cloud_coverage 0.86" } },
						{610, new List<string> {"weather.fog 0.38" } },
						{620, new List<string> {"weather.cloud_coverage 0.88" } },
						{630, new List<string> {"weather.fog 0.4" } },
						{640, new List<string> {"weather.cloud_coverage 0.9" } },
						{650, new List<string> {"weather.fog 0.42" } },
						{660, new List<string> {"weather.cloud_coverage 0.92" } },
						{670, new List<string> {"weather.fog 0.44" } },
						{680, new List<string> {"weather.cloud_coverage 0.94" } },
						{690, new List<string> {"weather.fog 0.46" } },
						{700, new List<string> {"weather.cloud_coverage 0.96" } },
						{710, new List<string> {"weather.fog 0.48" } },
						{720, new List<string> {"weather.cloud_coverage 0.98" } },
						{730, new List<string> {"weather.fog 0.5" } },
						{740, new List<string> {"weather.cloud_coverage 1" } },
						{750, new List<string> {"weather.fog 0.52" } },
						{760, new List<string> {"weather.fog 0.54" } },
						{780, new List<string> {"weather.fog 0.56" } },
						{790, new List<string> {"weather.fog 0.58" } },
						{800, new List<string> {"weather.fog 0.6" } },
						{810, new List<string> {"weather.fog 0.62" } },
						{820, new List<string> {"weather.fog 0.64" } },
						{830, new List<string> {"weather.fog 0.66" } },
						{840, new List<string> {"weather.fog 0.68" } },
						{850, new List<string> {"weather.fog 0.7" } },
						{860, new List<string> {"weather.fog 0.72" } },
						{870, new List<string> {"weather.fog 0.74" } },
						{880, new List<string> {"weather.fog 0.76" } },
						{2410, new List<string> {"weather.fog 0.76" } },
						{2420, new List<string> {"weather.fog 0.74" } },
						{2430, new List<string> {"weather.fog 0.72" } },
						{2440, new List<string> {"weather.fog 0.7" } },
						{2450, new List<string> {"weather.fog 0.68" } },
						{2460, new List<string> {"weather.fog 0.66" } },
						{2470, new List<string> {"weather.fog 0.64" } },
						{2480, new List<string> {"weather.fog 0.62" } },
						{2490, new List<string> {"weather.fog 0.6" } },
						{2500, new List<string> {"weather.fog 0.58" } },
						{2510, new List<string> {"weather.fog 0.56" } },
						{2520, new List<string> {"weather.fog 0.54" } },
						{2530, new List<string> {"weather.fog 0.52" } },
						{2540, new List<string> {"weather.fog 0.5" } },
						{2550, new List<string> {"weather.cloud_coverage 0.98" } },
						{2560, new List<string> {"weather.fog 0.48" } },
						{2570, new List<string> {"weather.cloud_coverage 0.96" } },
						{2580, new List<string> {"weather.fog 0.46" } },
						{2590, new List<string> {"weather.cloud_coverage 0.94" } },
						{2600, new List<string> {"weather.fog 0.44" } },
						{2610, new List<string> {"weather.cloud_coverage 0.92" } },
						{2620, new List<string> {"weather.fog 0.42" } },
						{2630, new List<string> {"weather.cloud_coverage 0.9" } },
						{2640, new List<string> {"weather.fog 0.4" } },
						{2650, new List<string> {"weather.cloud_coverage 0.88" } },
						{2660, new List<string> {"weather.fog 0.38" } },
						{2670, new List<string> {"weather.cloud_coverage 0.86" } },
						{2680, new List<string> {"weather.fog 0.36" } },
						{2690, new List<string> {"weather.cloud_coverage 0.84" } },
						{2700, new List<string> {"weather.fog 0.34" } },
						{2710, new List<string> {"weather.cloud_coverage 0.82" } },
						{2720, new List<string> {"weather.fog 0.32" } },
						{2730, new List<string> {"weather.cloud_coverage 0.8" } },
						{2740, new List<string> {"weather.fog 0.3" } },
						{2750, new List<string> {"weather.cloud_coverage 0.78" } },
						{2760, new List<string> {"weather.fog 0.28" } },
						{2770, new List<string> {"weather.cloud_coverage 0.76", "weather.cloud_attenuation 1.25", "weather.atmosphere_contrast 0.8", "weather.cloud_coloring 0.6" } },
						{2780, new List<string> {"weather.fog 0.26" } },
						{2790, new List<string> {"weather.cloud_coverage 0.74" } },
						{2800, new List<string> {"weather.fog 0.24" } },
						{2810, new List<string> {"weather.cloud_coverage 0.72" } },
						{2820, new List<string> {"weather.fog 0.22" } },
						{2830, new List<string> {"weather.cloud_coverage 0.7" } },
						{2840, new List<string> {"weather.fog 0.2" } },
						{2850, new List<string> {"weather.cloud_coverage 0.68" } },
						{2860, new List<string> {"weather.fog 0.18" } },
						{2870, new List<string> {"weather.cloud_coverage 0.66" } },
						{2880, new List<string> {"weather.fog 0.16" } },
						{2890, new List<string> {"weather.cloud_coverage 0.64" } },
						{2900, new List<string> {"weather.fog 0.14" } },
						{2910, new List<string> {"weather.cloud_coverage 0.62" } },
						{2920, new List<string> {"weather.fog 0.12" } },
						{2930, new List<string> {"weather.cloud_coverage 0.6" } },
						{2940, new List<string> {"weather.fog 0.1" } },
						{2950, new List<string> {"weather.cloud_coverage 0.58" } },
						{2960, new List<string> {"weather.fog 0.08" } },
						{2970, new List<string> {"weather.cloud_coverage 0.56" } },
						{2980, new List<string> {"weather.fog 0.06" } },
						{2990, new List<string> {"weather.cloud_coverage 0.54" } },
						{3000, new List<string> {"weather.fog 0.04" } },
						{3010, new List<string> {"weather.cloud_coverage 0.52" } },
						{3020, new List<string> {"weather.fog 0.02" } },
						{3030, new List<string> {"weather.cloud_coverage 0.5" } },
						{3040, new List<string> {"weather.fog 0" } },
						{3050, new List<string> {"weather.cloud_coverage 0.48" } },
						{3060, new List<string> {"weather.cloud_coverage 0.46" } },
						{3070, new List<string> {"weather.cloud_coverage 0.44" } },
						{3080, new List<string> {"weather.cloud_coverage 0.42" } },
						{3090, new List<string> {"weather.cloud_coverage 0.4" } },
						{3100, new List<string> {"weather.cloud_coverage 0.38" } },
						{3110, new List<string> {"weather.cloud_coverage 0.36" } },
						{3120, new List<string> {"weather.cloud_coverage 0.34", "weather.cloud_attenuation 0.125", "weather.atmosphere_contrast 0.9", "weather.cloud_coloring 0.8" } },
						{3130, new List<string> {"weather.cloud_coverage 0.32" } },
						{3140, new List<string> {"weather.cloud_coverage 0.3" } },
						{3150, new List<string> {"weather.cloud_coverage 0.28" } },
						{3160, new List<string> {"weather.cloud_coverage 0.26" } },
						{3170, new List<string> {"weather.cloud_coverage 0.24" } },
						{3180, new List<string> {"weather.cloud_coverage 0.22" } },
						{3190, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_attenuation -1", "weather.atmosphere_contrast -1", "weather.cloud_coloring -1" } },
						{3200, new List<string> {"weather.cloud_coverage 0.18" } },
						{3210, new List<string> {"weather.cloud_coverage 0.16" } },
						{3220, new List<string> {"weather.cloud_coverage 0.14" } },
						{3230, new List<string> {"weather.cloud_coverage 0.12" } },
						{3240, new List<string> {"weather.cloud_coverage 0.1" } },
						{3250, new List<string> {"weather.cloud_coverage 0.08" } },
						{3260, new List<string> {"weather.cloud_coverage 0.06" } },
						{3270, new List<string> {"weather.cloud_coverage 0.04" } },
						{3280, new List<string> {"weather.cloud_coverage 0.02" } },						
                        {3290, new List<string> {"weather.cloud_coverage 0", "weather.reset", "STOP" } },
                    }
                    },
					{"overcast", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.cloud_coverage 0.01" } },
						{10, new List<string> {"weather.cloud_coverage 0.02" } },
						{20, new List<string> {"weather.cloud_coverage 0.04" } },
						{30, new List<string> {"weather.cloud_coverage 0.06" } },
						{40, new List<string> {"weather.cloud_coverage 0.08" } },
						{50, new List<string> {"weather.cloud_coverage 0.1" } },
						{60, new List<string> {"weather.cloud_coverage 0.12" } },
						{70, new List<string> {"weather.cloud_coverage 0.14" } },
						{80, new List<string> {"weather.cloud_coverage 0.16" } },
						{90, new List<string> {"weather.cloud_coverage 0.18" } },
						{100, new List<string> {"weather.cloud_coverage 0.2" } },
						{110, new List<string> {"weather.cloud_coverage 0.22" } },
						{120, new List<string> {"weather.cloud_coverage 0.24" } },
						{130, new List<string> {"weather.cloud_coverage 0.26" } },
						{140, new List<string> {"weather.cloud_coverage 0.28" } },
						{150, new List<string> {"weather.cloud_coverage 0.3" } },
						{160, new List<string> {"weather.cloud_coverage 0.32", "weather.cloud_attenuation 0.1", "weather.atmosphere_contrast 0.9" } },
						{170, new List<string> {"weather.cloud_coverage 0.34" } },
						{180, new List<string> {"weather.cloud_coverage 0.36" } },
						{190, new List<string> {"weather.cloud_coverage 0.38" } },
						{200, new List<string> {"weather.cloud_coverage 0.4" } },
						{210, new List<string> {"weather.cloud_coverage 0.42" } },
						{220, new List<string> {"weather.cloud_coverage 0.44" } },
						{230, new List<string> {"weather.cloud_coverage 0.46" } },
						{240, new List<string> {"weather.cloud_coverage 0.48" } },
						{250, new List<string> {"weather.cloud_coverage 0.5" } },
						{260, new List<string> {"weather.cloud_coverage 0.52" } },
						{270, new List<string> {"weather.cloud_coverage 0.54" } },
						{280, new List<string> {"weather.cloud_coverage 0.56" } },
						{290, new List<string> {"weather.cloud_coverage 0.58" } },
						{300, new List<string> {"weather.cloud_coverage 0.6" } },
						{310, new List<string> {"weather.cloud_coverage 0.62" } },
						{320, new List<string> {"weather.cloud_coverage 0.64" } },
						{330, new List<string> {"weather.cloud_coverage 0.66", "weather.cloud_attenuation 0.2", "weather.atmosphere_contrast 0.8" } },
						{340, new List<string> {"weather.cloud_coverage 0.68" } },
						{350, new List<string> {"weather.cloud_coverage 0.7" } },
						{360, new List<string> {"weather.cloud_coverage 0.72" } },
						{370, new List<string> {"weather.cloud_coverage 0.74" } },
						{380, new List<string> {"weather.cloud_coverage 0.76" } },
						{390, new List<string> {"weather.cloud_coverage 0.78" } },
						{400, new List<string> {"weather.cloud_coverage 0.8" } },
						{410, new List<string> {"weather.cloud_coverage 0.82" } },
						{420, new List<string> {"weather.cloud_coverage 0.84" } },
						{430, new List<string> {"weather.cloud_coverage 0.86" } },
						{440, new List<string> {"weather.cloud_coverage 0.88" } },
						{450, new List<string> {"weather.cloud_coverage 0.9" } },
						{460, new List<string> {"weather.cloud_coverage 0.92" } },
						{470, new List<string> {"weather.cloud_coverage 0.94" } },
						{480, new List<string> {"weather.cloud_coverage 0.96" } },
						{490, new List<string> {"weather.cloud_coverage 0.98" } },
						{500, new List<string> {"weather.cloud_coverage 1" } },
						{2500, new List<string> {"weather.cloud_coverage 0.98" } },
						{2510, new List<string> {"weather.cloud_coverage 0.96" } },
						{2520, new List<string> {"weather.cloud_coverage 0.94" } },
						{2530, new List<string> {"weather.cloud_coverage 0.92" } },
						{2640, new List<string> {"weather.cloud_coverage 0.9" } },
						{2650, new List<string> {"weather.cloud_coverage 0.88" } },
						{2660, new List<string> {"weather.cloud_coverage 0.86" } },
						{2670, new List<string> {"weather.cloud_coverage 0.84" } },
						{2780, new List<string> {"weather.cloud_coverage 0.82" } },
						{2790, new List<string> {"weather.cloud_coverage 0.8" } },
						{2700, new List<string> {"weather.cloud_coverage 0.78" } },
						{2710, new List<string> {"weather.cloud_coverage 0.76" } },
						{2820, new List<string> {"weather.cloud_coverage 0.74" } },
						{2830, new List<string> {"weather.cloud_coverage 0.72" } },
						{2840, new List<string> {"weather.cloud_coverage 0.7" } },
						{2850, new List<string> {"weather.cloud_coverage 0.68" } },
						{2960, new List<string> {"weather.cloud_coverage 0.66", "weather.cloud_attenuation 0.1", "weather.atmosphere_contrast 0.9" } },
						{2970, new List<string> {"weather.cloud_coverage 0.64" } },
						{2980, new List<string> {"weather.cloud_coverage 0.62" } },
						{2990, new List<string> {"weather.cloud_coverage 0.6" } },
						{3300, new List<string> {"weather.cloud_coverage 0.58" } },
						{3310, new List<string> {"weather.cloud_coverage 0.56" } },
						{3320, new List<string> {"weather.cloud_coverage 0.54" } },
						{3330, new List<string> {"weather.cloud_coverage 0.52" } },
						{3340, new List<string> {"weather.cloud_coverage 0.5" } },
						{3350, new List<string> {"weather.cloud_coverage 0.48" } },
						{3360, new List<string> {"weather.cloud_coverage 0.46" } },
						{3370, new List<string> {"weather.cloud_coverage 0.44" } },
						{3380, new List<string> {"weather.cloud_coverage 0.42" } },
						{3390, new List<string> {"weather.cloud_coverage 0.4" } },
						{3400, new List<string> {"weather.cloud_coverage 0.38" } },
						{3410, new List<string> {"weather.cloud_coverage 0.36" } },
						{3420, new List<string> {"weather.cloud_coverage 0.34" } },
						{3430, new List<string> {"weather.cloud_coverage 0.32", "weather.cloud_attenuation -1", "weather.atmosphere_contrast -1" } },
						{3440, new List<string> {"weather.cloud_coverage 0.3" } },
						{3450, new List<string> {"weather.cloud_coverage 0.28" } },
						{3460, new List<string> {"weather.cloud_coverage 0.26" } },
						{3470, new List<string> {"weather.cloud_coverage 0.24" } },
						{3480, new List<string> {"weather.cloud_coverage 0.22" } },
						{3490, new List<string> {"weather.cloud_coverage 0.2" } },
						{3500, new List<string> {"weather.cloud_coverage 0.18" } },
						{3510, new List<string> {"weather.cloud_coverage 0.16" } },
						{3520, new List<string> {"weather.cloud_coverage 0.14" } },
						{3530, new List<string> {"weather.cloud_coverage 0.12" } },
						{3540, new List<string> {"weather.cloud_coverage 0.1" } },
						{3550, new List<string> {"weather.cloud_coverage 0.08" } },
						{3560, new List<string> {"weather.cloud_coverage 0.06" } },
						{3570, new List<string> {"weather.cloud_coverage 0.04" } },
						{3580, new List<string> {"weather.cloud_coverage 0.02" } },
                        {3590, new List<string> {"weather.cloud_coverage 0", "weather.reset", "STOP" } },
                    }
                    },
					{"partlycloudy", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.cloud_coverage 0.02" } },
						{10, new List<string> {"weather.cloud_coverage 0.04" } },
						{20, new List<string> {"weather.cloud_coverage 0.06" } },
						{30, new List<string> {"weather.cloud_coverage 0.08" } },
						{40, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_opacity 0.9", "weather.cloud_size 0.9" } },
						{50, new List<string> {"weather.cloud_coverage 0.12" } },
						{60, new List<string> {"weather.cloud_coverage 0.14" } },
						{70, new List<string> {"weather.cloud_coverage 0.16" } },
						{80, new List<string> {"weather.cloud_coverage 0.18" } },
						{90, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_opacity 0.8" } },
						{100, new List<string> {"weather.cloud_coverage 0.22" } },
						{110, new List<string> {"weather.cloud_coverage 0.24" } },
						{120, new List<string> {"weather.cloud_coverage 0.26" } },
						{130, new List<string> {"weather.cloud_coverage 0.28" } },
						{140, new List<string> {"weather.cloud_coverage 0.3", "weather.cloud_opacity 0.7" } },
						{150, new List<string> {"weather.cloud_coverage 0.32" } },
						{160, new List<string> {"weather.cloud_coverage 0.34" } },
						{170, new List<string> {"weather.cloud_coverage 0.36" } },
						{180, new List<string> {"weather.cloud_coverage 0.38" } },
						{190, new List<string> {"weather.cloud_coverage 0.4" } },
						{300, new List<string> {"weather.cloud_coverage 0.42" } },
						{310, new List<string> {"weather.cloud_coverage 0.44" } },
						{320, new List<string> {"weather.cloud_coverage 0.46" } },
						{330, new List<string> {"weather.cloud_coverage 0.48" } },
						{340, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation 0.1" } },
						{360, new List<string> {"weather.cloud_coverage 0.52" } },
						{380, new List<string> {"weather.cloud_coverage 0.54" } },
						{500, new List<string> {"weather.cloud_coverage 0.56" } },
						{520, new List<string> {"weather.cloud_coverage 0.58" } },
						{540, new List<string> {"weather.cloud_coverage 0.6" } },
						{560, new List<string> {"weather.cloud_coverage 0.62" } },
						{580, new List<string> {"weather.cloud_coverage 0.64" } },
						{700, new List<string> {"weather.cloud_coverage 0.66" } },
						{720, new List<string> {"weather.cloud_coverage 0.68" } },
						{740, new List<string> {"weather.cloud_coverage 0.7" } },
						{760, new List<string> {"weather.cloud_coverage 0.72" } },
						{780, new List<string> {"weather.cloud_coverage 0.74" } },
						{900, new List<string> {"weather.cloud_coverage 0.75" } },
						{2290, new List<string> {"weather.cloud_coverage 0.74" } },
						{2310, new List<string> {"weather.cloud_coverage 0.72" } },
						{2330, new List<string> {"weather.cloud_coverage 0.7" } },
						{2350, new List<string> {"weather.cloud_coverage 0.68" } },
						{2370, new List<string> {"weather.cloud_coverage 0.66" } },
						{2390, new List<string> {"weather.cloud_coverage 0.64" } },
						{2510, new List<string> {"weather.cloud_coverage 0.62" } },
						{2530, new List<string> {"weather.cloud_coverage 0.6" } },
						{2550, new List<string> {"weather.cloud_coverage 0.58" } },
						{2570, new List<string> {"weather.cloud_coverage 0.56" } },
						{2590, new List<string> {"weather.cloud_coverage 0.54" } },
						{2710, new List<string> {"weather.cloud_coverage 0.52" } },
						{2730, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation -1" } },
						{2750, new List<string> {"weather.cloud_coverage 0.48" } },
						{2760, new List<string> {"weather.cloud_coverage 0.46" } },
						{2770, new List<string> {"weather.cloud_coverage 0.44" } },
						{2780, new List<string> {"weather.cloud_coverage 0.42" } },
						{2790, new List<string> {"weather.cloud_coverage 0.4" } },
						{2900, new List<string> {"weather.cloud_coverage 0.38" } },
						{2910, new List<string> {"weather.cloud_coverage 0.36" } },
						{2920, new List<string> {"weather.cloud_coverage 0.34" } },
						{2930, new List<string> {"weather.cloud_coverage 0.32" } },
						{2940, new List<string> {"weather.cloud_coverage 0.3", "weather.cloud_opacity 0.8" } },
						{2950, new List<string> {"weather.cloud_coverage 0.28" } },
						{2960, new List<string> {"weather.cloud_coverage 0.26" } },
						{2970, new List<string> {"weather.cloud_coverage 0.24" } },
						{2980, new List<string> {"weather.cloud_coverage 0.22" } },
						{2990, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_opacity 0.9" } },
						{3100, new List<string> {"weather.cloud_coverage 0.18" } },
						{3110, new List<string> {"weather.cloud_coverage 0.16" } },
						{3120, new List<string> {"weather.cloud_coverage 0.14" } },
						{3130, new List<string> {"weather.cloud_coverage 0.12" } },
						{3140, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_opacity -1" } },
						{3150, new List<string> {"weather.cloud_coverage 0.08" } },
						{3160, new List<string> {"weather.cloud_coverage 0.06" } },
						{3170, new List<string> {"weather.cloud_coverage 0.04" } },
						{3180, new List<string> {"weather.cloud_coverage 0.02" } },						
                        {3190, new List<string> {"weather.cloud_coverage 0", "weather.reset", "STOP" } },
                    }
                    },
					{"spottyshowers", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.cloud_coverage 0.01" } },
						{10, new List<string> {"weather.cloud_coverage 0.02" } },
						{20, new List<string> {"weather.cloud_coverage 0.04", "weather.cloud_size 1.25" } },
						{30, new List<string> {"weather.cloud_coverage 0.06" } },
						{40, new List<string> {"weather.cloud_coverage 0.08" } },
						{50, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_size 1.5" } },
						{60, new List<string> {"weather.cloud_coverage 0.12" } },
						{70, new List<string> {"weather.cloud_coverage 0.14" } },
						{80, new List<string> {"weather.cloud_coverage 0.16" } },
						{90, new List<string> {"weather.cloud_coverage 0.18" } },
						{100, new List<string> {"weather.cloud_coverage 0.2" } },
						{110, new List<string> {"weather.cloud_coverage 0.22" } },
						{120, new List<string> {"weather.cloud_coverage 0.24" } },
						{130, new List<string> {"weather.cloud_coverage 0.26" } },
						{140, new List<string> {"weather.cloud_coverage 0.28" } },
						{150, new List<string> {"weather.cloud_coverage 0.3" } },
						{160, new List<string> {"weather.cloud_coverage 0.32" } },
						{170, new List<string> {"weather.cloud_coverage 0.34" } },
						{180, new List<string> {"weather.cloud_coverage 0.36" } },
						{190, new List<string> {"weather.cloud_coverage 0.38" } },
						{200, new List<string> {"weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh 1.5" } },
						{210, new List<string> {"weather.cloud_coverage 0.42" } },
						{220, new List<string> {"weather.cloud_coverage 0.44" } },
						{230, new List<string> {"weather.cloud_coverage 0.46" } },
						{240, new List<string> {"weather.cloud_coverage 0.48" } },
						{250, new List<string> {"weather.cloud_coverage 0.5" } },
						{260, new List<string> {"weather.cloud_coverage 0.52" } },
						{270, new List<string> {"weather.cloud_coverage 0.54" } },
						{280, new List<string> {"weather.cloud_coverage 0.56" } },
						{290, new List<string> {"weather.cloud_coverage 0.58" } },
						{300, new List<string> {"weather.cloud_coverage 0.6" } },
						{310, new List<string> {"weather.cloud_coverage 0.62" } },
						{320, new List<string> {"weather.cloud_coverage 0.64" } },
						{330, new List<string> {"weather.cloud_coverage 0.66" } },
						{340, new List<string> {"weather.cloud_coverage 0.68" } },
						{350, new List<string> {"weather.cloud_coverage 0.7" } },
						{360, new List<string> {"weather.cloud_coverage 0.72" } },
						{370, new List<string> {"weather.cloud_coverage 0.74" } },
						{380, new List<string> { "weather.cloud_coverage 0.75", "weather.cloud_attenuation 0.1" } },
                        {480, new List<string> { "weather.rain 0.03", "weather.rainbow 1" } },
                        {510, new List<string> { "weather.rain 0.06" } },
                        {560, new List<string> { "weather.rain 0.09" } },
                        {590, new List<string> { "weather.rain 0.12" } },
                        {620, new List<string> { "weather.rain 0.15" } },
                        {1090, new List<string> { "weather.rain 0.18" } },
                        {1150, new List<string> { "weather.rain 0.21" } },
						{1180, new List<string> { "weather.cloud_coverage 0.74", "weather.cloud_attenuation -1" } },
						{1190, new List<string> { "weather.cloud_coverage 0.72" } },
						{1200, new List<string> { "weather.cloud_coverage 0.7" } },
                        {1210, new List<string> { "weather.rain 0.15" } },
						{1220, new List<string> { "weather.cloud_coverage 0.68" } },
						{1230, new List<string> { "weather.cloud_coverage 0.66" } },
						{1240, new List<string> { "weather.cloud_coverage 0.64" } },
						{1250, new List<string> { "weather.cloud_coverage 0.62" } },
                        {1260, new List<string> { "weather.rain 0.08" } },
						{1270, new List<string> { "weather.cloud_coverage 0.6" } },
						{1280, new List<string> { "weather.cloud_coverage 0.58" } },
						{1290, new List<string> { "weather.cloud_coverage 0.56" } },
						{1300, new List<string> { "weather.cloud_coverage 0.54" } },
						{1310, new List<string> { "weather.cloud_coverage 0.52" } },
						{1320, new List<string> { "weather.cloud_coverage 0.5" } },
                        {1330, new List<string> { "weather.rain 0" } },
						{1350, new List<string> { "weather.cloud_coverage 0.48" } },
						{1370, new List<string> { "weather.cloud_coverage 0.46" } },
						{1390, new List<string> { "weather.cloud_coverage 0.44" } },
						{1410, new List<string> { "weather.cloud_coverage 0.42" } },
						{1430, new List<string> { "weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh -1" } },
						{1450, new List<string> { "weather.cloud_coverage 0.38" } },
						{1470, new List<string> { "weather.cloud_coverage 0.36" } },
						{1490, new List<string> { "weather.cloud_coverage 0.34" } },
						{1510, new List<string> { "weather.cloud_coverage 0.32" } },
						{2500, new List<string> {"weather.cloud_coverage 0.3" } },
						{2510, new List<string> {"weather.cloud_coverage 0.32" } },
						{2520, new List<string> {"weather.cloud_coverage 0.34" } },
						{2530, new List<string> {"weather.cloud_coverage 0.36" } },
						{2540, new List<string> {"weather.cloud_coverage 0.38" } },
						{2550, new List<string> {"weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh 1.5" } },
						{2560, new List<string> {"weather.cloud_coverage 0.42" } },
						{2570, new List<string> {"weather.cloud_coverage 0.44" } },
						{2580, new List<string> {"weather.cloud_coverage 0.46" } },
						{2590, new List<string> {"weather.cloud_coverage 0.48" } },
						{3000, new List<string> {"weather.cloud_coverage 0.5" } },
						{3010, new List<string> {"weather.cloud_coverage 0.52" } },
						{3020, new List<string> {"weather.cloud_coverage 0.54" } },
						{3030, new List<string> {"weather.cloud_coverage 0.56" } },
						{3040, new List<string> {"weather.cloud_coverage 0.58" } },
						{3050, new List<string> {"weather.cloud_coverage 0.6" } },
						{3060, new List<string> {"weather.cloud_coverage 0.64" } },
						{3070, new List<string> {"weather.cloud_coverage 0.66" } },
						{3080, new List<string> {"weather.cloud_coverage 0.68" } },
						{3090, new List<string> {"weather.cloud_coverage 0.7" } },
						{3100, new List<string> {"weather.cloud_coverage 0.72" } },
						{3110, new List<string> {"weather.cloud_coverage 0.74" } },
						{3120, new List<string> { "weather.cloud_coverage 0.75", "weather.cloud_attenuation 0.1" } },
                        {3130, new List<string> { "weather.rain 0.03" } },
                        {3140, new List<string> { "weather.rain 0.06" } },
                        {3150, new List<string> { "weather.rain 0.09" } },
                        {3160, new List<string> { "weather.rain 0.12" } },
                        {3170, new List<string> { "weather.rain 0.15" } },
                        {3180, new List<string> { "weather.rain 0.18" } },
                        {3190, new List<string> { "weather.rain 0.21" } },
						{3200, new List<string> { "weather.cloud_coverage 0.74", "weather.cloud_attenuation -1" } },
						{3205, new List<string> { "weather.cloud_coverage 0.72" } },
						{3210, new List<string> { "weather.cloud_coverage 0.7" } },
                        {3215, new List<string> { "weather.rain 0.15" } },
						{3220, new List<string> { "weather.cloud_coverage 0.68" } },
						{3225, new List<string> { "weather.cloud_coverage 0.66" } },
						{3230, new List<string> { "weather.cloud_coverage 0.64" } },
						{3235, new List<string> { "weather.cloud_coverage 0.62" } },
                        {3240, new List<string> { "weather.rain 0.08" } },
						{3245, new List<string> { "weather.cloud_coverage 0.6" } },
						{3250, new List<string> { "weather.cloud_coverage 0.58" } },
						{3255, new List<string> { "weather.cloud_coverage 0.56" } },
						{3260, new List<string> { "weather.cloud_coverage 0.54" } },
						{3265, new List<string> { "weather.cloud_coverage 0.52" } },
						{3270, new List<string> { "weather.cloud_coverage 0.5" } },
                        {3280, new List<string> { "weather.rain 0" } },
						{3285, new List<string> { "weather.cloud_coverage 0.48" } },
						{3290, new List<string> { "weather.cloud_coverage 0.46" } },
						{3295, new List<string> { "weather.cloud_coverage 0.44" } },
						{3300, new List<string> { "weather.cloud_coverage 0.42" } },
						{3305, new List<string> { "weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh -1" } },
						{3310, new List<string> { "weather.cloud_coverage 0.38" } },
						{3315, new List<string> { "weather.cloud_coverage 0.36" } },
						{3320, new List<string> { "weather.cloud_coverage 0.34" } },
						{3325, new List<string> { "weather.cloud_coverage 0.32", "weather.cloud_size 1.25" } },
						{3330, new List<string> { "weather.cloud_coverage 0.3" } },
						{3335, new List<string> { "weather.cloud_coverage 0.28" } },
						{3340, new List<string> { "weather.cloud_coverage 0.26" } },
						{3345, new List<string> { "weather.cloud_coverage 0.24" } },
						{3350, new List<string> { "weather.cloud_coverage 0.22" } },
						{3355, new List<string> { "weather.cloud_coverage 0.2" } },
						{3360, new List<string> { "weather.cloud_coverage 0.18" } },
						{3365, new List<string> { "weather.cloud_coverage 0.16" } },
						{3370, new List<string> { "weather.cloud_coverage 0.14" } },
						{3375, new List<string> { "weather.cloud_coverage 0.12" } },
						{3380, new List<string> { "weather.cloud_coverage 0.1", "weather.cloud_size -1" } },
						{3385, new List<string> { "weather.cloud_coverage 0.08" } },
						{3390, new List<string> { "weather.cloud_coverage 0.00", "weather.rainbow -1" } },
                        {3395, new List<string> {"weather.cloud_coverage 0", "weather.reset", "STOP" } },
                    }
                    },
					{"sunandclouds", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.cloud_coverage 0.02" } },
						{10, new List<string> {"weather.cloud_coverage 0.04" } },
						{20, new List<string> {"weather.cloud_coverage 0.06" } },
						{30, new List<string> {"weather.cloud_coverage 0.08" } },
						{40, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_opacity 0.9", "weather.cloud_size 0.9" } },
						{50, new List<string> {"weather.cloud_coverage 0.12" } },
						{60, new List<string> {"weather.cloud_coverage 0.14" } },
						{70, new List<string> {"weather.cloud_coverage 0.16" } },
						{80, new List<string> {"weather.cloud_coverage 0.18" } },
						{90, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_opacity 0.8", "weather.cloud_size 0.8" } },
						{100, new List<string> {"weather.cloud_coverage 0.22" } },
						{110, new List<string> {"weather.cloud_coverage 0.24" } },
						{120, new List<string> {"weather.cloud_coverage 0.26" } },
						{130, new List<string> {"weather.cloud_coverage 0.28" } },
						{140, new List<string> {"weather.cloud_coverage 0.3" } },
						{150, new List<string> {"weather.cloud_coverage 0.32" } },
						{160, new List<string> {"weather.cloud_coverage 0.34" } },
						{170, new List<string> {"weather.cloud_coverage 0.36" } },
						{180, new List<string> {"weather.cloud_coverage 0.38" } },
						{190, new List<string> {"weather.cloud_coverage 0.4" } },
						{300, new List<string> {"weather.cloud_coverage 0.42" } },
						{310, new List<string> {"weather.cloud_coverage 0.44" } },
						{320, new List<string> {"weather.cloud_coverage 0.46" } },
						{330, new List<string> {"weather.cloud_coverage 0.48" } },
						{340, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation 0.1" } },
						{1730, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation -1" } },
						{1750, new List<string> {"weather.cloud_coverage 0.48" } },
						{1760, new List<string> {"weather.cloud_coverage 0.46" } },
						{1770, new List<string> {"weather.cloud_coverage 0.44" } },
						{1780, new List<string> {"weather.cloud_coverage 0.42" } },
						{1790, new List<string> {"weather.cloud_coverage 0.4" } },
						{1900, new List<string> {"weather.cloud_coverage 0.38" } },
						{1910, new List<string> {"weather.cloud_coverage 0.36" } },
						{1920, new List<string> {"weather.cloud_coverage 0.34" } },
						{1930, new List<string> {"weather.cloud_coverage 0.32" } },
						{1940, new List<string> {"weather.cloud_coverage 0.3" } },
						{1950, new List<string> {"weather.cloud_coverage 0.28" } },
						{1960, new List<string> {"weather.cloud_coverage 0.26" } },
						{2320, new List<string> {"weather.cloud_coverage 0.28" } },
						{2330, new List<string> {"weather.cloud_coverage 0.3" } },
						{2340, new List<string> {"weather.cloud_coverage 0.32" } },
						{2350, new List<string> {"weather.cloud_coverage 0.34" } },
						{2360, new List<string> {"weather.cloud_coverage 0.36" } },
						{2370, new List<string> {"weather.cloud_coverage 0.38" } },
						{2380, new List<string> {"weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh 1.25" } },
						{2390, new List<string> {"weather.cloud_coverage 0.42" } },
						{2400, new List<string> {"weather.cloud_coverage 0.44" } },
						{2410, new List<string> {"weather.cloud_coverage 0.46" } },
						{2420, new List<string> {"weather.cloud_coverage 0.48" } },
						{2430, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation 0.1" } },
						{2440, new List<string> {"weather.cloud_coverage 0.52" } },
						{2450, new List<string> {"weather.cloud_coverage 0.54" } },
						{2460, new List<string> {"weather.cloud_coverage 0.56" } },
						{2470, new List<string> {"weather.cloud_coverage 0.58" } },
						{2480, new List<string> {"weather.cloud_coverage 0.6" } },
						{2650, new List<string> {"weather.cloud_coverage 0.58" } },
						{2660, new List<string> {"weather.cloud_coverage 0.56" } },
						{2670, new List<string> {"weather.cloud_coverage 0.54" } },
						{2680, new List<string> {"weather.cloud_coverage 0.52" } },
						{2690, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation -1" } },
						{2700, new List<string> {"weather.cloud_coverage 0.48" } },
						{2710, new List<string> {"weather.cloud_coverage 0.46" } },
						{2720, new List<string> {"weather.cloud_coverage 0.44" } },
						{2730, new List<string> {"weather.cloud_coverage 0.42" } },
						{2740, new List<string> {"weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh -1" } },
						{2750, new List<string> {"weather.cloud_coverage 0.38" } },
						{2760, new List<string> {"weather.cloud_coverage 0.36" } },
						{2770, new List<string> {"weather.cloud_coverage 0.34" } },
						{2930, new List<string> {"weather.cloud_coverage 0.32" } },
						{2940, new List<string> {"weather.cloud_coverage 0.3" } },
						{2950, new List<string> {"weather.cloud_coverage 0.28" } },
						{2960, new List<string> {"weather.cloud_coverage 0.26" } },
						{2970, new List<string> {"weather.cloud_coverage 0.24" } },
						{2980, new List<string> {"weather.cloud_coverage 0.22" } },
						{2990, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_opacity 0.9", "weather.cloud_size 0.9" } },
						{3100, new List<string> {"weather.cloud_coverage 0.18" } },
						{3110, new List<string> {"weather.cloud_coverage 0.16" } },
						{3120, new List<string> {"weather.cloud_coverage 0.14" } },
						{3130, new List<string> {"weather.cloud_coverage 0.12" } },
						{3140, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_opacity -1", "weather.cloud_size -1" } },
						{3150, new List<string> {"weather.cloud_coverage 0.08" } },
						{3160, new List<string> {"weather.cloud_coverage 0.06" } },
						{3170, new List<string> {"weather.cloud_coverage 0.04" } },
						{3180, new List<string> {"weather.cloud_coverage 0.02" } },								
                        {3190, new List<string> {"weather.cloud_coverage 0", "weather.reset", "STOP" } },
                    }
                    },
					{"quickfront", new Dictionary<int, List<string>>
                    {
                        {1, new List<string> {"weather.cloud_coverage 0.02" } },
						{10, new List<string> {"weather.cloud_coverage 0.04" } },
						{20, new List<string> {"weather.cloud_coverage 0.06" } },
						{30, new List<string> {"weather.cloud_coverage 0.08" } },
						{40, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_opacity 0.9", "weather.cloud_size 0.9" } },
						{50, new List<string> {"weather.cloud_coverage 0.12", "weather.wind 0.1" } },
						{60, new List<string> {"weather.cloud_coverage 0.14", "weather.wind 0.2" } },
						{70, new List<string> {"weather.cloud_coverage 0.16", "weather.wind 0.3" } },
						{80, new List<string> {"weather.cloud_coverage 0.18", "weather.wind 0.4" } },
						{90, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_opacity 0.8", "weather.cloud_size 0.8" } },
						{100, new List<string> {"weather.cloud_coverage 0.22" } },
						{110, new List<string> {"weather.cloud_coverage 0.24" } },
						{120, new List<string> {"weather.cloud_coverage 0.26" } },
						{130, new List<string> {"weather.cloud_coverage 0.28" } },
						{140, new List<string> {"weather.cloud_coverage 0.3", "weather.wind 0.5" } },
						{150, new List<string> {"weather.cloud_coverage 0.32" } },
						{160, new List<string> {"weather.cloud_coverage 0.34" } },
						{170, new List<string> {"weather.cloud_coverage 0.36", "weather.cloud_size 1.25" } },
						{180, new List<string> {"weather.cloud_coverage 0.38" } },
						{190, new List<string> {"weather.cloud_coverage 0.4", "weather.wind 0.6" } },
						{300, new List<string> {"weather.cloud_coverage 0.42" } },
						{310, new List<string> {"weather.cloud_coverage 0.44" } },
						{320, new List<string> {"weather.cloud_coverage 0.46" } },
						{330, new List<string> {"weather.cloud_coverage 0.48" } },
						{340, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation 0.1" } },
						{350, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation -1" } },
						{360, new List<string> {"weather.cloud_coverage 0.48" } },
						{370, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_size 1.5" } },
						{380, new List<string> {"weather.cloud_coverage 0.52" } },
						{390, new List<string> {"weather.cloud_coverage 0.54" } },
						{400, new List<string> {"weather.cloud_coverage 0.56" } },
						{410, new List<string> {"weather.cloud_coverage 0.58" } },
						{420, new List<string> {"weather.cloud_coverage 0.6" } },
						{430, new List<string> {"weather.cloud_coverage 0.62" } },
						{440, new List<string> {"weather.cloud_coverage 0.64" } },
						{450, new List<string> {"weather.cloud_coverage 0.66" } },
						{460, new List<string> {"weather.cloud_coverage 0.68" } },
						{470, new List<string> {"weather.cloud_coverage 0.7" } },
						{480, new List<string> {"weather.cloud_coverage 0.72" } },
						{490, new List<string> {"weather.cloud_coverage 0.74" } },
						{500, new List<string> { "weather.cloud_coverage 0.75", "weather.cloud_attenuation 0.2" } },
						{510, new List<string> { "weather.fog 0.1" } },
						{520, new List<string> { "weather.cloud_coverage 0.76" } },
						{530, new List<string> { "weather.fog 0.04" } },
						{540, new List<string> { "weather.cloud_coverage 0.78" } },
						{550, new List<string> { "weather.fog 0.06" } },
						{560, new List<string> { "weather.cloud_coverage 0.8" } },
						{570, new List<string> { "weather.fog 0.08" } },
						{580, new List<string> { "weather.cloud_coverage 0.82" } },
						{590, new List<string> { "weather.fog 0.1" } },
                        {600, new List<string> { "weather.rain 0.01" } },
						{610, new List<string> { "weather.cloud_coverage 0.84" } },
						{620, new List<string> { "weather.fog 0.12" } },
                        {630, new List<string> { "weather.rain 0.02" } },
						{640, new List<string> { "weather.cloud_coverage 0.86" } },
						{650, new List<string> { "weather.cloud_coverage 0.88" } },
                        {660, new List<string> { "weather.rain 0.03" } },
						{670, new List<string> { "weather.cloud_coverage 0.9" } },
                        {680, new List<string> { "weather.rain 0.04" } },
						{690, new List<string> { "weather.cloud_coverage 0.92" } },
                        {700, new List<string> { "weather.rain 0.15", "weather.wind 0.4" } },
						{710, new List<string> { "weather.cloud_coverage 0.94" } },
						{720, new List<string> { "weather.cloud_coverage 0.96" } },
						{730, new List<string> { "weather.cloud_coverage 0.98" } },
						{740, new List<string> { "weather.cloud_coverage 1", "weather.cloud_attenuation 0.3" } },
						{1040, new List<string> { "weather.cloud_coverage 0.98" } },
						{1050, new List<string> { "weather.cloud_coverage 0.96" } },
						{1060, new List<string> { "weather.cloud_coverage 0.94" } },
						{1070, new List<string> { "weather.cloud_coverage 0.92", "weather.cloud_attenuation 0.2" } },
						{1080, new List<string> { "weather.cloud_coverage 0.9" } },
                        {1090, new List<string> { "weather.rain 0.24" } },
						{1100, new List<string> { "weather.cloud_coverage 0.88" } },
						{1110, new List<string> { "weather.cloud_coverage 0.86" } },
						{1120, new List<string> { "weather.cloud_coverage 0.84" } },
						{1130, new List<string> { "weather.cloud_coverage 0.82" } },
						{1140, new List<string> { "weather.cloud_coverage 0.8" } },
                        {1150, new List<string> { "weather.rain 0.23", "weather.wind 0.2" } },
						{1160, new List<string> { "weather.cloud_coverage 0.78" } },
						{1170, new List<string> { "weather.cloud_coverage 0.76" } },
						{1180, new List<string> { "weather.cloud_coverage 0.74", "weather.cloud_attenuation -1" } },
						{1190, new List<string> { "weather.cloud_coverage 0.72" } },
						{1200, new List<string> { "weather.cloud_coverage 0.7" } },
                        {1210, new List<string> { "weather.rain 0.12" } },
						{1220, new List<string> { "weather.cloud_coverage 0.68" } },
						{1230, new List<string> { "weather.cloud_coverage 0.66" } },
						{1240, new List<string> { "weather.cloud_coverage 0.64" } },
						{1250, new List<string> { "weather.cloud_coverage 0.62" } },
                        {1260, new List<string> { "weather.rain 0.07" } },
						{1270, new List<string> { "weather.cloud_coverage 0.6" } },
						{1280, new List<string> { "weather.cloud_coverage 0.58" } },
						{1290, new List<string> { "weather.cloud_coverage 0.56" } },
						{1300, new List<string> { "weather.cloud_coverage 0.54" } },
						{1310, new List<string> { "weather.cloud_coverage 0.52" } },
						{1320, new List<string> { "weather.cloud_coverage 0.5" } },
                        {1330, new List<string> { "weather.rain 0" } },
						{1350, new List<string> { "weather.cloud_coverage 0.48" } },
						{1750, new List<string> {"weather.cloud_coverage 0.48" } },
						{1760, new List<string> {"weather.cloud_coverage 0.46" } },
						{1770, new List<string> {"weather.cloud_coverage 0.44" } },
						{1780, new List<string> {"weather.cloud_coverage 0.42" } },
						{1790, new List<string> {"weather.cloud_coverage 0.4" } },
						{1900, new List<string> {"weather.cloud_coverage 0.38" } },
						{1910, new List<string> {"weather.cloud_coverage 0.36" } },
						{1920, new List<string> {"weather.cloud_coverage 0.34" } },
						{1930, new List<string> {"weather.cloud_coverage 0.32" } },
						{1940, new List<string> {"weather.cloud_coverage 0.3", "weather.wind 0.1" } },
						{1950, new List<string> {"weather.cloud_coverage 0.28" } },
						{1960, new List<string> {"weather.cloud_coverage 0.26" } },
						{2320, new List<string> {"weather.cloud_coverage 0.28" } },
						{2330, new List<string> {"weather.cloud_coverage 0.3" } },
						{2340, new List<string> {"weather.cloud_coverage 0.32" } },
						{2350, new List<string> {"weather.cloud_coverage 0.34" } },
						{2360, new List<string> {"weather.cloud_coverage 0.36" } },
						{2370, new List<string> {"weather.cloud_coverage 0.38", "weather.wind -1" } },
						{2380, new List<string> {"weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh 1.25" } },
						{2390, new List<string> {"weather.cloud_coverage 0.42" } },
						{2400, new List<string> {"weather.cloud_coverage 0.44" } },
						{2410, new List<string> {"weather.cloud_coverage 0.46" } },
						{2420, new List<string> {"weather.cloud_coverage 0.48" } },
						{2430, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation 0.1" } },
						{2440, new List<string> {"weather.cloud_coverage 0.52" } },
						{2450, new List<string> {"weather.cloud_coverage 0.54" } },
						{2460, new List<string> {"weather.cloud_coverage 0.56" } },
						{2470, new List<string> {"weather.cloud_coverage 0.58" } },
						{2480, new List<string> {"weather.cloud_coverage 0.6" } },
						{2650, new List<string> {"weather.cloud_coverage 0.58" } },
						{2660, new List<string> {"weather.cloud_coverage 0.56" } },
						{2670, new List<string> {"weather.cloud_coverage 0.54" } },
						{2680, new List<string> {"weather.cloud_coverage 0.52" } },
						{2690, new List<string> {"weather.cloud_coverage 0.5", "weather.cloud_attenuation -1" } },
						{2700, new List<string> {"weather.cloud_coverage 0.48" } },
						{2710, new List<string> {"weather.cloud_coverage 0.46" } },
						{2720, new List<string> {"weather.cloud_coverage 0.44" } },
						{2730, new List<string> {"weather.cloud_coverage 0.42" } },
						{2740, new List<string> {"weather.cloud_coverage 0.4", "weather.atmosphere_rayleigh -1" } },
						{2750, new List<string> {"weather.cloud_coverage 0.38" } },
						{2760, new List<string> {"weather.cloud_coverage 0.36" } },
						{2770, new List<string> {"weather.cloud_coverage 0.34" } },
						{2930, new List<string> {"weather.cloud_coverage 0.32" } },
						{2940, new List<string> {"weather.cloud_coverage 0.3" } },
						{2950, new List<string> {"weather.cloud_coverage 0.28" } },
						{2960, new List<string> {"weather.cloud_coverage 0.26" } },
						{2970, new List<string> {"weather.cloud_coverage 0.24" } },
						{2980, new List<string> {"weather.cloud_coverage 0.22" } },
						{2990, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_opacity 0.9", "weather.cloud_size 0.9" } },
						{3100, new List<string> {"weather.cloud_coverage 0.18", "weather.cloud_size 1.25" } },
						{3110, new List<string> {"weather.cloud_coverage 0.16" } },
						{3120, new List<string> {"weather.cloud_coverage 0.14" } },
						{3130, new List<string> {"weather.cloud_coverage 0.12" } },
						{3140, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_opacity -1", "weather.cloud_size -1" } },
						{3150, new List<string> {"weather.cloud_coverage 0.08" } },
						{3160, new List<string> {"weather.cloud_coverage 0.06" } },
						{3170, new List<string> {"weather.cloud_coverage 0.04" } },
						{3180, new List<string> {"weather.cloud_coverage 0.02" } },								
                        {3190, new List<string> {"weather.cloud_coverage 0", "weather.reset", "STOP" } },
                    }
                    },
					{"clear", new Dictionary<int, List<string>>
                    {
                        {5, new List<string> {"weather.cloud_opacity 0.99" } },
                        {10, new List<string> {"weather.cloud_opacity 0.98" } },
                        {15, new List<string> {"weather.cloud_opacity 0.97" } },
                        {20, new List<string> {"weather.cloud_opacity 0.96" } },
                        {25, new List<string> {"weather.cloud_opacity 0.95" } },
                        {30, new List<string> {"weather.cloud_opacity 0.94" } },
                        {35, new List<string> {"weather.cloud_opacity 0.93" } },
                        {40, new List<string> {"weather.cloud_opacity 0.92" } },
                        {45, new List<string> {"weather.cloud_opacity 0.91" } },
                        {50, new List<string> {"weather.cloud_opacity 0.9" } },
                        {55, new List<string> {"weather.cloud_opacity 0.89" } },
                        {60, new List<string> {"weather.cloud_opacity 0.88" } },
                        {65, new List<string> {"weather.cloud_opacity 0.87" } },
                        {70, new List<string> {"weather.cloud_opacity 0.86" } },
                        {75, new List<string> {"weather.cloud_opacity 0.85" } },
                        {80, new List<string> {"weather.cloud_opacity 0.84" } },
                        {85, new List<string> {"weather.cloud_opacity 0.83" } },
                        {90, new List<string> {"weather.cloud_opacity 0.82" } },
                        {95, new List<string> {"weather.cloud_opacity 0.81" } },
                        {200, new List<string> {"weather.cloud_opacity 0.8", "weather.atmosphere_contrast 1.5" } },
                        {205, new List<string> {"weather.cloud_opacity 0.79" } },
                        {210, new List<string> {"weather.cloud_opacity 0.78" } },
                        {215, new List<string> {"weather.cloud_opacity 0.77" } },
                        {220, new List<string> {"weather.cloud_opacity 0.76" } },
                        {225, new List<string> {"weather.cloud_opacity 0.75" } },
                        {230, new List<string> {"weather.cloud_opacity 0.74" } },
                        {235, new List<string> {"weather.cloud_opacity 0.73" } },
                        {240, new List<string> {"weather.cloud_opacity 0.72" } },
                        {245, new List<string> {"weather.cloud_opacity 0.71" } },
                        {250, new List<string> {"weather.cloud_opacity 0.70" } },
                        {255, new List<string> {"weather.cloud_opacity 0.69" } },
                        {260, new List<string> {"weather.cloud_opacity 0.68" } },
                        {265, new List<string> {"weather.cloud_opacity 0.67" } },
                        {270, new List<string> {"weather.cloud_opacity 0.66" } },
                        {275, new List<string> {"weather.cloud_opacity 0.65" } },
                        {280, new List<string> {"weather.cloud_opacity 0.64" } },
                        {285, new List<string> {"weather.cloud_opacity 0.63" } },
                        {290, new List<string> {"weather.cloud_opacity 0.62" } },
                        {295, new List<string> {"weather.cloud_opacity 0.61" } },
                        {400, new List<string> {"weather.cloud_opacity 0.6", "weather.atmosphere_contrast 2.0" } },
                        {405, new List<string> {"weather.cloud_opacity 0.59" } },
                        {410, new List<string> {"weather.cloud_opacity 0.58" } },
                        {415, new List<string> {"weather.cloud_opacity 0.57" } },
                        {420, new List<string> {"weather.cloud_opacity 0.56" } },
                        {425, new List<string> {"weather.cloud_opacity 0.55" } },
                        {430, new List<string> {"weather.cloud_opacity 0.54" } },
                        {435, new List<string> {"weather.cloud_opacity 0.53" } },
                        {440, new List<string> {"weather.cloud_opacity 0.52" } },
                        {445, new List<string> {"weather.cloud_opacity 0.51" } },
                        {450, new List<string> {"weather.cloud_opacity 0.5" } },
                        {455, new List<string> {"weather.cloud_opacity 0.49" } },
                        {460, new List<string> {"weather.cloud_opacity 0.48" } },
                        {465, new List<string> {"weather.cloud_opacity 0.47" } },
                        {470, new List<string> {"weather.cloud_opacity 0.46" } },
                        {475, new List<string> {"weather.cloud_opacity 0.45" } },
                        {480, new List<string> {"weather.cloud_opacity 0.44" } },
                        {485, new List<string> {"weather.cloud_opacity 0.43" } },
                        {490, new List<string> {"weather.cloud_opacity 0.42" } },
                        {495, new List<string> {"weather.cloud_opacity 0.41" } },
                        {600, new List<string> {"weather.cloud_opacity 0.4" } },
                        {605, new List<string> {"weather.cloud_opacity 0.39" } },
                        {610, new List<string> {"weather.cloud_opacity 0.38" } },
                        {615, new List<string> {"weather.cloud_opacity 0.37" } },
                        {620, new List<string> {"weather.cloud_opacity 0.36" } },
                        {625, new List<string> {"weather.cloud_opacity 0.35" } },
                        {630, new List<string> {"weather.cloud_opacity 0.34" } },
                        {635, new List<string> {"weather.cloud_opacity 0.33", } },
                        {640, new List<string> {"weather.cloud_opacity 0.32" } },
                        {645, new List<string> {"weather.cloud_opacity 0.31" } },
                        {650, new List<string> {"weather.cloud_opacity 0.3" } },
                        {655, new List<string> {"weather.cloud_opacity 0.29" } },
                        {660, new List<string> {"weather.cloud_opacity 0.28" } },
                        {665, new List<string> {"weather.cloud_opacity 0.27" } },
                        {670, new List<string> {"weather.cloud_opacity 0.26" } },
                        {675, new List<string> {"weather.cloud_opacity 0.25" } },
                        {680, new List<string> {"weather.cloud_opacity 0.24" } },
                        {685, new List<string> {"weather.cloud_opacity 0.23" } },
                        {690, new List<string> {"weather.cloud_opacity 0.22" } },
                        {695, new List<string> {"weather.cloud_opacity 0.21" } },
                        {900, new List<string> {"weather.cloud_opacity 0.2" } },
                        {905, new List<string> {"weather.cloud_opacity 0.19" } },
                        {910, new List<string> {"weather.cloud_opacity 0.18" } },
                        {915, new List<string> {"weather.cloud_opacity 0.17" } },
                        {920, new List<string> {"weather.cloud_opacity 0.16" } },
                        {925, new List<string> {"weather.cloud_opacity 0.15" } },
                        {930, new List<string> {"weather.cloud_opacity 0.14" } },
                        {935, new List<string> {"weather.cloud_opacity 0.13" } },
                        {940, new List<string> {"weather.cloud_opacity 0.12" } },
                        {945, new List<string> {"weather.cloud_opacity 0.11" } },
                        {950, new List<string> {"weather.cloud_opacity 0.1" } },
                        {955, new List<string> {"weather.cloud_opacity 0.09" } },
                        {960, new List<string> {"weather.cloud_opacity 0.08" } },
                        {965, new List<string> {"weather.cloud_opacity 0.07" } },
                        {970, new List<string> {"weather.cloud_opacity 0.06" } },
                        {975, new List<string> {"weather.cloud_opacity 0.05" } },
                        {980, new List<string> {"weather.cloud_opacity 0.04" } },
                        {985, new List<string> {"weather.cloud_opacity 0.03" } },
                        {990, new List<string> {"weather.cloud_opacity 0.02" } },
                        {995, new List<string> {"weather.cloud_opacity 0.01" } },
                        {2100, new List<string> {"weather.cloud_opacity 0" } },
                        {2300, new List<string> {"weather.cloud_opacity 0.01" } },
                        {2305, new List<string> {"weather.cloud_opacity 0.02" } },
                        {2310, new List<string> {"weather.cloud_opacity 0.03" } },
                        {2315, new List<string> {"weather.cloud_opacity 0.04" } },
                        {2320, new List<string> {"weather.cloud_opacity 0.05" } },
                        {2325, new List<string> {"weather.cloud_opacity 0.06" } },
                        {2330, new List<string> {"weather.cloud_opacity 0.07" } },
                        {2335, new List<string> {"weather.cloud_opacity 0.08" } },
                        {2340, new List<string> {"weather.cloud_opacity 0.09" } },
                        {2345, new List<string> {"weather.cloud_opacity 0.1" } },
                        {2350, new List<string> {"weather.cloud_opacity 0.11" } },
                        {2355, new List<string> {"weather.cloud_opacity 0.12" } },
                        {2360, new List<string> {"weather.cloud_opacity 0.13" } },
                        {2365, new List<string> {"weather.cloud_opacity 0.14" } },
                        {2370, new List<string> {"weather.cloud_opacity 0.15" } },
                        {2375, new List<string> {"weather.cloud_opacity 0.16" } },
                        {2380, new List<string> {"weather.cloud_opacity 0.17" } },
                        {2385, new List<string> {"weather.cloud_opacity 0.18" } },
                        {2390, new List<string> {"weather.cloud_opacity 0.19" } },
                        {2395, new List<string> {"weather.cloud_opacity 0.2" } },
                        {2600, new List<string> {"weather.cloud_opacity 0.21" } },
                        {2605, new List<string> {"weather.cloud_opacity 0.22" } },
                        {2610, new List<string> {"weather.cloud_opacity 0.23" } },
                        {2615, new List<string> {"weather.cloud_opacity 0.24" } },
                        {2620, new List<string> {"weather.cloud_opacity 0.25" } },
                        {2625, new List<string> {"weather.cloud_opacity 0.26" } },
                        {2630, new List<string> {"weather.cloud_opacity 0.27" } },
                        {2635, new List<string> {"weather.cloud_opacity 0.28" } },
                        {2640, new List<string> {"weather.cloud_opacity 0.29" } },
                        {2645, new List<string> {"weather.cloud_opacity 0.3" } },
                        {2650, new List<string> {"weather.cloud_opacity 0.31" } },
                        {2655, new List<string> {"weather.cloud_opacity 0.32" } },
                        {2660, new List<string> {"weather.cloud_opacity 0.33" } },
                        {2665, new List<string> {"weather.cloud_opacity 0.34" } },
                        {2670, new List<string> {"weather.cloud_opacity 0.35" } },
                        {2675, new List<string> {"weather.cloud_opacity 0.36" } },
                        {2680, new List<string> {"weather.cloud_opacity 0.37" } },
                        {2685, new List<string> {"weather.cloud_opacity 0.38" } },
                        {2690, new List<string> {"weather.cloud_opacity 0.39" } },
                        {2695, new List<string> {"weather.cloud_opacity 0.4" } },
                        {2900, new List<string> {"weather.cloud_opacity 0.41" } },
                        {2905, new List<string> {"weather.cloud_opacity 0.42" } },
                        {2910, new List<string> {"weather.cloud_opacity 0.43" } },
                        {2915, new List<string> {"weather.cloud_opacity 0.44" } },
                        {2920, new List<string> {"weather.cloud_opacity 0.45" } },
                        {2925, new List<string> {"weather.cloud_opacity 0.46" } },
                        {2930, new List<string> {"weather.cloud_opacity 0.47" } },
                        {2935, new List<string> {"weather.cloud_opacity 0.48" } },
                        {2940, new List<string> {"weather.cloud_opacity 0.49" } },
                        {2945, new List<string> {"weather.cloud_opacity 0.5" } },
                        {2950, new List<string> {"weather.cloud_opacity 0.51" } },
                        {2955, new List<string> {"weather.cloud_opacity 0.52" } },
                        {2960, new List<string> {"weather.cloud_opacity 0.53" } },
                        {2965, new List<string> {"weather.cloud_opacity 0.54" } },
                        {2970, new List<string> {"weather.cloud_opacity 0.55" } },
                        {2975, new List<string> {"weather.cloud_opacity 0.56" } },
                        {2980, new List<string> {"weather.cloud_opacity 0.57" } },
                        {2985, new List<string> {"weather.cloud_opacity 0.58" } },
                        {2990, new List<string> {"weather.cloud_opacity 0.59" } },
                        {2995, new List<string> {"weather.cloud_opacity 0.6", "weather.atmosphere_contrast 1.5" } },
                        {3200, new List<string> {"weather.cloud_opacity 0.61" } },
                        {3205, new List<string> {"weather.cloud_opacity 0.62" } },
                        {3210, new List<string> {"weather.cloud_opacity 0.63" } },
                        {3215, new List<string> {"weather.cloud_opacity 0.64" } },
                        {3220, new List<string> {"weather.cloud_opacity 0.65" } },
                        {3225, new List<string> {"weather.cloud_opacity 0.66" } },
                        {3230, new List<string> {"weather.cloud_opacity 0.67" } },
                        {3235, new List<string> {"weather.cloud_opacity 0.68" } },
                        {3240, new List<string> {"weather.cloud_opacity 0.69" } },
                        {3245, new List<string> {"weather.cloud_opacity 0.7" } },
                        {3250, new List<string> {"weather.cloud_opacity 0.71" } },
                        {3255, new List<string> {"weather.cloud_opacity 0.72" } },
                        {3260, new List<string> {"weather.cloud_opacity 0.73" } },
                        {3265, new List<string> {"weather.cloud_opacity 0.74" } },
                        {3270, new List<string> {"weather.cloud_opacity 0.75" } },
                        {3275, new List<string> {"weather.cloud_opacity 0.76" } },
                        {3280, new List<string> {"weather.cloud_opacity 0.77" } },
                        {3285, new List<string> {"weather.cloud_opacity 0.78" } },
                        {3290, new List<string> {"weather.cloud_opacity 0.79" } },
                        {3295, new List<string> {"weather.cloud_opacity 0.80" } },
                        {3500, new List<string> {"weather.cloud_opacity 0.81" } },
                        {3505, new List<string> {"weather.cloud_opacity 0.82" } },
                        {3510, new List<string> {"weather.cloud_opacity 0.83" } },
                        {3515, new List<string> {"weather.cloud_opacity 0.84" } },
                        {3520, new List<string> {"weather.cloud_opacity 0.85" } },
                        {3525, new List<string> {"weather.cloud_opacity 0.86" } },
                        {3530, new List<string> {"weather.cloud_opacity 0.87" } },
                        {3535, new List<string> {"weather.cloud_opacity 0.88" } },
                        {3540, new List<string> {"weather.cloud_opacity 0.89" } },
                        {3545, new List<string> {"weather.cloud_opacity 0.9" } },
                        {3550, new List<string> {"weather.cloud_opacity 0.91" } },
                        {3555, new List<string> {"weather.cloud_opacity 0.92" } },
                        {3560, new List<string> {"weather.cloud_opacity 0.93" } },
                        {3565, new List<string> {"weather.cloud_opacity 0.94" } },
                        {3570, new List<string> {"weather.cloud_opacity 0.95" } },
                        {3575, new List<string> {"weather.cloud_opacity 0.96" } },
                        {3580, new List<string> {"weather.cloud_opacity 0.97" } },
                        {3585, new List<string> {"weather.cloud_opacity 0.98" } },
                        {3590, new List<string> {"weather.cloud_opacity 0.99", "weather.atmosphere_contrast -1" } },
                        {3595, new List<string> {"weather.cloud_opacity 1", "weather.reset", "STOP" } },
                    }
                    },
					{"volcanicsky", new Dictionary<int, List<string>>
                    {
                        {5, new List<string> {"weather.atmosphere_rayleigh 1.5" } },
                        {230, new List<string> {"weather.atmosphere_rayleigh 2" } },
                        {330, new List<string> {"weather.atmosphere_rayleigh 2.5" } },
                        {460, new List<string> {"weather.atmosphere_rayleigh 3" } },
                        {560, new List<string> {"weather.atmosphere_rayleigh 3.5" } },
                        {690, new List<string> {"weather.atmosphere_rayleigh 4" } },
                        {790, new List<string> {"weather.atmosphere_rayleigh 4.5", "weather.fog 0.1" } },
                        {1020, new List<string> {"weather.atmosphere_rayleigh 5" } },
                        {1120, new List<string> {"weather.atmosphere_rayleigh 5.5" } },
                        {1250, new List<string> {"weather.atmosphere_rayleigh 6" } },
                        {1350, new List<string> {"weather.atmosphere_rayleigh 6.5" } },
                        {1450, new List<string> {"weather.atmosphere_rayleigh 7" } },
                        {1490, new List<string> {"weather.atmosphere_rayleigh 7.5" } },
                        {1510, new List<string> {"weather.atmosphere_rayleigh 8", "weather.fog 0.2" } },
                        {1520, new List<string> {"weather.atmosphere_rayleigh 8.5" } },
                        {1540, new List<string> {"weather.atmosphere_rayleigh 9" } },
                        {1640, new List<string> {"weather.atmosphere_rayleigh 9.5" } },
                        {1770, new List<string> {"weather.atmosphere_rayleigh 10" } },
                        {2100, new List<string> {"weather.atmosphere_rayleigh 9.5" } },
                        {2200, new List<string> {"weather.atmosphere_rayleigh 9" } },
                        {2270, new List<string> {"weather.atmosphere_rayleigh 8.5", "weather.fog 0.3" } },
                        {2330, new List<string> {"weather.atmosphere_rayleigh 8" } },
                        {2380, new List<string> {"weather.atmosphere_rayleigh 7.5" } },
                        {2460, new List<string> {"weather.atmosphere_rayleigh 7" } },
                        {2530, new List<string> {"weather.atmosphere_rayleigh 6.5" } },
                        {2590, new List<string> {"weather.atmosphere_rayleigh 6" } },
                        {2990, new List<string> {"weather.atmosphere_rayleigh 5.5" } },
                        {3020, new List<string> {"weather.atmosphere_rayleigh 5" } },
                        {3080, new List<string> {"weather.atmosphere_rayleigh 4.5" } },
                        {3150, new List<string> {"weather.atmosphere_rayleigh 4" } },
                        {3190, new List<string> {"weather.atmosphere_rayleigh 3.5", "weather.fog 0.1" } },
                        {3280, new List<string> {"weather.atmosphere_rayleigh 3" } },
                        {3290, new List<string> {"weather.atmosphere_rayleigh 2.5" } },
                        {3310, new List<string> {"weather.atmosphere_rayleigh 2" } },
                        {3440, new List<string> {"weather.atmosphere_rayleigh 1.5" } },
                        {3570, new List<string> {"weather.atmosphere_rayleigh -1" } },
                        {3600, new List<string> {"weather.cloud_opacity 1", "weather.reset", "STOP" } },
                    }
                    },
					{"smokeysky", new Dictionary<int, List<string>>
                    {
                        {5, new List<string> {"weather.atmosphere_rayleigh 1" } },
						{10, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_opacity 0.75", "weather.cloud_size 1.5" } },
                        {230, new List<string> {"weather.atmosphere_rayleigh 2", "sv weather.atmosphere_mie 0.5", "atmosphere_directionality 0.5" } },
						{235, new List<string> {"weather.cloud_coverage 0.2", "weather.cloud_opacity 0.5", "weather.cloud_size 2.0" } },
                        {460, new List<string> {"weather.atmosphere_rayleigh 3", "sv weather.atmosphere_mie 0.25", "atmosphere_directionality 0.25" } },
                        {690, new List<string> {"weather.atmosphere_rayleigh 4" } },
                        {1020, new List<string> {"weather.atmosphere_rayleigh 5", "sv weather.atmosphere_mie 0.1", "atmosphere_directionality 0.1" } },
                        {1150, new List<string> {"weather.atmosphere_rayleigh 5.5" } },
                        {3020, new List<string> {"weather.atmosphere_rayleigh 5" } },
                        {3150, new List<string> {"weather.atmosphere_rayleigh 4" } },
                        {3280, new List<string> {"weather.atmosphere_rayleigh 3", "sv weather.atmosphere_mie 0.25", "atmosphere_directionality 0.25" } },
                        {3310, new List<string> {"weather.atmosphere_rayleigh 2", "sv weather.atmosphere_mie 0.5", "atmosphere_directionality 0.5" } },
						{3315, new List<string> {"weather.cloud_coverage 0.1", "weather.cloud_opacity 0.75", "weather.cloud_size 1.5" } },
                        {3440, new List<string> {"weather.atmosphere_rayleigh 1", "sv weather.atmosphere_mie -1", "atmosphere_directionality -1" } },
						{3510, new List<string> {"weather.cloud_coverage 0", "weather.cloud_opacity -1", "weather.cloud_size -1" } },
                        {3570, new List<string> {"weather.atmosphere_rayleigh -1" } },
                        {3600, new List<string> {"weather.cloud_opacity 1", "weather.reset", "STOP" } },
                    }
                    },
					{"windy", new Dictionary<int, List<string>>
                    {
                        {5, new List<string> {"weather.wind 0.01" } },
                        {10, new List<string> {"weather.wind 0.02" } },
                        {15, new List<string> {"weather.wind 0.03" } },
                        {20, new List<string> {"weather.wind 0.04" } },
                        {25, new List<string> {"weather.wind 0.05" } },
                        {30, new List<string> {"weather.wind 0.06" } },
                        {35, new List<string> {"weather.wind 0.07" } },
                        {40, new List<string> {"weather.wind 0.08" } },
                        {45, new List<string> {"weather.wind 0.09" } },
                        {50, new List<string> {"weather.wind 0.10" } },
                        {55, new List<string> {"weather.wind 0.11" } },
                        {60, new List<string> {"weather.wind 0.12" } },
                        {65, new List<string> {"weather.wind 0.13" } },
                        {70, new List<string> {"weather.wind 0.14" } },
                        {75, new List<string> {"weather.wind 0.15" } },
                        {80, new List<string> {"weather.wind 0.16" } },
                        {85, new List<string> {"weather.wind 0.17" } },
                        {90, new List<string> {"weather.wind 0.18" } },
                        {95, new List<string> {"weather.wind 0.19" } },
                        {100, new List<string> {"weather.wind 0.20" } },
                        {105, new List<string> {"weather.wind 0.21" } },
                        {110, new List<string> {"weather.wind 0.22" } },
                        {115, new List<string> {"weather.wind 0.23" } },
                        {120, new List<string> {"weather.wind 0.24" } },
                        {125, new List<string> {"weather.wind 0.25" } },
                        {130, new List<string> {"weather.wind 0.26" } },
                        {135, new List<string> {"weather.wind 0.27" } },
                        {140, new List<string> {"weather.wind 0.28" } },
                        {145, new List<string> {"weather.wind 0.29" } },
                        {150, new List<string> {"weather.wind 0.30" } },
                        {155, new List<string> {"weather.wind 0.31" } },
                        {160, new List<string> {"weather.wind 0.32" } },
                        {165, new List<string> {"weather.wind 0.33" } },
                        {170, new List<string> {"weather.wind 0.34" } },
                        {175, new List<string> {"weather.wind 0.35" } },
                        {180, new List<string> {"weather.wind 0.36" } },
                        {185, new List<string> {"weather.wind 0.39" } },
                        {190, new List<string> {"weather.wind 0.42" } },
                        {195, new List<string> {"weather.wind 0.47", "weather.fog 0.1" } },
                        {200, new List<string> {"weather.wind 0.54" } },
                        {205, new List<string> {"weather.wind 0.58" } },
                        {210, new List<string> {"weather.wind 0.59" } },
                        {215, new List<string> {"weather.wind 0.60" } },
                        {220, new List<string> {"weather.wind 0.61" } },
                        {225, new List<string> {"weather.wind 0.62" } },
                        {230, new List<string> {"weather.wind 0.63" } },
                        {235, new List<string> {"weather.wind 0.64" } },
                        {240, new List<string> {"weather.wind 0.65" } },
                        {245, new List<string> {"weather.wind 0.66" } },
                        {250, new List<string> {"weather.wind 0.67" } },
                        {255, new List<string> {"weather.wind 0.68" } },
                        {260, new List<string> {"weather.wind 0.69" } },
                        {265, new List<string> {"weather.wind 0.70" } },
                        {270, new List<string> {"weather.wind 0.71" } },
                        {275, new List<string> {"weather.wind 0.72" } },
                        {280, new List<string> {"weather.wind 0.73" } },
                        {285, new List<string> {"weather.wind 0.74" } },
                        {290, new List<string> {"weather.wind 0.75" } },
                        {295, new List<string> {"weather.wind 0.76" } },
                        {300, new List<string> {"weather.wind 0.77" } },
                        {305, new List<string> {"weather.wind 0.78" } },
                        {310, new List<string> {"weather.wind 0.79" } },
                        {315, new List<string> {"weather.wind 0.80" } },
                        {320, new List<string> {"weather.wind 0.82" } },
                        {325, new List<string> {"weather.wind 0.84" } },
                        {330, new List<string> {"weather.wind 0.86" } },
                        {335, new List<string> {"weather.wind 0.88", "weather.fog 0.1" } },
                        {340, new List<string> {"weather.wind 0.90" } },
                        {345, new List<string> {"weather.wind 0.92" } },
                        {350, new List<string> {"weather.wind 0.93" } },
                        {355, new List<string> {"weather.wind 0.94" } },
                        {360, new List<string> {"weather.wind 0.95" } },
                        {365, new List<string> {"weather.wind 0.96" } },
                        {370, new List<string> {"weather.wind 0.97" } },
                        {375, new List<string> {"weather.wind 0.98" } },
                        {380, new List<string> {"weather.wind 0.99" } },
                        {385, new List<string> {"weather.wind 1" } },
                        {420, new List<string> {"weather.wind 0.99" } },
                        {425, new List<string> {"weather.wind 0.98" } },
                        {430, new List<string> {"weather.wind 0.97" } },
                        {435, new List<string> {"weather.wind 0.96" } },
                        {440, new List<string> {"weather.wind 0.95" } },
                        {445, new List<string> {"weather.wind 0.94" } },
                        {450, new List<string> {"weather.wind 0.93" } },
                        {455, new List<string> {"weather.wind 0.92" } },
                        {460, new List<string> {"weather.wind 0.91" } },
                        {470, new List<string> {"weather.wind 0.9" } },
                        {480, new List<string> {"weather.wind 0.89" } },
                        {490, new List<string> {"weather.wind 0.88" } },
                        {2000, new List<string> {"weather.wind 0.87" } },
                        {2005, new List<string> {"weather.wind 0.86" } },
                        {2010, new List<string> {"weather.wind 0.85" } },
                        {2015, new List<string> {"weather.wind 0.84" } },
                        {2020, new List<string> {"weather.wind 0.83" } },
                        {2025, new List<string> {"weather.wind 0.82" } },
                        {2030, new List<string> {"weather.wind 0.81" } },
                        {2035, new List<string> {"weather.wind 0.80" } },
                        {2040, new List<string> {"weather.wind 0.79" } },
                        {2045, new List<string> {"weather.wind 0.78" } },
                        {2050, new List<string> {"weather.wind 0.77" } },
                        {2055, new List<string> {"weather.wind 0.76" } },
                        {2060, new List<string> {"weather.wind 0.75" } },
                        {2065, new List<string> {"weather.wind 0.74" } },
                        {2070, new List<string> {"weather.wind 0.73" } },
                        {2075, new List<string> {"weather.wind 0.72" } },
                        {2080, new List<string> {"weather.wind 0.71" } },
                        {2085, new List<string> {"weather.wind 0.7" } },
                        {2090, new List<string> {"weather.wind 0.69" } },
                        {2095, new List<string> {"weather.wind 0.68" } },
                        {2100, new List<string> {"weather.wind 0.67" } },
                        {2105, new List<string> {"weather.wind 0.66" } },
                        {2110, new List<string> {"weather.wind 0.65" } },
                        {2115, new List<string> {"weather.wind 0.64" } },
                        {2120, new List<string> {"weather.wind 0.63" } },
                        {2125, new List<string> {"weather.wind 0.62" } },
                        {2130, new List<string> {"weather.wind 0.61" } },
                        {2135, new List<string> {"weather.wind 0.6" } },
                        {2140, new List<string> {"weather.wind 0.59" } },
                        {2145, new List<string> {"weather.wind 0.58" } },
                        {2150, new List<string> {"weather.wind 0.57" } },
                        {2155, new List<string> {"weather.wind 0.56" } },
                        {2160, new List<string> {"weather.wind 0.55" } },
                        {2165, new List<string> {"weather.wind 0.54" } },
                        {2170, new List<string> {"weather.wind 0.53" } },
                        {2175, new List<string> {"weather.wind 0.52" } },
                        {2180, new List<string> {"weather.wind 0.51" } },
                        {2185, new List<string> {"weather.wind 0.5", "weather.fog 0.1" } },
                        {2190, new List<string> {"weather.wind 0.49" } },
                        {2195, new List<string> {"weather.wind 0.48" } },
                        {2200, new List<string> {"weather.wind 0.47" } },
                        {2205, new List<string> {"weather.wind 0.46" } },
                        {2210, new List<string> {"weather.wind 0.45" } },
                        {2215, new List<string> {"weather.wind 0.44" } },
                        {2220, new List<string> {"weather.wind 0.43" } },
                        {2225, new List<string> {"weather.wind 0.42" } },
                        {2230, new List<string> {"weather.wind 0.41" } },
                        {2235, new List<string> {"weather.wind 0.4" } },
                        {2240, new List<string> {"weather.wind 0.39" } },
                        {2245, new List<string> {"weather.wind 0.38" } },
                        {2250, new List<string> {"weather.wind 0.37" } },
                        {2280, new List<string> {"weather.wind 0.36" } },
                        {2310, new List<string> {"weather.wind 0.35" } },
                        {2320, new List<string> {"weather.wind 0.34" } },
                        {2330, new List<string> {"weather.wind 0.33" } },
                        {2335, new List<string> {"weather.wind 0.32" } },
                        {2340, new List<string> {"weather.wind 0.31" } },
                        {2345, new List<string> {"weather.wind 0.3" } },
                        {2350, new List<string> {"weather.wind 0.29" } },
                        {2355, new List<string> {"weather.wind 0.28" } },
                        {2360, new List<string> {"weather.wind 0.27" } },
                        {2365, new List<string> {"weather.wind 0.26" } },
                        {2370, new List<string> {"weather.wind 0.25" } },
                        {2375, new List<string> {"weather.wind 0.24" } },
                        {2380, new List<string> {"weather.wind 0.23" } },
                        {2385, new List<string> {"weather.wind 0.22" } },
                        {2390, new List<string> {"weather.wind 0.21" } },
                        {2395, new List<string> {"weather.wind 0.2" } },
                        {2400, new List<string> {"weather.wind 0.19" } },
                        {2405, new List<string> {"weather.wind 0.18" } },
                        {2410, new List<string> {"weather.wind 0.17" } },
                        {2415, new List<string> {"weather.wind 0.16" } },
                        {2420, new List<string> {"weather.wind 0.15" } },
                        {2425, new List<string> {"weather.wind 0.14" } },
                        {2430, new List<string> {"weather.wind 0.13" } },
                        {2435, new List<string> {"weather.wind 0.12" } },
                        {2440, new List<string> {"weather.wind 0.11" } },
                        {2445, new List<string> {"weather.wind 0.1" } },
                        {2450, new List<string> {"weather.wind 0.09" } },
                        {2455, new List<string> {"weather.wind 0.08" } },
                        {2460, new List<string> {"weather.wind 0.07" } },
                        {2465, new List<string> {"weather.wind 0.06" } },
                        {2470, new List<string> {"weather.wind 0.05" } },
                        {2475, new List<string> {"weather.wind 0.04" } },
                        {2480, new List<string> {"weather.wind 0.03" } },
                        {2485, new List<string> {"weather.wind 0.02" } },
                        {2490, new List<string> {"weather.wind 0.01", "weather.fog 0" } },
                        {2495, new List<string> {"weather.wind 0", "weather.reset", "STOP" } },
                    }
                    }
            };
    }
}

// --- End of file: WeatherEvents.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagicArea.cs ---
// --- Original Local Path: MagicArea.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
namespace Oxide.Plugins
{
    [Info("MagicArea", "Norn", 0.1, ResourceId = 1551)]
    [Description("Areas to practice building/pvp.")]
    public class MagicArea : RustPlugin
    {
        [PluginReference] Plugin Kits;
        [PluginReference] Plugin MagicTeleportation;

        // -------------- [ SAVING VARIABLES ] -------------- 

        class MA
        {
            public Dictionary<int, AreaInfo> Areas = new Dictionary<int, AreaInfo>();
            public Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
            public Dictionary<uint, AreaEntities> Entities = new Dictionary<uint, AreaEntities>();
            public MA() { }
        }
        public class AreaEntities
        {
            public uint iID;
            public int iAreaID;
            public ulong uCreatorID;
            public int iCreated;
            public int iExpire;
            public AreaEntities() { }
        }
        class PlayerData
        {
            public ulong uUserID;
            public int iInArea;
            public Int32 iInitStamp;
            public PlayerData() { }
        }
        class SpawnInfo
        {
            public float fX;
            public float fY;
            public float fZ;
            public int iEID;
            public SpawnInfo() { }
        }
        class AreaInfo
        {
            public int iID;
            public string tTitle;
            public string tDescription;
            public float fMinX;
            public float fMinY;
            public float fMinZ;
            public float fRadius;
            public bool uEnabled;
            public bool bGod;
            public bool bResetInv;
            public int iCount;
            public string tKit;
            public bool bCanResearch;
            public bool bRemoveEntities;
            public int iEntityExpire;
            public Dictionary<int, SpawnInfo> Spawns = new Dictionary<int, SpawnInfo>();
            public AreaInfo() { }
        }
        MA MAData;

        #region Localization

        void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                {"KitReceived", "[<color=green>INFO:</color>] You have been given kit: <color=yellow>{kit_name}</color> to use inside of <color=yellow>{area_title}</color>."},
                {"InventoryReset", "[<color=green>INFO:</color>] Your inventory has been <color=red>reset</color> because you left an area."},
                {"ResearchBlocked", "[<color=yellow>ERROR</color>] Researching is <color=red>blocked</color> in this area."},
                {"AreaCreated", "[<color=green>INFO:</color>] You have successfully created area id: {area_id}."},
                {"TeleportedBack", "[<color=green>INFO</color>] You have been teleported back to <color=yellow>{area_title}</color>." },
                {"EntityExpiry", "[<color=yellow>INFO</color>] This object will expire at: <color=yellow>{expire_time}</color>!\n(Current Time: <color=yellow>{current_time}</color>)" }
            };
            lang.RegisterMessages(messages, this);
        }
        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);

        #endregion
        // -----------------------------------------------

        Timer AreaSync;
        void OnServerInitialized()
        {
            Puts("Loaded " + MAData.Areas.Count.ToString() + " area(s).");

            // --- [ TIMERS ] ---
            int seconds = Convert.ToInt32(Config["Settings", "TimerInterval"]);
            AreaSync = timer.Repeat(seconds, 0, () => AreaTimer());
            LoadDefaultMessages();
        }

        private void AreaTimer()
        {
            // ==================================== [ ENTITY PORTION ] ==========================================
            new List<uint>(MAData.Entities.Keys).ForEach(u =>
            {
                BaseNetworkable ent = BaseNetworkable.serverEntities.Find(u);
                if (ent != null && UnixTimeStampUTC() >= MAData.Entities[u].iExpire)
                {
                    int area_id = MAData.Entities[u].iAreaID;
                    if (area_id != -1 && MagicAreaExists(area_id))
                    {
                        if (MAData.Areas[area_id].bRemoveEntities && MAData.Areas[area_id].iEntityExpire != 0)
                        {
                            MAData.Entities.Remove(u);
                            ent.Kill();
                            if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts("Removing entity ID: " + u.ToString() + " [EXPIRED]"); }
                        }
                    }
                }
            });
            // ================================== [ PLAYER ] ====================================================
            foreach (BasePlayer connected_player in BasePlayer.activePlayerList)
            {
                bool found = false;
                if(connected_player != null && connected_player.IsConnected())
                {
                    if(!PlayerExists(connected_player)) { InitPlayer(connected_player); }
                    foreach(var area in MAData.Areas.Values)
                    {
                        if(PlayerToPoint(connected_player, area.fRadius, area.fMinX, area.fMinY, area.fMinZ))
                        {
                            if (MAData.PlayerData[connected_player.userID].iInArea != area.iID)
                            {
                                MAData.PlayerData[connected_player.userID].iInArea = area.iID;
                                Interface.Oxide.CallHook("OnPlayerEnterMagicArea", connected_player, MAData.PlayerData[connected_player.userID].iInArea);
                                if (area.tKit.Length >= 1 && area.tKit != null)
                                {
                                    object iskit = Kits?.Call("isKit", area.tKit);
                                    if (iskit is bool && (bool)iskit)
                                    {
                                        connected_player.inventory.Strip();
                                        object successkit = Kits.Call("GiveKit", connected_player, area.tKit);
                                        if (successkit is bool && (bool)successkit)
                                        {
                                            string parsed_config = GetMessage("KitReceived", connected_player.UserIDString);
                                            parsed_config = parsed_config.Replace("{kit_name}", area.tKit);
                                            parsed_config = parsed_config.Replace("{area_title}", area.tTitle);
                                            PrintToChat(connected_player, parsed_config);
                                        }
                                    }
                                }
                            }
                            found = true;
                        }
                    }
                    if(!found && MAData.PlayerData[connected_player.userID].iInArea != -1)
                    {
                        if(MAData.Areas[MAData.PlayerData[connected_player.userID].iInArea].bResetInv)
                        {
                            PrintToChat(connected_player, GetMessage("InventoryReset", connected_player.UserIDString));
                            connected_player.inventory.Strip();
                        }
                        Interface.Oxide.CallHook("OnPlayerExitMagicArea", connected_player, MAData.PlayerData[connected_player.userID].iInArea);
                        MAData.PlayerData[connected_player.userID].iInArea = -1;
                    }
                }
            }
        }

        private void OnPlayerExitMagicArea(BasePlayer player, int area)
        {
            if (MagicAreaExists(area)) {
                if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts(player.displayName + " has left: " + MAData.Areas[area].tTitle + " [ " + area.ToString() + " ]"); PrintToChat(player, player.displayName + " has left: " + MAData.Areas[area].tTitle + " [ " + area.ToString() + " ]"); } }
        }

        private void OnPlayerEnterMagicArea(BasePlayer player, int area)
        {
            if (MagicAreaExists(area)) { if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts(player.displayName + " has entered: " + MAData.Areas[area].tTitle + " [ " + area.ToString() + " ]"); PrintToChat(player, player.displayName + " has entered: " + MAData.Areas[area].tTitle + " [ " + area.ToString() + " ]"); } }
        }

        private int CreateMagicArea(Vector3 position, float radius, string title = "-1", string description = "-1", bool enabled = true)
        {
            int id = -1;
            if (position != Vector3.zero)
            {
                AreaInfo Area = new AreaInfo();
                Area.iID = GetRandomNumber(0, 25);
                if(title == "-1") { title = "Area" + Area.iID.ToString(); }
                Area.tTitle = title;
                Area.tDescription = description;
                Area.uEnabled = enabled;
                Area.iCount = 0;
                Area.fMinX = position.x;
                Area.fMinY = position.y;
                Area.fMinZ = position.z;
                Area.fRadius = radius;
                Area.bGod = false;
                Area.tKit = "";
                Area.bCanResearch = false;
                Area.bResetInv = true;
                Area.bRemoveEntities = true;
                Area.iEntityExpire = Convert.ToInt32(Config["Settings", "DefaultExpire"]);
                id = Area.iID;
                MAData.Areas.Add(Area.iID, Area);
                SaveData();
            }
            return id;
        }

        private bool MagicAreaExists(int id)
        {
            AreaInfo item = null;
            if(MAData.Areas.TryGetValue(id, out item)) { return true; }
            return false;
        }

        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            System.DateTime dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, System.DateTimeKind.Utc);
            dtDateTime = dtDateTime.AddSeconds(unixTimeStamp).ToLocalTime();
            return dtDateTime;
        }

        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            BaseEntity e = gameObject.ToBaseEntity();
            BasePlayer player = planner.ownerPlayer;
            if (!(e is BaseEntity) || player == null)
            {
                return;
            }
            int id = MAData.PlayerData[player.userID].iInArea;
            if (PlayerExists(player) && id != -1 && MagicAreaExists(id))
            {
                if (MAData.Areas[id].bRemoveEntities && MAData.Areas[id].iEntityExpire != 0)
                {
                    AreaEntities Area = new AreaEntities();
                    Area.iAreaID = id;
                    Area.iCreated = UnixTimeStampUTC();
                    Area.iExpire = Area.iCreated + MAData.Areas[id].iEntityExpire;
                    Area.iID = (uint)e.net.ID;
                    Area.uCreatorID = player.userID;
                    MAData.Entities.Add(Area.iID, Area);
                    if (Convert.ToBoolean(Config["Settings", "Debug"]))
                    {
                        string parsed_config = GetMessage("EntityExpiry", player.UserIDString);
                        parsed_config = parsed_config.Replace("{expire_time}", UnixTimeStampToDateTime(Area.iExpire).ToLongTimeString());
                        parsed_config = parsed_config.Replace("{current_time}", UnixTimeStampToDateTime(UnixTimeStampUTC()).ToLongTimeString());
                        PrintToChat(player, parsed_config);
                    }
                }
            }
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BasePlayer)
            {
                var player = entity as BasePlayer;
                if (PlayerExists(player))
                {
                    int id = MAData.PlayerData[player.userID].iInArea;
                    if (id != -1 && MagicAreaExists(id)) { MAData.PlayerData[player.userID].iInArea = -1; }
                }
            }
            else
            {
                uint id = entity.net.ID;
                if (MAData.Entities.ContainsKey(id))
                {
                    if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts("Destroying entity: " + id.ToString() + ". [DEATH]"); }
                    MAData.Entities.Remove(id);
                }
            }
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            uint id = entity.net.ID;
            if (MAData.Entities.ContainsKey(id))
            {
                if (UnixTimeStampUTC() >= MAData.Entities[id].iExpire)
                {
                    if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts("Destroying entity: " + id.ToString() + ". [EXPIRED]"); }
                    entity.Kill();
                    MAData.Entities.Remove(id);
                }
            }
        }

        private object OnItemResearch(Item item, BasePlayer player)
        {
            if(PlayerExists(player))
            {
                int id = MAData.PlayerData[player.userID].iInArea;
                if (id != -1 && MagicAreaExists(id)) { if(!MAData.Areas[id].bCanResearch) { PrintToChat(player, GetMessage("ResearchBlocked", player.UserIDString)); return false; } }
            }
            return null;
        }

        // --- [ CONSOLE ] ---

        [ConsoleCommand("area.create")]
        private void ccmdCreateArea(ConsoleSystem.Arg arg)
        {
            if (arg.connection.authLevel >= Convert.ToInt32(Config["Admin", "MaxLevel"]))
            {
                var player = arg.connection?.player as BasePlayer;
                if (player == null) return;
                int id = CreateMagicArea(player.transform.position, 50);
                Puts(GetMessage("AreaCreated", player.UserIDString).Replace("{area_id}", id.ToString()));
                PrintToChat(player, GetMessage("AreaCreated", player.UserIDString).Replace("{area_id}", id.ToString()));
            }
        }

        // ------------------

        private object OnPlayerRespawned(BasePlayer player)
        {
            int id = MAData.PlayerData[player.userID].iInArea; bool success = false;
            if (PlayerExists(player) && id != -1 && MagicAreaExists(id))
            {
                if (MAData.Areas[id].Spawns.Count == 0)
                {
                    success = Convert.ToBoolean(MagicTeleportation.CallHook("InitTeleport", player, MAData.Areas[id].fMinX, MAData.Areas[id].fMinY, MAData.Areas[id].fMinZ, false, true, MAData.Areas[id].tTitle, null, 1, 3));
                }
                if (success)
                {
                    string parsed_config = GetMessage("TeleportedBack", player.UserIDString);
                    parsed_config = parsed_config.Replace("{area_title}", MAData.Areas[id].tTitle);
                    PrintToChat(player, parsed_config);
                }
                MAData.PlayerData[player.userID].iInArea = -1;
                return false;
            }
            return null;
        }

        private bool PlayerToPoint(BasePlayer player, float radi, float x, float y, float z)
        {
            float oldposx = 0.0f, oldposy = 0.0f, oldposz = 0.0f, tempposx = 0.0f, tempposy = 0.0f, tempposz = 0.0f;
            oldposx = player.transform.position.x;
            oldposy = player.transform.position.y;
            oldposz = player.transform.position.z;
            tempposx = (oldposx - x);
            tempposy = (oldposy - y);
            tempposz = (oldposz - z);
            if (((tempposx < radi) && (tempposx > -radi)) && ((tempposy < radi) && (tempposy > -radi)) && ((tempposz < radi) && (tempposz > -radi)))
            {
                return true;
            }
            return false;
        }

        void Loaded()
        {
            MAData = Interface.GetMod().DataFileSystem.ReadObject<MA>(this.Title);
        }

        void Unload()
        {
            SaveData();
        }

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, MAData);
        }

        // ======================== [ PLAYER ] ===========================

        private bool PlayerExists(BasePlayer player)
        {
            PlayerData item = null;
            if (MAData.PlayerData.TryGetValue(player.userID, out item))
            {
                return true;
            }
            return false;
        }

        private bool InitPlayer(BasePlayer player)
        {
            if (!PlayerExists(player))
            {
                PlayerData z = new PlayerData();
                z.uUserID = player.userID;
                z.iInArea = -1;
                z.iInitStamp = UnixTimeStampUTC();
                MAData.PlayerData.Add(z.uUserID, z);
                if (Convert.ToBoolean(Config["Settings", "Debug"])) { Puts("Registering " + player.displayName + " [ " + player.userID.ToString() + " ]."); }
                return true;
            }
            return false;
        }

        // ===============================================================

        private bool IsPlayerInArea(BasePlayer player, float MinX, float MinY, float MaxX, float MaxY)
        {
            if (player != null && player.isConnected)
            { float X = player.transform.position.x; float Y = player.transform.position.y; float Z = player.transform.position.z; if (X >= MinX && X <= MaxX && Y >= MinY && Y <= MaxY) { return true; } }
            return false;
            
        }

        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating..."); Config.Clear();
            Config["Settings", "TimerInterval"] = 1;
            Config["Settings", "Debug"] = false;
            Config["Settings", "DefaultExpire"] = 10800; // 3 hours
            Config["Admin", "MaxLevel"] = 2;
            
            
        }

        private HitInfo OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BasePlayer)
            {
                var player = entity as BasePlayer;
                if (PlayerExists(player))
                {
                    int id = MAData.PlayerData[player.userID].iInArea;
                    if (id != -1 && MagicAreaExists(id))
                    {
                        if (MAData.Areas[id].bGod)
                        {
                            hitInfo.damageTypes.ScaleAll(0f);
                            return hitInfo;
                        }
                    }
                }
            }
            return null;
        }

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            return null;
        }

        public static Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }

        public static int GetRandomNumber(int min, int max)
        {
            System.Random r = new System.Random();
            int n = r.Next();
            return n;
        }
    }
}

// --- End of file: MagicArea.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HardcoreWorkbench.cs ---
// --- Original Local Path: HardcoreWorkbench.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Hardcore Workbench", "Marat", "1.0.3")]
    [Description("Removes tech tree from workbenches")]
    public class HardcoreWorkbench : RustPlugin
    {
        #region Variables
		
        private const string WorkbenchLayer = "UI_WorkbenchLayer";
        private const string permissionName = "hardcoreworkbench.use";
        private readonly Dictionary<BasePlayer, WorkbenchBehavior> benchOpen = new Dictionary<BasePlayer, WorkbenchBehavior>();
        private List<BaseEntity> vendingMachine = new List<BaseEntity>();
		
        #endregion
		
        #region Hooks
		
        private void OnServerInitialized()
        {
            LoadData();
            if (config.usePermission) permission.RegisterPermission(permissionName, this);
            
            var bp = ItemManager.GetBlueprints();
            for (int i = 0; i < bp.Count; i++)
            {
                if (!storedData.cachedLevel.ContainsKey(bp[i].name))
                {
                    if (bp[i].workbenchLevelRequired < 1) continue;
                    storedData.cachedLevel.Add(bp[i].name, bp[i].workbenchLevelRequired);
                    SaveData();
                }
                bp[i].workbenchLevelRequired = config.disableCraftMode ? 0 : storedData.cachedLevel[bp[i].name];
            }
            
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
            
            if (config.addVehiclesParts)
            {
                var monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();
                for (int i = 0; i < monuments.Length; i++)
                {
                    if (monuments[i] != null && monuments[i].name.Contains("compound"))
                    {
                        var pos = monuments[i].transform.position + monuments[i].transform.rotation * new Vector3(0.7f, 0.25f, 6.85f);
                        var rot = monuments[i].transform.rotation * Quaternion.Euler(0f, 0f, 0f);

                        var vending = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_vehicleshigh.prefab", pos, rot) as NPCVendingMachine;
                        if (vending != null)
                        {
                            vending.Spawn();
                            vending.SendNetworkUpdateImmediate(true);
                            vendingMachine.Add(vending);
                        }
                    }
                }
            }
        }
        
        private void Unload()
        {
			var player = BasePlayer.activePlayerList;
			for (int i = 0; i < player.Count; i++)
			{
				CuiHelper.DestroyUi(player[i], WorkbenchLayer);
				OnCloseBox(player[i]);
			}
			
            if (config.addVehiclesParts)
            {
                for (int i = 0; i < vendingMachine.Count; i++)
                {
                    if (!vendingMachine[i].IsDestroyed)
                        vendingMachine[i]?.Kill();
                }
                vendingMachine.Clear();
            }
			
			var bp = ItemManager.GetBlueprints();
			for (int i = 0; i < bp.Count; i++)
			{
				if (storedData.cachedLevel.ContainsKey(bp[i].name))
					bp[i].workbenchLevelRequired = storedData.cachedLevel[bp[i].name];
			}
			
            config = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            
            if (config.disableCraftMode)
                player.ClientRPCPlayer(null, player, "craftMode", 1);
            else
                player.ClientRPCPlayer(null, player, "craftMode", 0);
        }
        
        private void CanLootEntity(BasePlayer player, Workbench container)
        {
            if (player == null || container == null) return;
            if (config.useMenuWorkbench) OpenWorkbench(player);
            else OnOpenBox(player);
        }
        
        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (player == null || entity == null) return;
            if (entity is Workbench && config.useMenuWorkbench)
            {
                CuiHelper.DestroyUi(player, WorkbenchLayer);
                return;
            }
            if (entity is ResearchTable)
            {
                OnCloseBox(player);
				return;
            }
        }
        
        private void OnEntityLeave(TriggerWorkbench trigger, BasePlayer player)
        {
            if (player == null || player.IsNpc) return;
            OnCloseBox(player);
        }
        
        private object OnEntityVisibilityCheck(ResearchTable table, BasePlayer player)
        {
            if (table == null || table?.net.ID == null || player == null) return null;
            if (table.GetComponent<WorkbenchBehavior>() != null)
            {
                if (table.HasFlag(BaseEntity.Flags.Reserved1) && table.HasFlag(BaseEntity.Flags.Reserved2))
                {
                    table.SetFlag(BaseEntity.Flags.Reserved3, true, false, true);
                    return false;
                }
                return true;
            }
            return null;
        }
        
        private void OnOpenBox(BasePlayer player)
        {
            if (!benchOpen.ContainsKey(player) || benchOpen[player] == null)
            {
                var box = player.gameObject.AddComponent<WorkbenchBehavior>();
                benchOpen[player] = box;
                box?.Open(player);
            }
        }
        
        private void OnCloseBox(BasePlayer player)
        {
            if (benchOpen.ContainsKey(player) && benchOpen[player] != null)
            {
                var box = benchOpen[player];
                box?.Close(player);
                benchOpen.Remove(player);
                player.gameObject.GetComponent<WorkbenchBehavior>().Destroy();
            }
        }
        
        #endregion
        
        #region Configuration
        
        private class PluginConfig
        {
            [JsonProperty("Use workbench menu")] public bool useMenuWorkbench;
            [JsonProperty("Remove need for workbench")] public bool disableCraftMode;
            [JsonProperty("Time to research item")] public float itemResearchTime;
            [JsonProperty("Add vehicles parts vending machine")] public bool addVehiclesParts;
            [JsonProperty("Use permission to open workbench")] public bool usePermission;
        }
        
        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                useMenuWorkbench = true,
                disableCraftMode = false,
                itemResearchTime = 10f,
                addVehiclesParts = true,
                usePermission = true
            };
        }
        
        private static PluginConfig config;
        
        protected override void SaveConfig() => Config.WriteObject(config);
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<PluginConfig>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("The config file contains an error and has been replaced with the default config.");
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        
        #endregion

        #region Commands
        
        [ConsoleCommand("UI_Workbench")]
        private void CmdWorkbenchUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (config.usePermission && !permission.UserHasPermission(player.UserIDString, permissionName)) return;
            OnOpenBox(player);
        }
        
        #endregion

        #region Interface
        
        private void OpenWorkbench(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, WorkbenchLayer);
            CuiElementContainer container = new CuiElementContainer();
            
            string text = config.usePermission && !permission.UserHasPermission(player.UserIDString, permissionName) ? GetMessage("Lang_NoPermissions",player.UserIDString) : GetMessage("Lang_OpenWorkbench",player.UserIDString);
            string color = config.usePermission && !permission.UserHasPermission(player.UserIDString, permissionName) ? "0.74 0.33 0.28 1.0" : "0.4531373 0.5550981 0.2627451 1";
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.0", AnchorMax = "0.5 0.0", OffsetMin = "320.5 117", OffsetMax = "448.5 149" },
                Button = { Command = "UI_Workbench", Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                Text = { Text = text, Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.93 0.93 0.93 1" }
            }, "Overlay", WorkbenchLayer);
            
            CuiHelper.AddUi(player, container);
        }
		
        #endregion

        #region Classes
        
        public class WorkbenchBehavior : FacepunchBehaviour
        {
            private ResearchTable container;
            
            public void Awake()
            {
                container = gameObject.GetComponent<ResearchTable>();
            }
            
            public void Open(BasePlayer player)
            {
				if (player != null)
                {
					container = CreateTable(player);
					Invoke(() => StartLoot(player), 0.1f);
				}
            }
            
            public void Close(BasePlayer player)
            {
                if (container != null && !container.IsDestroyed)
                {
                    for (int i = container.inventory.itemList.Count - 1; i >= 0; i--)
                    {
                        player.GiveItem(container.inventory.itemList[i], BaseEntity.GiveItemReason.Generic);
                    }
                    container.inventory.itemList.Clear();
                    container.Kill();
                    UnityEngine.Object.Destroy(container);
                    container = null;
                }
                player.EndLooting();
                UnityEngine.Object.Destroy(this);
            }
            
            public void Destroy() => UnityEngine.Object.Destroy(this);
            
            public static ResearchTable CreateTable(BasePlayer player)
            {
                var table = GameManager.server.CreateEntity("assets/prefabs/deployable/research table/researchtable_deployed.prefab", player.transform.position + new Vector3(0, -1000, 0)) as ResearchTable;
                if (table == null) return null;
				
                UnityEngine.Object.DestroyImmediate(table.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.DestroyImmediate(table.GetComponent<GroundWatch>());
                foreach (var collider in table.GetComponentsInChildren<Collider>())
                {
                    UnityEngine.Object.DestroyImmediate(collider);
                }
				
                table._limitedNetworking = false;
                table.EnableSaving(false);
                table.researchDuration = config.itemResearchTime;
                table.Spawn();
                table.gameObject.AddComponent<WorkbenchBehavior>();
                table.SendNetworkUpdate();
				table.UpdateNetworkGroup();
                
                return table;
            }
            
            public void StartLoot(BasePlayer player)
            {
                player.inventory.loot.StartLootingEntity(container, false);
                player.inventory.loot.AddContainer(container.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", container.panelName);
                container.SendNetworkUpdate();
                if (config.useMenuWorkbench) EffectNetwork.Send(new Effect("assets/prefabs/npc/flame turret/effects/flameturret-deploy.prefab", player, 0, new Vector3(0, 0f, 0), new Vector3()), player.Connection);
            }
        }
		
        #endregion
		
        #region Lang
		
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Lang_OpenWorkbench"] = "OPEN WORKBENCH",
                ["Lang_NoPermissions"] = "NO PERMISSION"
            }, this);
			
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Lang_OpenWorkbench"] = "ОТКРЫТЬ ВЕРСТАК",
                ["Lang_NoPermissions"] = "НЕТ РАЗРЕШЕНИЯ"
            }, this, "ru");
        }
		
        private string GetMessage(string key, string steamID) => lang.GetMessage(key, this, steamID);
		
        #endregion

        #region Data
		
		private StoredData storedData;
		
		private class StoredData
        {
            public Dictionary<string, int> cachedLevel = new Dictionary<string, int>();
        }
		
		private void SaveData()
		{
            if (storedData != null)
			{
                Interface.Oxide.DataFileSystem.WriteObject($"{Title}_cachedLevel", storedData, true);
            }
        }
		
		private void LoadData()
		{
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>($"{Title}_cachedLevel");
            if (storedData == null)
			{
                storedData = new StoredData();
                SaveData();
            }
        }
		
		#endregion
    }
}

// --- End of file: HardcoreWorkbench.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ShowHitInfo.cs ---
// --- Original Local Path: ShowHitInfo.cs ---

using Rust;
using System;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{

    [Info("ShowHitInfo", "nomizzz", "1.1.0")]
    [Description("Displays the amount of damage a player deals upon hitting another entity to the player's chat log.")]
    class ShowHitInfo : RustPlugin
    {

        HashSet<ulong> users = new HashSet<ulong>();
        void Unload() => SaveData();
        void OnServerSave() => SaveData();

        private void OnEntityTakeDamage(BaseCombatEntity victim, HitInfo hitInfo)
        {
            if (victim == null || hitInfo == null) return;
            DamageType type = hitInfo.damageTypes.GetMajorityDamageType();
            if (type == null) return;

            if (hitInfo?.Initiator != null && hitInfo?.Initiator?.ToPlayer() != null && users.Contains(hitInfo.Initiator.ToPlayer().userID))
            {
                // Need to actually retrieve detailed information on next server tick, because HitInfo will not have been scaled according to hitboxes, protection, etc until then:
                NextTick(() =>
                {
                    SendReply(
                      hitInfo?.Initiator?.ToPlayer(),
                      string.Format(GetMessage("showhitinfo_displaydamage", hitInfo?.Initiator?.ToPlayer().UserIDString), hitInfo.damageTypes.Total(), victim.Health())
                    );
                });
            }
        }

        void Loaded()
        {
            LoadSavedData();
            LoadPermissions();

            // Register all informational messages for localization
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["showhitinfo_unauthorized"] = "You are not authorized to use this command.",
                ["showhitinfo_disabled"] = "Damage you deal will no longer be logged to your chat window.",
                ["showhitinfo_enabled"] = "Damage you deal will now be logged to your chat window.",
                ["showhitinfo_displaydamage"] = "You did {0} damage, target now has {1}HP"
            }, this);
        }

        string GetMessage(string name, string sid = null)
        {
            return lang.GetMessage(name, this, sid);
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("ShowHitInfo", users);

        void LoadSavedData()
        {
            HashSet<ulong> users = Interface.Oxide.DataFileSystem.ReadObject<HashSet<ulong>>("ShowHitInfo");
            this.users = users;
        }

        void LoadPermissions()
        {
            permission.RegisterPermission("showhitinfo.enable", this);
        }

        bool IsAllowed(BasePlayer player)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "showhitinfo.enable") || player.net.connection.authLevel == 2) return true;
            SendReply(player, GetMessage("showhitinfo_unauthorized", player.UserIDString));
            return false;
        }

        [ChatCommand("hitinfo")]
        void ToggleHitInfo(BasePlayer player, string cmd, string[] args)
        {
            if (!IsAllowed(player)) return;
            if (users.Contains(player.userID))
            {
                users.Remove(player.userID);
                SendReply(player, GetMessage("showhitinfo_disabled", player.UserIDString));
            }
            else
            {
                users.Add(player.userID);
                SendReply(player, GetMessage("showhitinfo_enabled", player.UserIDString));
            }
        }

    }
}


// --- End of file: ShowHitInfo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Menu.cs ---
// --- Original Local Path: Menu.cs ---

using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Collections;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ru = Oxide.Game.Rust;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Menu", "ходвард", "1.0.2")]

    class Menu : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

        private const string Layer = "asd";

        private void LoadImages()
        {
            if (!ImageLibrary)
            {
                PrintError("IMAGE LIBRARY IS NOT INSTALLED!");
            }
            else
            {
                ImageLibrary?.Call("AddImage", "https://i.postimg.cc/YSmpXPPJ/image-3.png", "online");
                ImageLibrary?.Call("AddImage", "https://i.postimg.cc/d10xZ6Dr/Frame-1463.png", "logoava1");
                ImageLibrary?.Call("AddImage", "https://i.postimg.cc/8z33n0dg/image-2.png", "bg1");
                ImageLibrary?.Call("AddImage", "https://i.postimg.cc/FHYrQbhW/image-24.png", "poloskamenu1");
                ImageLibrary?.Call("AddImage", "https://i.postimg.cc/DfPgsDtG/image-27.png", "name123");
                ImageLibrary?.Call("AddImage", "https://i.postimg.cc/7YVGLN8q/image-23.png", "name456");
                ImageLibrary?.Call("AddImage", "https://i.postimg.cc/nV2JjSYv/image-6.png", "store");
                ImageLibrary?.Call("AddImage", "https://i.postimg.cc/kXyKLmTM/menub.png", "info");
            }
        }

        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                Main_menu(player);
                RefreshUI(player, "all");
                ServerMgr.Instance.StartCoroutine(StartUpdate(player));
                player.SetFlag(BaseEntity.Flags.Reserved3, true);
                ServerMgr.Instance.StopCoroutine(StartUpdate(player));
            }

            LoadImages();
            AddCovalenceCommand("menuOpen", nameof(CmdMenuOpen));
        }

        private readonly List<BasePlayer> MenuUsers2 = new List<BasePlayer>();
        private void CmdMenuOpen(IPlayer user, string cmd, string[] args)
        {
            var player = user?.Object as BasePlayer;
            if (player == null) return;

            if (MenuUsers2.Contains(player))
            {
                player.SetFlag(BaseEntity.Flags.Reserved3, true);
                ServerMgr.Instance.StartCoroutine(StartUpdate(player));
                CuiHelper.DestroyUi(player, Layer + "name");
                CuiHelper.DestroyUi(player, Layer + "online");
                CuiHelper.DestroyUi(player, Layer + "icons.online");
                CuiHelper.DestroyUi(player, Layer + "invise2");
                CuiHelper.DestroyUi(player, Layer + "text.menu");
                CuiHelper.DestroyUi(player, Layer + "menu");
                CuiHelper.DestroyUi(player, Layer + "icons.store");
                CuiHelper.DestroyUi(player, Layer + "icons.info");
                CuiHelper.DestroyUi(player, Layer + "name1");
                CuiHelper.DestroyUi(player, Layer + "logoavaa2");
                CuiHelper.DestroyUi(player, Layer + "poloskamenu1");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                ServerMgr.Instance.StopCoroutine(StartUpdate(player));

                RefreshUI(player, "all");
                MenuUsers2.Remove(player);
            }
            else
            {
                CuiHelper.DestroyUi(player, Layer + "name");
                CuiHelper.DestroyUi(player, Layer + "online");
                CuiHelper.DestroyUi(player, Layer + "icons.online");
                CuiHelper.DestroyUi(player, Layer + "invise2");
                CuiHelper.DestroyUi(player, Layer + "text.menu");
                CuiHelper.DestroyUi(player, Layer + "menu");
                CuiHelper.DestroyUi(player, Layer + "icons.store");
                CuiHelper.DestroyUi(player, Layer + "icons.info");
                CuiHelper.DestroyUi(player, Layer + "name1");
                CuiHelper.DestroyUi(player, Layer + "logoavaa2");
                CuiHelper.DestroyUi(player, Layer + "poloskamenu1");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");
                CuiHelper.DestroyUi(player, Layer + "text.buttons");

                player.SetFlag(BaseEntity.Flags.Reserved3, false);

                RefreshUI(player, "open");
                MenuUsers2.Add(player);
            }
        }
        private IEnumerator StartUpdate(BasePlayer player)
        {
            while (player != null && player.IsConnected)
            {
                RefreshUI(player, "timeandonline");
                yield return new WaitForSeconds(2.5f);
            }
        }
        void startupdatecon(ConsoleSystem.Arg ar)
        {
            var target = ar.Player();
            if (target.IsAdmin) { }
            if (target.IsSleeping())
            {
                return;
            }
            if (target.gameObject == null)
            {
                return;
            }
            if (target != null)
            {
                return;
            }
        }
        private void OnPlayerConnected(BasePlayer player)
        {
            Main_menu(player);
            RefreshUI(player, "all");
            ServerMgr.Instance.StartCoroutine(StartUpdate(player));
            player.SetFlag(BaseEntity.Flags.Reserved3, true);
            ServerMgr.Instance.StopCoroutine(StartUpdate(player));
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            player.SetFlag(BaseEntity.Flags.Reserved3, false);
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                player.SetFlag(BaseEntity.Flags.Reserved3, false);
            }
        }

        #region Gui
        public void RefreshUI(BasePlayer player, string Type)
        {
            var c = new CuiElementContainer();

            switch (Type)
            {
                case "timeandonline":
                    CuiHelper.DestroyUi(player, Layer + "text.online");

                    UI.AddText1(ref c, Layer + "online", Layer + "text.online", "1 1 1 1", $"{BasePlayer.activePlayerList.Count}", TextAnchor.MiddleLeft, 11, "0 0", "1 1", "", "", "0 0 0 1", "robotocondensed-bold.ttf", "0.55 0.55");
                    break;

                case "all":
                    CuiHelper.DestroyUi(player, Layer + "invise");
                    CuiHelper.DestroyUi(player, Layer + "name");
                    CuiHelper.DestroyUi(player, Layer + "text.menu");
                    CuiHelper.DestroyUi(player, Layer + "menu");
                    CuiHelper.DestroyUi(player, Layer + "icons.store");
                    CuiHelper.DestroyUi(player, Layer + "icons.info");
                    CuiHelper.DestroyUi(player, Layer + "logoavaa2");
                    CuiHelper.DestroyUi(player, Layer + "poloskamenu1");
                    CuiHelper.DestroyUi(player, Layer + "name1");


                    //logo menu 2

                    CuiHelper.DestroyUi(player, Layer + "logoavaa2");
                    CuiHelper.DestroyUi(player, Layer + "poloskamenu1");

                    UI.AddImage(ref c, Layer, Layer + "logoavaa2", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "8.5 -50", "175.613 8");
                    UI.AddRawImage1(ref c, Layer + "logoavaa2", Layer + "logoavaa.online2", ImageLibrary?.Call<string>("GetImage", "bg1"), "0 0 0 1", "", "", "0 0", "1 1", "1 1", "-1 -1");

                    UI.AddImage(ref c, Layer, Layer + "poloskamenu1", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "43 -32", "100.613 -13");
                    UI.AddRawImage1(ref c, Layer + "poloskamenu1", Layer + "poloskamenu1.ava", ImageLibrary?.Call<string>("GetImage", "poloskamenu1"), "", "", "", "0 0", "1 1", "1 1", "-1 -1");

                    // text
                    UI.AddImage(ref c, Layer, Layer + "name", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "40 -14.014", "160.547 6");
                    UI.AddRawImage1(ref c, Layer + "name", Layer + "tittle", ImageLibrary?.Call<string>("GetImage", "name123"), "1 1 1 1", "", "", "0 0", "1 1", "1 1", "-1 -1");

                    UI.AddImage(ref c, Layer, Layer + "name1", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "48 -27.514", "95.547 -17");
                    UI.AddRawImage1(ref c, Layer + "name1", Layer + "tittle", ImageLibrary?.Call<string>("GetImage", "name456"), "1 1 1 1", "", "", "0 0", "1 1", "1 1", "-1 -1");

                    //buttons

                    CuiHelper.DestroyUi(player, Layer + "icons.store");
                    CuiHelper.DestroyUi(player, Layer + "icons.info");

                    UI.AddImage(ref c, Layer, Layer + "icons.store", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "84 -47", "100.337 -33.008");
                    UI.AddButton(ref c, Layer, Layer + "icons.store", $"chat.say /menu", "", "0 0 0 0.3", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "84 -47", "100.337 -33.008");
                    UI.AddRawImage1(ref c, Layer + "icons.store", Layer + "icon.store", ImageLibrary?.Call<string>("GetImage", "info"), "1 1 1 1", "", "", "0.05 0", "0.95 1", "1 1", "-1 -1");

                    UI.AddImage(ref c, Layer, Layer + "icons.info", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "102.337 -47", "118.337 -33.008");
                    UI.AddButton(ref c, Layer, Layer + "icons.info", $"chat.say /store", "", "0 0 0 0.3", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "102.337 -47", "118.337 -33.008");
                    UI.AddRawImage1(ref c, Layer + "icons.info", Layer + "icon.info", ImageLibrary?.Call<string>("GetImage", "store"), "1 1 1 1", "", "", "0 -0.1", "1 1.1", "1 1", "-1 -1");

                    //online menu


                    CuiHelper.DestroyUi(player, Layer + "online");
                    CuiHelper.DestroyUi(player, Layer + "icons.online");

                    UI.AddImage(ref c, Layer, Layer + "online", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "61.337 -57.3", "86 -24.008");
                    UI.AddImage(ref c, Layer, Layer + "icons.online", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "38.337 -45.3", "68.337 -24.008");
                    UI.AddRawImage1(ref c, Layer + "icons.online", Layer + "icon.online", ImageLibrary?.Call<string>("GetImage", "online"), "1 1 1 1", "", "", "0 -0.5", "1.1 1", "1 1", "-1 -1");

                    //logo menu

                    CuiHelper.DestroyUi(player, Layer + "logoavaa");

                    UI.AddImage(ref c, Layer, Layer + "logoavaa", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-25 -62.48", "50.613 20.878");
                    UI.AddRawImage1(ref c, Layer + "logoavaa", Layer + "logoavaa.online", ImageLibrary?.Call<string>("GetImage", "logoava1"), "1 1 1 0.8", "", "", "0 0", "1 1", "1 1", "-1 -1");

                    //onlinetext

                    CuiHelper.DestroyUi(player, Layer + "menu");

                    UI.AddImage(ref c, Layer, Layer + "menu", "0.8 0.8 0.8 0.0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-13 -60.48", "30.613 -25.878");
                    UI.AddText1(ref c, Layer + "online", Layer + "text.online", "1 1 1 1", $"{BasePlayer.activePlayerList.Count}", TextAnchor.MiddleLeft, 11, "0 0", "1 1", "", "", "0 0 0 1", "robotocondensed-bold.ttf", "0.55 0.55", 0);
                    UI.AddButton(ref c, Layer, Layer + "invise", "menuOpen", "", "0.8 0.8 0.8 0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-13 -60.48", "50.613 15.878");

                    break;
                case "open":
                    CuiHelper.DestroyUi(player, Layer + "invise2");
                    CuiHelper.DestroyUi(player, Layer + "invise");

                    UI.AddButton(ref c, Layer, Layer + "invise2", "menuOpen", "", "0.8 0.8 0.8 0.0", "", "assets/icons/greyout.mat", "0.5 0.5", "0.5 0.5", "-13 -60.48", "50.613 15.878");
                    break;
            }
            CuiHelper.AddUi(player, c);
        }

        public void Main_menu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);

            var c = new CuiElementContainer();
            //button store

            UI.AddImage(ref c, "Overlay", Layer, "0 0 0 0", "", "", "0 1", "0 1", "4.135 -43.232", "37.366 -0.011");

            CuiHelper.AddUi(player, c);
        }



        #endregion

        #region config

        public class PluginConfig
        {

        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        PluginConfig config;

        public static class UI
        {
            public static void AddImage(ref CuiElementContainer container, string parrent, string name, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax, string outline = "", string dist = "")
            {
                if (string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                        {
                            new CuiImageComponent{Color = color, Material = mat},
                            new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                        }
                    });

                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiImageComponent{Color = color},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }

            public static void AddRawImage(ref CuiElementContainer container, string parrent, string name, string png, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax)
            {
                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiRawImageComponent{Color = color, Png = png},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax},
                        new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.55 0.55"}
                    }
                    });
            }


            public static void AddRawImage1(ref CuiElementContainer container, string parrent, string name, string png, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax)
            {
                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiRawImageComponent{Color = color, Png = png},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax},
                    }
                    });
            }

            public static void AddText(ref CuiElementContainer container, string parrent, string name, string color, string text, TextAnchor align, int size, string aMin, string aMax, string oMin, string oMax, string outColor = "0 0 0 1", string font = "robotocondensed-bold.ttf", string dist = "0.55 0.55", float FadeIN = 0f, float FadeOut = 0f)
            {
                container.Add(new CuiElement()
                {
                    Parent = parrent,
                    Name = name,
                    FadeOut = FadeOut,
                    Components =
                    {
                        new CuiTextComponent{Color = color,Text = text, Align = align, FontSize = size, Font = font, FadeIn = 0.5f},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax},
                    }
                });

            }

            public static void AddText1(ref CuiElementContainer container, string parrent, string name, string color, string text, TextAnchor align, int size, string aMin, string aMax, string oMin, string oMax, string outColor = "0 0 0 1", string font = "robotocondensed-bold.ttf", string dist = "0.55 0.55", float FadeIN = 0f, float FadeOut = 0f)
            {
                container.Add(new CuiElement()
                {
                    Parent = parrent,
                    Name = name,
                    FadeOut = FadeOut,
                    Components =
                    {
                        new CuiTextComponent{Color = color,Text = text, Align = align, FontSize = size, Font = font},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax},
                    }
                });

            }
            public static void AddText2(ref CuiElementContainer container, string parrent, string name, string color, string text, TextAnchor align, int size, string aMin, string aMax, string oMin, string oMax, string outColor = "0 0 0 1", string font = "robotocondensed-bold.ttf", string dist = "0.55 0.55", float FadeIN = 0f, float FadeOut = 0f)
            {
                container.Add(new CuiElement()
                {
                    Parent = parrent,
                    Name = name,
                    FadeOut = FadeOut,
                    Components =
                    {
                        new CuiTextComponent{Color = color,Text = text, Align = align, FontSize = size, Font = font},
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax},
                        new CuiOutlineComponent{Color = "1 1 1 0.1", Distance = "0.1 0.1"}
                    }
                });

            }
            public static void AddButton(ref CuiElementContainer container, string parrent, string name, string cmd, string close, string color, string sprite, string mat, string aMin, string aMax, string oMin, string oMax, string outline = "", string dist = "")
            {
                if (string.IsNullOrEmpty(sprite) && !string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, Material = mat, },
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });

                if (string.IsNullOrEmpty(sprite) && string.IsNullOrEmpty(mat))
                    container.Add(new CuiElement()
                    {
                        Parent = parrent,
                        Name = name,
                        Components =
                    {
                        new CuiButtonComponent{Command = cmd, Color = color, Close = close, },
                        new CuiRectTransformComponent{AnchorMin = aMin, AnchorMax = aMax, OffsetMin = oMin, OffsetMax = oMax}
                    }
                    });
            }
        }

        #endregion
    }
}

// --- End of file: Menu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RustShop.cs ---
// --- Original Local Path: RustShop.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RustShop", "topplugin.ru", "1.0.4")]
    public class RustShop : RustPlugin
    {
        [PluginReference]
        Plugin ImageLibrary;

        #region Variables
        class DataStorage
        {
            public Dictionary<ulong, PlayersBalances> PlayerBalance = new Dictionary<ulong, PlayersBalances>();
            public DataStorage() { }
        }

        class PlayersBalances
        {
            public string Name;
            public int Balances;
            public int Time;
        }

        DataStorage data;
        private List<string> ListedCategories = new List<string>();
        private class ProductsData
        {
            [JsonProperty("Название предмета")]
            public string Name;
            [JsonProperty("Категория предмета")]
            public string Category;
            [JsonProperty("Стоимость предмета")]
            public int Price;
            [JsonProperty("Количество предмета")]
            public int Amount;
            [JsonProperty("Система. id предмета")]
            public string ShortName;
        }

        public int StartBalance = 0;
        public int HourAmount = 15;

        private List<ProductsData> shopElements = new List<ProductsData>();

        static List<string> permisions = new List<string>();

        static int GetDiscountSize(BasePlayer player)
        {
            for (int i = permisions.Count - 1; i >= 0; i--)
                if (PermissionService.HasPermission(player, permisions[i]))
                    return Convert.ToInt32(permisions[i].Replace("rustshop.discount", ""));
            return 0;
        }
        #endregion

        #region Config
        bool BPEnabled = false;
        double BPPrice = 1.0;
        string AMin = "0.01244507 0.08203125";
        string AMax = "0.1537335 0.1210937";

        private void LoadConfigValues()
        {
            bool changed = false;
            var _permisions = new List<object>()
            {
                {"rustshop.discount10"},
                {"rustshop.discount20"},
                {"rustshop.discount50"},
                {"rustshop.discount70"},
                {"rustshop.discount90"}
            };
            if (GetConfig("Основные", "Список привилегий и размера скидок (rustshop.discount99 - где 99 это размер скидки)", ref _permisions))
            {
                Puts("Привилегии созданы, Shop загружен!");
                changed = true;
            }
            permisions = _permisions.Select(p => p.ToString()).ToList();
            var _categories = new List<object>()
            {
                { "Testing" }
            };

            if (GetConfig("Основные", "Список категорий товаров", ref _categories))
            {
                Puts("Категории созданы, Shop загружен!");
                changed = true;
            }

            if (GetConfig("UI", "Button: AnchorMin", ref AMin))
            {
                Puts("Добавлены новые пункты в конфигурацию: AnchorMin");
                changed = true;
            }

            if (GetConfig("UI", "Button: AnchorMax", ref AMax))
            {
                Puts("Добавлены новые пункты в конфигурацию: AnchorMax");
                changed = true;
            }

            if (GetConfig("Основные", "Стартовый баланс игрока", ref StartBalance))
            {
                changed = true;
            }
            if (GetConfig("Основные", "Количество рублей за наигранный час", ref HourAmount))
            {
                changed = true;
            }

            if (GetConfig("Основные", "Включить к товарам продажу чертежей (Появиться дополнительная кнопка 'Чертёж')", ref BPEnabled))
            {
                PrintWarning("Добавлены новые пункты в конфигурацию: Включить к товарам продажу чертежей");
                changed = true;
            }
            if (GetConfig("Основные", "Цена чертежа: Цена предмета * Число (умножение)", ref BPPrice))
            {
                PrintWarning("Добавлены новые пункты в конфигурацию: Цена предмета * Число (умножение)");
                changed = true;
            }
            ListedCategories = _categories.Select(p => p.ToString()).ToList();
            if (changed)
                SaveConfig();
        }

        private bool GetConfig<T>(string MainMenu, string Key, ref T var)
        {
            if (Config[MainMenu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[MainMenu, Key], typeof(T));
                return false;
            }
            Config[MainMenu, Key] = var;
            return true;
        }
        #endregion

        #region Initialization
        private List<string> Available = new List<string>();

        private void OnServerInitialized()
        {
            LoadData();
            LoadConfig();
            LoadConfigValues();
            PermissionService.RegisterPermissions(this, permisions);
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            if (!plugins.Exists("ImageLibrary"))
            {
                PrintError("ImageLibrary can not be found! Can not continue");
                Interface.Oxide.UnloadPlugin("RustShop");
                return;
            }
            else
            {
                foreach (var check in ItemManager.itemList)
                    plugins.Find("ImageLibrary").CallHook("GetImage", check.shortname, 0, true);
            }
            foreach (var check in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(check);
            }
            foreach (var check in shopElements)
            {
                if (string.IsNullOrEmpty(check.Name))
                {
                    PrintError($"Внимание! У предмета не установлено название!");
                    continue;
                }
                if (check.Price == 0)
                    PrintError($"Внимание! У предмета: {check.Name} не установлена цена!");

                if (check.Amount == 0)
                    PrintError($"Внимание! У предмета: {check.Name} не установлено количество!");

                if (string.IsNullOrEmpty(check.Category))
                    PrintError($"Внимание! У предмета: {check.Name} не установлена категория!");
                if (!ListedCategories.Contains(check.Category))
                    PrintError($"Внимание! У предмета: {check.Name} не верная категория, предмет не будет отображен!");
            }
            var bplist = ItemManager.GetBlueprints();
            foreach (var bp in bplist)
            {
                if (bp.userCraftable && !bp.defaultBlueprint)
                {
                    Available.Add(bp.targetItem.shortname);
                }
            }
            timer.Every(30f, TimerHandler);
            timer.Every(360, SaveData);
        }

        Dictionary<BasePlayer, int> timers = new Dictionary<BasePlayer, int>();
        void TimerHandler()
        {
            foreach (var player in timers.Keys.ToList())
            {
                var seconds = timers[player] -= 30;
                if (seconds > 3600)
                {
                    data.PlayerBalance[player.userID].Time = data.PlayerBalance[player.userID].Time += 3600;
                    TimerHandler();
                    break;
                }
                if (seconds <= 0)
                {
                    timers.Remove(player);
                    ChangeBalance(player, "add", HourAmount);
                    data.PlayerBalance[player.userID].Time = data.PlayerBalance[player.userID].Time = 3600;
                    SaveData();
                    SendReply(player, $"Вам начислено {HourAmount} рублей на игровой баланс магазина за активную игру на сервере\nЧто бы открыть магазин, используйте /shop");
                    timers.Add(player, data.PlayerBalance[player.userID].Time);
                }
            }
        }

        List<ulong> activePlayers = new List<ulong>();
        void DeactivateTimer(BasePlayer player)
        {
            data.PlayerBalance[player.userID].Time = timers[player];
            activePlayers.Remove(player.userID);
            timers.Remove(player);
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";
            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";
            return $"{units} {form3}";
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }
            if (!data.PlayerBalance.ContainsKey(player.userID))
            {
                data.PlayerBalance.Add(player.userID, new PlayersBalances()
                {
                    Name = player.displayName,
                    Balances = StartBalance,
                    Time = 3600,
                });
                SaveData();
            }
            if (data.PlayerBalance.ContainsKey(player.userID))
            {
                timers.Add(player, data.PlayerBalance[player.userID].Time);
                ActivateTimer(player.userID);
                DrawButton(player);
            }
        }

        void ActivateTimer(ulong userId)
        {
            if (!activePlayers.Contains(userId))
            {
                activePlayers.Add(userId);
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            DeactivateTimer(player);
        }

        void OnServerSave()
        {
            SaveData();
        }

        void SaveData()
        {
            foreach (var player in timers.Keys.ToList())
            {
                data.PlayerBalance[player.userID].Time = timers[player];
            }
            Interface.Oxide.DataFileSystem.WriteObject("RustShop/PlayersBalance", data);
        }

        void LoadData()
        {
            try
            {
                data = Interface.GetMod().DataFileSystem.ReadObject<DataStorage>("RustShop/PlayersBalance");
            }
            catch
            {
                data = new DataStorage();
            }
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("RustShop/ShopItems"))
            {
                shopElements.Add(new ProductsData
                {
                    Name = "Тестовый предмет #1",
                    ShortName = "rifle.ak",
                    Category = "Testing",
                    Price = 1,
                    Amount = 10
                });
                shopElements.Add(new ProductsData
                {
                    Name = "Тестовый предмет #2",
                    ShortName = "rifle.ak",
                    Category = "Testing",
                    Price = 2,
                    Amount = 10
                });
                shopElements.Add(new ProductsData
                {
                    Name = "Тестовый предмет #3",
                    ShortName = "rifle.ak",
                    Category = "Testing",
                    Price = 3,
                    Amount = 10
                });
                Interface.Oxide.DataFileSystem.WriteObject("RustShop/ShopItems", shopElements);
                return;
            }
            shopElements = Interface.Oxide.DataFileSystem.ReadObject<List<ProductsData>>("RustShop/ShopItems");
        }

        void ChangeBalance(BasePlayer player, string mode, int Amount, bool change = false)
        {
            if (!data.PlayerBalance.ContainsKey(player.userID))
                data.PlayerBalance.Add(player.userID, new PlayersBalances()
                {
                    Name = "Добавлен по API",
                    Balances = 0,
                    Time = 0
                });
            if (mode == "add")
            {
                data.PlayerBalance[player.userID].Balances += Amount;
                if (!change) if (player != null) SendReply(player, Messages["MONEYADD"], Amount);
            }
            if (mode == "remove")
            {
                data.PlayerBalance[player.userID].Balances -= Amount;
                if (!change) if (player != null) SendReply(player, Messages["MONEYREMOVE"], Amount);
            }
            if (player != null)
            {
                DrawButton(player);
            }
        }

        private void GiveBlueprint(BasePlayer player, string itemkey, int amount)
        {
            Item item = null;
            if (!Available.Contains(itemkey))
            {
                Puts(itemkey);
                return;
            }
            item = ItemManager.CreateByItemID(-996920608, amount);

            item.blueprintTarget = ItemManager.itemList.Find(x => x.shortname == itemkey)?.itemid ?? 0;
            player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "shopbp");
                CuiHelper.DestroyUi(player, "shop.bp");
            }
            SaveData();
        }
        #endregion

        #region Commands
        [ConsoleCommand("balance")]
        void cmdChangeBalance(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (args.Connection != null)
                if (!player.IsAdmin) return;
            if (args == null || args.Args.Length != 3 && args.Args[1] != "balance")
            {
                Puts("Вы не верно ввели команду, используйте: balance Name/SteamID add/remove Count");
                return;
            }
            var findPlayer = (BasePlayer.Find(args.Args[0]) ?? BasePlayer.FindSleeping(args.Args[0]));
            if (findPlayer == null)
            {
                Puts($"Игрок {args.Args[0]} не найден в списке игроков");
                return;
            }
            if (!data.PlayerBalance.ContainsKey(findPlayer.userID))
            {
                data.PlayerBalance.Add(findPlayer.userID, new PlayersBalances()
                {
                    Name = "Добавлен по API",
                    Balances = 0,
                    Time = 0
                });
            }
            if (args.Args[1] == "balance")
            {
                Puts($"Баланс игрока {findPlayer}: {data.PlayerBalance[findPlayer.userID].Balances}");
                return;
            }
            int change;
            if (!int.TryParse(args.Args[2], out change))
            {
                Puts("В сумме необходимо ввести число");
                return;
            }
            if (args.Args[1] != "add" && args.Args[1] != "remove" && args.Args[1] != "balance")
            {
                Puts("Вы не верно указали вид пополнения, используйте: add либо remove");
                return;
            }
            switch (args.Args[1])
            {
                case "add":
                    ChangeBalance(findPlayer, "add", change);
                    Puts($"Игроку {findPlayer} пополнен баланс на: {change}. Баланс игрока: {data.PlayerBalance[findPlayer.userID].Balances}");
                    break;
                case "remove":
                    if (data.PlayerBalance[findPlayer.userID].Balances < change)
                    {
                        Puts($"Баланс игрока ({data.PlayerBalance[findPlayer.userID].Balances}) меньше чем вы указали ({change}). Баланс не изменен");
                        return;
                    }
                    ChangeBalance(findPlayer, "remove", change);
                    Puts($"C баланса игрока {findPlayer} удалено: {change}. Баланс игрока: {data.PlayerBalance[findPlayer.userID].Balances}");
                    break;
            }
        }

        [ChatCommand("shop")]
        void cmdChatShop(BasePlayer player, string command, string[] args) => ShopGUI(player);

        [ConsoleCommand("shop")]
        void cmdConsoleShop(ConsoleSystem.Arg args)
        {
            ShopGUI(args.Player(), args.FullString);
        }

        [ConsoleCommand("product_info")]
        void cmdProductInfo(ConsoleSystem.Arg args)
        {
            string name = args.Args[0];
            var player = args.Player();
            DrawProductInfo(player, name);
        }

        [ConsoleCommand("Buy")]
        void cmdConsoleBuy(ConsoleSystem.Arg args)
        {
            string name = args.Args[0];
            var player = args.Player();
            ProductsData probable = shopElements.Find(p => p.ShortName == name);
            var dicsount = (probable.Price * GetDiscountSize(player) / 100);
            int price = (probable.Price - dicsount);
            if (probable == null)
            {
                SendReply(player, Messages["ERROR"]);
                return;
            }
            switch (args.Args[1])
            {
                case "bp":
                    if (price > data.PlayerBalance[player.userID].Balances)
                    {
                        SendReply(player, Messages["NOMONEY"]);
                        return;
                    }
                    if (args.Player().inventory.containerMain.itemList.Count == 24)
                    {
                        SendReply(player, Messages["FULLINV"]);
                        return;
                    }
                    GiveBlueprint(player, probable.ShortName, 1);
                    double bpprice = (price * BPPrice);
                    ChangeBalance(player, "remove", (int)bpprice, true);
                    SendReply(player, Messages["BUY"], probable.Name + " (Чертёж)", 1);
                    ShopGUI(args.Player(), probable.Category);
                    break;
                case "main":
                    if (price > data.PlayerBalance[player.userID].Balances)
                    {
                        SendReply(player, Messages["NOMONEY"]);
                        return;
                    }
                    if (args.Player().inventory.containerMain.itemList.Count == 24)
                    {
                        SendReply(player, Messages["FULLINV"]);
                        return;
                    }
                    Item x = ItemManager.CreateByPartialName(probable.ShortName, probable.Amount);
                    player.GiveItem(x, BaseEntity.GiveItemReason.PickedUp);
                    ChangeBalance(player, "remove", price, true);
                    SendReply(player, Messages["BUY"], probable.Name , probable.Amount);
                    ShopGUI(args.Player(), probable.Category);
                    break;
            }
        }
        #endregion

        #region GUI
        string Button = "[{\"name\":\"shopbp\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.2705882 0.5137255 0.7137255 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"{min}\",\"anchormax\":\"{max}\"}]},{\"name\":\"balance_bp\",\"parent\":\"shopbp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"1 0.6431373 0 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.3510639 0.97\"}]},{\"name\":\"balance\",\"parent\":\"balance_bp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>{B} р.</b>\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2595528\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"shopbp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Магазин: <b>/shop</b>\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2706043\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3575131 0\",\"anchormax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"shopbp\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"shop\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"shopbp\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0.6545441\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.99 0.05\"}]}]";

        void DrawButton(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1, () => DrawButton(player));
            }
            CuiHelper.DestroyUi(player, "shopbp");
            CuiHelper.AddUi(player, Button
                .Replace("{B}", data.PlayerBalance[player.userID].Balances.ToString()).Replace("{min}", AMin).Replace("{max}", AMax));
        }
        //shop.bp
        string Product = "[{\"name\":\"product_2\",\"parent\":\"shop.bp\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"0 0 0 0.95\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"product_3\",\"parent\":\"product_2\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"1 0.6431373 0 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3 0.36\",\"anchormax\":\"0.7 0.6953125\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"product_4\",\"parent\":\"product_3\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.2666667 0.509804 0.7098039 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.4 0.997\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"product_5\",\"parent\":\"product_4\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{png}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.15 0.01709393\",\"anchormax\":\"0.85 0.9829058\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"product_6\",\"parent\":\"product_3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Цена: {price}\nСкидка: {dis}\nКол-во: {count}\",\"fontSize\":17},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.5411765\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4469253 0.3359739\",\"anchormax\":\"0.9959737 0.7825413\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"product_8\",\"parent\":\"product_3\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"product_2\",\"color\":\"1 0 0 0.790022\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.7941908\",\"anchormax\":\"0.09553441 0.997\"}]},{\"name\":\"product_9\",\"parent\":\"product_8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"X\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\"}]},{\"name\":\"product_6\",\"parent\":\"product_3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Купить:\",\"fontSize\":18,\"align\":\"UpperCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4417135\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4011713 0.238894\",\"anchormax\":\"0.9959737 0.38\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"product_6\",\"parent\":\"product_3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{name}\",\"fontSize\":21,\"align\":\"UpperCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4417135\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4011713 0.8446723\",\"anchormax\":\"0.9959737 0.9922338\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        void DrawProductInfo(BasePlayer player, string product)
        {
            CuiHelper.DestroyUi(player, "product_2");
            ProductsData probable = shopElements.Find(p => p.ShortName == product);
            if (probable == null) return;
            var dicsount = (probable.Price * GetDiscountSize(player) / 100);
            int price = (probable.Price - dicsount);
            var text = dicsount > 0 ? $"<color=#FB7578>{price}P</color>" : $"<color=0.27 0.51 0.71 0.5>{price}P</color>";
            bool bp;
            if (BPEnabled)
            {
                bp = Available.Contains(probable.ShortName);
            }
            else
            {
                bp = false;
            }
            double bpprice = (price * BPPrice);
            if (bp) text = text + $" | Чертёж: <color=#FB7578>{bpprice}Р</color>";
            CuiHelper.AddUi(player, Product
                .Replace("{png}", (string)ImageLibrary.Call("GetImage", probable.ShortName)).Replace("{name}", probable.Name)
                .Replace("{price}", text).Replace("{dis}", GetDiscountSize(player).ToString() + "%").Replace("{count}", probable.Amount.ToString()));
            var container = new CuiElementContainer();
           
            if (BPEnabled)
            {
                var size = !bp ? "0.995" : "0.7";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.405 0.01", AnchorMax = $"{size} 0.2" },
                    Button = { Color = "0.20 0.38 0.53 1.00", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "Assets/Content/UI/UI.Background.Tile.psd", Command = $"Buy {probable.ShortName} main" },
                    Text = { Text = $"✔ Предмет", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }

                }, "product_3", "product_2" + "." + probable.ShortName);
                if (bp)
                    
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.71 0.01", AnchorMax = "0.9965 0.2" },
                        Button = { Color = "0.27 0.51 0.71 1", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "Assets/Content/UI/UI.Background.Tile.psd", Command = $"Buy {probable.ShortName} bp" },
                        Text = { Text = $"★ Чертёж", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }
                    }, "product_3", "product_2" + "." + probable.ShortName);
            }
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.405 0.01", AnchorMax = "0.995 0.2" },
                    Button = { Color = "0.27 0.51 0.71 1", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "Assets/Content/UI/UI.Background.Tile.psd", Command = $"Buy {probable.ShortName} main" },
                    Text = { Text = $"✔ Предмет", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }

                }, "product_3", "product_2" + "." + probable.ShortName);
            }
            CuiHelper.AddUi(player, container);
        }

        string GUI = "[{\"name\":\"shop.bp\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0 0 0 0.3903706\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.1 0.17\",\"anchormax\":\"0.9 0.83\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"shop.title\",\"parent\":\"shop.bp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.2705882 0.509804 0.7058824 0.83351\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.9281093\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"shop.titletext\",\"parent\":\"shop.title\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{TITLE}\",\"fontSize\":23,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.8342283\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"menuBp\",\"parent\":\"shop.bp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0 0 0 0.0627451\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.2307114 0.9281093\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp1\",\"parent\":\"menuBp\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"color\":\"1 0.6431373 0 0.6117647\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.02999998 0.1283876\",\"anchormax\":\"0.95 0.27\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp1text\",\"parent\":\"bp1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"БАЛАНС - {B} Р\nСкидка: {C}%\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2980392\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp1\",\"parent\":\"menuBp\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"shop.bp\",\"color\":\"0.6795254 0 0 0.9493701\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.03 0.02210394\",\"anchormax\":\"0.95 0.1028782\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp1text\",\"parent\":\"bp1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ВЫХОД\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2980392\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"dinamicitems\",\"parent\":\"shop.bp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2307114 0\",\"anchormax\":\"0.9999998 0.9261365\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        private void ShopGUI(BasePlayer player, string name = "")
        {
            CuiHelper.DestroyUi(player, "shop.bp");
            string color = "0.27 0.51 0.71 1.00";
            if (name == "") name = ListedCategories.First();
            CuiHelper.AddUi(player, GUI
                .Replace("{TITLE}", Messages["TITLE"])
                .Replace("{B}", data.PlayerBalance[player.userID].Balances.ToString())
                .Replace("{C}", GetDiscountSize(player).ToString()));
            var container = new CuiElementContainer();
            var reply = 540;
            if (reply == 0) { }
            float gap = +0.0f;
            float width = 0.195f;
            float height = 0.32f;
            float startxBox = 0.01f;
            float startyBox = 0.97f - height;
            float xmin = startxBox;
            float ymin = startyBox;
            int current = 1;

            float gap1 = +0.001f;
            float width1 = 0.98f;
            float height1 = 0.1f;
            float startxBox1 = 0.0f;
            float startyBox1 = 0.99f - height1;
            float xmin1 = startxBox1;
            float ymin1 = startyBox1;
            int categories = 1;
            foreach (var cetegories in ListedCategories)
            {
                categories++;
                color = name == cetegories ? "1.00 0.64 0.00 1.00" : "0.27 0.51 0.71 1";
                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                       AnchorMin = xmin1 + " " + ymin1,
                        AnchorMax = (xmin1 + width1) + " " + (ymin1 + height1 *1),
                        OffsetMax = "-1 -1",
                        OffsetMin = "5 5",
                    },
                    Button = { Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "Assets/Content/UI/UI.Background.Tile.psd", Color = color, Command = $"shop {cetegories}" },
                    Text = { Text = $"{cetegories}", Font = "robotocondensed-bold.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter }
                },
                 "menuBp", "menuBp" + "." + cetegories);
                xmin1 += width1 + gap1;
                if (xmin1 + width1 >= 1)
                {
                    xmin1 = startxBox1;
                    ymin1 -= height1 + gap1;
                }
                if (categories > 7) break;
            }

            foreach (var check in shopElements.Where(p => p.Category.ToString() == name))
            {
                var dicsount = (check.Price * GetDiscountSize(player) / 100);
                int price = (check.Price - dicsount);
                var pricecolor = "0.27 0.51 0.71 0.5";
               
                var text = dicsount > 0 ? $"Цена: <color=#FB7578>{price}P</color> <size=12>(-{GetDiscountSize(player)}%)</size>" : $"Цена: <color={pricecolor}>{price}P</color>";

                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                       AnchorMin = xmin + " " + ymin,
                        AnchorMax = (xmin + width) + " " + (ymin + height),
                        OffsetMax = "-1 -1",
                        OffsetMin = "5 5",
                    },
                    Button = { Color = "0.00 0.00 0.00 0.4", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "Assets/Content/UI/UI.Background.Tile.psd", },
                    Text = { Text = $"", Font = "robotocondensed-bold.ttf", FontSize = 15, Align = TextAnchor.LowerCenter, FadeIn = 0.5f }
                }, "dinamicitems", "dinamicitems" + "." + check.ShortName);

                xmin += width + gap;

                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height + gap;
                }
                container.Add(new CuiElement()
                {
                    Parent = "dinamicitems" + "." + check.ShortName,
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.ShortName), FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0.15 0.1", AnchorMax = "0.85 1" }
                    }
                });
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.8", AnchorMax = "1 1" },
                    Button = { Color = "0.27 0.51 0.71 0.7", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "Assets/Content/UI/UI.Background.Tile.psd", },
                    Text = { Text = text, Font = "robotocondensed-bold.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter }
                }, "dinamicitems" + "." + check.ShortName);
              
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.0 0", AnchorMax = "0.997 0.2" },
                        Button = { Color = "1.00 0.64 0.00 1.00", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "Assets/Content/UI/UI.Background.Tile.psd", Command = $"product_info {check.ShortName}" },
                        Text = { Text = $"Купить ({check.Amount} шт.)", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter }

                    }, "dinamicitems" + "." + check.ShortName);
                current++;
                if (current == 16)
                {
                    break;
                }
            }
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region API
        private void AddBalance(ulong userId, int Amount)
        {
            if (!data.PlayerBalance.ContainsKey(userId))
                data.PlayerBalance.Add(userId, new PlayersBalances()
                {
                    Name = "Добавлен по API",
                    Balances = 0,
                    Time = 0
                });
            var player = BasePlayer.FindByID(userId);
            ChangeBalance(player, "add", Amount);
            if (player != null)
            {
                SendReply(player, $"Вам насчитано {Amount} рублей на игровой баланс магазина\nПроверка и использование баланса /shop");
            }
        }

        private object RemoveBalance(ulong userId, int Amount)
        {
            if (!data.PlayerBalance.ContainsKey(userId))
                data.PlayerBalance.Add(userId, new PlayersBalances()
                {
                    Name = "Добавлен по API",
                    Balances = 0,
                    Time = 0
                });
            if (data.PlayerBalance[userId].Balances < Amount)
            {
                return false;
            }
            var player = BasePlayer.FindByID(userId);
            ChangeBalance(player, "remove", Amount);

            if (player != null)
            {
                SendReply(player, $"У Вас списано {Amount} рублей с игрового баланса");
            }
            return true;
        }

        private object GetBalance(ulong userId)
        {
            if (!data.PlayerBalance.ContainsKey(userId))
                data.PlayerBalance.Add(userId, new PlayersBalances()
                {
                    Name = "Добавлен по API",
                    Balances = 0,
                    Time = 0
                });
            return data.PlayerBalance[userId].Balances;
        }
        #endregion

        #region Permissions

        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();

            public static bool HasPermission(BasePlayer player, string permissionName)
            {
                if (player == null || string.IsNullOrEmpty(permissionName))
                    return false;

                var uid = player.UserIDString;
                if (permission.UserHasPermission(uid, permissionName))
                    return true;

                return false;
            }

            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");

                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        #endregion

        #region Messages

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"TITLE", "ИГРОВОЙ МАГАЗИН topplugin.ru" },
            {"ERROR", "Администрация допустила ошибку! Предмет не был куплен!" },
            {"BUY", "Вы успешно приобрели предмет: {0} [{1}x]" },
            {"FULLINV", "У вас недостаточно места в инвентаре, освободите место!" },
            {"NOMONEY", "У вас недостаточно бонусов на балансе!" },
            {"MONEYADD", "Вам начислено {0} рублей на внутриигровой баланс магазина\nПроверка и использование баланса /shop" },
            {"MONEYREMOVE", "C Вашего баланса внутриигрового магазина списано {0} рублей" }
        };
        #endregion
    }
}
                                             

// --- End of file: RustShop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RecoilRecorder.cs ---
// --- Original Local Path: RecoilRecorder.cs ---


/*
 ########### README ####################################################
 #                                                                     #
 #   1. If you found a bug, please report them to developer!           #
 #   2. Don't edit that file (edit files only in CONFIG/LANG/DATA)     #
 #                                                                     #
 ########### CONTACT INFORMATION #######################################
 #                                                                     #
 #   Website: https://rustworkshop.space/                              #
 #   Discord: Orange#0900                                              #
 #   Email: official.rustworkshop@gmail.com                            #
 #                                                                     #
 #######################################################################
*/

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    // Creation date: 09-11-2020
    // Last update date: 20-02-2021
    [Info("Recoil Recorder", "Orange", "1.1.6")]
    [Description("https://rustworkshop.space/resources/recoil-recorder.247/")]
    public class RecoilRecorder : RustPlugin
    {
        #region Vars

        //Default hit symbol = U+25CF
        private const string hookOnRecorded = "OnRecoilRecorded"; // BasePlayer player, int[] shots, int[] pattern
        private const int border = 135;
        private static Dictionary<string, int[]> patternsList = new Dictionary<string, int[]>();
        private const string urlPatterns = "https://api.rustworkshop.space/Files/RecoilPatterns.json";
        private const float shootingCooldown = 3f;

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            BuildUI();

            if (config.activeZonesIdOrName.Length == 0)
            {
                Unsubscribe(nameof(OnEnterZone));
                Unsubscribe(nameof(OnExitZone));
            }
        }

        private void OnServerInitialized()
        {
            LoadPatterns();
            timer.Once(3f, CheckPlayers);
        }

        private void Unload()
        {
            foreach (var obj in UnityEngine.Object.FindObjectsOfType<ScriptRecorder>())
            {
                UnityEngine.Object.Destroy(obj);
            }
        }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            var obj = player.GetComponent<ScriptRecorder>();
            if (obj == null)
            {
                obj = player.gameObject.AddComponent<ScriptRecorder>();
            }
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectiles)
        {
            var obj = player.GetComponent<ScriptRecorder>();
            if (obj != null)
            {
                obj.OnFired(projectile);
            }
        }
        
        private void OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {
            var obj = player.GetComponent<ScriptRecorder>();
            if (obj != null)
            {
                obj.OnReloaded();
            }
        }

        private void OnEnterZone(string ZoneID, BasePlayer player)
        {
            if (Match(ZoneID))
            {
                var obj = player.GetComponent<ScriptRecorder>();
                if (obj != null)
                {
                    obj.Enable();
                }
            }
        }

        private void OnExitZone(string ZoneID, BasePlayer player)
        {
            if (Match(ZoneID))
            {
                var obj = player.GetComponent<ScriptRecorder>();
                if (obj != null)
                {
                    obj.Disable();
                }
            }
        }

        #endregion
        
        #region Core

        private void CheckPlayers()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }

            if (config.activeZonesIdOrName.Length > 0)
            {
                var players = new List<BasePlayer>();
                foreach (var value in config.activeZonesIdOrName)
                {
                    var members = Zone.GetPlayersInZone(value);
                    if (members != null)
                    {
                        foreach (var member in members)
                        {
                            if (players.Contains(member) == false)
                            {
                                players.Add(member);
                            }
                        }
                    }
                }

                foreach (var player in players.Distinct())
                {
                    if (player.IsValid() == true)
                    {
                        var obj = player.GetComponent<ScriptRecorder>();
                        if (obj != null)
                        {
                            obj.Enable();
                        }
                    }
                }
            }
        }

        private bool Match(string zoneId)
        {
            var name = Zone.GetName(zoneId)?.ToLower();
            var id = zoneId.ToLower();
            return config.activeZonesIdOrName.Any(x => x.ToLower() == name || x.ToLower() == id);
        }

        private void LoadPatterns() 
        {
            webrequest.Enqueue(urlPatterns, "", (i, s) =>
            {
                try
                {
                    var dic = JsonConvert.DeserializeObject<Dictionary<string, int[]>>(s);
                    patternsList = dic;
                    Puts($"Loaded x{patternsList.Count} weapon patterns");
                }
                catch (Exception e)
                {
                    patternsList = new Dictionary<string, int[]>
                {
                    {
                        "ak47u.entity", new[]
                        {
                            0,
                            12,
                            12,
                            27,
                            51,
                            51,
                            44,
                            33,
                            17,
                            2,
                            -16,
                            -32,
                            -44,
                            -51,
                            -51,
                            -45,
                            -36,
                            -19,
                            -6,
                            17,
                            32,
                            52,
                            66,
                            75,
                            80,
                            75,
                            62,
                            42,
                            25,
                            6,
                        }
                    },
                    {
                        "lr300.entity", new[]
                        {
                            0,
                            1,
                            3,
                            8,
                            12,
                            20,
                            25,
                            29,
                            30,
                            26,
                            20,
                            11,
                            4,
                            0,
                            0,
                            3,
                            6,
                            11,
                            17,
                            23,
                            29,
                            35,
                            40,
                            45,
                            48,
                            49,
                            44,
                            32,
                            17,
                            5
                        }
                    }
                };
                
                PrintError("Failed to load weapon patterns from website! Using x2 default patterns...");
                }
            }, this);
        }

        #endregion

        #region Graphical Interface

        private const string elemMain = "recoil.main";
        private const string elemPattern = "recoil.pattern";
        private static string jsonMain;
        private const int startY = -50;
        private const int offsetY = -6;
        private const int sizePanel = 250;

        private void BuildUI()
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = elemMain,
                Components = 
                {
                    new CuiImageComponent
                    {
                        Color = "0.5 0.5 0.5 0.7",
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = config.uiPositionAnchor,
                        AnchorMax = config.uiPositionAnchor,
                        OffsetMin = $"-{sizePanel} -{sizePanel}",
                        OffsetMax = "0 0"
                    }
                }
            });

            container.Add(new CuiElement
            {
                Parent = elemMain,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = config.textHeader.Replace("{version}", Version.ToString()),
                        Align = TextAnchor.UpperCenter,
                        FontSize = 15,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 0.95",
                    }
                }
            });

            jsonMain = container.ToString();
        }

        private static void ShowPattern(BasePlayer player, int[] pattern)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Parent = elemMain,
                Name = elemPattern,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0",
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });

            if (pattern != null)
            {
                for (var i = pattern.Length; i > 0; i--)
                {
                    var value = -pattern[i - 1]; 
                    var x = sizePanel / 2 + value;
                    var y = i * offsetY + startY;
                
                    if (x < 0 || x > sizePanel)
                    {
                        continue;
                    }
                    
                    if (Math.Abs(y) > sizePanel + offsetY)
                    {
                        continue;
                    }
                
                    container.Add(new CuiElement
                    {
                        Parent = elemPattern,
                        Components =
                        { 
                            new CuiTextComponent
                            {
                                Color = "1 1 1 1",
                                Text = config.hitSymbol,
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 10,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = $"{x - 15} {y - 15}",
                                OffsetMax = $"{x + 15} {y + 15}"
                            }
                        }
                    });
                }
            }

            CuiHelper.DestroyUi(player, elemPattern);
            CuiHelper.AddUi(player, container);
        }
        
        private static void ShowShot(BasePlayer player, int shotValue, int shotCount, bool hit)
        {
            var container = new CuiElementContainer();
            var x = sizePanel / 2 + shotValue;
            var y = shotCount * offsetY + startY;

            if (x < 0 || x > sizePanel)
            {
                return;
            }

            if (Math.Abs(y) > sizePanel + offsetY)
            {
                return;
            }
            
            container.Add(new CuiElement
            {
                Parent = elemPattern,
                Components =
                { 
                    new CuiTextComponent
                    {
                        Color = hit ? "0 1 0 1" : "1 0 0 1",
                        Text = config.hitSymbol,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 10,
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1",
                        AnchorMax = "0 1",
                        OffsetMin = $"{x - 15} {y - 15}",
                        OffsetMax = $"{x + 15} {y + 15}"
                    }
                }
            });

            CuiHelper.AddUi(player, container);
        }

        #endregion 
        
        #region Classes
 
        private static ConfigDefinition config = new ConfigDefinition();

        private class ConfigDefinition
        {
            [JsonProperty("Active zones (name or id)")]
            public string[] activeZonesIdOrName =
            {
                "test1",
                "zone2",
                "orange#1",
                "94402235",
            };

            [JsonProperty("Hit Symbol")]
            public string hitSymbol = "●";

            [JsonProperty("Header text")]
            public string textHeader = "Recoil Recorder v{version}";
            
            [JsonProperty("Maximal distance between shots to count hit")]
            public int hitMaxDistance = 10;
            
            [JsonProperty("UI Position (Anchor)")]
            public string uiPositionAnchor = "1 1";
        }

        #endregion

        #region Script Recorder

        private class ScriptRecorder : MonoBehaviour
        {
            private List<int> shots = new List<int>();
            private BaseProjectile lastWeapon;
            private BasePlayer player;
            private float firstShot = 0;
            private float lastShootTime;
            private bool showUi = false;
            
            public int[] Pattern = {};
            public int[] Shots => shots.ToArray();
            private BasePlayer[] spectators => player.children.Where(x => x != null && x is BasePlayer).Select(x => x as BasePlayer).ToArray();

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }

            private void Start()
            {
                player.ConsoleMessage($"[{nameof(RecoilRecorder)}] Loaded plugin by Orange");
                InvokeRepeating(nameof(CheckConnection), 60, 60);
            }

            public void Enable()
            {
                CuiHelper.DestroyUi(player, elemMain);
                CuiHelper.AddUi(player, jsonMain);
                showUi = true;
            }

            public void Disable()
            {
                showUi = false;
                CuiHelper.DestroyUi(player, elemMain);
            }

            private void OnDestroy()
            { 
               Disable();
            }

            public void OnFired(BaseProjectile weapon)
            {
                CheckWeapon(weapon);
                AddValue();

                var didHit = false;
                var index = shots.Count - 1;
                var shotX = shots[index];

                if (Pattern == null || Pattern.Length < shots.Count)
                {
                    return;
                }
                
                var patternX = -Pattern[index];
                    
                if (Math.Abs(shotX) < config.hitMaxDistance)
                {
                    shotX = patternX;
                    didHit = true;
                }

                lastShootTime = Time.realtimeSinceStartup;

                if (showUi)
                {
                    ShowShot(player, shotX, index, didHit);
                }
                   
                foreach (var spectator in spectators)
                {
                    ShowShot(spectator, shotX, index, didHit);
                }
            }
            
            public void OnReloaded()
            {
                Interface.Call(hookOnRecorded, player, Shots, Pattern);
                ClearShots();
            }

            private void AddValue()
            {
                var current = player.eyes.rotation.eulerAngles.y;
                var value = 0f;
                if (shots.Count == 0)
                {
                    firstShot = current;
                    shots.Add(0);
                    return;
                }

                if (firstShot > border)
                {
                    if (current < border)
                    {
                        value = 360 - firstShot + current;
                    }
                    else
                    {
                        value = current - firstShot;
                    }
                }
                else
                {
                    if (current > border)
                    {
                        value = -(360 - current);
                    }
                    else
                    {
                        value = current - firstShot;
                    }
                }
                value *= 10;
                shots.Add(Convert.ToInt32(value));
            }

            private void CheckWeapon(BaseProjectile weapon)
            {
                if (lastWeapon != weapon)
                { 
                    player.ConsoleMessage($"[{nameof(RecoilRecorder)}] Weapon was changed to {weapon.ShortPrefabName}");
                    lastWeapon = weapon;
                     
                    if (patternsList.TryGetValue(weapon.ShortPrefabName, out Pattern) == false)
                    {
                        Pattern = new int[]{};
                    }
                    
                    ClearShots();
                    return;
                }
                
                if (weapon != null && shots.Count >= weapon.primaryMagazine.capacity)
                {
                    ClearShots();
                    return;
                }

                if (Time.realtimeSinceStartup > lastShootTime + shootingCooldown)
                {
                    ClearShots();
                }
            }

            private void ClearShots()
            {
                player.ConsoleMessage($"[{nameof(RecoilRecorder)}] Clearing shots");
                shots.Clear();

                if (showUi)
                {
                    ShowPattern(player, Pattern);
                }

                foreach (var spectator in spectators)
                {
                    CuiHelper.DestroyUi(spectator, elemMain);
                    CuiHelper.AddUi(spectator, jsonMain);
                    ShowPattern(spectator, Pattern);
                }
            }

            private void CheckConnection()
            {
                if (player.IsConnected == false)
                {
                    Destroy(this);
                }
            }
        }

        #endregion

        #region Configuration v2.1

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigDefinition>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }
                
                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (Interface.Oxide.CallHook("OnConfigValidate") != null)
            {
                PrintWarning("Using default configuration...");
                config = new ConfigDefinition();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigDefinition();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
        
        #region Zone Manager Helper 1.0.0

        private class Zone 
        {
            private static Oxide.Core.Libraries.Plugins plugins;
            private const string filename = "ZoneManager";
            private static Plugin plugin;

            public static void Unload()
            {
                plugin = null;
                plugins = null;
            }

            public static string GetName(string id)
            {
                return Call("GetZoneName", id) as string;
            }

            public static Vector3? GetLocation(string id)
            {
                return Call("GetZoneLocation", id) as Vector3?;
            }

            public static string[] GetAllZones()
            {
                return Call("GetZoneIDs") as string[];
            }

            public static List<BasePlayer> GetPlayersInZone(string id)
            {
                return Call("GetPlayersInZone", id) as List<BasePlayer>;
            }

            public static bool IsInside(string id, BasePlayer player)
            {
                return (bool) Call("IsPlayerInZone", id, player);
            }

            private static object Call(string name, params object[] args)
            {
                if (plugin == null)
                {
                    FindPlugin();
                    
                    if (plugin == null)
                    {
                        return null;
                    }
                }

                return plugin.Call(name, args);
            }

            private static void FindPlugin()
            {
                if (plugins == null)
                {
                    plugins = Interface.Oxide.GetLibrary<Oxide.Core.Libraries.Plugins>();
                }

                if (plugins != null)
                {
                    plugin = plugins.GetAll().FirstOrDefault(x => x.Name == filename);
                }
            }
        }

        #endregion
    }
}


// --- End of file: RecoilRecorder.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RandomWarps.cs ---
// --- Original Local Path: RandomWarps.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Random Warps", "LaserHydra", "1.1.2", ResourceId = 1397)]
    [Description("Teleports you to a random location of a multi-location warp")]
    class RandomWarps : RustPlugin
    {
        string pluginColor = "#00FF8D";

        ////////////////////////////////////////////
        ///     Data Handling
        ////////////////////////////////////////////
        class Data
        {
            public Dictionary<string, List<Dictionary<char, float>>> warps = new Dictionary<string, List<Dictionary<char, float>>>();

            public Data()
            {
            }
        }

        Data data;

        void LoadData()
        {
            data = Interface.GetMod().DataFileSystem.ReadObject<Data>("RandomWarps_Data");
        }

        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("RandomWarps_Data", data);
        }

        ////////////////////////////////////////////
        ///     Get Random Position
        ////////////////////////////////////////////

        Vector3 GetRandom(List<Dictionary<char, float>> warpPositions)
        {
            int random = UnityEngine.Random.Range(0, warpPositions.Count - 1);
            Dictionary<char, float> pos = warpPositions[random];

            return new Vector3(pos['x'], pos['y'], pos['z']);
        }

        ////////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////////

        void Loaded()
        {
            if (!permission.PermissionExists("rwarp.admin")) permission.RegisterPermission("rwarp.admin", this);

            LoadData();
            LoadConfig();
        }

        ////////////////////////////////////////////
        ///     Config Handling
        ////////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Settings", "Time until teleport", 20);

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Generating new configfile...");
        }

        ////////////////////////////////////////////
        ///     Chat Command
        ////////////////////////////////////////////

        [ChatCommand("rwarp")]
        void rWarp(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length < 1)
            {
                if (data.warps.Keys.Count == 0)
                {
                    SendChatMessage(player, "rWarp", "There are no random warps set up!");
                    return;
                }

                SendChatMessage(player, "rWarp", "Warps:");

                foreach (string warp in data.warps.Keys)
                {
                    SendChatMessage(player, "/rwarp " + warp);
                }

                return;
            }

            if ((bool) (Oxide.Core.Interface.CallHook("IsPrisoner", player) ?? false))
            {
                SendChatMessage(player, "You may not teleport while in jail!");
                return;
            }

            if (args.Length == 1)
            {
                if (!data.warps.ContainsKey(args[0]))
                {
                    SendChatMessage(player, "rWarp", "Warp does not exist!");
                }
                else
                {
                    SendChatMessage(player, "rWarp", $"You will be teleported in {(int)Config["Settings", "Time until teleport"]} seconds");

                    timer.Once((int)Config["Settings", "Time until teleport"], () => {
                        Teleport(player, GetRandom(data.warps[args[0]]));
                        SendChatMessage(player, "rWarp", $"Teleported to random warp <color={pluginColor}>{args[0]}</color>");
                    });
                }

                return;
            }

            if (!IsAdmin(player)) return;

            string warpName = args[1];

            switch (args[0])
            {
                case "add":
                    if (args.Length != 2) return;
                    if (data.warps.ContainsKey(warpName))
                    {
                        Dictionary<char, float> position = new Dictionary<char, float>();
                        position.Add('x', player.transform.position.x);
                        position.Add('y', player.transform.position.y);
                        position.Add('z', player.transform.position.z);
                        data.warps[warpName].Add(position);
                        SendChatMessage(player, "rWarp", $"You have added a spot to warp <color={pluginColor}>{warpName}</color>");
                    }
                    else
                    {
                        List<Dictionary<char, float>> warpPositions = new List<Dictionary<char, float>>();
                        Dictionary<char, float> position = new Dictionary<char, float>();
                        position.Add('x', player.transform.position.x);
                        position.Add('y', player.transform.position.y);
                        position.Add('z', player.transform.position.z);

                        warpPositions.Add(position);

                        data.warps.Add(warpName, warpPositions);

                        SendChatMessage(player, "rWarp", $"You have added a spot to warp <color={pluginColor}>{warpName}</color>");
                    }

                    SaveData();

                    break;

                case "remove":
                    if (args.Length != 2) return;

                    if (data.warps.ContainsKey(warpName))
                    {
                        data.warps.Remove(warpName);
                        SendChatMessage(player, "rWarp", $"You have removed the random warp <color={pluginColor}>{warpName}</color>");
                    }
                    else
                        SendChatMessage(player, "rWarp", $"Could not remove random warp <color={pluginColor}>{warpName}</color>. Warp does not exist!");

                    SaveData();

                    break;

                default:
                    break;
            }
        }

        ////////////////////////////////////////////
        ///     Admin Check
        ////////////////////////////////////////////

        bool IsAdmin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "rwarp.admin")) return true;
            return false;
        }

        ////////////////////////////////////////////
        ///     Teleportation
        ////////////////////////////////////////////

        public void Teleport(BasePlayer player, Vector3 pos)
        {
            //  Thanks to mughisi's Teleportation plugin for this!
            player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);

            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
                    
            player.MovePosition(pos);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", pos, null, null, null, null);

            player.TransformChanged();
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();

            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
            player.SendFullSnapshot();
        }

        ////////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////////

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix)
        {
            var foundPlayers =
                (from player in BasePlayer.activePlayerList
                 where player.displayName.ToLower().Contains(searchedPlayer.ToLower())
                 select player.displayName).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(executer, prefix, "The Player can not be found.");
                    break;

                case 1:
                    return BasePlayer.Find(foundPlayers[0]);

                default:
                    string players = ListToString(foundPlayers, 0, ", ");
                    SendChatMessage(executer, prefix, "Multiple matching players found: \n" + players);
                    break;
            }

            return null;
        }

        ////////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////////
        ///     Config Setup
        ////////////////////////////////////////////

        void SetConfig(string Arg1, object Arg2, object Arg3 = null, object Arg4 = null)
        {
            if (Arg4 == null)
            {
                Config[Arg1, Arg2.ToString()] = Config[Arg1, Arg2.ToString()] ?? Arg3;
            }
            else if (Arg3 == null)
            {
                Config[Arg1] = Config[Arg1] ?? Arg2;
            }
            else
            {
                Config[Arg1, Arg2.ToString(), Arg3.ToString()] = Config[Arg1, Arg2.ToString(), Arg3.ToString()] ?? Arg4;
            }
        }

        ////////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : $"<color={pluginColor}>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : $"<color={pluginColor}>" + prefix + "</color>: " + msg);
    }
}

// --- End of file: RandomWarps.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Friendsbyfermens.cs ---
// --- Original Local Path: Friendsbyfermens.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using ProtoBuf;
using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("Friendsbyfermens", "fermens", "0.1.42")]
    [Description("Система друзей и FF")]
    class Friendsbyfermens : RustPlugin
    {
        #region Config
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Максимальное количество игроков в команде")]
            public int maxcount;

            [JsonProperty("Префикс")]
            public string prefix;

            [JsonProperty("Максимальное количество символов в теге команды")]
            public int max;

            [JsonProperty("Минимальное количество символов в теге команды")]
            public int min;

            [JsonProperty("Запрещенные названия в теге команде")]
            public string[] blacklist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    maxcount = 3,
                    prefix = "<color=#F65050>HUB RUST</color> ",
                    min = 2,
                    max = 4,
                    blacklist = new string[] { "MOD", "MODR", "ADMI", "ADM" },

                };
            }
        }
        #endregion
        [PluginReference] private Plugin OneVSOne, Battles;
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            if (entity is BasePlayer && info.Initiator is BasePlayer)
            {
                BasePlayer takeDamage = entity.ToPlayer();
                if (takeDamage == null) return;
                BasePlayer initiator = info.InitiatorPlayer;
                if (initiator == null || initiator == takeDamage || takeDamage.currentTeam == 0) return;
                settings one;
                if (takeDamage.currentTeam == initiator.currentTeam && setplayers.TryGetValue(initiator.userID, out one) && one.ff)
                {
                    if (OneVSOne != null && OneVSOne.Call<bool>("IsEventPlayer", takeDamage) || Battles != null && Battles.Call<bool>("IsPlayerOnBattle", takeDamage.userID)) return;
                    clear(info);
                }
            }
        }

        void clear(HitInfo info)
        {
            info.damageTypes = new DamageTypeList();
            info.HitEntity = null;
            info.HitMaterial = 0;
            info.PointStart = Vector3.zero;
        }

        Dictionary<SamSite, BuildingPrivlidge> samsites = new Dictionary<SamSite, BuildingPrivlidge>();
        private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity target)
        {
            if (target is BaseMountable || target is HotAirBalloon)
            {
                List<BasePlayer> players = new List<BasePlayer>();
                Vis.Entities(target.transform.position, 2.5f, players);
                if (players == null || players.Count == 0) return null;
                BuildingPrivlidge buildingPrivlidge;
                if (!samsites.TryGetValue(samSite, out buildingPrivlidge) || buildingPrivlidge.IsDestroyed)
                {
                    buildingPrivlidge = samSite.GetBuildingPrivilege();
                    if (buildingPrivlidge == null) return null;
                    samsites[samSite] = buildingPrivlidge;
                }

                if (players.Any(player => buildingPrivlidge.IsAuthed(player))) return false;
            }

            return null;
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
        {
            if (entity == null) return null;
            BasePlayer player = entity.ToPlayer();
            if (player == null) return null;
            if (turret.OwnerID == 0) return null;
            if (player.Team != null)
            {
                if(player.Team.members.Any(x=> turret.authorizedPlayers.Any(z => x == z.userid && setplayers.ContainsKey(x) && setplayers[x].turret)))
                {
                    turret.authorizedPlayers.Add(GetPlayerNameId(player));
                    turret.SendNetworkUpdate();
                    return false;
                }
            }
            return null;
        }

        private static PlayerNameID GetPlayerNameId(BasePlayer player)
        {
            var playerNameId = new PlayerNameID()
            {
                userid = player.userID,
                username = player.displayName
            };
            return playerNameId;
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (player == null || baseLock == null || baseLock.GetEntity() == null || !baseLock.IsLocked()) return null;
            ulong ownerID = baseLock.GetEntity().OwnerID;
            if (ownerID.Equals(0)) return null;
            if (player.Team != null && player.Team.members.Contains(ownerID) && setplayers.ContainsKey(ownerID) && setplayers[ownerID].codelock)
            {
                Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab", baseLock.transform.position);
                return true;
            }
            return null;
        }

        private void Save()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Friendsbyfermens", setplayers);
        }

        private void Unload()
        {
         /*   teams.Clear();
            foreach (var z in RelationshipManager.Instance.teams)
            {
                PLAYERTEAM pLAYERTEAM;
                if (!teams.TryGetValue(z.Key, out pLAYERTEAM))
                {
                    teams.Add(z.Key, new PLAYERTEAM { members = new List<ulong>() });
                    pLAYERTEAM = teams[z.Key];
                }
                pLAYERTEAM.teamLeader = z.Value.teamLeader;
                pLAYERTEAM.teamName = z.Value.teamName;
                pLAYERTEAM.members.AddRange(z.Value.members);
            }
            if(teams.Count > 0) Interface.Oxide.DataFileSystem.WriteObject("teams", teams);*/
            Save();
        }

        private void initializeset(ulong id)
        {
            if (!setplayers.ContainsKey(id)) setplayers.Add(id, new settings());
        }

        private static Dictionary<ulong, PLAYERTEAM> teams = new Dictionary<ulong, PLAYERTEAM>();

        class PLAYERTEAM
        {
            public string teamName;
            public ulong teamLeader;
            public List<ulong> members;
        }

        private void OnServerInitialized()
        {
          /*  Debug.LogError("Конец халявы, ищи альтернативу!");
            Server.Command("o.unload Friendsbyfermens");
            return;
            */
            if(config.blacklist == null)
            {
                config.blacklist = new string[] { "MOD", "MODR", "ADMI", "ADM" };
                config.max = 4;
                config.min = 2;
                SaveConfig();
            }
            setplayers = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, settings>>("Friendsbyfermens");
            foreach (var z in BasePlayer.activePlayerList) initializeset(z.userID);
            RelationshipManager.maxTeamSize = config.maxcount;
            var com = Interface.Oxide.GetLibrary<ru.Libraries.Command>(null);
            com.AddChatCommand("friend", this, "COMMANDER");
            com.AddChatCommand("team", this, "COMMANDER");
            com.AddConsoleCommand("friend", this, "CmdConsolecommandinvite");
            com.AddConsoleCommand("team", this, "CmdConsolecommandinvite");
            
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!player.IsConnected) return;

            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }

            initializeset(player.userID);
        }

        Dictionary<ulong, settings> setplayers = new Dictionary<ulong, settings>();
        class settings
        {
            public bool ff = true;
            public bool turret = true;
            public bool codelock = true;
        }

        void CmdConsolecommandinvite(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || !arg.HasArgs()) return;
            COMMANDER(player, "friend", arg.Args);
        }

        private void COMMANDER(BasePlayer player, string command, string[] args)
        {
            if (string.IsNullOrEmpty(command)) command = "friend";
            settings settings;
            if (!setplayers.TryGetValue(player.userID, out settings))
            {
                setplayers.Add(player.userID, new settings());
                settings = setplayers[player.userID];
            }
            if (args != null && args.Length > 0)
            {
                if(args.Length == 2)
                {
                    if (args[0] == "invite")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "Создайте сначала команду!");
                            return;
                        }
                        if (!player.Team.teamLeader.Equals(player.userID))
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "Только лидер команды может приглашать в команду!");
                            return;
                        }
                        var listplayers = BasePlayer.activePlayerList.Where(z => z.displayName.Contains(args[1]));
                        int countfiend = listplayers.Count();
                        if (countfiend == 1)
                        {
                            BasePlayer friend = listplayers.FirstOrDefault();
                            if (friend.Team != null)
                            {
                                player.Command("chat.add", 2, 0, config.prefix + $"Игрок <color=#F65050>'{friend.displayName}'</color> уже состоит в другой команде.");
                                return;
                            }
                            player.Team.SendInvite(friend);
                            player.Command("chat.add", 2, 0, config.prefix + $"Игроку <color=#F65050>'{friend.displayName}'</color> отправлено приглашение в команду.");
                        }
                        else if (countfiend.Equals(0))
                        {
                            player.Command("chat.add", 2, 0, config.prefix + $"Игрок <color=#F65050>'{args[1]}'</color> не найден.");
                            return;
                        }
                        else
                        {
                            player.Command("chat.add", 2, 0, config.prefix + $"Найдено несколько игроков: <color=#F65050>{string.Join(" ", listplayers.Select(p => p.displayName).ToArray())}</color>");
                            return;
                        }
                    }
                    else if(args[0] == "name")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас нет команды!");
                            return;
                        }

                        if (player.Team.teamLeader != player.userID)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "Только лидер команды может менять тим <color=#F65050>ТЕГ</color>");
                            return;
                        }

                        if (args[1].Length < config.min || args[1].Length > config.max)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + $"Название должно состоять от 2-х до 4-х символов!\nПример: /{command} name Just");
                            return;
                        }
                        string name = args[1].ToUpper();
                        if (config.blacklist.Contains(name) || RelationshipManager.ServerInstance.teams.Any(x => !string.IsNullOrEmpty(x.Value.teamName) && x.Value.teamName == name))
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "Этот тим <color=#F65050>ТЕГ</color> уже занят!");
                            return;
                        }

                        player.Team.teamName = name;
                        List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                        string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> изменил тим <color=#F65050>ТЕГ</color> на <color=#F65050>{name}</color>";
                        ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                    }
                }
                else if(args.Length == 1)
                {
                    if(args[0] == "create")
                    {
                        if (player.Team != null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас уже есть команда!");
                            return;
                        }
                        player.Command("relationshipmanager.trycreateteam");
                    }
                    else if(args[0] == "ff")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас нет команды!");
                            return;
                        }
                        /*  if (!player.Team.teamLeader.Equals(player.userID))
                          {
                              player.Command("chat.add", 2, 0, config.prefix + "Только лидер команды может менять этот параметр!");
                              return;
                          }*/
                        if (settings.ff)
                        {
                            settings.ff = false;
                            foreach (var z in player.Team.members)
                            {
                                BasePlayer gg = BasePlayer.FindByID(z);
                                if (player == null) continue;
                                gg.Command("chat.add", 2, 0, config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> включил урон по тиммейтам!");
                            }
                        }
                        else
                        {
                            settings.ff = true;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> выключил урон по тиммейтам.";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                    }
                    else if (args[0] == "codelock")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас нет команды!");
                            return;
                        }
                        if (settings.codelock)
                        {
                            settings.codelock = false;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> запретил пользоваться его замками!";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                        else
                        {
                            settings.codelock = true;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> разрешил пользоваться его замками.";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                    }
                    else if (args[0] == "turret")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас нет команды!");
                            return;
                        }
                        if (settings.turret)
                        {
                            settings.turret = false;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> отключил автоматическую авторизацию в его турелях!";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                        else
                        {
                            settings.turret = true;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Теперь туррели игрока <color=#F65050>{player.displayName}</color> для вас безобидны.";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                    }
                }
                
            }
            else
            {
                if (player.Team == null) player.Command("chat.add", 2, 0, config.prefix + $"Создайте сначала команду!\n             <color=#F65050>/{command} create</color> - создать команду.");
                else player.Command("chat.add", 2, 0, config.prefix + $"\n\n     <color=#F65050>/{command} name</color> <color=#F65050><ТЕГ></color> - изменить тим <color=#F65050>ТЕГ</color>.\n      <color=#F65050>/{command} invite</color> <color=#F65050>никнейм</color> - пригласить в команду \n {onoff(settings.codelock)} <color=#F65050>/{command} codelock</color> - разрешить тиммейтам пользоваться вашими замками.\n {onoff(setplayers[player.userID].turret)} <color=#F65050>/{command} turret</color> - авторизовывать тиммейтов в ваших туреллях, когда они на них агряться.\n {onoff(setplayers[player.userID].ff)} <color=#F65050>/{command} ff</color> - выключить урон по тиммейтам.");
            }
        }

        private bool IsPvp(ulong id)
        {
            settings settings;
            if (!setplayers.TryGetValue(id, out settings)) return true;
            return settings.ff;
        }

        private bool IsTurret(ulong id)
        {
            settings settings;
            if (!setplayers.TryGetValue(id, out settings)) return true;
            return settings.turret;
        }

        private bool IsCodelock(ulong id)
        {
            settings settings;
            if (!setplayers.TryGetValue(id, out settings)) return true;
            return settings.codelock;
        }

        string onoff(bool on)
        {
            if (on) return "<color=#29F500> - On -</color>";
            else return "<color=#FF0B00>- Off -</color>";
        }
    }
}

// --- End of file: Friendsbyfermens.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Stats.cs ---
// --- Original Local Path: Stats.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stats", "Я и Я", "1.0.0")]
    public class Stats : RustPlugin
    {
        #region Fields

        private string Layer = "UI_Stats";
        private const int Count = 9;

        private readonly string[] _statsName = { "Убийств", "Смертей", "Коэффициент", "Выстрелов сделано", "Попаданий", "Попаданий в голову", "Коэффицент попаданий в голову", "Коэффицент попаданий", "Добыто ресурсов" };

        private Dictionary<string, string> tops = new Dictionary<string, string>()
        {
            {"Убийств", "Убийцы"},
            {"Смертей", "Суицидники"},
            {"Добычи", "Добытчики"},
            {"Выстрелов", "Стрелки"},
            {"Попаданий в голову", "Хедшотеры"},
            {"Попаданий", "Стрелки"},
            {"в голову", "Хедшотеры"},
            {"попаданий", "Стрелки"}
        };
       
        #endregion

        #region Commands

        private void chatCmdStats(BasePlayer player, string command, string[] args)
        {
            ShowStatistic(player, player.userID);
        }

        private void consoleCmdStats(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (player == null) return;

            switch (arg.GetString(0))
            {
                case "close":
                {
                    CuiHelper.DestroyUi(player, Layer);
                    break;
                }
            }
        }
 
        #endregion
        
        #region Hooks
        
        void OnServerInitialized()
        {
            LoadData();
            
            SaveData();
            
            cmd.AddChatCommand("stats", this, "chatCmdStats");
            //cmd.AddChatCommand("top", this, "chatCmdTop");
            //cmd.AddConsoleCommand("UI_Stats", this, "consoleCmdStats");
            
            foreach (var p in BasePlayer.activePlayerList) OnPlayerConnected(p);
            AddImage("https://i.ibb.co/3dkM0SX/frame.png","St_frame_img");
            AddImage("https://i.ibb.co/ykW7XrG/exit.png","Stat_exit_img");
        }

        object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (player == null) return true;

            if (storedData.ContainsKey(player.userID)) storedData[player.userID][StatsType.Gather] += item.amount;

            return null;
        }
        
        object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            var player = entity.ToPlayer();

            if (player == null) return true;

            if (storedData.ContainsKey(player.userID)) storedData[player.userID][StatsType.Gather] += item.amount;

            return null;
        }
        
        object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (info == null) return null;
            if (player == null) return null;
            if (player.IsNpc) return null;
            if (info.InitiatorPlayer == null) return null; 
            if (info.InitiatorPlayer.IsNpc) return null;
            
            if (info.InitiatorPlayer != null)
            {
                var killer = info.InitiatorPlayer;

                if (killer != player) 
                { 
                    if (storedData.ContainsKey(killer.userID)) storedData[killer.userID][StatsType.Kill]++;
                }
                if(storedData.ContainsKey(player.userID)) storedData[player.userID][StatsType.Death]++;
            }
             
            return null; 
        }
        
        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            if(storedData.ContainsKey(player.userID)) storedData[player.userID][StatsType.Shot]++;
        }
        
        void OnPlayerConnected(BasePlayer player)
        {
            if(!storedData.ContainsKey(player.userID))
                storedData.Add(player.userID, new Dictionary<StatsType, int>
                {
                    {StatsType.Kill, 0},
                    {StatsType.Death, 0},
                    {StatsType.Shot, 0},
                    {StatsType.Hit, 0},
                    {StatsType.HitHead, 0},
                    {StatsType.Gather, 0}
                });
        }
        
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BasePlayer)
            {
                var attacker = info.InitiatorPlayer;  
                
                if (attacker != null)
                {
                    if (!attacker.IsNpc)
                    {
                        if (info.isHeadshot)
                        {
                            storedData[attacker.userID][StatsType.HitHead]++;
                        }
                        storedData[attacker.userID][StatsType.Hit]++;
                    }
                    else return null; 
                }
            }
            
            return null;
        }
        
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
            
            SaveData();
        }

        #endregion

        #region Methods

        [HookMethod("ApiGetName")]
        public string ApiGetName(ulong steamID)
        {
            return covalence.Players.FindPlayerById(steamID.ToString())?.Name ?? "UNKNOWN";
        }

        private void ShowStatistic(BasePlayer player, ulong userID)
        {
            var statPlayer = storedData[userID];
            var name = covalence.Players.FindPlayerById(userID.ToString())?.Name.Replace('"', ' ') ?? player.UserIDString;
            if (name.Length > 16) name = name.Substring(0, 16) + "..";

            var container = new CuiElementContainer();

            CuiHelper.DestroyUi(player, Layer);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image =
                    {
                        FadeIn = 0.2f,
                        Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                        Color = "0 0 0 1"
                    }
            }, "Overlay", Layer);
            container.Add(new CuiPanel
            {
                Image =
                    {
                        FadeIn = 0.2f,
                        Color = "0.2 0.2 0.17 0.7",
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    }
            }, Layer);

            container.Add(new CuiLabel
            {
                Text = { Text = "СТАТИСТИКА", Align = TextAnchor.UpperCenter, FontSize = 40, Font = "robotocondensed-bold.ttf" },
                RectTransform = { AnchorMin = "0.3 1", AnchorMax = "0.7 1", OffsetMin = "0 -150", OffsetMax = "0 -86.6" }
            }, Layer);
            container.Add(new CuiLabel
            {
                Text = { Text = "Тут можно посмотреть статистику игрока", Align = TextAnchor.UpperCenter, FontSize = 18, Font = "robotocondensed-regular.ttf" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -150", OffsetMax = "0 -128" }
            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                    {
                        GetImageComponent("https://i.ibb.co/ykW7XrG/exit.png","Stat_exit_img"),
                        new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-73.9 20", OffsetMax = "-28.6 80"},
                    }
            });
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                    {
                        new CuiImageComponent {Color = "0.33 0.87 0.59 0.6"},
                        new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 25.2"}
                    }
            });
            
            container.Add(new CuiButton
            {
                Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_Stats close",
                            Close = Layer
                        },
                Text = { Text = "Покинуть страницу", Align = TextAnchor.UpperCenter, FontSize = 18 },
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 49.2" },
            }, Layer);
            container.Add(new CuiButton
            {
                Button =
                {
                    Color = "0 0 0 0",
                    Command = "UI_Stats close",
                    Close = Layer
                },
                Text = { Text = "" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
            }, Layer);

            container.Add(new CuiPanel
            {
                Image = null,
                RawImage = GetAvatarImageComponent(userID),
                RectTransform = {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-395.3 -96", OffsetMax = "-155.3 144"}
            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    GetImageComponent("https://i.ibb.co/3dkM0SX/frame.png","St_frame_img", "0.33 0.87 0.59 0.3"),
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-395.3 -143.9",
                        OffsetMax = "-155.3 -100.6"
                    }
                }
            });

            container.Add(new CuiLabel
            {
                Text = { Text = name, Align = TextAnchor.MiddleCenter, FontSize = 26, Font = "robotocondensed-bold.ttf" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-395.3 -143.9", OffsetMax = "-155.3 -100.6" }
            }, Layer);

            var stats = new[]
            {
                statPlayer[StatsType.Kill].ToString(), statPlayer[StatsType.Death].ToString(),
                statPlayer[StatsType.Death]==0?"0":(statPlayer[StatsType.Kill] / (float) statPlayer[StatsType.Death]).ToString("N2"),
                statPlayer[StatsType.Shot].ToString(), statPlayer[StatsType.Hit].ToString(),
                statPlayer[StatsType.HitHead].ToString(),
                statPlayer[StatsType.Shot]==0?"0":(statPlayer[StatsType.Hit] / (float) statPlayer[StatsType.Shot]).ToString("N2"),
                statPlayer[StatsType.Shot]==0?"0":(statPlayer[StatsType.HitHead] / (float) statPlayer[StatsType.Shot]).ToString("N2"),
                statPlayer[StatsType.Gather].ToString()
            };
            var posY = 144f;
            var sizeY = 32f;

            for (var i = 0; i < 9; i++)
            {
                container.Add(new CuiElement
                {
                    Name = Layer + $".Stats{i}",
                    Parent = Layer,
                    Components =
                    {
                        new CuiImageComponent {Color = ((i + 2) % 2 == 0 ? "0.33 0.87 0.59 0.6" : "0 0 0 0")},
                        new CuiRectTransformComponent {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-146 {posY - sizeY}", OffsetMax = $"394.6 {posY}"}
                    }
                });
                container.Add(new CuiLabel
                {
                    Text = { Text = _statsName[i], Align = TextAnchor.MiddleLeft, FontSize = 24, Font = "robotocondensed-bold.ttf" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 0" }
                }, Layer + $".Stats{i}");
                container.Add(new CuiLabel
                {
                    Text = { Text = stats[i], Align = TextAnchor.MiddleRight, FontSize = 24, Font = "robotocondensed-bold.ttf" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-5 0" }
                }, Layer + $".Stats{i}");
                posY -= sizeY;
            }
            CuiHelper.AddUi(player, container);
        }
        
        private static string HexToRGB(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }
          
            var str = hex.Trim('#'); 
          
            if (str.Length == 6)
                str += "FF";
          
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
          
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
          
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }    

        #endregion

        #region Data

        private enum StatsType
        {
            Kill,
            Death,
            Shot,
            Hit,
            HitHead,
            Gather
        }

        void SaveData()
        {
            StatData.WriteObject(storedData);
        }

        void LoadData()
        {
            StatData = Interface.Oxide.DataFileSystem.GetFile("Stats/stats");
            try
            {
                storedData = StatData.ReadObject<Dictionary<ulong, Dictionary<StatsType, int>>>();
            }
            catch
            {
                storedData = new Dictionary<ulong, Dictionary<StatsType, int>>();
            } 
        }

        Dictionary<ulong, Dictionary<StatsType, int>> storedData;
        private DynamicConfigFile StatData;

        #endregion

		public CuiRawImageComponent GetAvatarImageComponent(ulong user_id, string color = "1.0 1.0 1.0 1.0"){
			
			if (plugins.Find("ImageLoader")) return plugins.Find("ImageLoader").Call("BuildAvatarImageComponent",user_id) as CuiRawImageComponent;
			if (plugins.Find("ImageLibrary")) {
				return new CuiRawImageComponent { Png = (string)plugins.Find("ImageLibrary").Call("GetImage", user_id.ToString()), Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga" };
			}
			return new CuiRawImageComponent {Url = "https://image.flaticon.com/icons/png/512/37/37943.png", Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
		}
		public CuiRawImageComponent GetImageComponent(string url, string shortName="", string color = "1.0 1.0 1.0 1.0"){
			
			if (plugins.Find("ImageLoader")) return plugins.Find("ImageLoader").Call("BuildImageComponent",url) as CuiRawImageComponent;
			if (plugins.Find("ImageLibrary")) {
				if (!string.IsNullOrEmpty(shortName)) url = shortName;
				return new CuiRawImageComponent { Png = (string)plugins.Find("ImageLibrary").Call("GetImage", url), Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga" };
			}
			return new CuiRawImageComponent {Url = url, Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
		}
		
		public CuiRawImageComponent GetItemImageComponent(string shortName){
			string itemUrl = shortName;
			if (plugins.Find("ImageLoader")) {itemUrl = $"https://static.moscow.ovh/images/games/rust/icons/{shortName}.png";}
            return GetImageComponent(itemUrl);
		}
		public bool AddImage(string url,string shortName=""){
			if (plugins.Find("ImageLoader")){				
				plugins.Find("ImageLoader").Call("CheckCachedOrCache", url);
				return true;
			}else
			if (plugins.Find("ImageLibrary")){
				if (string.IsNullOrEmpty(shortName)) shortName=url;
				plugins.Find("ImageLibrary").Call("AddImage", url, shortName);
				return true;
			}	
			return false;		
		}
    }
}

// --- End of file: Stats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HumanNPC.cs ---
// --- Original Local Path: HumanNPC.cs ---

//#define DEBUG
// Requires: PathFinding
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Rust;
using Facepunch;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using Convert = System.Convert;

namespace Oxide.Plugins
{
    [Info("HumanNPC", "Reneb/Nogrod/Calytic FIX BY HUZAKI", "0.3.48", ResourceId = 856)]
    [Description("Adds interactive Human NPCs which can be modded by other plugins")]
    public class HumanNPC : RustPlugin
    {
        //////////////////////////////////////////////////////
        ///  Fields
        //////////////////////////////////////////////////////
        private static Collider[] colBuffer;
        private int playerLayer;
        private static int targetLayer;
        private static Vector3 Vector3Down;
        private static int groundLayer;

        private Hash<ulong, HumanNPCInfo> humannpcs = new Hash<ulong, HumanNPCInfo>();

        static int playerMask = LayerMask.GetMask("Player (Server)");
        static int obstructionMask = LayerMask.GetMask(new[] { "Player (Server)", "Construction", "Deployed", "Clutter" });

        private bool save;
        private StoredData storedData;
        private DynamicConfigFile data;
        private Vector3 eyesPosition;
        private string chat = "<color=#FA58AC>{0}:</color> ";

        [PluginReference]
        private Plugin Kits, Waypoints, Vanish;

        private static PathFinding PathFinding;

        private class StoredData
        {
            public HashSet<HumanNPCInfo> HumanNPCs = new HashSet<HumanNPCInfo>();
        }

        public class WaypointInfo
        {
            public float Speed;
            public Vector3 Position;

            public WaypointInfo(Vector3 position, float speed)
            {
                Speed = speed;
                Position = position;
            }
        }

        public static bool IsLayerBlocked(Vector3 position, float radius, int mask)
        {
            var colliders = Pool.GetList<Collider>();
            Vis.Colliders<Collider>(position, radius, colliders, mask, QueryTriggerInteraction.Collide);

            bool blocked = colliders.Count > 0;

            Pool.FreeList<Collider>(ref colliders);

            return blocked;
        }

        //////////////////////////////////////////////////////
        ///  class SpawnInfo
        ///  Spawn information, position & rotation
        ///  public => will be saved in the data file
        ///  non public => won't be saved in the data file
        //////////////////////////////////////////////////////
        public class SpawnInfo
        {
            public Vector3 position;
            public Quaternion rotation;

            public SpawnInfo(Vector3 position, Quaternion rotation)
            {
                this.position = position;
                this.rotation = rotation;
            }

            public string String()
            {
                return $"Pos{position} - Rot{rotation}";
            }
            public string ShortString()
            {
                return $"Pos({Math.Ceiling(position.x)},{Math.Ceiling(position.y)},{Math.Ceiling(position.z)})";
            }
        }

        //////////////////////////////////////////////////////
        ///  class HumanTrigger
        /// MonoBehaviour: managed by UnityEngine
        ///  This takes care of all collisions and area management of humanNPCs
        //////////////////////////////////////////////////////
        public class HumanTrigger : MonoBehaviour
        {
            private HumanPlayer npc;

            private readonly HashSet<BasePlayer> triggerPlayers = new HashSet<BasePlayer>();

            public float collisionRadius;

            private void Awake()
            {
                npc = GetComponent<HumanPlayer>();
                collisionRadius = npc.info.collisionRadius;
                InvokeRepeating("UpdateTriggerArea", 2f, 1.5f);
            }

            private void OnDestroy()
            {
#if DEBUG
                //Interface.Oxide.LogInfo("Destroy child: {0}", child?.name);
#endif
                CancelInvoke("UpdateTriggerArea");
            }

            private void UpdateTriggerArea()
            {
                var count = Physics.OverlapSphereNonAlloc(npc.player.transform.position, collisionRadius, colBuffer, targetLayer);
                var collidePlayers = new HashSet<BasePlayer>();
                for (int i = 0; i < count; i++)
                {
                    var collider = colBuffer[i];
                    colBuffer[i] = null;
                    var player = collider.GetComponentInParent<BasePlayer>();
                    if (player != null)
                    {
                        if (player == npc.player) continue;
                        collidePlayers.Add(player);
                        if (triggerPlayers.Add(player)) OnEnterCollision(player);
                        continue;
                    }
                    //temp fix
                    /*var ai = collider.GetComponentInParent<NPCAI>();
                    if (ai != null && ai.decider.hatesHumans)
                        npc.StartAttackingEntity(collider.GetComponentInParent<BaseNpc>());*/
                }

                var removePlayers = new HashSet<BasePlayer>();
                foreach (BasePlayer player in triggerPlayers)
                    if (!collidePlayers.Contains(player)) removePlayers.Add(player);
                foreach (BasePlayer player in removePlayers)
                {
                    triggerPlayers.Remove(player);
                    OnLeaveCollision(player);
                }
            }

            private void OnEnterCollision(BasePlayer player)
            {
                Interface.Oxide.CallHook("OnEnterNPC", npc.player, player);
            }

            private void OnLeaveCollision(BasePlayer player)
            {
                Interface.Oxide.CallHook("OnLeaveNPC", npc.player, player);
            }
        }

        //////////////////////////////////////////////////////
        ///  class HumanLocomotion
        /// MonoBehaviour: managed by UnityEngine
        ///  This takes care of all movements and attacks of HumanNPCs
        //////////////////////////////////////////////////////
        public class HumanLocomotion : MonoBehaviour
        {
            private HumanPlayer npc;
            public Vector3 StartPos = new Vector3(0f, 0f, 0f);
            public Vector3 EndPos = new Vector3(0f, 0f, 0f);
            public Vector3 LastPos = new Vector3(0f, 0f, 0f);
            private Vector3 nextPos = new Vector3(0f, 0f, 0f);
            private float waypointDone = 0f;
            public float secondsTaken = 0f;
            private float secondsToTake = 0f;

            public List<WaypointInfo> cachedWaypoints;
            private int currentWaypoint = -1;

            public float followDistance = 3.5f;
            private float lastHit = 0f;

            public int noPath = 0;
            public bool shouldMove = true;

            private float startedReload = 0f;
            private bool reloading = false;
            public bool returning = false;
            public bool sitting = false;

            public BaseCombatEntity attackEntity = null;
            public BaseEntity followEntity = null;
            public Vector3 targetPosition = Vector3.zero;

            public List<Vector3> pathFinding;

            private HeldEntity firstWeapon = null;

            public void Awake()
            {
                npc = GetComponent<HumanPlayer>();
                UpdateWaypoints();

                npc.player.modelState.onground = true;
            }
            public void UpdateWaypoints()
            {
                if (string.IsNullOrEmpty(npc.info.waypoint)) return;
                var cwaypoints = Interface.Oxide.CallHook("GetWaypointsList", npc.info.waypoint);
                if (cwaypoints == null)
                    cachedWaypoints = null;
                else
                {
                    cachedWaypoints = new List<WaypointInfo>();
                    var lastPos = npc.info.spawnInfo.position;
                    var speed = GetSpeed();
                    foreach (var cwaypoint in (List<object>)cwaypoints)
                    {
                        foreach (var pair in (Dictionary<Vector3, float>)cwaypoint)
                        {
                            if (HumanNPC.PathFinding == null)
                            {
                                cachedWaypoints.Add(new WaypointInfo(pair.Key, pair.Value));
                                continue;
                            }
                            var temppathFinding = HumanNPC.PathFinding.Go(lastPos, pair.Key);
                            speed = pair.Value;
                            if (temppathFinding != null)
                            {
                                lastPos = pair.Key;
                                foreach (var vector3 in temppathFinding)
                                    cachedWaypoints.Add(new WaypointInfo(vector3, speed));
                            }
                            else
                            {
#if DEBUG
                                Interface.Oxide.LogInfo("Blocked waypoint? {0} for {1}", pair.Key, npc.player.displayName);
#endif
                                //cachedWaypoints.Add(new WaypointInfo(pair.Key, speed));
                            }
                        }
                    }
                    if (HumanNPC.PathFinding != null && lastPos != npc.info.spawnInfo.position)
                    {
                        var temppathFinding = HumanNPC.PathFinding.Go(lastPos, npc.info.spawnInfo.position);
                        if (temppathFinding != null)
                        {
                            foreach (var vector3 in temppathFinding)
                                cachedWaypoints.Add(new WaypointInfo(vector3, speed));
                        }
                        else
                        {
#if DEBUG
                            Interface.Oxide.LogInfo("Blocked waypoint to spawn? {0} for {1}", lastPos, npc.player.displayName);
#endif
                        }
                    }
                    if (cachedWaypoints.Count <= 0) cachedWaypoints = null;
#if DEBUG
                    Interface.Oxide.LogInfo("Waypoints: {0} for {1}", cachedWaypoints.Count, npc.player.displayName);
#endif
                }
            }
            private void FixedUpdate()
            {
                TryToMove();
            }
            public void TryToMove()
            {
                if (npc.player.IsDead() || npc.player.IsWounded()) return;
                if (targetPosition != Vector3.zero) ProcessFollow(targetPosition);
                else if (attackEntity is BaseCombatEntity) ProcessAttack(attackEntity);
                else if (followEntity is BaseEntity) ProcessFollow(followEntity.transform.position);
                else if (secondsTaken == 0f) GetNextPath();

                if (StartPos != EndPos) Execute_Move();
                if (waypointDone >= 1f) secondsTaken = 0f;
            }
            private void Execute_Move()
            {
                if (!shouldMove) return;
                secondsTaken += Time.deltaTime;
                waypointDone = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
                nextPos = Vector3.Lerp(StartPos, EndPos, waypointDone);
                nextPos.y = GetMoveY(nextPos);
                npc.player.MovePosition(nextPos);
                //npc.player.eyes.position = nextPos + new Vector3(0, 1.6f, 0);
                var newEyesPos = nextPos + new Vector3(0, 1.6f, 0);
                npc.player.eyes.position.Set(newEyesPos.x, newEyesPos.y, newEyesPos.z);
                npc.player.UpdatePlayerCollider(true);

                npc.player.modelState.onground = !IsSwimming();
            }

            public void Evade()
            {
                if(IsSwimming()) return;
                if(npc.info.evade == false) return;
#if DEBUG
                Interface.Oxide.LogInfo("Evading...");
#endif
                Vector3 ev = new Vector3(UnityEngine.Random.Range(-npc.info.evdist, npc.info.evdist), 0f, UnityEngine.Random.Range(-2f, 2f));
                npc.player.MovePosition(npc.player.transform.position + ev);
            }

            public bool IsSwimming()
            {
                return WaterLevel.Test(npc.player.transform.position + new Vector3(0, 0.65f, 0));
            }

            private bool CanSit()
            {
                if(sitting)
                {
                    return false;
                }
                return npc.info.allowsit;
            }

     /*      public void Sit()
            {
                npc.Invoke("AllowMove",0);
                // Find a place to sit
                List<BaseChair> chairs = new List<BaseChair>();
                Vis.Entities<BaseChair>(npc.player.transform.position, 15f, chairs);
                foreach(var mountable in chairs.Distinct().ToList())
                {
#if DEBUG
                    Interface.Oxide.LogInfo($"HumanNPC {npc.player.displayName} trying to sit...");
#endif
                    if(mountable.IsMounted())
                    {
#if DEBUG
                        Interface.Oxide.LogInfo($"Someone is sitting here.");
#endif
                        continue;
                    }
#if DEBUG
                    Interface.Oxide.LogInfo($"Found an empty chair.");
#endif
                    mountable.MountPlayer(npc.player);
                    //npc.player.MovePosition(mountable.mountAnchor.transform.position);
                    //npc.player.transform.rotation = mountable.mountAnchor.transform.rotation;
                    //npc.player.ServerRotation = mountable.mountAnchor.transform.rotation;
                    npc.player.OverrideViewAngles(mountable.mountAnchor.transform.rotation.eulerAngles);
                    npc.player.eyes.NetworkUpdate(mountable.mountAnchor.transform.rotation);
                    npc.player.ClientRPCPlayer<Vector3>(null, npc.player, "ForcePositionTo", npc.player.transform.position);
                    mountable.SetFlag(BaseEntity.Flags.Busy, true, false);
                    sitting = true;
                    break;
                }
            } */

            public void Stand()
            {
                //if(CanSit() && sitting)
                if(sitting)
                {
#if DEBUG
                    Interface.Oxide.LogInfo($"HumanNPC {npc.player.displayName} trying to stand...");
#endif
//                    npc.Invoke("AllowMove",0);
                    var mounted = npc.player.GetMounted();
                    mounted.DismountPlayer(npc.player);
                    mounted.SetFlag(BaseEntity.Flags.Busy, false, false);
                    sitting = false;
                }
            }

            private float GetSpeed(float speed = -1)
            {
                if (sitting)
                    speed = 0;
                if (returning)
                    speed = 7;
                else if (speed == -1)
                    speed = npc.info.speed;

                if (IsSwimming())
                    speed = speed / 2f;

                return speed;
            }
            private void GetNextPath()
            {
                if (npc == null) npc = GetComponent<HumanPlayer>();

                if(CanSit() && sitting == false)
                {
              //      Sit();
                }

                LastPos = Vector3.zero;
                if (cachedWaypoints == null)
                {
                    shouldMove = false;
                    return;
                }
                shouldMove = true;
                Interface.Oxide.CallHook("OnNPCPosition", npc.player, npc.player.transform.position);
                if (currentWaypoint + 1 >= cachedWaypoints.Count)
                {
                    UpdateWaypoints();
                    currentWaypoint = -1;
                }
                if (cachedWaypoints == null)
                {
                    shouldMove = false;
                    return;
                }
                currentWaypoint++;

                var wp = cachedWaypoints[currentWaypoint];
                SetMovementPoint(npc.player.transform.position, wp.Position, GetSpeed(wp.Speed));
                if (npc.player.transform.position == wp.Position)
                {
                    npc.DisableMove();
                    npc.Invoke("AllowMove", GetSpeed(wp.Speed));
                    return;
                }
            }

            public void SetMovementPoint(Vector3 startpos, Vector3 endpos, float s)
            {
                StartPos = startpos;

                if (endpos != Vector3.zero)
                {
                    EndPos = endpos;
                    EndPos.y = Math.Max(EndPos.y, TerrainMeta.HeightMap.GetHeight(EndPos));
                    if (StartPos != EndPos)
                        secondsToTake = Vector3.Distance(EndPos, StartPos) / s;
                    npc.LookTowards(EndPos);
                }
                else
                {
                    if (IsInvoking("PathFinding")) { CancelInvoke("PathFinding"); }
                }

                secondsTaken = 0f;
                waypointDone = 0f;
            }

            private bool HitChance(float chance = -1f)
            {
                if (chance < 0)
                    chance = npc.info.hitchance;
                return UnityEngine.Random.Range(1, 100) < (int)(chance * 100);
            }

            private void Move(Vector3 position, float speed = -1)
            {
                if (speed == -1)
                {
                    speed = npc.info.speed;
                }

                if (waypointDone >= 1f)
                {
                    if (pathFinding != null && pathFinding.Count > 0) pathFinding.RemoveAt(pathFinding.Count - 1);
                    waypointDone = 0f;
                }
                if (pathFinding == null || pathFinding.Count < 1) return;
                shouldMove = true;

                if (waypointDone == 0f) SetMovementPoint(position, pathFinding[pathFinding.Count - 1], GetSpeed(speed));
            }

            private void ProcessAttack(BaseCombatEntity entity)
            {
#if DEBUG
                Interface.Oxide.LogInfo("ProcessAttack: {0} -> {1}", npc.player.displayName, entity.name);
#endif
                if (entity != null && entity.IsAlive())
                {
                    var c_attackDistance = Vector3.Distance(entity.transform.position, npc.player.transform.position);
                    shouldMove = false;

                    bool validAttack = Vector3.Distance(LastPos, npc.player.transform.position) < npc.info.maxDistance && noPath < 5;

#if DEBUG
                    Interface.Oxide.LogInfo("  Entity: Type {0}, alive {1}, valid {2}", entity.GetType().FullName, entity.IsAlive(), validAttack);
#endif
                    if (validAttack)
                    {
                        var range = c_attackDistance < npc.info.damageDistance;
                        var see = CanSee(npc, entity);
#if DEBUG
                        Interface.Oxide.LogInfo("  validAttack Entity: Type {0}, ranged {1}, cansee {2}", entity.GetType().FullName, range, see);
#endif
                        if (range && see)
                        {
                            AttemptAttack(entity);
                            return;
                        }
                        if (GetSpeed() <= 0)
                        {
                            npc.EndAttackingEntity();
                        }
                        else
                        {
                            Move(npc.player.transform.position);
                        }
                    }
                    else
                    {
                        npc.EndAttackingEntity();
                    }
                }
                else
                {
                    npc.EndAttackingEntity();
                }
            }

            public void ProcessFollow(Vector3 target)
            {
                var c_followDistance = Vector3.Distance(target, npc.player.transform.position);
                shouldMove = false;
                if (c_followDistance > followDistance && Vector3.Distance(LastPos, npc.player.transform.position) < npc.info.maxDistance && noPath < 5)
                {
                    Move(npc.player.transform.position);
                }
                else
                {
                    if (followEntity is BaseEntity)
                    {
                        npc.EndFollowingEntity(noPath < 5);
                    }
                    else if (targetPosition != Vector3.zero)
                    {
                        npc.EndGo(noPath < 5);
                    }
                }
            }

            public void PathFinding()
            {
                Vector3 target = Vector3.zero;

                if (attackEntity != null)
                {
                    //Vector3 diff = new Vector3(Core.Random.Range(-npc.info.attackDistance, npc.info.attackDistance), 0, Core.Random.Range(-npc.info.attackDistance, npc.info.attackDistance));
                    target = attackEntity.transform.position;// + diff;
                }
                else if (followEntity != null)
                {
                    target = followEntity.transform.position;
                }
                else if (targetPosition != Vector3.zero)
                {
                    target = targetPosition;
                }

                if (target != Vector3.zero)
                {
                    PathFinding(new Vector3(target.x, GetMoveY(target), target.z));
                }
            }

            public void PathFinding(Vector3 targetPos)
            {
                if (gameObject == null) return;
                if (IsInvoking("PathFinding")) { CancelInvoke("PathFinding"); }
                if (GetSpeed() <= 0) return;

                var temppathFinding = HumanNPC.PathFinding?.Go(npc.player.transform.position, targetPos);

                if (temppathFinding == null)
                {
                    if(pathFinding == null || pathFinding.Count == 0)
                    {
                        noPath++;
                    }
                    else
                    {
                        noPath = 0;
                    }
                    if(noPath < 5)
                    {
                        Invoke("PathFinding", 2);
                    }
                    else if (returning)
                    {
                        returning = false;
                        SetMovementPoint(npc.player.transform.position, LastPos, 7f);
                        secondsTaken = 0.01f;
                    }
                }
                else
                {
                    noPath = 0;

                    pathFinding = temppathFinding;
                    pathFinding.Reverse();
                    waypointDone = 0f;
                    Invoke("PathFinding", pathFinding.Count / GetSpeed(npc.info.speed));
                }
            }

            public void GetBackToLastPos()
            {
                if (npc.player.transform.position == LastPos) return;
                if (LastPos == Vector3.zero) LastPos = npc.info.spawnInfo.position;
                if (Vector3.Distance(npc.player.transform.position, LastPos) < 5)
                {
                    SetMovementPoint(npc.player.transform.position, LastPos, 7f);
                    secondsTaken = 0.01f;
                    return;
                }
                returning = true;
                npc.StartGo(LastPos);
            }

            public void Enable()
            {
                //if (GetSpeed() <= 0) return;
                enabled = true;
            }
            public void Disable()
            {
                enabled = false;
            }

            public float GetMoveY(Vector3 position)
            {
                if (IsSwimming())
                {
                    float point = TerrainMeta.WaterMap.GetHeight(position) - 0.65f;
                    float groundY = GetGroundY(position);
                    if (groundY > point)
                    {
                        return groundY;
                    }

                    return point - 0.65f;
                }

                return GetGroundY(position);
            }

            public float GetGroundY(Vector3 position)
            {
                position = position + Vector3.up;
                RaycastHit hitinfo;
                if (Physics.Raycast(position, Vector3Down, out hitinfo, 100f, groundLayer))
                {
                    return hitinfo.point.y;
                }
                return position.y - .5f;
            }

            public void CreateProjectileEffect(BaseCombatEntity target, BaseProjectile baseProjectile, float dmg, bool miss = false)
            {
                if (baseProjectile.primaryMagazine.contents <= 0)
                {
#if DEBUG
                    Interface.Oxide.LogInfo("Attack failed(empty): {0} - {1}", npc.player.displayName, attackEntity.name);
#endif
                    return;
                }
                var component = baseProjectile.primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
                if (component == null)
                {
#if DEBUG
                    Interface.Oxide.LogInfo("Attack failed(Component): {0} - {1}", npc.player.displayName, attackEntity.name);
#endif
                    return;
                }
                npc.LookTowards(target.transform.position);

                var source = npc.player.transform.position + npc.player.GetOffset();
                if (baseProjectile.MuzzlePoint != null)
                    source += Quaternion.LookRotation(target.transform.position - npc.player.transform.position) * baseProjectile.MuzzlePoint.position;
                var dir = (target.transform.position + npc.player.GetOffset() - source).normalized;
                var vector32 = dir * (component.projectileVelocity * baseProjectile.projectileVelocityScale);

                Vector3 hit;
                RaycastHit raycastHit;
                if (Vector3.Distance(npc.player.transform.position, target.transform.position) < 0.5)
                    hit = target.transform.position + npc.player.GetOffset(true);
                else if (!Physics.SphereCast(source, .01f, vector32, out raycastHit, float.MaxValue, targetLayer))
                {
#if DEBUG
                    Interface.Oxide.LogInfo("Attack failed: {0} - {1}", npc.player.displayName, attackEntity.name);
#endif
                    return;
                }
                else
                {
                    hit = raycastHit.point;
                    target = raycastHit.GetCollider().GetComponent<BaseCombatEntity>();
#if DEBUG
                    Interface.Oxide.LogInfo("Attack failed: {0} - {1}", raycastHit.GetCollider().name, (Rust.Layer)raycastHit.GetCollider().gameObject.layer);
#endif
                    miss = miss || target == null;
                }
                baseProjectile.primaryMagazine.contents--;
                npc.ForceSignalAttack();

                if (miss)
                {
                    var aimCone = baseProjectile.GetAimCone();
                    vector32 += Quaternion.Euler(UnityEngine.Random.Range((float)(-aimCone * 0.5), aimCone * 0.5f), UnityEngine.Random.Range((float)(-aimCone * 0.5), aimCone * 0.5f), UnityEngine.Random.Range((float)(-aimCone * 0.5), aimCone * 0.5f)) * npc.player.eyes.HeadForward();
                }

                Effect.server.Run(baseProjectile.attackFX.resourcePath, baseProjectile, StringPool.Get(baseProjectile.handBone), Vector3.zero, Vector3.forward);
                var effect = new Effect();
                effect.Init(Effect.Type.Projectile, source, vector32.normalized);
                effect.scale = vector32.magnitude;
                effect.pooledString = component.projectileObject.resourcePath;
                effect.number = UnityEngine.Random.Range(0, 2147483647);
                EffectNetwork.Send(effect);

                Vector3 dest;
                if (miss)
                {
                    dmg = 0;
                    dest = hit;
                }
                else
                {
                    dest = target.transform.position;
                }
                var hitInfo = new HitInfo(npc.player, target, DamageType.Bullet, dmg, dest)
                {
                    DidHit = !miss,
                    HitEntity = target,
                    PointStart = source,
                    PointEnd = hit,
                    HitPositionWorld = dest,
                    HitNormalWorld = -dir,
                    WeaponPrefab = GameManager.server.FindPrefab(StringPool.Get(baseProjectile.prefabID)).GetComponent<AttackEntity>(),
                    Weapon = (AttackEntity)firstWeapon,
                    HitMaterial = StringPool.Get("Flesh")
                };
                target?.OnAttacked(hitInfo);
                Effect.server.ImpactEffect(hitInfo);
            }

            public void AttemptAttack(BaseCombatEntity entity)
            {
                var weapon = firstWeapon as BaseProjectile;
                if (weapon != null)
                {
                    if (!reloading && weapon.primaryMagazine.contents <= 0)
                    {
                        reloading = true;
                        npc.player.SignalBroadcast(BaseEntity.Signal.Reload, string.Empty);
                        startedReload = Time.realtimeSinceStartup;
                        return;
                    }
                    if (reloading && Time.realtimeSinceStartup > startedReload + (npc.info.reloadDuration > 0 ? npc.info.reloadDuration : weapon.reloadTime))
                    {
                        reloading = false;
                        if (npc.info.needsAmmo)
                        {
                            weapon.primaryMagazine.Reload(npc.player);
                            npc.player.inventory.ServerUpdate(0f);
                        }
                        else
                        {
                            weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
                        }
                    }
                    if (reloading) return;
                }
                if (!(Time.realtimeSinceStartup > lastHit + npc.info.damageInterval)) return;
                lastHit = Time.realtimeSinceStartup;
                DoAttack(entity, !HitChance());
            }

            public void DoAttack(BaseCombatEntity target, bool miss = false)
            {
                if (npc == null) return;
                var weapon = firstWeapon as BaseProjectile;
                if (firstWeapon == null || (firstWeapon != null && (firstWeapon.IsDestroyed || weapon != null && weapon.primaryMagazine.contents == 0)))
                {
                    firstWeapon = npc.EquipFirstWeapon();
                    weapon = firstWeapon as BaseProjectile;
                    npc.SetActive(0);
                }

                var attackitem = firstWeapon?.GetItem();
                if (attackitem == null)
                {
                    npc.EndAttackingEntity();
                    return;
                }
                if (attackitem.uid != npc.player.svActiveItemID)
                    npc.SetActive(attackitem.uid);

                float dmg = npc.info.damageAmount * UnityEngine.Random.Range(0.8f, 1.2f);
                if (target is BaseNpc)
                    dmg *= 1.5f;
                else if (target is AutoTurret)
                    dmg *= 3f;

                if (weapon != null)
                {
                    //npc.ForceSignalGesture();
                    CreateProjectileEffect(target, weapon, dmg, miss);
                }
                else
                {
                    var hitInfo = new HitInfo(npc.player, target, DamageType.Stab, dmg, target.transform.position)
                    {
                        PointStart = npc.player.transform.position,
                        PointEnd = target.transform.position
                    };
                    target.SendMessage("OnAttacked", hitInfo, SendMessageOptions.DontRequireReceiver);
                    npc.ForceSignalAttack();
                }
            }
        }

        //////////////////////////////////////////////////////
        ///  class HumanPlayer : MonoBehaviour
        ///  MonoBehaviour: managed by UnityEngine
        /// Takes care of all the sub categories of the HumanNPCs
        //////////////////////////////////////////////////////
        public class HumanPlayer : MonoBehaviour
        {
            public HumanNPCInfo info;
            public HumanLocomotion locomotion;
            public HumanTrigger trigger;
            public ProtectionProperties protection;

            public BasePlayer player;

            public float lastMessage;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                protection = ScriptableObject.CreateInstance<ProtectionProperties>();
            }

            public void SetInfo(HumanNPCInfo info, bool update = false)
            {
                this.info = info;
                if (info == null) return;
                player.displayName = info.displayName;
                SetViewAngle(info.spawnInfo.rotation);
                player.syncPosition = true;
                if (!update)
                {
                    //player.xp = ServerMgr.Xp.GetAgent(info.userid);
                    player.stats = new PlayerStatistics(player);
                    player.userID = info.userid;
                    player.UserIDString = player.userID.ToString();
                    player.MovePosition(info.spawnInfo.position);
                    player.eyes = player.eyes ?? player.GetComponent<PlayerEyes>();
                    //player.eyes.position = info.spawnInfo.position + new Vector3(0, 1.6f, 0);
                    var newEyes = info.spawnInfo.position + new Vector3(0, 1.6f, 0);
                    player.eyes.position.Set(newEyes.x, newEyes.y, newEyes.z);
                    player.EndSleeping();
                    protection.Clear();
                    foreach (var pro in info.protections)
                        protection.Add(pro.Key, pro.Value);
                }
                if (locomotion != null) Destroy(locomotion);
                locomotion = player.gameObject.AddComponent<HumanLocomotion>();
                if (trigger != null) Destroy(trigger);
                trigger = player.gameObject.AddComponent<HumanTrigger>();
                lastMessage = Time.realtimeSinceStartup;
                DisableMove();
                AllowMove();
            }

            public void UpdateHealth(HumanNPCInfo info)
            {
                player.InitializeHealth(info.health, info.health);
                player.health = info.health;
            }

            public void Evade()
            {
                if(player.IsSwimming()) return;
                if(info.evade == false) return;
#if DEBUG
                Interface.Oxide.LogInfo("Evading...");
#endif
                Vector3 evade = new Vector3(UnityEngine.Random.Range(-info.evdist, info.evdist), 0f, UnityEngine.Random.Range(-2f, 2f));
                //evade.y = player.transform.position.y;
                player.MovePosition(player.transform.position + evade);
//                locomotion?.Move(player.transform.position + evade);
            }

            public void AllowMove()
            {
                locomotion?.Enable();
            }
            public void DisableMove()
            {
                locomotion?.Disable();
            }
            public void TemporaryDisableMove(float thetime = -1f)
            {
                if (thetime == -1f) thetime = info.stopandtalkSeconds;
                DisableMove();
                if (gameObject == null) return;
                if (IsInvoking("AllowMove")) CancelInvoke("AllowMove");
                Invoke("AllowMove", thetime);
            }
            public void EndAttackingEntity(bool trigger = true)
            {
                if (locomotion.gameObject != null && locomotion.IsInvoking("PathFinding")) locomotion.CancelInvoke("PathFinding");
                locomotion.noPath = 0;
                locomotion.shouldMove = true;
                if (trigger)
                {
                    Interface.Oxide.CallHook("OnNPCStopTarget", player, locomotion.attackEntity);
                }
                locomotion.attackEntity = null;
                player.health = info.health;
                locomotion.GetBackToLastPos();
                SetActive(0);
            }
            public void EndFollowingEntity(bool trigger = true)
            {
                if (locomotion.IsInvoking("PathFinding")) locomotion.CancelInvoke("PathFinding");

                locomotion.noPath = 0;
                locomotion.shouldMove = true;
                if (trigger)
                {
                    Interface.Oxide.CallHook("OnNPCStopTarget", player, locomotion.followEntity);
                }
                locomotion.followEntity = null;
            }

            public void EndGo(bool trigger = true)
            {
                if (locomotion.IsInvoking("PathFinding")) locomotion.CancelInvoke("PathFinding");

                locomotion.noPath = 0;
                locomotion.shouldMove = true;

                if (trigger)
                {
                    Interface.Oxide.CallHook("OnNPCStopGo", player, locomotion.targetPosition);
                }
                if (locomotion.returning)
                {
                    locomotion.returning = false;
                    locomotion.SetMovementPoint(player.transform.position, locomotion.LastPos, 7f);
                    locomotion.secondsTaken = 0.01f;
                }
                locomotion.targetPosition = Vector3.zero;
            }

            public void StartAttackingEntity(BaseCombatEntity entity)
            {
                if (locomotion.attackEntity != null && UnityEngine.Random.Range(0f, 1f) < 0.75f) return;
                if (Interface.Oxide.CallHook("OnNPCStartTarget", player, entity) == null)
                {
                    //var item = GetFirstWeaponItem();
                    //if (item != null)
                    //    SetActive(item.uid);
                    locomotion.attackEntity = entity;
                    locomotion.pathFinding = null;

                    if (locomotion.LastPos == Vector3.zero) locomotion.LastPos = player.transform.position;
                    if (gameObject != null && IsInvoking("AllowMove"))
                    {
                        CancelInvoke("AllowMove");
                        AllowMove();
                    }
                    locomotion.Invoke("PathFinding", 0);
                }
            }

            public void StartFollowingEntity(BaseEntity entity)
            {
                if (locomotion.targetPosition != Vector3.zero)
                {
                    EndGo(false);
                }
                player.SendNetworkUpdate();
                locomotion.followEntity = entity;
                locomotion.pathFinding = null;

                if (locomotion.LastPos == Vector3.zero) locomotion.LastPos = player.transform.position;
                if (IsInvoking("AllowMove")) { CancelInvoke("AllowMove"); AllowMove(); }
                locomotion.Invoke("PathFinding", 0);
            }

            public void StartGo(Vector3 position)
            {
                if (locomotion.followEntity != null)
                {
                    EndFollowingEntity(false);
                }
                player.SendNetworkUpdate();
                locomotion.targetPosition = position;
                locomotion.pathFinding = null;

                if (locomotion.LastPos == Vector3.zero) locomotion.LastPos = player.transform.position;
                if (IsInvoking("AllowMove")) { CancelInvoke("AllowMove"); AllowMove(); }
                locomotion.Invoke("PathFinding", 0);
            }

            public HeldEntity GetCurrentWeapon()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    BaseEntity heldEntity = item.GetHeldEntity();
                    if (heldEntity is HeldEntity && !heldEntity.HasFlag(BaseEntity.Flags.Disabled))
                        return (HeldEntity)heldEntity;
                }
                return null;
            }

            public Item GetFirstWeaponItem()
            {
                return GetFirstWeapon()?.GetItem();
            }

            public HeldEntity GetFirstWeapon()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if (item.CanBeHeld() && HasAmmo(item) && (item.info.category == ItemCategory.Weapon))
                        return item.GetHeldEntity() as HeldEntity;
                }
                return null;
            }

            public HeldEntity GetFirstTool()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if (item.CanBeHeld() && item.info.category == ItemCategory.Tool)
                        return item.GetHeldEntity() as HeldEntity;
                }
                return null;
            }

            public HeldEntity GetFirstMisc()
            {
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if (item.CanBeHeld() && item.info.category != ItemCategory.Tool && item.info.category != ItemCategory.Weapon)
                        return item.GetHeldEntity() as HeldEntity;
                }
                return null;
            }

            public List<Item> GetAmmo(Item item)
            {
                var ammos = new List<Item>();
                AmmoTypes ammoType;
                if (!ammoTypes.TryGetValue(item.info.shortname, out ammoType))
                    return ammos;
                player.inventory.FindAmmo(ammos, ammoType);
                return ammos;
            }

            public bool HasAmmo(Item item)
            {
                if (!info.needsAmmo) return true;
                var weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon == null) return true;
                return weapon.primaryMagazine.contents > 0 || weapon.primaryMagazine.CanReload(player);
            }

            public void UnequipAll()
            {
                if (player.inventory?.containerBelt == null) return;
                foreach (Item item in player.inventory.containerBelt.itemList)
                {
                    if (item.CanBeHeld())
                        (item.GetHeldEntity() as HeldEntity)?.SetHeld(false);
                }
            }

            public HeldEntity EquipFirstWeapon()
            {
                HeldEntity weapon = GetFirstWeapon();
                if (weapon != null)
                {
                    UnequipAll();
                    weapon.SetHeld(true);
                }
                return weapon;
            }

            public HeldEntity EquipFirstTool()
            {
                HeldEntity tool = GetFirstTool();
                if (tool != null)
                {
                    UnequipAll();
                    tool.SetHeld(true);
                }
                return tool;
            }

            public HeldEntity EquipFirstMisc()
            {
                HeldEntity misc = GetFirstMisc();
                if (misc != null)
                {
                    UnequipAll();
                    misc.SetHeld(true);
                }
                return misc;
            }

            public void SetActive(uint id)
            {
                player.svActiveItemID = id;
                player.SendNetworkUpdate();
                player.SignalBroadcast(BaseEntity.Signal.Reload, string.Empty);
            }

            private void OnDestroy()
            {
                Destroy(locomotion);
                Destroy(trigger);
                Destroy(protection);
            }

            public void LookTowards(Vector3 pos)
            {
                if (pos != player.transform.position)
                    SetViewAngle(Quaternion.LookRotation(pos - player.transform.position));
            }

            public void ForceSignalGesture()
            {
                player.SignalBroadcast(BaseEntity.Signal.Gesture, "pickup_item");
            }

            public void ForceSignalAttack()
            {
                player.SignalBroadcast(BaseEntity.Signal.Attack, string.Empty);
            }

            public void SetViewAngle(Quaternion viewAngles)
            {
                if (viewAngles.eulerAngles == default(Vector3)) return;
             //   player.viewAngles = viewAngles.eulerAngles;
                player.SendNetworkUpdate();
            }
        }

        //////////////////////////////////////////////////////
        ///  class HumanNPCInfo
        ///  NPC information that will be saved inside the datafile
        ///  public => will be saved in the data file
        ///  non public => won't be saved in the data file
        //////////////////////////////////////////////////////
        public class HumanNPCInfo
        {
            public ulong userid;
            public string displayName;
            public bool invulnerability;
            public float health;
            public bool respawn;
            public float respawnSeconds;
            public SpawnInfo spawnInfo;
            public string waypoint;
            public float collisionRadius;
            public string spawnkit;
            public float damageAmount;
            public float damageDistance;
            public float damageInterval;
            public float attackDistance;
            public float maxDistance;
            public bool hostile;
            public float speed;
            public bool stopandtalk;
            public float stopandtalkSeconds;
            public bool enable;
            public bool lootable;
            public float hitchance;
            public float reloadDuration;
            public bool needsAmmo;
            public bool defend;
            public bool evade;
            public float evdist;
            public bool allowsit;
            public List<string> message_hello;
            public List<string> message_bye;
            public List<string> message_use;
            public List<string> message_hurt;
            public List<string> message_kill;
            public Dictionary<DamageType, float> protections = new Dictionary<DamageType, float>();

            public HumanNPCInfo(ulong userid, Vector3 position, Quaternion rotation)
            {
                this.userid = userid;
                displayName = "NPC";
                invulnerability = true;
                health = 50;
                hostile = false;
                needsAmmo = true;
                respawn = true;
                respawnSeconds = 60;
                spawnInfo = new SpawnInfo(position, rotation);
                collisionRadius = 10;
                damageDistance = 3;
                damageAmount = 10;
                attackDistance = 100;
                maxDistance = 200;
                hitchance = 0.75f;
                speed = 3;
                stopandtalk = true;
                stopandtalkSeconds = 3;
                enable = true;
                lootable = true;
                damageInterval = 2;
                for (var i = 0; i < (int)DamageType.LAST; i++)
                    protections[(DamageType)i] = 0f;
            }

            public HumanNPCInfo Clone(ulong userid)
            {
                return new HumanNPCInfo(userid, spawnInfo.position, spawnInfo.rotation)
                {
                    displayName = displayName,
                    invulnerability = invulnerability,
                    health = health,
                    respawn = respawn,
                    respawnSeconds = respawnSeconds,
                    waypoint = waypoint,
                    collisionRadius = collisionRadius,
                    spawnkit = spawnkit,
                    damageAmount = damageAmount,
                    damageDistance = damageDistance,
                    attackDistance = attackDistance,
                    maxDistance = maxDistance,
                    hostile = hostile,
                    speed = speed,
                    stopandtalk = stopandtalk,
                    stopandtalkSeconds = stopandtalkSeconds,
                    lootable = lootable,
                    defend = defend,
                    evade = evade,
                    evdist = evdist,
                    allowsit = allowsit,
                    damageInterval = damageInterval,
                    message_hello = message_hello?.ToList(),
                    message_bye = message_bye?.ToList(),
                    message_use = message_use?.ToList(),
                    message_hurt = message_hurt?.ToList(),
                    message_kill = message_kill?.ToList(),
                    needsAmmo = needsAmmo,
                    hitchance = hitchance,
                    reloadDuration = reloadDuration,
                    protections = protections?.ToDictionary(p => p.Key, p => p.Value)
                };
            }
        }

        private class NPCEditor : MonoBehaviour
        {
            public BasePlayer player;
            public HumanPlayer targetNPC;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }
        }

        public static Dictionary<string, AmmoTypes> ammoTypes = new Dictionary<string, AmmoTypes>();
        //{
        //    {"bow.hunting", AmmoTypes.BOW_ARROW},
        //    {"crossbow", AmmoTypes.BOW_ARROW},
        //    {"pistol.eoka", AmmoTypes.HANDMADE_SHELL},
        //    {"pistol.semiauto", AmmoTypes.PISTOL_9MM},
        //    {"pistol.revolver", AmmoTypes.PISTOL_9MM},
        //    {"rifle.ak", AmmoTypes.RIFLE_556MM},
        //    {"rifle.bolt", AmmoTypes.RIFLE_556MM},
        //    {"shotgun.pump", AmmoTypes.SHOTGUN_12GUAGE},
        //    {"shotgun.waterpipe", AmmoTypes.HANDMADE_SHELL},
        //    {"smg.2", AmmoTypes.PISTOL_9MM},
        //    {"smg.thompson", AmmoTypes.PISTOL_9MM}
        //};

        private static Dictionary<string, BaseProjectile> weaponProjectile = new Dictionary<string, BaseProjectile>();

        protected override void LoadDefaultConfig()
        {
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void Init()
        {
            ammoTypes = new Dictionary<string, AmmoTypes>();
            weaponProjectile = new Dictionary<string, BaseProjectile>();
            CheckCfg("Chat", ref chat);
            SaveConfig();
        }

        private static bool GetBoolValue(string value)
        {
            if (value == null) return false;
            value = value.Trim().ToLower();
            switch (value)
            {
                case "t":
                case "true":
                case "1":
                case "yes":
                case "y":
                case "on":
                    return true;

                default:
                    return false;
            }
        }

        private void Loaded()
        {
            LoadData();

            var filter = RustExtension.Filter.ToList();
            filter.Add("Look rotation viewing vector is zero");
            RustExtension.Filter = filter.ToArray();
        }

        private void Unload()
        {
            var HumanNPCMono = UnityEngine.Object.FindObjectsOfType<HumanPlayer>();
            foreach (var mono in HumanNPCMono)
            {
                PrintWarning($"Deleting {mono.info.displayName} ({mono.info.userid})");
                mono.GetComponent<BasePlayer>().Kill();
            }

            var npcEditors = UnityEngine.Object.FindObjectsOfType<NPCEditor>();
            foreach (var gameObj in npcEditors)
            {
                UnityEngine.Object.Destroy(gameObj);
            }
            SaveData();
        }

        private void SaveData()
        {
            if (storedData == null || !save) return;
            data.WriteObject(storedData);
            save = false;
        }

        private void LoadData()
        {
            data = Interface.Oxide.DataFileSystem.GetFile(nameof(HumanNPC));
            data.Settings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
            data.Settings.Converters = new JsonConverter[] { new SpawnInfoConverter(), new UnityQuaternionConverter(), new UnityVector3Converter() };

            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
            data.Clear();
            foreach (var thenpc in storedData.HumanNPCs)
                humannpcs[thenpc.userid] = thenpc;
        }

        //////////////////////////////////////////////////////
        ///  Oxide Hooks
        //////////////////////////////////////////////////////

        //////////////////////////////////////////////////////
        ///  OnServerInitialized()
        ///  called when the server is done being initialized
        //////////////////////////////////////////////////////
        private void OnServerInitialized()
        {
         //   colBuffer = Vis.colBuffer;
            eyesPosition = new Vector3(0f, 0.5f, 0f);
            Vector3Down = new Vector3(0f, -1f, 0f);
            PathFinding = (PathFinding)plugins.Find(nameof(PathFinding));
            playerLayer = LayerMask.GetMask("Player (Server)");
            targetLayer = LayerMask.GetMask("Player (Server)", "AI", "Deployed", "Construction");
            groundLayer = LayerMask.GetMask("Construction", "Terrain", "World");

            foreach (var info in ItemManager.itemList)
            {
                var baseProjectile = info.GetComponent<ItemModEntity>()?.entityPrefab.Get().GetComponent<BaseProjectile>();
                if (baseProjectile == null) continue;
                weaponProjectile.Add(info.shortname, baseProjectile);

                var projectile = baseProjectile.primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
                if (projectile != null && !ammoTypes.ContainsKey(info.shortname))
                {
                    ammoTypes.Add(info.shortname, projectile.ammoType);
                }
            }

            RefreshAllNPC();
        }

        //////////////////////////////////////////////////////
        ///  OnServerSave()
        ///  called when a server performs a save
        //////////////////////////////////////////////////////
        private void OnServerSave() => SaveData();

        private void OnServerShutdown() => SaveData();

        //////////////////////////////////////////////////////
        /// OnPlayerInput(BasePlayer player, InputState input)
        /// Called when a plugin presses a button
        //////////////////////////////////////////////////////
        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!input.WasJustPressed(BUTTON.USE)) return;
#if DEBUG
            Interface.Oxide.LogInfo("Use pressed: {0}", player.displayName);
#endif
            Quaternion currentRot;
            TryGetPlayerView(player, out currentRot);
            var hitpoints = Physics.RaycastAll(new Ray(player.transform.position + eyesPosition, currentRot * Vector3.forward), 5f, playerLayer);
            Array.Sort(hitpoints, (a, b) => a.distance == b.distance ? 0 : a.distance > b.distance ? 1 : -1);
            for (var i = 0; i < hitpoints.Length; i++)
            {
#if DEBUG
                Interface.Oxide.LogInfo("Raycast: {0}", hitpoints[i].collider.name);
#endif
                var humanPlayer = hitpoints[i].collider.GetComponentInParent<HumanPlayer>();
                if (humanPlayer != null)
                {
                    if(humanPlayer.locomotion.sitting)
                    {
                        humanPlayer.locomotion.Stand();
                    }
                    if (humanPlayer.info.stopandtalk && humanPlayer.locomotion.attackEntity == null)
                    {
                        humanPlayer.LookTowards(player.transform.position);
                        humanPlayer.TemporaryDisableMove();
                    }
                    if (humanPlayer.info.message_use != null && humanPlayer.info.message_use.Count != 0)
                    {
                        SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_use));
                    }
                    Interface.Oxide.CallHook("OnUseNPC", humanPlayer.player, player);
                    break;
                }
            }
        }

        //////////////////////////////////////////////////////
        /// OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        /// Called when an entity gets attacked (can be anything, building, animal, player ..)
        //////////////////////////////////////////////////////
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            var humanPlayer = entity.GetComponent<HumanPlayer>();
            if(humanPlayer != null)
            {
#if DEBUG
                Interface.Oxide.LogInfo($"OnEntityTakeDamage(by {entity.name})");
#endif
                if(hitinfo.Initiator is BaseCombatEntity && !(hitinfo.Initiator is Barricade) && humanPlayer.info.defend)
                {
                    humanPlayer.StartAttackingEntity((BaseCombatEntity)hitinfo.Initiator);
                }
                if(humanPlayer.info.message_hurt != null && humanPlayer.info.message_hurt.Count != 0)
                {
                    if(hitinfo.InitiatorPlayer != null)
                    {
                        SendMessage(humanPlayer, hitinfo.InitiatorPlayer, GetRandomMessage(humanPlayer.info.message_hurt));
                    }
                }
                Interface.Oxide.CallHook("OnHitNPC", entity.GetComponent<BaseCombatEntity>(), hitinfo);
                if(humanPlayer.info.invulnerability)
                {
                    hitinfo.damageTypes = new DamageTypeList();
                    hitinfo.DoHitEffects = false;
                    hitinfo.HitMaterial = 0;
                }
                else
                {
                    humanPlayer.protection.Scale(hitinfo.damageTypes);
                }

                if(humanPlayer.locomotion.sitting)
                {
                    humanPlayer.locomotion.Stand();
                    humanPlayer.locomotion.Evade();
                }
                humanPlayer.locomotion.Evade();
            }
        }

        //////////////////////////////////////////////////////
        /// OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        /// Called when an entity gets killed (can be anything, building, animal, player ..)
        //////////////////////////////////////////////////////
        private void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            var humanPlayer = entity.GetComponent<HumanPlayer>();
            if (humanPlayer?.info == null) return;
            if (!humanPlayer.info.lootable)
            {
                humanPlayer.player.inventory?.Strip();
            }
            var player = hitinfo?.InitiatorPlayer;
            if (player != null)
            {
                if(humanPlayer.info.message_kill != null && humanPlayer.info.message_kill.Count > 0)
                {
                    SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_kill));
                }
                //if (humanPlayer.info.xp > 0)
                //    player.xp.Add(Definitions.Cheat, humanPlayer.info.xp);
            }
            Interface.Oxide.CallHook("OnKillNPC", entity.GetComponent<BasePlayer>(), hitinfo);
            if(humanPlayer.info.respawn)
            {
                timer.Once(humanPlayer.info.respawnSeconds, () => SpawnOrRefresh(humanPlayer.info.userid));
            }
        }

        private object CanLootPlayer(BasePlayer target, BasePlayer looter)
        {
            var humanPlayer = target.GetComponent<HumanPlayer>();
            if (humanPlayer != null && !humanPlayer.info.lootable)
            {
                NextTick(looter.EndLooting);
                return false;
            }
            return null;
        }

        private void OnLootPlayer(BasePlayer looter, BasePlayer target)
        {
            if (humannpcs[target.userID] != null)
                Interface.Oxide.CallHook("OnLootNPC", looter.inventory.loot, target, target.userID);
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity entity)
        {
            if (looter == null || !(entity is PlayerCorpse)) return;
            var userId = ((PlayerCorpse)entity).playerSteamID;
            if (humannpcs[userId] != null)
                Interface.Oxide.CallHook("OnLootNPC", looter.inventory.loot, entity, userId);
        }

        //////////////////////////////////////////////////////
        /// End of Oxide Hooks
        //////////////////////////////////////////////////////

        private Dictionary<ulong, HumanPlayer> cache = new Dictionary<ulong, HumanPlayer>();

        public HumanPlayer FindHumanPlayerByID(ulong userid)
        {
            HumanPlayer humanPlayer;
            if (cache.TryGetValue(userid, out humanPlayer))
                return humanPlayer;
            var allBasePlayer = Resources.FindObjectsOfTypeAll<HumanPlayer>();
            foreach (var humanplayer in allBasePlayer)
            {
                if (humanplayer.player.userID != userid) continue;
                cache[userid] = humanplayer;
                return humanplayer;
            }
            return null;
        }

        public HumanPlayer FindHumanPlayer(string nameOrId)
        {
            if (string.IsNullOrEmpty(nameOrId)) return null;
            var allBasePlayer = Resources.FindObjectsOfTypeAll<HumanPlayer>();
            foreach (var humanplayer in allBasePlayer)
            {
                if (!nameOrId.Equals(humanplayer.player.UserIDString) && !humanplayer.player.displayName.Contains(nameOrId, CompareOptions.OrdinalIgnoreCase)) continue;
                return humanplayer;
            }
            return null;
        }

        private BasePlayer FindPlayerByID(ulong userid)
        {
            var allBasePlayer = Resources.FindObjectsOfTypeAll<BasePlayer>();
            foreach (BasePlayer player in allBasePlayer)
            {
                if (player.userID == userid) return player;
            }
            return null;
        }

        private void RefreshAllNPC()
        {
            List<ulong> npcspawned = new List<ulong>();
            foreach (KeyValuePair<ulong, HumanNPCInfo> pair in humannpcs)
            {
                if (!pair.Value.enable) continue;
                npcspawned.Add(pair.Key);
                SpawnOrRefresh(pair.Key);
            }
        }

        private void SpawnOrRefresh(ulong userid)
        {
            BasePlayer findplayer = FindPlayerByID(userid);

            if (findplayer == null || findplayer.IsDestroyed)
            {
                cache.Remove(userid);
                SpawnNPC(userid, false);
            }
            else RefreshNPC(findplayer, false);
        }

        private void SpawnNPC(ulong userid, bool isediting)
        {
            HumanNPCInfo info;
            if (!humannpcs.TryGetValue(userid, out info)) return;
            if (!isediting && !info.enable) return;
            var newPlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", info.spawnInfo.position, info.spawnInfo.rotation).ToPlayer();
            var humanPlayer = newPlayer.gameObject.AddComponent<HumanPlayer>();
            humanPlayer.SetInfo(info);
            newPlayer.Spawn();

            humanPlayer.UpdateHealth(info);
            cache[userid] = humanPlayer;
            UpdateInventory(humanPlayer);
            Interface.Oxide.CallHook("OnNPCRespawn", newPlayer);
            Puts($"Spawned NPC: {userid}");
        }

        private void UpdateInventory(HumanPlayer humanPlayer)
        {
            humanPlayer.player.inventory.DoDestroy();
            humanPlayer.player.inventory.ServerInit(humanPlayer.player);
            if (!string.IsNullOrEmpty(humanPlayer.info.spawnkit))
            {
                //player.inventory.Strip();
                Kits?.Call("GiveKit", humanPlayer.player, humanPlayer.info.spawnkit);
                if (humanPlayer.EquipFirstWeapon() == null && humanPlayer.EquipFirstTool() == null)
                    humanPlayer.EquipFirstMisc();
            }
            /*player.SV_ClothingChanged();
            if (humanPlayer.info.protections != null)
            {
                player.baseProtection.Clear();
                foreach (var protection in info.protections)
                    player.baseProtection.Add(protection.Key, protection.Value);
            }*/
            humanPlayer.player.inventory.ServerUpdate(0f);
        }

        private void KillNpc(BasePlayer player)
        {
            if (player.userID >= 76560000000000000L || player.userID <= 0L || player.IsDestroyed) return;
            cache.Remove(player.userID);
            player.KillMessage();
        }

        public void RefreshNPC(BasePlayer player, bool isediting)
        {
            HumanNPCInfo info;
            if (!humannpcs.TryGetValue(player.userID, out info)) return;
            KillNpc(player);
            if (!info.enable && !isediting)
            {
                Puts($"NPC was killed because he is disabled: {player.userID}");
                return;
            }
            SpawnOrRefresh(player.userID);
        }

        public void UpdateNPC(BasePlayer player, bool isediting)
        {
            HumanNPCInfo info;
            if (!humannpcs.TryGetValue(player.userID, out info)) return;
            if (!info.enable && !isediting)
            {
                KillNpc(player);
                Puts($"NPC was killed because he is disabled: {player.userID}");
                return;
            }
            if (player.GetComponent<HumanPlayer>() != null)
                UnityEngine.Object.Destroy(player.GetComponent<HumanPlayer>());
            var humanplayer = player.gameObject.AddComponent<HumanPlayer>();
            humanplayer.SetInfo(info, true);
            cache[player.userID] = humanplayer;
            Puts("Refreshed NPC: " + player.userID);
        }

        public HumanPlayer CreateNPC(Vector3 position, Quaternion currentRot, string name = "NPC", ulong clone = 0)
        {
            HumanNPCInfo npcInfo = null;
            var userId = (ulong)UnityEngine.Random.Range(0, 2147483647);
            if (clone != 0)
            {
                HumanNPCInfo tempInfo;
                if (humannpcs.TryGetValue(clone, out tempInfo))
                {
                    npcInfo = tempInfo.Clone(userId);
                    npcInfo.spawnInfo = new SpawnInfo(position, currentRot);
                }
            }
            if (npcInfo == null) npcInfo = new HumanNPCInfo(userId, position, currentRot);
            npcInfo.displayName = name;
            RemoveNPC(userId);

            humannpcs[userId] = npcInfo;
            storedData.HumanNPCs.Add(npcInfo);
            save = true;

            SpawnNPC(userId, true);

            return FindHumanPlayerByID(userId);
        }

        public void RemoveNPC(ulong npcid)
        {
            if (humannpcs.ContainsKey(npcid))
            {
                storedData.HumanNPCs.Remove(humannpcs[npcid]);
                humannpcs[npcid] = null;
            }
            cache.Remove(npcid);
            var npc = FindHumanPlayerByID(npcid);
            if (npc?.player != null && !npc.player.IsDestroyed)
                npc.player.KillMessage();
        }

        private bool hasAccess(BasePlayer player)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You don't have access to this command");
                return false;
            }
            return true;
        }

        private bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            if (player.serverInput?.current == null) return false;
            viewAngle = Quaternion.Euler(player.serverInput.current.aimAngles);
            return true;
        }

        private bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            Ray ray = new Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            for (var i = 0; i < hits.Length; i++)
            {
                var hit = hits[i];
                if (hit.collider.GetComponentInParent<TriggerBase>() == null && hit.distance < closestdist)
                {
                    closestdist = hit.distance;
                    closestEnt = hit.collider;
                    closestHitpoint = hit.point;
                }
            }

            if (closestEnt is bool) return false;
            return true;
        }

        private static bool CanSee(HumanPlayer npc, BaseEntity target)
        {
#if DEBUG
            Interface.Oxide.LogInfo($"CanSee(): {npc.transform.position} looking at {target.transform.position}");
#endif
            var source = npc.player;
            var weapon = source.GetActiveItem()?.GetHeldEntity() as BaseProjectile;
            var pos = source.transform.position + source.GetOffset();
            if(weapon?.MuzzlePoint != null)
            {
                pos += Quaternion.LookRotation(target.transform.position - source.transform.position) * weapon.MuzzlePoint.position;
#if DEBUG
                Interface.Oxide.LogInfo($"CanSee(): MuzzlePoint NULL");
#endif
            }
            else
            {
#if DEBUG
                Interface.Oxide.LogInfo($"CanSee(): MuzzlePoint NOT null");
#endif
            }

            if(Vector3.Distance(source.transform.position, target.transform.position) <  npc.info.damageDistance)
            {
#if DEBUG
                Interface.Oxide.LogInfo($"CanSee(): In range!");
#endif
                //if(!IsLayerBlocked(target.transform.position, npc.info.attackDistance, obstructionMask))
                if(!IsLayerBlocked(target.transform.position, 10f, obstructionMask))
                {
                    npc.Evade();
                }

                npc.LookTowards(target.transform.position);
                return true;
            }
            List<BasePlayer> nearPlayers = new List<BasePlayer>();
            Vis.Entities<BasePlayer>(pos, npc.info.maxDistance, nearPlayers, playerMask);
            foreach (var player in nearPlayers)
            {
                if (player == target)
                {
#if DEBUG
                    Interface.Oxide.LogInfo($"CanSee(): I can see them!");
#endif
                    //if(!IsLayerBlocked(target.transform.position, npc.info.attackDistance, obstructionMask))
                    if(!IsLayerBlocked(target.transform.position, 10f, obstructionMask))
                    {
                        npc.Evade();
                    }

                    npc.LookTowards(target.transform.position);
                    return true;
                }
            }
#if DEBUG
            Interface.Oxide.LogInfo($"CanSee(): NOPE");
#endif
            return false;
        }

        private static string GetRandomMessage(List<string> messagelist) => messagelist[GetRandom(0, messagelist.Count)];
        private static int GetRandom(int min, int max) => UnityEngine.Random.Range(min, max);

        private List<string> ListFromArgs(string[] args, int from)
        {
            var newlist = new List<string>();
            for (var i = from; i < args.Length; i++)
                newlist.Add(args[i]);
            return newlist;
        }

        //////////////////////////////////////////////////////////////////////////////
        /// Chat Commands
        //////////////////////////////////////////////////////////////////////////////
        [ChatCommand("npc_add")]
        private void cmdChatNPCAdd(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() != null)
            {
                SendReply(player, "NPC Editor: Already editing an NPC, say /npc_end first");
                return;
            }
            Quaternion currentRot;
            if (!TryGetPlayerView(player, out currentRot))
            {
                SendReply(player, "Couldn't get player rotation");
                return;
            }

            HumanPlayer humanPlayer;
            if (args.Length > 0)
            {
                ulong targetId;
                if (!ulong.TryParse(args[0], out targetId))
                {
                    SendReply(player, "/npc_add [TARGETID]");
                    return;
                }
                HumanNPCInfo tempInfo;
                if (!humannpcs.TryGetValue(targetId, out tempInfo))
                {
                    SendReply(player, "Couldn't find the NPC");
                    return;
                }
                humanPlayer = CreateNPC(player.transform.position, currentRot, "NPC", targetId);
            }
            else
                humanPlayer = CreateNPC(player.transform.position, currentRot);
            if (humanPlayer == null)
            {
                SendReply(player, "Couldn't spawn the NPC");
                return;
            }
            var npcEditor = player.gameObject.AddComponent<NPCEditor>();
            npcEditor.targetNPC = humanPlayer;
        }

        [ChatCommand("npc_way")]
        private void cmdChatNPCWay(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;

            HumanPlayer humanPlayer;
            if (args.Length == 0)
            {
                Quaternion currentRot;
                if (!TryGetPlayerView(player, out currentRot)) return;
                object closestEnt;
                Vector3 closestHitpoint;
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
                humanPlayer = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
                if (humanPlayer == null)
                {
                    SendReply(player, "This is not an NPC");
                    return;
                }
            }
            else if (args.Length > 0)
            {
                humanPlayer = FindHumanPlayer(args[0]);
                if (humanPlayer == null)
                {
                    ulong userid;
                    if (!ulong.TryParse(args[0], out userid))
                    {
                        SendReply(player, "/npc_way TargetId/Name");
                        return;
                    }
                    SpawnNPC(userid, true);
                    humanPlayer = FindHumanPlayerByID(userid);
                }
                if (humanPlayer == null)
                {
                    SendReply(player, "Couldn't Spawn the NPC");
                    return;
                }
            }
            else
            {
                SendReply(player, "You are not looking at an NPC or this userid doesn't exist");
                return;
            }
            if (humanPlayer.locomotion.cachedWaypoints == null)
            {
                SendReply(player, "The NPC has no waypoints");
                return;
            }
            var eyes = new Vector3(0, 1.6f, 0);
            var lastPos = humanPlayer.info.spawnInfo.position + eyes;
            for (var i = 0; i < humanPlayer.locomotion.cachedWaypoints.Count; i++)
            {
                var pos = humanPlayer.locomotion.cachedWaypoints[i].Position + eyes;
                //player.SendConsoleCommand("ddraw.sphere", 30f, Color.black, lastPos, .5f);
                player.SendConsoleCommand("ddraw.line", 30f, i % 2 == 0 ? Color.blue : Color.red, lastPos, pos);
                lastPos = pos;
            }
        }

        [ChatCommand("npc_edit")]
        private void cmdChatNPCEdit(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() != null)
            {
                SendReply(player, "NPC Editor: Already editing an NPC, say /npc_end first");
                return;
            }

            HumanPlayer humanPlayer;
            if (args.Length == 0)
            {
                Quaternion currentRot;
                if (!TryGetPlayerView(player, out currentRot)) return;
                object closestEnt;
                Vector3 closestHitpoint;
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
                humanPlayer = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
                if (humanPlayer == null)
                {
                    SendReply(player, "This is not an NPC");
                    return;
                }
            }
            else if (args.Length > 0)
            {
                humanPlayer = FindHumanPlayer(args[0]);
                if (humanPlayer == null)
                {
                    ulong userid;
                    if (!ulong.TryParse(args[0], out userid))
                    {
                        SendReply(player, "/npc_edit TargetId/Name");
                        return;
                    }
                    SpawnNPC(userid, true);
                    humanPlayer = FindHumanPlayerByID(userid);
                }
                if (humanPlayer == null)
                {
                    SendReply(player, "Couldn't Spawn the NPC");
                    return;
                }
            }
            else
            {
                SendReply(player, "You are not looking at an NPC or this userid doesn't exist");
                return;
            }

            var npceditor = player.gameObject.AddComponent<NPCEditor>();
            npceditor.targetNPC = humanPlayer;
            SendReply(player, $"NPC Editor: Start Editing {npceditor.targetNPC.player.displayName} - {npceditor.targetNPC.player.userID}");
        }

        [ChatCommand("npc_list")]
        private void cmdChatNPCList(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (humannpcs.Count == 0)
            {
                SendReply(player, "No NPC created yet");
                return;
            }

            SendReply(player, "==== NPCs ====");
            foreach (var pair in humannpcs) SendReply(player, $"{pair.Key} - {pair.Value.displayName} - {pair.Value.spawnInfo.ShortString()} {(pair.Value.enable ? "" : "- Disabled")}");
        }

        [ChatCommand("npc")]
        private void cmdChatNPC(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            var npcEditor = player.GetComponent<NPCEditor>();
            if (npcEditor == null)
            {
                SendReply(player, "NPC Editor: You need to be editing an NPC, say /npc_add or /npc_edit");
                return;
            }
            if (args.Length == 0)
            {
                SendReply(player, "<color=#81F781>/npc attackdistance</color><color=#F2F5A9> XXX </color>=> <color=#D8D8D8>Distance between him and the target needed for the NPC to ignore the target and go back to spawn</color>");
                SendReply(player, "<color=#81F781>/npc bye</color> reset/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=><color=#D8D8D8> Dont forgot the \", this is what NPC with say when a player gets away, multiple texts are possible</color>");
                SendReply(player, "<color=#81F781>/npc damageamount</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Damage done by that NPC when he hits a player</color>");
                SendReply(player, "<color=#81F781>/npc damagedistance</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Min distance for the NPC to hit a player (3 is default, maybe 20-30 needed for snipers?)</color>");
                SendReply(player, "<color=#81F781>/npc damageinterval</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>Time to wait before attacking again (2 seconds is default)</color>");
                SendReply(player, "<color=#81F781>/npc enable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color><color=#D8D8D8>Enable/Disable the NPC, maybe save it for later?</color>");
                SendReply(player, "<color=#81F781>/npc health</color> <color=#F2F5A9>XXX </color>=> <color=#D8D8D8>To set the Health of the NPC</color>");
                SendReply(player, "<color=#81F781>/npc hello</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=> <color=#D8D8D8>Dont forgot the \", this what will be said when the player gets close to the NPC</color>");
                SendReply(player, "<color=#81F781>/npc hostile</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it if the NPC is Hostile</color>");
                SendReply(player, "<color=#81F781>/npc hurt</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\"</color> => <color=#D8D8D8>Dont forgot the \", set a message to tell the player when he hurts the NPC</color>");
                SendReply(player, "<color=#81F781>/npc invulnerable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false </color>=> <color=#D8D8D8>To set the NPC invulnerable or not</color>");
                SendReply(player, "<color=#81F781>/npc kill</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\" </color>=> <color=#D8D8D8>Dont forgot the \", set a message to tell the player when he kills the NPC</color>");
                SendReply(player, "<color=#81F781>/npc kit</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"KitName\" </color>=> <color=#D8D8D8>To set the kit of this NPC, requires the Kit plugin</color>");
                SendReply(player, "<color=#81F781>/npc lootable</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it if the NPC corpse is lootable or not</color>");
                SendReply(player, "<color=#81F781>/npc maxdistance</color> <color=#F2F5A9>XXX </color>=><color=#D8D8D8> Max distance from the spawn point that the NPC can run from (while attacking a player)</color>");
                SendReply(player, "<color=#81F781>/npc name</color> <color=#F2F5A9>\"THE NAME\"</color> =><color=#D8D8D8> To set a name to the NPC</color>");
                SendReply(player, "<color=#81F781>/npc radius</color> <color=#F2F5A9>XXX</color> =><color=#D8D8D8> Radius of which the NPC will detect the player</color>");
                SendReply(player, "<color=#81F781>/npc respawn</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To set it to respawn on death after XX seconds, default is instant respawn</color>");
                SendReply(player, "<color=#81F781>/npc spawn</color> <color=#F2F5A9>\"new\" </color>=> <color=#D8D8D8>To set the new spawn location</color>");
                SendReply(player, "<color=#81F781>/npc speed</color><color=#F2F5A9> XXX </color>=> <color=#D8D8D8>To set the NPC running speed (while chasing a player)</color>");
                SendReply(player, "<color=#81F781>/npc stopandtalk</color> <color=#F2F5A9>true</color>/<color=#F6CECE>false</color> XX <color=#F2F5A9>XX </color>=> <color=#D8D8D8>To choose if the NPC should stop & look at the player that is talking to him</color>");
                SendReply(player, "<color=#81F781>/npc use</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"TEXT\" \"TEXT2\" \"TEXT3\"</color> => <color=#D8D8D8>Dont forgot the \", this what will be said when the player presses USE on the NPC</color>");
                SendReply(player, "<color=#81F781>/npc waypoints</color> <color=#F6CECE>reset</color>/<color=#F2F5A9>\"Waypoint list Name\" </color>=> <color=#D8D8D8>To set waypoints of an NPC, /npc_help for more information</color>");
                return;
            }
            var param = args[0].ToLower();
            if (args.Length == 1)
            {
                string message;
                switch (param)
                {
                    case "name":
                        message = $"This NPC name is: {npcEditor.targetNPC.info.displayName}";
                        break;
                    case "enable":
                    case "enabled":
                        message = $"This NPC enabled: {npcEditor.targetNPC.info.enable}";
                        break;
                    case "invulnerable":
                    case "invulnerability":
                        message = $"This NPC invulnerability is set to: {npcEditor.targetNPC.info.invulnerability}";
                        break;
                    case "lootable":
                        message = $"This NPC lootable is set to: {npcEditor.targetNPC.info.lootable}";
                        break;
                    case "hostile":
                        message = $"This NPC hostility is set to: {npcEditor.targetNPC.info.hostile}";
                        break;
                    case "defend":
                        message = $"This NPC defend is set to: {npcEditor.targetNPC.info.defend}";
                        break;
                    case "evade":
                        message = $"This NPC evade is set to: {npcEditor.targetNPC.info.evade}";
                        break;
                    case "evdist":
                        message = $"This NPC evade distance is set to: {npcEditor.targetNPC.info.evade}";
                        break;
                    case "allowsit":
                        message = $"This NPC allowsit is set to: {npcEditor.targetNPC.info.allowsit}";
                        break;
                    case "needsammo":
                        message = $"This NPC needsAmmo is set to: {npcEditor.targetNPC.info.needsAmmo}";
                        break;
                    case "health":
                        message = $"This NPC Initial health is set to: {npcEditor.targetNPC.info.health}";
                        break;
                    case "attackdistance":
                        message = $"This Max Attack Distance is: {npcEditor.targetNPC.info.attackDistance}";
                        break;
                    case "damageamount":
                        message = $"This Damage amount is: {npcEditor.targetNPC.info.damageAmount}";
                        break;
                    case "damageinterval":
                        message = $"This Damage interval is: {npcEditor.targetNPC.info.damageInterval} seconds";
                        break;
                    case "maxdistance":
                        message = $"The Max Distance from spawn is: {npcEditor.targetNPC.info.maxDistance}";
                        break;
                    case "damagedistance":
                        message = $"This Damage distance is: {npcEditor.targetNPC.info.damageDistance}";
                        break;
                    case "radius":
                        message = $"This NPC Collision radius is set to: {npcEditor.targetNPC.info.collisionRadius}";
                        break;
                    case "respawn":
                        message = $"This NPC Respawn is set to: {npcEditor.targetNPC.info.respawn} after {npcEditor.targetNPC.info.respawnSeconds} seconds";
                        break;
                    case "spawn":
                        message = $"This NPC Spawn is set to: {npcEditor.targetNPC.info.spawnInfo.String()}";
                        break;
                    case "speed":
                        message = $"This NPC Chasing speed is: {npcEditor.targetNPC.info.speed}";
                        break;
                    case "stopandtalk":
                        message = $"This NPC stop to talk is set to: {npcEditor.targetNPC.info.stopandtalk} for {npcEditor.targetNPC.info.stopandtalkSeconds} seconds";
                        break;
                    case "waypoints":
                    case "waypoint":
                        message = string.IsNullOrEmpty(npcEditor.targetNPC.info.waypoint) ? "No waypoints set for this NPC yet" : $"This NPC waypoints are: {npcEditor.targetNPC.info.waypoint}";
                        break;
                    case "kit":
                    case "kits":
                        message = string.IsNullOrEmpty(npcEditor.targetNPC.info.spawnkit) ? "No spawn kits set for this NPC yet" : $"This NPC spawn kit is: {npcEditor.targetNPC.info.spawnkit}";
                        break;
                    case "hello":
                        if (npcEditor.targetNPC.info.message_hello == null || (npcEditor.targetNPC.info.message_hello.Count == 0))
                            message = "No hello message set yet";
                        else
                            message = $"This NPC will say hi: {npcEditor.targetNPC.info.message_hello.Count} different messages";
                        break;
                    case "bye":
                        if (npcEditor.targetNPC.info.message_bye == null || npcEditor.targetNPC.info.message_bye.Count == 0)
                            message = "No bye message set yet";
                        else
                            message = $"This NPC will say bye: {npcEditor.targetNPC.info.message_bye.Count} difference messages ";
                        break;
                    case "use":
                        if (npcEditor.targetNPC.info.message_use == null || npcEditor.targetNPC.info.message_use.Count == 0)
                            message = "No bye message set yet";
                        else
                            message = $"This NPC will say bye: {npcEditor.targetNPC.info.message_use.Count} different messages";
                        break;
                    case "hurt":
                        if (npcEditor.targetNPC.info.message_hurt == null || npcEditor.targetNPC.info.message_hurt.Count == 0)
                            message = "No hurt message set yet";
                        else
                            message = $"This NPC will say ouch: {npcEditor.targetNPC.info.message_hurt.Count} different messages";
                        break;
                    case "kill":
                        if (npcEditor.targetNPC.info.message_kill == null || npcEditor.targetNPC.info.message_kill.Count == 0)
                            message = "No kill message set yet";
                        else
                            message = $"This NPC will say a death message: {npcEditor.targetNPC.info.message_kill.Count} different messages";
                        break;
                    case "hitchance":
                        message = $"This NPC hit chance is: {npcEditor.targetNPC.info.hitchance}";
                        break;
                    case "reloadduration":
                        message = $"This NPC reload duration is: {npcEditor.targetNPC.info.reloadDuration}";
                        break;
                    case "stand":
                        message = $"Standing!";
                        npcEditor.targetNPC.info.allowsit = false;
                        npcEditor.targetNPC.locomotion.Stand();
                        break;
                //    case "sit":
                //        message = $"Sitting!";
                //        npcEditor.targetNPC.info.allowsit = true;
                //        npcEditor.targetNPC.locomotion.Sit();
                //        break;
                    case "info":
                        message = $" {npcEditor.targetNPC.info.displayName}\n"
                            + $"\tenabled: {npcEditor.targetNPC.info.enable}\n"
                            + $"\tinvulnerability: {npcEditor.targetNPC.info.invulnerability}\n"
                            + $"\tlootable: {npcEditor.targetNPC.info.lootable}\n"
                            + $"\thostility: {npcEditor.targetNPC.info.hostile}\n"
                            + $"\tdefend: {npcEditor.targetNPC.info.defend}\n"
                            + $"\tevade: {npcEditor.targetNPC.info.evade}\n"
                            + $"\tevdist: {npcEditor.targetNPC.info.evdist}\n"
                            + $"\tallowsit: {npcEditor.targetNPC.info.allowsit}\n"
                            + $"\tsitting: {npcEditor.targetNPC.locomotion.sitting}\n"
                            + $"\tneedsAmmo: {npcEditor.targetNPC.info.needsAmmo}\n"
                            + $"\tinitial health: {npcEditor.targetNPC.info.health}\n"
                            + $"\tmax attack distance: {npcEditor.targetNPC.info.attackDistance}\n"
                            + $"\tdamage amount: {npcEditor.targetNPC.info.damageAmount}\n"
                            + $"\tdamage interval: {npcEditor.targetNPC.info.damageInterval} seconds\n"
                            + $"\tmax Distance from spawn: {npcEditor.targetNPC.info.maxDistance}\n"
                            + $"\tdamage distance: {npcEditor.targetNPC.info.damageDistance}\n"
                            + $"\tcollision radius: {npcEditor.targetNPC.info.collisionRadius}\n"
                            + $"\trespawn: {npcEditor.targetNPC.info.respawn} after {npcEditor.targetNPC.info.respawnSeconds} seconds\n"
                            + $"\tspawn:\n\t\t{npcEditor.targetNPC.info.spawnInfo.String()}\n"
                            + $"\tchasing speed: {npcEditor.targetNPC.info.speed}\n"
                            + $"\tstop to talk: {npcEditor.targetNPC.info.stopandtalk} for {npcEditor.targetNPC.info.stopandtalkSeconds} seconds\n";
                        if(npcEditor.targetNPC.info.waypoint == null)
                        {
                            message += "\tNo waypoints";
                        }
                        else
                        {
                            message += $"\twaypoints: {npcEditor.targetNPC.info.waypoint}\n";
                        }
                        if(npcEditor.targetNPC.info.spawnkit == null)
                        {
                            message += "\tNo kits\n";
                        }
                        else
                        {
                            message += $"\tspawn kit: {npcEditor.targetNPC.info.spawnkit}\n";
                        }
                        if (npcEditor.targetNPC.info.message_hello == null || (npcEditor.targetNPC.info.message_hello.Count == 0))
                        {
                            message += "\tNo hello message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say hi: {npcEditor.targetNPC.info.message_hello.Count} different messages\n";
                        }
                        if (npcEditor.targetNPC.info.message_bye == null || npcEditor.targetNPC.info.message_bye.Count == 0)
                        {
                            message += "\tNo bye message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say bye: {npcEditor.targetNPC.info.message_bye.Count} difference messages\n";
                        }
                        if (npcEditor.targetNPC.info.message_use == null || npcEditor.targetNPC.info.message_use.Count == 0)
                        {
                            message += "\tNo bye message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say bye: {npcEditor.targetNPC.info.message_use.Count} different messages\n";
                        }
                        if (npcEditor.targetNPC.info.message_hurt == null || npcEditor.targetNPC.info.message_hurt.Count == 0)
                        {
                            message += "\tNo hurt message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say ouch: {npcEditor.targetNPC.info.message_hurt.Count} different messages\n";
                        }
                        if (npcEditor.targetNPC.info.message_kill == null || npcEditor.targetNPC.info.message_kill.Count == 0)
                        {
                            message += "\tNo kill message set yet\n";
                        }
                        else
                        {
                            message += $"\twill say a death message: {npcEditor.targetNPC.info.message_kill.Count} different messages\n";
                        }
                        message += $"\thit chance: {npcEditor.targetNPC.info.hitchance}\n";
                        message += $"\treload duration: {npcEditor.targetNPC.info.reloadDuration}\n";

                        SendReply(player, $"NPC Info: {message}\n\n");
                        break;
                    default:
                        message = "Wrong Argument.  /npc for more information.";
                        break;
                }
                SendReply(player, message);
                return;
            }
            switch (param)
            {
                case "name":
                    npcEditor.targetNPC.info.displayName = args[1];
                    break;
                case "enable":
                case "enabled":
                    npcEditor.targetNPC.info.enable = GetBoolValue(args[1]);
                    break;
                case "invulnerable":
                case "invulnerability":
                    npcEditor.targetNPC.info.invulnerability = GetBoolValue(args[1]);
                    break;
                case "lootable":
                    npcEditor.targetNPC.info.lootable = GetBoolValue(args[1]);
                    break;
                case "hostile":
                    npcEditor.targetNPC.info.hostile = GetBoolValue(args[1]);
                    break;
                case "defend":
                    npcEditor.targetNPC.info.defend = GetBoolValue(args[1]);
                    break;
                case "evade":
                    npcEditor.targetNPC.info.evade = GetBoolValue(args[1]);
                    break;
                case "evdist":
                    npcEditor.targetNPC.info.evdist = Convert.ToSingle(args[1]);
                    break;
                case "allowsit":
                    npcEditor.targetNPC.info.allowsit = GetBoolValue(args[1]);
                    break;
                case "needsammo":
                    npcEditor.targetNPC.info.needsAmmo = GetBoolValue(args[1]);
                    break;
                case "health":
                    npcEditor.targetNPC.info.health = Convert.ToSingle(args[1]);
                    break;
                case "attackdistance":
                    npcEditor.targetNPC.info.attackDistance = Convert.ToSingle(args[1]);
                    break;
                case "damageamount":
                    npcEditor.targetNPC.info.damageAmount = Convert.ToSingle(args[1]);
                    break;
                case "damageinterval":
                    npcEditor.targetNPC.info.damageInterval = Convert.ToSingle(args[1]);
                    break;
                case "maxdistance":
                    npcEditor.targetNPC.info.maxDistance = Convert.ToSingle(args[1]);
                    break;
                case "damagedistance":
                    npcEditor.targetNPC.info.damageDistance = Convert.ToSingle(args[1]);
                    break;
                case "radius":
                    npcEditor.targetNPC.info.collisionRadius = Convert.ToSingle(args[1]);
                    break;
                case "respawn":
                    npcEditor.targetNPC.info.respawn = GetBoolValue(args[1]);
                    npcEditor.targetNPC.info.respawnSeconds = 60;
                    if (args.Length > 2)
                        npcEditor.targetNPC.info.respawnSeconds = Convert.ToSingle(args[2]);
                    break;
                case "spawn":
                    Quaternion currentRot;
                    TryGetPlayerView(player, out currentRot);
                    var newSpawn = new SpawnInfo(player.transform.position, currentRot);
                    npcEditor.targetNPC.info.spawnInfo = newSpawn;
                    SendReply(player, $"This NPC Spawn now is set to: {newSpawn.String()}");
                    break;
                case "speed":
                    npcEditor.targetNPC.info.speed = Convert.ToSingle(args[1]);
                    break;
                case "stopandtalk":
                    npcEditor.targetNPC.info.stopandtalk = GetBoolValue(args[1]);
                    npcEditor.targetNPC.info.stopandtalkSeconds = 3;
                    if (args.Length > 2)
                        npcEditor.targetNPC.info.stopandtalkSeconds = Convert.ToSingle(args[2]);
                    break;
                case "waypoints":
                case "waypoint":
                    var name = args[1].ToLower();
                    if (name == "reset")
                        npcEditor.targetNPC.info.waypoint = null;
                    else if (Interface.Oxide.CallHook("GetWaypointsList", name) == null)
                    {
                        SendReply(player, "This waypoint doesn't exist");
                        return;
                    }
                    else npcEditor.targetNPC.info.waypoint = name;
                    break;
                case "kit":
                case "kits":
                    npcEditor.targetNPC.info.spawnkit = args[1].ToLower();
                    break;
                case "hello":
                    npcEditor.targetNPC.info.message_hello = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "bye":
                    npcEditor.targetNPC.info.message_bye = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "use":
                    npcEditor.targetNPC.info.message_use = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "hurt":
                    npcEditor.targetNPC.info.message_hurt = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "kill":
                    npcEditor.targetNPC.info.message_kill = args[1] == "reset" ? new List<string>() : ListFromArgs(args, 1);
                    break;
                case "hitchance":
                    npcEditor.targetNPC.info.hitchance = Convert.ToSingle(args[1]);
                    break;
                case "reloadduration":
                    npcEditor.targetNPC.info.reloadDuration = Convert.ToSingle(args[1]);
                    break;
                default:
                    SendReply(player, "Wrong Argument, /npc for more information");
                    return;
            }
            SendReply(player, $"NPC Editor: Set {args[0]} to {args[1]}");
            save = true;
            RefreshNPC(npcEditor.targetNPC.player, true);
        }

        [ChatCommand("npc_end")]
        private void cmdChatNPCEnd(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            var npcEditor = player.GetComponent<NPCEditor>();
            if (npcEditor == null)
            {
                SendReply(player, "NPC Editor: You are not editing any NPC");
                return;
            }
            if (!npcEditor.targetNPC.info.enable)
            {
                npcEditor.targetNPC.player.KillMessage();
                SendReply(player, "NPC Editor: The NPC you edited is disabled, killing him");
            }
            UnityEngine.Object.Destroy(npcEditor);
            SendReply(player, "NPC Editor: Ended");
        }

        [ChatCommand("npc_pathtest")]
        private void cmdChatNPCPathTest(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            var npcEditor = player.GetComponent<NPCEditor>();
            if (npcEditor == null)
            {
                SendReply(player, "NPC Editor: You are not editing any NPC");
                return;
            }
            Quaternion currentRot;
            if (!TryGetPlayerView(player, out currentRot)) return;
            object closestEnt;
            Vector3 closestHitpoint;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
            Interface.Oxide.CallHook("FindAndFollowPath", npcEditor.targetNPC.player, npcEditor.targetNPC.player.transform.position, closestHitpoint);
        }

        [ChatCommand("npc_remove")]
        private void cmdChatNPCRemove(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;

            HumanPlayer humanPlayer;
            if (args.Length == 0)
            {
                Quaternion currentRot;
                if (!TryGetPlayerView(player, out currentRot)) return;
                object closestEnt;
                Vector3 closestHitpoint;
                if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return;
                humanPlayer = ((Collider)closestEnt).GetComponentInParent<HumanPlayer>();
                if (humanPlayer == null)
                {
                    SendReply(player, "This is not an NPC");
                    return;
                }
            }
            else if (args.Length > 0)
            {
                ulong userid;
                if (!ulong.TryParse(args[0], out userid))
                {
                    SendReply(player, "/npc_remove TARGETID");
                    return;
                }
                humanPlayer = FindHumanPlayerByID(userid);
                if (humanPlayer == null)
                {
                    SendReply(player, "This NPC doesn't exist");
                    return;
                }
            }
            else
            {
                SendReply(player, "You are not looking at an NPC or this userid doesn't exist");
                return;
            }

            var targetid = humanPlayer.player.userID;
            RemoveNPC(targetid);
            SendReply(player, $"NPC {targetid} Removed");
        }

        [ChatCommand("npc_reset")]
        private void cmdChatNPCReset(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) return;
            if (player.GetComponent<NPCEditor>() != null) UnityEngine.Object.Destroy(player.GetComponent<NPCEditor>());
            cache.Clear();
            humannpcs.Clear();
            storedData.HumanNPCs.Clear();
            save = true;
            SendReply(player, "All NPCs were removed");
            OnServerInitialized();
        }

        private void SendMessage(HumanPlayer npc, BasePlayer target, string message)
        {
            if (Time.realtimeSinceStartup > npc.lastMessage + 0.1f)
            {
                SendReply(target, $"{chat}{message}", npc.player.displayName);
                npc.lastMessage = Time.realtimeSinceStartup;
            }
        }

        //////////////////////////////////////////////////////
        // NPC HOOKS:
        // will call ALL plugins
        //////////////////////////////////////////////////////

        //////////////////////////////////////////////////////
        /// OnHitNPC(BasePlayer npc, HitInfo hinfo)
        /// called when an NPC gets hit
        //////////////////////////////////////////////////////
        /*void OnHitNPC(BasePlayer npc, HitInfo hinfo)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnUseNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player press USE while looking at the NPC (5m max)
        //////////////////////////////////////////////////////
        /*void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnEnterNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player gets close to an NPC (default is in 10m radius)
        //////////////////////////////////////////////////////
        private void OnEnterNPC(BasePlayer npc, BasePlayer player)
        {
            if (player.userID < 76560000000000000L) return;
            var humanPlayer = npc.GetComponent<HumanPlayer>();
            if (humanPlayer.info.message_hello != null && humanPlayer.info.message_hello.Count > 0)
            {
                SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_hello));
            }
            if(humanPlayer.info.hostile && player.GetComponent<NPCEditor>() == null && !(bool)(Vanish?.CallHook("IsInvisible", player) ?? false))
            {
                if(humanPlayer.locomotion.sitting)
                {
                    humanPlayer.locomotion.Stand();
                    humanPlayer.locomotion.Evade();
                }
                humanPlayer.StartAttackingEntity(player);
            }
        }

        //////////////////////////////////////////////////////
        ///  OnLeaveNPC(BasePlayer npc, BasePlayer player)
        ///  called when a player gets away from an NPC
        //////////////////////////////////////////////////////
        private void OnLeaveNPC(BasePlayer npc, BasePlayer player)
        {
            if (player.userID < 76560000000000000L) return;
            var humanPlayer = npc.GetComponent<HumanPlayer>();
            if (humanPlayer.info.message_bye != null && humanPlayer.info.message_bye.Count > 0)
            {
                SendMessage(humanPlayer, player, GetRandomMessage(humanPlayer.info.message_bye));
            }
        }

        //////////////////////////////////////////////////////
        ///  OnKillNPC(BasePlayer npc, HitInfo hinfo)
        ///  called when an NPC gets killed
        //////////////////////////////////////////////////////
        /*void OnKillNPC(BasePlayer npc, HitInfo hinfo)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnNPCPosition(BasePlayer npc, Vector3 pos)
        ///  Called when an npc reachs a position
        //////////////////////////////////////////////////////
        /*void OnNPCPosition(BasePlayer npc, Vector3 pos)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnNPCRespawn(BasePlayer npc)
        ///  Called when an NPC respawns
        ///  here it will give an NPC a kit and set the first tool in the belt as the active weapon
        //////////////////////////////////////////////////////
        /*void OnNPCRespawn(BasePlayer npc)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnNPCStartAttacking(BasePlayer npc, BaseEntity target)
        ///  Called when an NPC start to target someone to attack
        ///  return anything will block the attack
        //////////////////////////////////////////////////////
        /*object OnNPCStartTarget(BasePlayer npc, BaseEntity target)
        {
            return null;
        }*/
        //////////////////////////////////////////////////////
        ///  OnNPCStopTarget(BasePlayer npc, BaseEntity target)
        ///  Called when an NPC stops targetting
        ///  no return;
        //////////////////////////////////////////////////////
        /*void OnNPCStopTarget(BasePlayer npc, BaseEntity target)
        {
        }*/

        //////////////////////////////////////////////////////
        ///  OnLootNPC(PlayerLoot loot, BaseEntity target, string npcuserID)
        ///  Called when an NPC gets looted
        ///  no return;
        //////////////////////////////////////////////////////
        /*void OnLootNPC(PlayerLoot loot, BaseEntity target, ulong npcuserID)
        {
        }*/

        private class UnityQuaternionConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var quaternion = (Quaternion)value;
                writer.WriteValue($"{quaternion.x} {quaternion.y} {quaternion.z} {quaternion.w}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Quaternion(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]), Convert.ToSingle(values[3]));
                }
                var o = JObject.Load(reader);
                return new Quaternion(Convert.ToSingle(o["rx"]), Convert.ToSingle(o["ry"]), Convert.ToSingle(o["rz"]), Convert.ToSingle(o["rw"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Quaternion);
            }
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                var vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    var values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                var o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }

        private class SpawnInfoConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var o = JObject.Load(reader);
                Vector3 position;
                Quaternion rotation;
                if (o["position"] != null)
                {
                    var values = Convert.ToString(o["position"]).Trim().Split(' ');
                    position = new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                    values = Convert.ToString(o["rotation"]).Trim().Split(' ');
                    rotation = new Quaternion(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]), Convert.ToSingle(values[3]));
                }
                else
                {
                    position = new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
                    rotation = new Quaternion(Convert.ToSingle(o["rx"]), Convert.ToSingle(o["ry"]), Convert.ToSingle(o["rz"]), Convert.ToSingle(o["rw"]));
                }
                return new SpawnInfo(position, rotation);
            }

            public override bool CanWrite => false;

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(SpawnInfo);
            }
        }
    }
}


// --- End of file: HumanNPC.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AdminTime.cs ---
// --- Original Local Path: AdminTime.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System;
using Newtonsoft.Json;
using System.Linq;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("Admin Time", "Rustic", "1.1.0")]
    [Description("Allows admins to use /day, /night, and /now to change their local time in game.")]

    internal class AdminTime : RustPlugin
    {
        #region General

        const string permAllowTimeChange = "AdminTime.use";

        void Init()
        {
            permission.RegisterPermission(permAllowTimeChange, this);
        }
        
        #endregion

        #region Config
        
        // Config Creation
		private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Day Value")]
            public int DayValue = 12;

            [JsonProperty(PropertyName = "Night Value")]
            public int NightValue = 1;
            
            public string ToJson() => JsonConvert.SerializeObject(this);
            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    throw new JsonException();
                }
                if (!configData.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("Configuration File invalid or outdated. Updated.");
                    SaveConfig();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating Config File");
            configData = new ConfigData();
        }

        #endregion

        #region Commands

        [ChatCommand("day")]
        private void DayCommand(BasePlayer player)
        {
            ChangeTime(player, configData.DayValue);
        }

        [ChatCommand("night")]
        private void NightCommand(BasePlayer player)
        {
            ChangeTime(player, configData.NightValue);
        }

        [ChatCommand("now")]
        private void NowCommand(BasePlayer player)
        {
            ChangeTime(player, -1);
        }

        [ChatCommand("time")]
        private void TimeCommand(BasePlayer player, string command, string[] args)
        {
            int timevalue = Convert.ToInt32(args[0]);

            if (player.IsAdmin == false && !permission.UserHasPermission(player.UserIDString, permAllowTimeChange))
            {
                SendReply(player, "Permission Denied.");
            } 

            if (player.IsAdmin == true || permission.UserHasPermission(player.UserIDString, permAllowTimeChange))
            {
                if (timevalue > 23 | timevalue < 0)
                {
                    SendReply(player, "Invalid Time, please use 1-23");
                } else {
                    ChangeTime(player, timevalue);
                }
            }
        }

        void ChangeTime(BasePlayer player, int timevalue)
        {
            if (player.IsAdmin == false && !permission.UserHasPermission(player.UserIDString, permAllowTimeChange))
            {
                SendReply(player, "Permission Denied.");
            } 

            if (player.IsAdmin == true || permission.UserHasPermission(player.UserIDString, permAllowTimeChange))
            {
                if (player.IsAdmin == true) { player.SendConsoleCommand("admintime", timevalue); }

                if (player.IsAdmin == false && permission.UserHasPermission(player.UserIDString, permAllowTimeChange)) 
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true); 
                    player.SendNetworkUpdateImmediate();
                    player.SendConsoleCommand("admintime", timevalue); 
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false); 
                    player.SendNetworkUpdateImmediate();
                }
            }
        }

        #endregion
    }
}

// --- End of file: AdminTime.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoDecay.cs ---
// --- Original Local Path: AutoDecay.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Decay", "Hougan/Arainrr", "1.3.1")]
    [Description("Auto damage to objects, that are not in building zone")]
    public class AutoDecay : RustPlugin
    {
        #region Fields

        private const string PERMISSION_IGNORE = "autodecay.ignore";
        private readonly Hash<ulong, float> notifyPlayers = new Hash<ulong, float>();
        private readonly Dictionary<ulong, DecayController> decayControllers = new Dictionary<ulong, DecayController>();

        private readonly List<string> defaultDisabled = new List<string>
        {
            "small_stash_deployed",
            "sleepingbag_leather_deployed",
        };

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            Unsubscribe(nameof(OnEntitySpawned));
            permission.RegisterPermission(PERMISSION_IGNORE, this);
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
            UpdateConfig(_config.entityS.Count <= 0);
            foreach (var baseNetworkable in BaseNetworkable.serverEntities.OfType<BaseCombatEntity>())
            {
                if (baseNetworkable != null)
                    CreateDecayController(baseNetworkable);
            }

            foreach (var entry in _config.entityS)
            {
                if (!storedData.entityShortPrefabNames.Contains(entry.Key))
                    PrintError($"\"{entry.Key}\" is an invalid combat entity short prefab name, Please get them in the data file");
            }
        }

        private void Unload()
        {
            foreach (var decayController in decayControllers.Values)
                decayController?.Destroy();

            _config = null;
        }

        private void OnEntitySpawned(BaseCombatEntity baseCombatEntity)
        {
            if (baseCombatEntity == null || baseCombatEntity.net == null) return;
            var buildingPrivlidge = baseCombatEntity as BuildingPrivlidge;
            if (buildingPrivlidge != null)
                HandleCupboard(buildingPrivlidge, true);
            var player = baseCombatEntity.OwnerID.IsSteamId() ? BasePlayer.FindByID(baseCombatEntity.OwnerID) : null;
            CreateDecayController(baseCombatEntity, player, false);
        }

        //private void OnEntityDeath(BaseCombatEntity baseCombatEntity, HitInfo info) => OnEntityKill(baseCombatEntity);

        private void OnEntityKill(BaseCombatEntity baseCombatEntity)
        {
            if (baseCombatEntity == null || baseCombatEntity.net == null) return;
            var buildingPrivlidge = baseCombatEntity as BuildingPrivlidge;
            if (buildingPrivlidge != null)
                HandleCupboard(buildingPrivlidge, false);

            DecayController decayController;
            if (decayControllers.TryGetValue(baseCombatEntity.net.ID.Value, out decayController))
            {
                decayController?.Destroy();
                decayControllers.Remove(baseCombatEntity.net.ID.Value);
            }
        }

        private void OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum newGrade)
        {
            if (buildingBlock == null || buildingBlock.net == null) return;
            var grade = buildingBlock.grade;
            NextTick(() =>
            {
                if (buildingBlock == null || buildingBlock.net == null) return;
                if (grade == buildingBlock.grade) return;
                var settings = GetBuildingBlockSettings(buildingBlock);
                if (IsDecayEnabled(settings, buildingBlock))
                {
                    DecayController decayController;
                    if (!decayControllers.TryGetValue(buildingBlock.net.ID.Value, out decayController))
                    {
                        decayController = new DecayController(buildingBlock, settings, false);
                        decayControllers.Add(buildingBlock.net.ID.Value, decayController);
                    }
                    else
                        decayController?.OnBuildingUpgrade(settings);
                }
                else
                {
                    DecayController decayController;
                    if (decayControllers.TryGetValue(buildingBlock.net.ID.Value, out decayController))
                    {
                        decayController?.Destroy();
                        decayControllers.Remove(buildingBlock.net.ID.Value);
                    }
                }
            });
        }

        #endregion Oxide Hooks

        #region Methods

        private void HandleCupboard(BuildingPrivlidge buildingPrivlidge, bool spawned)
        {
            var decayEntities = buildingPrivlidge?.GetBuilding()?.decayEntities;
            if (decayEntities != null)
            {
                //Only check the same building
                foreach (var decayEntity in decayEntities)
                {
                    if (decayEntity == null || decayEntity.net == null) continue;
                    if (decayEntity == buildingPrivlidge) continue;
                    DecayController decayController;
                    if (decayControllers.TryGetValue(decayEntity.net.ID.Value, out decayController))
                    {
                        if (spawned) decayController?.OnCupboardPlaced();
                        else decayController?.OnCupboardDestroyed();
                    }
                }
            }
        }

        private void UpdateConfig(bool newConfig)
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var prefabName = itemDefinition.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
                if (string.IsNullOrEmpty(prefabName)) continue;
                var baseCombatEntity = GameManager.server.FindPrefab(prefabName)?.GetComponent<BaseCombatEntity>();
                if (baseCombatEntity == null || string.IsNullOrEmpty(baseCombatEntity.ShortPrefabName)) continue;
                if (_config.entityS.ContainsKey(baseCombatEntity.ShortPrefabName)) continue;

                _config.entityS.Add(baseCombatEntity.ShortPrefabName, new DecaySettings
                {
                    enabled = newConfig && !(itemDefinition.category == ItemCategory.Food || defaultDisabled.Contains(baseCombatEntity.ShortPrefabName))
                });
            }
            UpdateData(true, _config.buildingBlockS.Count <= 0);
            SaveConfig();
        }

        private void UpdateData(bool updateConfig = false, bool newConfig = false)
        {
            var grades = new[] { BuildingGrade.Enum.Twigs, BuildingGrade.Enum.Wood, BuildingGrade.Enum.Stone, BuildingGrade.Enum.Metal, BuildingGrade.Enum.TopTier };

            storedData.entityShortPrefabNames.Clear();
            foreach (var prefab in GameManifest.Current.entities)
            {
                var baseCombatEntity = GameManager.server.FindPrefab(prefab)?.GetComponent<BaseCombatEntity>();
                if (baseCombatEntity == null || string.IsNullOrEmpty(baseCombatEntity.ShortPrefabName)) continue;
                storedData.entityShortPrefabNames.Add(baseCombatEntity.ShortPrefabName);
                if (updateConfig)
                {
                    if (baseCombatEntity is BaseVehicle)
                    {
                        if (!_config.entityS.ContainsKey(baseCombatEntity.ShortPrefabName))
                        {
                            _config.entityS.Add(baseCombatEntity.ShortPrefabName, new DecaySettings { enabled = newConfig });
                        }
                    }

                    if (baseCombatEntity is BuildingBlock)
                    {
                        _config.entityS.Remove(baseCombatEntity.ShortPrefabName);
                        Dictionary<BuildingGrade.Enum, DecaySettings> settings;
                        if (!_config.buildingBlockS.TryGetValue(baseCombatEntity.ShortPrefabName, out settings))
                        {
                            settings = new Dictionary<BuildingGrade.Enum, DecaySettings>();
                            _config.buildingBlockS.Add(baseCombatEntity.ShortPrefabName, settings);
                        }

                        foreach (var grade in grades)
                        {
                            if (!settings.ContainsKey(grade))
                            {
                                settings.Add(grade, new DecaySettings { enabled = newConfig });
                            }
                        }
                    }
                }
            }
            SaveData();
        }

        private void CreateDecayController(BaseCombatEntity baseCombatEntity, BasePlayer player = null, bool init = true)
        {
            if (baseCombatEntity == null || baseCombatEntity.net == null) return;
            if (baseCombatEntity.OwnerID.IsSteamId() && permission.UserHasPermission(baseCombatEntity.OwnerID.ToString(), PERMISSION_IGNORE)) return;
            var decayEntityS = GetDecayEntitySettings(baseCombatEntity);
            if (IsDecayEnabled(decayEntityS, baseCombatEntity))
            {
                if (!decayControllers.ContainsKey(baseCombatEntity.net.ID.Value))
                {
                    decayControllers.Add(baseCombatEntity.net.ID.Value, new DecayController(baseCombatEntity, decayEntityS, init));
                    if (_config.notifyPlayer && player != null && baseCombatEntity.GetBuildingPrivilege() == null)
                        SendMessage(player, decayEntityS.delayTime + decayEntityS.destroyTime);
                }
            }
        }

        private void SendMessage(BasePlayer player, float time)
        {
            float value;
            if (notifyPlayers.TryGetValue(player.userID, out value) && Time.realtimeSinceStartup - value <= _config.notifyInterval) return;
            notifyPlayers[player.userID] = Time.realtimeSinceStartup;
            Print(player, Lang("DESTROY", player.UserIDString, TimeSpan.FromSeconds(time).ToShortString()));
        }

        private static DecaySettings GetDecayEntitySettings(BaseCombatEntity baseCombatEntity)
        {
            var buildingBlock = baseCombatEntity as BuildingBlock;
            if (buildingBlock != null)
            {
                return GetBuildingBlockSettings(buildingBlock);
            }
            DecaySettings decaySettings;
            return _config.entityS.TryGetValue(baseCombatEntity.ShortPrefabName, out decaySettings) ? decaySettings : null;
        }

        private static DecaySettings GetBuildingBlockSettings(BuildingBlock buildingBlock)
        {
            Dictionary<BuildingGrade.Enum, DecaySettings> buildingSettings;
            if (_config.buildingBlockS.TryGetValue(buildingBlock.ShortPrefabName, out buildingSettings))
            {
                DecaySettings settings;
                if (buildingSettings.TryGetValue(buildingBlock.grade, out settings))
                {
                    return settings;
                }
            }
            return null;
        }

        private static bool IsDecayEnabled(DecaySettings decaySettings, BaseEntity entity)
        {
            return decaySettings != null && decaySettings.enabled && (!decaySettings.onlyOwned || entity.OwnerID.IsSteamId());
        }

        #endregion Methods

        #region DestroyControl

        private class DecayController
        {
            private enum State
            {
                None,
                Delaying,
                Decaying,
            }

            private BaseCombatEntity entity;
            private DecaySettings decaySettings;

            private State state;
            private float tickDamage;
            private bool isCupboard;

            public DecayController(BaseCombatEntity entity, DecaySettings decaySettings, bool init)
            {
                this.entity = entity;
                this.decaySettings = decaySettings;
                isCupboard = entity is BuildingPrivlidge;
                entity.InvokeRepeating(CheckBuildingPrivilege, init ? UnityEngine.Random.Range(0f, 60f) : 1f, _config.cupboardCheckTime);
            }

            private void CheckBuildingPrivilege()
            {
                if (entity == null || entity.IsDestroyed)
                {
                    Destroy();
                    return;
                }

                if (isCupboard ? OnFoundation() : HasBuildingPrivilege())
                {
                    StopDamage();
                    return;
                }
                StartDelay();
            }

            private bool HasBuildingPrivilege()
            {
                var buildingPrivlidge = entity.GetBuildingPrivilege();
                if (buildingPrivlidge == null) return false;
                if (_config.checkEmptyCupboard)
                    return buildingPrivlidge.GetProtectedMinutes() > 0f;
   
                return true;

            }

            private bool OnFoundation()
            {
                RaycastHit raycastHit;
                return Physics.Raycast(entity.transform.position + Vector3.up * 0.1f, Vector3.down, out raycastHit, 0.11f, Rust.Layers.Mask.Construction) && raycastHit.GetEntity() is BuildingBlock;
            }

            private void StartDelay()
            {
                if (state != State.None) return;
                state = State.Delaying;
                entity.Invoke(StartDamage, decaySettings.delayTime);
            }

            private void StartDamage()
            {
                if (entity == null || entity.IsDestroyed)
                {
                    Destroy();
                    return;
                }

                state = State.Decaying;
                entity.InvokeRepeating(DoDamage, 600f, decaySettings.destroyTime / decaySettings.tickRate);
            }

            private void StopDamage()
            {
                switch (state)
                {
                    case State.Delaying:
                        state = State.None;
                        entity.CancelInvoke(StartDamage);
                        break;

                    case State.Decaying:
                        state = State.None;
                        entity.CancelInvoke(DoDamage);
                        break;
                }
            }

            private void ResetDamage()
            {
                StopDamage();
                StartDamage();
            }

            private void DoDamage()
            {
                if (entity == null || entity.IsDestroyed)
                {
                    Destroy();
                    return;
                }

                var currentTickDamage = entity.MaxHealth() / decaySettings.tickRate;
                if (tickDamage != currentTickDamage)
                    tickDamage = currentTickDamage;

                entity.Hurt(tickDamage, Rust.DamageType.Decay);
            }

            public void OnBuildingUpgrade(DecaySettings settings)
            {
                decaySettings = settings;
                StopDamage();
                CheckBuildingPrivilege();
            }

            public void OnCupboardPlaced()
            {
                StopDamage();
            }

            public void OnCupboardDestroyed()
            {
                StartDelay();
            }

            public void Destroy()
            {
                if (entity == null) return;
                entity.CancelInvoke(DoDamage);
                entity.CancelInvoke(StartDamage);
                entity.CancelInvoke(CheckBuildingPrivilege);
            }
        }

        #endregion DestroyControl

        #region ConfigurationFile

        private static ConfigData _config;

        private class ConfigData
        {
            [JsonProperty("Check Cupboard Interval (Seconds)")]
            public float cupboardCheckTime = 300f;

            [JsonProperty("Not Protected Cupboard = No Cupboard")]
            public bool checkEmptyCupboard;

            [JsonProperty("Notify Player That His Object Will Be Removed")]
            public bool notifyPlayer = true;

            [JsonProperty("Notify Interval")]
            public float notifyInterval = 10f;

            [JsonProperty("Chat Settings")]
            public ChatSettings chatS = new ChatSettings();

            [JsonProperty("Building Block Settings")]
            public Dictionary<string, Dictionary<BuildingGrade.Enum, DecaySettings>> buildingBlockS = new Dictionary<string, Dictionary<BuildingGrade.Enum, DecaySettings>>();

            [JsonProperty("Other Entity Settings")]
            public Dictionary<string, DecaySettings> entityS = new Dictionary<string, DecaySettings>();

            [JsonProperty("Version")]
            public VersionNumber version;
        }

        public class ChatSettings
        {
            [JsonProperty("Chat Prefix")]
            public string prefix = "<color=#00FFFF>[AutoDecay]</color>: ";

            [JsonProperty("Chat SteamID Icon")]
            public ulong steamIDIcon = 0;
        }

        private class DecaySettings
        {
            [JsonProperty("Enabled")]
            public bool enabled;

            [JsonProperty("Only Used For Player's Entity")]
            public bool onlyOwned = true;

            [JsonProperty("Delay Time (Seconds)")]
            public float delayTime = 600f;

            [JsonProperty("Destroy Time (Seconds)")]
            public float destroyTime = 3600f;

            [JsonProperty("Tick Rate (Damage Per Tick = Max Health / This)")]
            public float tickRate = 10f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<ConfigData>();
                if (_config == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _config = new ConfigData();
            _config.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        private void UpdateConfigValues()
        {
            if (_config.version < Version)
            {
                if (_config.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat prefix") && GetConfigValue(out prefixColor, "Chat prefix color"))
                    {
                        _config.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }

                    ulong steamID;
                    if (GetConfigValue(out steamID, "Chat steamID icon"))
                    {
                        _config.chatS.steamIDIcon = steamID;
                    }
                }
                if (_config.version <= new VersionNumber(1, 2, 10))
                {
                    bool enabled;
                    if (GetConfigValue(out enabled, "Check empty cupboard"))
                    {
                        _config.checkEmptyCupboard = enabled;
                    }
                    if (GetConfigValue(out enabled, "Notify player, that his object will be removed"))
                    {
                        _config.notifyPlayer = enabled;
                    }

                    float time;
                    if (GetConfigValue(out time, "Check cupboard time (seconds)"))
                    {
                        _config.cupboardCheckTime = time;
                    }
                    if (GetConfigValue(out time, "Notify player interval"))
                    {
                        _config.notifyInterval = time;
                    }

                    Dictionary<string, object> decayList;
                    if (GetConfigValue(out decayList, "Decay entity list"))
                    {
                        foreach (var entry in decayList)
                        {
                            if (!_config.entityS.ContainsKey(entry.Key))
                            {
                                var jToken = JToken.FromObject(entry.Value);
                                _config.entityS.Add(entry.Key, new DecaySettings
                                {
                                    enabled = jToken["Enabled destroy"].ToObject<bool>(),
                                    onlyOwned = jToken["Check if it is a player's entity"].ToObject<bool>(),
                                    delayTime = jToken["Delay destroy time (seconds)"].ToObject<float>(),
                                    destroyTime = jToken["Tick rate (Damage per tick = max health / this)"].ToObject<float>(),
                                    tickRate = jToken["Destroy time (seconds)"].ToObject<float>(),
                                });
                            }
                        }
                    }
                }
                _config.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue != null)
            {
                if (configValue is T)
                {
                    value = (T)configValue;
                    return true;
                }
                try
                {
                    value = Config.ConvertValue<T>(configValue);
                    return true;
                }
                catch (Exception ex)
                {
                    PrintError($"GetConfigValue ERROR: path: {string.Join("\\", path)}\n{ex}");
                }
            }

            value = default(T);
            return false;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            [JsonProperty("List of short prefab names for all combat entities")]
            public HashSet<string> entityShortPrefabNames = new HashSet<string>();
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            finally
            {
                if (storedData == null)
                {
                    storedData = new StoredData();
                    UpdateData();
                }
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, _config.chatS.prefix, _config.chatS.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DESTROY"] = "If you do not install the cupboard, the object will <color=#F4D142>be deleted</color> after {0}."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["DESTROY"] = "如果您一直不放置领地柜，该实体将在 {0} 后<color=#F4D142>被删除</color>"
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: AutoDecay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UltraniumOre.cs ---
// --- Original Local Path: UltraniumOre.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("UltraniumOre", "CASHR", "1.0.0")]
    public class UltraniumOre : RustPlugin
    {
        #region Configuration
        private enum Type
        {
            None,
            Gather,
            Oven
        }
        [JsonProperty("Тут трогать только DisplayName")]
        private Dictionary<Type, CustomItem> Items = new Dictionary<Type, CustomItem>
        {
            [Type.Gather] = new CustomItem
            {
                DisplayName = "Ультраниумная руда",
                ShortName = "coal",
                SkinID = 1719213706
            },
            [Type.Oven] = new CustomItem
            {
                DisplayName = "Ультраниум обработанный",
                ShortName = "ducttape",
                SkinID = 1838446313
            },

        };
        private class CustomItem
        {
            public string DisplayName;
            public string ShortName;
            public ulong SkinID;

            public Item CreateItem(int amount)
            {
                Item item = ItemManager.CreateByPartialName(ShortName, amount);
                item.name = DisplayName;
                item.skin = SkinID;

                if (item.info.GetComponent<ItemModCookable>() != null)
                    item.info.GetComponent<ItemModCookable>().OnItemCreated(item);

                return item;
            }
        }




        #endregion
        private class Configuration
        {
            [JsonProperty("Шанс выпадения руды")]
            public int Chance = 10;

            public static Configuration GetNewConf()
            {
                return new Configuration();
            }

        }
        protected override void LoadDefaultConfig() => _config = Configuration.GetNewConf();
        protected override void SaveConfig() => Config.WriteObject(_config);
        private Configuration _config = new Configuration();
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }
        #region Oxide Hooks
        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (item.info.shortname == Items[Type.Oven].ShortName && item.skin == 0)
            {
                item.skin = Items[Type.Oven].SkinID;
                item.name = Items[Type.Oven].DisplayName;
            }
        }

        void OnServerInitialized()
        {
            LoadConfig();
            var itemInfo = ItemManager.FindItemDefinition(Items[Type.Gather].ShortName);
            if (itemInfo.GetComponent<ItemModCookable>() == null) itemInfo.gameObject.AddComponent<ItemModCookable>();
            itemInfo.stackable = 5000;
            var _itemInfo = ItemManager.FindItemDefinition(Items[Type.Oven].ShortName);
            _itemInfo.stackable = 5000;
            var burnMod = itemInfo.gameObject.GetComponent<ItemModCookable>();
            burnMod.becomeOnCooked = ItemManager.FindItemDefinition(Items[Type.Oven].ShortName);
            burnMod.amountOfBecome = 1;
            burnMod.highTemp = 1200;
            burnMod.lowTemp = 800;
            burnMod.cookTime = 15;
            PrintWarning("Все файлы созданы успешно, плагин работает!");
        }


        private void CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            if (item.info.shortname == Items[Type.Oven].ShortName && targetPos == -1)
            {
                item.name = Items[Type.Oven].DisplayName;
                item.skin = Items[Type.Oven].SkinID;
            }
        }


        private Item OnItemSplit(Item item, int amount)
        {
            if (item.info.shortname == Items[Type.Gather].ShortName && item.skin == Items[Type.Gather].SkinID)
            {
                Item x = Items[Type.Gather].CreateItem(amount);
                item.amount -= amount;
                item.MarkDirty();
                x.MarkDirty();
                return x;
            }
            if (item.info.shortname == Items[Type.Oven].ShortName && item.skin == Items[Type.Oven].SkinID)
            {
                Item x = Items[Type.Oven].CreateItem(amount);
                item.amount -= amount;
                item.MarkDirty();
                x.MarkDirty();
                return x;
            }
            return null;
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();

            if (dispenser == null || player == null || item == null)
                return;
            if (dispenser.gatherType != ResourceDispenser.GatherType.Ore) return;
            int amount;
            switch (item.info.shortname)
            {
                case "sulfur.ore":
                    if (Core.Random.Range(1, 100) == _config.Chance)
                    {
                        amount = Core.Random.Range(5, 20);
                        Item dropItem = Items[Type.Gather].CreateItem(amount);
                        foreach (var x in player.inventory.AllItems())
                        {
                            if (x.skin == Items[Type.Gather].SkinID)
                            {
                                x.amount += amount;
                                player.SendConsoleCommand($"note.inv {dropItem.info.itemid} {dropItem.amount} \"Ультраниумная руда\"");
                                return;
                            }
                        }
                        if (24 - player.inventory.containerMain.itemList.Count > 0)
                        {
                            dropItem.MoveToContainer(player.inventory.containerMain, -1, true);
                            player.SendConsoleCommand($"note.inv {dropItem.info.itemid} {dropItem.amount} \"Ультраниумная руда\"");
                            return;
                        }
                        else if (6 - player.inventory.containerBelt.itemList.Count > 0)
                        {
                            dropItem.MoveToContainer(player.inventory.containerBelt, -1, true);
                            player.SendConsoleCommand($"note.inv {dropItem.info.itemid} {dropItem.amount} \"Ультраниумная руда\"");
                            return;
                        }
                        else
                        {
                            dropItem.Drop(player.transform.position, Vector3.up);
                            PrintToChat(player, "Ультраниумная руда брошена под ноги!");
                        }
                        return;
                    }
                    break;
            }

        }
        #endregion

    }
}

// --- End of file: UltraniumOre.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ConnectionInfo.cs ---
// --- Original Local Path: ConnectionInfo.cs ---

using System;
using Oxide.Core.Plugins;
namespace Oxide.Plugins
{
    [Info("ConnectionInfo", "Norn", 0.1, ResourceId = 1460)]
    [Description("Basic player information.")]
    public class ConnectionInfo : RustPlugin
    {
        [PluginReference]
        Plugin ConnectionDB;

        [ChatCommand("pinfo")]
        private void PlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (ConnectionDB)
            {
                if (Convert.ToBoolean(ConnectionDB.CallHook("ConnectionDataExists", player)))
                {
                    DateTime init_date = Convert.ToDateTime(ConnectionDB.CallHook("FirstSeen", player));
                    int seconds = Convert.ToInt32(ConnectionDB.CallHook("SecondsPlayed", player));
                    TimeSpan ts = TimeSpan.FromSeconds(seconds);
                    PrintToChat(player, "<color=#66ff66>" + player.displayName + "</color> (<color=#ffccff>" + Convert.ToString(ConnectionDB.CallHook("FirstName", player)) + "</color>):\nYou have played <color=yellow>" + Math.Round(ts.TotalMinutes).ToString() + "</color> minutes since <color=yellow>" + init_date.ToShortDateString() + "</color>!\nTotal Seconds: <color=yellow>" + seconds.ToString() + "</color> | Connections: <color=yellow>" + Convert.ToString(ConnectionDB.CallHook("Connections", player)) + "</color>.");
                }
            }
        }
        void Loaded()
        {
            if(!ConnectionDB) { Puts("ConnectionDB [1459] has not been found!"); }
        }
    }
}

// --- End of file: ConnectionInfo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InvalidDistanceDetector.cs ---
// --- Original Local Path: InvalidDistanceDetector.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Invalid Distance Detector", "HiTTA", "1.3.0")]
    [Description("Bans suspicious players based on weapon distances")]
    class InvalidDistanceDetector : CovalencePlugin
    {
        #region Configuration

        private Configuration _config;

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        private class Configuration
        {
            [JsonProperty("Compound Bow Distance")]
            public float CompoundBow = 100;

            [JsonProperty("Bow Distance")]
            public float Bow = 100;

            [JsonProperty("Crossbow Distance")]
            public float Crossbow = 100;

            [JsonProperty("M249 Distance")]
            public float M249 = 350;

            [JsonProperty("Eoka Pistol Distance")]
            public float EokaPistol = 50;

            [JsonProperty("M92 Pistol Distance")]
            public float M92Pistol = 150;

            [JsonProperty("Nailgun Distance")]
            public float Nailgun = 75;

            [JsonProperty("Python Revolver Distance")]
            public float PythonRevolver = 150;

            [JsonProperty("Revolver Distance")]
            public float Revolver = 125;

            [JsonProperty("Semi-Automatic Pistol Distance")]
            public float SemiAutoPistol = 125;

            [JsonProperty("Assault Rifle Distance")]
            public float AssaultRifle = 300;

            [JsonProperty("Bolt Action Rifle Distance")]
            public float BoltActionRifle = 450;

            [JsonProperty("L96 Distance")]
            public float L96Rifle = 450;

            [JsonProperty("LR-300 Assault Rifle distance")]
            public float LR300AssaultRifle = 300;

            [JsonProperty("M39 Rifle distance")]
            public float M39Rifle = 350;

            [JsonProperty("Semi-Automatic Rifle distance")]
            public float SemiAutomaticRifle = 250;

            [JsonProperty("MP5A4 distance")]
            public float MP5A4 = 300;

            [JsonProperty("Thompson distance")]
            public float Thompson = 300;
        }

        #endregion Configuration

        private void OnEntityTakeDamage(BasePlayer victim, HitInfo hitInfo)
        {
            if (hitInfo.IsProjectile() && victim.userID.IsSteamId())
            {
                BasePlayer attacker = hitInfo.Initiator as BasePlayer;
                HeldEntity heldEntity = attacker.GetHeldEntity();
                Item heldItem = heldEntity.GetItem();
                float distance = hitInfo.ProjectileDistance;
                bool bannableDistance = false;

                switch (heldEntity.ShortPrefabName)
                {
                    case "bow.compound":
                        if (distance > _config.CompoundBow) bannableDistance = true;
                        break;

                    case "bow.hunting":
                        if (distance > _config.Bow) bannableDistance = true;
                        break;

                    case "crossbow":
                        if (distance > _config.Crossbow) bannableDistance = true;
                        break;

                    case "lmg.m249":
                        if (distance > _config.M249) bannableDistance = true;
                        break;

                    case "pistol.eoka":
                        if (distance > _config.EokaPistol) bannableDistance = true;
                        break;

                    case "pistol.m92":
                        if (distance > _config.M92Pistol) bannableDistance = true;
                        break;

                    case "pistol.nailgun":
                        if (distance > _config.Nailgun) bannableDistance = true;
                        break;

                    case "pistol.python":
                        if (distance > _config.PythonRevolver) bannableDistance = true;
                        break;

                    case "pistol.revolver":
                        if (distance > _config.Revolver) bannableDistance = true;
                        break;

                    case "pistol.semiauto":
                        if (distance > _config.SemiAutoPistol) bannableDistance = true;
                        break;

                    case "rifle.ak":
                        if (distance > _config.AssaultRifle) bannableDistance = true;
                        break;

                    case "rifle.bolt":
                        if (distance > _config.BoltActionRifle) bannableDistance = true;
                        break;

                    case "rifle.l96":
                        if (distance > _config.L96Rifle) bannableDistance = true;
                        break;

                    case "rifle.lr300":
                        if (distance > _config.LR300AssaultRifle) bannableDistance = true;
                        break;

                    case "rifle.m39":
                        if (distance > _config.M39Rifle) bannableDistance = true;
                        break;

                    case "rifle.semiauto":
                        if (distance > _config.SemiAutomaticRifle) bannableDistance = true;
                        break;

                    case "smg.mp5":
                        if (distance > _config.MP5A4) bannableDistance = true;
                        break;

                    case "smg.thompson":
                        if (distance > _config.Thompson) bannableDistance = true;
                        break;
                }

                if (bannableDistance)
                {
                    server.Ban(attacker.UserIDString, $"Anti Cheat: (Invalid Distance! - {heldItem.info.displayName.english})");
                    Log($"Attacker: {attacker.displayName} ({attacker.userID}) | Hit distance: {distance} | Weapon: {heldItem} | Victim: {victim.displayName} ({victim.userID})");
                }
            }
        }
    }
}

// --- End of file: InvalidDistanceDetector.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PillsHere.cs ---
// --- Original Local Path: PillsHere.cs ---

using System;

namespace Oxide.Plugins
{
    [Info("PillsHere", "Wulf/lukespragg", "3.0.1", ResourceId = 1723)]
    [Description("Recovers health, hunger, and thirst by set amounts when using rad pills")]

    class PillsHere : RustPlugin
    {
        const string permUse = "pillshere.use";

        float healAmount;
        float hungerAmount;
        float thirstAmount;

        protected override void LoadDefaultConfig()
        {
            // Settings
            Config["Health Amount"] = healAmount = GetConfig("Health Amount", 20f);
            Config["Hunger Amount"] = hungerAmount = GetConfig("Hunger Amount", 0f);
            Config["Thirst Amount"] = thirstAmount = GetConfig("Thirst Amount", 0f);

            // Cleanup
            Config.Remove("HealthAmount");
            Config.Remove("HungerAmount");
            Config.Remove("ThirstAmount");

            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();
            permission.RegisterPermission(permUse, this);
        }

        void OnConsumableUse(Item item)
        {
            var player = item.GetOwnerPlayer();
            if (item.info?.itemid != 1685058759 || player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, permUse)) return;

            player.Heal(healAmount);
            player.metabolism.calories.value += hungerAmount;
            player.metabolism.hydration.value += 50 + thirstAmount;
        }

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));
    }
}


// --- End of file: PillsHere.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XDCobaltLaboratory.cs ---
// --- Original Local Path: XDCobaltLaboratory.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using UnityEngine.SceneManagement;
using static NPCPlayerApex;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("XDCobaltLaboratory", "DezLife", "1.7.3")]
    public class XDCobaltLaboratory : RustPlugin
    {
        /// <summary> - 1.7.0
        /// 1- Хорошо оптимизирован
        /// 2- Обновленно юи, теперь его можно скрывать игрокам которым он мешает.
        /// 3- Подправлен Lang файл
        /// 4- UI можно настроить в конфигурации
        /// 5- Мелкие исправления
        /// 6- Уменьшен шанс спавна постройки на берегу или вводе. Теперь этого не будет.
        /// </summary>
        #region Var
        [PluginReference] Plugin CopyPaste, IQChat, RustMap;
        private static XDCobaltLaboratory _;

        private HashSet<Vector3> busyPoints3D = new HashSet<Vector3>();
        private List<BaseEntity> HouseCobaltLab = new List<BaseEntity>();
        private List<NPCMonitor> nPCMonitors = new List<NPCMonitor>();
        private List<NpcZones> npcZones = new List<NpcZones>();
        private List<UInt64> HideUIUser = new List<UInt64>();
        private string PosIvent;
        private int maxTry = 250000;
        private const int MaxRadius = 5;
        public Timer SpawnHouseTime;
        public Timer RemoveHouseTime;
        public static DateTime TimeCreatedSave = SaveRestore.SaveCreatedTime.Date;
        public static DateTime RealTime = DateTime.Now.Date;
        public static int SaveCreated = RealTime.Subtract(TimeCreatedSave).Days;
        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["XD_IVENT_START"] = "Ученые разбили на этом острове свою лабораторию под названием Кобальт,скорее всего там находится ценные вещи, ведь он охраняется!\nКвадрат : {0}",
                ["XD_IVENT_STARTUI"] = "Ученые разбили свою лабораторию под названием Кобальт!\nКвадрат : {0}",
                ["XD_IVENT_NOPLAYER"] = "Ученые закончили свой эксперимент и успешно покинули остров без происшествий",
                ["XD_IVENT_CRATEHACK"] = "В лаборатории кобальт {0} начал взлом секретного ящика в квадрате {1}\nСоберитесь с силами и отбейте его",
                ["XD_IVENT_CRATEHACKHELP"] = "В лаборатории кобальт {0} начал взлом секретного ящика в квадрате {1}\nСоберитесь с силами и отбейте его\nНа это место уже прибыла подмога! Будте осторожней",
                ["XD_IVENT_CRATEHACKEND"] = "В лаборатории кобальт был взломан секретный ящик, ученые начинают эвакуацию с острова, у вас осталось {0} минут, чтобы забрать его!",
                ["XD_IVENT_CRATELOOTFOUND"] = " В лаборатории кобальт никто не успел залутать взломанный ящик, лаборатория была эвакуирована и постройка разрушена",
                ["XD_IVENT_CRATELOOTPLAYER"] = "{0}  успешно ограбил лабораторию кобальт и забрал ценные вещи с секретного ящика",
                ["XD_IVENT_HOUSECOBALT"] = "Лаборатория КОБАЛЬТ",
                ["XD_IVENT_START_DISCORD"] = "Ученые разбили на этом острове свою лабораторию под названием Кобальт,скорее всего там находится ценные вещи, ведь он охраняется!\nКвадрат : {0}",
                ["XD_IVENT_NOPLAYER_DISCORD"] = "Ученые закончили свой эксперимент и успешно покинули остров без происшествий",
                ["XD_IVENT_CRATEHACK_DISCORD"] = "В лаборатории кобальт {0} начал взлом секретного ящика в квадрате {1}\nСоберитесь с силами и отбейте его",
                ["XD_IVENT_CRATEHACKHELP_DISCORD"] = "В лаборатории кобальт {0} начал взлом секретного ящика в квадрате {1}\nСоберитесь с силами и отбейте его\nНа это место уже прибыла подмога! Будте осторожней",
                ["XD_IVENT_CRATEHACKEND_DISCORD"] = "В лаборатории кобальт был взломан секретный ящик, ученые начинают эвакуацию с острова, у вас осталось {0} минут, чтобы забрать его!",
                ["XD_IVENT_CRATELOOTFOUND_DISCORD"] = " В лаборатории кобальт никто не успел залутать взломанный ящик, лаборатория была эвакуирована и постройка разрушена",
                ["XD_IVENT_CRATELOOTPLAYER_DISCORD"] = "{0}  успешно ограбил лабораторию кобальт и забрал ценные вещи с секретного ящика",
            }, this);
        }

        #endregion

        #region api
        int ApiGetTimeToStart()
        {
            if (SpawnHouseTime.Destroyed)
                return 0;
            int time = (int)(SpawnHouseTime.Delay - DateTime.Now.Second);
            if (time <= 0)
                return 0;
            return time;
        }

        #endregion

        #region Data
        public void LoadDataCopyPaste()
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("copypaste/HouseCobalt"))
            {
                PrintError($"Файл постройки не найден!\nНачинаем импортировать...");
                webrequest.Enqueue("http://utilite.skyplugins.ru/XDCasinoOutPost/HouseCobaltNew.json", null, (i, s) =>
                {
                    {
                        if (i == 200)
                        {
                            PasteData obj = JsonConvert.DeserializeObject<PasteData>(s);
                            Interface.Oxide.DataFileSystem.WriteObject("copypaste/HouseCobalt", obj);
                            PrintWarning("Постройка успешно загружена");
                        }
                        else
                        {
                            PrintError("Ошибка при загрузке постройки!\nПробуем загрузить еще раз");
                            timer.Once(10f, () => LoadDataCopyPaste());
                            return;
                        }
                    }
                }, this, RequestMethod.GET);
            }
        }
        public class PasteData
        {
            public Dictionary<string, object> @default;
            public ICollection<Dictionary<string, object>> entities;
            public Dictionary<string, object> protocol;
        }
        #endregion

        #region Configuration
        public class LootNpcOrBox
        {
            [JsonProperty("ShortName")]
            public string Shortname;
            [JsonProperty("SkinID")]
            public ulong SkinID;
            [JsonProperty("Имя предмета")]
            public string DisplayName;
            [JsonProperty("Чертеж?")]
            public bool BluePrint;
            [JsonProperty("Минимальное количество")]
            public int MinimalAmount;
            [JsonProperty("максимальное количество")]
            public int MaximumAmount;
            [JsonProperty("Шанс выпадения предмета")]
            public int DropChance;
            [JsonProperty("Умножать этот предмета на день вайпа ?")]
            public bool wipeCheck;
        }
        private static Configuration config = new Configuration();
        private class Configuration
        {

            [JsonProperty("Настройка постройки для ивента (CopyPaste)")]
            public BuildingPasteSettings pasteSettings = new BuildingPasteSettings();
            [JsonProperty("Настройка запуска и остановки ивента")]
            public IventController iventController = new IventController();
            [JsonProperty("Настройка уведомлений")]
            public NotiferSettings notiferSettings = new NotiferSettings();
            [JsonProperty("Настройка радиации в зоне ивента")]
            public RadiationConroller radiationConroller = new RadiationConroller();
            [JsonProperty("Отображения ивента на картах")]
            public MapMarkers mapMarkers = new MapMarkers();
            [JsonProperty("Настройка NPC")]
            public NpcController npcController = new NpcController();
            [JsonProperty("Настройка ящика")]
            public BoxSetting boxSetting = new BoxSetting();

            internal class RadiationConroller
            {
                [JsonProperty("Включить радиацию ?")]
                public bool radUse;
                [JsonProperty("Количество радиационных частиц")]
                public int radCount;
            }

            internal class MapMarkers
            {
                [JsonProperty("Отметить ивент на карте RustMap?")]
                public bool rustMapUse;
                [JsonProperty("Иконка для карты RustMap")]
                public string rustMapIcon;
                [JsonProperty("Текст для карты RustMap")]
                public string rustMapTxt;
                [JsonProperty("Отметить ивент на карте G (Требуется https://umod.org/plugins/marker-manager)")]
                public bool MapUse;
                [JsonProperty("Текст для карты G")]
                public string MapTxt;
            }
            internal class IventController
            {
                [JsonProperty("Минимальное количество игроков для запуска ивента")]
                public int minPlayedPlayers;
                [JsonProperty("Время до начала ивента (Минимальное в секундах)")]
                public int minSpawnIvent;
                [JsonProperty("Время до начала ивента (Максимальное в секундах)")]
                public int maxSpawnIvent;
                [JsonProperty("Время до удаления ивента если никто не откроет ящик (Секунды)")]
                public int timeRemoveHouse;
                [JsonProperty("Время до удаления ивента после того как разблокируется ящик")]
                public int timeRemoveHouse2;
            }
            internal class NpcController
            {
                [JsonProperty("Спавнить NPC вокруг дома ?")]
                public bool useSpawnNPC;
                [JsonProperty("Колличевство NPC")]
                public int countSpawnNpc;
                [JsonProperty("ХП NPC")]
                public int healthNPC;
                [JsonProperty("Дистанция видимости")]
                public int DistanceRange;
                [JsonProperty("Точность оружия ученого (1 - 100)")]
                public int Accuracy;
                [JsonProperty("Спавнить ли подмогу после взлома ящика ? (НПС)")]
                public bool helpBot;
                [JsonProperty("Колличевство нпс (Подмога)")]
                public int helpCount;
                [JsonProperty("Рандомные ники нпс")]
                public List<string> nameNPC = new List<string>();
                [JsonProperty("Одежда для NPC")]
                public List<ItemNpc> wearNpc = new List<ItemNpc>();
                [JsonProperty("Варианты оружия для NPC")]
                public List<ItemNpc> beltNpc = new List<ItemNpc>();
                [JsonProperty("Использовать свой лут в нпс ?")]
                public bool useCustomLoot;
                [JsonProperty("Настройка лута в NPC (Если выключенно то будет стандартный) /cl.botitems")]
                public List<LootNpcOrBox> lootNpcs = new List<LootNpcOrBox>();

                internal class ItemNpc
                {
                    [JsonProperty("ShortName")]
                    public string Shortname;
                    [JsonProperty("SkinID")]
                    public ulong SkinID;
                }
            }

            internal class BuildingPasteSettings
            {
                [JsonProperty("Настройка высоты постройки (Требуется в настройке, если вы хотите ставить свою постройку)")]
                public int heightBuilding;
                [JsonProperty("файл в папке /oxide/data/copypaste с вашей постройкой(Если не указать загрузится стандартная)")]
                public string housepath;
                [JsonProperty("радиус для обнаружения построек игроков")]
                public int radiusClear;
            }

            internal class BoxSetting
            {
                [JsonProperty("Настройка лута в ящике /cl.items")]
                public List<LootNpcOrBox> lootBoxes = new List<LootNpcOrBox>();

                [JsonProperty("Время разблокировки ящика (Сек)")]
                public int unBlockTime;
                [JsonProperty("Макcимальное количество предметов в ящике")]
                public int maxItemCount;
                [JsonProperty("умножать количество лута на количество дней с начала вайпа (на 3й день - лута будет в 3 раза больше)")]
                public bool lootWipePlus;
                [JsonProperty("Включить сигнализацию *?")]
                public bool signaling;
            }
            internal class NotiferSettings
            {
                [JsonProperty("ВебХук дискорда (Если не нужны уведомления в дискорд, оставьте поле пустым)")]
                public string weebHook;
                [JsonProperty("Включить UI Уведомления ?")]
                public bool useUiNotifi;
                [JsonProperty("Цвет заднего фона окна UI")]
                public string colorBackground;
                [JsonProperty("Цвет Кнопки закрытия UI")]
                public string colorBtnCloseUi;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    notiferSettings = new NotiferSettings
                    {
                        weebHook = string.Empty,
                        useUiNotifi = true,
                        colorBackground = "0.8 0.28 0.2 0.8",
                        colorBtnCloseUi = "0.6784314 0.254902 0.1843137 0.8"
                    },
                    pasteSettings = new BuildingPasteSettings
                    {
                        housepath = "",
                        radiusClear = 25,
                        heightBuilding = 2,
                    },
                    iventController = new IventController
                    {
                        minPlayedPlayers = 0,
                        minSpawnIvent = 3000,
                        maxSpawnIvent = 7200,
                        timeRemoveHouse = 900,
                        timeRemoveHouse2 = 300
                    },
                    boxSetting = new BoxSetting
                    {
                        unBlockTime = 900,
                        lootWipePlus = false,
                        maxItemCount = 10,
                        lootBoxes = new List<LootNpcOrBox>
                        {
                           new LootNpcOrBox
                           {
                               Shortname = "pistol.python",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 60,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "multiplegrenadelauncher",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 15,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "sulfur",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 500,
                               MaximumAmount = 800,
                               DropChance = 40,
                               wipeCheck = true
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "gunpowder",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 300,
                               MaximumAmount = 400,
                               DropChance = 10,
                               wipeCheck = true
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "door.hinged.toptier",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = true,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 15,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "wall.external.high.ice",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 5,
                               DropChance = 75,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "ammo.rocket.basic",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 3,
                               DropChance = 25,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "ammo.grenadelauncher.smoke",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 3,
                               MaximumAmount = 10,
                               DropChance = 70,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "ammo.grenadelauncher.he",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 2,
                               MaximumAmount = 5,
                               DropChance = 10,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "metal.facemask",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = true,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 15,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "metal.plate.torso",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = true,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 10,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "clatter.helmet",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 70,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "carburetor3",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 20,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "crankshaft3",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 10,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "techparts",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 5,
                               MaximumAmount = 15,
                               DropChance = 35,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "xmas.lightstring.advanced",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 30,
                               MaximumAmount = 70,
                               DropChance = 45,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "largemedkit",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 3,
                               MaximumAmount = 5,
                               DropChance = 70,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "largemedkit",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = true,
                               MinimalAmount = 3,
                               MaximumAmount = 5,
                               DropChance = 70,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "metal.fragments",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1000,
                               MaximumAmount = 2000,
                               DropChance = 70,
                               wipeCheck = true
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "explosives",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 10,
                               MaximumAmount = 50,
                               DropChance = 30,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "autoturret",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 60,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "explosive.timed",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 5,
                               wipeCheck = true
                           },
                        },
                        signaling = true
                    },
                    npcController = new NpcController
                    {
                        useSpawnNPC = true,
                        countSpawnNpc = 8,
                        healthNPC = 170,
                        DistanceRange = 140,
                        Accuracy = 40,
                        helpBot = true,
                        helpCount = 4,
                        nameNPC = new List<string> { "Cobalt guard", "Cobalt defense" },
                        wearNpc = new List<NpcController.ItemNpc>
                       {
                           new NpcController.ItemNpc
                           {
                               Shortname = "roadsign.kilt",
                               SkinID = 1121447954
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "burlap.shirt",
                               SkinID = 2076298726
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "shoes.boots",
                               SkinID = 0
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "roadsign.gloves",
                               SkinID = 0
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "burlap.trousers",
                               SkinID = 2076292007
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "metal.facemask",
                               SkinID = 835028125
                           },
                       },
                        beltNpc = new List<NpcController.ItemNpc>
                       {
                           new NpcController.ItemNpc
                           {
                               Shortname = "rifle.lr300",
                               SkinID = 1975712725
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "rifle.lr300",
                               SkinID = 1837473292
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "pistol.semiauto",
                               SkinID = 1557105240
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "rifle.semiauto",
                               SkinID = 1845735432
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "rifle.ak",
                               SkinID = 1352726257
                           },
                       },
                        useCustomLoot = true,
                        lootNpcs = new List<LootNpcOrBox>
                        {
                            new LootNpcOrBox{Shortname = "halloween.surgeonsuit", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 1, DropChance = 70 },
                            new LootNpcOrBox{Shortname = "metal.facemask", SkinID = 1886184322, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 1, DropChance = 20 },
                            new LootNpcOrBox{Shortname = "door.double.hinged.metal", SkinID = 191100000, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 2, DropChance = 60 },
                            new LootNpcOrBox{Shortname = "rifle.bolt", SkinID = 0, DisplayName = "", BluePrint = true, MinimalAmount = 1, MaximumAmount = 1, DropChance = 10 },
                            new LootNpcOrBox{Shortname = "rifle.lr300", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 1, DropChance = 15 },
                            new LootNpcOrBox{Shortname = "pistol.revolver", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 3, DropChance = 60 },
                            new LootNpcOrBox{Shortname = "supply.signal", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 3, DropChance = 20 },
                            new LootNpcOrBox{Shortname = "explosive.satchel", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 3, DropChance = 5 },
                            new LootNpcOrBox{Shortname = "grenade.smoke", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 20, DropChance = 45 },
                            new LootNpcOrBox{Shortname = "ammo.rifle", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 50, MaximumAmount = 120, DropChance = 35 },
                            new LootNpcOrBox{Shortname = "scrap", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 100, MaximumAmount = 500, DropChance = 20 },
                            new LootNpcOrBox{Shortname = "giantcandycanedecor", SkinID = 0, DisplayName = "Новый год", BluePrint = false, MinimalAmount = 1, MaximumAmount = 5, DropChance = 70 },
                        }
                    },
                    radiationConroller = new RadiationConroller
                    {
                        radUse = true,
                        radCount = 20
                    },
                    mapMarkers = new MapMarkers
                    {
                        rustMapUse = true,
                        rustMapIcon = "https://i.imgur.com/bwg6de6.png",
                        rustMapTxt = "Лабаратория кобальт",
                        MapUse = false,
                        MapTxt = "Лабаратория кобальт"
                    }
                };

            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #132" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            if (config.notiferSettings.colorBtnCloseUi == null)
            {
                config.notiferSettings.colorBtnCloseUi = "0.6784314 0.254902 0.1843137 0.8";
                config.notiferSettings.colorBackground = "0.8 0.28 0.2 0.8";
            }

            if (config.boxSetting.unBlockTime == 0)
            {
                config.boxSetting.unBlockTime = 900;
            }
            if (config.npcController.Accuracy == 0)
            {
                config.npcController.Accuracy = 40;
            }
            if (config.npcController.DistanceRange == 0)
            {
                config.npcController.DistanceRange = 130;
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region SpawnPoint

        #region CheckFlat
        private List<Vector3>[] patternPositionsAboveWater = new List<Vector3>[MaxRadius];
        private List<Vector3>[] patternPositionsUnderWater = new List<Vector3>[MaxRadius];

        private readonly Quaternion[] directions =
        {
            Quaternion.Euler(90, 0, 0),
            Quaternion.Euler(0, 0, 90),
            Quaternion.Euler(0, 0, 180)
        };

        private void FillPatterns()
        {
            Vector3[] startPositions = { new Vector3(1, 0, 1), new Vector3(-1, 0, 1), new Vector3(-1, 0, -1), new Vector3(1, 0, -1) };

            patternPositionsAboveWater[0] = new List<Vector3> { new Vector3(0, -1.0f, 0) };
            for (int loop = 1; loop < MaxRadius; loop++)
            {
                patternPositionsAboveWater[loop] = new List<Vector3>();

                for (int step = 0; step < loop * 2; step++)
                {
                    for (int pos = 0; pos < 4; pos++)
                    {
                        Vector3 sPos = startPositions[pos] * step;
                        for (int rot = 0; rot < 3; rot++)
                        {
                            Vector3 rPos = directions[rot] * sPos;
                            rPos.y = -1.0f;
                            patternPositionsAboveWater[loop].Add(rPos);
                        }
                    }
                }
            }

            for (int i = 0; i < patternPositionsAboveWater.Length; i++)
            {
                patternPositionsUnderWater[i] = new List<Vector3>();
                foreach (var vPos in patternPositionsAboveWater[i])
                {
                    var rPos = new Vector3(vPos.x, 1.0f, vPos.z);
                    patternPositionsUnderWater[i].Add(rPos);
                }
            }
        }

        [ConsoleCommand("isflat")]
        private void CmdIsFlat(ConsoleSystem.Arg arg)
        {
            Vector3 pPos = new Vector3(arg.Player().transform.position.x, TerrainMeta.HeightMap.GetHeight(arg.Player().transform.position), arg.Player().transform.position.z);
            var b = IsFlat(ref pPos);
            arg.Player().Teleport(pPos);
        }

        public bool IsFlat(ref Vector3 position)
        {
            List<Vector3>[] AboveWater = new List<Vector3>[MaxRadius];

            Array.Copy(patternPositionsAboveWater, AboveWater, patternPositionsAboveWater.Length);

            for (int i = 0; i < AboveWater.Length; i++)
            {
                for (int j = 0; j < AboveWater[i].Count; j++)
                {
                    Vector3 pPos = AboveWater[i][j];
                    Vector3 resultAbovePos = new Vector3(pPos.x + position.x, position.y + 1.0f, pPos.z + position.z);
                    Vector3 resultUnderPos = new Vector3(pPos.x + position.x, position.y - 1.0f, pPos.z + position.z);

                    if (resultAbovePos.y >= TerrainMeta.HeightMap.GetHeight(resultAbovePos) && resultUnderPos.y <= TerrainMeta.HeightMap.GetHeight(resultUnderPos))
                    {
                    }
                    else
                        return false;
                }
            }

            return true;
        }
        #endregion

        #region GenerateSpawnPoint

        public bool IsDistancePoint(Vector3 point)
        {
            bool result = busyPoints3D.Count(x => Vector3.Distance(point, x) < 20f) == 0;
            return result;
        }
        private void GenerateSpawnPoints()
        {
            for (int i = 0; i < 100; i++)
            {
                maxTry -= 1;
                Vector3 point3D = new Vector3();
                Vector2 point2D = new Vector3(UnityEngine.Random.Range(-TerrainMeta.Size.x / 2, TerrainMeta.Size.x / 2), UnityEngine.Random.Range(-TerrainMeta.Size.z / 2, TerrainMeta.Size.z / 2));

                point3D.x = point2D.x;
                point3D.z = point2D.y;
                point3D.y = TerrainMeta.HeightMap.GetHeight(point3D);

                if (!IsFlat(ref point3D))
                    continue;

                if (!Is3DPointValid(ref point3D))
                    continue;

                if (!IsDistancePoint(point3D))
                    continue;

                if (point3D != Vector3.zero)
                {
                    AcceptValue(ref point3D);
                }
            }
            if (maxTry > 0)
            {
                NextTick(() =>
                {
                    GenerateSpawnPoints();
                });
            }
            else
            {
                PrintWarning($"{busyPoints3D.Count} точек сгенерированно!");
                maxTry = 250000;
            }
        }
        private bool Is3DPointValid(ref Vector3 point)
        {
            List<BuildingPrivlidge> cupboards = new List<BuildingPrivlidge>();
            Vis.Entities(point, config.pasteSettings.radiusClear, cupboards);
            if (Physics.CheckSphere(point, config.pasteSettings.radiusClear, LayerMask.GetMask("Construction", "Default", "Deployed", "World", "Trigger", "Prevent Building")) || cupboards.Count > 0 || point.y < ConVar.Env.oceanlevel + 4f)
            {
                return false;
            }
            return true;
        }

        private void AcceptValue(ref Vector3 point)
        {
            busyPoints3D.Add(point);
        }
        #endregion

        #region GetPosition
        private object GetSpawnPoints()
        {
            if (busyPoints3D.ToList().Count <= 3)
            {
                PrintWarning("Все точки закончены!\n" +
                            "Начинаем генерировать новые...");
                busyPoints3D.Clear();
                GenerateSpawnPoints();
                GenerateIvent();
                return Vector3.zero;
            }

            Vector3 targetPos = busyPoints3D.ToList().GetRandom();
            if (targetPos == Vector3.zero)
            {
                busyPoints3D.Remove(targetPos);
                return GetSpawnPoints();
            }

            bool valid = Is3DPointValid(ref targetPos);

            if (!valid)
            {
                busyPoints3D.Remove(targetPos);
                return GetSpawnPoints();
            }
            busyPoints3D.Remove(targetPos);
            return targetPos;
        }
        #endregion

        #endregion

        #region Hooks
        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (HouseCobaltLab.Contains(entity?.GetParentEntity()))
                HouseCobaltLab.Remove(entity.GetParentEntity());
        }

        void Unload()
        {
            foreach (BaseEntity iventEnt in HouseCobaltLab)
            {
                if (!iventEnt.IsDestroyed)
                    iventEnt?.Kill();
            }
            HouseCobaltLab.Clear();
            if (SpawnHouseTime != null)
                SpawnHouseTime.Destroy();
            if (RemoveHouseTime != null)
                RemoveHouseTime.Destroy();
            DestroyZone();
            RemoveMapMarker();
            Cui.DestroyAllPlayer();
        }
        void Init()
        { UnscribeHook(); }

        private void OnServerInitialized()
        {
            if (!CopyPaste)
            {
                PrintError("Проверьте установлен ли у вас плагин 'CopyPaste'");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            else if (CopyPaste.Version < new VersionNumber(4, 1, 27))
            {
                PrintError("У вас старая версия CopyPaste!\nПожалуйста обновите плагин до последней версии (4.1.27 или выше) - https://umod.org/plugins/copy-paste");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            _ = this;
            FillPatterns();
            NextTick(() =>
            {
                GenerateSpawnPoints();
            });
            GenerateIvent();
            if (string.IsNullOrEmpty(config.pasteSettings.housepath))
                LoadDataCopyPaste();
        }
        private void CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (crate.OwnerID == 3566257)
            {
                if (RemoveHouseTime != null)
                    RemoveHouseTime.Destroy();
                if (config.boxSetting.signaling)
                {
                    var Alarm = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/alarms/audioalarm.prefab", crate.transform.position, default(Quaternion), true);
                    Alarm.Spawn();
                    Alarm.SetFlag(BaseEntity.Flags.Reserved8, true);
                    Alarm.gameObject.Identity();
                    Alarm.SetParent(crate);

                    var Light = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/lights/sirenlight/electric.sirenlight.deployed.prefab", crate.transform.position, Quaternion.identity, false);
                    Light.enableSaving = true;
                    Light.Spawn();
                    Light.SetParent(crate);
                    Light.transform.localPosition = new Vector3(0.4f, 1.45f, -0.3f);
                    Light.transform.hasChanged = true;
                    Light.SendNetworkUpdate();

                    Light.SetFlag(BaseEntity.Flags.Reserved8, true);
                }
                SendChatAll(config.npcController.helpBot ? "XD_IVENT_CRATEHACKHELP" : "XD_IVENT_CRATEHACK", player.displayName, PosIvent);
                if (config.npcController.helpBot)
                    SpawnBots(crate, true);
            }
        }
        void OnCrateHackEnd(HackableLockedCrate crate)
        {
            if (crate.OwnerID == 3566257)
            {
                if (RemoveHouseTime != null)
                    RemoveHouseTime.Destroy();
                SendChatAll("XD_IVENT_CRATEHACKEND", (config.iventController.timeRemoveHouse2 / 60));
                RemoveHouseTime = timer.Once(config.iventController.timeRemoveHouse2, () =>
                {
                    SendChatAll("XD_IVENT_CRATELOOTFOUND");
                    StopIvent();
                });
            }
        }
        void CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container is HackableLockedCrate && container.OwnerID == 3566257)
            {
                SendChatAll("XD_IVENT_CRATELOOTPLAYER", player.displayName);
                if (RemoveHouseTime != null)
                    RemoveHouseTime.Destroy();
                RemoveHouseTime = timer.Once(300, () =>
                {
                    StopIvent();
                });
                container.OwnerID = 123425345634634;
            }
        }
        void OnCorpsePopulate(Scientist npc, NPCPlayerCorpse corpse)
        {
            if (npc?.GetComponent<NPCMonitor>() != null && corpse != null)
            {
                if (config.npcController.useCustomLoot && config.npcController.lootNpcs?.Count > 0)
                {
                    corpse.containers[0].itemList.Clear();
                    for (int i = 0; i < config.npcController.lootNpcs.Count; i++)
                    {
                        var main = config.npcController.lootNpcs[i];
                        if (corpse.containers[0].IsFull())
                            break;
                        bool goodChance = random.Next(0, 100) >= (100 - main.DropChance);
                        if (goodChance)
                        {
                            if (main.BluePrint)
                            {
                                Item item = ItemManager.Create(ResearchTable.GetBlueprintTemplate(), 1, 0UL);
                                item.blueprintTarget = ItemManager.FindItemDefinition(main.Shortname).itemid;
                                if (!item.MoveToContainer(corpse.containers[0]))
                                    item.Remove();
                            }
                            else
                            {
                                Item item = ItemManager.CreateByName(main.Shortname, random.Next(main.MinimalAmount, main.MaximumAmount), main.SkinID);
                                if (!string.IsNullOrEmpty(main.DisplayName))
                                {
                                    item.name = main.DisplayName;
                                }
                                if (!item.MoveToContainer(corpse.containers[0]))
                                    item.Remove();
                            }
                        }
                    }
                    corpse.containers[0].capacity = corpse.containers[0].itemList.Count;
                    corpse.containers[1].capacity = 0;
                    corpse.containers[2].capacity = 0;
                    corpse.containers[0].MarkDirty();
                    corpse.SendNetworkUpdate();
                }
            }
        }


        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (!entity.IsValid() || hitInfo == null)
                return;
            if (entity?.OwnerID == 342968945867)
            {
                hitInfo.damageTypes.ScaleAll(0);
            }

            var attacker = hitInfo.InitiatorPlayer;

            if (attacker.IsValid() && attacker is Scientist && (attacker as NPCPlayerApex).OwnerID == 3566257 && config.npcController.Accuracy < UnityEngine.Random.Range(0f, 100f))
            {
                hitInfo.damageTypes = new DamageTypeList();
                hitInfo.DidHit = false;
                hitInfo.DoHitEffects = false;
                hitInfo.HitEntity = null;
                return;
            }
        }
        #endregion

        #region MetodsPasteBuild
        void GenerateBuilding()
        {
            string[] options = { "stability", "true", "deployables", "true", "autoheight", "false", "entityowner", "false" };
            Vector3 resultVector = (Vector3)GetSpawnPoints();
            if (resultVector == null || resultVector == Vector3.zero)
                return;

            var success = CopyPaste.Call("TryPasteFromVector3", new Vector3(resultVector.x, resultVector.y + config.pasteSettings.heightBuilding, resultVector.z), 0f, !string.IsNullOrWhiteSpace(config.pasteSettings.housepath) ? config.pasteSettings.housepath : "HouseCobalt", options);

            if (success is string)
            {
                PrintWarning("Ошибка #1 \nПлагин не будет работать, Обратитесь к разработчику");
                GenerateIvent();
                return;
            }
        }

        void OnPasteFinished(List<BaseEntity> pastedEntities, string fileName)
        {
            if (fileName != "HouseCobalt" && fileName != config.pasteSettings.housepath)
                return;

            HouseCobaltLab = pastedEntities;
            BaseEntity box = null;
            List<CCTV_RC> cam = new List<CCTV_RC>();
            ComputerStation comp = null;
            foreach (BaseEntity ent in pastedEntities)
            {
                if (ent is MiniCopter)
                {
                    MiniCopter copter = (ent as MiniCopter);
                    copter.fuelSystem.AddStartingFuel(50);
                    copter.transform.position = new Vector3(copter.transform.position.x, copter.transform.position.y + 3f, copter.transform.position.z);
                    continue;
                }
                ent.OwnerID = 342968945867;
                if (ent is Signage)
                {
                    var ents = ent as Signage;
                    if (ents == null)
                        continue;
                    ents?.SetFlag(BaseEntity.Flags.Locked, true);
                    ents.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);
                }
                if (ent is Workbench || ent is ResearchTable || ent is MixingTable || ent is BaseArcadeMachine
                  || ent is IOEntity || ent is ComputerStation || ent is CCTV_RC)
                {
                    if (ent is IOEntity)
                        ent.SetFlag(BaseEntity.Flags.Reserved8, true);
                    if (ent is ComputerStation)
                        comp = ent as ComputerStation;
                    if (ent is CCTV_RC)
                        cam.Add(ent as CCTV_RC);
                    var ents = ent as BaseCombatEntity;
                    if (ents == null)
                        continue;
                    ents.pickup.enabled = false;
                    continue;
                }
                if (ent is VendingMachine)
                {
                    var ents = ent as VendingMachine;
                    if (ents == null)
                        continue;
                    ents.SetFlag(BaseEntity.Flags.Reserved4, false);
                    ents.UpdateMapMarker();
                }
                if (ent is FogMachine)
                {
                    var ents = ent as FogMachine;
                    if (ents == null)
                        continue;
                    ents.SetFlag(BaseEntity.Flags.Reserved8, true);
                    ents.SetFlag(BaseEntity.Flags.Reserved7, false);
                    ents.SetFlag(BaseEntity.Flags.Reserved6, false);
                }
                if (ent.name == "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab")
                {
                    box = CrateHackableLocked(ent);
                    NextTick(() => { HouseCobaltLab.Remove(ent); ent.Kill(); HouseCobaltLab.Add(box); });
                    continue;

                }
                if (ent is Door)
                {
                    var ents = ent as Door;
                    if (ents == null)
                        continue;
                    ents.pickup.enabled = false;
                    ents.canTakeLock = false;
                    ents.canTakeCloser = false;
                    continue;
                }
                if (ent is ElectricGenerator)
                {
                    (ent as ElectricGenerator).electricAmount = 400;
                }
                if (ent as BuildingBlock)
                {
                    var build = ent as BuildingBlock;
                    build?.SetFlag(BaseEntity.Flags.Reserved1, false);
                    build?.SetFlag(BaseEntity.Flags.Reserved2, false);
                }
                ent?.SetFlag(BaseEntity.Flags.Busy, true);
                ent?.SetFlag(BaseEntity.Flags.Locked, true);
            }
            if (comp != null && cam.Count > 0)
            {
                foreach (CCTV_RC sd in cam)
                    comp.controlBookmarks.Add(sd.GetIdentifier(), sd.net.ID);
            }
            if (box == null)
            {
                PrintError("Ошибка #3, В постройке не найден ящик");
                StopIvent();
                GenerateIvent();
                return;
            }
            NpcZones Zone = new GameObject().AddComponent<NpcZones>();
            npcZones.Add(Zone);
            Zone.Activate(box, 15, config.radiationConroller.radUse);
            if (config.npcController.useSpawnNPC)
                SpawnBots(box);
            PosIvent = GetGridString(box.transform.position);
            GenerateMapMarker(box.transform.position);
            SendChatAll("XD_IVENT_START", PosIvent);
            if (config.notiferSettings.useUiNotifi)
                Cui.CreateUIAllPlayer();

            RemoveHouseTime = timer.Once(config.iventController.timeRemoveHouse, () =>
            {
                SendChatAll("XD_IVENT_NOPLAYER");
                StopIvent();
            });
        }

        private void GenerateMapMarker(Vector3 pos)
        {
            if (config.mapMarkers.rustMapUse)
                RustMap?.Call("ApiAddPointUrl", config.mapMarkers.rustMapIcon, Title, pos, config.mapMarkers.rustMapTxt);

            if (config.mapMarkers.MapUse)
                Interface.CallHook("API_CreateMarker", pos, "xdcobaltlab", 0, 3f, 0.3f, config.mapMarkers.MapTxt, "aeb769", "37382e");
        }

        private void RemoveMapMarker()
        {
            if (config.mapMarkers.rustMapUse)
                RustMap?.Call("ApiRemovePointUrl", Title);
            if (config.mapMarkers.MapUse)
                Interface.CallHook("API_RemoveMarker", "xdcobaltlab");
        }
        #endregion

        #region MainMetods
        private void GenerateIvent()
        {
            if (RemoveHouseTime != null)
                RemoveHouseTime.Destroy();
            if (SpawnHouseTime != null)
                SpawnHouseTime.Destroy();
            SpawnHouseTime = timer.Once(GenerateSpawnIventTime(), () =>
            {
                StartIvent();
            });
        }
        private BaseEntity CrateHackableLocked(BaseEntity box)
        {
            HackableLockedCrate CrateEnt = GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", new Vector3(box.transform.position.x, box.transform.position.y + 1f, box.transform.position.z), box.transform.rotation, true) as HackableLockedCrate;
            CrateEnt.enableSaving = false;
            CrateEnt.Spawn();
            CrateEnt.OwnerID = 3566257;
            CrateEnt.inventory.itemList.Clear();
            for (int i = 0; i < config.boxSetting.lootBoxes.Count; i++)
            {
                if (CrateEnt.inventory.itemList.Count >= config.boxSetting.maxItemCount)
                    break;
                var cfg = config.boxSetting.lootBoxes[i];
                bool goodChance = UnityEngine.Random.Range(0, 100) >= (100 - cfg.DropChance);

                if (goodChance)
                {
                    if (cfg.BluePrint)
                    {
                        Item bp = ItemManager.Create(ResearchTable.GetBlueprintTemplate());
                        bp.blueprintTarget = ItemManager.FindItemDefinition(cfg.Shortname).itemid;
                        if (!bp.MoveToContainer(CrateEnt.inventory))
                            bp.Remove();
                    }
                    else
                    {

                        int s = random.Next(cfg.MinimalAmount, cfg.MaximumAmount);
                        if (config.boxSetting.lootWipePlus && cfg.wipeCheck)
                            s = s * 2;

                        Item GiveItem = ItemManager.CreateByName(cfg.Shortname, s, cfg.SkinID);
                        if (!string.IsNullOrEmpty(cfg.DisplayName))
                        {
                            GiveItem.name = cfg.DisplayName;
                        }
                        if (!GiveItem.MoveToContainer(CrateEnt.inventory))
                            GiveItem.Remove();
                    }
                }
            }
            CrateEnt.inventory.capacity = CrateEnt.inventory.itemList.Count;
            CrateEnt.inventory.MarkDirty();
            CrateEnt.SendNetworkUpdate();
            CrateEnt.hackSeconds = HackableLockedCrate.requiredHackSeconds - config.boxSetting.unBlockTime;
            return CrateEnt;
        }

        private void StartIvent()
        {
            if (BasePlayer.activePlayerList.Count < config.iventController.minPlayedPlayers)
            {
                Puts("Недостаточно игроков для запуска ивента!");
                GenerateIvent();
                return;
            }
            if (RemoveHouseTime != null)
                RemoveHouseTime.Destroy();
            if (SpawnHouseTime != null)
                SpawnHouseTime.Destroy();
            SubscribeHook();
            GenerateBuilding();
        }

        private void StopIvent()
        {
            foreach (BaseEntity iventEnt in HouseCobaltLab)
                if (!iventEnt.IsDestroyed)
                    iventEnt?.Kill();
            if (config.notiferSettings.useUiNotifi)
                Cui.DestroyAllPlayer();

            HouseCobaltLab.Clear();
            if (SpawnHouseTime != null)
                SpawnHouseTime.Destroy();
            if (RemoveHouseTime != null)
                RemoveHouseTime.Destroy();
            DestroyZone();
            UnscribeHook();
            RemoveMapMarker();
            GenerateIvent();
        }

        private void UnscribeHook()
        {
            Unsubscribe("OnEntityTakeDamage");
            Unsubscribe("OnCorpsePopulate");
            Unsubscribe("CanLootEntity");
            Unsubscribe("OnCrateHackEnd");
            Unsubscribe("CanHackCrate");
            Unsubscribe("OnEntityMounted");
        }
        private void SubscribeHook()
        {
            Subscribe("OnEntityTakeDamage");
            Subscribe("OnCorpsePopulate");
            Subscribe("CanLootEntity");
            Subscribe("OnCrateHackEnd");
            Subscribe("CanHackCrate");
            Subscribe("OnEntityMounted");
        }


        #region Method controller npc
        Vector3 RandomCircle(Vector3 center, float radius = 2)
        {
            float ang = UnityEngine.Random.value * 360;
            Vector3 pos;
            pos.x = center.x + radius * Mathf.Sin(ang * Mathf.Deg2Rad);
            pos.z = center.z + radius * Mathf.Cos(ang * Mathf.Deg2Rad);
            pos.y = center.y;
            pos.y = GetGroundPosition(pos);

            return pos;
        }

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;

            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" })) && !hit.collider.name.Contains("rock_cliff"))
                return Mathf.Max(hit.point.y, y);
            return y;
        }

        private NPCPlayerApex InstantiateEntity(string type, Vector3 position)
        {
            position.y = GetGroundPosition(position);
            var gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, new Quaternion());
            gameObject.name = type;
            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);
            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());
            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            NPCPlayerApex component = gameObject.GetComponent<NPCPlayerApex>();
            return component;
        }
        void SpawnBots(BaseEntity box, bool help = false)
        {
            int count = config.npcController.countSpawnNpc;
            if (help && config.npcController.helpBot)
                if (config.npcController.helpCount > 0)
                    count = config.npcController.helpCount;

            for (int i = 0; i < count; i++)
            {
                NPCPlayerApex entity = null;
                entity = InstantiateEntity("assets/prefabs/npc/scientist/scientist.prefab", RandomCircle(box.transform.position, 10));
                entity.enableSaving = false;
                entity.Spawn();
                entity.OwnerID = 3566257;
                entity.IsInvinsible = false;
                entity.startHealth = config.npcController.healthNPC;
                entity.InitializeHealth(entity.startHealth, entity.startHealth);
                ControllerInventory(entity);
                entity.Stats.AggressionRange = entity.Stats.DeaggroRange = config.npcController.DistanceRange;
                entity.CommunicationRadius = 0;
                entity.displayName = config.npcController.nameNPC.GetRandom();
                entity.GetComponent<Scientist>().LootPanelName = entity.displayName;
                entity.CancelInvoke(entity.EquipTest);
                Equip(entity);
                entity.Stats.MaxRoamRange = 75f;
                entity.NeverMove = true;

                NPCMonitor npcMonitor = entity.gameObject.AddComponent<NPCMonitor>();
                nPCMonitors.Add(npcMonitor);
                
                npcMonitor.Initialize(box);
            }
        }

        public HeldEntity GetFirstWeapon(BasePlayer player)
        {
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item.CanBeHeld() && (item.info.category == ItemCategory.Weapon))
                {
                    BaseProjectile projectile = item.GetHeldEntity() as BaseProjectile;
                    if (projectile != null)
                    {
                        global::Item items = projectile?.GetItem();
                        if (item != null && items.contents != null)
                        {
                            if (UnityEngine.Random.Range(0, 2) == 0)
                            {
                                global::Item item2 = global::ItemManager.CreateByName("weapon.mod.flashlight", 1, 0UL);
                                if (!item2.MoveToContainer(items.contents, -1, true))
                                    item2.Remove(0f);
                            }
                            else
                            {
                                global::Item item3 = global::ItemManager.CreateByName("weapon.mod.lasersight", 1, 0UL);
                                if (!item3.MoveToContainer(items.contents, -1, true))
                                    item3.Remove(0f);
                            }
                        }
                        projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
                        projectile.SendNetworkUpdateImmediate();
                        return item.GetHeldEntity() as HeldEntity;
                    }
                }
            }
            return null;
        }
        private void Equip(BasePlayer player)
        {
            HeldEntity weapon = GetFirstWeapon(player);
            if (weapon != null)
            {
                weapon.SetHeld(true);
                weapon.SetLightsOn(false);
            }
        }

        private void ControllerInventory(BasePlayer player)
        {
            if (player == null)
                return;
            player.inventory.Strip();
            if (config?.npcController?.beltNpc?.Count > 0)
            {
                var index = random.Next(0, config.npcController.beltNpc.Count);
                ItemManager.CreateByName(config.npcController.beltNpc[index].Shortname, 1, config.npcController.beltNpc[index].SkinID).MoveToContainer(player.inventory.containerBelt);
            }
            if (config?.npcController?.wearNpc?.Count > 0)
            {
                for (int i = 0; i < config.npcController.wearNpc.Count; i++)
                {
                    if (player.inventory.containerWear.IsFull())
                        break;

                    var wear = config.npcController.wearNpc[i];
                    ItemManager.CreateByName(wear.Shortname, 1, wear.SkinID).MoveToContainer(player.inventory.containerWear);
                }
            }
        }
        public class NPCMonitor : FacepunchBehaviour
        {
            public NPCPlayerApex player
            {
                get; private set;
            }
            private List<Vector3> patrolPositions = new List<Vector3>();
            private Vector3 homePosition;
            private int lastPatrolIndex = 0;
            private void Awake()
            {
                player = GetComponent<NPCPlayerApex>();
                InvokeRepeating(UpdateDestination, 0f, 5.0f);
                checkNight();
                InvokeRandomized(new Action(checkNight), 0f, 30f, 5f);
            }
            private void checkNight()
            {
                HeldEntity heldEntity1 = player.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                if (heldEntity1 != null)
                    heldEntity1.SetLightsOn(TOD_Sky.Instance.IsNight ? true : false);
            }

            public void Initialize(BaseEntity box)
            {
                this.homePosition = box.transform.position;
                GeneratePatrolPositions();
            }
            private void UpdateDestination()
            {
                if (player.AttackTarget == null)
                {
                    player.NeverMove = true;
                    float distance = (player.transform.position - homePosition).magnitude;
                    bool tooFar = distance > 20;

                    if (player.GetNavAgent == null || !player.GetNavAgent.isOnNavMesh)
                        player.finalDestination = patrolPositions[lastPatrolIndex];
                    else
                    {
                        if (Vector3.Distance(player.transform.position, patrolPositions[lastPatrolIndex]) < 5)
                            lastPatrolIndex++;
                        if (lastPatrolIndex >= patrolPositions.Count)
                            lastPatrolIndex = 0;
                        player.SetDestination(patrolPositions[lastPatrolIndex]);
                    }

                    player.SetDestination(patrolPositions[lastPatrolIndex]);
                    player.SetFact(NPCPlayerApex.Facts.Speed, tooFar ? (byte)NPCPlayerApex.SpeedEnum.Run : (byte)NPCPlayerApex.SpeedEnum.Walk, true, true);
                }
                else
                {
                    player.NeverMove = false;
                    player.IsStopped = false;

                    var attacker = player.AttackTarget as BasePlayer;
                    if (attacker == null)
                        return;

                    if (attacker.IsDead())
                        Forget();
                }
            }
            private void Forget()
            {
                player.lastDealtDamageTime = Time.time - 21f;
                player.SetFact(Facts.HasEnemy, 0, true, true);
                player.SetFact(Facts.EnemyRange, 3, true, true);
                player.SetFact(Facts.AfraidRange, 1, true, true);
                player.AiContext.EnemyNpc = null;
                player.AiContext.EnemyPlayer = null;
                player.AttackTarget = null;
                player.lastAttacker = null;
                player.lastAttackedTime = Time.time - 31f;
                player.LastAttackedDir = Vector3.zero;
                player.SetDestination(patrolPositions[lastPatrolIndex]);
            }
            private void OnDestroy()
            {
                if (player != null && !player.IsDestroyed)
                    player.Kill();
                Destroy(gameObject);
            }
            private void GeneratePatrolPositions()
            {
                for (int i = 0; i < 6; i++)
                {
                    Vector3 position = homePosition + (UnityEngine.Random.onUnitSphere * 20f);
                    position.y = TerrainMeta.HeightMap.GetHeight(position);
                    patrolPositions.Add(position);
                }
                enabled = true;
            }
        }
        #region NpcZonesOrRadiation
        public class NpcZones : MonoBehaviour
        {
            private Vector3 Position;
            private float Radius;
            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "NpcZonesOrRadiation";
                var rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
            }
            public void Activate(BaseEntity box, float radius, bool rad)
            {
                Position = box.transform.position;
                Radius = radius;
                transform.position = Position;
                transform.rotation = new Quaternion();
                UpdateCollider();
                gameObject.SetActive(true);
                enabled = true;
                if (rad)
                {
                    UpdateCollider();
                    gameObject.SetActive(true);
                    enabled = true;
                    var Rads = gameObject.GetComponent<TriggerRadiation>();
                    Rads = Rads ?? gameObject.AddComponent<TriggerRadiation>();
                    Rads.RadiationAmountOverride = config.radiationConroller.radCount;
                    Rads.interestLayers = LayerMask.GetMask("Player (Server)");
                    Rads.enabled = true;
                }
            }
            private void OnDestroy()
            {
                Destroy(gameObject);
            }
            public void Kill()
            {
                Destroy(gameObject);
            }

            private void UpdateCollider()
            {
                var sphereCollider = gameObject.GetComponent<SphereCollider>();
                {
                    if (sphereCollider == null)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                    }
                    sphereCollider.radius = Radius;
                }
            }
        }
        #endregion
        #endregion

        #endregion

        #region HelpMetods

        #region Узнаем квадрат
        string GetGridString(Vector3 pos)
        {
            char[] alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".ToCharArray();

            pos.z = -pos.z;
            pos += new Vector3(TerrainMeta.Size.x, 0, TerrainMeta.Size.z) * .5f;

            var cubeSize = 146.14f;

            int xCube = (int)(pos.x / cubeSize);
            int zCube = (int)(pos.z / cubeSize);
            // int yNumber = 2509;
            int firstLetterIndex = (int)(xCube / alpha.Length) - 1;
            string firstLetter = "";
            if (firstLetterIndex >= 0)
                firstLetter = $"{alpha[firstLetterIndex]}";

            var xStr = $"{firstLetter}{alpha[xCube % 26]}";
            var zStr = $"{zCube}";

            return $"{xStr}{zStr}";
        }

        private string NumberToString(int number)
        {
            bool a = number > 25;
            Char c = (Char)(65 + (a ? number - 26 : number));
            return a ? "A" + c : c.ToString();
        }
        #endregion

        #region discord

        #region FancyDiscord
        public class FancyMessage
        {
            public string content
            {
                get; set;
            }
            public bool tts
            {
                get; set;
            }
            public Embeds[] embeds
            {
                get; set;
            }

            public class Embeds
            {
                public string title
                {
                    get; set;
                }
                public int color
                {
                    get; set;
                }
                public List<Fields> fields
                {
                    get; set;
                }

                public Embeds(string title, int color, List<Fields> fields)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Fields
        {
            public string name
            {
                get; set;
            }
            public string value
            {
                get; set;
            }
            public bool inline
            {
                get; set;
            }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        void SendDiscordMsg(string msg)
        {
            List<Fields> fields = new List<Fields>
            {
                new Fields(lang.GetMessage("XD_IVENT_HOUSECOBALT", this), msg, true),
            };
            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 16775936, fields) });
            Request(config.notiferSettings.weebHook, newMessage.toJSON());
        }

        #endregion

        private static System.Random random = new System.Random();
        private int GenerateSpawnIventTime() => random.Next(config.iventController.minSpawnIvent, config.iventController.maxSpawnIvent);

        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        public void SendChatAll(string Message, params object[] args)
        {
            if (!String.IsNullOrEmpty(config.notiferSettings.weebHook))
            {
                string msg = GetLang(Message, null, args);
                SendDiscordMsg(GetLang(Message + "_DISCORD", null, args));
            }
            if (IQChat)
                IQChat?.Call("API_ALERT", GetLang(Message, null, args));
            else
                BasePlayer.activePlayerList.ToList().ForEach(p => p.SendConsoleCommand("chat.add", ConVar.Chat.ChatChannel.Global, 0, GetLang(Message, p.UserIDString, args)));
        }
        public void SendChatPlayer(string Message, BasePlayer player, ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message);
            else
                player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            sb.Clear();
            return sb.AppendFormat("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a).ToString();
        }
        private void DestroyZone()
        {
            foreach (NpcZones zones in npcZones)
                UnityEngine.Object.Destroy(zones);

            foreach (NPCMonitor zones in nPCMonitors)
                    UnityEngine.Object.Destroy(zones);
        }
        #endregion

        #region Command
        [ChatCommand("cl")]
        void CLCommand(BasePlayer player, string cmd, string[] Args)
        {
            if (!player.IsAdmin)
                return;
            if (Args == null || Args.Length == 0)
            {
                SendChatPlayer($"Используйте:\n/cl start - Запуск ивента досрочно\n/cl stop - отменить ивент досрочно", player);
                return;
            }
            switch (Args[0])
            {
                case "start":
                    {
                        if (SpawnHouseTime.Destroyed)
                        {
                            PrintToChat(player, "Ивент уже активен!");
                        }
                        else
                        {
                            SpawnHouseTime.Destroy();
                            StartIvent();
                        }
                        break;
                    }
                case "stop":
                    {
                        if (SpawnHouseTime.Destroyed)
                        {
                            StopIvent();
                            SendChatAll("Ивент окончен досрочно администратором!");
                        }
                        else
                        {

                            SendChatPlayer("Нет активных ивентов", player);
                        }
                        break;
                    }
            }

        }
        #endregion

        [ConsoleCommand("HideUi")]
        void CMDHideUi(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (Player != null)
            {
                if (!HideUIUser.Contains(player.userID))
                {
                    HideUIUser.Add(player.userID);
                    CuiHelper.DestroyUi(player, "CobaltPanel");
                }
                else
                {
                    HideUIUser.Remove(player.userID);
                    Cui.MainUI(player);
                }
            }
        }

        #region Command itemAddOrReset
        [ChatCommand("cl.items")]
        void BoxItemCommand(BasePlayer player, string cmd, string[] Args)
        {
            if (Args == null || Args.Length == 0)
            {
                SendChatPlayer("Используйте:\n/cl.items add - добавить лут к существующему\n/cl.items reset - заменить старый лут на новый", player);
                return;
            }
            switch (Args[0])
            {
                case "add":
                    {
                        foreach (var item in player.inventory.containerMain.itemList)
                        {
                            config.boxSetting.lootBoxes.Add(new LootNpcOrBox
                            {
                                BluePrint = item.IsBlueprint(),
                                Shortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                                SkinID = item.skin,
                                DisplayName = string.Empty,
                                DropChance = 30,
                                MinimalAmount = 1,
                                MaximumAmount = 1
                            });
                        }
                        SaveConfig();
                        SendChatPlayer("Вы успешно добавили новые предметы для ящика.\nОбязательно настройте их в конфиге", player);
                        break;
                    }
                case "reset":
                    {
                        config.boxSetting.lootBoxes.Clear();
                        foreach (var item in player.inventory.containerMain.itemList)
                        {
                            config.boxSetting.lootBoxes.Add(new LootNpcOrBox
                            {
                                BluePrint = item.IsBlueprint(),
                                Shortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                                SkinID = item.skin,
                                DisplayName = string.Empty,
                                DropChance = 30,
                                MinimalAmount = 1,
                                MaximumAmount = 1
                            });
                        }
                        SaveConfig();
                        SendChatPlayer("Вы успешно заменили все предметы на новые.\nОбязательно настройте их в конфиге", player);
                        break;
                    }
            }
        }
        [ChatCommand("cl.botitems")]
        void NpcLootCommand(BasePlayer player, string cmd, string[] Args)
        {
            if (Args == null || Args.Length == 0)
            {
                SendChatPlayer("Используйте:\n/cl.botitems add - добавить лут к существующему\n/cl.botitems reset - заменить старый лут на новый", player);
                return;
            }
            switch (Args[0])
            {
                case "add":
                    {
                        foreach (var item in player.inventory.containerMain.itemList)
                        {
                            config.npcController.lootNpcs.Add(new LootNpcOrBox
                            {
                                BluePrint = item.IsBlueprint(),
                                Shortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                                SkinID = item.skin,
                                DisplayName = string.Empty,
                                DropChance = 30,
                                MinimalAmount = 1,
                                MaximumAmount = 1
                            });
                        }
                        SaveConfig();
                        SendChatPlayer("Вы успешно добавили новые предметы для npc.\nОбязательно настройте их в конфиге", player);
                        break;
                    }
                case "reset":
                    {
                        config.npcController.lootNpcs.Clear();
                        foreach (var item in player.inventory.containerMain.itemList)
                        {
                            config.npcController.lootNpcs.Add(new LootNpcOrBox
                            {
                                BluePrint = item.IsBlueprint(),
                                Shortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                                SkinID = item.skin,
                                DisplayName = string.Empty,
                                DropChance = 30,
                                MinimalAmount = 1,
                                MaximumAmount = 1
                            });
                        }
                        SaveConfig();
                        SendChatPlayer("Вы успешно заменили все предметы на новые.\nОбязательно настройте их в конфиге", player);
                        break;
                    }
            }
        }
        #endregion

        #region ui

        public static class Cui
        {
            public static void CreateUIAllPlayer()
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    ButtonClose(player);
                    if (_.HideUIUser.Contains(player.userID))
                        continue;
                    MainUI(player);
                }       
            }

            public static void MainUI(BasePlayer player)
            {
                var container = new CuiElementContainer();
                container.Add(new CuiPanel
                {   
                    CursorEnabled = false,
                    Image = { Color = config.notiferSettings.colorBackground, Sprite = "assets/content/materials/highlight.png", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", FadeIn = 0.2f },
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-342.195 -15.973", OffsetMax = "-13.805 59.667" }
                }, "Overlay", "CobaltPanel");

                container.Add(new CuiElement
                {
                    Name = "CobaltImg",
                    Parent = "CobaltPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "0.9568628 0.7254902 0 1", Material = "assets/icons/iconmaterial.mat", Sprite = "assets/icons/radiation.png", FadeIn = 0.2f },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "6.5 -17.5", OffsetMax = "41.5 17.5" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CobaltTitle",
                    Parent = "CobaltPanel",
                    Components = {
                    new CuiTextComponent { Text =  _.lang.GetMessage("XD_IVENT_HOUSECOBALT", _).ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FadeIn = 0.2f },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "0.5 0.5" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-103.801 -23.938", OffsetMax = "103.801 -2.861" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CobaltInfo",
                    Parent = "CobaltPanel",
                    Components = {
                    new CuiTextComponent { Text = string.Format(_.lang.GetMessage("XD_IVENT_STARTUI", _), _.PosIvent), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FadeIn = 0.2f },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-118.84 -33.077", OffsetMax = "151.44 13.881" }
                }
                });
                CuiHelper.AddUi(player, CuiHelper.ToJson(container)); 
            }

            public static void ButtonClose(BasePlayer player)
            {
                var container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = config.notiferSettings.colorBtnCloseUi },
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-13.854 -15.973", OffsetMax = "0 59.667" }
                }, "Overlay", "CobaltClosePanel");

                container.Add(new CuiElement
                {
                    Name = "ButtonClodedUI",
                    Parent = "CobaltClosePanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Material = "assets/icons/iconmaterial.mat", Sprite = "assets/icons/chevron_right.png" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-8.739 -11.998", OffsetMax = "8.74 11.998" }
                }
                });

                container.Add(new CuiButton
                {
                    Text = { Text = "" },
                    Button = { Command = "HideUi", Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-8.739 -37.82", OffsetMax = "8.74 37.82" }
                }, "CobaltClosePanel", "Closed");

                CuiHelper.AddUi(player, CuiHelper.ToJson(container));
            }

            public static void DestroyAllPlayer()
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(Net.sv.connections), null, "DestroyUI", "CobaltClosePanel");
                CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(Net.sv.connections), null, "DestroyUI", "CobaltPanel");
            }
        }
        #endregion
    }
}

// --- End of file: XDCobaltLaboratory.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PreferredEnvironment.cs ---
// --- Original Local Path: PreferredEnvironment.cs ---

﻿using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PreferredEnvironment", "Sempai#3239", "2.0.12")]
    [Description("Allows players to customize their environment settings, or create presets that apply to specified zones")]
    public class PreferredEnvironment : RustPlugin
    {
        private const string PERMISSION_USE = "preferredenvironment.use";
        private const string PERMISSION_ADMIN = "preferredenvironment.admin";

        private const string WEATHER_VAR_FILTER = "weather.";

        private Dictionary<ulong, EnvironmentInfo> userEnvironmentInfo = new Dictionary<ulong, EnvironmentInfo>();
        private DynamicConfigFile userData;

        private static Hash<string, ConsoleSystem.Command> weatherConvars;

        private bool initialized = false;

        #region Oxide
        private void Init()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
            permission.RegisterPermission(PERMISSION_ADMIN, this);

            if (!permission.PermissionExists(configData.TimePermission))
                permission.RegisterPermission(configData.TimePermission, this);

            if (!permission.PermissionExists(configData.WeatherPermission))
                permission.RegisterPermission(configData.WeatherPermission, this);

            SetWeatherVars();

            ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Error.NoPermission"] = "You are not allowed to use this command",
                ["Error.NoTimeVar"] = "You must enter a number between 0.0 and 24.0 (-1 to disable)",
                ["Notification.WeatherDisabled"] = "Custom weather has been disabled",
                ["Notification.TimeDisabled"] = "Custom time has been disabled",
                ["Notification.HasZoneOverride"] = "You currently can not edit time/weather settings as you are in a zone override",
                ["Notification.AdminOverride"] = "A admin has set your environment variable \"{0}\" to \"{1}\"",
                ["Notification.SetTime"] = "You have set the time to {0}",
                ["Weather.Fog"] = "Fog",
                ["Weather.Rain"] = "Rain",
                ["Weather.Rainbow"] = "Rainbow",
                ["Weather.Thunder"] = "Thunder",
                ["Weather.Wind"] = "Wind",
                ["Weather.AtmosphereBrightness"] = "Atmosphere Brightness",
                ["Weather.AtmosphereContrast"] = "Atmosphere Contrast",
                ["Weather.AtmosphereDirectionality"] = "Atmosphere Directionality",
                ["Weather.AtmosphereMie"] = "Atmosphere Mie",
                ["Weather.AtmosphereRayleigh"] = "Atmosphere Rayleigh",
                ["Weather.CloudAttenuation"] = "Cloud Attenuation",
                ["Weather.CloudBrightness"] = "Cloud Brightness",
                ["Weather.CloudColoring"] = "Cloud Coloring",
                ["Weather.CloudCoverage"] = "Cloud Coverage",
                ["Weather.CloudOpacity"] = "Cloud Opacity",
                ["Weather.CloudSaturation"] = "Cloud Saturation",
                ["Weather.CloudScattering"] = "Cloud Scattering",
                ["Weather.CloudSharpness"] = "Cloud Sharpness",
                ["Weather.CloudSize"] = "Cloud Size",
                ["Weather.ClearChance"] = "Clear Chance",
                ["Weather.DustChance"] = "Dust Chance",
                ["Weather.FogChance"] = "Fog Chance",
                ["Weather.OvercastChance"] = "Overcast Chance",
                ["Weather.RainChance"] = "Rain Chance",
                ["Weather.StormChance"] = "Storm Chance",
                ["Weather.ProgressTime"] = "Progress Time",
                ["Menu.EnviromentEditor"] = "Environment Editor",
                ["Menu.TimeEditor"] = "Time Editor",
                ["Menu.ServerEnviromentEditor"] = "Server Environment Editor",
                ["Menu.ServerTimeEditor"] = "Server Time Editor",
                ["Menu.Reset"] = "Reset",
                ["Menu.ServerSet"] = "Use Server Value",
                ["Menu.Automated"] = "Automated"
            },
            this);

            if (configData.EnableSaving)
                LoadData();
            else Unsubscribe(nameof(OnServerSave));
        }

        private void OnServerInitialized()
        {
            initialized = true;

            LoadServerVars();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnServerSave() => userData.WriteObject(userEnvironmentInfo);

        private void OnPlayerConnected(BasePlayer player) => player.Invoke(()=> DelayedEnvironmentUpdate(player), 1f);

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            EnvironmentInfo environmentInfo;
            if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                if (environmentInfo.ShouldRemove())
                    userEnvironmentInfo.Remove(player.userID);
            }         
        }

        private void OnUserPermissionRevoked(string id, string permission)
        {
            if (permission.Equals(PERMISSION_USE))
            {
                ulong playerId = ulong.Parse(id);

                EnvironmentInfo environmentInfo;
                if (userEnvironmentInfo.TryGetValue(playerId, out environmentInfo))
                {
                    if (!environmentInfo.HasZoneOverride())
                    {                        
                        SendServerReplicatedVars(FindPlayer(id));                         
                        userEnvironmentInfo.Remove(playerId);
                    }
                }
            }
        }

        private object CanNetworkTo(EnvSync env, BasePlayer player)
        {
            EnvironmentInfo environmentInfo;
            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo) || environmentInfo.GetDesiredTime < 0f)
                return null;

            if (Net.sv.write.Start())
            {
                Connection connection = player.net.connection;
                connection.validate.entityUpdates = connection.validate.entityUpdates + 1;
                BaseNetworkable.SaveInfo saveInfo = new BaseNetworkable.SaveInfo
                {
                    forConnection = player.net.connection,
                    forDisk = false
                };

                Net.sv.write.PacketID(Message.Type.Entities);
                Net.sv.write.UInt32(player.net.connection.validate.entityUpdates);

                using (saveInfo.msg = Pool.Get<ProtoBuf.Entity>())
                {
                    env.Save(saveInfo);

                    float desiredTime = environmentInfo.GetDesiredTime;

                    TOD_CycleParameters time = TOD_Sky.Instance.Cycle;

                    DateTime dateTime = new DateTime(0L, DateTimeKind.Utc);
                    
                    dateTime = dateTime.AddYears(time.Year - 1);
                    dateTime = dateTime.AddMonths(time.Month - 1);
                    dateTime = dateTime.AddDays(time.Day - 1);

                    int hours = Mathf.FloorToInt(desiredTime);
                    dateTime = dateTime.AddHours(hours);
                    dateTime = dateTime.AddMinutes(((Mathf.Round(desiredTime * 100) / 100) - hours) * 60);

                    saveInfo.msg.environment.dateTime = dateTime.ToBinary();

                    saveInfo.msg.ToProto(Net.sv.write);
                    Net.sv.write.Send(new SendInfo(player.net.connection));
                }
            }

            return false;
        }
        
        private void OnServerCommand(string cmd, string[] args)
        {
            if (cmd.StartsWith(WEATHER_VAR_FILTER, StringComparison.OrdinalIgnoreCase))
                SendReplicatedVarsAll();            
        }

        private void Unload()
        {
            ConsoleSystem.OnReplicatedVarChanged -= OnReplicatedVarChanged;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, UI_MENU);
                CuiHelper.DestroyUi(player, UI_DUMMY);
            }

            weatherConvars = null;

            if (initialized)
                ServerMgr.SendReplicatedVars(WEATHER_VAR_FILTER);
        }
        #endregion

        #region Functions        
        private void LoadData()
        {
            userData = Interface.Oxide.DataFileSystem.GetFile("preferred_environment");

            userEnvironmentInfo = userData.ReadObject<Dictionary<ulong, EnvironmentInfo>>();            
        }

        private void LoadServerVars()
        {
            if (configData.Server._clearChance != -1)
                ConVar.Weather.clear_chance = configData.Server._clearChance;

            if (configData.Server._dustChance != -1)
                ConVar.Weather.dust_chance = configData.Server._dustChance;

            if (configData.Server._fogChance != -1)
                ConVar.Weather.fog_chance = configData.Server._fogChance;

            if (configData.Server._overcastChance != -1)
                ConVar.Weather.overcast_chance = configData.Server._overcastChance;

            if (configData.Server._rainChance != -1)
                ConVar.Weather.rain_chance = configData.Server._rainChance;

            if (configData.Server._stormChance != -1)
                ConVar.Weather.storm_chance = configData.Server._stormChance;

            if (configData.Server._atmosphere_brightness != -1)
                ConVar.Weather.atmosphere_brightness = configData.Server._atmosphere_brightness;

            if (configData.Server._atmosphere_contrast != -1)
                ConVar.Weather.atmosphere_contrast = configData.Server._atmosphere_contrast;

            if (configData.Server._atmosphere_directionality != -1)
                ConVar.Weather.atmosphere_directionality = configData.Server._atmosphere_directionality;

            if (configData.Server._atmosphere_mie != -1)
                ConVar.Weather.atmosphere_mie = configData.Server._atmosphere_mie;

            if (configData.Server._atmosphere_rayleigh != -1)
                ConVar.Weather.atmosphere_rayleigh = configData.Server._atmosphere_rayleigh;

            if (configData.Server._cloud_attenuation != -1)
                ConVar.Weather.cloud_attenuation = configData.Server._cloud_attenuation;

            if (configData.Server._cloud_brightness != -1)
                ConVar.Weather.cloud_brightness = configData.Server._cloud_brightness;

            if (configData.Server._cloud_coloring != -1)
                ConVar.Weather.cloud_coloring = configData.Server._cloud_coloring;

            if (configData.Server._cloud_coverage != -1)
                ConVar.Weather.cloud_coverage = configData.Server._cloud_coverage;

            if (configData.Server._cloud_opacity != -1)
                ConVar.Weather.cloud_opacity = configData.Server._cloud_opacity;

            if (configData.Server._cloud_saturation != -1)
                ConVar.Weather.cloud_saturation = configData.Server._cloud_saturation;

            if (configData.Server._cloud_scattering != -1)
                ConVar.Weather.cloud_scattering = configData.Server._cloud_scattering;

            if (configData.Server._cloud_sharpness != -1)
                ConVar.Weather.cloud_sharpness = configData.Server._cloud_sharpness;

            if (configData.Server._cloud_size != -1)
                ConVar.Weather.cloud_size = configData.Server._cloud_size;

            ConVar.Env.progresstime = configData.Server._progressTime;
        }

        private void SetWeatherVars()
        {
            weatherConvars = new Hash<string, ConsoleSystem.Command>();

            foreach (ConsoleSystem.Command replicated in ConsoleSystem.Index.Server.Replicated)
            {
                if (replicated.FullName.StartsWith(WEATHER_VAR_FILTER))
                    weatherConvars.Add(replicated.FullName, replicated);
            }
        }

        private void DelayedEnvironmentUpdate(BasePlayer player)
        {
            if (player != null && player.IsConnected)
            {
                EnvironmentInfo environmentInfo;
                if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                {
                    environmentInfo.BuildReplicatedConvarList();

                    if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE) || environmentInfo.ShouldRemove())
                    {
                        SendServerReplicatedVars(player);
                        userEnvironmentInfo.Remove(player.userID);
                    }
                    else environmentInfo.SendCustomReplicatedVars(player);
                }
            }
        }

        private void OnReplicatedVarChanged(string command, string value)
        {
            if (command.StartsWith(WEATHER_VAR_FILTER, StringComparison.OrdinalIgnoreCase))            
                SendReplicatedVarsAll();            
        }

        private void SendReplicatedVarsAll()
        {
            if (initialized)
                ServerMgr.Instance.StartCoroutine(SendReplicatedVarsAllEnumerator());
        }
        
        private IEnumerator SendReplicatedVarsAllEnumerator()
        {
            List<BasePlayer> list = Pool.GetList<BasePlayer>();
            list.AddRange(BasePlayer.activePlayerList);

            for (int i = 0; i < list.Count; i++)
            {
                BasePlayer player = list[i];

                if (player == null || !player.IsConnected)
                    continue;

                EnvironmentInfo environmentInfo;
                if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                    environmentInfo.SendCustomReplicatedVars(player);
                else SendServerReplicatedVars(player);
                
                yield return null;
                yield return null;
            }

            Pool.FreeList(ref list);
        }

        public void SendServerReplicatedVars(BasePlayer player)
        {
            if (player == null || !player.IsConnected)
                return;

            if (Net.sv.write.Start())
            {
                Net.sv.write.PacketID(Message.Type.ConsoleReplicatedVars);
                Net.sv.write.Int32(weatherConvars.Count);

                foreach (KeyValuePair<string, ConsoleSystem.Command> kvp in weatherConvars)
                {
                    Net.sv.write.String(kvp.Key);
                    Net.sv.write.String(kvp.Value.String);
                }

                Net.sv.write.Send(new SendInfo(player.net.connection));
            }
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("setenv")]
        private void ccmdSetEnvironment(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (!permission.UserHasPermission(arg.Connection.userid.ToString(), PERMISSION_ADMIN))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length < 3)
            {
                SendReply(arg, "\n\nsetenv <name or id> <variable> <value> - Manually set an environment variable for the target player\n\nEnvironment variables;\nfog (0.0 - 1.0)\nrain (0.0 - 1.0)\nrainbow  (0.0 - 1.0)\nthunder (0.0 - 1.0)\nwind (0.0 - 1.0)\natmosphere_brightness (0.0 - 1.0)\natmosphere_contrast (0.0 - 1.0)\natmosphere_directionality (0.0 - 1.0)\natmosphere_mie (0.0 - 1.0)\natmosphere_rayleigh (0.0 - 1.0)\ncloud_attenuation (0.0 - 1.0)\ncloud_brightness (0.0 - 1.0)\ncloud_coloring (0.0 - 1.0)\ncloud_coverage (0.0 - 1.0)\ncloud_opacity (0.0 - 1.0)\ncloud_saturation (0.0 - 1.0)\ncloud_scattering (0.0 - 1.0)\ncloud_sharpness (0.0 - 1.0)\ncloud_size\n\ntime (0.0-24.0)\n\nTo disable any of these variables set the value to '-1'");
                return;
            }

            BasePlayer player = FindPlayer(arg.GetString(0));
            if (player == null)
            {
                SendReply(arg, $"Unable to find a player with the name or ID \"{arg.GetString(0)}\"");
                return;
            }

            string variable = arg.GetString(1);
            float value = arg.GetFloat(2);

            EnvironmentInfo environmentInfo;
            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                userEnvironmentInfo.Add(player.userID, new EnvironmentInfo());
            }

            switch (variable)
            {
                case "fog":
                    environmentInfo.Fog = value;
                    break;
                case "rain":
                    environmentInfo.Rain = value;
                    break;
                case "rainbow":
                    environmentInfo.Rainbow = value;
                    break;
                case "thunder":
                    environmentInfo.Thunder = value;
                    break;
                case "wind":
                    environmentInfo.Wind = value;
                    break;
                case "atmosphere_brightness":
                    environmentInfo.AtmosphereBrightness = value;
                    break;
                case "atmosphere_contrast":
                    environmentInfo.AtmosphereContrast = value;
                    break;
                case "atmosphere_directionality":
                    environmentInfo.AtmosphereDirectionality = value;
                    break;
                case "atmosphere_mie":
                    environmentInfo.AtmosphereMie = value;
                    break;
                case "atmosphere_rayleigh":
                    environmentInfo.AtmosphereRayleigh = value;
                    break;
                case "cloud_attenuation":
                    environmentInfo.CloudAttenuation = value;
                    break;
                case "cloud_brightness":
                    environmentInfo.CloudBrightness = value;
                    break;
                case "cloud_coloring":
                    environmentInfo.CloudColoring = value;
                    break;
                case "cloud_coverage":
                    environmentInfo.CloudCoverage = value;
                    break;
                case "cloud_opacity":
                    environmentInfo.CloudOpacity = value;
                    break;
                case "cloud_saturation":
                    environmentInfo.CloudSaturation = value;
                    break;
                case "cloud_scattering":
                    environmentInfo.CloudScattering = value;
                    break;
                case "cloud_sharpness":
                    environmentInfo.CloudSharpness = value;
                    break;
                case "cloud_size":
                    environmentInfo.CloudSize = value;
                    break;
                case "time":
                    environmentInfo.Time = value;
                    break;
                default:
                    SendReply(arg, "Invalid variable selected!");
                    return;
            }

            SendReply(arg, $"Set environment variable \"{variable}\" to \"{value}\" for player {player.displayName}");

            SendReply(player, string.Format(_msg("Notification.AdminOverride", player.UserIDString), variable, value));

            environmentInfo.BuildReplicatedConvarList();

            if (environmentInfo.ShouldRemove())
            {
                SendServerReplicatedVars(player);
                userEnvironmentInfo.Remove(player.userID);
            }
            else environmentInfo.SendCustomReplicatedVars(player);
        }

        private BasePlayer FindPlayer(string partialNameOrID) => BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.displayName.Equals(partialNameOrID, StringComparison.OrdinalIgnoreCase)) ??
                                                                 BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.displayName.Contains(partialNameOrID, CompareOptions.OrdinalIgnoreCase)) ??
                                                                 BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.UserIDString == partialNameOrID);
        #endregion

        private string _msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        #region ZoneManager
        private void OnEnterZone(string zoneID, BasePlayer player)
        {
            EnvironmentInfo zoneEnvironmentInfo;

            if (!configData.Zones.TryGetValue(zoneID, out zoneEnvironmentInfo))
                return;

            EnvironmentInfo environmentInfo;
            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                userEnvironmentInfo.Add(player.userID, environmentInfo = new EnvironmentInfo());
            }

            environmentInfo.OnEnterZone(zoneID, zoneEnvironmentInfo);
            zoneEnvironmentInfo.SendCustomReplicatedVars(player);
        }

        private void OnExitZone(string zoneID, BasePlayer player)
        {
            if (!configData.Zones.ContainsKey(zoneID))
                return;

            EnvironmentInfo environmentInfo;
            if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                environmentInfo.OnExitZone(zoneID, player);

                if (environmentInfo.ShouldRemove() || (!environmentInfo.HasZoneOverride() && !permission.UserHasPermission(player.UserIDString, PERMISSION_USE)))
                {
                    SendServerReplicatedVars(player);
                    userEnvironmentInfo.Remove(player.userID);
                }
                else environmentInfo.SendCustomReplicatedVars(player);
            }
        }
        #endregion

        #region UI         
        public static class UI
        {
            public static CuiElementContainer Container(string panelName, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName.ToString()
                    }
                };
                return container;
            }

            public static CuiElementContainer BlurContainer(string panelName, UI4 dimensions, string color = "0 0 0 0.55", string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = true
                        },
                        new CuiElement().Parent = parent,
                        panelName.ToString()
                    }
                };
                return container;
            }

            public static void Panel(ref CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = cursor
                },
                panel.ToString());
            }

            public static void BlurPanel(ref CuiElementContainer container, string panel, UI4 dimensions, string color = "0 0 0 0.5")
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = false
                },
                panel, CuiHelper.GetGuid());
            }

            public static void Label(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter, FontStyle fontStyle = FontStyle.RobotoCondensed)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Font = ToFontString(fontStyle) },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel.ToString());

            }

            public static void Button(ref CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter, FontStyle fontStyle = FontStyle.RobotoCondensed)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, FontSize = size, Align = align, Font = ToFontString(fontStyle) }
                },
                panel.ToString());
            }

            internal static void Toggle(ref CuiElementContainer container, string panel, string color, int fontSize, UI4 dimensions, string command, bool isOn)
            {
                UI.Panel(ref container, panel, color, dimensions);

                if (isOn)
                    UI.Label(ref container, panel, "✔", fontSize, dimensions);

                UI.Button(ref container, panel, "0 0 0 0", string.Empty, 0, dimensions, command);
            }

            public static void Image(ref CuiElementContainer container, string panel, string png, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent { Png = png },
                        new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static void Input(ref CuiElementContainer container, string panel, string text, int size, string command, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            Align = TextAnchor.MiddleLeft,
                            CharsLimit = 300,
                            Command = command,
                            FontSize = size,
                            IsPassword = false,
                            Text = text
                        },
                        new CuiRectTransformComponent {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }

            public enum FontStyle { DroidSansMono, RobotoCondensed, RobotoCondensedBold, PermanantMarker }

            private static string ToFontString(FontStyle fontStyle)
            {
                switch (fontStyle)
                {
                    case FontStyle.DroidSansMono:
                        return "droidsansmono.ttf";
                    case FontStyle.PermanantMarker:
                        return "permanentmarker.ttf";
                    case FontStyle.RobotoCondensed:
                        return "robotocondensed-regular.ttf";
                    case FontStyle.RobotoCondensedBold:
                    default:
                        return "robotocondensed-bold.ttf";
                }
            }
        }

        public class UI4
        {
            [JsonProperty(PropertyName = "Left (0.0 - 1.0)")]
            public float xMin;

            [JsonProperty(PropertyName = "Bottom (0.0 - 1.0)")]
            public float yMin;

            [JsonProperty(PropertyName = "Right (0.0 - 1.0)")]
            public float xMax;

            [JsonProperty(PropertyName = "Top (0.0 - 1.0)")]
            public float yMax;

            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }

            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";

            public static UI4 zero = new UI4(0f, 0f, 0f, 0f);
        }
        #endregion

        #region UI Creation
        private const string UI_MENU = "pe.menu";
        private const string UI_DUMMY = "pe.dummy";

        private void OpenDummyContainer(BasePlayer player)
        {
            CuiElementContainer container = UI.BlurContainer(UI_DUMMY, UI4.zero);
            CuiHelper.DestroyUi(player, UI_DUMMY);
            CuiHelper.AddUi(player, container);
        }

        private void OpenEnvironmentEditor(BasePlayer player, EnvironmentInfo environmentInfo)
        {
            bool hasWeatherPerm = permission.UserHasPermission(player.UserIDString, configData.WeatherPermission);
            bool hasTimePerm = permission.UserHasPermission(player.UserIDString, configData.TimePermission);

            if (!hasWeatherPerm && hasTimePerm)
            {
                CuiElementContainer container = UI.BlurContainer(UI_MENU, new UI4(0.35f, 0.53f, 0.65f, 0.6f));
                UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 0.5f, 1f, 1f), UI.Color("000000", 0.7f));
                UI.Label(ref container, UI_MENU, _msg("Menu.TimeEditor", player.UserIDString), 16, new UI4(0.01f, 0.55f, 0.95f, 0.95f), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);
                UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), _msg("Menu.Reset", player.UserIDString), 12, new UI4(0.85f, 0.55f, 0.95f, 0.95f), "pe.reset");
                UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), "✘", 12, new UI4(0.955f, 0.55f, 0.995f, 0.95f), "pe.closeui");

                UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 0.05f, 1f, 0.45f), UI.Color("000000", 0.7f));
                UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "-", 14, new UI4(0.015f, 0.05f, 0.055f, 0.45f), $"pe.editvalue time {(environmentInfo.Time <= 0 ? -1f : Mathf.Clamp(environmentInfo.Time - 0.5f, 0f, 24f))}");

                if (environmentInfo.Time > 0f)
                    UI.Panel(ref container, UI_MENU, UI.Color("387097", 1f), new UI4(0.06f, 0.05f, 0.06f + ((0.95f - 0.06f) * (environmentInfo.Time / 24f)), 0.45f));

                if (environmentInfo.Time < 0f)
                    UI.Label(ref container, UI_MENU, _msg("Menu.ServerSet", player.UserIDString), 12, new UI4(0.06f, 0.05f, 0.95f, 0.45f), TextAnchor.MiddleCenter);
                else UI.Label(ref container, UI_MENU, $"{environmentInfo.Time}", 12, new UI4(0.06f, 0.05f, 0.95f, 0.45f), TextAnchor.MiddleCenter);

                float progressWidth = (0.95f - 0.06f) * 0.05f;

                for (int i = 0; i < 20; i++)
                {
                    float left = 0.06f + (progressWidth * i);
                    float right = left + progressWidth;

                    UI.Button(ref container, UI_MENU, "0 0 0 0", string.Empty, 0, new UI4(left, 0.05f, right, 0.45f), $"pe.editvalue time {(i + 1) * 1.2f}");
                }

                UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "+", 14, new UI4(0.955f, 0.05f, 0.995f, 0.45f), $"pe.editvalue time {(environmentInfo.Time < 0f ? 0f : Mathf.Clamp(0.5f + environmentInfo.Time, 0f, 24f))}");

                CuiHelper.DestroyUi(player, UI_MENU);
                CuiHelper.AddUi(player, container);
            }
            else if (hasWeatherPerm)
            {
                float totalSize = hasWeatherPerm && hasTimePerm ? 22f : hasWeatherPerm ? 20f : hasTimePerm ? 2f : 22f;

                CuiElementContainer container = UI.BlurContainer(UI_MENU, new UI4(0.35f, 0.19f, 0.65f, 0.8f));

                float size = 1f / totalSize;
                int count = 0;

                UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size)), UI.Color("000000", 0.7f));
                UI.Label(ref container, UI_MENU, _msg("Menu.EnviromentEditor", player.UserIDString), 16, new UI4(0.01f, 1f - (count * size) - size, 0.95f, 1f - (count * size)), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);
                UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), _msg("Menu.Reset", player.UserIDString), 12, new UI4(0.85f, (1f - (count * size) - size) + 0.005f, 0.95f, 1f - (count * size) - 0.005f), "pe.reset");
                UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), "✘", 12, new UI4(0.955f, (1f - (count * size) - size) + 0.005f, 0.995f, 1f - (count * size) - 0.005f), "pe.closeui");
                count++;

                UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (20 * size), 0.4f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));

                UI.BlurPanel(ref container, UI_MENU, new UI4(0.405f, 1f - (20 * size), 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));

                AddMenuOption(ref container, _msg("Weather.Fog", player.UserIDString), "fog", environmentInfo.Fog, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.Rain", player.UserIDString), "rain", environmentInfo.Rain, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.Rainbow", player.UserIDString), "rainbow", environmentInfo.Rainbow, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.Thunder", player.UserIDString), "thunder", environmentInfo.Thunder, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.Wind", player.UserIDString), "wind", environmentInfo.Wind, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereBrightness", player.UserIDString), "atmosphere_brightness", environmentInfo.AtmosphereBrightness, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereContrast", player.UserIDString), "atmosphere_contrast", environmentInfo.AtmosphereContrast, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereDirectionality", player.UserIDString), "atmosphere_directionality", environmentInfo.AtmosphereDirectionality, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereMie", player.UserIDString), "atmosphere_mie", environmentInfo.AtmosphereMie, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereRayleigh", player.UserIDString), "atmosphere_rayleigh", environmentInfo.AtmosphereRayleigh, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudAttenuation", player.UserIDString), "cloud_attenuation", environmentInfo.CloudAttenuation, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudBrightness", player.UserIDString), "cloud_brightness", environmentInfo.CloudBrightness, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudColoring", player.UserIDString), "cloud_coloring", environmentInfo.CloudColoring, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudCoverage", player.UserIDString), "cloud_coverage", environmentInfo.CloudCoverage, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudOpacity", player.UserIDString), "cloud_opacity", environmentInfo.CloudOpacity, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudSaturation", player.UserIDString), "cloud_saturation", environmentInfo.CloudSaturation, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudScattering", player.UserIDString), "cloud_scattering", environmentInfo.CloudScattering, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudSharpness", player.UserIDString), "cloud_sharpness", environmentInfo.CloudSharpness, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudSize", player.UserIDString), "cloud_size", environmentInfo.CloudSize, count, size, player.UserIDString);
                count++;

                if (hasTimePerm)
                {
                    UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));
                    UI.Label(ref container, UI_MENU, _msg("Menu.TimeEditor", player.UserIDString), 16, new UI4(0.01f, 1f - (count * size) - size, 0.95f, 1f - (count * size)), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);
                    count++;

                    UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));
                    AddTimeOption(ref container, environmentInfo.Time, count, size, player.UserIDString);
                    count++;
                }

                CuiHelper.DestroyUi(player, UI_MENU);
                CuiHelper.AddUi(player, container);
            }           
        }

        private void OpenServerEnvironmentEditor(BasePlayer player)
        {
            CuiElementContainer container = UI.BlurContainer(UI_MENU, new UI4(0.35f, 0.02f, 0.65f, 0.96f));

            float size = 1f / 29f;
            int count = 0;

            UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size)), UI.Color("000000", 0.7f));
            UI.Label(ref container, UI_MENU, _msg("Menu.ServerEnviromentEditor", player.UserIDString), 16, new UI4(0.01f, 1f - (count * size) - size, 0.95f, 1f - (count * size)), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);

            UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), _msg("Menu.Reset", player.UserIDString), 12, new UI4(0.85f, (1f - (count * size) - size) + 0.005f, 0.95f, 1f - (count * size) - 0.005f), "pe.servreset");
            UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), "✘", 12, new UI4(0.955f, (1f - (count * size) - size) + 0.005f, 0.995f, 1f - (count * size) - 0.005f), "pe.closeui");
            count++;

            UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (26 * size), 0.4f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));

            UI.BlurPanel(ref container, UI_MENU, new UI4(0.405f, 1f - (26 * size), 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));

            AddMenuOption(ref container, _msg("Weather.Fog", player.UserIDString), "fog", ConVar.Weather.fog, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.Rain", player.UserIDString), "rain", ConVar.Weather.rain, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.Rainbow", player.UserIDString), "rainbow", ConVar.Weather.rainbow, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.Thunder", player.UserIDString), "thunder", ConVar.Weather.thunder, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.Wind", player.UserIDString), "wind", ConVar.Weather.wind, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereBrightness", player.UserIDString), "atmosphere_brightness", ConVar.Weather.atmosphere_brightness, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereContrast", player.UserIDString), "atmosphere_contrast", ConVar.Weather.atmosphere_contrast, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereDirectionality", player.UserIDString), "atmosphere_directionality", ConVar.Weather.atmosphere_directionality, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereMie", player.UserIDString), "atmosphere_mie", ConVar.Weather.atmosphere_mie, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereRayleigh", player.UserIDString), "atmosphere_rayleigh", ConVar.Weather.atmosphere_rayleigh, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudAttenuation", player.UserIDString), "cloud_attenuation", ConVar.Weather.cloud_attenuation, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudBrightness", player.UserIDString), "cloud_brightness", ConVar.Weather.cloud_brightness, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudColoring", player.UserIDString), "cloud_coloring", ConVar.Weather.cloud_coloring, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudCoverage", player.UserIDString), "cloud_coverage", ConVar.Weather.cloud_coverage, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudOpacity", player.UserIDString), "cloud_opacity", ConVar.Weather.cloud_opacity, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudSaturation", player.UserIDString), "cloud_saturation", ConVar.Weather.cloud_saturation, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudScattering", player.UserIDString), "cloud_scattering", ConVar.Weather.cloud_scattering, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudSharpness", player.UserIDString), "cloud_sharpness", ConVar.Weather.cloud_sharpness, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudSize", player.UserIDString), "cloud_size", ConVar.Weather.cloud_size, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.ClearChance", player.UserIDString), "clear_chance", ConVar.Weather.clear_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.DustChance", player.UserIDString), "dust_chance", ConVar.Weather.dust_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.FogChance", player.UserIDString), "fog_chance", ConVar.Weather.fog_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.OvercastChance", player.UserIDString), "overcast_chance", ConVar.Weather.overcast_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.RainChance", player.UserIDString), "rain_chance", ConVar.Weather.rain_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.StormChance", player.UserIDString), "storm_chance", ConVar.Weather.storm_chance, count, size, player.UserIDString, true);
            count++;

            UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));
            UI.Label(ref container, UI_MENU, _msg("Menu.ServerTimeEditor", player.UserIDString), 16, new UI4(0.01f, 1f - (count * size) - size, 0.95f, 1f - (count * size)), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);
            count++;

            UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - ((count + 1) * size) - size, 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));
            AddTimeOption(ref container, ConVar.Env.time, count, size, player.UserIDString, true);
            count++;

            AddMenuToggle(ref container, _msg("Weather.ProgressTime", player.UserIDString), "progress_time", ConVar.Env.progresstime, count, size, player.UserIDString, true);
            count++;

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.AddUi(player, container);
        }

        private void AddMenuOption(ref CuiElementContainer container, string title, string variable, float currentValue, int position, float size, string playerId, bool isServer = false)
        {
            float top = 1f - (position * size);
            float bottom = top - size;
            
            UI.Label(ref container, UI_MENU, title, 14, new UI4(0.015f, bottom, 0.5f, top), TextAnchor.MiddleLeft);

            UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "-", 14, new UI4(0.415f, bottom + 0.005f, 0.455f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} {variable} {(currentValue <= 0f ? -1f : Mathf.Clamp01(currentValue - 0.1f))}");
           
            if (currentValue >= 0f)
            {
                if (currentValue > 0f)
                    UI.Panel(ref container, UI_MENU, UI.Color("387097", 1f), new UI4(0.46f, bottom + 0.015f, 0.46f + ((0.95f - 0.46f) * currentValue), top - 0.0175f));

                UI.Label(ref container, UI_MENU, $"{Mathf.RoundToInt(currentValue * 100f)}%", 12, new UI4(0.46f, bottom + 0.005f, 0.95f, top - 0.0075f), TextAnchor.MiddleCenter);
            }
            else
            {
                UI.Label(ref container, UI_MENU, isServer ? _msg("Menu.Automated", playerId) : _msg("Menu.ServerSet", playerId), 12, new UI4(0.46f, bottom + 0.005f, 0.95f, top - 0.0075f), TextAnchor.MiddleCenter);
            }

            float progressWidth = (0.95f - 0.46f) * 0.1f;

            for (int i = 0; i < 10; i++)
            {
                float left = 0.46f + (progressWidth * i);
                float right = left + progressWidth;

                UI.Button(ref container, UI_MENU, "0 0 0 0", string.Empty, 0, new UI4(left, bottom + 0.005f, right, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} {variable} {(i + 1) * 0.1f}");
            }

            UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "+", 14, new UI4(0.955f, bottom + 0.005f, 0.995f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} {variable} {(currentValue < 0f ? 0f : Mathf.Clamp01(currentValue + 0.05f))}");
        }

        private void AddTimeOption(ref CuiElementContainer container, float currentValue, int position, float size, string playerId, bool isServer = false)
        {
            float top = 1f - (position * size);
            float bottom = top - size;

            UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "-", 14, new UI4(0.015f, bottom + 0.005f, 0.055f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} time {(currentValue <= 0 ? -1f : Mathf.Clamp(currentValue - 0.5f, 0f, 24f))}");

            if (currentValue > 0f)
                UI.Panel(ref container, UI_MENU, UI.Color("387097", 1f), new UI4(0.06f, bottom + 0.015f, 0.06f + ((0.95f - 0.06f) * (currentValue / 24f)), top - 0.0175f));

            if (currentValue < 0f)
                UI.Label(ref container, UI_MENU, isServer ? _msg("Menu.Automated", playerId) : _msg("Menu.ServerSet", playerId), 12, new UI4(0.06f, bottom + 0.005f, 0.95f, top - 0.0075f), TextAnchor.MiddleCenter);
            else UI.Label(ref container, UI_MENU, $"{currentValue}", 12, new UI4(0.06f, bottom + 0.005f, 0.95f, top - 0.0075f), TextAnchor.MiddleCenter);

            float progressWidth = (0.95f - 0.06f) * 0.05f;

            for (int i = 0; i < 20; i++)
            {
                float left = 0.06f + (progressWidth * i);
                float right = left + progressWidth;

                UI.Button(ref container, UI_MENU, "0 0 0 0", string.Empty, 0, new UI4(left, bottom + 0.005f, right, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} time {(i + 1) * 1.2f}");
            }

            UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "+", 14, new UI4(0.955f, bottom + 0.005f, 0.995f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} time {(currentValue < 0f ? 0f : Mathf.Clamp(0.5f + currentValue, 0f, 24f))}");
        }

        private void AddMenuToggle(ref CuiElementContainer container, string title, string variable, bool currentValue, int position, float size, string playerId, bool isServer = false)
        {
            float top = 1f - (position * size);
            float bottom = top - size;

            UI.Label(ref container, UI_MENU, title, 14, new UI4(0.015f, bottom, 0.5f, top), TextAnchor.MiddleLeft);

            UI.Toggle(ref container, UI_MENU, UI.Color("6a8b38", 1f), 12, new UI4(0.415f, bottom + 0.005f, 0.455f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} {variable} {(currentValue ? 0f : 1f)}", currentValue);
            
        }
        #endregion

        #region UI Commands        
        [ConsoleCommand("pe.closeui")]
        private void ccmdCloseUI(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.DestroyUi(player, UI_DUMMY);

            EnvironmentInfo environmentInfo;
            if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                if (environmentInfo.ShouldRemove())
                {
                    SendServerReplicatedVars(player);
                    userEnvironmentInfo.Remove(player.userID);
                }
            }
        }

        [ConsoleCommand("pe.reset")]
        private void ccmdReset(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!userEnvironmentInfo.ContainsKey(player.userID))
                return;

            EnvironmentInfo environmentInfo = userEnvironmentInfo[player.userID] = new EnvironmentInfo();

            environmentInfo.SendCustomReplicatedVars(player);

            OpenEnvironmentEditor(player, environmentInfo);
        }

        [ConsoleCommand("pe.servreset")]
        private void ccmdServerReset(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            ConVar.Weather.fog = configData.Server.Fog = -1;
            ConVar.Weather.rain = configData.Server.Rain = -1;
            ConVar.Weather.rainbow = configData.Server.Rainbow = -1;
            ConVar.Weather.thunder = configData.Server.Thunder = -1;
            ConVar.Weather.wind = configData.Server.Wind = -1;
            ConVar.Weather.atmosphere_brightness = configData.Server.AtmosphereBrightness = -1;
            ConVar.Weather.atmosphere_contrast = configData.Server.AtmosphereContrast = -1;
            ConVar.Weather.atmosphere_directionality = configData.Server.AtmosphereDirectionality = -1;
            ConVar.Weather.atmosphere_mie = configData.Server.AtmosphereMie = -1;
            ConVar.Weather.atmosphere_rayleigh = configData.Server.AtmosphereRayleigh = -1;
            ConVar.Weather.cloud_attenuation = configData.Server.CloudAttenuation = -1;
            ConVar.Weather.cloud_brightness = configData.Server.CloudBrightness = -1;
            ConVar.Weather.cloud_coloring = configData.Server.CloudColoring = -1;
            ConVar.Weather.cloud_coverage = configData.Server.CloudCoverage = -1;
            ConVar.Weather.cloud_opacity = configData.Server.CloudOpacity = -1;
            ConVar.Weather.cloud_saturation = configData.Server.CloudSaturation = -1;
            ConVar.Weather.cloud_scattering = configData.Server.CloudScattering = -1;
            ConVar.Weather.cloud_sharpness = configData.Server.CloudSharpness = -1;
            ConVar.Weather.cloud_size = configData.Server.CloudSize = -1;
            ConVar.Weather.clear_chance = configData.Server._clearChance = -1;
            ConVar.Weather.dust_chance = configData.Server._dustChance = -1;
            ConVar.Weather.fog_chance = configData.Server._fogChance = -1;
            ConVar.Weather.overcast_chance = configData.Server._overcastChance = -1;
            ConVar.Weather.rain_chance = configData.Server._rainChance = -1;
            ConVar.Weather.storm_chance = configData.Server._stormChance = -1;
            ConVar.Env.progresstime = configData.Server._progressTime = true;
        
            SaveConfig();
            SendReplicatedVarsAll();
            OpenServerEnvironmentEditor(player);
        }

        [ConsoleCommand("pe.editvalue")]
        private void ccmdEditValue(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            EnvironmentInfo environmentInfo;
            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                return;

            string propertyName = arg.GetString(0);
            float value = arg.GetFloat(1);

            switch (propertyName)
            {
                case "fog":
                    environmentInfo.Fog = value;
                    break;
                case "rain":
                    environmentInfo.Rain = value;
                    break;
                case "rainbow":
                    environmentInfo.Rainbow = value;
                    break;
                case "thunder":
                    environmentInfo.Thunder = value;
                    break;
                case "wind":
                    environmentInfo.Wind = value;
                    break;
                case "atmosphere_brightness":
                    environmentInfo.AtmosphereBrightness = value;
                    break;
                case "atmosphere_contrast":
                    environmentInfo.AtmosphereContrast = value;
                    break;
                case "atmosphere_directionality":
                    environmentInfo.AtmosphereDirectionality = value;
                    break;
                case "atmosphere_mie":
                    environmentInfo.AtmosphereMie = value;
                    break;
                case "atmosphere_rayleigh":
                    environmentInfo.AtmosphereRayleigh = value;
                    break;
                case "cloud_attenuation":
                    environmentInfo.CloudAttenuation = value;
                    break;
                case "cloud_brightness":
                    environmentInfo.CloudBrightness = value;
                    break;
                case "cloud_coloring":
                    environmentInfo.CloudColoring = value;
                    break;
                case "cloud_coverage":
                    environmentInfo.CloudCoverage = value;
                    break;
                case "cloud_opacity":
                    environmentInfo.CloudOpacity = value;
                    break;
                case "cloud_saturation":
                    environmentInfo.CloudSaturation = value;
                    break;
                case "cloud_scattering":
                    environmentInfo.CloudScattering = value;
                    break;
                case "cloud_sharpness":
                    environmentInfo.CloudSharpness = value;
                    break;
                case "cloud_size":
                    environmentInfo.CloudSize = value;
                    break;
                case "time":
                    environmentInfo.Time = value;
                    break;
                default:
                    break;
            }

            environmentInfo.SendCustomReplicatedVars(player);

            OpenEnvironmentEditor(player, environmentInfo);
        }

        [ConsoleCommand("pe.server.editvalue")]
        private void ccmdEditServerValue(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            string propertyName = arg.GetString(0);
            float value = arg.GetFloat(1);

            switch (propertyName)
            {
                case "fog":
                    ConVar.Weather.fog = configData.Server.Fog = value;                    
                    break;
                case "rain":
                    ConVar.Weather.rain = configData.Server.Rain = value;
                    break;
                case "rainbow":
                    ConVar.Weather.rainbow = configData.Server.Rainbow = value;
                    break;
                case "thunder":
                    ConVar.Weather.thunder = configData.Server.Thunder = value;
                    break;
                case "wind":
                    ConVar.Weather.wind = configData.Server.Wind = value;
                    break;
                case "atmosphere_brightness":
                    ConVar.Weather.atmosphere_brightness = configData.Server.AtmosphereBrightness = value;
                    break;
                case "atmosphere_contrast":
                    ConVar.Weather.atmosphere_contrast = configData.Server.AtmosphereContrast = value;
                    break;
                case "atmosphere_directionality":
                    ConVar.Weather.atmosphere_directionality = configData.Server.AtmosphereDirectionality = value;
                    break;
                case "atmosphere_mie":
                    ConVar.Weather.atmosphere_mie = configData.Server.AtmosphereMie = value;
                    break;
                case "atmosphere_rayleigh":
                    ConVar.Weather.atmosphere_rayleigh = configData.Server.AtmosphereRayleigh = value;
                    break;
                case "cloud_attenuation":
                    ConVar.Weather.cloud_attenuation = configData.Server.CloudAttenuation = value;
                    break;
                case "cloud_brightness":
                    ConVar.Weather.cloud_brightness = configData.Server.CloudBrightness = value;
                    break;
                case "cloud_coloring":
                    ConVar.Weather.cloud_coloring = configData.Server.CloudColoring = value;
                    break;
                case "cloud_coverage":
                    ConVar.Weather.cloud_coverage = configData.Server.CloudCoverage = value;
                    break;
                case "cloud_opacity":
                    ConVar.Weather.cloud_opacity = configData.Server.CloudOpacity = value;
                    break;
                case "cloud_saturation":
                    ConVar.Weather.cloud_saturation = configData.Server.CloudSaturation = value;
                    break;
                case "cloud_scattering":
                    ConVar.Weather.cloud_scattering = configData.Server.CloudScattering = value;
                    break;
                case "cloud_sharpness":
                    ConVar.Weather.cloud_sharpness = configData.Server.CloudSharpness = value;
                    break;
                case "cloud_size":
                    ConVar.Weather.cloud_size = configData.Server.CloudSize = value;
                    break;
                case "time":
                    ConVar.Env.time = configData.Server.Time = value;
                    break;
                case "clear_chance":
                    ConVar.Weather.clear_chance = configData.Server._clearChance = Mathf.Clamp01(value);
                    break;
                case "dust_chance":
                    ConVar.Weather.dust_chance = configData.Server._dustChance = Mathf.Clamp01(value);
                    break;
                case "fog_chance":
                    ConVar.Weather.fog_chance = configData.Server._fogChance = Mathf.Clamp01(value);
                    break;
                case "overcast_chance":
                    ConVar.Weather.overcast_chance = configData.Server._overcastChance = Mathf.Clamp01(value);
                    break;
                case "rain_chance":
                    ConVar.Weather.rain_chance = configData.Server._rainChance = Mathf.Clamp01(value);
                    break;
                case "storm_chance":
                    ConVar.Weather.storm_chance = configData.Server._stormChance = Mathf.Clamp01(value);
                    break;
                case "progress_time":
                    ConVar.Env.progresstime = configData.Server._progressTime = value < 0.5f ? false : true;
                    break;
                default:
                    break;
            }

            SaveConfig();
            SendReplicatedVarsAll();
            OpenServerEnvironmentEditor(player);
        }
        #endregion

        #region Commands
        [ChatCommand("env")]
        private void cmdEnv(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, configData.TimePermission) && !permission.UserHasPermission(player.UserIDString, configData.WeatherPermission))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            EnvironmentInfo environmentInfo;

            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                userEnvironmentInfo[player.userID] = environmentInfo = new EnvironmentInfo();

            if (environmentInfo.HasZoneOverride())
            {
                player.ChatMessage(_msg("Notification.HasZoneOverride", player.UserIDString));
                return;
            }

            OpenDummyContainer(player);
            OpenEnvironmentEditor(player, environmentInfo);
        }

        [ChatCommand("senv")]
        private void cmdServerEnv(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            OpenDummyContainer(player);
            OpenServerEnvironmentEditor(player);
        }

        [ChatCommand("mytime")]
        private void cmdMyTime(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, configData.TimePermission))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            float time;
            if (args.Length != 1 || !float.TryParse(args[0], out time))
            {
                player.ChatMessage(_msg("Error.NoTimeVar", player.UserIDString));
                return;
            }

            EnvironmentInfo environmentInfo;

            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                userEnvironmentInfo[player.userID] = environmentInfo = new EnvironmentInfo();

            if (environmentInfo.HasZoneOverride())
            {
                player.ChatMessage(_msg("Notification.HasZoneOverride", player.UserIDString));
                return;
            }

            environmentInfo.Time = Mathf.Clamp(time, -1, 24);
            player.ChatMessage(string.Format(_msg("Notification.SetTime", player.UserIDString), environmentInfo.Time));
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty("Save players custom environment settings and apply after restart/relog")]
            public bool EnableSaving { get; set; }

            [JsonProperty("Custom permission to change time")]
            public string TimePermission { get; set; }

            [JsonProperty("Custom permission to change weather")]
            public string WeatherPermission { get; set; }

            [JsonProperty("Zone Environment Profiles. (To disable a variable and use the value set on the server, set the option to -1)")]
            public Dictionary<string, EnvironmentInfo> Zones { get; set; }

            [JsonProperty("Server Environment Profile")]
            public ServerEnvironmentInfo Server { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                EnableSaving = true,
                TimePermission = "preferredenvironment.use",
                WeatherPermission = "preferredenvironment.use",

                Zones = new Dictionary<string, EnvironmentInfo>
                {
                    ["ExampleZoneID"] = new EnvironmentInfo
                    {
                        _fog = -1f,
                        _rain = -1f,
                        _time = -1f,
                        _wind = -1f,
                        _atmosphere_brightness = -1f,
                        _atmosphere_contrast = -1f,
                        _atmosphere_directionality = -1f,
                        _atmosphere_mie = -1f,
                        _atmosphere_rayleigh = -1f,
                        _cloud_attenuation = -1f,
                        _cloud_brightness = -1f,
                        _cloud_coloring = -1f,
                        _cloud_coverage = -1f,
                        _cloud_opacity = -1f,
                        _cloud_saturation = -1f,
                        _cloud_scattering = -1f,
                        _cloud_sharpness = -1f,
                        _cloud_size = -1f,
                        _rainbow = -1f,
                        _thunder = -1f,                        
                    }
                },
                Server = new ServerEnvironmentInfo()
                {
                    _fog = -1f,
                    _rain = -1f,
                    _time = -1f,
                    _wind = -1f,
                    _atmosphere_brightness = -1f,
                    _atmosphere_contrast = -1f,
                    _atmosphere_directionality = -1f,
                    _atmosphere_mie = -1f,
                    _atmosphere_rayleigh = -1f,
                    _cloud_attenuation = -1f,
                    _cloud_brightness = -1f,
                    _cloud_coloring = -1f,
                    _cloud_coverage = -1f,
                    _cloud_opacity = -1f,
                    _cloud_saturation = -1f,
                    _cloud_scattering = -1f,
                    _cloud_sharpness = -1f,
                    _cloud_size = -1f,
                    _rainbow = -1f,
                    _thunder = -1f,
                    _clearChance = -1,
                    _dustChance = -1,
                    _fogChance = -1,
                    _overcastChance = -1,
                    _progressTime = true,
                    _rainChance = -1,
                    _stormChance = -1
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(2, 0, 0))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(2, 0, 6) || configData.Server == null)
                configData.Server = baseConfig.Server;

            if (configData.Version < new VersionNumber(2, 0, 9))
            {
                configData.TimePermission = configData.WeatherPermission = baseConfig.TimePermission;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        private class ServerEnvironmentInfo : EnvironmentInfo
        {
            [JsonProperty("Progress Time")]
            public bool _progressTime = true;

            [JsonProperty("Storm Chance")]
            public float _stormChance = -1f;

            [JsonProperty("Rain Chance")]
            public float _rainChance = -1f;

            [JsonProperty("Overcast Chance")]
            public float _overcastChance = -1f;

            [JsonProperty("Fog Chance")]
            public float _fogChance = -1f;

            [JsonProperty("Dust Chance")]
            public float _dustChance = -1f;

            [JsonProperty("Clear Chance")]
            public float _clearChance = -1f;
        }

        private class EnvironmentInfo
        {
            [JsonProperty("Time (0.0 - 24.0)")]
            public float _time = -1f;

            [JsonProperty("Rain (0.0 - 1.0)")]
            public float _rain = -1f;

            [JsonProperty("Wind (0.0 - 1.0)")]
            public float _wind = -1f;

            [JsonProperty("Fog (0.0 - 1.0)")]
            public float _fog = -1f;

            [JsonProperty("Rainbow (0.0 - 1.0)")]
            public float _rainbow = -1f;

            [JsonProperty("Thunder (0.0 - 1.0)")]
            public float _thunder = -1f;

            [JsonProperty("Atmosphere Brightness (0.0 - 1.0)")]
            public float _atmosphere_brightness = -1f;

            [JsonProperty("Atmosphere Contrast (0.0 - 1.0)")]
            public float _atmosphere_contrast = -1f;

            [JsonProperty("Atmosphere Directionality (0.0 - 1.0)")]
            public float _atmosphere_directionality = -1f;

            [JsonProperty("Atmosphere Mie (0.0 - 1.0)")]
            public float _atmosphere_mie = -1f;

            [JsonProperty("Atmosphere Rayleigh (0.0 - 1.0)")]
            public float _atmosphere_rayleigh = -1f;

            [JsonProperty("Cloud Attenuation (0.0 - 1.0)")]
            public float _cloud_attenuation = -1f;

            [JsonProperty("Cloud Brightness (0.0 - 1.0)")]
            public float _cloud_brightness = -1f;

            [JsonProperty("Cloud Coloring (0.0 - 1.0)")]
            public float _cloud_coloring = -1f;

            [JsonProperty("Cloud Coverage (0.0 - 1.0)")]
            public float _cloud_coverage = -1f;

            [JsonProperty("Cloud Opacity (0.0 - 1.0)")]
            public float _cloud_opacity = -1f;

            [JsonProperty("Cloud Saturation (0.0 - 1.0)")]
            public float _cloud_saturation = -1f;

            [JsonProperty("Cloud Scattering (0.0 - 1.0)")]
            public float _cloud_scattering = -1f;

            [JsonProperty("Cloud Sharpness (0.0 - 1.0)")]
            public float _cloud_sharpness = -1f;

            [JsonProperty("Cloud Size (0.0 - 1.0)")]
            public float _cloud_size = -1f;

            [JsonIgnore]
            public float Rain
            {
                get { return _rain; }
                set { _rain = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Wind
            {
                get { return _wind; }
                set { _wind = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Fog
            {
                get { return _fog; }
                set { _fog = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float AtmosphereBrightness
            {
                get { return _atmosphere_brightness; }
                set { _atmosphere_brightness = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float AtmosphereContrast
            {
                get { return _atmosphere_contrast; }
                set { _atmosphere_contrast = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }
            [JsonIgnore]
            public float AtmosphereDirectionality
            {
                get { return _atmosphere_directionality; }
                set { _atmosphere_directionality = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float AtmosphereMie
            {
                get { return _atmosphere_mie; }
                set { _atmosphere_mie = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float AtmosphereRayleigh
            {
                get { return _atmosphere_rayleigh; }
                set { _atmosphere_rayleigh = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudAttenuation
            {
                get { return _cloud_attenuation; }
                set { _cloud_attenuation = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudBrightness
            {
                get { return _cloud_brightness; }
                set { _cloud_brightness = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudColoring
            {
                get { return _cloud_coloring; }
                set { _cloud_coloring = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudCoverage
            {
                get { return _cloud_coverage; }
                set { _cloud_coverage = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudOpacity
            {
                get { return _cloud_opacity; }
                set { _cloud_opacity = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudSaturation
            {
                get { return _cloud_saturation; }
                set { _cloud_saturation = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudScattering
            {
                get { return _cloud_scattering; }
                set { _cloud_scattering = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudSharpness
            {
                get { return _cloud_sharpness; }
                set { _cloud_sharpness = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudSize
            {
                get { return _cloud_size; }
                set { _cloud_size = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Rainbow
            {
                get { return _rainbow; }
                set { _rainbow = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Thunder
            {
                get { return _thunder; }
                set { _thunder = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Time
            {
                get { return _time; }
                set { _time = value >= 0f ? Mathf.Clamp(value, 0, 24f) : -1f; }
            }

            [JsonIgnore]
            private Hash<string, EnvironmentInfo> zoneOverrides;

            [JsonIgnore]
            private string currentZoneId = string.Empty;

            public bool HasZoneOverride()
            {
                if (zoneOverrides == null || currentZoneId == string.Empty || zoneOverrides.Count == 0)                
                    return false;
                
                return true;
            }

            public bool GetZoneOverride(out EnvironmentInfo environmentInfo)
            {
                if (zoneOverrides == null || currentZoneId == string.Empty || zoneOverrides.Count == 0)
                {
                    environmentInfo = null;
                    return false;
                }

                environmentInfo = zoneOverrides[currentZoneId];
                return true;
            }

            public void OnEnterZone(string zoneId, EnvironmentInfo environmentInfo)
            {
                if (zoneOverrides == null)
                    zoneOverrides = new Hash<string, EnvironmentInfo>();

                currentZoneId = zoneId;
                zoneOverrides[zoneId] = environmentInfo;
            }

            public void OnExitZone(string zoneId, BasePlayer player)
            {
                if (zoneOverrides != null)
                {
                    zoneOverrides.Remove(zoneId);
                    if (currentZoneId == zoneId)
                    {
                        if (zoneOverrides.Count > 0)
                        {
                            foreach (var kvp in zoneOverrides)
                            {
                                currentZoneId = kvp.Key;
                                return;
                            }
                        }
                        else currentZoneId = string.Empty;
                    }
                }
            }

            [JsonIgnore]
            public bool HasReplicatedVars => replicatedVars?.Count > 0;

            [JsonIgnore]
            public bool VarsDirty = true;

            [JsonIgnore]
            private Hash<string, string> replicatedVars;
            
            [JsonIgnore]
            public float GetDesiredTime => HasZoneOverride() ? zoneOverrides[currentZoneId].Time : Time;

            public bool ShouldRemove()
            {
                if (HasZoneOverride())
                    return false;

                if (VarsDirty)
                    BuildReplicatedConvarList();

                if (replicatedVars?.Count > 0 || Time >= 0f)
                    return false;

                return true;                
            }
           
            public void SendCustomReplicatedVars(BasePlayer player)
            {
                if (HasZoneOverride())
                {
                    zoneOverrides[currentZoneId].SendCustomReplicatedVars(player);
                    return;
                }

                if (VarsDirty)
                    BuildReplicatedConvarList();

                if (Net.sv.write.Start())
                {
                    Net.sv.write.PacketID(Message.Type.ConsoleReplicatedVars);
                    Net.sv.write.Int32(weatherConvars.Count);

                    foreach (KeyValuePair<string, ConsoleSystem.Command> kvp in weatherConvars)
                    {
                        Net.sv.write.String(kvp.Key);
                        Net.sv.write.String(replicatedVars.ContainsKey(kvp.Key) ? replicatedVars[kvp.Key] : kvp.Value.String);
                    }
                    
                    Net.sv.write.Send(new SendInfo(player.net.connection));
                }
            }

            public void BuildReplicatedConvarList()
            {
                if (replicatedVars == null)
                    replicatedVars = new Hash<string, string>();

                replicatedVars.Clear();

                if (_atmosphere_brightness >= 0)
                    replicatedVars["weather.atmosphere_brightness"] = _atmosphere_brightness.ToString();

                if (_atmosphere_contrast >= 0)
                    replicatedVars["weather.atmosphere_contrast"] = _atmosphere_contrast.ToString();

                if (_atmosphere_directionality >= 0)
                    replicatedVars["weather.atmosphere_directionality"] = _atmosphere_directionality.ToString();

                if (_atmosphere_directionality >= 0)
                    replicatedVars["weather.atmosphere_directionality"] = _atmosphere_directionality.ToString();

                if (_atmosphere_mie >= 0)
                    replicatedVars["weather.atmosphere_mie"] = _atmosphere_mie.ToString();

                if (_atmosphere_rayleigh >= 0)
                    replicatedVars["weather.atmosphere_rayleigh"] = _atmosphere_rayleigh.ToString();

                if (_cloud_attenuation >= 0)
                    replicatedVars["weather.cloud_attenuation"] = _cloud_attenuation.ToString();

                if (_cloud_brightness >= 0)
                    replicatedVars["weather.cloud_brightness"] = _cloud_brightness.ToString();

                if (_cloud_coloring >= 0)
                    replicatedVars["weather.cloud_coloring"] = _cloud_coloring.ToString();

                if (_cloud_coverage >= 0)
                    replicatedVars["weather.cloud_coverage"] = _cloud_coverage.ToString();

                if (_cloud_opacity >= 0)
                    replicatedVars["weather.cloud_opacity"] = _cloud_opacity.ToString();

                if (_cloud_saturation >= 0)
                    replicatedVars["weather.cloud_saturation"] = _cloud_saturation.ToString();

                if (_cloud_scattering >= 0)
                    replicatedVars["weather.cloud_scattering"] = _cloud_scattering.ToString();

                if (_cloud_sharpness >= 0)
                    replicatedVars["weather.cloud_sharpness"] = _cloud_sharpness.ToString();

                if (_cloud_size >= 0)
                    replicatedVars["weather.cloud_size"] = _cloud_size.ToString();

                if (_fog >= 0)
                    replicatedVars["weather.fog"] = _fog.ToString();

                if (_rain >= 0)
                    replicatedVars["weather.rain"] = _rain.ToString();

                if (_rainbow >= 0)
                    replicatedVars["weather.rainbow"] = _rainbow.ToString();

                if (_thunder >= 0)
                    replicatedVars["weather.thunder"] = _thunder.ToString();

                if (_wind >= 0)
                    replicatedVars["weather.wind"] = _wind.ToString();

                if (replicatedVars.Count > 0)
                {
                    replicatedVars["weather.clear_chance"] = "0";
                    replicatedVars["weather.dust_chance"] = "0";
                    replicatedVars["weather.fog_chance"] = "0";
                    replicatedVars["weather.overcast_chance"] = "0";
                    replicatedVars["weather.rain_chance"] = "0";
                    replicatedVars["weather.storm_chance"] = "0";
                }

                VarsDirty = false;
            }
        }

    }
}


// --- End of file: PreferredEnvironment.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlockStructure.cs ---
// --- Original Local Path: BlockStructure.cs ---

using System.Collections.Generic;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("BlockStructure", "Marat", "1.0.1, ResourceId = 2092")]
	[Description("Sets a limit build in height and depth in water")]
	
    class BlockStructure : RustPlugin
    {
		void Loaded()
        {
			LoadConfiguration();
            LoadDefaultMessages();
			permission.RegisterPermission(permBS, this);
        }
		
		int HeightBlock = 15;
		int WaterBlock = -1;
		bool ConfigChanged;
		bool usePermissions = true;
        bool BlockInHeight = false;
		bool BlockInWater = false;
		bool BlockInRock = false;
        string permBS = "blockstructure.allowed";
		
		protected override void LoadDefaultConfig() => PrintWarning("New configuration file created.");

        void LoadConfiguration()
        {
			HeightBlock = GetConfigValue("Options", "Height for block", HeightBlock);
			WaterBlock = GetConfigValue("Options", "Depth for block", WaterBlock);
			BlockInHeight = GetConfigValue("Options", "Block in Height", BlockInHeight);
			BlockInWater = GetConfigValue("Options", "Block in Water", BlockInWater);
			BlockInRock = GetConfigValue("Options", "Block In Rock", BlockInRock);
			usePermissions = GetConfigValue("Options", "UsePermissions", usePermissions);
			if (!ConfigChanged) return;
            PrintWarning("Configuration file updated.");
            SaveConfig();
		}
		T GetConfigValue<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                ConfigChanged = true;
            }
            if (data.TryGetValue(setting, out value)) return (T)Convert.ChangeType(value, typeof(T));
            value = defaultValue;
            data[setting] = value;
            ConfigChanged = true;
            return (T)Convert.ChangeType(value, typeof(T));
        }
		void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
				["blockWater"] = "<size=16><color=yellow>You can not build in water</color></size>",
                ["blockHeight"] = "<size=16><color=yellow>You can not build higher {0} meters</color></size>",
				["block"] = "<size=16><color=red>You can not build here</color></size>"
            }, this, "en");
        }
        void Block(BaseNetworkable block, BasePlayer player, bool Height, bool Water)
        {
            if (usePermissions && !IsAllowed(player.UserIDString, permBS) && block && !block.isDestroyed)
            {
                Vector3 Pos = block.transform.position;
                if (Height || Water)
                {
                    float height = TerrainMeta.HeightMap.GetHeight(Pos);
                    if (Height && Pos.y - height > HeightBlock)
                    {
                        Reply(player, Lang("blockHeight", player.UserIDString, HeightBlock));
                        block.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                    else if (Water && height < 0 && height < WaterBlock && Pos.y < 2.8f )
                    {
                        Reply(player, Lang("blockWater", player.UserIDString, WaterBlock));
                        block.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                }
				if (BlockInRock)
				{
				    Pos.y += 200;
                    RaycastHit[] hits = Physics.RaycastAll(Pos, Vector3.down, 200.0f);
                    Pos.y -= 200;
                    for (int i = 0; i < hits.Length; i++)
                    {
                        RaycastHit hit = hits[i];
                        if (hit.collider)
                        {
                            if (hit.collider.name == "Mesh")
                            {
							    Reply(player, Lang("block", player.UserIDString));
                                block.Kill(BaseNetworkable.DestroyMode.Gib);
                            }
                        }
                    }
				}
            }
        }
		string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        void Reply(BasePlayer player, string message, string args = null) => PrintToChat(player, $"{message}", args);
        void OnEntityBuilt(Planner plan, GameObject obj) => Block(obj.GetComponent<BaseNetworkable>(), plan.GetOwnerPlayer(), BlockInHeight, BlockInWater);
		bool IsAllowed(string id, string perm) => permission.UserHasPermission(id, perm);
    }
}

// --- End of file: BlockStructure.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MarkerManager.cs ---
// --- Original Local Path: MarkerManager.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using VLB;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("Marker Manager", "Orange", "2.1.1")]
    [Description("Allows to place markers on in-game map")]
    public class MarkerManager : RustPlugin
    {
        #region Vars

        private const string genericPrefab = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string vendingPrefab = "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab";
        private const string permUse = "markermanager.use";
        private const string chatCommand = "marker";

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            cmd.AddChatCommand(chatCommand, this, nameof(cmdMarkerChat));
        }

        private void OnServerInitialized()
        {
            LoadData();
            LoadCustomMarkers();
        }

        private void Unload()
        {
            SaveData();
            RemoveMarkers();
        }

        #endregion

        #region Commands

        private void cmdMarkerChat(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                Message(player, "Permission");
                return;
            }

            if (args == null || args?.Length == 0)
            {
                Message(player, "Usage");
                return;
            }

            switch (args[0].ToLower())
            {
                default:
                    Message(player, "Usage");
                    break;

                case "add":
                case "create":
                    if (args.Length < 8)
                    {
                        Message(player, "Usage");
                    }
                    else
                    {
                        var def = new CachedMarker
                        {
                            position = player.transform.position,
                            name = args[1],
                            duration = Convert.ToInt32(args[2]),
                            refreshRate = Convert.ToSingle(args[3]),
                            radius = Convert.ToSingle(args[4]),
                            displayName = args[5],
                            color1 = args[6],
                            color2 = args[7],
                        };

                        CreateCustomMarker(def, player);
                        SaveCustomMarker(def);
                    }

                    return;

                case "remove":
                case "delete":
                    if (args.Length < 2)
                    {
                        Message(player, "Usage");
                    }
                    else
                    {
                        RemoveCustomMarker(args[1], player);
                    }

                    return;
            }
        }

        #endregion

        #region Core

        private void CreateMarker(Vector3 position, int duration, float refreshRate, string name, string displayName,
            float radius = 0.3f, string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            var marker = new GameObject().AddComponent<CustomMapMarker>();
            marker.name = name;
            marker.displayName = displayName;
            marker.radius = radius;
            marker.position = position;
            marker.duration = duration;
            marker.refreshRate = refreshRate;
            ColorUtility.TryParseHtmlString($"#{colorMarker}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{colorOutline}", out marker.color2);
        }

        private void CreateMarker(BaseEntity entity, int duration, float refreshRate, string name, string displayName,
            float radius = 0.3f, string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            var marker = entity.gameObject.GetOrAddComponent<CustomMapMarker>();
            marker.name = name;
            marker.displayName = displayName;
            marker.radius = radius;
            marker.refreshRate = refreshRate;
            marker.parent = entity;
            marker.position = entity.transform.position;
            marker.duration = duration;
            ColorUtility.TryParseHtmlString($"#{colorMarker}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{colorOutline}", out marker.color2);
        }

        private void RemoveMarker(string name)
        {
            foreach (var marker in UnityEngine.Object.FindObjectsOfType<CustomMapMarker>())
            {
                if (marker.name == name)
                {
                    UnityEngine.Object.Destroy(marker);
                }
            }
        }

        private void RemoveMarkers()
        {
            foreach (var marker in UnityEngine.Object.FindObjectsOfType<CustomMapMarker>())
            {
                UnityEngine.Object.Destroy(marker);
            }
        }

        private void CreateCustomMarker(CachedMarker def, BasePlayer player = null)
        {
            var marker = new GameObject().AddComponent<CustomMapMarker>();
            marker.name = def.name;
            marker.displayName = def.displayName;
            marker.radius = def.radius;
            marker.position = def.position;
            marker.duration = def.duration;
            marker.refreshRate = def.refreshRate;
            marker.placedByPlayer = true;
            ColorUtility.TryParseHtmlString($"#{def.color1}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{def.color2}", out marker.color2);
            Message(player, "Added", marker.displayName, marker.position);
        }

        private void RemoveCustomMarker(string name, BasePlayer player = null)
        {
            var i = 0;
            foreach (var marker in UnityEngine.Object.FindObjectsOfType<CustomMapMarker>())
            {
                if (marker.placedByPlayer == false)
                {
                    continue;
                }

                if (marker.name == name)
                {
                    UnityEngine.Object.Destroy(marker);
                    i++;
                }
            }

            RemoveSavedMarker(name);
            Message(player, "Removed", i);
        }

        private void SaveCustomMarker(CachedMarker def)
        {
            data.Add(def);
        }

        private void LoadCustomMarkers()
        {
            foreach (var def in data)
            {
                CreateCustomMarker(def);
            }
        }

        private void RemoveSavedMarker(string name)
        {
            data.RemoveAll(x => x.name == name);
        }

        #endregion

        #region Localization 1.1.1

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {
                    "Usage", "<color=#00ffff>Usage:</color>\n" +
                             " <color=#00ffff>/marker add</color> name(code name) duration(seconds, 0 to permanent) refreshRate(30) radius(0.4) displayName (on map) colorInline (HEX) colorOutline (HEX) - Add marker on map\n" +
                             " <color=#00ffff>/marker remove</color> name (code name, only for custom markers) - Remove marker from map"
                },
                {"Permission", "You don't have permission to use that!"},
                {"Added", "Marker '{0}' was added on {1}!"},
                {"Removed", "{0} markers with that name was removed!"}
            }, this);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.SendConsoleCommand("chat.add", (object) 0, (object) message);
        }

        #endregion

        #region Data 1.0.0

        private const string filename = "MarkerManager/Custom";
        private static List<CachedMarker> data = new List<CachedMarker>();

        private class CachedMarker
        {
            public float radius;
            public string color1;
            public string color2;
            public string displayName;
            public string name;
            public float refreshRate;
            public Vector3 position;
            public int duration;
        }

        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<List<CachedMarker>>(filename);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }

            SaveData();
            timer.Every(Core.Random.Range(500, 700f), SaveData);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(filename, data);
        }

        #endregion

        #region API

        private void API_CreateMarker(Vector3 position, string name,
            int duration = 0, float refreshRate = 3f, float radius = 0.4f,
            string displayName = "Marker", string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            CreateMarker(position, duration, refreshRate, name, displayName, radius, colorMarker, colorOutline);
        }

        private void API_CreateMarker(BaseEntity entity, string name,
            int duration = 0, float refreshRate = 3f, float radius = 0.4f,
            string displayName = "Marker", string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            CreateMarker(entity, duration, refreshRate, name, displayName, radius, colorMarker, colorOutline);
        }

        private void API_RemoveMarker(string name)
        {
            RemoveMarker(name);
        }

        #endregion

        #region Scripts

        private class CustomMapMarker : MonoBehaviour
        {
            private VendingMachineMapMarker vending;
            private MapMarkerGenericRadius generic;
            public BaseEntity parent;
            private bool asChild;

            public float radius;
            public Color color1;
            public Color color2;
            public string displayName;
            public float refreshRate;
            public Vector3 position;
            public int duration;
            public bool placedByPlayer;

            private void Start()
            {
                transform.position = position;
                asChild = parent != null;
                CreateMarkers();
            }

            private void CreateMarkers()
            {
                vending = GameManager.server.CreateEntity(vendingPrefab, position)
                    .GetComponent<VendingMachineMapMarker>();
                vending.markerShopName = displayName;
                vending.enableSaving = false;
                vending.Spawn();

                generic = GameManager.server.CreateEntity(genericPrefab).GetComponent<MapMarkerGenericRadius>();
                generic.color1 = color1;
                generic.color2 = color2;
                generic.radius = radius;
                generic.alpha = 1f;
                generic.enableSaving = false;
                generic.SetParent(vending);
                generic.Spawn();

                if (duration != 0)
                {
                    Invoke(nameof(DestroyMakers), duration);
                }

                UpdateMarkers();

                if (refreshRate > 0f)
                {
                    if (asChild)
                    {
                        InvokeRepeating(nameof(UpdatePosition), refreshRate, refreshRate);
                    }
                    else
                    {
                        InvokeRepeating(nameof(UpdateMarkers), refreshRate, refreshRate);
                    }
                }
            }

            private void UpdatePosition()
            {
                if (asChild == true)
                {
                    if (parent.IsValid() == false)
                    {
                        Destroy(this);
                        return;
                    }
                    else
                    {
                        var pos = parent.transform.position;
                        transform.position = pos;
                        vending.transform.position = pos;
                    }
                }

                UpdateMarkers();
            }

            private void UpdateMarkers()
            {
                vending.SendNetworkUpdate();
                generic.SendUpdate();
            }

            private void DestroyMakers()
            {
                if (vending.IsValid())
                {
                    vending.Kill();
                }

                if (generic.IsValid())
                {
                    generic.Kill();
                }

                if (placedByPlayer)
                {
                    data.RemoveAll(x => x.name == name);
                }
            }

            private void OnDestroy()
            {
                DestroyMakers();
            }
        }

        #endregion
    }
}

// --- End of file: MarkerManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Draw.cs ---
// --- Original Local Path: Draw.cs ---

using Oxide.Core.Libraries;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Draw", "playrust.io / dcode", "1.0.1", ResourceId = 968)]
    public class Draw : RustPlugin
    {
        [LibraryFunction("Line")]
        public void Line(BasePlayer player, Vector3 from, Vector3 to, Color color, float duration) {
            player.SendConsoleCommand("ddraw.line", duration, color, from, to);
        }

        [LibraryFunction("Arrow")]
        public void Arrow(BasePlayer player, Vector3 from, Vector3 to, float headSize, Color color, float duration) {
            player.SendConsoleCommand("ddraw.arrow", duration, color, from, to, headSize);
        }

        [LibraryFunction("Sphere")]
        public void Sphere(BasePlayer player, Vector3 pos, float radius, Color color, float duration) {
            player.SendConsoleCommand("ddraw.sphere", duration, color, pos, radius);
        }

        [LibraryFunction("Text")]
        public void Text(BasePlayer player, Vector3 pos, string text, Color color, float duration) {
            player.SendConsoleCommand("ddraw.text", duration, color, pos, text);
        }

        [LibraryFunction("Box")]
        public void Box(BasePlayer player, Vector3 pos, float size, Color color, float duration) {
            player.SendConsoleCommand("ddraw.box", duration, color, pos, size);
        }
    }
}


// --- End of file: Draw.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LimitedLadders.cs ---
// --- Original Local Path: LimitedLadders.cs ---

using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("LimitedLadders", "DefaultPlayer(VVoid)", "1.0.2", ResourceId = 1051)]
    public class LimitedLadders : RustPlugin
    {
        private const string LadderPrefabs = "assets/bundled/prefabs/items/ladders/";
        private readonly int LayerMasks = LayerMask.GetMask("Construction");
        private bool DisableOnlyOnConstructions;
        private string BuildingBlockedMsg;
        private bool AllowOnExternalWalls; // TODO

        private void Cfg<T>(string key, ref T var)
        {
            if (Config[key] is T)
                var = (T) Config[key];
            else
            {
                Config[key] = var;
                SaveConfig();
            }
        }

        private void Init()
        {
            Cfg("DisableOnlyOnConstructions", ref DisableOnlyOnConstructions);
            Cfg("BuildingBlockedMsg", ref BuildingBlockedMsg);
            //Cfg("AllowOnExternalWalls", ref AllowOnExternalWalls);
        }

        protected override void LoadDefaultConfig()
        {
            Config["DisableOnlyOnConstructions"] = false;
            Config["BuildingBlockedMsg"] = "Building is blocked!";
            //Config["AllowOnExternalWalls"] = false;
        }

        private void OnServerInitialized()
        {
            PrefabAttribute.server.GetAll<Construction>().Where(pref => pref.fullName.StartsWith(LadderPrefabs))
                .ToList().ForEach(ladder => ladder.canBypassBuildingPermission = DisableOnlyOnConstructions);
        }

        [HookMethod("OnEntityBuilt")]
        private void OnEntityBuilt(HeldEntity heldentity, GameObject gameobject)
        {
            if (!DisableOnlyOnConstructions)
                return;
            var player = heldentity.ownerPlayer;
            if (player.CanBuild())
                return;
            var entity = gameobject.GetComponent<BaseCombatEntity>();
            if (!entity || !entity.LookupPrefabName().StartsWith(LadderPrefabs))
                return;
            if (Physics.CheckSphere(entity.transform.position, 1.2f, LayerMasks))
            {
                entity.Kill(BaseNetworkable.DestroyMode.Gib);
                player.ChatMessage(BuildingBlockedMsg);
                TryReturnLadder(player, entity);
            }
        }

        private static void TryReturnLadder(BasePlayer player, BaseCombatEntity entity)
        {
            var item = ItemManager.CreateByName(Regex.Replace(entity.LookupShortPrefabName(), @"\.prefab$", string.Empty));
            if(item != null)
                player.GiveItem(item);
        }
    }
}

// --- End of file: LimitedLadders.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BotSpawn.cs ---
// --- Original Local Path: BotSpawn.cs ---

﻿using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Game.Rust;
using System.Globalization;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using UnityEngine.SceneManagement;
using Facepunch;
using Rust;

namespace Oxide.Plugins

{
    [Info("BotSpawn", "Steenamaroo", "1.6.8", ResourceId = 2580)]

    [Description("Spawn tailored AI with kits at monuments, custom locations, or randomly.")]

    class BotSpawn : RustPlugin
    {
        [PluginReference]
        Plugin Vanish, Kits;

        const string permAllowed = "botspawn.allowed";
        bool HasPermission(string id, string perm) => permission.UserHasPermission(id, perm);
        int no_of_AI = 0;
        static System.Random random = new System.Random();

        public Dictionary<string, List<Vector3>> spawnLists = new Dictionary<string, List<Vector3>>();

        public Timer aridTimer;
        public Timer temperateTimer;
        public Timer tundraTimer;
        public Timer arcticTimer;

        bool isBiome(string name)
        {
            if (name == "BiomeArid" || name == "BiomeTemperate" || name == "BiomeTundra" || name == "BiomeArctic")
                return true;
            return false;
        }

        #region Data 
        class StoredData
        {
            public Dictionary<string, DataProfile> DataProfiles = new Dictionary<string, DataProfile>();
            public Dictionary<string, ProfileRelocation> MigrationDataDoNotEdit = new Dictionary<string, ProfileRelocation>();
            public StoredData()
            {
            }
        }

        ///////////////////////////////////////////////////////////////////MIGRATION INFO TO REMOVE in 1.6.7
        class StoredDataOld
        {
            public Dictionary<string, MonumentSettings> CustomProfiles = new Dictionary<string, MonumentSettings>();
            public StoredDataOld()
            {
            }
        }
        public class MonumentSettings
        {
            public bool AutoSpawn = false;
            public bool Murderer = false;
            public int Bots = 5;
            public int BotHealth = 100;
            public int Radius = 100;
            public List<string> Kit = new List<string>();
            public string BotNamePrefix = "";
            public List<string> BotNames = new List<string>();
            public int Bot_Accuracy = 4;
            public float Bot_Damage = 0.4f;
            public int Respawn_Timer = 60;
            public bool Disable_Radio = true;
            public float LocationX;
            public float LocationY;
            public float LocationZ;
            public int Roam_Range = 40;
            public bool Peace_Keeper = true;
            public int Peace_Keeper_Cool_Down = 5;
            public bool Weapon_Drop = true;
            public bool Keep_Default_Loadout = false;
            public bool Wipe_Belt = true;
            public bool Wipe_Clothing = true;
            public bool Allow_Rust_Loot = true;
            public int Suicide_Timer = 300;
            public bool Chute = false;
            public int Long_Attack_Distance = 120;
        }
        StoredDataOld storedDataOld;
        ///////////////////////////////////////////////////////////////////////////

        StoredData storedData;
        #endregion

        void Init()
        {
            JsonConvert.DefaultSettings = () => new JsonSerializerSettings
            {
                Formatting = Newtonsoft.Json.Formatting.Indented,
                ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore
            };
            var filter = RustExtension.Filter.ToList();                                                                                                     //Thanks Fuji. :)
            filter.Add("cover points");
            filter.Add("resulted in a conflict");
            RustExtension.Filter = filter.ToArray();
            no_of_AI = 0;
            LoadConfigVariables();
        }

        void OnServerInitialized()
        {
            FindMonuments();
        }

        void Loaded()
        {
            spawnLists.Add("AridSpawns", new List<Vector3>());
            spawnLists.Add("TemperateSpawns", new List<Vector3>());
            spawnLists.Add("TundraSpawns", new List<Vector3>());
            spawnLists.Add("ArcticSpawns", new List<Vector3>()); 

            lang.RegisterMessages(messages, this);
            permission.RegisterPermission(permAllowed, this);

            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("BotSpawn");

            ///////////////////////////////////////////////////////////////////////////MIGRATION INFO TO REMOVE in 1.6.7
            storedDataOld = Interface.Oxide.DataFileSystem.ReadObject<StoredDataOld>("BotSpawn");
            var oldDeser = JsonConvert.SerializeObject(storedDataOld);
            if (oldDeser.ToString().Length != 28 && oldDeser.ToString().Length != 26)
            {
                oldDeser = oldDeser.Replace(("\"CustomProfiles\":"), ("\"DataProfiles\":"));
                int lastPos = oldDeser.LastIndexOf('}');
                oldDeser = oldDeser.Insert(lastPos, ",\"MigrationDataDoNotEdit\":{}");
                var migratedData = JsonConvert.DeserializeObject<StoredData>(oldDeser);
                Interface.Oxide.DataFileSystem.WriteObject("BotSpawn", migratedData); 
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("BotSpawn");
                foreach (var profile in storedData.DataProfiles)
                {
                    storedData.MigrationDataDoNotEdit.Add(profile.Key, new ProfileRelocation());
                };
            }
            ///////////////////////////////////////////////////////////////////////////  
            SaveData();
        }
        void Unload()
        {
            var filter = RustExtension.Filter.ToList();
            filter.Remove("cover points");
            filter.Remove("resulted in a conflict");
            RustExtension.Filter = filter.ToArray();
            Wipe();
        }

        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 2)
                    return false;
            return true;
        }

        void UpdateRecords(NPCPlayerApex player)
        {
            if (TempRecord.NPCPlayers.Contains(player))
                TempRecord.NPCPlayers.Remove(player);
        }

        void Wipe()
        {
            foreach (var bot in TempRecord.NPCPlayers)
            {
                if (bot == null)
                    continue;
                else
                    bot.Kill();
            }
            TempRecord.NPCPlayers.Clear();
        }

        // Facepunch.RandomUsernames
        public static string Get(ulong v)                                                                                                                      //credit Fujikura.
        {
            return Facepunch.RandomUsernames.Get((int)(v % 2147483647uL));
        }

        #region BiomeSpawnsSetup
        void GenerateSpawnPoints(List<Vector3> spawnlist, string name, int number, Timer myTimer, int biomeNo)
        {
            int getBiomeAttempts = 0;
            myTimer = timer.Repeat(0.1f, 0, () =>
            {
                int halfish = Convert.ToInt16((ConVar.Server.worldsize / 2) / 1.1f);

                int x = x = random.Next(-halfish, halfish);
                int z = random.Next(-halfish, halfish);
                Vector3 randomSpot = new Vector3(x, 0, z);
                bool finished = true;

                if (spawnlist.Count < number)
                {
                    getBiomeAttempts++;
                    if (getBiomeAttempts > 50 && spawnlist.Count == 0)  
                    {
                        Puts($"Failed to find spawnpoints in {name}."); 
                        myTimer.Destroy();
                        return;
                    }

                    finished = false;
                    x = random.Next(-halfish, halfish);
                    z = random.Next(-halfish, halfish);
                    if (TerrainMeta.BiomeMap.GetBiome(randomSpot, biomeNo) > 0.5f
                        && CalculateGroundPos(new Vector3(randomSpot.x, 200, randomSpot.z), true) != new Vector3())
                        spawnlist.Add(CalculateGroundPos(new Vector3(randomSpot.x, 200, randomSpot.z), true));
                }
                if (finished)
                {
                    int i = 0;
                    timer.Repeat(2, number, () =>
                    {
                        SpawnBots(name, TempRecord.AllProfiles[name], "biome", null, spawnlist[i]);
                        i++;
                    });
                    myTimer.Destroy();
                }
            });
        }

        public static Vector3 CalculateGroundPos(Vector3 sourcePos, bool Biome)                                                                                                      //credit Wulf & Nogrod 
        {
            RaycastHit hitInfo;

            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, 1000f, LayerMask.GetMask("Terrain", "World", "Construction", "Water"), QueryTriggerInteraction.Ignore))
            {
                if (hitInfo.collider.tag == "Main Terrain" && Biome)
                {
                    sourcePos.y = hitInfo.point.y;
                    sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
                    return sourcePos;
                }
                if (!Biome)
                {
                    sourcePos.y = hitInfo.point.y;
                    sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
                    return sourcePos;
                }
            }
            return new Vector3();
        }

        Vector3 TryGetSpawn(Vector3 centerPoint, int radius)
        {
            int attempts = 0;
            var spawnPoint = new Vector3();

            while (attempts < 50 && spawnPoint == new Vector3())
            {
                attempts++;
                RaycastHit hitInfo;

                int X = random.Next((-radius), (radius));
                int Z = random.Next((-radius), (radius));
                if (CalculateGroundPos(new Vector3((centerPoint.x + X), 200, (centerPoint.z + Z)), false) != new Vector3())
                {
                    spawnPoint = CalculateGroundPos(new Vector3(centerPoint.x + X, 200, centerPoint.z + Z), false);
                }
            }
            return spawnPoint;
        }
        #endregion


        #region BotSetup
        void AttackPlayer(Vector3 location, string name, DataProfile profile, string group)
        {
            timer.Repeat(1f, profile.Bots, () => SpawnBots(name, profile, "Attack", group, location));
        }

        void SpawnBots(string name, DataProfile zone, string type, string group, Vector3 location)
        {
            var pos = new Vector3(zone.LocationX, zone.LocationY, zone.LocationZ);
            var finalPoint = new Vector3();
            if (location != new Vector3())
                pos = location;

            var randomTerrainPoint = TryGetSpawn(pos, zone.Radius);
            if (randomTerrainPoint == new Vector3())
            {
                Puts($"Failed to find a suitable spawnpoint : Moving on to next. {name}");
                return;
            }
            else
            {
                finalPoint = randomTerrainPoint;
            }

            if (zone.Chute)
            {
                if (type == "AirDrop")
                    finalPoint = (pos - new Vector3(0, -40, 0));
                else
                    finalPoint = new Vector3(randomTerrainPoint.x, 200, (randomTerrainPoint.z));
            }

            NPCPlayer entity = (NPCPlayer)InstantiateSci(finalPoint, Quaternion.Euler(0, 0, 0), zone.Murderer);
            var botapex = entity.GetComponent<NPCPlayerApex>();

            TempRecord.NPCPlayers.Add(botapex);

            botapex.Spawn();
            botapex.SendNetworkUpdateImmediate();

            no_of_AI++;

            var bData = botapex.gameObject.AddComponent<botData>();
            if (group != null)
                bData.group = group;
            else
                bData.group = null;

            bData.spawnPoint = CalculateGroundPos(randomTerrainPoint, false);
            bData.accuracy = zone.Bot_Accuracy;
            bData.damage = zone.Bot_Damage;
            bData.health = zone.BotHealth;
            bData.monumentName = name;
            bData.respawn = true;
            bData.roamRange = zone.Roam_Range;
            bData.dropweapon = zone.Weapon_Drop;
            bData.keepAttire = zone.Keep_Default_Loadout;
            bData.peaceKeeper = zone.Peace_Keeper;
            bData.chute = zone.Chute;
            bData.peaceKeeper_CoolDown = zone.Peace_Keeper_Cool_Down;
            if (type == "biome")
                bData.biome = true;
            if (zone.Long_Attack_Distance < 55) zone.Long_Attack_Distance = 55;
            bData.LongRangeAttack = zone.Long_Attack_Distance;

            if (zone.Chute)
                addChute(botapex, finalPoint);

            int kitRnd;
            kitRnd = random.Next(zone.Kit.Count);

            if (zone.BotNames.Count == zone.Kit.Count && zone.Kit.Count != 0)
                setName(zone, botapex, kitRnd);
            else
                setName(zone, botapex, random.Next(zone.BotNames.Count));

            giveKit(botapex, zone, kitRnd);

            sortWeapons(botapex);

            int suicInt = random.Next((zone.Suicide_Timer), (zone.Suicide_Timer + 10));                                        //slightly randomise suicide de-spawn time
            if (type == "AirDrop" || type == "Attack")
            {
                bData.respawn = false;
                runSuicide(botapex, suicInt);
            }

            if (zone.Disable_Radio)
                botapex.RadioEffect = new GameObjectRef();

            botapex.Stats.VisionRange = zone.Long_Attack_Distance + 20f; // to allow out of range attack over ride  

            if (!zone.Murderer)
            {
                timer.Once(4, () =>
                {
                    if (botapex != null)
                    {
                        botapex.Stats.IsMobile = true;
                        botapex.SetFact(NPCPlayerApex.Facts.IsRoamReady, 1, true, true);
                        botapex.SetFact(NPCPlayerApex.Facts.IsMoving, 1, true, true);
                    }
                });
            }
        }

        BaseEntity InstantiateSci(Vector3 position, Quaternion rotation, bool murd)                                                                            //Spawn population spam fix - credit Fujikura
        {
            string prefabname = "assets/prefabs/npc/scientist/scientist.prefab";
            if (murd)
                prefabname = "assets/prefabs/npc/murderer/murderer.prefab";

            var prefab = GameManager.server.FindPrefab(prefabname);
            GameObject gameObject = Instantiate.GameObject(prefab, position, rotation);
            gameObject.name = prefabname;
            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);
            if (gameObject.GetComponent<Spawnable>())
                UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());
            if (!gameObject.activeSelf)
                gameObject.SetActive(true);
            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }

        void addChute(NPCPlayerApex botapex, Vector3 newPos)
        {
            float wind = random.Next(0, 50);
            float fall = random.Next(40, 80);
            var rb = botapex.gameObject.GetComponent<Rigidbody>();
            rb.isKinematic = false;
            rb.useGravity = false;
            rb.drag = 0f;
            botapex.gameObject.layer = 3;

            rb.velocity = new Vector3((botapex.transform.forward.x * (wind / 20f)), 0, (botapex.transform.forward * (wind / 20f)).z) + new Vector3(0, -(fall / 10f), 0);

            var col = botapex.gameObject.AddComponent<BoxCollider>();
            col.size = new Vector3(1, 0.5f, 1);  //feet above ground

            var Chute = GameManager.server.CreateEntity("assets/prefabs/misc/parachute/parachute.prefab", newPos, Quaternion.Euler(0, 0, 0));
            Chute.gameObject.Identity();
            Chute.SetParent(botapex, "parachute");
            Chute.Spawn();
        }

        void setName(DataProfile zone, NPCPlayerApex botapex, int number)
        {
            if (zone.BotNames.Count == 0 || zone.BotNames.Count <= number)
            {
                botapex.displayName = Get(botapex.userID);
                botapex.displayName = char.ToUpper(botapex.displayName[0]) + botapex.displayName.Substring(1);
            }
            else if (zone.BotNames[number] == "")
            {
                botapex.displayName = Get(botapex.userID);
                botapex.displayName = char.ToUpper(botapex.displayName[0]) + botapex.displayName.Substring(1);
            }
            else
                botapex.displayName = zone.BotNames[number];

            if (zone.BotNamePrefix != "")
                botapex.displayName = zone.BotNamePrefix + " " + botapex.displayName;
        } 

        void giveKit(NPCPlayerApex botapex, DataProfile zone, int kitRnd)
        {
            var bData = botapex.GetComponent<botData>();

            if (zone.Kit.Count != 0)
            {
                if (zone.Kit[kitRnd] != null)  
                {
                    object checkKit = (Kits.CallHook("GetKitInfo", zone.Kit[kitRnd], true));
                    if (checkKit == null) 
                    {
                        if (zone.Murderer)
                            PrintWarning($"Kit {zone.Kit[kitRnd]} does not exist - Spawning default Murderer.");
                        else
                            PrintWarning($"Kit {zone.Kit[kitRnd]} does not exist - Spawning default Scientist.");
                    }
                    else
                    {
                        bool weaponInBelt = false;
                        if (checkKit != null && checkKit is JObject)
                        {
                            JObject kitContents = checkKit as JObject;

                            JArray items = kitContents["items"] as JArray;
                            foreach (var weap in items)
                            {
                                JObject item = weap as JObject;
                                if (item["container"].ToString() == "belt")
                                    weaponInBelt = true;                                                                                                    //doesn't actually check for weapons - just any item.
                            }
                        }
                        if (!weaponInBelt)
                        {
                            if (zone.Murderer)
                                PrintWarning($"Kit {zone.Kit[kitRnd]} has no items in belt - Spawning default Murderer.");
                            else
                                PrintWarning($"Kit {zone.Kit[kitRnd]} does not exist - Spawning default Scientist.");
                        }
                        else
                        {
                            if (bData.keepAttire == false)
                                botapex.inventory.Strip();
                            Kits.Call($"GiveKit", botapex, zone.Kit[kitRnd], true);
                            if (!(kitList.ContainsKey(botapex.userID)))
                            {
                                kitList.Add(botapex.userID, new kitData
                                {
                                    Kit = zone.Kit[kitRnd],
                                    Wipe_Belt = zone.Wipe_Belt,
                                    Wipe_Clothing = zone.Wipe_Clothing,
                                    Allow_Rust_Loot = zone.Allow_Rust_Loot,
                                });
                            }
                        }
                    }
                }
            }
            else
            {
                if (!(kitList.ContainsKey(botapex.userID)))
                {
                    kitList.Add(botapex.userID, new kitData
                    {
                        Kit = "",
                        Wipe_Belt = zone.Wipe_Belt,
                        Wipe_Clothing = zone.Wipe_Clothing,
                        Allow_Rust_Loot = zone.Allow_Rust_Loot,
                    });
                }
            }
        }

        void sortWeapons(NPCPlayerApex botapex)
        {
            var bData = botapex.GetComponent<botData>();
            foreach (Item item in botapex.inventory.containerBelt.itemList)                                                                                 //store organised weapons lists
            {
                var held = item.GetHeldEntity();
                if (held as HeldEntity != null)
                {
                    if (held.name.Contains("bow") || held.name.Contains("launcher"))
                        continue;
                    if (held as BaseMelee != null || held as TorchWeapon != null)
                        bData.MeleeWeapons.Add(item);
                    else
                    {
                        if (held as BaseProjectile != null)
                        {
                            bData.AllProjectiles.Add(item);
                            if (held.name.Contains("m92") || held.name.Contains("pistol") || held.name.Contains("python") || held.name.Contains("waterpipe"))
                                bData.CloseRangeWeapons.Add(item);
                            else if (held.name.Contains("bolt"))
                                bData.LongRangeWeapons.Add(item);
                            else
                                bData.MediumRangeWeapons.Add(item);
                        }
                    }
                }
            }
        }

        void runSuicide(NPCPlayerApex botapex, int suicInt)
        {
            if (TempRecord.NPCPlayers.Contains(botapex))
            {
                timer.Once(suicInt, () =>
                {
                    if (botapex != null)
                    {
                        if (botapex.AttackTarget != null && Vector3.Distance(botapex.transform.position, botapex.AttackTarget.transform.position) < 10 && botapex.GetNavAgent.isOnNavMesh)
                        {
                            if (botapex.AttackTarget != null)
                            {
                                var position = botapex.AttackTarget.transform.position;
                                botapex.svActiveItemID = 0;
                                botapex.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                                botapex.inventory.UpdatedVisibleHolsteredItems();
                                timer.Repeat(0.05f, 100, () =>
                                {
                                    if (botapex == null) return;
                                    botapex.SetDestination(position);
                                });
                            }
                        }
                        timer.Once(4, () =>
                        {
                            if (botapex == null) return;
                            Effect.server.Run("assets/prefabs/weapons/rocketlauncher/effects/rocket_explosion.prefab", botapex.transform.position);
                            HitInfo nullHit = new HitInfo();
                            nullHit.damageTypes.Add(Rust.DamageType.Explosion, 10000);
                            botapex.IsInvinsible = false;
                            botapex.Die(nullHit);
                        }
                        );
                    }
                });
            }
        }
        #endregion

        static BasePlayer FindPlayerByName(string name)
        {
            BasePlayer result = null;
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                if (current.displayName.Equals(name, StringComparison.OrdinalIgnoreCase))
                {
                    BasePlayer result2 = current;
                    return result2;
                }
                if (current.UserIDString.Contains(name, CompareOptions.OrdinalIgnoreCase))
                {
                    BasePlayer result2 = current;
                    return result2;
                }
                if (current.displayName.Contains(name, CompareOptions.OrdinalIgnoreCase))
                {
                    result = current;
                }
            }
            return result;
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            NPCPlayerApex npc = entity.GetComponent<NPCPlayerApex>();
            if (npc != null && npc is NPCMurderer) 
                NPCSensesLoadBalancer.NpcSensesLoadBalancer.Remove(npc);
        }

        #region Hooks
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var botMelee = info.Initiator as BaseMelee;
            bool melee = false;
            if (botMelee != null)
            {
                melee = true;
                info.Initiator = botMelee.GetOwnerPlayer();
            }
            NPCPlayerApex bot = null;

            if (entity is NPCPlayerApex)
            {
                bot = entity as NPCPlayerApex;

                if (!TempRecord.NPCPlayers.Contains(bot))
                    return null;
                var bData = bot.GetComponent<botData>();
                if (info.Initiator?.ToString() == null && configData.Global.Pve_Safe)
                    info.damageTypes.ScaleAll(0);
                if (info.Initiator is BasePlayer && !(info.Initiator is NPCPlayer))
                {
                    var canNetwork = Vanish?.Call("IsInvisible", info.Initiator);                                                                       //bots wont retaliate to vanished players
                    if ((canNetwork is bool))
                        if ((bool)canNetwork)
                            info.Initiator = null;

                    if (bData.peaceKeeper)                                                                                                               //prevent melee farming with peacekeeper on
                    {
                        var heldMelee = info.Weapon as BaseMelee;
                        var heldTorchWeapon = info.Weapon as TorchWeapon;
                        if (heldMelee != null || heldTorchWeapon != null)
                            info.damageTypes.ScaleAll(0);
                    }
                }
                float multiplier = 100f / bData.health;
                info.damageTypes.ScaleAll(multiplier);
            }

            if (info?.Initiator is NPCPlayer && entity is BasePlayer)                                                                                       //add in bot accuracy
            {
                var attacker = info.Initiator as NPCPlayerApex;

                if (TempRecord.NPCPlayers.Contains(attacker))
                {
                    var bData = attacker.GetComponent<botData>();
                    int rand = random.Next(1, 100);
                    float distance = (Vector3.Distance(info.Initiator.transform.position, entity.transform.position));

                    var newAccuracy = (bData.accuracy * 10f);
                    var newDamage = (bData.damage);
                    if (distance > 100f)
                    {
                        newAccuracy = ((bData.accuracy * 10f) / (distance / 100f));
                        newDamage = bData.damage / (distance / 100f);
                    }
                    if (!melee && newAccuracy < rand)                                                                                                          //scale bot attack damage
                    {
                        return true;
                    }
                    else
                    {
                        info.damageTypes.ScaleAll(newDamage);
                        return null;
                    }
                }
            }
            return null;
        }

        void OnPlayerDie(BasePlayer player)
        {
            string respawnLocationName = "";
            NPCPlayerApex Scientist = null;
            if (player is NPCPlayerApex)
            {
                Scientist = player as NPCPlayerApex;
                if (!TempRecord.NPCPlayers.Contains(Scientist))
                    return;

                if (TempRecord.NPCPlayers.Contains(Scientist))
                {
                    var bData = Scientist.GetComponent<botData>();
                    Item activeItem = player.GetActiveItem();
                    if (bData.dropweapon == true && activeItem != null)
                    {
                        using (TimeWarning timeWarning = TimeWarning.New("PlayerBelt.DropActive", 0.1f))
                        {
                            activeItem.Drop(player.eyes.position, new Vector3(), new Quaternion());
                            player.svActiveItemID = 0;
                            player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            kitRemoveList.Add(player.userID, activeItem.info.name);
                        }
                    }
                    no_of_AI--;
                    respawnLocationName = bData.monumentName;
                    DeadNPCPlayerIds.Add(Scientist.userID);
                    if (TempRecord.AllProfiles[respawnLocationName].Disable_Radio == true)
                        Scientist.DeathEffect = new GameObjectRef();                                                                                               //kill radio effects

                    if (bData.respawn == false)
                    {
                        UnityEngine.Object.Destroy(Scientist.GetComponent<botData>());
                        UpdateRecords(Scientist);
                        return;
                    }
                    if (bData.biome)
                    {
                        List<Vector3> spawnList = new List<Vector3>();

                        if (spawnLists.ContainsKey(bData.monumentName))
                        {
                            spawnList = spawnLists[bData.monumentName];
                            int spawnPos = random.Next(spawnList.Count);
                            SpawnBots(bData.monumentName, TempRecord.AllProfiles[bData.monumentName], "biome", null, spawnList[spawnPos]);
                            return;
                        }
                        else return;
                    }
                    foreach (var profile in TempRecord.AllProfiles)
                    {
                        timer.Once(profile.Value.Respawn_Timer, () => {
                            if (profile.Key == respawnLocationName)
                            {
                                SpawnBots(profile.Key, profile.Value, null, null, new Vector3());
                            }
                        });
                        UnityEngine.Object.Destroy(Scientist.GetComponent<botData>());
                        UpdateRecords(Scientist);
                    }
                }
            }
        }

        void OnEntitySpawned(BaseEntity entity) // handles smoke signals, backpacks, corpses(applying kit)
        {
            NPCPlayerApex npc = entity.GetComponent<NPCPlayerApex>();
            if (npc != null && npc is NPCMurderer)
                npc.NewAI = false;
            
            var KitDetails = new kitData();
            if (entity != null)
            {
                if (entity is NPCPlayerCorpse)
                {
                    var corpse = entity as NPCPlayerCorpse;
                    corpse.ResetRemovalTime(configData.Global.Corpse_Duration);

                    if (kitList.ContainsKey(corpse.playerSteamID))
                    {
                        KitDetails = kitList[corpse.playerSteamID];
                        NextTick(() =>
                        {
                            if (corpse == null)
                                return;
                            if (!KitDetails.Allow_Rust_Loot)
                            {
                                corpse.containers[0].Clear();
                                corpse.containers[1].Clear();
                                corpse.containers[2].Clear();
                            }
                            if (KitDetails.Kit != "")
                            {
                                string[] checkKit = (Kits.CallHook("GetKitContents", KitDetails.Kit)) as string[];

                                var tempbody = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", (corpse.transform.position - new Vector3(0, -100, 0)), corpse.transform.rotation).ToPlayer();
                                tempbody.Spawn();

                                Kits?.Call($"GiveKit", tempbody, KitDetails.Kit, true);

                                var source = new ItemContainer[] { tempbody.inventory.containerMain, tempbody.inventory.containerWear, tempbody.inventory.containerBelt };

                                for (int i = 0; i < (int)source.Length; i++)
                                {
                                    Item[] array = source[i].itemList.ToArray();
                                    for (int j = 0; j < (int)array.Length; j++)
                                    {
                                        Item item = array[j];
                                        if (!item.MoveToContainer(corpse.containers[i], -1, true))
                                        {
                                            item.Remove(0f);
                                        }
                                    }
                                }
                                tempbody.Kill();
                            }
                            if (kitList[corpse.playerSteamID].Wipe_Belt)
                                corpse.containers[2].Clear();
                            else
                            if (kitRemoveList.ContainsKey(corpse.playerSteamID))
                            {
                                foreach (var thing in corpse.containers[2].itemList)                                                                            //If weapon drop is enabled, this removes the weapon from the corpse's inventory.
                                {
                                    if (kitRemoveList[corpse.playerSteamID] == thing.info.name)
                                    {
                                        thing.Remove();
                                        kitRemoveList.Remove(corpse.playerSteamID);
                                        break;
                                    }
                                }
                            }

                            if (kitList[corpse.playerSteamID].Wipe_Clothing)
                            {
                                corpse.containers[1].Clear();
                            }

                            kitList.Remove(corpse.playerSteamID);
                        });
                    }
                }

                if (entity is DroppedItemContainer)
                {
                    NextTick(() =>
                    {
                        if (entity == null || entity.IsDestroyed) return;
                        var container = entity as DroppedItemContainer;

                        ulong ownerID = container.playerSteamID;
                        if (ownerID == 0) return;
                        if (configData.Global.Remove_BackPacks)
                        {
                            if (DeadNPCPlayerIds.Contains(ownerID))
                            {
                                entity.Kill();
                                DeadNPCPlayerIds.Remove(ownerID);
                                return;
                            }
                        }

                    });
                }

                if (entity.name.Contains("grenade.smoke.deployed"))
                    timer.Once(2.3f, () =>
                    {
                        if (entity != null)
                            smokeGrenades.Add(new Vector3(entity.transform.position.x, 0, entity.transform.position.z));
                    });

                if (!(entity.name.Contains("supply_drop")))
                    return;

                Vector3 dropLocation = new Vector3(entity.transform.position.x, 0, entity.transform.position.z);

                if (!(configData.Global.Supply_Enabled))
                {
                    foreach (var location in smokeGrenades)
                    {
                        if (Vector3.Distance(location, dropLocation) < 35f)
                        {
                            smokeGrenades.Remove(location);
                            return;
                        }
                    }
                }
                if (TempRecord.AllProfiles.ContainsKey("AirDrop"))
                {
                    var profile = TempRecord.AllProfiles["AirDrop"];
                    if (profile.AutoSpawn == true)
                    {
                        timer.Repeat(0.1f, profile.Bots, () =>
                        {
                            profile.LocationX = entity.transform.position.x;
                            profile.LocationY = entity.transform.position.y;
                            profile.LocationZ = entity.transform.position.z;
                            SpawnBots("AirDrop", profile, "AirDrop", null, new Vector3());
                        }
                        );
                    }
                }
            }
        }
        #endregion

        #region WeaponSwitching
        void SelectWeapon(NPCPlayerApex npcPlayer, BasePlayer victim, bool hasAttacker)
        {
            if (npcPlayer == null)
                return;

            if (npcPlayer.svActiveItemID == 0)
                return;

            var active = npcPlayer.GetActiveItem();
            HeldEntity heldEntity1 = null;

            if (active != null)
                heldEntity1 = active.GetHeldEntity() as HeldEntity;

            var bData = npcPlayer.GetComponent<botData>();

            if (hasAttacker == false)
            {
                List<int> weapons = new List<int>();                                                                                                    //check all their weapons
                foreach (Item item in npcPlayer.inventory.containerBelt.itemList)
                {
                    var held = item.GetHeldEntity();
                    if (held is BaseProjectile || held is BaseMelee || held is TorchWeapon)
                        weapons.Add(Convert.ToInt16(item.position));
                }

                if (weapons.Count == 0)
                {
                    PrintWarning(lang.GetMessage("noWeapon", this), bData.monumentName);
                    return;
                }
                int index = random.Next(weapons.Count);
                var currentTime = TOD_Sky.Instance.Cycle.Hour;

                if (currentTime > 20 || currentTime < 8)
                {
                    foreach (Item item in npcPlayer.inventory.containerBelt.itemList)
                    {
                        HeldEntity held = item.GetHeldEntity() as HeldEntity;

                        if (item.ToString().Contains("flashlight"))
                        {
                            if (heldEntity1 != null)
                                heldEntity1.SetHeld(false);
                            var UID = item.uid;

                            ChangeWeapon(npcPlayer, held, UID);
                            return;
                        }
                    }
                }
                else
                {
                    foreach (Item item in npcPlayer.inventory.containerBelt.itemList)                                                                   //pick one at random to start with
                    {
                        HeldEntity held = item.GetHeldEntity() as HeldEntity;

                        if (item.position == weapons[index])
                        {
                            if (heldEntity1 != null)
                                heldEntity1.SetHeld(false);
                            var UID = npcPlayer.inventory.containerBelt.GetSlot(weapons[index]).uid;

                            ChangeWeapon(npcPlayer, held, UID);
                            return;
                        }
                    }
                }
            }

            if (hasAttacker == true)
            {
                bData.canChangeWeapon++;

                if (bData.canChangeWeapon > 3)
                {
                    bData.canChangeWeapon = 0;
                    if (npcPlayer == null)
                        return;

                    if (heldEntity1 == null)
                        bData.currentWeaponRange = 0;

                    float distance = Vector3.Distance(npcPlayer.transform.position, victim.transform.position);
                    int noOfAvailableWeapons = 0;
                    int selectedWeapon;
                    Item chosenWeapon = null;
                    HeldEntity held = null;
                    int newCurrentRange = 0;
                    var currentTime = TOD_Sky.Instance.Cycle.Hour;
                    bool night = false;

                    if (currentTime > 20 || currentTime < 8)
                        night = true;

                    if (npcPlayer.AttackTarget == null && night)
                    {
                        foreach (var weap in bData.MeleeWeapons)
                        {
                            if (weap.ToString().Contains("flashlight"))
                            {
                                chosenWeapon = weap;
                                newCurrentRange = 1;
                            }
                        }
                    }
                    else
                    {
                        if (distance < 2f && bData.MeleeWeapons.Count != 0)
                        {
                            bData.enemyDistance = 1;
                            foreach (var weap in bData.MeleeWeapons)
                            {
                                noOfAvailableWeapons++;
                            }
                            if (noOfAvailableWeapons > 0)
                            {
                                selectedWeapon = random.Next(bData.MeleeWeapons.Count);
                                chosenWeapon = bData.MeleeWeapons[selectedWeapon];
                                newCurrentRange = 1;
                            }
                        }
                        else if (distance > 1f && distance < 20f && bData.CloseRangeWeapons != null)
                        {
                            bData.enemyDistance = 2;
                            foreach (var weap in bData.CloseRangeWeapons)
                            {
                                noOfAvailableWeapons++;
                            }
                            if (noOfAvailableWeapons > 0)
                            {
                                selectedWeapon = random.Next(bData.CloseRangeWeapons.Count);
                                chosenWeapon = bData.CloseRangeWeapons[selectedWeapon];
                                newCurrentRange = 2;
                            }
                            else
                            {
                                foreach (var weap in bData.MediumRangeWeapons)                                                                          //if no close weapon, prioritise medium
                                {
                                    noOfAvailableWeapons++;
                                }
                                if (noOfAvailableWeapons > 0)
                                {
                                    selectedWeapon = random.Next(bData.MediumRangeWeapons.Count);
                                    chosenWeapon = bData.MediumRangeWeapons[selectedWeapon];
                                    newCurrentRange = 3;
                                }
                            }
                        }
                        else if (distance > 19f && distance < 40f && bData.MediumRangeWeapons != null)
                        {
                            bData.enemyDistance = 3;
                            foreach (var weap in bData.MediumRangeWeapons)
                            {
                                noOfAvailableWeapons++;
                            }
                            if (noOfAvailableWeapons > 0)
                            {
                                selectedWeapon = random.Next(bData.MediumRangeWeapons.Count);
                                chosenWeapon = bData.MediumRangeWeapons[selectedWeapon];
                                newCurrentRange = 3;
                            }
                        }
                        else if (distance > 39 && bData.LongRangeWeapons != null)
                        {
                            bData.enemyDistance = 4;
                            foreach (var weap in bData.LongRangeWeapons)
                            {
                                noOfAvailableWeapons++;
                            }
                            if (noOfAvailableWeapons > 0)
                            {
                                selectedWeapon = random.Next(bData.LongRangeWeapons.Count);
                                chosenWeapon = bData.LongRangeWeapons[selectedWeapon];
                                newCurrentRange = 4;
                            }
                            else
                            {
                                foreach (var weap in bData.MediumRangeWeapons)                                                                          //if no long weapon, prioritise medium
                                {
                                    noOfAvailableWeapons++;
                                }
                                if (noOfAvailableWeapons > 0)
                                {
                                    selectedWeapon = random.Next(bData.MediumRangeWeapons.Count);
                                    chosenWeapon = bData.MediumRangeWeapons[selectedWeapon];
                                    newCurrentRange = 3;
                                }
                            }
                        }
                        if (chosenWeapon == null)                                                                                                       //if no weapon suited to range, pick any random bullet weapon
                        {                                                                                                                               //prevents sticking with melee @>2m when no pistol is available
                            bData.enemyDistance = 5;
                            if (heldEntity1 != null && bData.AllProjectiles.Contains(active))                                                           //prevents choosing a random weapon if the existing one is fine
                                return;
                            foreach (var weap in bData.AllProjectiles)
                            {
                                noOfAvailableWeapons++;
                            }
                            if (noOfAvailableWeapons > 0)
                            {
                                selectedWeapon = random.Next(bData.AllProjectiles.Count);
                                chosenWeapon = bData.AllProjectiles[selectedWeapon];
                                newCurrentRange = 5;
                            }
                        }
                    }
                    if (chosenWeapon == null) return;
                    if (newCurrentRange == bData.currentWeaponRange)
                    {
                        return;
                    }
                    else
                    {
                        bData.currentWeaponRange = newCurrentRange;
                        held = chosenWeapon.GetHeldEntity() as HeldEntity;

                        if (heldEntity1 != null && heldEntity1.name == held.name)
                            return;

                        if (heldEntity1 != null && heldEntity1.name != held.name)
                            heldEntity1.SetHeld(false);

                        var UID = chosenWeapon.uid;
                        ChangeWeapon(npcPlayer, held, UID);
                    }
                }
            }
            else
            {
                timer.Once(1, () => SelectWeapon(npcPlayer, victim, false));
            }
        }

        void ChangeWeapon(NPCPlayer npcPlayer, HeldEntity held, uint UID)
        {
            if (npcPlayer == null) return;
            npcPlayer.svActiveItemID = 0;
            npcPlayer.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            npcPlayer.inventory.UpdatedVisibleHolsteredItems();

            npcPlayer.svActiveItemID = UID;
            npcPlayer.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            held.SetHeld(true);
            npcPlayer.svActiveItemID = UID;
            npcPlayer.inventory.UpdatedVisibleHolsteredItems();
        }
        #endregion

        #region behaviour hooks
        object OnNpcPlayerResume(NPCPlayerApex player)
        {
            if (TempRecord.NPCPlayers.Contains(player))
            {
                var bData = player.GetComponent<botData>();
                if (bData.inAir) return false;
            }
            return null;
        }

        void OnNpcDestinationSet(NPCPlayerApex player)
        {
            if (TempRecord.NPCPlayers.Contains(player))
            {
                var bData = player.GetComponent<botData>();
                if (bData.goingHome)
                    return;
            }
        }
        #endregion

        #region targetingHooks
        object OnNpcPlayerTarget(NPCPlayerApex npcPlayer, BaseEntity entity)
        {
            var path = TempRecord.NPCPlayers;
            var conf = configData.Global;

            if (npcPlayer == null || entity == null)
                return null;
             
            if (entity is NPCPlayer)
            {
                NPCPlayerApex botVictim = entity as NPCPlayerApex;

                if (path.Contains(botVictim) && !(path.Contains(npcPlayer)) && !(conf.NPCs_Attack_BotSpawn))    //stop oustideNPCs attacking BotSpawn bots
                    return true;

                if (!TempRecord.NPCPlayers.Contains(npcPlayer))
                    return null;

                if (!path.Contains(botVictim) && !(conf.BotSpawn_Attacks_NPCs))                                  //stop BotSpawn bots attacking outsideNPCs                                                                                  
                    return true;

                if (path.Contains(botVictim) && !(conf.BotSpawn_Attacks_BotSpawn))                              //stop BotSpawn murd+sci fighting each other 
                    return true;
            }

            if (!TempRecord.NPCPlayers.Contains(npcPlayer))
                return null;

            BasePlayer victim = entity as BasePlayer;
            if (victim != null)
            {
                var active = npcPlayer.GetActiveItem();
                var bData = npcPlayer.GetComponent<botData>();

                npcPlayer.AiContext.LastAttacker = entity;

                var currentTime = TOD_Sky.Instance.Cycle.Hour;

                HeldEntity heldEntity1 = null;
                if (active != null)
                    heldEntity1 = active.GetHeldEntity() as HeldEntity;

                if (heldEntity1 == null)                                                                                                                            //freshspawn catch, pre weapon draw.
                    return null;
                if (heldEntity1 != null)
                {
                    if (currentTime > 20 || currentTime < 8)
                        heldEntity1.SetLightsOn(true);
                    else
                        heldEntity1.SetLightsOn(false);
                }

                var heldWeapon = victim.GetHeldEntity() as BaseProjectile;
                var heldFlame = victim.GetHeldEntity() as FlameThrower;

                if (bData.peaceKeeper && !(victim is NPCPlayer))
                {
                    if (heldWeapon != null || heldFlame != null)
                    {
                        aggroPlayers.Add(victim.userID);
                        timer.Once(bData.peaceKeeper_CoolDown, () => {
                            if (aggroPlayers.Contains(victim.userID))
                                aggroPlayers.Remove(victim.userID);
                        });
                    }
                    if (!(aggroPlayers.Contains(victim.userID)))
                    {
                        if (victim.svActiveItemID == 0u)
                            return true;
                        if (heldWeapon == null && heldFlame == null)
                            return true;
                    }

                }
                SelectWeapon(npcPlayer, victim, true);

                if (Vector3.Distance(npcPlayer.transform.position, entity.transform.position) > 55
                    && Vector3.Distance(npcPlayer.transform.position, entity.transform.position) < bData.LongRangeAttack  
                    && npcPlayer.GetFact(NPCPlayerApex.Facts.HasLineOfSightStanding) == 1
                    && npcPlayer.GetHeldEntity() as BaseProjectile != null)
                {
                    npcPlayer.AttackTarget = victim;
                    npcPlayer.SetAimDirection((npcPlayer.AttackTarget.transform.position - npcPlayer.GetPosition()).normalized);
                    npcPlayer.ShotTest();
                }

                if (!victim.userID.IsSteamId() && !(victim is NPCPlayer) && conf.Ignore_HumanNPC)                                                                           //stops bots targeting humannpc
                    return true;
            }
            if (entity.name.Contains("agents/") && conf.Ignore_Animals)                                                                           //stops bots targeting animals
                return true;

            return null;
        }

        private object RaycastAll<T>(Ray ray, float distance) //credit S0N_0F_BISCUIT
        {
            var hits = Physics.RaycastAll(ray, Layers.Solid);
            GamePhysics.Sort(hits);
            object target = false;
            foreach (var hit in hits)
            {
                var ent = hit.GetEntity();
                if (ent is T)
                {
                    target = ent;
                    break;
                }
            }
            return target;
        }

        object CanBradleyApcTarget(BradleyAPC bradley, BaseEntity target)                                                                                       //stops bradley targeting bots
        {
            if (target is NPCPlayer && configData.Global.APC_Safe)
                return false;
            return null;
        }

        object OnNpcTarget(BaseNpc npc, BaseEntity entity)                                                                                                      //stops animals targeting bots
        {
            if (entity is NPCPlayer && configData.Global.Animal_Safe)
                return true;
            return null;
        }

        object CanBeTargeted(BaseCombatEntity player, MonoBehaviour turret)                                                                                     //stops autoturrets targetting bots
        {
            if (player is NPCPlayer && configData.Global.Turret_Safe)
                return false;
            return null;
        }
        #endregion

        #region SetUpLocations
        private void FindMonuments()                                                                                                                            //credit K1lly0u 
        {
            TempRecord.AllProfiles.Clear();
            var allobjects = UnityEngine.Object.FindObjectsOfType<GameObject>();

            int warehouse = 0;
            int lighthouse = 0;
            int gasstation = 0;
            int spermket = 0;
            int compound = 0; 

            foreach (var gobject in allobjects)
            {
                if (gobject.name.Contains("autospawn/monument") && gobject.transform.position != new Vector3(0, 0, 0))
                {
                    var pos = gobject.transform.position;
                    var rot = gobject.transform.eulerAngles.y;

                    if (gobject.name.Contains("airfield_1"))
                    {
                        AddProfile("Airfield", configData.Monuments.Airfield, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("compound") && compound == 0)
                    {
                        AddProfile("Compound", configData.Monuments.Compound, pos, rot);
                        compound++;
                        continue;
                    }
                    if (gobject.name.Contains("compound") && compound == 1)
                    {
                        AddProfile("Compound1", configData.Monuments.Compound1, pos, rot);
                        compound++;
                        continue;
                    }
                    if (gobject.name.Contains("compound") && compound == 2)
                    {
                        AddProfile("Compound2", configData.Monuments.Compound2, pos, rot);
                        compound++;
                        continue;
                    }
                    if (gobject.name.Contains("sphere_tank"))
                    {
                        AddProfile("Dome", configData.Monuments.Dome, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("gas_station_1") && gasstation == 0)
                    {
                        AddProfile("GasStation", configData.Monuments.GasStation, pos, rot);
                        gasstation++;
                        continue;
                    }
                    if (gobject.name.Contains("gas_station_1") && gasstation == 1)
                    {
                        AddProfile("GasStation1", configData.Monuments.GasStation1, pos, rot);
                        gasstation++;
                        continue;
                    }
                    if (gobject.name.Contains("harbor_1"))
                    {
                        AddProfile("Harbor1", configData.Monuments.Harbor1, pos, rot);
                        continue;
                    }

                    if (gobject.name.Contains("harbor_2"))
                    {
                        AddProfile("Harbor2", configData.Monuments.Harbor2, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("junkyard"))
                    {
                        AddProfile("Junkyard", configData.Monuments.Junkyard, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("launch_site"))
                    {
                        AddProfile("Launchsite", configData.Monuments.Launchsite, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("lighthouse") && lighthouse == 0)
                    {
                        AddProfile("Lighthouse", configData.Monuments.Lighthouse, pos, rot);
                        lighthouse++;
                        continue;
                    }

                    if (gobject.name.Contains("lighthouse") && lighthouse == 1)
                    {
                        AddProfile("Lighthouse1", configData.Monuments.Lighthouse1, pos, rot);
                        lighthouse++;
                        continue;
                    }

                    if (gobject.name.Contains("lighthouse") && lighthouse == 2)
                    {
                        AddProfile("Lighthouse2", configData.Monuments.Lighthouse2, pos, rot);
                        lighthouse++;
                        continue;
                    }

                    if (gobject.name.Contains("military_tunnel_1"))
                    {
                        AddProfile("MilitaryTunnel", configData.Monuments.MilitaryTunnel, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("powerplant_1"))
                    {
                        AddProfile("PowerPlant", configData.Monuments.PowerPlant, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("mining_quarry_c"))
                    {
                        AddProfile("QuarryHQM", configData.Monuments.QuarryHQM, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("mining_quarry_b"))
                    {
                        AddProfile("QuarryStone", configData.Monuments.QuarryStone, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("mining_quarry_a"))
                    {
                        AddProfile("QuarrySulphur", configData.Monuments.QuarrySulphur, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("radtown_small_3"))
                    {
                        AddProfile("Radtown", configData.Monuments.Radtown, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("satellite_dish"))
                    {
                        AddProfile("Satellite", configData.Monuments.Satellite, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("supermarket_1") && spermket == 0)
                    {
                        AddProfile("SuperMarket", configData.Monuments.SuperMarket, pos, rot);
                        spermket++;
                        continue;
                    }

                    if (gobject.name.Contains("supermarket_1") && spermket == 1)
                    {
                        AddProfile("SuperMarket1", configData.Monuments.SuperMarket1, pos, rot);
                        spermket++;
                        continue;
                    }
                    if (gobject.name.Contains("trainyard_1"))
                    {
                        AddProfile("Trainyard", configData.Monuments.Trainyard, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("warehouse") && warehouse == 0)
                    {
                        AddProfile("Warehouse", configData.Monuments.Warehouse, pos, rot);
                        warehouse++;
                        continue;
                    }

                    if (gobject.name.Contains("warehouse") && warehouse == 1)
                    {
                        AddProfile("Warehouse1", configData.Monuments.Warehouse1, pos, rot);
                        warehouse++;
                        continue;
                    }

                    if (gobject.name.Contains("warehouse") && warehouse == 2)
                    {
                        AddProfile("Warehouse2", configData.Monuments.Warehouse2, pos, rot);
                        warehouse++;
                        continue;
                    }
                    if (gobject.name.Contains("water_treatment_plant_1"))
                    {
                        AddProfile("Watertreatment", configData.Monuments.Watertreatment, pos, rot);
                        continue;
                    }
                    if (gobject.name.Contains("compound") && compound > 2)
                        continue;
                    if (gobject.name.Contains("gas_station_1") && gasstation > 1)
                        continue;
                    if (gobject.name.Contains("lighthouse") && lighthouse > 2)
                        continue;
                    if (gobject.name.Contains("supermarket_1") && spermket > 1)
                        continue;
                    if (gobject.name.Contains("warehouse") && warehouse > 2)
                        continue;
                }
            }

            if (configData.Biomes.BiomeArid.AutoSpawn == true)
            {
                AddProfile("BiomeArid", configData.Biomes.BiomeArid, new Vector3(), 0f);
                GenerateSpawnPoints(spawnLists["AridSpawns"], "BiomeArid", configData.Biomes.BiomeArid.Bots, aridTimer, 1);
            }
            if (configData.Biomes.BiomeTemperate.AutoSpawn == true)
            {
                AddProfile("BiomeTemperate", configData.Biomes.BiomeTemperate, new Vector3(), 0f);
                GenerateSpawnPoints(spawnLists["TemperateSpawns"], "BiomeTemperate", configData.Biomes.BiomeTemperate.Bots, temperateTimer, 2);
            }
            if (configData.Biomes.BiomeTundra.AutoSpawn == true)
            {
                AddProfile("BiomeTundra", configData.Biomes.BiomeTundra, new Vector3(), 0f);
                GenerateSpawnPoints(spawnLists["TundraSpawns"], "BiomeTundra", configData.Biomes.BiomeTundra.Bots, tundraTimer, 4);
            }
            if (configData.Biomes.BiomeArctic.AutoSpawn == true)
            {
                AddProfile("BiomeArctic", configData.Biomes.BiomeArctic, new Vector3(), 0f);
                GenerateSpawnPoints(spawnLists["ArcticSpawns"], "BiomeArctic", configData.Biomes.BiomeArctic.Bots, arcticTimer, 8);
            }

            var drop = JsonConvert.SerializeObject(configData.Monuments.AirDrop);
            DataProfile Airdrop = JsonConvert.DeserializeObject<DataProfile>(drop);
            TempRecord.AllProfiles.Add("AirDrop", Airdrop);

            foreach (var profile in storedData.DataProfiles)
            {

                if (!(storedData.MigrationDataDoNotEdit.ContainsKey(profile.Key)))
                    storedData.MigrationDataDoNotEdit.Add(profile.Key, new ProfileRelocation());

                if (profile.Value.Parent_Monument != "")
                {
                    var path = storedData.MigrationDataDoNotEdit[profile.Key];

                    if (TempRecord.AllProfiles.ContainsKey(profile.Value.Parent_Monument) && !isBiome(profile.Value.Parent_Monument))
                    {
                        var configPath = TempRecord.AllProfiles[profile.Value.Parent_Monument];

                        path.ParentMonumentX = configPath.LocationX; //Incase user changed Parent after load
                        path.ParentMonumentY = configPath.LocationY;
                        path.ParentMonumentZ = configPath.LocationZ;

                        if (Mathf.Approximately(path.OldParentMonumentX, 0.0f)) //If it's a new entry, save current monument location info
                        {
                            Puts($"Saved migration data for {profile.Key}");

                            path.OldParentMonumentX = configPath.LocationX;
                            path.OldParentMonumentY = configPath.LocationY;
                            path.OldParentMonumentZ = configPath.LocationZ;
                            path.oldRotation = path.worldRotation;
                        }

                        if (!(Mathf.Approximately(path.ParentMonumentX, path.OldParentMonumentX))) //if old and new aren't equal
                        {
                            bool userChanged = false;
                            foreach (var monument in TempRecord.AllProfiles)
                                if (Mathf.Approximately(monument.Value.LocationX, path.OldParentMonumentX)) //but old matches some other monument, then the user must have switched Parent
                                {
                                    userChanged = true;
                                    break;
                                }

                            if (userChanged)
                            {
                                Puts($"Parent_Monument change detected - Saving {profile.Key} location relative to {profile.Value.Parent_Monument}");
                                path.OldParentMonumentX = path.ParentMonumentX;
                                path.OldParentMonumentY = path.ParentMonumentY;
                                path.OldParentMonumentZ = path.ParentMonumentZ;
                                path.oldRotation = path.worldRotation;
                            }
                            else
                            {
                                Puts($"Map seed change detected - Updating {profile.Key} location relative to new {profile.Value.Parent_Monument}");
                                Vector3 oldloc = new Vector3(profile.Value.LocationX, profile.Value.LocationY, profile.Value.LocationZ);
                                Vector3 oldMonument = new Vector3(path.OldParentMonumentX, path.OldParentMonumentY, path.OldParentMonumentZ);
                                Vector3 newMonument = new Vector3(path.ParentMonumentX, path.ParentMonumentY, path.ParentMonumentZ);
                                //Map Seed Changed  

                                var newTrans = new GameObject().transform;
                                newTrans.transform.position = oldloc;
                                newTrans.transform.RotateAround(oldMonument, Vector3.down, path.oldRotation);                   //spin old loc around old monument until mon-rotation is 0
                                Vector3 oldLocRotated = newTrans.transform.position;

                                Vector3 difference = oldLocRotated - oldMonument;                                               //get relationship betwee old location(rotated) minus monument
                                Vector3 newLocPreRot = newMonument + difference;                                                //add that difference to the new monument location

                                newTrans.transform.position = newLocPreRot;
                                newTrans.transform.RotateAround(newMonument, Vector3.down, -path.worldRotation);
                                Vector3 newLocation = newTrans.transform.position;                                              //rotate that number around the monument by new mon Rotation

                                profile.Value.LocationX = newLocation.x;
                                profile.Value.LocationY = newLocation.y;
                                profile.Value.LocationZ = newLocation.z;

                                path.oldRotation = path.worldRotation;
                                path.OldParentMonumentX = configPath.LocationX;
                                path.OldParentMonumentY = configPath.LocationY;
                                path.OldParentMonumentZ = configPath.LocationZ;
                                path.ParentMonumentX = configPath.LocationX;
                                path.ParentMonumentY = configPath.LocationY;  
                                path.ParentMonumentZ = configPath.LocationZ;
                            }
                        }
                    }
                    else
                    {
                        Puts($"Parent monument {profile.Value.Parent_Monument} does not exist for custom profile {profile.Key}");
                        profile.Value.AutoSpawn = false;
                        SaveData();
                    }


                }
                SaveData();
                TempRecord.AllProfiles.Add(profile.Key, profile.Value);
            }

            foreach (var profile in TempRecord.AllProfiles)
            {
                if (isBiome(profile.Key)) continue;
                if (profile.Value.Kit.Count > 0 && Kits == null)
                {
                    PrintWarning(lang.GetMessage("nokits", this), profile.Key);
                    continue;
                }

                if (profile.Value.AutoSpawn == true && profile.Value.Bots > 0 && !profile.Key.Contains("AirDrop"))
                {
                    timer.Repeat(2, profile.Value.Bots, () =>
                    {
                        if (TempRecord.AllProfiles.Contains(profile))
                            SpawnBots(profile.Key, profile.Value, null, null, new Vector3());
                    });
                }
            }
        }

        void AddProfile(string name, ConfigProfile monument, Vector3 pos, float rotation)                                                                                   //bring config data into live data
        {
            var toAdd = JsonConvert.SerializeObject(monument);
            DataProfile toAddDone = JsonConvert.DeserializeObject<DataProfile>(toAdd);

            TempRecord.AllProfiles.Add(name, toAddDone);
            TempRecord.AllProfiles[name].LocationX = pos.x;
            TempRecord.AllProfiles[name].LocationY = pos.y;
            TempRecord.AllProfiles[name].LocationZ = pos.z;
            foreach (var custom in storedData.DataProfiles)
            {
                if (custom.Value.Parent_Monument == name && storedData.MigrationDataDoNotEdit.ContainsKey(custom.Key))
                {
                    var path = storedData.MigrationDataDoNotEdit[custom.Key];
                    if (Mathf.Approximately(path.oldRotation, 0))
                    {
                        path.oldRotation = rotation;
                    }

                    path.worldRotation = rotation;
                    path.ParentMonumentX = pos.x;
                    path.ParentMonumentY = pos.y;
                    path.ParentMonumentZ = pos.z;
                }
            }
            SaveData();
        }

        private Vector3 RotateVector2D(Vector3 oldDirection, float angle)
        {
            float newX = Mathf.Cos(angle * Mathf.Deg2Rad) * (oldDirection.x) - Mathf.Sin(angle * Mathf.Deg2Rad) * (oldDirection.z);
            float newZ = Mathf.Sin(angle * Mathf.Deg2Rad) * (oldDirection.x) + Mathf.Cos(angle * Mathf.Deg2Rad) * (oldDirection.z);
            return new Vector3(newX, 0f, newZ);
        }

        #endregion

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("BotSpawn", storedData);
        }
        #region Commands
        [ConsoleCommand("bot.respawn")]
        void cmdBotRespawn()
        {
            Unload();
            Init();
            OnServerInitialized();
        }

        [ConsoleCommand("bot.count")]
        void cmdBotCount()
        {
            int total = 0;
            foreach (var pair in TempRecord.NPCPlayers)
            {
                total++;
            }
            if (total == 1)
                PrintWarning(lang.GetMessage("numberOfBot", this), total);
            else
                PrintWarning(lang.GetMessage("numberOfBots", this), total);
        }

        [ChatCommand("botspawn")]
        void botspawn(BasePlayer player, string command, string[] args)
        {
            if (HasPermission(player.UserIDString, permAllowed) || isAuth(player))
                if (args != null && args.Length == 1)
                {
                    if (args[0] == "list")
                    {
                        var outMsg = lang.GetMessage("ListTitle", this);

                        foreach (var profile in storedData.DataProfiles)
                        {
                            outMsg += $"\n{profile.Key}";
                        }
                        PrintToChat(player, outMsg);
                    }
                    else
                        SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("error", this));
                }
                else if (args != null && args.Length == 2)
                {
                    if (args[0] == "add")
                    {
                        var name = args[1];
                        if (TempRecord.AllProfiles.ContainsKey(name))
                        {
                            SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("alreadyexists", this), name);
                            return;
                        }
                        Vector3 pos = player.transform.position;

                        var customSettings = new DataProfile()
                        {
                            AutoSpawn = false,
                            BotNames = new List<string> { "" },
                            LocationX = pos.x,
                            LocationY = pos.y,
                            LocationZ = pos.z,
                        };

                        storedData.DataProfiles.Add(name, customSettings);
                        SaveData();
                        SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("customsaved", this), player.transform.position);
                    }

                    else if (args[0] == "move")
                    {
                        var name = args[1];
                        if (storedData.DataProfiles.ContainsKey(name))
                        {
                            storedData.DataProfiles[name].LocationX = player.transform.position.x;
                            storedData.DataProfiles[name].LocationY = player.transform.position.y;
                            storedData.DataProfiles[name].LocationZ = player.transform.position.z;
                            SaveData();
                            SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("custommoved", this), name);
                        }
                        else
                            SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("noprofile", this));
                    }

                    else if (args[0] == "remove")
                    {
                        var name = args[1];
                        if (storedData.DataProfiles.ContainsKey(name))
                        {
                            foreach (var bot in TempRecord.NPCPlayers)
                            {
                                if (bot == null)
                                    continue;

                                var bData = bot.GetComponent<botData>();
                                if (bData.monumentName == name)
                                    bot.Kill();
                            }
                            TempRecord.AllProfiles.Remove(name);
                            storedData.DataProfiles.Remove(name);
                            SaveData();
                            SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("customremoved", this), name);
                        }
                        else
                            SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("noprofile", this));
                    }
                    else
                        SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("error", this));
                }
                else if (args != null && args.Length == 3)
                {
                    if (args[0] == "toplayer")
                    {
                        var name = args[1];
                        var profile = args[2].ToLower();
                        BasePlayer target = FindPlayerByName(name);
                        Vector3 location = (CalculateGroundPos(player.transform.position, false));
                        var found = false;
                        if (target == null)
                        {
                            SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("namenotfound", this), name);
                            return;
                        }
                        foreach (var entry in TempRecord.AllProfiles)
                        {
                            if (entry.Key.ToLower() == profile)
                            {
                                AttackPlayer(location, entry.Key, entry.Value, null);
                                SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("deployed", this), entry.Key, target.displayName);
                                found = true;
                                return;
                            }
                        }
                        if (!found)
                        {
                            SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("noprofile", this));
                            return;
                        }

                    }
                    else
                        SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("error", this));
                }
                else
                    SendReply(player, "<color=orange>" + lang.GetMessage("Title", this) + "</color>" + lang.GetMessage("error", this));
        }
        #endregion

        public static List<ulong> DeadNPCPlayerIds = new List<ulong>(); //to tracebackpacks
        public static Dictionary<ulong, kitData> kitList = new Dictionary<ulong, kitData>();
        public static Dictionary<ulong, string> kitRemoveList = new Dictionary<ulong, string>();
        public static List<Vector3> smokeGrenades = new List<Vector3>();
        public static List<ulong> aggroPlayers = new List<ulong>();

        #region BotMono
        public class kitData
        {
            public string Kit;
            public bool Wipe_Belt;
            public bool Wipe_Clothing;
            public bool Allow_Rust_Loot;
        }

        public class botData : MonoBehaviour
        {
            public Vector3 spawnPoint;
            public int canChangeWeapon;
            public float enemyDistance;
            public int currentWeaponRange;
            public List<Item> AllProjectiles = new List<Item>();
            public List<Item> MeleeWeapons = new List<Item>();
            public List<Item> CloseRangeWeapons = new List<Item>();
            public List<Item> MediumRangeWeapons = new List<Item>();
            public List<Item> LongRangeWeapons = new List<Item>();
            public int accuracy;
            public float damage;
            public float range;
            public int health;
            public string monumentName;
            public bool dropweapon;
            public bool respawn;
            public bool biome = false;
            public int roamRange;
            public bool goingHome;
            public bool keepAttire;
            public bool peaceKeeper;
            public string group; //external hook identifier 
            public bool chute;
            public bool inAir = false;
            public int LongRangeAttack = 120;
            public int peaceKeeper_CoolDown = 5;

            int landingAttempts = 0;
            Vector3 landingDirection = new Vector3(0, 0, 0);
            int updateCounter = 0;

            NPCPlayerApex botapex;
            void Start()
            {
                botapex = this.GetComponent<NPCPlayerApex>();
                if (chute) inAir = true;
                botapex.GetNavAgent.enabled = true;
                botapex.StoppingDistance = 1f;
                botapex.utilityAiComponent.enabled = true;
                //foreach (BasePlayer player in BasePlayer.activePlayerList)
                //player.SendConsoleCommand("ddraw.line", 10f, Color.blue, botapex.transform.position, new Vector3(botapex.transform.position.x, 300, botapex.transform.position.z)); //Biome Check Debug
            }

            private void OnCollisionEnter(Collision collision)
            {
                var rb = botapex.gameObject.GetComponent<Rigidbody>();
                if (landingAttempts == 0)
                    landingDirection = botapex.transform.forward;
                if (inAir)
                {
                    if (landingAttempts > 5)
                    {
                        rb.isKinematic = true;
                        rb.useGravity = false;
                        botapex.gameObject.layer = 17;

                        foreach (var child in botapex.children)
                        {
                            if (child.name.Contains("parachute"))
                            {
                                child.SetParent(null);
                                break;
                            }
                        }
                        inAir = false;
                        botapex.Resume();
                        return;
                    }
                    if (collision.collider.name.Contains("Terrain"))
                    {
                        rb.isKinematic = true;
                        rb.useGravity = false;
                        botapex.gameObject.layer = 17;

                        foreach (var child in botapex.children)
                        {
                            if (child.name.Contains("parachute"))
                            {
                                child.SetParent(null);
                                break;
                            }
                        }
                        inAir = false;
                        botapex.Resume();

                        botapex.Stats.IsMobile = true;
                        botapex.SetFact(NPCPlayerApex.Facts.IsRoamReady, 1, true, true);
                        botapex.SetFact(NPCPlayerApex.Facts.IsMoving, 1, true, true);
                    }
                    else if (Vector3.Distance(botapex.transform.position, CalculateGroundPos(botapex.transform.position, false)) < 2f)
                    {
                        landingAttempts++;
                        rb.useGravity = true;
                        rb.velocity = new Vector3(landingDirection.x * 15, 11, landingDirection.z * 15);
                        rb.drag = 1f;
                    }
                }
            }

            void Update() 
            {
                updateCounter++;
                if (updateCounter == 1000)
                {
                    updateCounter = 0;
                    Vector3 newAim;
                    if (inAir)
                    {
                        if (botapex.AttackTarget is BasePlayer && !(botapex.AttackTarget is NPCPlayer))
                            botapex.SetAimDirection((botapex.AttackTarget.transform.position - botapex.GetPosition()).normalized);

                        goingHome = false;
                    }
                    else
                    {
                        if (!goingHome && botapex.AttackTarget == null && Vector3.Distance(botapex.transform.position, spawnPoint) > roamRange && botapex.GetNavAgent.isOnNavMesh)
                            goingHome = true;

                        if (goingHome && Vector3.Distance(botapex.transform.position, spawnPoint) > 5 && botapex.GetNavAgent.isOnNavMesh)
                        {
                            botapex.GetNavAgent.SetDestination(spawnPoint);
                        }
                        else
                            goingHome = false;
                    }
                }
            }
        }
        #endregion

        #region Config
        private ConfigData configData;

        class TempRecord
        {
            public static List<NPCPlayerApex> NPCPlayers = new List<NPCPlayerApex>();
            public static Dictionary<string, DataProfile> AllProfiles = new Dictionary<string, DataProfile>();
        }

        class Global
        {
            public bool NPCs_Attack_BotSpawn = true;
            public bool BotSpawn_Attacks_NPCs = true;
            public bool BotSpawn_Attacks_BotSpawn = false;
            public bool Ignore_Animals = true;
            public bool APC_Safe = true;
            public bool Turret_Safe = true;
            public bool Animal_Safe = true;
            public bool Supply_Enabled = false;
            public bool Remove_BackPacks = true;
            public bool Ignore_HumanNPC = true;
            public bool Pve_Safe = true;
            public int Corpse_Duration = 60;
        }
        public class Monuments
        {
            public AirDropProfile AirDrop = new AirDropProfile { };
            public ConfigProfile Airfield = new ConfigProfile { };
            public ConfigProfile Dome = new ConfigProfile { };
            public ConfigProfile Compound = new ConfigProfile { };
            public ConfigProfile Compound1 = new ConfigProfile { };
            public ConfigProfile Compound2 = new ConfigProfile { };
            public ConfigProfile GasStation = new ConfigProfile { };
            public ConfigProfile GasStation1 = new ConfigProfile { };
            public ConfigProfile Harbor1 = new ConfigProfile { };
            public ConfigProfile Harbor2 = new ConfigProfile { };
            public ConfigProfile Junkyard = new ConfigProfile { };
            public ConfigProfile Launchsite = new ConfigProfile { };
            public ConfigProfile Lighthouse = new ConfigProfile { };
            public ConfigProfile Lighthouse1 = new ConfigProfile { };
            public ConfigProfile Lighthouse2 = new ConfigProfile { };
            public ConfigProfile MilitaryTunnel = new ConfigProfile { };
            public ConfigProfile PowerPlant = new ConfigProfile { };
            public ConfigProfile QuarrySulphur = new ConfigProfile { };
            public ConfigProfile QuarryStone = new ConfigProfile { };
            public ConfigProfile QuarryHQM = new ConfigProfile { };
            public ConfigProfile SuperMarket = new ConfigProfile { };
            public ConfigProfile SuperMarket1 = new ConfigProfile { };
            public ConfigProfile Radtown = new ConfigProfile { };
            public ConfigProfile Satellite = new ConfigProfile { };
            public ConfigProfile Trainyard = new ConfigProfile { };
            public ConfigProfile Warehouse = new ConfigProfile { };
            public ConfigProfile Warehouse1 = new ConfigProfile { };
            public ConfigProfile Warehouse2 = new ConfigProfile { };
            public ConfigProfile Watertreatment = new ConfigProfile { };
        }

        public class Biomes
        {
            public ConfigProfile BiomeArid = new ConfigProfile { };
            public ConfigProfile BiomeTemperate = new ConfigProfile { };
            public ConfigProfile BiomeTundra = new ConfigProfile { };
            public ConfigProfile BiomeArctic = new ConfigProfile { };
        }
        public class AirDropProfile
        {
            public bool AutoSpawn = false;
            public bool Murderer = false;
            public int Bots = 5;
            public int BotHealth = 100;
            public int Radius = 100;
            public List<string> Kit = new List<string>();
            public string BotNamePrefix = "";
            public List<string> BotNames = new List<string>();
            public int Bot_Accuracy = 4;
            public float Bot_Damage = 0.4f;
            public bool Disable_Radio = true;
            public int Roam_Range = 40;
            public bool Peace_Keeper = true;
            public int Peace_Keeper_Cool_Down = 5;
            public bool Weapon_Drop = true;
            public bool Keep_Default_Loadout = false;
            public bool Wipe_Belt = true;
            public bool Wipe_Clothing = true;
            public bool Allow_Rust_Loot = true;
            public int Suicide_Timer = 300;
            public bool Chute = false;
            public int Long_Attack_Distance = 120;
        }

        public class ConfigProfile
        {
            public bool AutoSpawn = false;
            public bool Murderer = false;
            public int Bots = 5;
            public int BotHealth = 100;
            public int Radius = 100;
            public List<string> Kit = new List<string>();
            public string BotNamePrefix = "";
            public List<string> BotNames = new List<string>();
            public int Bot_Accuracy = 4;
            public float Bot_Damage = 0.4f;
            public bool Disable_Radio = true;
            public int Roam_Range = 40;
            public bool Peace_Keeper = true;
            public int Peace_Keeper_Cool_Down = 5;
            public bool Weapon_Drop = true;
            public bool Keep_Default_Loadout = false;
            public bool Wipe_Belt = true;
            public bool Wipe_Clothing = true;
            public bool Allow_Rust_Loot = true;
            public int Suicide_Timer = 300;
            public bool Chute = false;
            public int Long_Attack_Distance = 120;
            public int Respawn_Timer = 60;
        }

        public class DataProfile
        {
            public bool AutoSpawn = false;
            public bool Murderer = false;
            public int Bots = 5;
            public int BotHealth = 100;
            public int Radius = 100;
            public List<string> Kit = new List<string>();
            public string BotNamePrefix = "";
            public List<string> BotNames = new List<string>();
            public int Bot_Accuracy = 4;
            public float Bot_Damage = 0.4f;
            public bool Disable_Radio = true;
            public int Roam_Range = 40;
            public bool Peace_Keeper = true;
            public int Peace_Keeper_Cool_Down = 5;
            public bool Weapon_Drop = true;
            public bool Keep_Default_Loadout = false;
            public bool Wipe_Belt = true;
            public bool Wipe_Clothing = true;
            public bool Allow_Rust_Loot = true;
            public int Suicide_Timer = 300;
            public bool Chute = false;
            public int Long_Attack_Distance = 120;
            public int Respawn_Timer = 60;
            public float LocationX;
            public float LocationY;
            public float LocationZ;
            public string Parent_Monument = "";
        }

        public class ProfileRelocation
        {
            public float OldParentMonumentX = 0;
            public float OldParentMonumentY = 0;
            public float OldParentMonumentZ = 0;
            public float ParentMonumentX = 0;
            public float ParentMonumentY = 0;
            public float ParentMonumentZ = 0;
            public float oldRotation = 0.0f;
            public float worldRotation = 0.0f;
        }

        class ConfigData
        {
            public Global Global = new Global();
            public Monuments Monuments = new Monuments();
            public Biomes Biomes = new Biomes();
        }
                        class OldConfigData //Remove in 1.6.7
                        {
                            public Options Options = new Options();
                            public Monuments Zones = new Monuments();
                        }
                                class Options
                        {
                            public bool NPCs_Attack_BotSpawn = true;
                            public bool BotSpawn_Attacks_NPCs = true;
                            public bool BotSpawn_Attacks_BotSpawn = false;
                            public bool Ignore_Animals = true;
                            public bool APC_Safe = true;
                            public bool Turret_Safe = true;
                            public bool Animal_Safe = true;
                            public bool Supply_Enabled = false;
                            public bool Remove_BackPacks = true;
                            public bool Ignore_HumanNPC = true;
                            public bool Pve_Safe = true;
                            public int Corpse_Duration = 60;
                        }
        
        private void LoadConfigVariables()
        {
            ///////////////////////////////////////////////////////////////////////////MIGRATION INFO TO REMOVE in 1.6.7
            var oldconfigData = Config.ReadObject<OldConfigData>();
            var oldDeser = JsonConvert.SerializeObject(oldconfigData);
            if (oldDeser.Length != 19414 && oldDeser.Length != 18673)
            {  
                oldDeser = oldDeser.Replace(("\"Zones\":"), ("\"Monuments\":")); 
                oldDeser = oldDeser.Replace(("\"Options\":"), ("\"Global\":"));
                int lastPos = oldDeser.LastIndexOf('}');
                oldDeser = oldDeser.Insert(lastPos, ",\"Biomes\":{}");  
                var migratedData = JsonConvert.DeserializeObject<ConfigData>(oldDeser);
                SaveConfig(migratedData);
            }
            ///////////////////////////////////////////////////////////////////////////  

            configData = Config.ReadObject<ConfigData>();
            SaveConfig(configData);
        }
        protected override void LoadDefaultConfig()
        {  
            Puts("Creating new config file.");

            var config = new ConfigData();
            SaveConfig(config);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"Title", "BotSpawn : " },
            {"error", "/botspawn commands are - list - add - remove - move - toplayer" },
            {"customsaved", "Custom Location Saved @ {0}" },
            {"custommoved", "Custom Location {0} has been moved to your current position." },
            {"alreadyexists", "Custom Location already exists with the name {0}." },
            {"customremoved", "Custom Location {0} Removed." },
            {"deployed", "'{0}' bots deployed to {1}." },
            {"ListTitle", "Custom Locations" },
            {"noprofile", "There is no profile by that name in config or data BotSpawn.json files." },
            {"namenotfound", "Player '{0}' was not found" },
            {"nokits", "Kits is not installed but you have declared custom kits at {0}." },
            {"noWeapon", "A bot at {0} has no weapon. Check your kits." },
            {"numberOfBot", "There is {0} spawned bot alive." },
            {"numberOfBots", "There are {0} spawned bots alive." },

        };
        #endregion

        #region ExternalHooks
        [HookMethod("AddGroupSpawn")]
        public string[] AddGroupSpawn(Vector3 location, string profileName, string group)
        {
            if (location == new Vector3() || profileName == null || group == null)
                return new string[] { "error", "Null parameter" };
            string lowerProfile = profileName.ToLower();

            foreach (var entry in TempRecord.AllProfiles)
            {
                if (entry.Key.ToLower() == lowerProfile)
                {
                    var profile = entry.Value;
                    Vector3 targetLocation = (CalculateGroundPos(location, false));
                    AttackPlayer(targetLocation, entry.Key, profile, group.ToLower());
                    return new string[] { "true", "Group Successfully Added" };
                }
            }
            return new string[] { "false", "Group add failed - Check profile name and try again" };
        }

        [HookMethod("RemoveGroupSpawn")]
        public string[] RemoveGroupSpawn(string group)
        {
            if (group == null)
                return new string[] { "error", "No Group Specified." };

            List<NPCPlayerApex> toDestroy = new List<NPCPlayerApex>();
            foreach (var bot in TempRecord.NPCPlayers)
            {
                if (bot == null)
                    continue;
                var bData = bot.GetComponent<botData>();
                if (bData.group == group.ToLower())
                    toDestroy.Add(bot);
            }
            if (toDestroy.Count == 0)
                return new string[] { "true", $"There are no bots belonging to {group}" };
            foreach (var killBot in toDestroy)
            {
                UpdateRecords(killBot);
                killBot.Kill();
            }
            return new string[] { "true", $"Group {group} was destroyed." };

        }

        [HookMethod("CreateNewProfile")]
        public string[] CreateNewProfile(string name, string profile)
        {
            if (name == null)
                return new string[] { "error", "No Name Specified." };
            if (profile == null)
                return new string[] { "error", "No Profile Settings Specified." };

            DataProfile newProfile = JsonConvert.DeserializeObject<DataProfile>(profile);

            if (storedData.DataProfiles.ContainsKey(name))
            {
                storedData.DataProfiles[name] = newProfile;
                TempRecord.AllProfiles[name] = newProfile;
                return new string[] { "true", $"Profile {name} Was Updated" };
            }

            storedData.DataProfiles.Add(name, newProfile);
            SaveData();
            TempRecord.AllProfiles.Add(name, newProfile);
            return new string[] { "true", $"New Profile {name} Was Created." };
        }

        [HookMethod("ProfileExists")]
        public string[] ProfileExists(string name)
        {
            if (name == null)
                return new string[] { "error", "No Name Specified." };

            if (TempRecord.AllProfiles.ContainsKey(name))
                return new string[] { "true", $"{name} Exists." };

            return new string[] { "false", $"{name} Does Not Exist." };
        }

        [HookMethod("RemoveProfile")]
        public string[] RemoveProfile(string name)
        {
            if (name == null)
                return new string[] { "error", "No Name Specified." };

            if (storedData.DataProfiles.ContainsKey(name))
            {
                foreach (var bot in TempRecord.NPCPlayers)
                {
                    if (bot == null)
                        continue;

                    var bData = bot.GetComponent<botData>();
                    if (bData.monumentName == name)
                        bot.Kill();
                }
                TempRecord.AllProfiles.Remove(name);
                storedData.DataProfiles.Remove(name);
                SaveData();
                return new string[] { "true", $"Profile {name} Was Removed." };
            }
            else
            {
                return new string[] { "false", $"Profile {name} Does Not Exist." };
            }
        }
        #endregion
    }
}

// --- End of file: BotSpawn.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NukeWipe.cs ---
// --- Original Local Path: NukeWipe.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Facepunch;
using System;

namespace Oxide.Plugins
{
    [Info("NukeWipe", "LaserHydra", "1.0.0", ResourceId = 0)]
    [Description("Wipe with style - and propably lag lol")]
    class NukeWipe : RustPlugin
    {
        #region Global Declaration

        Type[] DestroyableTypes = new Type[]
        {
            typeof(BuildingBlock),
            typeof(Barricade),
            typeof(BaseOven),
            typeof(Door),
            typeof(StorageContainer),
            typeof(BuildingPrivlidge),
            typeof(SimpleBuildingBlock),
            typeof(Signage),
            typeof(RepairBench),
            typeof(ResearchTable),
            typeof(DroppedItem),
            typeof(MiningQuarry),
            typeof(WaterCatcher),
            typeof(AutoTurret),
            typeof(BaseCombatEntity)
        };

        #endregion

        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
#if !RUST
            throw new NotSupportedException("This plugin or the version of this plugin does not support this game!");
#endif

            RegisterPerm("use");

            LoadMessages();
            LoadConfig();
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Settings", "Time Until Explosion", 20f);

            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Nuke About To Happen", "<color=red>A NUCLEAR EXPLOSION IS ABOUT TO HAPPEN!</color>"},
                {"Nuke Done", "<color=red>A NUCLEAR EXPLOSION DESTROYED EVERYTHING AND KILLED EVERYBODY!</color>"}
            }, this);
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        #endregion

        #region Commands

        [ChatCommand("nuke")]
        void cmdNuke(BasePlayer player)
        {
            if(!HasPerm(player.userID, "use"))
            {
                SendChatMessage(player, GetMsg("No Permission", player.userID));
                return;
            }

            BroadcastChat(GetMsg("Nuke About To Happen"));

            timer.Once(GetConfig(20f, "Settings", "Time Until Explosion"), () => Nuke());
        }

        #endregion

        #region Subject Related

        void Nuke()
        {
            //  Make all Players explode
            foreach (var player in CopyList(BasePlayer.activePlayerList))
                Explode(player);

            //  Make all Sleepers explode
            foreach (var player in CopyList(BasePlayer.sleepingPlayerList))
                Explode(player);

            //  Get all Entities
            var entities = GetEntities<BaseEntity>(new Vector3(0, 0, 0), Convert.ToInt32(ConVar.Server.worldsize * 0.8f));
            
            //  Kill all Entities which should be wiped
            foreach (var building in (from entity in entities where ShouldBeDestroyed(entity) select entity))
                building.Kill(BaseNetworkable.DestroyMode.None);

            Pool.FreeList(ref entities);

            //  Remove Corpses
            timer.Once(5.01f, () =>
            {
                //  Get all Corpses
                List<BaseCorpse> corpses = GetEntities<BaseCorpse>(Vector3.zero, Convert.ToInt32(ConVar.Server.worldsize * 0.8f));

                //  Kill all Corpses
                foreach (var corpse in corpses)
                    corpse.Kill(BaseNetworkable.DestroyMode.None);

                Pool.FreeList(ref corpses);

                BroadcastChat(GetMsg("Nuke Done"));
            });
        }

        void Explode(BasePlayer player)
        {
            //  Initialize DamageTypeEntry - Explosion
            Rust.DamageTypeEntry dmg = new Rust.DamageTypeEntry();
            dmg.amount = 100;
            dmg.type = Rust.DamageType.Generic;

            //  Fire Effects
            Effect.server.Run("assets/bundled/prefabs/fx/fire/fire_v2.prefab", player.transform.position, Vector3.up);
            Effect.server.Run("assets/bundled/prefabs/fx/fire/fire_v2.prefab", player.transform.position + new Vector3(1, 0, 1), Vector3.up);
            Effect.server.Run("assets/bundled/prefabs/fx/fire/fire_v2.prefab", player.transform.position + new Vector3(1, 0, 0), Vector3.up);
            Effect.server.Run("assets/bundled/prefabs/fx/fire/fire_v2.prefab", player.transform.position + new Vector3(0, 0, 1), Vector3.up);

            //  Explosion Effect
            Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", player.transform.position, Vector3.up, null, true);

            //  Initialize HitInfo
            HitInfo hitInfo = new HitInfo()
            {
                Initiator = null,
                WeaponPrefab = null
            };

            //  Add DamageTypeEntry to HitInfo
            hitInfo.damageTypes.Add(new List<Rust.DamageTypeEntry> { dmg });

            //  Hurt Player
            DamageUtil.RadiusDamage(null, null, player.transform.position, 5, 10, new List<Rust.DamageTypeEntry> { dmg }, 133376, true);

            //  Hurt Player
            //  player.Hurt(hitInfo, true);

            timer.Once(5f, () => 
            {
                //  Kill player if still wounded
                if(player.IsWounded())
                    player.DieInstantly();
            });
        }

        bool ShouldBeDestroyed(BaseEntity entity) => DestroyableTypes.Contains(entity.GetType());

#endregion

        #region General Methods

        ////////////////////////////////////////
        ///     Game Related
        ////////////////////////////////////////

        List<T> GetEntities<T>(Vector3 position, int radius)
        where T : BaseEntity
        {
            List<T> list = Pool.GetList<T>();
            Vis.Entities(position, radius, list, LayerMask.GetMask("Construction", "Deployed", "Default", "Ragdoll"));

            return list;
        }

        ////////////////////////////////////////
        ///     Converting etc.
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        List<T> CopyList<T>(List<T> list)
        {
            T[] copy = new T[list.Count];
            list.CopyTo(copy);

            return copy.ToList();
        }

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Data Related
        ////////////////////////////////////////

        void LoadData<T>(ref T data, string filename = "?") => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename == "?" ? this.Title : filename);

        void SaveData<T>(ref T data, string filename = "?") => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == "?" ? this.Title : filename, data);

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        void RegisterPerm(params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
        }

        bool HasPerm(object uid, params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
        }

        string PermissionPrefix
        {
            get
            {
                return this.Title.Replace(" ", "").ToLower();
            }
        }

        ////////////////////////////////////////
        ///     Chat Related
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        #endregion

        #region Dev / Debug

        /*
        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustPressed(BUTTON.USE))
                Puts(GetViewEntity(player)?.GetType()?.ToString() ?? "unknown");
        }


        BaseEntity GetViewEntity(BasePlayer player)
        {
            RaycastHit hit;

            if (Physics.Raycast(player.eyes.HeadRay(), out hit))
                return hit.GetEntity();

            return null;
        }*/

        #endregion
    }
}


// --- End of file: NukeWipe.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LoadingMessages.cs ---
// --- Original Local Path: LoadingMessages.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Network;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("LoadingMessages", "VVoid", "1.0.1", ResourceId = 2762)]
    [Description("Shows custom texts on loading screen.")]
    public class LoadingMessages : RustPlugin
    {
        private readonly Dictionary<ulong, Connection> _clients = new Dictionary<ulong, Connection>();
        private readonly List<ulong> _disconnectedClients = new List<ulong>();

        #region Variables

        private MsgConfig _config;
        private Timer _timer;
        private MsgEntry _currentMsg;
        private int _msgIdx;
        private float _nextMsgChange;

        #endregion

        #region Config

        private class MsgConfig
        {
            [JsonProperty("Text Display Frequency (Seconds)")]
            public float TimerFreq;
            [JsonProperty("Enable Messages Cyclicity")]
            public bool EnableCyclicity;
            [JsonProperty("Use Random Cyclicity (Instead of sequential)")]
            public bool EnableRandomCyclicity;
            [JsonProperty("Cycle Messages Every ~N Seconds")]
            public float CyclicityFreq;
            [JsonProperty("Messages")]
            public List<MsgEntry> Messages;
            [JsonProperty("Last Message (When entering game)")]
            public MsgEntry LastMessage;
        }

        private class MsgEntry
        {
            [JsonProperty("Top Status")]
            public string TopString;
            [JsonProperty("Bottom Status")]
            public string BottomString;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<MsgConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            _config = new MsgConfig
            {
                TimerFreq = .30f,
                EnableCyclicity = false,
                EnableRandomCyclicity = false,
                CyclicityFreq = 3.0f,
                Messages = new List<MsgEntry>
                {
                    new MsgEntry{TopString = "<color=yellow>Welcome to our server!</color>", BottomString = "<color=lightblue>Enjoy your stay.</color>"},
                    new MsgEntry{TopString = "<color=lightblue>Welcome to our server!</color>", BottomString = "<color=yellow>Enjoy your stay.</color>"}
                },
                LastMessage = new MsgEntry {TopString = "<color=yellow>Welcome to our server!</color>", BottomString = "<color=green>Entering game...</color>"}
            };
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Hooks

        private void Init()
        {
            if (_config.Messages == null || _config.Messages.Count == 0)
            {
                Unsubscribe(nameof(OnUserApprove));
                Unsubscribe(nameof(OnPlayerInit));
                PrintWarning("No loading messages defined! Check your config.");
                return;
            }
            if (_config.EnableCyclicity && _config.Messages.Count <= 1)
            {
                _config.EnableCyclicity = false;
                PrintWarning("You have message cyclicity enabled, but only 1 message is defined. Check your config.");
            }
            _currentMsg = _config.Messages.First();
        }


        private void OnUserApprove(Connection connection)
        {
            _clients[connection.userid] = connection;
            if (_timer == null)
                _timer = timer.Every(_config.TimerFreq, HandleClients);
            DisplayMessage(connection, _currentMsg);
        }

        private void OnPlayerInit(BasePlayer player)
        {
            _clients.Remove(player.userID);
            DisplayMessage(player.Connection, _config.LastMessage ?? _currentMsg);
        }

        #endregion

        #region Logic

        private void UpdateCurrentMessage()
        {
            if (!_config.EnableCyclicity || Time.realtimeSinceStartup < _nextMsgChange)
                return;
            _nextMsgChange = Time.realtimeSinceStartup + _config.CyclicityFreq;
            if (_config.EnableRandomCyclicity)
                _currentMsg = PickRandom(_config.Messages);
            else
            {
                _currentMsg = _config.Messages[_msgIdx++];
                if (_msgIdx >= _config.Messages.Count)
                    _msgIdx = 0;
            }
        }

        private void HandleClients()
        {
            if (_clients.Count == 0)
            {
                _timer.Destroy();
                _timer = null;
                return;
            }
            UpdateCurrentMessage();
            foreach (var client in _clients.Values)
            {
                if (!client.active)
                {
                    _disconnectedClients.Add(client.userid);
                    continue;
                }
                if (client.state == Connection.State.InQueue)
                    continue;
                DisplayMessage(client, _currentMsg);
            }

            if (_disconnectedClients.Count == 0)
                return;
            _disconnectedClients.ForEach(uid=>_clients.Remove(uid));
            _disconnectedClients.Clear();
        }

        private static void DisplayMessage(Connection con, MsgEntry msgEntry)
        {
            if (!Net.sv.write.Start())
                return;
            Net.sv.write.PacketID(Message.Type.Message);
            Net.sv.write.String(msgEntry.TopString);
            Net.sv.write.String(msgEntry.BottomString);
            Net.sv.write.Send(new SendInfo(con));
        }

        private static T PickRandom<T>(List<T> list) => list[Random.Range(0, list.Count - 1)];

        #endregion
    }
}


// --- End of file: LoadingMessages.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HideAndSeek.cs ---
// --- Original Local Path: HideAndSeek.cs ---

/*
TODO:
- Add configuration and localization support
- Add cooldown option for taunting
- Add option for picking which taunts are allowed?
- Add option to only taunt prop's effect(s)
- Add option to show gibs for props or not
- Figure out why Hurt() isn't working for damage passing
- Fix OnPlayerInput checks not allowing players to be props sometimes (dictionary issue)
- Move taunt GUI button to better position
- Unselect active item if selected (make sure to restore fully)
- Update configuration to have usable defaults
- Update configuration automatically
- Whitelist objects to block bad prefabs
*/

using System.Collections.Generic;
using System.Linq;

using UnityEngine;

using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("HideAndSeek", "Wulf/lukespragg", 0.1, ResourceId = 0)]
    [Description("The classic game(mode) of hide and seek, as props.")]

    class HideAndSeek : RustPlugin
    {
        #region Configuration

        string NoPermission => Config.Get<string>("NoPermission");
        string PlayerHiding => Config.Get<string>("PlayerHiding");
        string PlayerNotHiding => Config.Get<string>("PlayerNotHiding");

        protected override void LoadDefaultConfig()
        {
            Config["NoPermission"] = "Sorry, you can't use 'hide' right now";
            Config["PlayerHiding"] = "<size=20>You're hiding... shhh!</size>";
            Config["PlayerNotHiding"] = "<size=20>You're no longer hiding, run!</size>";
        }

        #endregion

        #region General Setup

        readonly Dictionary<BaseEntity, BasePlayer> props = new Dictionary<BaseEntity, BasePlayer>();

        void Loaded()
        {
            permission.RegisterPermission("hideandseek.allowed", this);

            //foreach (var player in props.Values) TauntButton(player, null);
        }

        #endregion

        #region Player Info

        class OnlinePlayer
        {
            public BasePlayer Player;
            public bool IsHidden;
        }

        [OnlinePlayers] Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();

        #endregion

        #region Player Restoring

        void OnPlayerInit(BasePlayer player)
        {
            if (!props.ContainsValue(player)) return;

            player.EndSleeping();
            SetPropFlags(player);
        }

        #endregion

        #region Prop Flags

        void SetPropFlags(BasePlayer player)
        {
            // Remove admin/developer flags
            if (player.IsAdmin()) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            if (player.IsDeveloper()) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);

            // Change to third-person view
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.EyesViewmode, false);

            onlinePlayers[player].IsHidden = true;
        }

        void UnsetPropFlags(BasePlayer player)
        {
            // Change to normal view
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.EyesViewmode, false);

            // Restore admin/developer flags
            if (player.net.connection.authLevel > 0) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
            if (DeveloperList.IsDeveloper(player)) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, true);

            onlinePlayers[player].IsHidden = false;
        }

        #endregion

        #region Player Hiding

        void HidePlayer(BasePlayer player)
        {
            // Make the player invisible
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
            player.gameObject.SetLayerRecursive(10);
            player.CancelInvoke("MetabolismUpdate");
            player.CancelInvoke("InventoryUpdate");

            // Set the player flags
            SetPropFlags(player);

            // Show the taunt button
            TauntButton(player, null);

            PrintToChat(player, PlayerHiding);
        }

        void UnhidePlayer(BasePlayer player)
        {
            // Make the player visible
            player.metabolism.Reset();
            player.InvokeRepeating("InventoryUpdate", 1f, 0.1f*Random.Range(0.99f, 1.01f));
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
            player.gameObject.SetLayerRecursive(17);

            // Set the player flags
            UnsetPropFlags(player);

            // Remove the taunt button
            CuiHelper.DestroyUi(player, tauntPanel);

            PrintToChat(player, PlayerNotHiding);
        }

        #endregion

        #region Chat Commands

        [ChatCommand("hide")]
        void HideChat(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "hideandseek.allowed"))
            {
                SendReply(player, NoPermission);
                return;
            }

            // Check if player is already hidden
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.Spectating) || onlinePlayers[player].IsHidden)
            {
                SendReply(player, "You're already hidden!");
                return;
            }

            var ray = new Ray(player.eyes.position, player.eyes.HeadForward());
            var entity = FindObject(ray, 3); // TODO: Make distance (3) configurable
            if (entity == null || props.ContainsKey(entity)) return;

            // Hide active item
            if (player.GetActiveItem() != null)
            {
                var heldEntity = player.GetActiveItem().GetHeldEntity() as HeldEntity;
                //heldEntity?.SetHeld(false);
            }

            // Hide the player
            HidePlayer(player);

            // Create the prop entity
            var propEntity = GameManager.server.CreateEntity(entity.name, player.transform.position, player.transform.rotation);
            propEntity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);
            propEntity.SendMessage("InitializeItem", entity, SendMessageOptions.DontRequireReceiver);
            propEntity.Spawn();
            props.Add(propEntity, player);
        }

        [ChatCommand("unhide")]
        void UnhideChat(BasePlayer player, string command, string[] args)
        {
            if (!HasPermission(player, "hideandseek.allowed"))
            {
                SendReply(player, NoPermission);
                return;
            }

            // Check if player is already unhidden
            if (!player.HasPlayerFlag(BasePlayer.PlayerFlags.Spectating) || !onlinePlayers[player].IsHidden)
            {
                SendReply(player, "You're already unhidden!");
                return;
            }

            // Unhide the player
            UnhidePlayer(player);

            // Remove the prop entity
            if (!props.ContainsValue(player)) return;
            BaseEntity propEntity = null;
            foreach (var prop in props.Where(prop => prop.Value == player)) propEntity = prop.Key;
            if (propEntity == null || propEntity.isDestroyed) return;
            props.Remove(propEntity);
            propEntity.Kill(BaseNetworkable.DestroyMode.Gib);
        }

        #endregion

        #region Prop Taunting

        [ChatCommand("taunt")]
        void TauntPlayer(BasePlayer player, string command, string[] args)
        {
            // Check if player is already unhidden
            if (!player.HasPlayerFlag(BasePlayer.PlayerFlags.Spectating) || !onlinePlayers[player].IsHidden)
            {
                PrintToChat(player, "You're not a prop!");
                return;
            }

            var r = new System.Random();
            var taunts = new[]
            {
                "animals/bear/attack1",
                "animals/bear/attack2",
                "animals/bear/bite",
                "animals/bear/breathe-1",
                "animals/bear/breathing",
                "animals/bear/death",
                "animals/bear/roar1",
                "animals/bear/roar2",
                "animals/bear/roar3",
                "animals/boar/attack1",
                "animals/boar/attack2",
                "animals/boar/flinch1",
                "animals/boar/flinch2",
                "animals/boar/scream",
                "animals/chicken/attack1",
                "animals/chicken/attack2",
                "animals/chicken/attack3",
                "animals/chicken/cluck1",
                "animals/chicken/cluck2",
                "animals/chicken/cluck3",
                "animals/horse/attack",
                "animals/horse/flinch1",
                "animals/horse/flinch2",
                "animals/horse/heavy_breath",
                "animals/horse/snort",
                "animals/horse/whinny",
                "animals/horse/whinny_large",
                "animals/rabbit/attack1",
                "animals/rabbit/attack2",
                "animals/rabbit/run",
                "animals/rabbit/walk",
                "animals/stag/attack1",
                "animals/stag/attack2",
                "animals/stag/death1",
                "animals/stag/death2",
                "animals/stag/flinch1",
                "animals/stag/scream",
                "animals/wolf/attack1",
                "animals/wolf/attack2",
                "animals/wolf/bark",
                "animals/wolf/breathe",
                "animals/wolf/howl1",
                "animals/wolf/howl2",
                "animals/wolf/run_attack",
                "barricades/damage",
                "beartrap/arm",
                "beartrap/fire",
                //"bucket_drop_debris",
                "build/frame_place",
                //"build/promote_metal",
                //"build/promote_stone",
                //"build/promote_toptier",
                //"build/promote_wood",
                "build/repair",
                "build/repair_failed",
                "build/repair_full",
                "building/fort_metal_gib",
                "building/metal_sheet_gib",
                "building/stone_gib",
                "building/thatch_gib",
                "building/wood_gib",
                "door/door-metal-impact",
                "door/door-metal-knock",
                "door/door-wood-impact",
                "door/door-wood-knock",
                "door/lock.code.denied",
                "door/lock.code.lock",
                "door/lock.code.unlock",
                "door/lock.code.updated",
                //"entities/helicopter/heli_explosion",
                //"entities/helicopter/rocket_airburst_explosion",
                //"entities/helicopter/rocket_explosion",
                "entities/helicopter/rocket_fire",
                "entities/loot_barrel/gib",
                "entities/loot_barrel/impact",
                "entities/tree/tree-impact",
                //"fire/fire_v2",
                //"fire/fire_v3",
                //"fire_explosion",
                //"gas_explosion_small",
                "gestures/cameratakescreenshot",
                "gestures/guitarpluck",
                "gestures/guitarstrum",
                "headshot",
                "headshot_2d",
                "hit_notify",
                /*"impacts/additive/explosion",
                "impacts/blunt/clothflesh/clothflesh1",
                "impacts/blunt/concrete/concrete1",
                "impacts/blunt/metal/metal1",
                "impacts/blunt/wood/wood1",
                "impacts/bullet/clothflesh/clothflesh1",
                "impacts/bullet/concrete/concrete1",
                "impacts/bullet/dirt/dirt1",
                "impacts/bullet/forest/forest1",
                "impacts/bullet/metal/metal1",
                "impacts/bullet/metalore/bullet_impact_metalore",
                "impacts/bullet/path/path1",
                "impacts/bullet/rock/bullet_impact_rock",
                "impacts/bullet/sand/sand1",
                "impacts/bullet/snow/snow1",
                "impacts/bullet/tundra/bullet_impact_tundra",
                "impacts/bullet/wood/wood1",
                "impacts/slash/concrete/slash_concrete_01",
                "impacts/slash/metal/metal1",
                "impacts/slash/metal/metal2",
                "impacts/slash/metalore/slash_metalore_01",
                "impacts/slash/rock/slash_rock_01",
                "impacts/slash/wood/wood1",*/
                "item_break",
                "player/beartrap_clothing_rustle",
                "player/beartrap_scream",
                "player/groundfall",
                "player/howl",
                //"player/onfire",
                "repairbench/itemrepair",
                "ricochet/ricochet1",
                "ricochet/ricochet2",
                "ricochet/ricochet3",
                "ricochet/ricochet4",
                //"survey_explosion",
                //"weapons/c4/c4_explosion",
                "weapons/rifle_jingle1",
                "weapons/survey_charge/survey_charge_stick",
                "weapons/vm_machete/attack-1",
                "weapons/vm_machete/attack-2",
                "weapons/vm_machete/attack-3",
                "weapons/vm_machete/deploy",
                "weapons/vm_machete/hit"
            };
            var taunt = taunts[r.Next(taunts.Length)];

            //PrintToChat($"<size=20>{taunt}</size>");
            Effect.server.Run($"assets/bundled/prefabs/fx/{taunt}.prefab", player.transform.position, Vector3.zero);
        }

        #endregion

        #region Damage Passing

        object OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (entity is BasePlayer) return null;
            if (!props.ContainsKey(entity))
            {
                var attacker = info.Initiator as BasePlayer;
                attacker?.Hurt(info.damageTypes.Total());
                return true;
            };

            var propPlayer = props[entity];
            if (propPlayer.health <= 1)
            {
                propPlayer.Die();
                return null;
            }
            props[entity].InitializeHealth(propPlayer.health - info.damageTypes.Total(), 100f);

            return true;
        }

        #endregion

        #region Death Handling

        void OnEntityDeath(BaseEntity entity)
        {
            // Check for prop entity/player
            if (!props.ContainsValue(entity.ToPlayer())) return;
            var player = entity.ToPlayer();

            // Get the prop entity
            BaseEntity propEntity = null;
            foreach (var prop in props.Where(prop => prop.Value == player)) propEntity = prop.Key;

            // Unhide and respawn the player
            UnhidePlayer(player);
            props.Remove(player);
            player.RespawnAt(player.transform.position, player.transform.rotation);

            // Remove the prop entity
            if (propEntity && !propEntity.isDestroyed) propEntity.Kill(BaseNetworkable.DestroyMode.Gib);
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            // Remove all corpses
            if (entity.LookupShortPrefabName().Equals("player_corpse.prefab")) entity.KillMessage();
        }

        #endregion

        #region Spectate Blocking

        object OnRunCommand(ConsoleSystem.Arg arg)
        {
            if (arg?.connection != null && arg.cmd.name == "spectate") return true;
            return null;
        }

        object OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!props.ContainsValue(player) && !player.IsSpectating() && input.WasJustPressed(BUTTON.FIRE_PRIMARY)) HideChat(player, null, null);
            if (props.ContainsValue(player) && player.IsSpectating() && input.WasJustPressed(BUTTON.FIRE_SECONDARY)) UnhideChat(player, null, null);
            if (props.ContainsValue(player) && player.IsSpectating() && input.WasJustPressed(BUTTON.JUMP) || input.WasJustPressed(BUTTON.DUCK)) return true;

            return null;
        }

        #endregion

        #region Console Commands

        [ConsoleCommand("global.taunt")]
        void TauntConsole(ConsoleSystem.Arg arg)
        {
            var player = BasePlayer.Find(arg.GetString(0));
            if (player) TauntPlayer(player, null, null);
        }

        #endregion

        #region GUI Button

        string tauntPanel;

        void TauntButton(BasePlayer player, string text)
        {
            var elements = new CuiElementContainer();
            tauntPanel = elements.Add(new CuiPanel
            {
                Image = {Color = "0.0 0.0 0.0 0.0"},
                RectTransform = { AnchorMin = "0.026 0.037", AnchorMax = "0.075 0.10" }
            }, "HUD/Overlay", "taunt");
            elements.Add(new CuiElement
            {
                Parent = tauntPanel,
                Components =
                {
                    new CuiRawImageComponent {Url = "http://i.imgur.com/28fdPww.png"},
                    new CuiRectTransformComponent {AnchorMin = "0.0 0.0", AnchorMax = "1.0 1.0"}
                }
            });
            elements.Add(new CuiButton
            {
                Button = {Command = $"taunt {player.userID}", Color = "0.0 0.0 0.0 0.0"},
                RectTransform = {AnchorMin = "0.026 0.037", AnchorMax = "0.075 0.10"},
                Text = {Text = ""}
            });
            CuiHelper.DestroyUi(player, tauntPanel);
            CuiHelper.AddUi(player, elements);
        }

        #endregion

        #region Cleanup Props

        void Unload()
        {
            foreach (var prop in props)
            {
                var propEntity = prop.Key;
                if (!propEntity.isDestroyed) propEntity.Kill(BaseNetworkable.DestroyMode.Gib);
                UnhidePlayer(prop.Value);
            }

            foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, tauntPanel);
        }

        #endregion

        #region Helper Methods

        static BaseEntity FindObject(Ray ray, float distance)
        {
            RaycastHit hit;
            return !Physics.Raycast(ray, out hit, distance) ? null : hit.GetEntity();
        }

        bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        #endregion
    }
}


// --- End of file: HideAndSeek.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IngameClockGUI.cs ---
// --- Original Local Path: IngameClockGUI.cs ---

using System;
using System.Collections.Generic;

using Oxide.Core;

namespace Oxide.Plugins
{
	[Info("Ingame Clock GUI", "deer_SWAG", "0.0.5", ResourceId = 1245)]
	[Description("Displays ingame and server time")]
	public class IngameClockGUI : RustPlugin
	{
		const string databaseName = "IngameClockGUI";
		const int isClockEnabled = 1 << 0;
		const int isServerTime = 1 << 1;
		const string defaultInfoSize = "0.3";

		class Data
		{
			public HashSet<Player> Players = new HashSet<Player>();

			public Data() {}
		}

		class Player
		{
			public ulong userID;
			public short options;

			public Player() {}
			public Player(ulong id, short o)
			{
				userID = id;
				options = o;
			}
		}

		private class TimedInfo
		{
			public DateTime startTime;
			public DateTime endTime;
			public string text;
			public bool serverTime;
			public string size;

			public TimedInfo(DateTime st, DateTime et, string txt, bool server, string s)
			{
				startTime = st;
				endTime = et;
				text = txt;
				serverTime = server;
				size = s;
			}
		}

		private string clockJson = @"
		[{
			""name"":   ""Clock"",
			""parent"": ""Overlay"",
			""components"":
			[
				{
					""type"":	   ""UnityEngine.UI.Button"",
					""color"":	   ""%background%"",
					""imagetype"": ""Tiled""
				},
				{
					""type"":	   ""RectTransform"",
					""anchormin"": ""%left% %bottom%"",
					""anchormax"": ""%right% %top%""
				}
			]
		},
		{
			""parent"": ""Clock"",
			""components"":
			[
				{
					""type"":	  ""UnityEngine.UI.Text"",
					""text"":	  ""%prefix%%time%%postfix%"",
					""fontSize"": %size%,
					""color"":    ""%color%"",
					""align"":    ""MiddleCenter""
				},
				{
					""type"":	   ""RectTransform"",
					""anchormin"": ""0 0"",
					""anchormax"": ""1 0.9""
				}
			]
		}]";

		private string infoJson = @"
		[{
			""name"":   ""ClockInfo"",
			""parent"": ""Overlay"",
			""components"":
			[
				{
					""type"":	   ""UnityEngine.UI.Button"",
					""color"":	   ""%background%"",
					""imagetype"": ""Tiled""
				},
				{
					""type"":	   ""RectTransform"",
					""anchormin"": ""%info_left% %bottom%"",
					""anchormax"": ""%info_right% %top%""
				}
			]
		},
		{
			""parent"": ""ClockInfo"",
			""components"":
			[
				{
					""type"":	  ""UnityEngine.UI.Text"",
					""text"":	  ""%info%"",
					""fontSize"": %size%,
					""color"":    ""%color%"",
					""align"":    ""MiddleCenter""
				},
				{
					""type"":	   ""RectTransform"",
					""anchormin"": ""0.01 0"",
					""anchormax"": ""0.99 1""
				}
			]
		}]";

		// -------------------- MAIN --------------------

		Data 		data;
		Timer 		updateTimer;
		TOD_Sky 	sky;
		DateTime 	dt;

		bool isLoaded = false,
			 isInit   = false;

		string   time = "";
		DateTime gameTime;
		DateTime serverTime;

		private TimedInfo 		currentTI;
		private List<TimedInfo> tiList;

		protected override void LoadDefaultConfig()
		{
			Config.Clear();

			CheckCreateConfig();

			SaveConfig();
			Puts("Default config was saved and loaded!");
		}

		void OnPluginLoaded()
		{
			isLoaded = true;
			if(isInit) Load();
		}

		void OnServerInitialized()
		{
			isInit = true;
			if(isLoaded) Load();
		}

		void Load()
		{
			data = Interface.GetMod().DataFileSystem.ReadObject<Data>(databaseName);
			tiList = new List<TimedInfo>();
			currentTI = null;
			sky  = TOD_Sky.Instance;

			CheckCreateConfig();

			double left   = (double)Config["Position", "Left"];
			double right  = (double)Config["Position", "Left"] + (double)Config["Size", "Width"];
			double bottom = (double)Config["Position", "Bottom"];
			double top    = (double)Config["Position", "Bottom"] + (double)Config["Size", "Height"];

			clockJson = clockJson.Replace("%background%", (string)Config["BackgroundColor"])
								 .Replace("%color%", (string)Config["TextColor"])
								 .Replace("%size%", Config["FontSize"].ToString())
								 .Replace("%left%", left.ToString())
								 .Replace("%right%", right.ToString())
								 .Replace("%bottom%", bottom.ToString())
								 .Replace("%top%", top.ToString())
								 .Replace("%prefix%", (string)Config["Prefix"])
								 .Replace("%postfix%", (string)Config["Postfix"]);

			// --- for timed notifications

			List<object> ti = (List<object>)Config["TimedInfo"];
			int size = ti.Count;

			for(int i = 0; i < size; i++)
			{
				string infoString = (string)ti[i];

				if(infoString.Length > 0)
					tiList.Add(GetTimedInfo(infoString));
			}

			double info_left = right + 0.002;

			infoJson = infoJson.Replace("%background%", (string)Config["BackgroundColor"])
							   .Replace("%color%", (string)Config["TextColor"])
							   .Replace("%size%", Config["FontSize"].ToString())
							   .Replace("%bottom%", bottom.ToString())
							   .Replace("%top%", top.ToString())
							   .Replace("%info_left%", info_left.ToString())
							   .Replace("%info_right%", defaultInfoSize);
			// ---

			UpdateTime();

			updateTimer = timer.Repeat((int)Config["UpdateTimeInSeconds"], 0, () => UpdateTime());
		}

		void Unload()
		{
			SaveData();
			DestroyGUI();
			DestroyInfo();
		}

		[ChatCommand("clock")]
		void cmdChat(BasePlayer player, string command, string[] args)
		{
			if(args.Length == 1)
			{
				if(args[0] == "server" || args[0] == "s")
				{
					if((bool)Config["PreventChangingTime"])
						PrintToChat(player, (string)Config["Messages", "PreventChangeEnabled"]);
					else
						if(data.Players.Count > 0)
						{
							foreach(Player p in data.Players)
							{
								if(p.userID == player.userID)
								{
									if(GetOption(p.options, isServerTime))
									{
										p.options &= ~isServerTime;
										PrintToChat(player, (string)Config["Messages", "STDisabled"]);
									}
									else
									{
										p.options += isServerTime;
										PrintToChat(player, (string)Config["Messages", "STEnabled"]);
									}

									break;
								}
							}
						}
						else
						{
							data.Players.Add(new Player(player.userID, isClockEnabled | isServerTime));
							PrintToChat(player, (string)Config["Messages", "STEnabled"]);
						}
				}
				else
				{
					PrintToChat(player, (string)Config["Messages", "Help"]);
				}
			}
			else
			{
				bool found = false;

				if(data.Players.Count > 0)
				{
					foreach(Player p in data.Players)
					{
						if(p.userID == player.userID)
						{
							found = true;

							if(GetOption(p.options, isClockEnabled))
							{
								p.options &= ~isClockEnabled;
								DestroyGUI();
								PrintToChat(player, (string)Config["Messages", "Disabled"]);
							}
							else
							{
								p.options += isClockEnabled;
								AddGUI();
								PrintToChat(player, (string)Config["Messages", "Enabled"]);
							}

							break;
						}
						else
						{
							found = false;
						}
					}

					if(!found)
					{
						data.Players.Add(new Player(player.userID, 0));
						DestroyGUI();
						PrintToChat(player, (string)Config["Messages", "Disabled"]);
					}
				}
				else
				{
					data.Players.Add(new Player(player.userID, 0));
					PrintToChat(player, (string)Config["Messages", "Disabled"]);
				}
			}
		}

		void AddGUI()
		{
			if(data.Players.Count > 0)
			{
				int size = BasePlayer.activePlayerList.Count;
				for(int i = 0; i < size; i++)
				{
					BasePlayer bp = BasePlayer.activePlayerList[i];
					bool found = false;

					foreach(Player p in data.Players)
					{
						if(p.userID == bp.userID)
						{
							found = true;

							if(GetOption(p.options, isClockEnabled))
							{
								if(!((bool)Config["PreventChangingTime"]))
									if(GetOption(p.options, isServerTime))
										dt = serverTime;
									else
										dt = gameTime;

								ShowTime();

								CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(bp.net.connection),	null, "AddUI", new Facepunch.ObjectList(clockJson.Replace("%time%", time)));
							}

							break;
						}
						else
						{
							found = false;
						}
					}

					if(!found)
					{
						if(!((bool)Config["PreventChangingTime"]))
							dt = gameTime;
						ShowTime();
						CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(bp.net.connection),	null, "AddUI", new Facepunch.ObjectList(clockJson.Replace("%time%", time)));
					}
				}
			}
			else
			{
				int size = BasePlayer.activePlayerList.Count;
				for(int i = 0; i < size; i++)
				{
					BasePlayer bp = BasePlayer.activePlayerList[i];
					if(!((bool)Config["PreventChangingTime"]))
						dt = gameTime;
					ShowTime();
					CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(bp.net.connection),	null, "AddUI", new Facepunch.ObjectList(clockJson.Replace("%time%", time)));
				}
			}
		}

		private void UpdateTime()
		{
			gameTime = sky.Cycle.DateTime;
			serverTime = DateTime.Now;

			if((bool)Config["PreventChangingTime"])
				if((bool)Config["ServerTime"])
					dt = serverTime;
				else
					dt = gameTime;

			DestroyGUI();
			AddGUI();
			UpdateInfo();
		}

		private void DestroyGUI()
		{
			int size = BasePlayer.activePlayerList.Count;
			for(int i = 0; i < size; i++)
			{
				BasePlayer bp = BasePlayer.activePlayerList[i];
				CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(bp.net.connection), null, "DestroyUI", new Facepunch.ObjectList("Clock"));
			}
		}

		private void ShowTime()
		{
			if((int)Config["TimeFormat"] == 24)
				if((bool)Config["ShowSeconds"])
					time = dt.ToString("HH:mm:ss");
				else
					time = dt.ToString("HH:mm");
			else
				if((bool)Config["ShowSeconds"])
					time = dt.ToString("h:mm:ss tt");
				else
					time = dt.ToString("h:mm tt");
		}

		void ShowInfo(string text, string iSize)
		{
			int size = BasePlayer.activePlayerList.Count;
			for(int i = 0; i < size; i++)
				CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(BasePlayer.activePlayerList[i].net.connection),	null,  "AddUI", new Facepunch.ObjectList(infoJson.Replace("%info%", text).Replace("%info_right%", iSize)));
		}

		void UpdateInfo()
		{
			if(tiList.Count > 0)
			{
				DateTime g = DateTime.Parse(gameTime.ToString("HH:mm"));
				DateTime s = DateTime.Parse(serverTime.ToString("HH:mm"));

				if(currentTI == null)
				{
					for(int i = 0; i < tiList.Count; i++)
					{
						if(!tiList[i].serverTime)
						{
							if(g.Ticks > tiList[i].startTime.Ticks && g.Ticks < tiList[i].endTime.Ticks)
							{
								currentTI = tiList[i];
								ShowInfo(tiList[i].text, tiList[i].size);
							}
						}
						else
						{
							if(s.Ticks > tiList[i].startTime.Ticks && s.Ticks < tiList[i].endTime.Ticks)
							{
								currentTI = tiList[i];
								ShowInfo(tiList[i].text, tiList[i].size);
							}
						}
					}
				}
				else
				{
					if(!currentTI.serverTime)
					{
						if(g.Ticks > currentTI.endTime.Ticks)
						{
							currentTI = null;
							DestroyInfo();
						}
					}
					else
					{
						if(s.Ticks > currentTI.endTime.Ticks)
						{
							currentTI = null;
							DestroyInfo();
						}
					}
				}
			}
		}

		void DestroyInfo()
		{
			int size = BasePlayer.activePlayerList.Count;
			for(int i = 0; i < size; i++)
				CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo(BasePlayer.activePlayerList[i].net.connection), null, "DestroyUI", new Facepunch.ObjectList("ClockInfo"));
		}

		// -------------------- UTILS --------------------

		void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject(databaseName, data);
		}

		bool GetOption(int options, int option)
		{
			if((options & option) != 0)
				return true;
			else
				return false;
		}

		void SendHelpText(BasePlayer player)
		{
			PrintToChat(player, (string)Config["Messages", "Help"]);
		}

		private enum TIStates { Init, StartBracket, StartTime, FirstColon, SecondColon, Hyphen, EndTime, AfterBracket, Text, Size, SizeAfterDot };

		private TimedInfo GetTimedInfo(string source)
		{
			source = source.TrimStart();
			source = source.TrimEnd();

			TIStates currentState = TIStates.Init;

			string startTime = "", endTime = "", text = "", nSize = "";
			bool st = false; // Server time

			int size = source.Length;

			for(int i = 0; i < size; i++)
			{				
				switch(currentState)
				{
					case TIStates.Init:
						{
							if (source[i] == '[')
							{
								currentState = TIStates.StartTime;
							}
							else if(source[i] == 's' || source[i] == 'S')
							{
								st = true;
								i++;
								currentState = TIStates.StartTime;
							}
							break;
						}
					case TIStates.StartTime:
						{
							if (Char.IsDigit(source[i]))
							{
								startTime += source[i];
							}
							else if (source[i] == ':')
							{
								startTime += source[i];
								currentState = TIStates.FirstColon;
							}
							break;
						}
					case TIStates.FirstColon:
						{
							if (Char.IsDigit(source[i]))
							{
								startTime += source[i];
							}
							else if(source[i] == '-')
							{
								i--;
								currentState = TIStates.Hyphen;
							}
							break;
						}
					case TIStates.Hyphen:
						{
							if (Char.IsDigit(source[i]))
							{
								i--;
								currentState = TIStates.EndTime;
							}
							break;
						}
					case TIStates.EndTime:
						{
							if (Char.IsDigit(source[i]))
							{
								endTime += source[i];
							}
							else if (source[i] == ':')
							{
								endTime += source[i];
								currentState = TIStates.SecondColon;
							}
							break;
						}
					case TIStates.SecondColon:
						{
							if (Char.IsDigit(source[i]))
								endTime += source[i];
							else if(source[i] == ']')
								currentState = TIStates.AfterBracket;
							else if(source[i] == '-')
								currentState = TIStates.Size;
							break;
						}
					case TIStates.Size:
						{
							if(Char.IsDigit(source[i]))
							{
								nSize += source[i];
							}
							else if(source[i] == '.')
							{
								nSize += '.';
								currentState = TIStates.SizeAfterDot;
							}
							break;
						}
					case TIStates.SizeAfterDot:
						{
							if(Char.IsDigit(source[i]))
								nSize += source[i];
							else if(source[i] == ']')
								currentState = TIStates.AfterBracket;
							break;
						}
					case TIStates.AfterBracket:
						{
							if(source[i] != ' ')
								text += source[i];
							currentState = TIStates.Text;
							break;
						}
					case TIStates.Text:
						{
							text += source[i];
							break;
						}
				}
			}

			if(nSize.Length == 0)
				nSize = defaultInfoSize;

			return new TimedInfo(DateTime.Parse(startTime), DateTime.Parse(endTime), text, st, nSize);
		}

		// -------------------- DEFAULT CONFIG --------------------

		void CheckCreateConfig()
		{
			if(Config["UpdateTimeInSeconds"] == null)
				Config["UpdateTimeInSeconds"] = 2;

			if(Config["ShowSeconds"] == null)
				Config["ShowSeconds"] = false;

			if(Config["BackgroundColor"] == null)
				Config["BackgroundColor"] = "0.1 0.1 0.1 0.3";

			if(Config["TextColor"] == null)
				Config["TextColor"] = "1 1 1 0.3";

			if(Config["FontSize"] == null)
				Config["FontSize"] = 14;

			if(Config["Position", "Left"] == null)
				Config["Position", "Left"] = 0.01;

			if(Config["Position", "Bottom"] == null)
				Config["Position", "Bottom"] = 0.015;

			if(Config["Size", "Width"] == null)
				Config["Size", "Width"] = 0.05;

			if(Config["Size", "Height"] == null)
				Config["Size", "Height"] = 0.03;

			if(Config["ServerTime"] == null)
				Config["ServerTime"] = false;

			if(Config["PreventChangingTime"] == null)
				Config["PreventChangingTime"] = false;

			if(Config["TimeFormat"] == null)
				Config["TimeFormat"] = 24;

			if(Config["Prefix"] == null)
				Config["Prefix"] = "";

			if(Config["Postfix"] == null)
				Config["Postfix"] = "";

			if(Config["TimedInfo"] == null)
				Config["TimedInfo"] = new string[1] {""};

			if(Config["Messages", "Enabled"] == null)
				Config["Messages", "Enabled"] = "You have enabled clock";

			if(Config["Messages", "Disabled"] == null)
				Config["Messages", "Disabled"] = "You have disabled clock";

			if(Config["Messages", "STEnabled"] == null)
				Config["Messages", "STEnabled"] = "Now your clock shows server time";

			if(Config["Messages", "STDisabled"] == null)
				Config["Messages", "STDisabled"] = "Now your clock shows ingame time";

			if(Config["Messages", "Help"] == null)
				Config["Messages", "Help"] = "Clock:\n/clock - toggle clock\n/clock server - toggle server/ingame time";

			if(Config["Messages", "PreventChangeEnabled"] == null)
				Config["Messages", "PreventChangeEnabled"] = "You can't choose between server or ingame time";

			SaveConfig();
		}
	}
}

// --- End of file: IngameClockGUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DiscordClans.cs ---
// --- Original Local Path: DiscordClans.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Messages.Embeds;
using Oxide.Ext.Discord.Entities.Permissions;
using Oxide.Ext.Discord.Logging;
using System;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("DiscordClans", "k1lly0u", "0.1.2"), Description("Log ClansReborn events to Discord")]
    class DiscordClans : RustPlugin
    {
        #region Fields
        [DiscordClient]
        private DiscordClient Client;

        private DiscordGuild Guild;

        private bool ConnectionExists { get; set; } = false;
        #endregion

        #region Oxide Hooks     
        private void Unload()
        {
            if (Client != null)
            {
                Client.Disconnect();
                Client = null;
            }

            Guild = null;
        }
        #endregion

        #region Discord Hooks       
        private void OnDiscordClientCreated()
        {
            if (string.IsNullOrEmpty(configData.Discord.APIKey))
            {
                PrintError("No API token set in config... Unable to continue!");
                return;
            }

            if (string.IsNullOrEmpty(configData.Discord.BotID))
            {
                PrintError("No bot client ID set in config... Unable to continue!");
                return;
            }

            Puts("Establishing connection to your Discord server...");

            DiscordSettings settings = new DiscordSettings();
            settings.ApiToken = configData.Discord.APIKey;
            settings.LogLevel = configData.Discord.LogLevel;
            settings.Intents = GatewayIntents.Guilds;
           
            Client.Connect(settings);
        }

        private void OnDiscordGatewayReady(GatewayReadyEvent ready) 
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Failed to find your bot in any guilds. Unable to continue...");
                return;
            }

            Guild = ready.Guilds.Values.FirstOrDefault();

            if (Guild == null)
            {
                PrintError("Failed to connect to guild. Unable to continue...");
                return;
            }

            Puts($"Connection to {Guild.Name} established! DiscordClans is now active");
            ConnectionExists = true;
        }
        #endregion
       
        #region API
        private enum MessageType { Create, Invite, InviteReject, InviteWithdrawn, Join, Leave, Kick, Promote, Demote, Disband, AllianceInvite, AllianceInviteReject, AllianceInviteWithdrawn, AllianceAccept, AllianceWithdrawn, TeamChat, ClanChat, AllyChat }

        private void LogMessage(string message, int messageType)
        {
            if (!ConnectionExists)
                return;

            ConfigData.LogSettings logSettings;

            if (!configData.Log.TryGetValue((MessageType)messageType, out logSettings) || !logSettings.Enabled)
                return;

            if (string.IsNullOrEmpty(logSettings.Channel))
                return;

            DiscordChannel channel = Guild.GetChannel(logSettings.Channel);
            if (channel == null)
                return;

            DiscordEmbed embed = new DiscordEmbed
            {
                Title = $"Clan Log - {(MessageType)messageType}",
                Description = message,
                Color = new DiscordColor(logSettings.Color),
                Footer = new EmbedFooter { Text = $"{DateTime.Now.ToLongDateString()}, {DateTime.Now.ToLongTimeString()}" }
            };

            channel.CreateMessage(Client, embed);            
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Discord Settings")]
            public DiscordSettings Discord { get; set; }

            [JsonProperty(PropertyName = "Log Settings")]
            public Hash<MessageType, LogSettings> Log { get; set; }

            public class DiscordSettings
            {
                [JsonProperty(PropertyName = "Bot Token")]
                public string APIKey { get; set; }

                [JsonProperty(PropertyName = "Bot Client ID")]
                public string BotID { get; set; }

                [JsonConverter(typeof(StringEnumConverter))]
                [JsonProperty(PropertyName = "Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
                public DiscordLogLevel LogLevel { get; set; }
            }

            public class LogSettings
            {
                [JsonProperty(PropertyName = "Logs enabled for this message type")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Log Channel Name")]
                public string Channel { get; set; }

                [JsonProperty(PropertyName = "Embed Color (hex)")]
                public string Color { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Discord = new ConfigData.DiscordSettings
                {
                    APIKey = string.Empty,
                    BotID = string.Empty,
                    LogLevel = DiscordLogLevel.Info
                },
                Log = new Hash<MessageType, ConfigData.LogSettings>
                {
                    [MessageType.Create] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#e91e63",
                        Enabled = true
                    },
                    [MessageType.Invite] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#9b59b6",
                        Enabled = true
                    },
                    [MessageType.InviteReject] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#71368a",
                        Enabled = true
                    },
                    [MessageType.InviteWithdrawn] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#71368a",
                        Enabled = true
                    },
                    [MessageType.Join] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#3498db",
                        Enabled = true
                    },
                    [MessageType.Leave] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#206694",
                        Enabled = true
                    },
                    [MessageType.Kick] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#992d22",
                        Enabled = true
                    },
                    [MessageType.Promote] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#f1c40f",
                        Enabled = true
                    },
                    [MessageType.Demote] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#c27c0e",
                        Enabled = true
                    },
                    [MessageType.Disband] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#ad1457",
                        Enabled = true
                    },
                    [MessageType.AllianceInvite] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#95a5a6",
                        Enabled = true
                    },
                    [MessageType.AllianceInviteReject] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#95a5a6",
                        Enabled = true
                    },
                    [MessageType.AllianceInviteWithdrawn] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#95a5a6",
                        Enabled = true
                    },
                    [MessageType.AllianceAccept] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#95a5a6",
                        Enabled = true
                    },
                    [MessageType.AllianceWithdrawn] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#95a5a6",
                        Enabled = true
                    },
                    [MessageType.TeamChat] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#607d8b",
                        Enabled = true
                    },
                    [MessageType.ClanChat] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#607d8b",
                        Enabled = true
                    },
                    [MessageType.AllyChat] = new ConfigData.LogSettings
                    {
                        Channel = "clanlog",
                        Color = "#607d8b",
                        Enabled = true
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 1, 1))
            {
                configData.Log[MessageType.TeamChat] = baseConfig.Log[MessageType.TeamChat];
                configData.Log[MessageType.ClanChat] = baseConfig.Log[MessageType.ClanChat];
                configData.Log[MessageType.AllyChat] = baseConfig.Log[MessageType.AllyChat];
            }

            if (configData.Version < new VersionNumber(0, 1, 2))
            {
                configData.Discord.LogLevel = DiscordLogLevel.Info;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion
    }
}


// --- End of file: DiscordClans.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoDistanceLoot.cs ---
// --- Original Local Path: NoDistanceLoot.cs ---

using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using UnityEngine;
using System.Text;


namespace Oxide.Plugins
{
    [Info("NoDistanceLoot", "4seti [Lunatiq] for Rust Planet", "0.1.1", ResourceId = 000)]
    public class NoDistanceLoot : RustPlugin
    {

        #region Utility Methods

        private void Log(string message)
        {
            Puts("{0}: {1}", Title, message);
        }

        private void Warn(string message)
        {
            PrintWarning("{0}: {1}", Title, message);
        }

        private void Error(string message)
        {
            PrintError("{0}: {1}", Title, message);
        }

        #endregion


        void Loaded()
        {
            Log("Loaded");
        }

        Dictionary<BasePlayer, string> looters = new Dictionary<BasePlayer, string>();

        [HookMethod("OnPlayerLoot")]
        void OnPlayerLoot(PlayerLoot lootInventory, UnityEngine.Object entry)
        {
            BasePlayer looter = lootInventory.GetComponent("BasePlayer") as BasePlayer;
            if (looters.ContainsKey(looter))            
                looters.Remove(looter);
            
            if (entry is BasePlayer)
            {
                BasePlayer target = entry as BasePlayer;              
                if (target.IsAlive() && !target.IsSleeping())
                {
                    looter.ChatMessage("Finish him before loot!");
                    looter.SendConsoleCommand("inventory.endloot");
                    looter.UpdateNetworkGroup();
                    looter.SendFullSnapshot();
                }
                else if (target.IsSleeping())
                {
                    looters.Add(looter, target.userID.ToString());
                }
            }

        }
        [HookMethod("OnPlayerSleepEnded")]
        void OnPlayerSleepEnded(BasePlayer player)
        {
			if (player != null)
			{
				if (looters.ContainsValue(player.userID.ToString()))
				{
					var looter = looters.FirstOrDefault(x => x.Value == player.userID.ToString()).Key;		
					if(looter.IsConnected()){					
						looter.SendConsoleCommand("inventory.endloot");
						looter.UpdateNetworkGroup();
						looter.SendFullSnapshot();
					}					
						looters.Remove(looter);					
				}
			}
        }
    }
}

// --- End of file: NoDistanceLoot.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ShowHealth.cs ---
// --- Original Local Path: ShowHealth.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("ShowHealth", "Troubled", "0.2.1")]
    [Description("Check any player's health")]

    class ShowHealth : RustPlugin
    {
        void Init()
        {
            LoadDefaultMessages();
            permission.RegisterPermission("showhealth.use", this);
        }

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"PlayerHealth", "{0} has {1} health"},
                {"PlayerNotFound", "Player not found"},
                {"WrongSyntax", "Check your syntax. Use /hp playername"},
                {"NotAllowed", "You are not allowed to use this command" }
            }, this);
        }

        [ChatCommand("hp")]
        void Health(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "showhealth.use")) return;

            if (args.Length < 1 || args.Length > 1)
            {
                PrintToChat(player, Lang("WrongSyntax"));
                return;
            }

            var target = rust.FindPlayer(args[0]);
            PrintToChat(player, target == null
                ? Lang("PlayerNotFound")
                : string.Format(Lang("PlayerHealth"), target.displayName, Math.Round(target.health)));
        }

        string Lang(string key, string userId = null) => lang.GetMessage(key, this, userId);

        bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
            PrintToChat(player, Lang("NotAllowed"));
            return false;
        }
    }
}


// --- End of file: ShowHealth.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoTakeoff.cs ---
// --- Original Local Path: AutoTakeoff.cs ---

using System.Collections;
using System.Collections.Generic;

using UnityEngine;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Auto Takeoff", "0x89A", "1.1.1")]
    [Description("Allows smooth takeoff with helicopters")]
    class AutoTakeoff : RustPlugin
    {
        #region -Fields-

        private const string _canUse = "autotakeoff.use";

        private readonly Dictionary<Minicopter, bool> _isTakingOff = new Dictionary<Minicopter, bool>();

        #endregion

        void Init()
        {
            permission.RegisterPermission(_canUse, this);
        }

        #region -Chat Command-

        [ChatCommand("takeoff")]
        private void TakeOffCommand(BasePlayer player)
        {
            if (player == null)
            {
                return;
            }

            if (!permission.UserHasPermission(player.UserIDString, _canUse))
            {
                player.ChatMessage(GetMessage("NoPermission", player.UserIDString));
                return;
            }

            Minicopter helicopter = player.GetMountedVehicle() as Minicopter;
            if (helicopter == null)
            {
                player.ChatMessage(GetMessage("NotMounted", player.UserIDString));
                return;
            }

            bool isTakingOff;
            if (_isTakingOff.TryGetValue(helicopter, out isTakingOff) && isTakingOff)
            {
                player.ChatMessage(GetMessage("AlreadyTakingOff", player.UserIDString));
                return;
            }

            string vehiclePrefab = helicopter.ShortPrefabName;

            if (!_config.scrapheliCanTakeoff && vehiclePrefab == "scraptransporthelicopter" || !_config.minicopterCanTakeoff && vehiclePrefab == "minicopter.entity")
            {
                player.ChatMessage(GetMessage("NotAllowed", player.UserIDString));
                return;
            }

            DoTakeOff(player, helicopter);
        }

        private void DoTakeOff(BasePlayer player, Minicopter helicopter)
        {
            if (helicopter.IsEngineOn() && helicopter.isMobile)
            {
                //raycast to check if on ground
                Ray ray = new Ray(helicopter.transform.position, -Vector2.up);

                if (Physics.Raycast(ray, 0.5f))
                {
                    if (_config.takeOffMethodType)
                    {
                        helicopter.StartCoroutine(LerpMethod(helicopter));
                        return;
                    }

                    PushMethod(helicopter);
                }
                else
                {
                    player.ChatMessage(GetMessage("NotOnGround", player.UserIDString));
                }

                return;
            }
            
            player.ChatMessage(GetMessage("NotFlying", player.UserIDString));
        }

        #endregion

        #region -Methods-

        private IEnumerator LerpMethod(Minicopter helicopter)
        {
            _isTakingOff[helicopter] = true;
            
            Vector3 helicopterPosition = helicopter.transform.position;
            Vector3 endPos = helicopterPosition + Vector3.up * _config.distanceMoved;

            float distance = Vector3.Distance(helicopterPosition, endPos);
				
            float speed = helicopter.ShortPrefabName == "minicopter.entity" ? _config.minicopterSpeed : _config.scrapHelicopterSpeed;

            float startTime = Time.time;

            while (helicopter.AnyMounted() && helicopter.IsEngineOn())
            {
                float distCovered = (Time.time - startTime) * speed;

                float fractionOfJourney = distCovered / distance;

                helicopter.transform.position = Vector3.Lerp(helicopter.transform.position, endPos, fractionOfJourney);

                if (helicopter.CenterPoint().y + 1 >= endPos.y - 2)
                {
                    _isTakingOff[helicopter] = false;
                    yield break;
                }

                yield return CoroutineEx.waitForFixedUpdate;
            }
        }

        private void PushMethod(Minicopter helicopter)
        {
            Rigidbody rb;
            if (!helicopter.TryGetComponent(out rb))
            {
                return;
            }

            float force = helicopter.ShortPrefabName == "minicopter.entity" ? _config.minicopterPushForce : _config.scrapHelicopterPushForce;
            rb.AddForce(Vector3.up * force, ForceMode.Acceleration);
        }
        
        #endregion
        
        #region -Localization-

        private string GetMessage(string key, string userid) => lang.GetMessage(key, this, userid);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You do not have permission to use this command",
                ["NotMounted"] = "You are not in a helicopter",
                ["NotOnGround"] = "You are too far from the ground",
                ["NotFlying"] = "The helicopter is not flying",
                ["AlreadyTakingOff"] = "This helicopter is already taking off",
                ["DefaultConfig"] = "Generating new config"
            }
            , this);
        }

        #endregion

        #region -Configuration-

        private Configuration _config;
        class Configuration
        {
            [JsonProperty(PropertyName = "Take off method type")]
            public bool takeOffMethodType = true;

            [JsonProperty(PropertyName = "Helicopter move distance")]
            public float distanceMoved = 10f;

            [JsonProperty(PropertyName = "Minicopter can auto takeoff")]
            public bool minicopterCanTakeoff = true;

            [JsonProperty(PropertyName = "Minicopter move speed")]
            public float minicopterSpeed = 0.025f;

            [JsonProperty(PropertyName = "Minicopter push force")]
            public float minicopterPushForce = 50;

            [JsonProperty(PropertyName = "Scrap Helicopter can auto takeoff")]
            public bool scrapheliCanTakeoff = true;

            [JsonProperty(PropertyName = "Scrap helicopter move speed")]
            public float scrapHelicopterSpeed = 0.0075f;

            [JsonProperty(PropertyName = "Scrap helicopter push force")]
            public float scrapHelicopterPushForce = 100;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new System.Exception();
                SaveConfig();
            }
            catch
            {
                PrintWarning("Error with config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion
    }
}


// --- End of file: AutoTakeoff.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Clans (10).cs ---
// --- Original Local Path: Clans (10).cs ---

﻿using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Clans", "OxideBro - RustPlugin.ru", "1.0.3", ResourceId = 14)]
    public class Clans : RustPlugin
    {
        bool Changed;
        bool Initialized;
        internal static Clans cc = null;
        bool newSaveDetected = false;
        List<ulong> manuallyEnabledBy = new List<ulong>();
        HashSet<ulong> bypass = new HashSet<ulong>();
        Dictionary<string, DateTime> notificationTimes = new Dictionary<string, DateTime>();
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;
        Library lib;
        public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
        public Dictionary<string, string> clansSearch = new Dictionary<string, string>();
        List<string> purgedClans = new List<string>();
        Dictionary<string, string> originalNames = new Dictionary<string, string>();
        Dictionary<string, List<string>> pendingPlayerInvites = new Dictionary<string, List<string>>();
        Regex tagReExt;
        Dictionary<string, Clan> clanCache = new Dictionary<string, Clan>();
        List<object> filterDefaults()
        {
            var dp = new List<object>();
            dp.Add("admin");
            dp.Add("mod");
            dp.Add("owner");
            return dp;
        }

        private void SaveConf()
        {
            if (Author != r("BkvqrOeb - EhfgCyhtva.eh"))
                Author = r("Cyhtva nhgube BkvqrOeb - EhfgCyhtva.eh");

        }
        private static string r(string i)
        {
            return !string.IsNullOrEmpty(i) ? new string(i.Select(x => x >= 'a' && x <= 'z' ? (char)((x - 'a' + 13) % 26 + 'a') : x >= 'A' && x <= 'Z' ? (char)((x - 'A' + 13) % 26 + 'A') : x).ToArray()) : i;
        }

        Dictionary<string, object> rewardsDefaults()
        {
            var dp = new Dictionary<string, object>()
            {
                {"wood", 1 },
                { "stones", 1 },
                { "metal.ore", 1 },
                { "sulfur.ore", 1},
                { "hq.metal.ore", 1 },
                {"fat.animal", 1},
                {"cloth", 1},
                {"leather", 1},
                {"scrap", 1},
                {"gears", 1},
                {"techparts", 1},
                {"metalpipe", 1},
            };
            return dp;
        }


        Dictionary<string, object> rewardsTranslateDefault()
        {
            var dp = new Dictionary<string, object>()
            {
                {"wood", "ДЕРЕВО"},
                { "stones", "КАМЕНЬ" },
                { "metal.ore", "МЕТАЛ" },
                { "sulfur.ore", "СЕРА"},
                { "hq.metal.ore", "МВК" },
                {"fat.animal", "ЖИР"},
                {"cloth", "ТКАНЬ"},
                {"leather", "КОЖА"},
                {"scrap", "СКРАП"},
                {"gears", "ШЕСТЕРНИ"},
                {"techparts", "МИКРОСХЕМЫ"},
                {"metalpipe", "ТРУБЫ"},
            };
            return dp;
        }
        public int limitMembers;
        int limitModerators;
        public int limitAlliances;
        int tagLengthMin;
        int tagLengthMax;
        int inviteValidDays;
        int friendlyFireNotifyTimeout;
        string allowedSpecialChars;
        public bool enableFFOPtion;
        bool enableAllyFFOPtion;
        bool enableWordFilter;
        bool enableClanTagging;
        public bool enableClanAllies;
        bool forceAllyFFNoDeactivate;
        bool forceClanFFNoDeactivate;
        bool enableWhoIsOnlineMsg;
        bool enableComesOnlineMsg;
        int authLevelRename;
        int authLevelDelete;
        int authLevelInvite;
        int authLevelKick;
        int authLevelPromoteDemote;
        int authLevelClanInfo;
        bool purgeOldClans;
        int notUpdatedSinceDays;
        bool listPurgedClans;
        bool wipeClansOnNewSave;
        bool useProtostorageClandata;
        string consoleName;
        string broadcastPrefix;
        string broadcastPrefixAlly;
        string broadcastPrefixColor;
        string broadcastPrefixFormat;
        string broadcastMessageColor;
        string colorCmdUsage;
        string colorTextMsg;
        string colorClanNamesOverview;
        string colorClanFFOff;
        string colorClanFFOn;
        string pluginPrefix;
        string pluginPrefixColor;
        string pluginPrefixREBORNColor;
        bool pluginPrefixREBORNShow;
        string pluginPrefixFormat;
        string clanServerColor;
        string clanOwnerColor;
        string clanCouncilColor;
        string clanModeratorColor;
        string clanMemberColor;
        bool setHomeOwner = false;
        bool setHomeModerator = false;
        bool setHomeMember = false;
        string chatCommandClan;
        string chatCommandFF;
        string chatCommandAllyChat;
        string chatCommandClanChat;
        string chatCommandClanInfo;
        string subCommandClanHelp;
        string subCommandClanAlly;
        bool usePermGroups;
        string permGroupPrefix;
        bool usePermToCreateClan;
        string permissionToCreateClan;
        bool usePermToJoinClan;
        string permissionToJoinClan;
        bool addClanMembersAsIOFriends;
        string clanTagColorBetterChat;
        int clanTagSizeBetterChat;
        string clanTagOpening;
        string clanTagClosing;
        bool clanChatDenyOnMuted;
        List<string> activeRadarUsers = new List<string>();
        Dictionary<string, List<BasePlayer>> clanRadarMemberobjects = new Dictionary<string, List<BasePlayer>>();
        static Vector3 sleeperHeight = new Vector3(0f, 1.0f, 0f);
        static Vector3 playerHeight = new Vector3(0f, 1.8f, 0f);
        bool enableClanRadar;
        string colorClanRadarOff;
        string colorClanRadarOn;
        float refreshTime;
        string nameColor;
        string sleeperNameColor;
        string distanceColor;
        static float minDistance;
        static float maxNamedistance;
        static float maxSleeperDistance;
        bool showSleepers;
        bool extendOnAllyMembers;
        bool enableAtLogin;
        int radarTextSize;
        string permissionClanRadarUse;
        bool usePermissionClanRadar;
        string chatCommandRadar;
        private bool forceNametagsOnTagging;
        public static bool useRelationshipManager;
        private bool teamUiWasDisabled;
        private bool useRankColorsPanel;
        private bool disableManageFunctions;
        private bool allowButtonLeave;
        private bool allowButtonKick;
        private bool allowDirectInvite;
        private bool allowPromoteLeader;

        List<object> wordFilter = new List<object>();

        Dictionary<string, object> RewardGather = new Dictionary<string, object>();
        Dictionary<string, object> RewardTranslate = new Dictionary<string, object>();


        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }


        int PointsOfDeath = 1;
        int PointsOfKilled = 1;
        int PointsOfKilledHeli = 1;
		int PointsOfKilledTank = 1;
        int PointsOfSuicide = 1;
        int PointsOfBarrel = 1;
		int PointsOfRocket = 1;



        int PointsOfGatherSulfur = 1;
        int PointsOfGatherMetalOre = 1;
        int PointsOfGatherStone = 1;
        int PointsOfGatherWood = 1;
        int PointsOfGatherHQM = 1;

        void LoadVariables()
        {
            wordFilter = (List<object>)GetConfig("Фильтр", "Слова", filterDefaults());
            RewardGather = (Dictionary<string, object>)GetConfig("ТОП", "Список предметов и очков за их добычу [Shortname: количество очков]", rewardsDefaults());


            RewardTranslate = (Dictionary<string, object>)GetConfig("ТОП", "Перевод итемов на русский [Shortname: Русский перевод]", rewardsTranslateDefault());

            PointsOfDeath = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков убирает за смерть", 1));
            PointsOfKilled = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за убийство игрока", 1));
            PointsOfKilledHeli = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за сбитие вертолёта", 1));
			PointsOfKilledTank = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за сбитие танка", 1));
            PointsOfSuicide = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков забираем за суицид", 1));
            PointsOfGatherSulfur = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу серы (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherMetalOre = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу металической руды (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherStone = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу камня (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherWood = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу дерева (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherHQM = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу МВК (за разбитый камень - то есть за последний удар)", 1));
            PointsOfBarrel = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за разрушение бочки (за разбитый камень - то есть за последний удар)", 1));
			PointsOfRocket = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков выпущенную ракету)", 1));


            limitMembers = Convert.ToInt32(GetConfig("Лимиты", "Лимит участников клана", 8));
            limitModerators = Convert.ToInt32(GetConfig("Лимиты", "Лимит модераторов", 2));
            limitAlliances = Convert.ToInt32(GetConfig("Лимиты", "Лимит альянса", 2));
            tagLengthMin = Convert.ToInt32(GetConfig("Лимиты", "Лимит размера тега клана от", 2));
            tagLengthMax = Convert.ToInt32(GetConfig("Лимиты", "Лимит размера тега клана до", 10));
            inviteValidDays = Convert.ToInt32(GetConfig("Лимиты", "Длительность активного приглашения в днях", 1));
            friendlyFireNotifyTimeout = Convert.ToInt32(GetConfig("Лимиты", "Таймаут FF", 5));
            allowedSpecialChars = Convert.ToString(GetConfig("Лимиты", "Разрешенные специальные символы в тег клана", "!²³"));
            enableFFOPtion = Convert.ToBoolean(GetConfig("Настройки", "Включить FF длля кланов", true));
            enableAllyFFOPtion = Convert.ToBoolean(GetConfig("Настройки", "Включить FF для альянса", true));
            forceAllyFFNoDeactivate = Convert.ToBoolean(GetConfig("Настройки", "Запретить отключать FF для альянса", true));
            forceClanFFNoDeactivate = Convert.ToBoolean(GetConfig("Настройки", "Запретить отключать FF для клана", false));
            enableWordFilter = Convert.ToBoolean(GetConfig("Настройки", "Включить фльтр слов", true));
            enableClanTagging = Convert.ToBoolean(GetConfig("Настройки", "Включить клан ТЭГ", true));
            enableClanAllies = Convert.ToBoolean(GetConfig("Настройки", "Включить альянсы", false));
            enableWhoIsOnlineMsg = Convert.ToBoolean(GetConfig("Настройки", "Включить сообщение об онлайне клана", true));
            enableComesOnlineMsg = Convert.ToBoolean(GetConfig("Настройки", "Включить сообщение об входе игрока сокланам", true));
            useProtostorageClandata = Convert.ToBoolean(GetConfig("Storage", "Использовать Proto хранилище данных клана (Дата)", false));
            authLevelRename = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Rename (Не трогать)", 1));
            authLevelDelete = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Delete (Не трогать)", 2));
            authLevelInvite = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Invite (Не трогать)", 1));
            authLevelKick = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Kick (Не трогать)", 2));
            authLevelPromoteDemote = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Promote Demote (Не трогать)", 1));
            authLevelClanInfo = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Clan Info (Не трогать)", 0));
            usePermGroups = Convert.ToBoolean(GetConfig("Настройки привилегий", "Использовать разрешения для групп?", false));
            permGroupPrefix = Convert.ToString(GetConfig("Настройки привилегий", "Префикс привилегий для групп", "clan_"));
            usePermToCreateClan = Convert.ToBoolean(GetConfig("Настройки привилегий", "Использовать привилегию для создания клана?", false));
            permissionToCreateClan = Convert.ToString(GetConfig("Настройки привилегий", "Привилегия для создания клана", "clans.cancreate"));
            usePermToJoinClan = Convert.ToBoolean(GetConfig("Permission", "Использовать привилегию для возможности вступления в клан?", false));
            permissionToJoinClan = Convert.ToString(GetConfig("Permission", "Привилегия на возможность вступления в клан", "clans.canjoin"));
            purgeOldClans = Convert.ToBoolean(GetConfig("Очистка", "Удаление старых кланов", false));
            notUpdatedSinceDays = Convert.ToInt32(GetConfig("Очистка", "Дни с каких клан не обновлялся на удаление", 14));
            listPurgedClans = Convert.ToBoolean(GetConfig("Очистка", "Включить список очищенных кланов", false));
            wipeClansOnNewSave = Convert.ToBoolean(GetConfig("Очистка", "Удалить кланы при вайпе?", false));
            consoleName = Convert.ToString(GetConfig("Оформление", "Консольное имя", "ServerOwner"));
            broadcastPrefix = Convert.ToString(GetConfig("Оформление", "Префикс", "(CLAN)"));
            broadcastPrefixAlly = Convert.ToString(GetConfig("Оформление", "Префикс альянса", "(ALLY)"));
            broadcastPrefixColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса", "#a1ff46"));
            broadcastPrefixFormat = Convert.ToString(GetConfig("Оформление", "Формат вывода сообщения", "<color={0}>{1}</color> "));
            broadcastMessageColor = Convert.ToString(GetConfig("Оформление", "Цвет вывода сообщения", "#e0e0e0"));
            colorCmdUsage = Convert.ToString(GetConfig("Оформление", "Цвет CMD", "#ffd479"));
            colorTextMsg = Convert.ToString(GetConfig("Оформление", "Цвет сообщения", "#e0e0e0"));
            colorClanNamesOverview = Convert.ToString(GetConfig("Оформление", "Цвет имена клана ", "#b2eece"));
            colorClanFFOff = Convert.ToString(GetConfig("Оформление", "Цвет сообщения об отключении FF", "#00DF00"));
            colorClanFFOn = Convert.ToString(GetConfig("Оформление", "Цвет сообщения об включении FF", "#DF0005"));
            pluginPrefix = Convert.ToString(GetConfig("Оформление", "Префикс", "CLANS"));
            pluginPrefixColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса в сообщении", "#FBA300"));
            pluginPrefixREBORNColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса в сообщении", "#ce422b"));
            pluginPrefixREBORNShow = Convert.ToBoolean(GetConfig("Оформление", "Включить префикс?", true));
            pluginPrefixFormat = Convert.ToString(GetConfig("Оформление", "Формат префикса REBORN в сообщении", "<color={0}>{1}</color>: "));
            clanServerColor = Convert.ToString(GetConfig("Оформление", "Цвет клана сервера в сообщении", "#ff3333"));
            clanOwnerColor = Convert.ToString(GetConfig("Оформление", "Цвец владельца клана в сообщении", "#a1ff46"));
            clanCouncilColor = Convert.ToString(GetConfig("Оформление", "Цвет команд помощи в сообщении", "#b573ff"));
            clanModeratorColor = Convert.ToString(GetConfig("Оформление", "Цвет модераторов клана в сообщении", "#74c6ff"));
            clanMemberColor = Convert.ToString(GetConfig("Оформление", "Цвет онлайна клана в сообщении", "#fcf5cb"));
            clanTagColorBetterChat = Convert.ToString(GetConfig("BetterChat", "Цвет тега кланов в чате", "#aaff55"));
            clanTagSizeBetterChat = Convert.ToInt32(GetConfig("BetterChat", "Размер тега кланов в чате", 15));
            clanTagOpening = Convert.ToString(GetConfig("BetterChat", "Скобка начало для тега", "["));
            clanTagClosing = Convert.ToString(GetConfig("BetterChat", "Скобка конец для тега", "]"));
            clanChatDenyOnMuted = Convert.ToBoolean(GetConfig("BetterChat", "Использовать полный мут для клана", false));
            chatCommandClan = Convert.ToString(GetConfig("Команды", "Открытие меню клана", "clan"));
            chatCommandFF = Convert.ToString(GetConfig("Команды", "Настройка FF для клана", "cff"));
            chatCommandAllyChat = Convert.ToString(GetConfig("Команды", "Отправка сообщения альянсу", "a"));
            chatCommandClanChat = Convert.ToString(GetConfig("Команды", "Отправка сообщения клану", "c"));
            chatCommandClanInfo = Convert.ToString(GetConfig("Команды", "Чатовая команда инфо клана для администраторов", "cinfo"));
            subCommandClanHelp = Convert.ToString(GetConfig("Команды", "Дополнительная подкоманда для вывода информации помощи", "help"));
            subCommandClanAlly = Convert.ToString(GetConfig("Команды", "Дополнительная подкоманда для вывода информации об альянсе", "ally"));
            addClanMembersAsIOFriends = Convert.ToBoolean(GetConfig("RustIO", "Добавить членов клана в качестве IO Friends", true));
            enableClanRadar = Convert.ToBoolean(GetConfig("Клановый радар", "Включить радар дял кланов", false));
            colorClanRadarOff = Convert.ToString(GetConfig("Клановый радар", "Цвет радара когда он отключен", "#A8A8A8"));
            colorClanRadarOn = Convert.ToString(GetConfig("Клановый радар", "Цвет радара когда он включен", "#00FB2C"));
            refreshTime = Convert.ToSingle(GetConfig("Клановый радар", "Время обновления", 3.0));
            nameColor = Convert.ToString(GetConfig("Клановый радар", "Цвет имен", "#008000"));
            sleeperNameColor = Convert.ToString(GetConfig("Клановый радар", "Цвет имен спящих", "#ff00ff"));
            distanceColor = Convert.ToString(GetConfig("Клановый радар", "Цвет дистанции", "#0000ff"));
            minDistance = Convert.ToSingle(GetConfig("Клановый радар", "Минимальная дистанция", 10.0));
            maxNamedistance = Convert.ToSingle(GetConfig("Клановый радар", "Максимальная дистанция для онлайн игроков", 200.0));
            maxSleeperDistance = Convert.ToSingle(GetConfig("Клановый радар", "Максимальная дистанция для спящих игроков", 50.0));
            showSleepers = Convert.ToBoolean(GetConfig("Клановый радар", "Показывать слиперов?", false));
            radarTextSize = Convert.ToInt32(GetConfig("Клановый радар", "Размер текста в радаре", 15));
            extendOnAllyMembers = Convert.ToBoolean(GetConfig("Клановый радар", "Включить отображение участников альянса на радаре", false));
            enableAtLogin = Convert.ToBoolean(GetConfig("Клановый радар", "Включить тех кто входит", false));
            permissionClanRadarUse = Convert.ToString(GetConfig("Клановый радар", "Привилегия на использование радара", "clans.radaruse"));
            usePermissionClanRadar = Convert.ToBoolean(GetConfig("Клановый радар", "Использовать привилегию на включение радара ?", false));
            chatCommandRadar = Convert.ToString(GetConfig("Клановый радар", "Чатовая команда открытия радара", "crd"));

            forceNametagsOnTagging = Convert.ToBoolean(GetConfig("Настройки", "forceNametagsOnTagging", false));

            useRelationshipManager = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Использовать внутриигровую систему друзей", false));
            useRankColorsPanel = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Использовать цвета рангов", true));
            disableManageFunctions = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Отключить управление тимой игрокам (Выход, инвайт и прочее)", false));
            allowButtonLeave = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить выходить из тимы", true));
            allowButtonKick = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить удалять из тимы", true));
            allowDirectInvite = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрешить приглашение в тиму", true));
            allowPromoteLeader = Convert.ToBoolean(GetConfig("Внутриигровая система друзей", "Разрушить продвижение лидера тимы", true));
            if (!Changed) return;

            SaveConf();
            SaveConfig();
            Changed = false;



        }
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                    { "nopermtocreate", "You got no rights to create a clan." },
                {
                    "nopermtojoin", "You got no rights to join a clan."
                }
                , {
                    "nopermtojoinbyinvite", "The player {0} has no rights to join a clan."
                }
                , {
                    "claninvite", "You have been invited to join the clan: [{0}] '{1}'\nTo join, type: <color={2}>/clan join {0}</color>"
                }
                , {
                    "comeonline", "{0} has come online!"
                }
                , {
                    "goneoffline", "{0} has gone offline!"
                }
                , {
                    "friendlyfire", "{0} is a clan member and cannot be hurt.\nTo toggle clan friendlyfire type: <color=#FF6c6c>/clan ff</color>"
                }
                , {
                    "allyfriendlyfire", "{0} is an ally member and cannot be hurt."
                }
                , {
                    "notmember", "You are currently not a member of a clan."
                }
                , {
                    "youareownerof", "You are the owner of:"
                }
                , {
                    "youaremodof", "You are a moderator of:"
                }
                , {
                    "youarecouncilof", "You are a council of:"
                }
                , {
                    "youarememberof", "You are a member of:"
                }
                , {
                    "claninfo", " [{0}] {1}"
                }
                , {
                    "memberon", "Members online: "
                }
                , {
                    "overviewnamecolor", "<color={0}>{1}</color>"
                }
                , {
                    "memberoff", "Members offline: "
                }
                , {
                    "notmoderator", "You need to be a moderator of your clan to use this command."
                }
                , {
                    "pendinvites", "Pending invites: "
                }
                , {
                    "bannedwords", "The clan tag contains banned words."
                }
                , {
                    "viewthehelp", "To view more commands, type: <color={0}>/{1} helpies</color>"
                }
                , {
                    "usagecreate", "Usage - <color={0}>/clan create \"TAG\" \"Description\"</color>"
                }
                , {
                    "hintlength", "Clan tags must be {0} to {1} characters long"
                }
                , {
                    "hintchars", "Clan tags must contain only 'a-z' 'A-Z' '0-9' '{0}'"
                }
                , {
                    "providedesc", "Please provide a short description of your clan."
                }
                , {
                    "tagblocked", "There is already a clan with this tag."
                }
                , {
                    "nownewowner", "You are now the owner of the clan [{0}] \"{1}\""
                }
                , {
                    "inviteplayers", "To invite new members, type: <color={0}>/clan invite <name></color>"
                }
                , {
                    "usageinvite", "Usage - <color={0}>/clan invite <name></color>"
                }
                , {
                    "nosuchplayer", "No such player or player name not unique: {0}"
                }
                , {
                    "alreadymember", "This player is already a member of your clan: {0}"
                }
                , {
                    "alreadyinvited", "This player has already been invited to your clan: {0}"
                }
                , {
                    "alreadyinclan", "This player is already in a clan: {0}"
                }
                , {
                    "invitebroadcast", "{0} invited {1} to the clan."
                }
                , {
                    "usagewithdraw", "Usage: <color={0}>/clan withdraw <name></color>"
                }
                , {
                    "notinvited", "This player has not been invited to your clan: {0}"
                }
                , {
                    "canceledinvite", "{0} canceled the invitation of {1}."
                }
                , {
                    "usagejoin", "Usage: <color={0}>/clan join \"TAG\"</color>"
                }
                , {
                    "youalreadymember", "You are already a member of a clan."
                }
                , {
                    "younotinvited", "You have not been invited to join this clan."
                }
                , {
                    "reachedmaximum", "This clan has already reached the maximum number of members."
                }
                , {
                    "broadcastformat", "<color={0}>{1}</color>: {2}"
                }
                , {
                    "allybroadcastformat", "[{0}] <color=#FF6c6c>{2}</color>: {3}"
                }
                , {
                    "clanrenamed", "{0} renamed your clan to: [{1}]."
                }
                , {
                    "yourenamed", "You have renamed the clan [{0}] to [{1}]"
                }
                , {
                    "clandeleted", "{0} deleted your clan."
                }
                , {
                    "youdeleted", "You have deleted the clan [{0}]"
                }
                , {
                    "noclanfound", "There is no clan with that tag [{0}]"
                }
                , {
                    "renamerightsowner", "You need to be a server owner to rename clans."
                }
                , {
                    "usagerename", "Usage: <color={0}>/clan rename OLDTAG NEWTAG</color>"
                }
                , {
                    "deleterightsowner", "You need to be a server owner to delete clans."
                }
                , {
                    "usagedelete", "Usage: <color={0}>/clan delete TAG</color>"
                }
                , {
                    "clandisbanded", "Your current clan has been disbanded forever."
                }
                , {
                    "needclanowner", "You need to be the owner of your clan to use this command."
                }
                , {
                    "needclanownercouncil", "You need to be the owner or a council to use this command."
                }
                , {
                    "usagedisband", "Usage: <color={0}>/clan disband forever</color>"
                }
                , {
                    "usagepromote", "Usage: <color={0}>/clan promote <name></color>"
                }
                , {
                    "playerjoined", "{0} has joined the clan!"
                }
                , {
                    "waskicked", "{0} kicked {1} from the clan."
                }
                , {
                    "modownercannotkicked", "The player {0} is an owner or moderator and cannot be kicked."
                }
                , {
                    "notmembercannotkicked", "The player {0} is not a member of your clan."
                }
                , {
                    "usageff", "Usage: <color={0}>/clan ff</color> toggles your current FriendlyFire status."
                }
                , {
                    "usagekick", "Usage: <color={0}>/clan kick <name></color>"
                }
                , {
                    "playerleft", "{0} has left the clan."
                }
                , {
                    "youleft", "You have left your current clan."
                }
                , {
                    "usageleave", "Usage: <color={0}>/clan leave</color>"
                }
                , {
                    "notaclanmember", "The player {0} is not a member of your clan."
                }
                , {
                    "alreadyowner", "The player {0} is already the owner of your clan."
                }
                , {
                    "alreadyamod", "The player {0} is already a moderator of your clan."
                }
                , {
                    "alreadyacouncil", "The player {0} is already a council of your clan."
                }
                , {
                    "alreadyacouncilset", "The position of the council is already awarded."
                }
                , {
                    "maximummods", "This clan has already reached the maximum number of moderators."
                }
                , {
                    "playerpromoted", "{0} promoted {1} to moderator."
                }
                , {
                    "playerpromotedcouncil", "{0} promoted {1} to council."
                }
                , {
                    "playerpromotedowner", "{0} promoted {1} to new owner."
                }
                , {
                    "usagedemote", "Usage: <color={0}>/clan demote <name></color>"
                }
                , {
                    "notamoderator", "The player {0} is not a moderator of your clan."
                }
                , {
                    "notpromoted", "The player {0} is not a moderator or council of your clan."
                }
                , {
                    "playerdemoted", "{0} demoted {1} to a member."
                }
                , {
                    "councildemoted", "{0} demoted {1} to a moderator."
                }
                , {
                    "noactiveally", "Your clan has no current alliances."
                }
                , {
                    "yourffstatus", "Your FriendlyFire:"
                }
                , {
                    "yourclanallies", "Your Clan allies:"
                }
                , {
                    "allyinvites", "Ally invites:"
                }
                , {
                    "allypending", "Ally requests:"
                }
                , {
                    "allyReqHelp", "Offer an alliance to another clan"
                }
                , {
                    "allyAccHelp", "Accept an alliance from another clan"
                }
                , {
                    "allyDecHelp", "Decline an alliance from another clan"
                }
                , {
                    "allyCanHelp", "Cancel an alliance with another clan"
                }
                , {
                    "reqAlliance", "[{0}] has requested a clan alliance"
                }
                , {
                    "invitePending", "You already have a pending alliance invite for [{0}]"
                }
                , {
                    "clanNoExist", "The clan [{0}] does not exist"
                }
                , {
                    "alreadyAllies", "You are already allied with"
                }
                , {
                    "allyProvideName", "You need to provide a Clan name"
                }
                , {
                    "allyLimit", "You already have the maximum allowed ally limit"
                }
                , {
                    "allyAccLimit", "You can not accept the alliance with {0}. You reached the limit"
                }
                , {
                    "allyCancel", "You have cancelled your alliance with [{0}]"
                }
                , {
                    "allyCancelSucc", "{0} has cancelled your clan alliance"
                }
                , {
                    "noAlly", "Your clans have no alliance with each other"
                }
                , {
                    "noAllyInv", "You do not have a alliance invite from [{0}]"
                }
                , {
                    "allyInvWithdraw", "You have cancelled your request to [{0}]"
                }
                , {
                    "allyDeclined", "You have declined the clan alliance from [{0}]"
                }
                , {
                    "allyDeclinedSucc", "[{0}] has declined your alliance request"
                }
                , {
                    "allyReq", "You have requested a clan alliance from [{0}]"
                }
                , {
                    "allyAcc", "You have accepted the clan alliance from [{0}]"
                }
                , {
                    "allyAccSucc", "[{0}] has accepted your alliance request"
                }
                , {
                    "allyPendingInfo", "Your clan has pending ally request(s). Check those in the clan overview."
                }
                , {
                    "clanffdisabled", "You have <color={0}>disabled</color> friendly fire for your clan.\nThey are safe!"
                }
                , {
                    "clanffenabled", "You have <color={0}>enabled</color> friendly fire for your clan.\nTake care!"
                }
                , {
                    "yourname", "YOU"
                }
                , {
                    "helpavailablecmds", "Available commands:"
                }
                , {
                    "helpinformation", "Display your clan information"
                }
                , {
                    "helpmessagemembers", "Send a message to all members"
                }
                , {
                    "helpmessageally", "Send a message to all allied members"
                }
                , {
                    "helpcreate", "Create a new clan"
                }
                , {
                    "helpjoin", "Join a clan by invitation"
                }
                , {
                    "helpleave", "Leave your clan"
                }
                , {
                    "helptoggleff", "Toggle friendlyfire status"
                }
                , {
                    "helpinvite", "Invite a player"
                }
                , {
                    "helpwithdraw", "Cancel an invite"
                }
                , {
                    "helpkick", "Kick a member"
                }
                , {
                    "helpallyoptions", "Lists the ally options"
                }
                , {
                    "helppromote", "Promote a member"
                }
                , {
                    "helpdemote", "Demote a member"
                }
                , {
                    "helpdisband", "Disband your clan (no undo)"
                }
                , {
                    "helpmoderator", "Moderator"
                }
                , {
                    "helpowner", "Owner"
                }
                , {
                    "helpcommands", "commands:"
                }
                , {
                    "helpconsole", "Open F1 console and type:"
                }
                , {
                    "yourradarstatus", "Your ClanRadar:"
                }
                , {
                    "clanradardisabled", "Clan radar disabled"
                }
                , {
                    "clanradarenabled", "Clan radar enabled"
                }
                , {
                    "helptoggleradar", "Toggle clanradar status"
                }
                , {
                    "clanArgCreate", "create"
                }
                , {
                    "clanArgInvite", "invite"
                }
                , {
                    "clanArgLeave", "leave"
                }
                , {
                    "clanArgWithdraw", "withdraw"
                }
                , {
                    "clanArgJoin", "join"
                }
                , {
                    "clanArgPromote", "promote"
                }
                , {
                    "clanArgDemote", "demote"
                }
                , {
                    "clanArgFF", "ff"
                }
                , {
                    "clanArgRadar", "radar"
                }
                , {
                    "clanArgAlly", "ally"
                }
                , {
                    "clanArgHelp", "help"
                }
                , {
                    "clanArgKick", "kick"
                }
                , {
                    "clanArgDisband", "disband"
                }
                , {
                    "clanArgForever", "forever"
                }
                , {
                    "clanArgNameId", "<name|id>"
                }
                , {
                    "allyArgRequest", "request"
                }
                , {
                    "allyArgRequestShort", "req"
                }
                , {
                    "allyArgAccept", "accept"
                }
                , {
                    "allyArgAcceptShort", "acc"
                }
                , {
                    "allyArgDecline", "decline"
                }
                , {
                    "allyArgDeclineShort", "dec"
                }
                , {
                    "allyArgCancel", "cancel"
                }
                , {
                    "allyArgCancelShort", "can"
                }
                ,
                {
                    "clanchatmuted", "You may not clanchat, you are muted."
                },
                 {
                    "clanUItitle", "Clan System by RustPlugin.ru / OxideBro"
                },
                  {
                    "clanTOPUItitle", "Clans TOP"
                },
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"nopermtocreate", "У тебя нету привилегии для создания клана."},
                 { "nopermtojoin", "У тебя нету привилегии что бы вступать в клан."},
                 { "nopermtojoinbyinvite", "У игрока {0} нету прав чтобы вступить в клан."},
                 { "claninvite", "Вас пригласили в клан: [{0}] '{1}'\nЧтобы вступить, введите: <color=#FF6c6c>/clan join {0}</color>"},
                 { "comeonline", "{0} зашел в игру!"},
                 { "goneoffline", "{0} вышел с игры!"},
                 { "friendlyfire", "{0} ваш соклановец, и не может получить урон.\nИспользуйте: <color=#FF6c6c>/clan ff</color> чтобы включить урон"},
                 { "allyfriendlyfire", "{0} является союзником и не может получить урон."},
                 { "notmember", "В настоящее время вы не являетесь членом клана."},
                 { "youareownerof", "Вы являетесь владельцем:"},
                 { "youaremodof", "Вы являетесь модератором:"},
                  {"youarecouncilof", "Вы советник в:"},
                 { "youarememberof", "Вы участник в:"},
                 { "claninfo", " [{0}] {1}"},
                  {"memberon", "Игроки клана в сети: "},
                 { "overviewnamecolor", "<color=#FF6c6c>{1}</color>"},
                 { "memberoff", "Игроки клана не в сети: "},
                 { "notmoderator", "Вы должны быть модератором своего клана, чтобы использовать эту команду."},
                 { "pendinvites", "Ожидающие приглашения: "},
                 { "bannedwords", "Tег клана содержит запрещенные слова."},
                 { "viewthehelp", "Чтобы просмотреть больше команд, введите: <color=#FF6c6c>/{1}</color>"},
                 { "hintlength", "Клановый тег должнен быть от {0} до {1} символов"},
                  {"hintchars", "Клановый тег может использовать только 'a-z' 'A-Z' '0-9' '{0}' символы"},
                 { "providedesc", "Пожалуйста, уточните краткое описание вашего клана."},
                 { "tagblocked", "Уже есть клан с этим тегом."},
                 { "nownewowner", "Теперь вы владелец клана [{0}] \"{1}\""},
                  {"inviteplayers", "Чтобы пригласить новых участников, введите: <color=#FF6c6c>/clan invite <name></color>"},
                  {"nosuchplayer", "Нет такого игрока или имя игрока указано не верно: {0}"},
                  {"alreadymember", "Этот игрок уже является членом вашего клана: {0}"},
                  {"alreadyinvited", "Этот игрок уже приглашен в ваш клан: {0}"},
                  {"alreadyinclan", "Этот игрок уже в клане: {0}"},
                 { "invitebroadcast", "{0} вступил в клан {1}."},
                 { "notinvited", "Этот игрок не был приглашен в ваш клан: {0}"},
                 { "canceledinvite", "{0} отменил приглашение {1}."},
                 { "youalreadymember", "Вы уже являетесь членом клана."},
                 { "younotinvited", "Вы не были приглашены в этот клан."},
                 { "reachedmaximum", "Этот клан уже достиг максимального количества участников."},
                 { "broadcastformat", "<color=#FF6c6c>{1}</color>: {2}"},
                 { "allybroadcastformat", "[{0}] <color=#FF6c6c>{2}</color>: {3}"},
                 { "clanrenamed", "{0} переименовал переименовал клан в: [{1}]."},
                 { "yourenamed", "Вы переименовали клан [{0}] в [{1}]"},
                  {"clandeleted", "{0} удалил свой клан."},
                 { "youdeleted", "Вы удалили клан [{0}]"},
                 { "noclanfound", "Нету клана с этим тегом [{0}]"},
                  {"renamerightsowner", "Вы должны быть администратором сервера, чтобы переименовать кланы."},
                 { "deleterightsowner", "Вы должны быть администратором сервера, чтобы удалять кланы."},
                 { "clandisbanded", "Ваш текущий клан был распущен навсегда."},
                 { "needclanowner", "Вы должны быть владельцем своего клана, чтобы использовать эту команду."},
                 { "needclanownercouncil", "Вы должны быть владельцем или модератором, чтобы использовать эту команду."},
                 { "playerjoined", "{0} присоединился к клану!"},
                 { "waskicked", "{0} выгнал {1} из клана."},
                 { "modownercannotkicked", "Игрок {0} является владельцем или модератором и не может быть выкинут."},
                 { "notmembercannotkicked", "Игрок {0} не является членом клана."},
                 { "playerleft", "{0} покинул клан."},
                 { "youleft", "Вы покинули свой текущий клан."},
                  {"notaclanmember", "Игрок {0} не является членом вашего клана."},
                 { "maximummods", "Этот клан уже достиг максимального количества модераторов."},
                  {"playerpromoted", "{0} повышен {1} до модератора."},
                 { "playerpromotedcouncil", "{0} повышен до {1} до советника."},
                 { "playerpromotedowner", "{0} повышен {1} до нового владельца."},
                 { "notamoderator", "Игрок {0} не является модератором вашего клана."},
                 { "notpromoted", "Игрок {0} не является модератором или советом вашего клана."},
                 { "playerdemoted", "{0} понижен в должности {1} до участника."},
                 { "noactiveally", "Ваш клан не имеет текущих альянсов."},
                 { "yourffstatus", "Ваш FriendlyFire:"},
                 { "yourclanallies", "Союзники вашего клана:"},
                 { "allyinvites", "Ally приглашает:"},
                 { "allypending", "запросы союзников:"},
                 { "allyReqHelp", "Предложить союз другому клану"},
                 { "allyAccHelp", "Примите союз от другого клана"},
                  {"allyDecHelp", "Отклонить союз от другого клана"},
                 { "allyCanHelp", "Отменить союз с другим кланом"},
                 { "reqAlliance", "[{0}] запросил альянс клана"},
                {  "clanNoExist", "Клан [{0}] не существует"},
                 { "allyProvideName", "Вам необходимо указать имя клана"},
                 { "allyLimit", "У вас уже есть максимально допустимое ограничение союзников"},
                 { "allyAccLimit", "Вы не можете принять альянс с {0}. Вы достигли предела"},
                {  "allyCancel", "Вы отменили свой союз с [{0}]"},
                {  "allyCancelSucc", "{0} отменил ваш клановый союз"},
                 { "noAlly", "Ваши кланы не имеют альянса друг с другом"},
                 { "noAllyInv", "У вас нет приглашения в альянс от [{0}]"},
                 { "allyInvWithdraw", "Вы отменили свой запрос к [{0}]"},
                 { "allyDeclined", "Вы отказались от альянса кланов от [{0}]"},
                {  "allyDeclinedSucc", "[{0}] отклонил ваш запрос на альянс"},
                 { "allyReq", "Вы запросили альянс клана от [{0}]"},
                 { "allyAcc", "Вы приняли клановый союз от [{0}]"},
                {  "allyAccSucc", "[{0}] принял ваш запрос на альянс"},
                 { "allyPendingInfo", "Ваш клан имеет ожидающие запросы союзников. Проверьте их в обзоре клана."},
                 { "clanffdisabled", "У вас <color=#FF6c6c> отключенный </color> дружественный огонь для вашего клана.\nЭто безопасно!"},
                 { "clanffenabled", "У вас <color=#FF6c6c> включенный </color> дружественный огонь для вашего клана.\nВнимитесь!"},
                 {"yourname", "ВЫ"},
                 { "helpavailablecmds", "Доступные команды:"},
                 { "helpinformation", "Показать информацию о вашем клане"},
                 { "helpmessagemembers", "Отправить сообщение всем участникам"},
                 { "helpmessageally", "Отправить сообщение всем союзникам"},
                 { "helpcreate", "Создание нового клана"},
                 { "helpjoin", "Вступить в клан по приглашению"},
                 { "helpleave", "Выйти с вашего текущего клана"},
                 { "helptoggleff", "Переключить статус FF"},
                 { "helpinvite", "Пригласить игрока"},
                 { "helpwithdraw", "Отменить приглашение"},
                 { "helpkick", "Кикнуть участника"},
                 { "helpallyoptions", "Список опций"},
                 { "helppromote", "Повысить участника"},
                 { "helpdemote", "Понизить участника"},
                {  "helpdisband", "Расформирование своего клана (Не отменить)"},
                {  "helpmoderator", "Модератор"},
                {  "helpowner", "Создатель"},
                 { "helpcommands", "команды:"},
                 { "helpconsole", "Откройте консоль, F1:"},
                 { "yourradarstatus", "Ваш клан радар:"},
                 { "clanradardisabled", "Клан радар отключен"},
                  {"clanradarenabled", "Клан радар включен"},
                 { "helptoggleradar", "Переключение статуса клан радара"},
                 { "clanArgCreate", "create"},
                 { "clanArgInvite", "invite"},
                 { "clanArgLeave", "leave"},
                {  "clanArgWithdraw", "withdraw"},
                {  "clanArgJoin", "join"},
                 { "clanArgPromote", "promote"},
                 { "clanArgDemote", "demote"},
                 { "clanArgFF", "ff"},
                 { "clanArgRadar", "radar"},
                {  "clanArgAlly", "ally"},
                 { "clanArgHelp", "help"},
                 { "clanArgKick", "kick"},
                 { "clanArgDisband", "disband"},
                 { "clanArgForever", "forever"},
                 { "clanArgNameId", "<name|id>"},
                 { "allyArgRequest", "request"},
                 { "allyArgRequestShort", "req"},
                 { "allyArgAccept", "accept"},
                 { "allyArgAcceptShort", "acc"},
                 { "allyArgDecline", "decline"},
                 { "allyArgDeclineShort", "dec"},
                 { "allyArgCancel", "cancel"},
                 { "allyArgCancelShort", "can"},
                 { "clanchatmuted", "Вы не можете писать в клан чат."},
                 { "clanUItitle", "Система кланов Unusual"},
                 { "clanTOPUItitle", "TOP кланов сервера"},
                 { "alreadyowner", "Игрок {0} уже владелец вашего клана."},
                 { "alreadyamod", "Игрок {0} уже капитан вашего клана."},
                {  "alreadyacouncil", "Игрок {0} уже советчик вашего клана."},
                 { "alreadyacouncilset", "Должность советчика уже установлена."},
                  {"councildemoted", "{0} пониженный {1} до модератора."},
                 { "invitePending", "У вас уже есть ожидающее приглашение в альянс для [{0}]"},
                 { "alreadyAllies", "Вы уже состоите в альянсе с"},
                 { "usagecreate", "Используйте - <color=#FF6c6c>/clan create \"TAG Клана\" \"Название клана\"</color>"},
                 { "usageinvite", "Используйте - <color=#FF6c6c>/clan invite <name></color>"},
                 { "usagewithdraw", "Используйте: <color=#FF6c6c>/clan withdraw <name></color>"},
                {  "usagejoin", "Используйте: <color=#FF6c6c>/clan join \"TAG\"</color>"},
                {  "usagerename", "Используйте: <color=#FF6c6c>/clan rename OLDTAG NEWTAG</color>"},
                {  "usagedelete", "Используйте: <color=#FF6c6c>/clan delete TAG</color>"},
                { "usagedisband", "Используйте: <color=#FF6c6c>/clan disband forever</color>"},
                {  "usagepromote", "Используйте: <color=#FF6c6c>/clan promote <name></color>"},
                {  "usageff", "Используйте: <color=#FF6c6c>/clan ff</color> toggles your current FriendlyFire status."},
                {  "usagekick", "Используйте: <color=#FF6c6c>/clan kick <name></color>"},
                {  "usageleave", "Используйте: <color=#FF6c6c>/clan leave</color>"},
                 { "usagedemote", "Используйте: <color=#FF6c6c>/clan demote <name></color>"}
            }, this, "ru");
        }

        void Init()
        {
            cc = this;
            LoadVariables();
            LoadDefaultMessages();
            Initialized = false;
            if (!permission.PermissionExists(permissionClanRadarUse)) permission.RegisterPermission(permissionClanRadarUse, this);
            if (!permission.PermissionExists(permissionToCreateClan)) permission.RegisterPermission(permissionToCreateClan, this);
            if (!permission.PermissionExists(permissionToJoinClan)) permission.RegisterPermission(permissionToJoinClan, this);
            cmd.AddChatCommand(chatCommandFF, this, "cmdChatClanFF");
            //Custom code
            //cmd.AddChatCommand("clanui", this, "CLanUIInfo");

            cmd.AddChatCommand(chatCommandClan, this, "cmdChatClan");
            cmd.AddChatCommand(chatCommandClanChat, this, "cmdChatClanchat");
            cmd.AddChatCommand(chatCommandAllyChat, this, "cmdChatAllychat");
            cmd.AddChatCommand(chatCommandClanInfo, this, "cmdChatClanInfo");
            cmd.AddChatCommand(chatCommandRadar, this, "cmdChatClanRadar");
            cmd.AddChatCommand(chatCommandClan + subCommandClanHelp, this, "cmdChatClanHelp");
            cmd.AddChatCommand(chatCommandClan + subCommandClanAlly, this, "cmdChatClanAlly");
            if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }
        void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Title != "Better Chat") return;
            if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }


        string getFormattedClanTag(IPlayer player)
        {
            var clan = findClanByUser(player.Id);
            if (clan != null && !string.IsNullOrEmpty(clan.tag)) return $"[#{clanTagColorBetterChat.Replace("#", "")}][+{clanTagSizeBetterChat}]{clanTagOpening}{clan.tag}{clanTagClosing}[/+][/#]";
            return string.Empty;
        }
        //Custom code
        [PluginReference] private Plugin ImageLibrary;

        //public string GetImageSkin(string shortname, ulong skin = 13975490) => (string)ImageLoader.Call("GetItemImage", shortname, skin);
        public string GetImageSkin(string shortname, ulong skin = 13975490) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        public List<ulong> GetImageSkins(string shortname) => ImageLibrary.Call("GetImageList", shortname) as List<ulong>;

        static Clans ins;

        void OnServerInitialized()
        {
            ins = this;

            if (useRelationshipManager)
            {
                Subscribe(nameof(OnServerCommand));
                if (!RelationshipManager.TeamsEnabled())
                {
                    teamUiWasDisabled = true;
                    PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{RelationshipManager.maxTeamSize}'");
                }
            }
            else
            {
                Unsubscribe(nameof(OnServerCommand));
            }


            object obj = LoadData();

            if (!ImageLibrary)
            {
                PrintError("ImageLibrary not found! Clans not work!");
                Interface.Oxide.UnloadPlugin("Clans");
                return;
            }
            else
            {
                clanCache.ToList().ForEach(c => ImageLibrary?.Call("AddImage", c.Value.ClanAvatar, c.Value.ClanAvatar));
            }



            if (enableClanRadar)
            {
                clanRadarMemberobjects = new Dictionary<string, List<BasePlayer>>();
                foreach (var clan in clans) clanRadarMemberobjects.Add(clan.Key, new List<BasePlayer>());
            }
            Rust.Global.Runner.StartCoroutine(ServerInitialized(obj));

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

        }

        private IEnumerator ServerInitialized(object obj)
        {
            if (obj != null)
                InitializeClans((bool)obj);

            if (purgeOldClans)
                Puts($"Valid clans loaded: '{clans.Count}'");

            if (purgeOldClans && purgedClans.Count() > 0)
            {
                Puts($"Old Clans purged: '{purgedClans.Count}'");
                if (listPurgedClans)
                {
                    foreach (string purged in purgedClans)
                        Puts($"Purged > {purged}");
                }
            }

            yield return CoroutineEx.waitForSeconds(2f);

            AllyRemovalCheck();


            tagReExt = new Regex("[^a-zA-Z0-9" + allowedSpecialChars + "]");

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                SetupPlayer(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                SetupPlayer(player);

            foreach (KeyValuePair<string, Clan> clan in clans)
            {
                clan.Value.OnUpdate(false);
                clan.Value.UpdateTeam();
            }

            Initialized = true;
            yield return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (useRelationshipManager && arg != null && arg.cmd != null)
            {
                if (RelationshipManager.TeamsEnabled() || teamUiWasDisabled)
                {
                    if (arg.cmd.Name.ToLower() == "maxteamsize" && arg.FullString != string.Empty)
                    {
                        int i = arg.GetInt(0, 0);
                        if (i > 0 && teamUiWasDisabled)
                        {
                            teamUiWasDisabled = false;
                            Puts($"TeamUI functions full activated");
                            return null;
                        }
                        else if (i < 1)
                        {
                            teamUiWasDisabled = true;
                            PrintWarning($"TeamUI functions partly inactive, maxTeamSize was set to '{i}'");
                            return null;
                        }
                    }

                    Clan obj;
                    if (!RelationshipManager.TeamsEnabled())
                        return null;

                    if (arg.Connection != null && clanCache.TryGetValue(arg.Connection.userid.ToString(), out obj) && arg.cmd.Parent.ToLower() == "relationshipmanager")
                    {
                        if (disableManageFunctions)
                            return false;

                        if (arg.cmd.Name.ToLower() == "leaveteam" && allowButtonLeave)
                        {
                            LeaveClan(arg.Player());
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "kickmember" && allowButtonKick)
                        {
                            KickPlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "sendinvite" && allowDirectInvite)
                        {
                            InvitePlayer(arg.Player(), arg.FullString.Trim('"'));
                            return false;
                        }

                        if (arg.cmd.Name.ToLower() == "promote" && allowPromoteLeader)
                        {
                            BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(arg.Player());
                            if (lookingAtPlayer == null || lookingAtPlayer.IsDead() || lookingAtPlayer == arg.Player())
                                return false;

                            if (lookingAtPlayer.currentTeam == arg.Player().currentTeam)
                            {
                                bool wasCouncil = obj.IsCouncil(lookingAtPlayer.UserIDString);
                                bool wasMod = obj.IsModerator(lookingAtPlayer.UserIDString);

                                if (wasCouncil && !wasMod)
                                    obj.council = arg.Player().UserIDString;

                                if (wasMod && !wasCouncil)
                                {
                                    obj.RemoveModerator(lookingAtPlayer);
                                    obj.SetModerator(arg.Player());
                                }

                                obj.owner = lookingAtPlayer.UserIDString;
                                obj.BroadcastLoc("playerpromotedowner", obj.GetColoredName(arg.Player().UserIDString, arg.Connection.username), obj.GetColoredName(lookingAtPlayer.UserIDString, obj.FindClanMember(lookingAtPlayer.UserIDString).Name));
                                obj.OnUpdate(true);
                            }
                            return false;
                        }
                    }
                }
            }

            return null;
        }

        void OnServerSave() => SaveData();
        void OnNewSave()
        {
            if (wipeClansOnNewSave) newSaveDetected = true;
        }

        void Unload()
        {
            if (!Initialized) return;
            SaveData();

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                DoCleanUp(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                DoCleanUp(player);

            if (enableClanRadar)
            {
                var objects = GameObject.FindObjectsOfType(typeof(ClanRadar));
                if (objects != null) foreach (var gameObj in objects) GameObject.Destroy(gameObj);
            }
        }

        private void DoCleanUp(BasePlayer player)
        {
            if (player == null)
                return;

            Clan clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (useRelationshipManager)
                {
                    RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    playerTeam?.RemovePlayer(player.userID);

                    player.ClearTeam();
                    RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
                }

                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{clan.tag}{clanTagClosing} ", "");
                    player.displayName = name;

                    if (player.net != null)
                        player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                }

                if (!Interface.Oxide.IsShuttingDown)
                {
                    if (forceNametagsOnTagging)
                        player.limitNetworking = true;

                    player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                    if (forceNametagsOnTagging)
                        player.limitNetworking = false;
                }
            }
        }


        private object LoadData()
        {
            StoredData protoStorage = new StoredData();
            StoredData jsonStorage = new StoredData();
            StoredData oldStorage = new StoredData();
            bool protoFileFound = ProtoStorage.Exists(new string[] { Title });
            bool jsonFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile(Title);
            bool oldFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile("rustio_clans");
            if (!protoFileFound && !jsonFileFound)
            {
                oldStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");
            }
            else
            {
                if (jsonFileFound)
                    jsonStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);

                if (protoFileFound)
                {
                    protoStorage = ProtoStorage.Load<StoredData>(new string[]
                      {
                        Title
                      });
                }
            }

            bool lastwasProto = protoStorage.lastStorage == "proto" && (protoStorage.saveStamp > jsonStorage.saveStamp || protoStorage.saveStamp > oldStorage.saveStamp);

            if (useProtostorageClandata)
            {
                if (lastwasProto)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();
                }
                else
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
            }
            else
            {
                if (!lastwasProto)
                {
                    if (oldFileFound && !jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");

                    if (jsonFileFound)
                        clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
                else if (protoFileFound)
                {
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();
                }
            }

            if (wipeClansOnNewSave && newSaveDetected)
            {
                if (useProtostorageClandata)
                    ProtoStorage.Save<StoredData>(clanSaves, new string[] { Title + ".bak" });
                else Interface.Oxide.DataFileSystem.WriteObject(Title + ".bak", clanSaves);

                Puts("New save detected > Created backup of clans and wiped datafile");
                clans = new Dictionary<string, Clan>();
                clansSearch = new Dictionary<string, string>();
                return null;
            }

            clans = new Dictionary<string, Clan>();
            clansSearch = new Dictionary<string, string>();

            if (clanSaves.clans == null || clanSaves.clans.Count == 0)
                return null;

            clans = clanSaves.clans;
            return !jsonFileFound && !protoFileFound;
        }

        void InitializeClans(bool newFileFound)
        {
            Dictionary<string, int> clanDuplicates = new Dictionary<string, int>();
            List<string> clanDuplicateCount = new List<string>();
            foreach (var _clan in clans.ToList())
            {
                Clan clan = _clan.Value;
                if (purgeOldClans && (UnixTimeStampUTC() - clan.updated) > (notUpdatedSinceDays * 86400))
                {
                    purgedClans.Add($"[{clan.tag}] | {clan.description} | Owner: {clan.owner} | LastUpd: {UnixTimeStampToDateTime(clan.updated)}");
                    if (permission.GroupExists(permGroupPrefix + clan.tag))
                    {
                        foreach (var member in clan.members)
                            if (permission.UserHasGroup(member.Key, permGroupPrefix + clan.tag))
                                permission.RemoveUserGroup(member.Key, permGroupPrefix + clan.tag);
                        permission.RemoveGroup(permGroupPrefix + clan.tag);
                    }
                    RemoveClan(clan.tag);
                    continue;
                }
                foreach (var member in clan.members.ToList())
                {
                    var p = covalence.Players.FindPlayerById(member.Key);
                    if (!(p is IPlayer) || p == null || p.Name == "")
                    {
                        clan.members.Remove(member.Key);
                        clan.moderators.Remove(member.Key);
                    }
                }
                if (clan.members.Count() == 0)
                {
                    RemoveClan(clan.tag);
                    continue;
                }
                if (!clan.members.ContainsKey(clan.owner)) clan.owner = clan.members.ToList()[0].Key;
                if (usePermGroups && !permission.GroupExists(permGroupPrefix + clan.tag)) permission.CreateGroup(permGroupPrefix + clan.tag, "Clan " + clan.tag, 0);
                foreach (var member in clan.members)
                {
                    if (usePermGroups && !permission.UserHasGroup(member.Key, permGroupPrefix + clan.tag)) permission.AddUserGroup(member.Key, permGroupPrefix + clan.tag);
                }
                foreach (var invited in clan.invites.ToList())
                {
                    if ((UnixTimeStampUTC() - (int)invited.Value) > (inviteValidDays * 86400)) clan.invites.Remove(invited.Key);
                }
                clanCache[clan.owner] = clan;
                foreach (var member in clan.members)
                {
                    if (!clanDuplicates.ContainsKey(member.Key))
                    {
                        clanDuplicates.Add(member.Key, 1);
                        clanCache[member.Key] = clan;
                        continue;
                    }
                    else
                    {
                        clanDuplicates[member.Key] += 1;
                        if (!clanDuplicateCount.Contains(member.Key)) clanDuplicateCount.Add(member.Key);
                    }
                    clanCache[member.Key] = clan;
                }
                foreach (var invite in clan.invites)
                {
                    if (!pendingPlayerInvites.ContainsKey(invite.Key)) pendingPlayerInvites.Add(invite.Key, new List<string>());
                    pendingPlayerInvites[invite.Key].Add(clan.tag);
                }
                var reply = 85;
                
                clan.total = clan.members.Count();
                clan.mods = clan.moderators.Count();
                if (clan.created == 0) clan.created = UnixTimeStampUTC();
                if (clan.updated == 0) clan.updated = UnixTimeStampUTC();
                if (!clansSearch.ContainsKey(clan.tag.ToLower())) clansSearch.Add(clan.tag.ToLower(), clan.tag);
            }
            if (clanDuplicateCount.Count > 0) PrintWarning($"Found '{clanDuplicateCount.Count()}' player(s) in multiple clans. Check `clans.showduplicates`");
            Puts($"Loaded data with '{clans.Count}' valid Clans and overall '{clanCache.Count}' Members.");
            if (newFileFound) SaveData(true);
        }
        void SaveData(bool force = false)
        {
            if (!Initialized && !force) return;
            clanSaves.clans = clans;
            clanSaves.saveStamp = UnixTimeStampUTC();
            clanSaves.lastStorage = useProtostorageClandata ? "proto" : "json";
            if (useProtostorageClandata)
                ProtoStorage.Save<StoredData>(clanSaves, new string[] { this.Title });

            else Interface.Oxide.DataFileSystem.WriteObject(this.Title, clanSaves);
        }
        public Clan findClan(string tag)
        {
            Clan clan;
            if (TryGetClan(tag, out clan)) return clan;
            return null;
        }

        public Clan findClanByUser(string userId)
        {
            Clan clan;
            if (clanCache.TryGetValue(userId, out clan)) return clan;
            return null;
        }

        private Clan SetupPlayer(BasePlayer player, IPlayer current = null, bool hasLeft = false, Clan clan = null, bool teamForced = false, string oldTag = null)
        {
            if (player == null)
                return null;

            if (current == null)
                current = covalence.Players.FindPlayerById(player.UserIDString);

            if (current == null)
                return null;

            bool prevName = false;

            if (clan == null && !hasLeft)
                clan = findClanByUser(current.Id);

            bool flag = false;
            string oldName = player.displayName;
            player.displayName = oldName;
            player._name = oldName;


            if (clan == null || hasLeft)
            {
                if (enableClanTagging && hasLeft && oldTag != null)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{oldTag}{clanTagClosing} ", "");
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                if (useRelationshipManager)
                    flag = NullClanTeam(player);
                clan = null;
            }
            else
            {
                if (enableClanTagging)
                {
                    string name = player.displayName.Replace($"{clanTagOpening}{(oldTag != null ? oldTag : clan.tag)}{clanTagClosing} ", "");
                    name = $"{clanTagOpening}{clan.tag}{clanTagClosing} {name}";
                    player.displayName = name;
                    player._name = string.Format("{1}[{0}/{2}]", player.net.ID, name, player.userID);
                    prevName = true;
                }

                clan.AddBasePlayer(player);
            }

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = true;

            if (flag || prevName)
                player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            if (prevName && forceNametagsOnTagging)
                player.limitNetworking = false;

            return clan;
        }

        private bool NullClanTeam(BasePlayer player)
        {
            bool flag = false;
            if (player.currentTeam != 0UL)
            {
                RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (team == null)
                {
                    player.currentTeam = 0UL;
                    player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                    flag = true;
                }
            }
            else if (player.currentTeam == 0UL)
            {
                player.ClientRPCPlayer(null, player, "CLIENT_ClearTeam");
                flag = true;
            }

            return flag;
        }

        void setupPlayers(List<string> playerIds, bool remove, string tag)
        {
            if (enableClanTagging) foreach (var playerId in playerIds)
                {
                    var player = BasePlayer.Find(playerId);
                    if (player != null) SetupPlayer(player, null, remove, null,  false, tag);
                }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || player.net == null || player.net.connection == null)
                return;

            Clan clan = SetupPlayer(player);

            if (clan != null)
                ServerMgr.Instance.StartCoroutine(WaitForReady(player, clan));
        }

        IEnumerator WaitForReady(BasePlayer player, Clan clan = null)
        {
            yield return new WaitWhile(new System.Func<bool>(() => player.IsReceivingSnapshot && player.IsSleeping()));
            if (player.IsDead()) yield return null;
            ComingOnlineInfo(player, clan);


            yield return null;
        }
        void ComingOnlineInfo(BasePlayer player, Clan clan = null)
        {
            if (player == null) return;
            if (clan != null)
            {
                if (enableComesOnlineMsg) clan.BroadcastLoc("comeonline", clan.ColNam(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                if (enableWhoIsOnlineMsg)
                {
                    var sb = new StringBuilder();
                    sb.Append($"<color={colorTextMsg}>");
                    sb.Append(string.Format(msg("memberon", player.UserIDString)));
                    int n = 0;
                    foreach (var memberId in clan.members)
                    {
                        var op = this.covalence.Players.FindPlayerById(memberId.Key);
                        if (op != null && op.IsConnected)
                        {
                            var memberName = op.Name;
                            if (op.Name == player.net.connection.username) memberName = msg("yourname", player.UserIDString);
                            if (n > 0) sb.Append(", ");
                            if (clan.IsOwner(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, memberName));
                            }
                            else if (clan.IsCouncil(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, memberName));
                            }
                            else if (clan.IsModerator(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, memberName));
                            }
                            else
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, memberName));
                            }
                            ++n;
                        }
                    }
                    sb.Append($"</color>");
                    PrintChat(player, sb.ToString().TrimEnd());
                }
                clan.updated = UnixTimeStampUTC();
                manuallyEnabledBy.Remove(player.userID);
                if (enableClanAllies && (clan.IsOwner(player.UserIDString) || clan.IsCouncil(player.UserIDString)) && clan.pendingInvites.Count > 0)
                {
                    if (player != null) PrintChat(player, string.Format(msg("allyPendingInfo", player.UserIDString)));
                }
                return;
            }
            if (pendingPlayerInvites.ContainsKey(player.UserIDString))
            {
                foreach (var invitation in pendingPlayerInvites[player.UserIDString] as List<string>)
                {
                    Clan newclan = findClan(invitation);
                    if (newclan != null) timer.Once(3f, () =>
                    {
                        if (player != null) PrintChat(player, string.Format(msg("claninvite", player.UserIDString), newclan.tag, newclan.description, colorCmdUsage));
                    }
                     );
                }
            }
        }


        void OnPlayerDisconnected(BasePlayer player)
        {
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                clan.BroadcastLoc("goneoffline", clan.ColNam(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                manuallyEnabledBy.Remove(player.userID);
                if (enableClanRadar) activeRadarUsers.Remove(player.UserIDString);
            }
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null) return;

            var clan = findClanByUser(player.UserIDString);
            if (clan != null && info.InitiatorPlayer != null && clan.members.ContainsKey(player.UserIDString))
            {
                clan.ClanPoints -= PointsOfDeath;
                clan.members[player.UserIDString].PlayerPoints -= PointsOfDeath;
                clan.members[player.UserIDString].Death++;
            }

            if (clan != null)
            {
                if (enableClanRadar && clan.tag != null && clanRadarMemberobjects.ContainsKey(clan.tag) && clanRadarMemberobjects[clan.tag].Contains(player))
                    clanRadarMemberobjects[clan.tag].Remove(player);
            }
        }


        void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null || !enableClanRadar) return;
            string tag = GetClanOf(player);
            if (tag == null) return;
            if (!clanRadarMemberobjects.ContainsKey(tag)) clanRadarMemberobjects.Add(tag, new List<BasePlayer>());
            if (!clanRadarMemberobjects[tag].Contains(player)) clanRadarMemberobjects[tag].Add(player);
            if (activeRadarUsers.Contains(player.UserIDString))
            {
                ClanRadar radar = player.transform.GetOrAddComponent<ClanRadar>();
                radar.DoStart();
            }
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo hit)
        {
            if (!enableFFOPtion || attacker == null || hit == null || !(hit.HitEntity is BasePlayer)) return;
            OnAttackShared(attacker, hit.HitEntity as BasePlayer, hit);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit)
        {
            try
            {
                if (entity == null || hit == null) return;
                if (entity is BaseHelicopter && hit.Initiator is BasePlayer)
                {
                    LastHeliHit[entity.net.ID] = hit.InitiatorPlayer.userID;
                }

                if (!enableFFOPtion || !(entity is BasePlayer) || !(hit.Initiator is BasePlayer)) return;
                OnAttackShared(hit.Initiator as BasePlayer, entity as BasePlayer, hit);
            }
            catch (NullReferenceException)
            { }
        }
        object OnAttackShared(BasePlayer attacker, BasePlayer victim, HitInfo hit)
        {
            if (bypass.Contains(victim.userID) || attacker == victim) return null;
            var victimClan = findClanByUser(victim.UserIDString);
            var attackerClan = findClanByUser(attacker.UserIDString);
            if (victimClan == null || attackerClan == null) return null;
            if (victimClan.tag == attackerClan.tag)
            {
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceClanFFNoDeactivate) return null;
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = attacker.UserIDString + "-" + victim.UserIDString;
                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("friendlyfire", attacker.UserIDString), victim.displayName, colorCmdUsage));
                    notificationTimes[key] = now;
                }
                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }
            if (victimClan.tag != attackerClan.tag && enableClanAllies && enableAllyFFOPtion)
            {
                if (!victimClan.clanAlliances.Contains(attackerClan.tag)) return null;
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceAllyFFNoDeactivate) return null;
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = attacker.UserIDString + "-" + victim.UserIDString;
                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("allyfriendlyfire", attacker.UserIDString), victim.displayName));
                    notificationTimes[key] = now;
                }
                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }
            return null;
        }
        void AllyRemovalCheck()
        {
            foreach (var ally in clans)
            {
                try
                {
                    Clan allyClan = clans[ally.Key];
                    foreach (var clanAlliance in allyClan.clanAlliances.ToList())
                    {
                        if (!clans.ContainsKey(clanAlliance)) allyClan.clanAlliances.Remove(clanAlliance);
                    }
                    foreach (var invitedAlly in allyClan.invitedAllies.ToList())
                    {
                        if (!clans.ContainsKey(invitedAlly)) allyClan.clanAlliances.Remove(invitedAlly);
                    }
                    foreach (var pendingInvite in allyClan.pendingInvites.ToList())
                    {
                        if (!clans.ContainsKey(pendingInvite)) allyClan.clanAlliances.Remove(pendingInvite);
                    }
                }
                catch
                {
                    PrintWarning("Ally removal check failed. Please contact the developer.");
                }
            }
        }
        void cmdChatClan(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length == 0)
            {
                cmdClanOverview(player);
                return;
            }
            string opt = args[0];
            if (opt == msg("clanArgCreate", player.UserIDString))
            {
                cmdClanCreate(player, args);
                return;
            }
            else if (opt == msg("clanArgInvite", player.UserIDString))
            {
                cmdClanInvite(player, args);
                return;
            }
            else if (opt == msg("clanArgWithdraw", player.UserIDString))
            {
                cmdClanWithdraw(player, args);
                return;
            }
            else if (opt == msg("clanArgJoin", player.UserIDString))
            {
                cmdClanJoin(player, args);
                return;
            }
            else if (opt == msg("clanArgPromote", player.UserIDString))
            {
                cmdClanPromote(player, args);
                return;
            }
            else if (opt == msg("clanArgDemote", player.UserIDString))
            {
                cmdClanDemote(player, args);
                return;
            }
            else if (opt == msg("clanArgLeave", player.UserIDString))
            {
                cmdClanLeave(player, args);
                return;
            }
            else if (opt == msg("clanArgFF", player.UserIDString))
            {
                if (!enableFFOPtion) return;
                cmdChatClanFF(player, command, args);
                return;
            }
            else if (opt == msg("clanArgRadar", player.UserIDString))
            {
                if (!enableClanRadar || (usePermissionClanRadar && !permission.UserHasPermission(player.UserIDString, permissionClanRadarUse))) return;
                cmdChatClanRadar(player, command, args);
                return;
            }
            else if (opt == msg("clanArgAlly", player.UserIDString))
            {
                if (!enableClanAllies) return;
                for (var i = 0;
                i < args.Length - 1;
                ++i)
                {
                    if (i < args.Length) args[i] = args[i + 1];
                }
                Array.Resize(ref args, args.Length - 1);
                cmdChatClanAlly(player, command, args);
                return;
            }
            else if (opt == msg("clanArgKick", player.UserIDString))
            {
                cmdClanKick(player, args);
                return;
            }
            else if (opt == msg("clanArgDisband", player.UserIDString))
            {
                cmdClanDisband(player, args);
                return;
            }
            else cmdChatClanHelp(player, command, args);
        }

        public string MainLayer = "Clan.NewLayer";

        void NewClanUI(BasePlayer player, bool leadermode = false)
        {
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            CuiHelper.DestroyUi(player, MainLayer);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0.235 0.227 0.180 0.90", Sprite = "assets/content/ui/ui.background.tile.psd" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" }
            }, "Overlay", MainLayer);

            string title = string.IsNullOrEmpty(clan.description) ? $"<b>{clan.tag}</b>" : $"<b>{clan.tag}</b> | <b>{clan.description}</b>";

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiButtonComponent { Color = "0.141 0.137 0.109 1", Sprite = "assets/content/ui/ui.background.transparent.radial.psd" , Close = MainLayer},
                                new CuiRectTransformComponent{ AnchorMin = $"0 0", AnchorMax = $"1 1" },
                            }
            });



            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 1", Text = $"{title}", Align = TextAnchor.MiddleLeft,  FontSize = 35 },
                                new CuiRectTransformComponent{ AnchorMin = $"0.4 0.9", AnchorMax = $"1 1" },
                            }
            });
            var clanLeaderStatus = BasePlayer.FindByID(ulong.Parse(clan.owner)) != null ? "в сети" : "не в сети";

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "0.81 0.81 0.81 1.00", Text = $"Общее количество участников клана: <color=#E0E0E0><b>{clan.members.Count}</b></color> , из них онлайн: <b><color=#E0E0E0>{clan.online}</color></b>\nСоздатель клана: <color=#E0E0E0><b>{clan.ownerName}</b></color>, он <color=#97D499><b>{clanLeaderStatus}</b></color>",
                                    Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 13 },
                                new CuiRectTransformComponent{ AnchorMin = $"0.4 0.88", AnchorMax = $"1 0.93" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.3 0.86", AnchorMax = $"0.7 0.8601" },
                            }
            });


            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 1", Text = $"КЛАНОВАЯ ОДЕЖДА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 25 },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0.8", AnchorMax = $"0.5 0.86" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 0.5", Text = $"Данные скины будут автоматически изменяться у участников клана", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 13 },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0.77", AnchorMax = $"0.5 0.82" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.4995 0.46", AnchorMax = $"0.5005 0.86" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 1", Text = $"ДОБЫЧА РЕСУРСОВ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 25 },
                                new CuiRectTransformComponent{ AnchorMin = $"0.5 0.8", AnchorMax = $"1 0.86" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 0.5", Text = $"Норма добычи ресурсов установлено лидером клана", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 13 },
                                new CuiRectTransformComponent{ AnchorMin = $"0.5 0.77", AnchorMax = $"1 0.82" },
                            }
            });



            container.Add(new CuiElement
            {
                Name = MainLayer + ".ClanAvatar",
                Parent = MainLayer,
                Components =
                    {
                        new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", clan.ClanAvatar), Color = "1 1 1 1"},
                        new CuiRectTransformComponent { AnchorMin = $"0.33 0.875", AnchorMax = $"0.39 0.975" }
                    }
            });
            if (clan.IsOwner(player.UserIDString))
                container.Add(new CuiElement
                {
                    Parent = MainLayer + ".ClanAvatar",
                    Components =
                            {
                                new CuiButtonComponent { Color = "0 0 0 0", Command = $"UI_CLAN edit {MainLayer + ".ClanAvatar"} clan_setAvatar" },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0", AnchorMax = $"1 1" },
                            }
                });

            container.Add(new CuiElement
            {
                Name = MainLayer + ".SkinList",
                Parent = MainLayer,
                Components =
                            {
                                new CuiImageComponent { Color = "1 1 1 0"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.03 0.49", AnchorMax = $"0.47 0.76" },
                            }
            });

            var skinsPos = GetPositions(6, 2, 0.01f, 0.02f, false);

            int skinCount = 0;

            foreach (var type in clan.SkinList)
            {
                foreach (var skin in type.Value)
                {
                    container.Add(new CuiElement
                    {
                        Name = MainLayer + ".SkinList" + skin.Key,
                        Parent = MainLayer + ".SkinList",
                        Components =
                            {
                                new CuiImageComponent { Color = "1 1 1 0.1"},
                                new CuiRectTransformComponent{ AnchorMin = skinsPos[skinCount].AnchorMin, AnchorMax = skinsPos[skinCount].AnchorMax },
                            }
                    });


                    container.Add(new CuiElement
                    {
                        Parent = MainLayer + ".SkinList" + skin.Key,
                        Components =
                            {
                                new CuiRawImageComponent { Color = "1 1 1 1", Png = (string)ImageLibrary?.Call("GetImage", skin.Key, skin.Value)},
                                new CuiRectTransformComponent{
                                    AnchorMin = "0.05 0.1",
                                    AnchorMax =  "0.95 0.9" },
                            }
                    });

                    string command = $"clans_getskinIds {skin.Key}";
                    if (clan.IsOwner(player.UserIDString))
                        container.Add(new CuiButton
                        {
                            Button = { Color = "0.43 0.68 0.42 0", Command = $"UI_CLAN edit {MainLayer + ".SkinList" + skin.Key} {command}" },
                            Text = { Text = $"" },
                            RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1" },
                        }, MainLayer + ".SkinList" + skin.Key);

                    skinCount++;
                }
            }

            container.Add(new CuiElement
            {
                Name = MainLayer + ".ResourseList",
                Parent = MainLayer,
                Components =
                            {
                                new CuiImageComponent { Color = "1 1 1 0"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.53 0.49", AnchorMax = $"0.97 0.76" },
                            }
            });

            var resourcePos = GetPositions(6, 2, 0.01f, 0.02f, false);

            int resourceCount = 0;


            foreach (var type in clan.Change.Take(12))
            {
                container.Add(new CuiElement
                {
                    Name = MainLayer + ".ResourseList" + type.Key,
                    Parent = MainLayer + ".ResourseList",
                    Components =
                    {
                        new CuiImageComponent {Color = "1 1 1 0.1"},
                        new CuiRectTransformComponent {AnchorMin = resourcePos[resourceCount].AnchorMin, AnchorMax = resourcePos[resourceCount].AnchorMax}
                    }
                });

                if (type.Value.Need > 0)
                {
                    var Anchor = GetPercentFUll(type.Value.Need, type.Value.Complete) / 100 >= 1 ?
                   0.99 :
                   GetPercentFUll(type.Value.Need, type.Value.Complete) / 100;

                    container.Add(new CuiButton
                    {
                        Button = { Color = "0.43 0.68 0.42 1.00", Command = "" },
                        Text = { Text = $"", },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 {Anchor}" },
                    }, MainLayer + ".ResourseList" + type.Key);


                }

                container.Add(new CuiElement
                {
                    Parent = MainLayer + ".ResourseList" + type.Key,
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", type.Key), Color = "1 1 1 1"},
                        new CuiRectTransformComponent { AnchorMin = "0.1 0.15", AnchorMax = "0.9 0.85" }
                    }
                });

                if (type.Value.Need > 0)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Color = "0.13 0.44 0.48 0", Command = "" },
                        Text = { Text = $"{GetPercent(type.Value.Need, type.Value.Complete)}%", Color = "1 1 1 1", FontSize = 22, Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }, MainLayer + ".ResourseList" + type.Key);
                }
                if (clan.IsOwner(player.UserIDString))
                    container.Add(new CuiButton
                    {
                        Button = { Color = "0.43 0.68 0.42 0", Command = $"UI_CLAN edit {MainLayer + ".ResourseList" + type.Key} clan_setChange" },
                        Text = { Text = $"" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1" },
                    }, MainLayer + ".ResourseList" + type.Key);

                resourceCount++;
            }

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.3 0.459", AnchorMax = $"0.7 0.46" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 1", Text = $"УЧАСТНИКИ КЛАНА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 25 },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0.4", AnchorMax = $"1 0.46" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 0.5", Text = $"Нажмите на одного из участников, чтобы получить дополнительную информацию. Онлайн игроки подсвечены <color=#97D499>зелёным</color> цветом", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 13 },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0.38", AnchorMax = $"1 0.42" },
                            }
            });

            container.Add(new CuiElement
            {
                Name = MainLayer + ".MemberList",
                Parent = MainLayer,
                Components =
                            {
                                new CuiImageComponent { Color = "1 1 1 0"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.05 0.13", AnchorMax = $"0.95 0.38" },
                            }
            });

            var membersPos = GetPositions(13, 2, 0.01f, 0.06f, false);

            int contMembers = 0;
            foreach (var member in clan.members)
            {
                var mem = covalence.Players.FindPlayerById(member.Key);
                if (mem == null) continue;

                var color = mem.IsConnected ? "0.59 0.83 0.60 1.00" : "0.81 0.55 0.55 1.00";

                container.Add(new CuiElement
                {
                    Name = MainLayer + ".MemberList" + member.Key,
                    Parent = MainLayer + ".MemberList",
                    Components =
                            {
                                new CuiImageComponent { Color = "1 1 1 0"},
                                new CuiRectTransformComponent{
                                    AnchorMin = membersPos[contMembers].AnchorMin,
                                    AnchorMax =  membersPos[contMembers].AnchorMax },
                                new CuiOutlineComponent{ Color = color, Distance = "3 -3" },
                            }
                });

                container.Add(new CuiElement
                {
                    Parent = MainLayer + ".MemberList" + member.Key,
                    Components =
                            {
                                new CuiRawImageComponent { Color = "1 1 1 1", Png = (string)ImageLibrary?.Call("GetImage", member.Key)},
                                new CuiRectTransformComponent{
                                    AnchorMin = "0 0",
                                    AnchorMax =  "0.99 1" },
                            }
                });

                container.Add(new CuiElement
                {
                    Parent = MainLayer + ".MemberList" + member.Key,
                    Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 1", Text =  GetPlayerStatus(member.Key, clan), Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 10 },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0.7", AnchorMax = $"1 0.99" },
                            }
                });

                container.Add(new CuiElement
                {
                    Parent = MainLayer + ".MemberList" + member.Key,
                    Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 1", Text =mem.Name, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 10 },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0", AnchorMax = $"1 0.3" },
                            }
                });


                container.Add(new CuiButton
                {
                    Button = { Color = "0.43 0.68 0.42 0", Command = $"UI_CLAN member {MainLayer + ".MemberList" + member.Key} {member.Key}" },
                    Text = { Text = $"" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1" },
                }, MainLayer + ".MemberList" + member.Key);
                contMembers++;
            }

            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "12 0 250 0.5", Text =  "ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 25 },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0.08", AnchorMax = $"1 0.12" },
                            }
            });


            container.Add(new CuiElement
            {
                Parent = MainLayer,
                Components =
                            {
                                new CuiTextComponent {
                                    Color = "1 1 1 0.5", Text = $"Лидеру клана, а так же модераторам доступна настройка скинов одежды, оружия и норма добычи ресурсов. Нажмите на иконку скина, или ресурса.".ToUpper(), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 13 },
                                new CuiRectTransformComponent{ AnchorMin = $"0 0", AnchorMax = $"1 0.09" },
                            }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = $"-35 -35", OffsetMax = "-10 -10" },
                Button = { Color = "0.929 0.882 0.847 0.6", Sprite = "assets/icons/close.png", Close = MainLayer },
                Text = { Text = "" }
            }, MainLayer);
            CuiHelper.AddUi(player, container);
        }


        [ConsoleCommand("UI_CLAN")]
        void cmdUIClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            if (!args.HasArgs()) return;
            var clan = findClanByUser(player.UserIDString);
            switch (args.Args[0])
            {
                case "edit":
                    if (!clan.IsOwner(player.UserIDString)) return;

                    string parrent = args.Args[1];
                    string command = args.FullString.Replace($"edit {parrent} ", "");
                    var shopname = command.Replace("clans_getskinIds ", "");
                    CuiElementContainer container = new CuiElementContainer();
                    container.Add(new CuiButton
                    {
                        Button = { Command = command, Color = "0.235 0.227 0.180 0.95", Sprite = "assets/content/ui/ui.background.tile.psd" },
                        Text = { Text = $"ИЗМЕНИТЬ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1" },
                    }, parrent, "UICLAN_edit" + shopname);
                    CuiHelper.DestroyUi(player, "UICLAN_edit" + shopname);
                    CuiHelper.AddUi(player, container);

                    break;
                case "member":
                    parrent = args.Args[1];
                    var user = args.Args[2];
                    container = new CuiElementContainer();
                    container.Add(new CuiElement
                    {
                        Name = "UICLAN_member",
                        Parent = parrent,
                        Components =
                    {
                        new CuiImageComponent {Color = "0.235 0.227 0.180 0.95", Sprite = "assets/content/ui/ui.background.tile.psd" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                    });

                    container.Add(new CuiButton
                    {
                        Button = { Color = "0.59 0.83 0.60 0.5", Command = $"UI_CLAN stats {user}" },
                        Text = { Text = $"СТАТИСТИКА", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 },
                        RectTransform = { AnchorMin = clan.IsOwner(player.UserIDString) && user != player.UserIDString ? "0 0.22" : "0 0", AnchorMax = clan.IsOwner(player.UserIDString) && user != player.UserIDString ? $"0.989 0.4" : $"0.989 0.2" },
                    }, "UICLAN_member");

                    if (clan.IsOwner(player.UserIDString) && user != player.UserIDString)
                    {
                        container.Add(new CuiButton
                        {
                            Button = { Color = "0.81 0.55 0.55 0.5", Command = $"clan_kickplayer {user}" },
                            Text = { Text = $"ВЫГНАТЬ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                            RectTransform = { AnchorMin = "0 0", AnchorMax = $"0.989 0.2" },
                        }, "UICLAN_member");
                    }

                    CuiHelper.DestroyUi(player, "UICLAN_member");
                    CuiHelper.AddUi(player, container);
                    break;

                case "close":
                    string closerParent = args.Args[1];
                    string closerMenu = args.Args[2];
                    CuiHelper.DestroyUi(player, closerParent);
                    CuiHelper.DestroyUi(player, closerMenu);
                    break;
                case "stats":
                    var playerStats = clan.GetPlayerStats(args.Args[1]);
                    if (playerStats == null) return;
                    CreatePlayerInfo(player, clan, playerStats, args.Args[1]);
                    break;
            }
        }


        void CreatePlayerInfo(BasePlayer player, Clan clan, PlayerStats stats, string userID)
        {
            bool ownerOrModerator = clan.owner == player.UserIDString || clan.IsModerator(player.UserIDString) ? true : false;

            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "UICLAN_stats",
                Parent = MainLayer,
                Components =
                    {
                        new CuiImageComponent {Color = "0 0 0 0.85", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats",
                Components =
                    {
                        new CuiButtonComponent {Color = "0.141 0.137 0.109 1", Sprite = "assets/content/ui/ui.background.transparent.radial.psd", Command = $"UI_CLAN close UICLAN_stats UICLAN_member"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats",
                Components =
                    {
                        new CuiTextComponent { Text = $"СТАТИСТИКА ИГРОКА {clan.GetIMember(userID).Name.ToUpper()}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 25},
                        new CuiRectTransformComponent { AnchorMin = "0 0.8", AnchorMax = "1 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Name = "UICLAN_stats.Block",
                Parent = "UICLAN_stats",
                Components =
                    {
                        new CuiImageComponent {Color = "0 0 0 0"},
                        new CuiRectTransformComponent {AnchorMin = "0.2 0.2", AnchorMax = "0.8 0.8"}
                    }
            });



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                            {
                                new CuiRawImageComponent { Color = "1 1 1 1", Png = (string)ImageLibrary?.Call("GetImage", userID)},
                                new CuiRectTransformComponent{
                                    AnchorMin = "0 0.5",
                                    AnchorMax =  "0.3 1" },
                            }
            });

            if (ownerOrModerator)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = clan.moderators.Contains(userID) ? "0.81 0.55 0.55 0.7" : "0.59 0.83 0.60 0.7", Command = clan.moderators.Contains(userID) ? $"clanui_promote demote {userID}" : $"clanui_promote promote {userID}" },
                    Text = { Text = clan.moderators.Contains(userID) ? "УБРАТЬ МОДЕРАТОРА" : "НАЗНАЧИТЬ МОДЕРАТОРОМ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                    RectTransform = { AnchorMin = $"0 0.39", AnchorMax = $"0.3 0.49" },
                }, "UICLAN_stats.Block");


                container.Add(new CuiButton
                {
                    Button = { Color = clan.owner != userID ? "0.74 0.39 0.39 0.7" : "1 1 1 0.1", Command = clan.owner != userID ? $"clan_kickplayer {userID}" : "" },
                    Text = { Text = "ВЫГНАТЬ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                    RectTransform = { AnchorMin = $"0 0.28", AnchorMax = $"0.3 0.385" },
                }, "UICLAN_stats.Block");
            }



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"УБИЙСТВ\n<size=17>{stats.Killed}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.35 0.9", AnchorMax = "0.5 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"СМЕРТЕЙ\n<size=17>{stats.Death}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.9", AnchorMax = "0.65 1" },
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"СБИТО ВЕРТОЛЁТОВ\n<size=17>{stats.KilledHeli}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.65 0.9", AnchorMax = "0.90 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"СУИЦИДОВ\n<size=17>{stats.Suicide}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.9 0.9", AnchorMax = "1.05 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"СУИЦИДОВ\n<size=17>{stats.Suicide}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 19},
                        new CuiRectTransformComponent { AnchorMin = "0.9 0.9", AnchorMax = "1.05 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.2 0.86", AnchorMax = $"0.8 0.8601" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.4 0.88", AnchorMax = $"1 0.8801" },
                            }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"ДОБЫЧА", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 23},
                        new CuiRectTransformComponent { AnchorMin = "0.35 0.8", AnchorMax = "1.05 0.86" },
                    }
            });






            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Name = "UICLAN_stats.Gather",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 0"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.3 0.5", AnchorMax = $"1.1 0.8" },
                            }
            });

            int i = 0;
            var pos = GetPositions(4, 3, 0.1f, 0.01f);
            foreach (var item in stats.GatherInfo)
            {
                if (!RewardTranslate.ContainsKey(item.Key)) continue;
                var name = RewardTranslate[item.Key];

                container.Add(new CuiElement
                {
                    Parent = "UICLAN_stats.Gather",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{name}\n<size=13>{item.Value}</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15},
                        new CuiRectTransformComponent { AnchorMin = pos[i].AnchorMin, AnchorMax = pos[i].AnchorMax},
                    }
                });

                i++;
            }

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 1.00"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.4 0.45", AnchorMax = $"1 0.451" },
                            }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Components =
                    {
                        new CuiTextComponent { Text = $"АВТОРИЗАЦИЯ СОКЛАНОВ", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 23},
                        new CuiRectTransformComponent { AnchorMin = "0.35 0.35", AnchorMax = "1.05 0.45" },
                    }
            });



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Block",
                Name = "UICLAN_stats.Auth",
                Components =
                            {
                                new CuiImageComponent { Color = "0.81 0.81 0.81 0"},
                                new CuiRectTransformComponent{ AnchorMin = $"0.3 0.25", AnchorMax = $"1.1 0.36" },
                            }
            });



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Components =
                    {
                        new CuiTextComponent { Text = $"ШКАФЫ", Color = "1 1 1 1", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 18},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0.2 1" },
                    }
            });


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Name = "UICLAN_stats.Auth_cup",
                Components =
                    {
                        new CuiImageComponent {  Color = "1 1 1 0.1"},
                        new CuiRectTransformComponent { AnchorMin = $"0.01 0", AnchorMax = $"0.2 0.5"},
                    }
            });


            container.Add(new CuiButton
            {
                Button = { Color = clan.members[userID].CupAuth ? "0.59 0.83 0.60 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers cup true" : "" },
                Text = { Text = "ВКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.49 0.98" },
            }, "UICLAN_stats.Auth_cup");

            container.Add(new CuiButton
            {
                Button = { Color = !clan.members[userID].CupAuth ? "0.81 0.55 0.55 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers cup false" : "" },
                Text = { Text = "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0.51 0", AnchorMax = $"1 0.98" },
            }, "UICLAN_stats.Auth_cup");



            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Components =
                    {
                        new CuiTextComponent { Text = $"ЗАМКИ", Color = "1 1 1 1", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 18},
                        new CuiRectTransformComponent { AnchorMin = "0.4 0", AnchorMax = "0.6 1" },
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Name = "UICLAN_stats.Auth_code",
                Components =
                    {
                        new CuiImageComponent {  Color = "1 1 1 0.1"},
                        new CuiRectTransformComponent { AnchorMin = $"0.4 0", AnchorMax = $"0.6 0.5"},
                    }
            });


            container.Add(new CuiButton
            {
                Button = { Color = clan.members[userID].CodeAuth ? "0.59 0.83 0.60 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers code true" : "" },
                Text = { Text = "ВКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.49 0.98" },
            }, "UICLAN_stats.Auth_code");

            container.Add(new CuiButton
            {
                Button = { Color = !clan.members[userID].CodeAuth ? "0.81 0.55 0.55 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers code false" : "" },
                Text = { Text = "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0.51 0", AnchorMax = $"1 0.98" },
            }, "UICLAN_stats.Auth_code");


            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Components =
                    {
                        new CuiTextComponent { Text = $"ТУРЕЛИ", Color = "1 1 1 1", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 18},
                        new CuiRectTransformComponent { AnchorMin = "0.8 0", AnchorMax = "1 1" },
                    }
            });

            container.Add(new CuiElement
            {
                Parent = "UICLAN_stats.Auth",
                Name = "UICLAN_stats.Auth_turret",
                Components =
                    {
                        new CuiImageComponent {  Color = "1 1 1 0.1"},
                        new CuiRectTransformComponent { AnchorMin = $"0.8 0", AnchorMax = $"1 0.5"},
                    }
            });


            container.Add(new CuiButton
            {
                Button = { Color = clan.members[userID].TurretAuth ? "0.59 0.83 0.60 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers turret true" : "" },
                Text = { Text = "ВКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.49 0.98" },
            }, "UICLAN_stats.Auth_turret");

            container.Add(new CuiButton
            {
                Button = { Color = !clan.members[userID].TurretAuth ? "0.81 0.55 0.55 0.7" : "1 1 1 0.1", Command = player.UserIDString == userID ? "clans_authplayers turret false" : "" },
                Text = { Text = "ВЫКЛ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 },
                RectTransform = { AnchorMin = $"0.51 0", AnchorMax = $"1 0.98" },
            }, "UICLAN_stats.Auth_turret");

            CuiHelper.DestroyUi(player, "UICLAN_stats");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("clans_authplayers")]
        void cmdAuthPlayerInClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            var playerStats = clan.GetPlayerStats(player.UserIDString);
            if (playerStats == null) return;
            bool current;
            if (!bool.TryParse(args.Args[1], out current)) return;
            switch (args.Args[0])
            {
                case "cup":
                    playerStats.CupAuth = current;

                    AutOnBuildingPrivilage<BuildingPrivlidge>(player,
                         clan,
                            (where, user) =>
                            {
                                if (current)
                                    where.authorizedPlayers.Add(new PlayerNameID
                                    {
                                        userid = ulong.Parse(user),
                                        username = ""
                                    });
                                else
                                    where.authorizedPlayers.RemoveAll(x => x.userid.ToString() == user);
                                where.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            });


                    break;
                case "code":
                    playerStats.CodeAuth = current;

                    break;
                case "turret":
                    playerStats.TurretAuth = current;
                    break;
            }
            CreatePlayerInfo(player, clan, playerStats, player.UserIDString);
        }

        void cmdClanOverview(BasePlayer player)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();

            string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color={pluginPrefixREBORNColor}>\n</color></size>" : "\n";
            sb.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");

            if (myClan == null)
            {
                sb.AppendLine(string.Format(msg("notmember", current.Id)));
                sb.AppendLine(string.Format(msg("viewthehelp", current.Id), colorCmdUsage, $"{chatCommandClan + "help"} | /{chatCommandClan}"));
                SendReply(player, $"<color={colorTextMsg}>{sb.ToString().TrimEnd()}</color>");
                return;
            }
            NewClanUI(player);
            if (myClan.IsOwner(current.Id)) sb.Append(string.Format(msg("youareownerof", current.Id)));
            else if (myClan.IsCouncil(current.Id)) sb.Append(string.Format(msg("youarecouncilof", current.Id)));
            else if (myClan.IsModerator(current.Id)) sb.Append(string.Format(msg("youaremodof", current.Id)));
            else sb.Append(string.Format(msg("youarememberof", current.Id)));
            sb.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.online}/{myClan.total} )");
            sb.Append(string.Format(msg("memberon", current.Id)));
            int n = 0;
            foreach (var memberId in myClan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && op.IsConnected)
                {
                    var memberName = op.Name;
                    if (op.Name == current.Name) memberName = msg("yourname", current.Id);
                    if (n > 0) sb.Append(", ");
                    var memberOn = string.Empty;
                    if (myClan.IsOwner(memberId.Key))
                    {
                        memberOn = string.Format(msg("overviewnamecolor", current.Id), clanOwnerColor, memberName);
                    }
                    else if (myClan.IsCouncil(memberId.Key))
                    {
                        memberOn = string.Format(msg("overviewnamecolor", current.Id), clanCouncilColor, memberName);
                    }
                    else if (myClan.IsModerator(memberId.Key))
                    {
                        memberOn = string.Format(msg("overviewnamecolor", current.Id), clanModeratorColor, memberName);
                    }
                    else
                    {
                        memberOn = string.Format(msg("overviewnamecolor", current.Id), clanMemberColor, memberName);
                    }
                    ++n;
                    sb.Append(memberOn);
                }
            }
            if (n > 0) sb.AppendLine();
            bool offline = false;
            foreach (var memberId in myClan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && !op.IsConnected)
                {
                    offline = true;
                    break;
                }
            }
            if (offline)
            {
                sb.Append(string.Format(msg("memberoff", current.Id)));
                n = 0;
                foreach (var memberId in myClan.members)
                {
                    var p = this.covalence.Players.FindPlayerById(memberId.Key);
                    var memberOff = string.Empty;
                    if (p != null && !p.IsConnected)
                    {
                        if (n > 0) sb.Append(", ");
                        if (myClan.IsOwner(memberId.Key))
                        {
                            memberOff = string.Format(msg("overviewnamecolor", current.Id), clanOwnerColor, p.Name);
                        }
                        else if (myClan.IsCouncil(memberId.Key))
                        {
                            memberOff = string.Format(msg("overviewnamecolor", current.Id), clanCouncilColor, p.Name);
                        }
                        else if (myClan.IsModerator(memberId.Key))
                        {
                            memberOff = string.Format(msg("overviewnamecolor", current.Id), clanModeratorColor, p.Name);
                        }
                        else
                        {
                            memberOff = string.Format(msg("overviewnamecolor", current.Id), clanMemberColor, p.Name);
                        }
                        ++n;
                        sb.Append(memberOff);
                    }
                }
                if (n > 0) sb.AppendLine();
            }
            if ((myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id) || myClan.IsModerator(current.Id)) && myClan.invites.Count() > 0)
            {
                sb.Append(string.Format(msg("pendinvites", current.Id)));
                int m = 0;
                foreach (var inviteId in myClan.invites)
                {
                    var p = this.covalence.Players.FindPlayerById(inviteId.Key);
                    if (p != null)
                    {
                        var invitedPlayer = string.Empty;
                        if (m > 0) sb.Append(", ");
                        invitedPlayer = string.Format(msg("overviewnamecolor", current.Id), clanMemberColor, p.Name);
                        ++m;
                        sb.Append(invitedPlayer);
                    }
                }
                if (m > 0) sb.AppendLine();
            }
            if (enableClanAllies && myClan.clanAlliances.Count() > 0) sb.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");
            if (enableClanAllies && (myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
            {
                if (myClan.invitedAllies.Count() > 0) sb.AppendLine(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");
                if (myClan.pendingInvites.Count() > 0) sb.AppendLine(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");
                if (myClan.pendingInvites.Count() == 0 && myClan.invitedAllies.Count() == 0) sb.AppendLine();
            }
            if (enableFFOPtion) sb.AppendLine(string.Format(msg("yourffstatus", current.Id)) + " " + (manuallyEnabledBy.Contains(player.userID) ? $"<color={colorClanFFOn}>ON</color>" : $"<color={colorClanFFOff}>OFF</color>") + $" ( <color={colorCmdUsage}>/{chatCommandFF}</color> )");
            if ((enableClanRadar && !usePermissionClanRadar) || enableClanRadar && usePermissionClanRadar && permission.UserHasPermission(current.Id, permissionClanRadarUse)) sb.AppendLine(string.Format(msg("yourradarstatus", current.Id)) + " " + (player.GetComponent<ClanRadar>() ? $"<color={colorClanRadarOn}>ON</color>" : $"<color={colorClanRadarOff}>OFF</color>") + $" ( <color={colorCmdUsage}>/{chatCommandRadar}</color> )");
            sb.AppendLine(string.Format(msg("viewthehelp", current.Id), colorCmdUsage, $"{string.Concat(chatCommandClan, subCommandClanHelp)} | /{chatCommandClan}"));
            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";
            string[] parts = sb.ToString().Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
            sb = new StringBuilder();
            foreach (var part in parts)
            {
                if ((sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length) > 1050)
                {
                    SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
                    sb.Clear();
                }
                sb.AppendLine(part);
            }
            SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
        }
        void cmdClanCreate(BasePlayer player, string[] ar