he default value for all non-licensed)" : "Рейтинг использования топлива при переплавки(Если включен список - это значение будет стандартное для всех у кого нет прав)")]
                    public Int32 SpeedFuelBurnable = 1;
                    [JsonProperty(LanguageEn ? "Enable list of melting speed in furnaces (true - yes/false - no)" : "Включить список скорости плавки в печах(true - да/false - нет)")]
                    public Boolean UseSpeedBurnableList;
                    [JsonProperty(LanguageEn ? "Setting the melting speed in furnaces by privileges" : "Настройка скорости плавки в печах по привилегиям")]
                    public List<SpeedBurnablePreset> SpeedBurableList = new List<SpeedBurnablePreset>();
                    internal class DayAnNightRate
                    {
                        [JsonProperty(LanguageEn ? "Ranking setting during the day" : "Настройка рейтинга днем")]
                        public AllRates DayRates = new AllRates();
                        [JsonProperty(LanguageEn ? "Setting the rating at night" : "Настройка рейтинга ночью")]
                        public AllRates NightRates = new AllRates();
                    }
                    internal class SpeedBurnablePreset
                    {
                        [JsonProperty(LanguageEn ? "Permissions" : "Права")]
                        public String Permissions;
                        [JsonProperty(LanguageEn ? "Furnace melting speed" : "Скорость плавки печей")]
                        public Single SpeedBurnable;
                        [JsonProperty(LanguageEn ? "Smelting Fuel Use Rating" : "Рейтинг использования топлива при переплавки")]
                        public Int32 SpeedFuelBurnable = 1;
                    }
                    internal class PermissionsRate
                    {
                        [JsonProperty(LanguageEn ? "Ranking setting during the day" : "Настройка рейтинга днем")]
                        public Dictionary<String, List<PermissionsRateDetalis>> DayRates = new Dictionary<String, List<PermissionsRateDetalis>>();
                        [JsonProperty(LanguageEn ? "Setting the rating at night" : "Настройка рейтинга ночью")]
                        public Dictionary<String, List<PermissionsRateDetalis>> NightRates = new Dictionary<String, List<PermissionsRateDetalis>>();
                        public class PermissionsRateDetalis
                        {
                            [JsonProperty(LanguageEn ? "Shortname" : "Shortname")]
                            public String Shortname;
                            [JsonProperty(LanguageEn ? "Rate" : "Рейтинг")]
                            public Single Rate;
                        }
                    }
                    internal class AllRates
                    {
                        [JsonProperty(LanguageEn ? "Rating of extracted resources" : "Рейтинг добываемых ресурсов")]
                        public Single GatherRate;
                        [JsonProperty(LanguageEn ? "Rating of found items" : "Рейтинг найденных предметов")]
                        public Single LootRate;
                        [JsonProperty(LanguageEn ? "Pickup Rating" : "Рейтинг поднимаемых предметов")]
                        public Single PickUpRate;
                        [JsonProperty(LanguageEn ? "Rating of plants raised from the beds" : "Рейтинг поднимаемых растений с грядок")]
                        public Single GrowableRate = 1.0f;
                        [JsonProperty(LanguageEn ? "Quarry rating" : "Рейтинг карьеров")]
                        public Single QuarryRate;
                        [JsonProperty(LanguageEn ? "Excavator Rating" : "Рейтинг экскаватора")]
                        public Single ExcavatorRate;
                        [JsonProperty(LanguageEn ? "Coal drop chance" : "Шанс выпадения угля")]
                        public Single CoalRare;
                    }
                }
                internal class OtherSettings
                {
                    [JsonProperty(LanguageEn ? "Event settings on the server" : "Настройки ивентов на сервере")]
                    public EventSettings EventSetting = new EventSettings();   
                    [JsonProperty(LanguageEn ? "Fuel settings when buying vehicles from NPCs" : "Настройки топлива при покупке транспорта у NPC")]
                    public FuelSettings FuelSetting = new FuelSettings();

                    internal class FuelSettings
                    {
                        [JsonProperty(LanguageEn ? "Amount of fuel for boats" : "Кол-во топлива у лодок")]
                        public Int32 AmountBoat = 200;
                        [JsonProperty(LanguageEn ? "The amount of fuel in submarines" : "Кол-во топлива у подводных лодок")]
                        public Int32 AmountSubmarine = 200;
                        [JsonProperty(LanguageEn ? "Minicopter fuel quantity" : "Кол-во топлива у миникоптера")]
                        public Int32 AmountMinicopter = 200;
                        [JsonProperty(LanguageEn ? "Helicopter fuel quantity" : "Кол-во топлива у вертолета")]
                        public Int32 AmountScrapTransport = 200;
                    }

                    [JsonProperty(LanguageEn ? "Use Time Acceleration" : "Использовать ускорение времени")]
                    public Boolean UseTime;
                    [JsonProperty(LanguageEn ? "Use time freeze (the time will be the one you set in the item &lt;Frozen time on the server&gt;)" : "Использовать заморозку времени(время будет такое, какое вы установите в пунке <Замороженное время на сервере>)")]
                    public Boolean UseFreezeTime;
                    [JsonProperty(LanguageEn ? "Frozen time on the server (Set time that will not change and be forever on the server, must be true on &lt;Use time freeze&gt;" : "Замороженное время на сервере (Установите время, которое не будет изменяться и будет вечно на сервере, должен быть true на <Использовать заморозку времени>")]
                    public Int32 FreezeTime;
                    [JsonProperty(LanguageEn ? "What time will the day start?" : "Укажите во сколько будет начинаться день")]
                    public Int32 DayStart;
                    [JsonProperty(LanguageEn ? "What time will the night start?" : "Укажите во сколько будет начинаться ночь")]
                    public Int32 NightStart;
                    [JsonProperty(LanguageEn ? "Specify how long the day will be in minutes" : "Укажите сколько будет длится день в минутах")]
                    public Int32 DayTime;
                    [JsonProperty(LanguageEn ? "Specify how long the night will last in minutes" : "Укажите сколько будет длится ночь в минутах")]
                    public Int32 NightTime;

                    [JsonProperty(LanguageEn ? "Use notification of players about the change of day and night (switching rates. The message is configured in the lang)" : "Использовать уведомление игроков о смене дня и ночи (переключение рейтов. Сообщение настраивается в лэнге)")]
                    public Boolean UseAlertDayNight = true;
                    [JsonProperty(LanguageEn ? "Enable the ability to completely skip the time of day (selected in the paragraph below)" : "Включить возможность полного пропуска времени суток(выбирается в пункте ниже)")]
                    public Boolean UseSkipTime = true;
                    [JsonProperty(LanguageEn ? "Select the type of time-of-day skip (0 - Skip day, 1 - Skip night)" : "Выберите тип пропуска времени суток (0 - Пропускать день, 1 - Пропускать ночь)(Не забудьте включить возможность полного пропуска времени суток)")]
                    public SkipType TypeSkipped = SkipType.Night;

                    internal class EventSettings
                    {
                        [JsonProperty(LanguageEn ? "Helicopter spawn custom settings" : "Кастомные настройки спавна вертолета")]
                        public Setting HelicopterSetting = new Setting();
                        [JsonProperty(LanguageEn ? "Custom tank spawn settings" : "Кастомные настройки спавна танка")]
                        public Setting BreadlaySetting = new Setting();
                        [JsonProperty(LanguageEn ? "Custom ship spawn settings" : "Кастомные настройки спавна корабля")]
                        public Setting CargoShipSetting = new Setting();
                        [JsonProperty(LanguageEn ? "Airdrop spawn custom settings" : "Кастомные настройки спавна аирдропа")]
                        public Setting CargoPlaneSetting = new Setting();
                        [JsonProperty(LanguageEn ? "Chinook custom spawn settings" : "Кастомные настройки спавна чинука")]
                        public Setting ChinoockSetting = new Setting();
                        internal class Setting
                        {
                            [JsonProperty(LanguageEn ? "Completely disable event spawning on the server (true - yes/false - no)" : "Полностью отключить спавн ивента на сервере(true - да/false - нет)")]
                            public Boolean FullOff;
                            [JsonProperty(LanguageEn ? "Enable custom spawn event (true - yes/false - no)" : "Включить кастомный спавн ивент(true - да/false - нет)")]
                            public Boolean UseEventCustom;
                            [JsonProperty(LanguageEn ? "Static event spawn time" : "Статическое время спавна ивента")]
                            public Int32 EventSpawnTime;
                            [JsonProperty(LanguageEn ? "Random spawn time settings" : "Настройки случайного времени спавна")]
                            public RandomingTime RandomTimeSpawn = new RandomingTime();
                            internal class RandomingTime
                            {
                                [JsonProperty(LanguageEn ? "Use random event spawn time (static time will not be taken into account) (true - yes/false - no)" : "Использовать случайное время спавно ивента(статическое время не будет учитываться)(true - да/false - нет)")]
                                public Boolean UseRandomTime;
                                [JsonProperty(LanguageEn ? "Minimum event spawn value" : "Минимальное значение спавна ивента")]
                                public Int32 MinEventSpawnTime;
                                [JsonProperty(LanguageEn ? "Max event spawn value" : "Максимальное значении спавна ивента")]
                                public Int32 MaxEventSpawnTime;
                            }
                        }
                    }
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    pluginSettings = new PluginSettings
                    {
                        ReferenceSettings = new PluginSettings.ReferencePlugin
                        {
                            IQChatSetting = new PluginSettings.ReferencePlugin.IQChatReference
                            {
                                CustomAvatar = "0",
                                CustomPrefix = "[IQRates]",
                                UIAlertUse = false,
                            },
                        },
                        RateSetting = new PluginSettings.Rates
                        {
                            UseSpeedBurnable = true,
                            SpeedBurnable = 3.5f,
                            SpeedFuelBurnable = 2,
                            BlackListBurnable = new List<String>
                            {
                                "wolfmeat.cooked",
                                "deermeat.cooked",
                                "meat.pork.cooked",
                                "humanmeat.cooked",
                                "chicken.cooked",
                                "bearmeat.cooked",
                                "horsemeat.cooked",
                            },
                            UseSpeedBurnableList = true,
                            SpeedBurableList = new List<PluginSettings.Rates.SpeedBurnablePreset>
                            {
                                new PluginSettings.Rates.SpeedBurnablePreset
                                {
                                    Permissions = "iqrates.vip",
                                    SpeedBurnable = 5.0f,
                                    SpeedFuelBurnable = 20,
                                },
                                new PluginSettings.Rates.SpeedBurnablePreset
                                {
                                    Permissions = "iqrates.speedrun",
                                    SpeedBurnable = 55.0f,
                                    SpeedFuelBurnable = 20,
                                },
                                new PluginSettings.Rates.SpeedBurnablePreset
                                {
                                    Permissions = "iqrates.fuck",
                                    SpeedBurnable = 200f,
                                    SpeedFuelBurnable = 20,
                                },
                            },
                            DayRates = new PluginSettings.Rates.AllRates
                            {
                                GatherRate = 1.0f,
                                LootRate = 1.0f,
                                PickUpRate = 1.0f,
                                GrowableRate = 1.0f,
                                QuarryRate = 1.0f,
                                ExcavatorRate = 1.0f,
                                CoalRare = 10,
                            },
                            NightRates = new PluginSettings.Rates.AllRates
                            {
                                GatherRate = 2.0f,
                                LootRate = 2.0f,
                                PickUpRate = 2.0f,
                                GrowableRate = 2.0f,
                                QuarryRate = 2.0f,
                                ExcavatorRate = 2.0f,
                                CoalRare = 15,
                            },
                            CustomRatesPermissions = new PluginSettings.Rates.PermissionsRate
                            {
                                DayRates = new Dictionary<String, List<PluginSettings.Rates.PermissionsRate.PermissionsRateDetalis>>
                                {
                                    ["iqrates.gg"] = new List<PluginSettings.Rates.PermissionsRate.PermissionsRateDetalis>
                                    {
                                        new PluginSettings.Rates.PermissionsRate.PermissionsRateDetalis
                                        {
                                            Rate = 200.0f,
                                            Shortname = "wood",
                                        },
                                        new PluginSettings.Rates.PermissionsRate.PermissionsRateDetalis
                                        {
                                              Rate = 200.0f,
                                              Shortname = "stones",
                                        }
                                    }
                                },
                                NightRates = new Dictionary<string, List<PluginSettings.Rates.PermissionsRate.PermissionsRateDetalis>>
                                {
                                    ["iqrates.gg"] = new List<PluginSettings.Rates.PermissionsRate.PermissionsRateDetalis>
                                    {
                                        new PluginSettings.Rates.PermissionsRate.PermissionsRateDetalis
                                        {
                                            Rate = 400.0f,
                                            Shortname = "wood",
                                        },
                                        new PluginSettings.Rates.PermissionsRate.PermissionsRateDetalis
                                        {
                                              Rate = 400.0f,
                                              Shortname = "stones",
                                        }
                                    }
                                },
                            },
                            PrivilegyRates = new Dictionary<string, PluginSettings.Rates.DayAnNightRate>
                            {
                                ["iqrates.vip"] = new PluginSettings.Rates.DayAnNightRate
                                {
                                    DayRates =
                                    {
                                        GatherRate = 3.0f,
                                        LootRate = 3.0f,
                                        PickUpRate = 3.0f,
                                        QuarryRate = 3.0f,
                                        GrowableRate = 3.0f,
                                        ExcavatorRate = 3.0f,
                                        CoalRare = 15,
                                    },
                                    NightRates = new PluginSettings.Rates.AllRates
                                    {
                                        GatherRate = 13.0f,
                                        LootRate = 13.0f,
                                        PickUpRate = 13.0f,
                                        GrowableRate = 13.0f,
                                        QuarryRate = 13.0f,
                                        ExcavatorRate = 13.0f,
                                        CoalRare = 25,
                                    }
                                },
                                ["iqrates.premium"] = new PluginSettings.Rates.DayAnNightRate
                                {
                                    DayRates =
                                    {
                                        GatherRate = 3.5f,
                                        LootRate = 3.5f,
                                        PickUpRate = 3.5f,
                                        GrowableRate = 3.5f,
                                        QuarryRate = 3.5f,
                                        ExcavatorRate = 3.5f,
                                        CoalRare = 20,
                                    },
                                    NightRates = new PluginSettings.Rates.AllRates
                                    {
                                        GatherRate = 13.5f,
                                        LootRate = 13.5f,
                                        PickUpRate = 13.5f,
                                        GrowableRate = 13.5f,
                                        QuarryRate = 13.5f,
                                        ExcavatorRate = 13.5f,
                                        CoalRare = 20,
                                    }
                                },
                            },
                            BlackList = new List<String>
                            {
                                "sulfur.ore",
                            },
                        },
                        OtherSetting = new PluginSettings.OtherSettings
                        {
                            UseAlertDayNight = true,
                            UseSkipTime = true,
                            TypeSkipped = SkipType.Night,
                            UseTime = false,
                            FreezeTime = 12,
                            UseFreezeTime = true,
                            DayStart = 10,
                            NightStart = 22,
                            DayTime = 5,
                            NightTime = 1,
                            FuelSetting = new PluginSettings.OtherSettings.FuelSettings
                            {
                                AmountBoat = 200,
                                AmountMinicopter = 200,
                                AmountScrapTransport = 200,
                                AmountSubmarine = 200
                            },
                            EventSetting = new PluginSettings.OtherSettings.EventSettings
                            {
                                BreadlaySetting = new PluginSettings.OtherSettings.EventSettings.Setting
                                {
                                    FullOff = false,
                                    UseEventCustom = true,
                                    EventSpawnTime = 3000,
                                    RandomTimeSpawn = new PluginSettings.OtherSettings.EventSettings.Setting.RandomingTime
                                    {
                                        UseRandomTime = false,
                                        MaxEventSpawnTime = 3000,
                                        MinEventSpawnTime = 1000,
                                    },
                                },
                                CargoPlaneSetting = new PluginSettings.OtherSettings.EventSettings.Setting
                                {
                                    FullOff = false,
                                    UseEventCustom = true,
                                    EventSpawnTime = 5000,
                                    RandomTimeSpawn = new PluginSettings.OtherSettings.EventSettings.Setting.RandomingTime
                                    {
                                        UseRandomTime = false,
                                        MaxEventSpawnTime = 3000,
                                        MinEventSpawnTime = 1000,
                                    },
                                },
                                CargoShipSetting = new PluginSettings.OtherSettings.EventSettings.Setting
                                {
                                    FullOff = false,
                                    UseEventCustom = true,
                                    EventSpawnTime = 0,
                                    RandomTimeSpawn = new PluginSettings.OtherSettings.EventSettings.Setting.RandomingTime
                                    {
                                        UseRandomTime = true,
                                        MaxEventSpawnTime = 3000,
                                        MinEventSpawnTime = 8000,
                                    },
                                },
                                ChinoockSetting = new PluginSettings.OtherSettings.EventSettings.Setting
                                {
                                    FullOff = true,
                                    UseEventCustom = false,
                                    EventSpawnTime = 3000,
                                    RandomTimeSpawn = new PluginSettings.OtherSettings.EventSettings.Setting.RandomingTime
                                    {
                                        UseRandomTime = false,
                                        MaxEventSpawnTime = 3000,
                                        MinEventSpawnTime = 1000,
                                    },
                                },
                                HelicopterSetting = new PluginSettings.OtherSettings.EventSettings.Setting
                                {
                                    FullOff = true,
                                    UseEventCustom = false,
                                    EventSpawnTime = 3000,
                                    RandomTimeSpawn = new PluginSettings.OtherSettings.EventSettings.Setting.RandomingTime
                                    {
                                        UseRandomTime = false,
                                        MaxEventSpawnTime = 3000,
                                        MinEventSpawnTime = 1000,
                                    },
                                },
                            }
                        },
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {                       
                PrintWarning(LanguageEn ? "Error #3314013" + $"read configuration 'oxide/config/{Name}', create a new configuration!!" : "Ошибка #3314013" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!"); //#333
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Metods
        public void Register(string Permissions)
        {
            if (!String.IsNullOrWhiteSpace(Permissions))
                if (!permission.PermissionExists(Permissions, this))
                    permission.RegisterPermission(Permissions, this);
        }

        #region Events
        private const string prefabCH47 = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";
        private const string prefabPlane = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        private const string prefabShip = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab";
        private const string prefabPatrol = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

        private Int32 GetRandomTime(Int32 Min, Int32 Max) => UnityEngine.Random.Range(Min, Max);
        void StartEvent()
        {
            var EventSettings = config.pluginSettings.OtherSetting.EventSetting;
            StartCargoShip(EventSettings);
            StartCargoPlane(EventSettings);
            StartBreadley(EventSettings);
            StartChinoock(EventSettings);
            StartHelicopter(EventSettings);
        }
        private void StartCargoShip(Configuration.PluginSettings.OtherSettings.EventSettings EventSettings)
        {
            if (!EventSettings.CargoShipSetting.FullOff && EventSettings.CargoShipSetting.UseEventCustom)
            {
                Int32 TimeSpawn = EventSettings.CargoShipSetting.RandomTimeSpawn.UseRandomTime ? GetRandomTime(EventSettings.CargoShipSetting.RandomTimeSpawn.MinEventSpawnTime, EventSettings.CargoShipSetting.RandomTimeSpawn.MaxEventSpawnTime) : EventSettings.CargoShipSetting.EventSpawnTime;
                timer.Once(TimeSpawn, () =>
                {
                    StartCargoShip(EventSettings);
                    SpawnCargo();
                });
            }
        }
        private void StartCargoPlane(Configuration.PluginSettings.OtherSettings.EventSettings EventSettings)
        {
            if (!EventSettings.CargoPlaneSetting.FullOff && EventSettings.CargoPlaneSetting.UseEventCustom)
            {
                Int32 TimeSpawn = EventSettings.CargoPlaneSetting.RandomTimeSpawn.UseRandomTime ? GetRandomTime(EventSettings.CargoPlaneSetting.RandomTimeSpawn.MinEventSpawnTime, EventSettings.CargoPlaneSetting.RandomTimeSpawn.MaxEventSpawnTime) : EventSettings.CargoPlaneSetting.EventSpawnTime;
                timer.Once(TimeSpawn, () =>
                {
                    StartCargoPlane(EventSettings);
                    SpawnPlane();
                });
            }
        }
        private void StartBreadley(Configuration.PluginSettings.OtherSettings.EventSettings EventSettings)
        {
            if (SpacePort == null) return;
            if (!EventSettings.BreadlaySetting.FullOff && EventSettings.BreadlaySetting.UseEventCustom)
            {
                Int32 TimeSpawn = EventSettings.BreadlaySetting.RandomTimeSpawn.UseRandomTime ? GetRandomTime(EventSettings.BreadlaySetting.RandomTimeSpawn.MinEventSpawnTime, EventSettings.BreadlaySetting.RandomTimeSpawn.MaxEventSpawnTime) : EventSettings.BreadlaySetting.EventSpawnTime;
                timer.Once(TimeSpawn, () =>
                {
                    StartBreadley(EventSettings);
                    SpawnTank();
                });
            }
        }
        private void StartChinoock(Configuration.PluginSettings.OtherSettings.EventSettings EventSettings)
        {
            if (!EventSettings.ChinoockSetting.FullOff && EventSettings.ChinoockSetting.UseEventCustom)
            {
                Int32 TimeSpawn = EventSettings.ChinoockSetting.RandomTimeSpawn.UseRandomTime ? GetRandomTime(EventSettings.ChinoockSetting.RandomTimeSpawn.MinEventSpawnTime, EventSettings.ChinoockSetting.RandomTimeSpawn.MaxEventSpawnTime) : EventSettings.ChinoockSetting.EventSpawnTime;
                timer.Once(TimeSpawn, () =>
                {
                    StartChinoock(EventSettings);
                    SpawnCH47();
                });
            }
        }
        private void StartHelicopter(Configuration.PluginSettings.OtherSettings.EventSettings EventSettings)
        {
            if (!EventSettings.HelicopterSetting.FullOff && EventSettings.HelicopterSetting.UseEventCustom)
            {
                Int32 TimeSpawn = EventSettings.HelicopterSetting.RandomTimeSpawn.UseRandomTime ? GetRandomTime(EventSettings.HelicopterSetting.RandomTimeSpawn.MinEventSpawnTime, EventSettings.HelicopterSetting.RandomTimeSpawn.MaxEventSpawnTime) : EventSettings.HelicopterSetting.EventSpawnTime;
                timer.Once(TimeSpawn, () => 
                {
                    StartHelicopter(EventSettings);
                    SpawnHeli();
                });
            }
        }
        private void UnSubProSub(int time = 1)
        {
            Unsubscribe("OnEntitySpawned");
            timer.Once(time, () =>
            {
                Subscribe("OnEntitySpawned");
            });
        }
        void SpawnCH47()
        {
            UnSubProSub();

            var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
            var entity = GameManager.server.CreateEntity(prefabCH47, position) as CH47HelicopterAIController;
            entity?.TriggeredEventSpawn();
            entity?.Spawn();
        }
        void SpawnCargo()
        {
            UnSubProSub();

            var x = TerrainMeta.Size.x;
            var vector3 = Vector3Ex.Range(-1f, 1f);
            vector3.y = 0.0f;
            vector3.Normalize();
            var worldPos = vector3 * (x * 1f);
            worldPos.y = TerrainMeta.WaterMap.GetHeight(worldPos);
            var entity = GameManager.server.CreateEntity(prefabShip, worldPos);
            entity?.Spawn();
        }
        void SpawnHeli()
        {
            UnSubProSub();

            var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
            var entity = GameManager.server.CreateEntity(prefabPatrol, position);
            entity?.Spawn();
        }
        void SpawnPlane()
        {
            UnSubProSub();

            var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
            var entity = GameManager.server.CreateEntity(prefabPlane, position);
            entity?.Spawn();
        }

        private void SpawnTank()
        {
            UnSubProSub();
            if (!BradleySpawner.singleton.spawned.isSpawned)
                BradleySpawner.singleton?.SpawnBradley();
        }
        #endregion

        #region ConvertedMetods
        enum Types
        {
            Gather,
            Loot,
            PickUP,
            Quarry,
            Excavator,
            Growable,
        }
        int Converted(Types RateType, string Shortname, float Amount, BasePlayer player = null)
        {
            float ConvertedAmount = Amount;
            if (IsBlackList(Shortname)) return Convert.ToInt32(ConvertedAmount);
            var PrivilegyRates = config.pluginSettings.RateSetting.PrivilegyRates;
            Boolean IsTimes = IsTime();
            var Rates = IsTimes ? config.pluginSettings.RateSetting.DayRates : config.pluginSettings.RateSetting.NightRates;
            if (player != null)
            {
                var CustomRate = IsTimes ? config.pluginSettings.RateSetting.CustomRatesPermissions.DayRates : config.pluginSettings.RateSetting.CustomRatesPermissions.NightRates;

                var Rate = CustomRate.FirstOrDefault(x => IsPermission(player.UserIDString, x.Key)); //dbg
                if (Rate.Value != null)
                    foreach (var RateValue in Rate.Value.Where(x => x.Shortname == Shortname))
                    {
                        ConvertedAmount = Amount * RateValue.Rate;
                        return (int)ConvertedAmount;
                    }

                foreach (var RatesSetting in PrivilegyRates)
                    if (IsPermission(player.UserIDString, RatesSetting.Key))
                        Rates = IsTimes ? RatesSetting.Value.DayRates : RatesSetting.Value.NightRates;
            }


            switch (RateType)
            {
                case Types.Gather:
                    {
                        ConvertedAmount = Amount * Rates.GatherRate;
                        break;
                    }
                case Types.Loot:
                    {
                        ConvertedAmount = Amount * Rates.LootRate;
                        break;
                    }
                case Types.PickUP:
                    {
                        ConvertedAmount = Amount * Rates.PickUpRate;
                        break;
                    }
                case Types.Growable:
                    {
                        ConvertedAmount = Amount * Rates.GrowableRate;
                        break;
                    }
                case Types.Quarry:
                    {
                        ConvertedAmount = Amount * Rates.QuarryRate;
                        break;
                    }
                case Types.Excavator:
                    {
                        ConvertedAmount = Amount * Rates.ExcavatorRate;
                        break;
                    }
            }
            return Convert.ToInt32(ConvertedAmount);
        }
        float GetRareCoal(BasePlayer player = null)
        {
            Boolean IsTimes = IsTime();

            var Rates = IsTimes ? config.pluginSettings.RateSetting.DayRates : config.pluginSettings.RateSetting.NightRates;
            var PrivilegyRates = config.pluginSettings.RateSetting.PrivilegyRates;

            if (player != null)
            {
                foreach (var RatesSetting in PrivilegyRates)
                    if (IsPermission(player.UserIDString, RatesSetting.Key))
                        Rates = IsTimes ? RatesSetting.Value.DayRates : RatesSetting.Value.NightRates;
            }

            float Rare = Rates.CoalRare;
            float RareResult = (100 - Rare) / 100;
            return RareResult;
        }

        #endregion

        #region FuelSystem
        private void FuelSystemRating(EntityFuelSystem FuelSystem, Int32 Amount)
        {
            if (FuelSystem == null) return;
            NextTick(() =>
            {
                Item Fuel = FuelSystem.GetFuelItem();
                if (Fuel == null) return;

                if (Fuel.amount == 50 || Fuel.amount == 100)
                    Fuel.amount = Amount;
            });
        }
        #endregion

        #region BoolMetods

        bool IsBlackList(string Shortname)
        {
            var BlackList = config.pluginSettings.RateSetting.BlackList;
            if (BlackList.Contains(Shortname))
                return true;
            else return false;
        }      
        bool IsBlackListBurnable(string Shortname)
        {
            var BlackList = config.pluginSettings.RateSetting.BlackListBurnable;
            if (BlackList.Contains(Shortname))
                return true;
            else return false;
        }
        bool IsTime()
        {
            var Settings = config.pluginSettings.OtherSetting;
            float TimeServer = TOD_Sky.Instance.Cycle.Hour;
            return TimeServer < Settings.NightStart && Settings.DayStart <= TimeServer;
        }
        bool IsPermission(string userID,string Permission)
        {
            if (permission.UserHasPermission(userID, Permission))
                return true;
            else return false;
        }
        #endregion

        #endregion

        #region Commands
        [ChatCommand("rates")]
        private void GetInfoMyRates(BasePlayer player)
        {
            if (player == null) return;

            var PrivilegyRates = config.pluginSettings.RateSetting.PrivilegyRates;
            Boolean IsTimes = IsTime();
            var Rates = IsTimes ? config.pluginSettings.RateSetting.DayRates : config.pluginSettings.RateSetting.NightRates;
            var CustomRate = IsTimes ? config.pluginSettings.RateSetting.CustomRatesPermissions.DayRates : config.pluginSettings.RateSetting.CustomRatesPermissions.NightRates;

            var Rate = CustomRate.FirstOrDefault(x => IsPermission(player.UserIDString, x.Key)); 

            foreach (var RatesSetting in PrivilegyRates)
                if (IsPermission(player.UserIDString, RatesSetting.Key))
                    Rates = IsTimes ? RatesSetting.Value.DayRates : RatesSetting.Value.NightRates;

            SendChat(GetLang("MY_RATES_INFO", player.UserIDString, Rates.GatherRate, Rates.LootRate, Rates.PickUpRate, Rates.QuarryRate, Rates.ExcavatorRate, Rates.GrowableRate), player);
        }

        #endregion

        #region Hooks

        #region Player Gather Hooks
        object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity as BasePlayer;
            if (item == null || player == null) return null;

            int Rate = Converted(Types.Gather, item.info.shortname, item.amount, player);
            item.amount = Rate;
            return null;
        }

        void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            if (item == null || player == null) return;
            
            int Rate = Converted(Types.Gather, item.info.shortname, item.amount, player);
            item.amount = Rate;
        }
        #endregion

        #region Player PickUP Hooks

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (player == null || item == null) return;
            item.amount = Converted(Types.PickUP, item.info.shortname, item.amount, player);
        }

        void OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player)
        {
            if (item == null || player == null) return;
            item.amount = Converted(Types.Growable, item.info.shortname, item.amount, player);
        }
        void OnContainerDropItems(ItemContainer container)
        {
            if (container == null) return;
            var Container = container.entityOwner as LootContainer;
            if (Container == null) return;
            uint NetID = Container.net.ID;
            if (LootersListCrateID.Contains(NetID)) return;
            
            BasePlayer player = Container.lastAttacker as BasePlayer;

            foreach (var item in container.itemList)
                item.amount = Converted(Types.Loot, item.info.shortname, item.amount, player);
        }
        #endregion

        #region Player Loot Hooks
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (entity == null) return;
            LootContainer container = entity as LootContainer;
            if (container == null || entity.net == null) return;
            UInt64 NetID = entity.net.ID;
            if (LootersListCrateID.Contains(NetID)) return;

            foreach (Item item in container.inventory.itemList)
                item.amount = Converted(Types.Loot, item.info.shortname, item.amount, player);
            LootersListCrateID.Add(NetID);
        }
        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null || entity.net == null) return; 
            UInt64 NetID = entity.net.ID;
            if (LootersListCrateID.Contains(NetID))
                LootersListCrateID.Remove(NetID);           
        }
        #endregion

        #region Quarry Gather Hooks
        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (item == null || quarry == null) return;
            BasePlayer player = quarry.OwnerID != 0 ? BasePlayer.FindByID(quarry.OwnerID) : null;
            item.amount = Converted(Types.Quarry, item.info.shortname, item.amount, player);
        }
        #endregion

        #region Exacavator Gather Hooks
        private BasePlayer ExcavatorPlayer = null;
        void OnExcavatorResourceSet(ExcavatorArm arm, string resourceName, BasePlayer player)
        {
            if (arm == null || player == null) return;
            ExcavatorPlayer = player;
        }
        private object OnExcavatorGather(ExcavatorArm arm, Item item)
        {
            if (arm == null) return null;
            if (item == null) return null;
            item.amount = Converted(Types.Excavator, item.info.shortname, item.amount, ExcavatorPlayer);
            return null;
        }
        #endregion

        #region Coal Hooks

        void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (oven == null) return;
            burnable.byproductChance = GetRareCoal(BasePlayer.FindByID(oven.OwnerID));
            if (burnable.byproductChance == 0)
                burnable.byproductChance = -1;
        }
        #endregion

        #region Server Hooks
        TOD_Time timeComponent = null;
        Boolean activatedDay;

        private void GetTimeComponent()
        {
            timeComponent = TOD_Sky.Instance.Components.Time;
            if (timeComponent == null) return;
            SetTimeComponent();
            StartupFreeze();
        }
        void SetTimeComponent()
        {
            if (!config.pluginSettings.OtherSetting.UseTime) return;

            timeComponent.ProgressTime = true;
            timeComponent.UseTimeCurve = false;
            timeComponent.OnSunrise += OnSunrise;
            timeComponent.OnSunset += OnSunset;
            timeComponent.OnHour += OnHour;

            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunsetTime)
                OnSunrise();
            else
                OnSunset();
        }

        void OnHour()
        {
            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunsetTime && TOD_Sky.Instance.Cycle.Hour >= config.pluginSettings.OtherSetting.DayStart && !activatedDay)
            {
                OnSunrise();
                return;
            }
            if ((TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunsetTime || TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunriseTime) && TOD_Sky.Instance.Cycle.Hour >= config.pluginSettings.OtherSetting.NightStart && activatedDay)
            {
                OnSunset();
                return;
            }
        }

        void OnSunrise()
        {
            timeComponent.DayLengthInMinutes = config.pluginSettings.OtherSetting.DayTime * (24.0f / (TOD_Sky.Instance.SunsetTime - TOD_Sky.Instance.SunriseTime));
            activatedDay = true;
            if (config.pluginSettings.OtherSetting.UseSkipTime)
            {
                if (config.pluginSettings.OtherSetting.TypeSkipped == SkipType.Day)
                    TOD_Sky.Instance.Cycle.Hour = config.pluginSettings.OtherSetting.NightStart;
                else
                {
                    if (config.pluginSettings.OtherSetting.UseAlertDayNight)
                    {
                        Configuration.PluginSettings.Rates.AllRates Rate = config.pluginSettings.RateSetting.DayRates;
                        foreach (BasePlayer player in BasePlayer.activePlayerList)
                            SendChat(GetLang("DAY_RATES_ALERT", player.UserIDString, Rate.GatherRate, Rate.LootRate, Rate.PickUpRate, Rate.QuarryRate, Rate.ExcavatorRate, Rate.GrowableRate), player); 
                    }
                }
                return;
            }
            if (config.pluginSettings.OtherSetting.UseAlertDayNight)
            {
                Configuration.PluginSettings.Rates.AllRates Rate = config.pluginSettings.RateSetting.DayRates;
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    SendChat(GetLang("DAY_RATES_ALERT", player.UserIDString, Rate.GatherRate, Rate.LootRate, Rate.PickUpRate, Rate.QuarryRate, Rate.ExcavatorRate, Rate.GrowableRate), player);
            }
        }

        void OnSunset()
        {
            timeComponent.DayLengthInMinutes = config.pluginSettings.OtherSetting.NightTime * (24.0f / (24.0f - (TOD_Sky.Instance.SunsetTime - TOD_Sky.Instance.SunriseTime)));
            activatedDay = false;
            if (config.pluginSettings.OtherSetting.UseSkipTime)
            {
                if (config.pluginSettings.OtherSetting.TypeSkipped == SkipType.Night)
                    TOD_Sky.Instance.Cycle.Hour = config.pluginSettings.OtherSetting.DayStart;
                else
                {
                    if (config.pluginSettings.OtherSetting.UseAlertDayNight)
                    {
                        Configuration.PluginSettings.Rates.AllRates Rate = config.pluginSettings.RateSetting.NightRates;
                        foreach (BasePlayer player in BasePlayer.activePlayerList)
                            SendChat(GetLang("NIGHT_RATES_ALERT", player.UserIDString, Rate.GatherRate, Rate.LootRate, Rate.PickUpRate, Rate.QuarryRate, Rate.ExcavatorRate, Rate.GrowableRate), player);
                    }
                }
                return;
            }
            if (config.pluginSettings.OtherSetting.UseAlertDayNight)
            {
                Configuration.PluginSettings.Rates.AllRates Rate = config.pluginSettings.RateSetting.NightRates;
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    SendChat(GetLang("NIGHT_RATES_ALERT", player.UserIDString, Rate.GatherRate, Rate.LootRate, Rate.PickUpRate, Rate.QuarryRate, Rate.ExcavatorRate, Rate.GrowableRate), player);
            }
        }
        void StartupFreeze()
        {
            if (!config.pluginSettings.OtherSetting.UseFreezeTime) return;
            timeComponent.ProgressTime = false;
            ConVar.Env.time = config.pluginSettings.OtherSetting.FreezeTime;
        }

        private void OnServerInitialized()
        {
            _ = this;
 
            SpacePort = TerrainMeta.Path.Monuments.FirstOrDefault(p => p.name.ToLower().Contains("launch_site"));

            StartEvent();
            foreach (var RateCustom in config.pluginSettings.RateSetting.PrivilegyRates)
                Register(RateCustom.Key);

            if (config.pluginSettings.RateSetting.UseSpeedBurnableList)
                foreach (var BurnableList in config.pluginSettings.RateSetting.SpeedBurableList)
                    Register(BurnableList.Permissions);

            List<String> PrivilegyCustomRatePermissions = config.pluginSettings.RateSetting.CustomRatesPermissions.NightRates.Keys.Union(config.pluginSettings.RateSetting.CustomRatesPermissions.DayRates.Keys).ToList();
            foreach (var RateItemCustom in PrivilegyCustomRatePermissions)
                Register(RateItemCustom);

                timer.Once(5, GetTimeComponent);
            
            if(config.pluginSettings.RateSetting.UseSpeedBurnable)
            foreach (var oven in BaseNetworkable.serverEntities.OfType<BaseOven>())
                OvenController.GetOrAdd(oven).TryRestart();

            if (!config.pluginSettings.RateSetting.UseSpeedBurnable)
                Unsubscribe("OnOvenToggle");

        }

        #endregion

        #region Burnable
        public Single GetMultiplaceBurnableSpeed(String ownerid)
        {
            Single Multiplace = config.pluginSettings.RateSetting.SpeedBurnable;
            if (config.pluginSettings.RateSetting.UseSpeedBurnableList)
            {
                var SpeedInList = config.pluginSettings.RateSetting.SpeedBurableList.OrderByDescending(z => z.SpeedBurnable).FirstOrDefault(x => permission.UserHasPermission(ownerid, x.Permissions));
                if (SpeedInList != null)
                    Multiplace = SpeedInList.SpeedBurnable;
            }
            return Multiplace;
        }     
        public Int32 GetMultiplaceBurnableFuelSpeed(String ownerid)
        {
            Int32 Multiplace = config.pluginSettings.RateSetting.SpeedFuelBurnable;
            if (config.pluginSettings.RateSetting.UseSpeedBurnableList)
            {
                var SpeedInList = config.pluginSettings.RateSetting.SpeedBurableList.OrderByDescending(z => z.SpeedFuelBurnable).FirstOrDefault(x => permission.UserHasPermission(ownerid, x.Permissions));
                if (SpeedInList != null)
                    Multiplace = SpeedInList.SpeedFuelBurnable;
            }
            return Multiplace;
        }

        private object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            return OvenController.GetOrAdd(oven).Switch(player);
        }

        private class OvenController : FacepunchBehaviour
        {
            private static readonly Dictionary<BaseOven, OvenController> Controllers = new Dictionary<BaseOven, OvenController>();
            private BaseOven _oven;
            private float _speed;
            private Int32 _ticks;
            private string _ownerId;
            private Int32 _speedFuel;

            private bool IsFurnace => (int)_oven.temperature >= 2;

            private void Awake()
            {
                _oven = (BaseOven)gameObject.ToBaseEntity();
                _ownerId = _oven.OwnerID.ToString();
            }

            public object Switch(BasePlayer player)
            {
                if (!IsFurnace || _oven.needsBuildingPrivilegeToUse && !player.CanBuild())
                    return null;

                if (_oven.IsOn())
                    StopCooking();
                else
                {
                    _ownerId = _oven.OwnerID != 0 ? _oven.OwnerID.ToString() : player.UserIDString;
                    StartCooking();
                }
                return false;
            }

            public void TryRestart()
            {
                if (!_oven.IsOn())
                    return;
                _oven.CancelInvoke(_oven.Cook);
                StopCooking();
                StartCooking();
            }
            private void Kill()
            {
                if (_oven.IsOn())
                {
                    StopCooking();
                    _oven.StartCooking();
                }
                Destroy(this);
            }

            #region Static methods⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

            public static OvenController GetOrAdd(BaseOven oven)
            {
                OvenController controller;
                if (Controllers.TryGetValue(oven, out controller))
                    return controller;
                controller = oven.gameObject.AddComponent<OvenController>();
                Controllers[oven] = controller;
                return controller;
            }

            public static void TryRestartAll()
            {
                foreach (var pair in Controllers)
                {
                    pair.Value.TryRestart();
                }
            }
            public static void KillAll()
            {
                foreach (var pair in Controllers)
                {
                    pair.Value.Kill();
                }
                Controllers.Clear();
            }

            #endregion

            private void StartCooking()
            {
                if (_oven.FindBurnable() == null)
                    return;
                Single Multiplace = _.GetMultiplaceBurnableSpeed(_ownerId);
                Int32 MultiplaceFuel = _.GetMultiplaceBurnableFuelSpeed(_ownerId);
                _speed = (Single)(0.5f / Multiplace); // 0.5 * M
                _speedFuel = MultiplaceFuel;
                _oven.inventory.temperature = _oven.cookingTemperature;
                _oven.UpdateAttachmentTemperature();
                InvokeRepeating(Cook, _speed, _speed);
                _oven.SetFlag(BaseEntity.Flags.On, true);
            }

            private void StopCooking()
            {
                _oven.UpdateAttachmentTemperature();
                if (_oven.inventory != null)
                {
                   // _oven.inventory.temperature = 15f;
                    foreach (Item item in _oven.inventory.itemList)
                    {
                        if (!item.HasFlag(global::Item.Flag.OnFire))
                            continue;
                        item.SetFlag(global::Item.Flag.OnFire, false);
                        item.MarkDirty();
                    }
                }
                CancelInvoke(Cook);
                _oven.SetFlag(BaseEntity.Flags.On, false);
            }
           
            public void Cook()
            {
                var item = _oven.FindBurnable();
                if (item == null)
                {
                    StopCooking();
                    return;
                }
                SmeltItems();
                var slot = _oven.GetSlot(BaseEntity.Slot.FireMod);
                if (slot)
                {
                    slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
                }

                var component = item.info.GetComponent<ItemModBurnable>();
                item.fuel -= 0.5f * (_oven.cookingTemperature / 200f) * _speedFuel; 
                if (!item.HasFlag(global::Item.Flag.OnFire))
                {
                    item.SetFlag(global::Item.Flag.OnFire, true);
                    item.MarkDirty();
                }

                if (item.fuel <= 0f)
                {
                    _oven.ConsumeFuel(item, component);
                }

                _ticks++;
            }
            private void SmeltItems()
            {
                if (_ticks % 1 != 0)
                    return;

                for (var i = 0; i < _oven.inventory.itemList.Count; i++)
                {
                    var item = _oven.inventory.itemList[i];
                    if (item == null || !item.IsValid() || item.info == null || _.IsBlackListBurnable(item.info.shortname))
                        continue;

                    var cookable = item.info.GetComponent<ItemModCookable>();
                    if (cookable == null)
                        continue;

                   var temperature = item.temperature;
                    if ((temperature < cookable.lowTemp || temperature > cookable.highTemp)) 
                        {
                            if (!cookable.setCookingFlag || !item.HasFlag(global::Item.Flag.Cooking)) continue;
                            item.SetFlag(global::Item.Flag.Cooking, false);
                            item.MarkDirty();
                            continue;
                        }

                    if (cookable.cookTime > 0 && _ticks * 1f / 1 % cookable.cookTime > 0)
                        continue;

                    if (cookable.setCookingFlag && !item.HasFlag(global::Item.Flag.Cooking))
                    {
                        item.SetFlag(global::Item.Flag.Cooking, true);
                        item.MarkDirty();
                    }

                    var position = item.position;
                    if (item.amount > 1)
                    {
                        item.amount--;
                        item.MarkDirty();
                    }
                    else
                    {
                        item.Remove();
                    }

                    if (cookable.becomeOnCooked == null) continue;

                    var item2 = ItemManager.Create(cookable.becomeOnCooked,
                        (int)(cookable.amountOfBecome * 1f));

                    if (item2 == null || item2.MoveToContainer(item.parent, position) ||
                        item2.MoveToContainer(item.parent))
                        continue;

                    item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
                    if (!item.parent.entityOwner) continue;
                    StopCooking();
                }
            }
        }

        #endregion

        #region Event Hooks
        private void Unload()
        {
            OvenController.KillAll();
            if (timeComponent == null) return;
            timeComponent.OnSunrise -= OnSunrise;
            timeComponent.OnSunset -= OnSunset;
            timeComponent.OnHour -= OnHour;
        }

        #region Fuel Controller
        private void OnEntitySpawned(BaseBoat boat)
        {
            if (boat == null) return;
            FuelSystemRating(boat.GetFuelSystem(), config.pluginSettings.OtherSetting.FuelSetting.AmountBoat);
        }     
        private void OnEntitySpawned(BaseSubmarine submarine)
        {
            if (submarine == null) return;
            FuelSystemRating(submarine.GetFuelSystem(), config.pluginSettings.OtherSetting.FuelSetting.AmountSubmarine);
        }
        private void OnEntitySpawned(MiniCopter copter)
        {
            if (copter == null) return;
            FuelSystemRating(copter.GetFuelSystem(), config.pluginSettings.OtherSetting.FuelSetting.AmountMinicopter);
        }
        private void OnEntitySpawned(ScrapTransportHelicopter helicopter)
        {
            if (helicopter == null) return;
            FuelSystemRating(helicopter.GetFuelSystem(), config.pluginSettings.OtherSetting.FuelSetting.AmountScrapTransport);
        }
        #endregion

        private void OnEntitySpawned(SupplySignal entity) => UnSubProSub(10);
        private void OnEntitySpawned(CargoPlane entity)
        {
            NextTick(() =>
            {
                if (entity.OwnerID != 0 || entity.skinID != 0) return;
                var EvenTimer = config.pluginSettings.OtherSetting.EventSetting.CargoPlaneSetting;
                if ((EvenTimer.FullOff || EvenTimer.UseEventCustom))
                    entity.Kill();
            });
        }
        private void OnEntitySpawned(CargoShip entity)
        {
            NextTick(() =>
            {
                if (entity.OwnerID != 0 || entity.skinID != 0) return;
                var EvenTimer = config.pluginSettings.OtherSetting.EventSetting.CargoShipSetting;
                if ((EvenTimer.FullOff || EvenTimer.UseEventCustom))
                    entity.Kill();
            });
        }
        private void OnEntitySpawned(BradleyAPC entity)
        {
            NextTick(() =>
            {
                if (entity.OwnerID != 0 || entity.skinID != 0) return;
                var EvenTimer = config.pluginSettings.OtherSetting.EventSetting.BreadlaySetting;
                if ((EvenTimer.FullOff || EvenTimer.UseEventCustom))
                    entity.Kill();
            });
        }

        private void OnEntitySpawned(BaseHelicopter entity)
        {
            NextTick(() =>
            {
                if (entity.OwnerID != 0 || entity.skinID != 0) return;
                var EvenTimer = config.pluginSettings.OtherSetting.EventSetting.HelicopterSetting;
                if ((EvenTimer.FullOff || EvenTimer.UseEventCustom))
                    entity.Kill();
            });
        }
        private void OnEntitySpawned(CH47Helicopter entity)
        {
            NextTick(() =>
            {
                if (entity.OwnerID != 0 || entity.skinID != 0) return;
                timer.Once(3f, () =>
                {
                    var EvenTimer = config.pluginSettings.OtherSetting.EventSetting.ChinoockSetting;
                    if ((EvenTimer.FullOff || EvenTimer.UseEventCustom) && entity.mountPoints.Where(x => x.mountable.GetMounted() != null && x.mountable.GetMounted().ShortPrefabName.Contains("scientistnpc_heavy")).Count() <= 0)
                        timer.Once(1f, () => { entity.Kill();});
                });
            });
        }   
        #endregion

        #endregion

        #region Lang

        private static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MY_RATES_INFO"] = "Your resource rating at the moment :" +
                "\n- Rating of extracted resources: <color=#FAF0F5>x{0}</color>" +
                "\n- Rating of found items: <color=#FAF0F5>х{1}</color>" +
                "\n- Rating of raised items: <color=#FAF0F5>х{2}</color>" +
                "\n- Career rankings: <color=#FAF0F5>x{3}</color>" +
                "\n- Excavator Rating: <color=#FAF0F5>x{4}</color>" +
                "\n- Rating of growable : <color=#FAF0F5>x{5}</color>",

                ["DAY_RATES_ALERT"] = "The day has come!" +
                "\nThe global rating on the server has been changed :" +
                "\n- Rating of extracted resources: <color=#FAF0F5>x{0}</color>" +
                "\n- Rating of found items: <color=#FAF0F5>х{1}</color>" +
                "\n- Rating of raised items: <color=#FAF0F5>х{2}</color>" +
                "\n- Career rankings: <color=#FAF0F5>x{3}</color>" +
                "\n- Excavator Rating: <color=#FAF0F5>x{4}</color>" +
                "\n- Rating of growable : <color=#FAF0F5>x{5}</color>",

                ["NIGHT_RATES_ALERT"] = "Night came!" +
                "\nThe global rating on the server has been changed :" +
                "\n- Rating of extracted resources: <color=#FAF0F5>x{0}</color>" +
                "\n- Rating of found items: <color=#FAF0F5>х{1}</color>" +
                "\n- Rating of raised items: <color=#FAF0F5>х{2}</color>" +
                "\n- Career rankings: <color=#FAF0F5>x{3}</color>" +
                "\n- Excavator Rating: <color=#FAF0F5>x{4}</color>" +
                "\n- Rating of growable : <color=#FAF0F5>x{5}</color>",


            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MY_RATES_INFO"] = "Ваш рейтинг ресурсов на данный момент :" +
                "\n- Рейтинг добываемых ресурсов: <color=#FAF0F5>x{0}</color>" +
                "\n- Рейтинг найденных предметов: <color=#FAF0F5>х{1}</color>" +
                "\n- Рейтинг поднимаемых предметов: <color=#FAF0F5>х{2}</color>" +
                "\n- Рейтинг карьеров: <color=#FAF0F5>x{3}</color>" +
                "\n- Рейтинг экскаватора: <color=#FAF0F5>x{4}</color>" +
                "\n- Рейтинг грядок : <color=#FAF0F5>x{5}</color>",

                ["DAY_RATES_ALERT"] = "Наступил день!" +
                "\nГлобальный рейтинг на сервере был изменен :" +
                "\n- Рейтинг добываемых ресурсов: <color=#FAF0F5>x{0}</color>" +
                "\n- Рейтинг найденных предметов: <color=#FAF0F5>х{1}</color>" +
                "\n- Рейтинг поднимаемых предметов: <color=#FAF0F5>х{2}</color>" +
                "\n- Рейтинг карьеров: <color=#FAF0F5>x{3}</color>" +
                "\n- Рейтинг экскаватора: <color=#FAF0F5>x{4}</color>" +
                "\n- Рейтинг грядок : <color=#FAF0F5>x{5}</color>", 
                
                ["NIGHT_RATES_ALERT"] = "Наступила ночь!" +
                "\nГлобальный рейтинг на сервере был изменен :" +
                "\n- Рейтинг добываемых ресурсов: <color=#FAF0F5>x{0}</color>" +
                "\n- Рейтинг найденных предметов: <color=#FAF0F5>х{1}</color>" +
                "\n- Рейтинг поднимаемых предметов: <color=#FAF0F5>х{2}</color>" +
                "\n- Рейтинг карьеров: <color=#FAF0F5>x{3}</color>" +
                "\n- Рейтинг экскаватора: <color=#FAF0F5>x{4}</color>" +
                "\n- Рейтинг грядок : <color=#FAF0F5>x{5}</color>",
            }, this, "ru");
        }
        #endregion

        #region API
        int API_CONVERT(Types RateType, string Shortname, float Amount, BasePlayer player = null) => Converted(RateType, Shortname, Amount, player);
        int API_CONVERT_GATHER(string Shortname, float Amount, BasePlayer player = null) => Converted(Types.Gather, Shortname, Amount, player);
        #endregion
    }
}

// --- End of file: IQRates.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DailyReward.cs ---
// --- Original Local Path: DailyReward.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Oxide.Core.Database;

namespace Oxide.Plugins
{
    [Info("DailyReward", "Hougan", "1.0.0")]
    [Description("Награды за ежедневный вход на сервер")]
    public class DailyReward : RustPlugin
    {
        #region Classes
        
        Core.MySql.Libraries.MySql Sql = Interface.GetMod().GetLibrary<Core.MySql.Libraries.MySql>();
        Connection Sql_conn;

        private class DailyPlayer
        {
            [JsonProperty("Отображаемое имя игрока")]
            public string DisplayName;
            [JsonProperty("Отображаемый ID игрока")]
            public ulong UserID;
            
            [JsonProperty("Дни в которых игрок получил награду")]
            public Dictionary<string, bool> Joins = new Dictionary<string,bool>();
        }
        private Dictionary<ulong, DailyPlayer> dailyPlayers = new Dictionary<ulong, DailyPlayer>();

        #endregion

        #region Variables

        [JsonProperty("Название слоя с ГУИ")]
        private string Layer = "UI.DailyBonus";
        [JsonProperty("Начальный бонус в рублях")]
        private int DefaultMoney = 1;
        [JsonProperty("Максимальное пополнение за раз")]
        private int MaxDeposit = 10;

        [JsonProperty("Ключ магазина")] 
        private string APIKey;
        [JsonProperty("ID Сервера")] 
        private string ServerID;

        [JsonProperty("Использовать MySQL?")]
        private bool MySQL_Use = true;
        [JsonProperty("MySQL. IP БД")] 
        private string MySQL_IP = "localhost";
        [JsonProperty("MySQL. Port")]
        private int MySQL_Port = 3306;
        [JsonProperty("MySQL. Название БД")] 
        private string MySQL_DBName = "joins";
        [JsonProperty("MySQL. Название таблицы")] 
        private string MySQL_TBName = "playerjoin";
        [JsonProperty("MySQL. Имя пользователя")]
        private string MySQL_Name = "root";
        [JsonProperty("MySQL. Пароль пользователя")]
        private string MySQL_Password = "root1234";

        #endregion

        #region Commands

        [ConsoleCommand("db.get")]
        private void cmdConsoleGet(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null)
            {
                PrintWarning("Команда только для игроков!");
                return;
            }

            DailyPlayer dailyPlayer = dailyPlayers[player.userID];
            if (dailyPlayer.Joins[DateTime.Now.Day.ToString()])
            {
                player.ChatMessage(lang.GetMessage("TODAY.GOT", this, player.UserIDString));
                return;
            }
            
            if (MySQL_Use)
                TodayPlayer(player);
            else
            {
                dailyPlayer.Joins[DateTime.Now.Day.ToString()] = true;

                int current = 0;
                int i = DateTime.Now.Day;
                do
                {
                    if (!dailyPlayer.Joins[i.ToString()])
                        break;
                
                    current++;
                    i--;
                } while (dailyPlayer.Joins.ContainsKey(i.ToString()));

                if (current * DefaultMoney > MaxDeposit)
                {
                    player.ChatMessage(lang.GetMessage("ERROR", this, player.UserIDString).Replace("{0}", (current * DefaultMoney).ToString()));
                    return;
                }
            
                player.ChatMessage(lang.GetMessage("TODAY.SUCCESS", this, player.UserIDString).Replace("{0}", (current * DefaultMoney).ToString()).Replace("{1}", ((current + 1) * DefaultMoney).ToString()));
            
                LogToFile("DailyBonus", $"{player.displayName} [{player.userID}] получил {current * DefaultMoney} рублей", this);
            
                AddMoney(player.userID, current * DefaultMoney);
            
                DailyGUI(player);
            }
        }

        #endregion

        #region MySQL
        
        private void TodayPlayer(BasePlayer player)
        {
            if (Sql_conn == null)
                Sql_conn = Sql.OpenDb(MySQL_IP, MySQL_Port, MySQL_DBName, MySQL_Name, MySQL_Password, this);
            if (Sql_conn?.Con == null)
            {
                if (Sql_conn != null)
                    Puts("Ошибка соединения с БД: " + Sql_conn.Con?.State.ToString());
                else
                    Puts("Ошибка соединения с БД не определена!");

                return;
            }
            Sql.Query(Core.Database.Sql.Builder.Append($"SELECT * FROM `{MySQL_DBName}`.`{MySQL_TBName}` WHERE `userid`={player.userID};"), Sql_conn, lists =>
            {
                if (lists.Count == 0)
                {
                    AddPrize(player, true);
                    return;
                }

                foreach (var check in lists)
                {
                    if (check.Values.ToList()[1].ToString() != DateTime.Now.Day.ToString())
                    {
                        AddPrize(player, false);
                        return;
                    }
                    player.ChatMessage(lang.GetMessage("TODAY.GOT", this, player.UserIDString));
                    return;
                }
            });
            
            Sql_conn.Con.Close();
        }

        private void AddPrize(BasePlayer player, bool newPlayer = false)
        {
            if (!newPlayer)
            {
                Sql.Query(Core.Database.Sql.Builder.Append($"UPDATE `{MySQL_DBName}`.`{MySQL_TBName}` SET `join`= '{DateTime.Now.Day}' WHERE `userid`= {player.userID};"), Sql_conn, lists =>
                {
                    DailyPlayer dailyPlayer = dailyPlayers[player.userID];
                    dailyPlayer.Joins[DateTime.Now.Day.ToString()] = true;

                    int current = 0;
                    int i = DateTime.Now.Day;
                    do
                    {
                        if (!dailyPlayer.Joins[i.ToString()])
                            break;
                
                        current++;
                        i--;
                    } while (dailyPlayer.Joins.ContainsKey(i.ToString()));

                    if (current * DefaultMoney > MaxDeposit)
                    {
                        player.ChatMessage(lang.GetMessage("ERROR", this, player.UserIDString).Replace("{0}", (current * DefaultMoney).ToString()));
                        return;
                    }
            
                    player.ChatMessage(lang.GetMessage("TODAY.SUCCESS", this, player.UserIDString).Replace("{0}", (current * DefaultMoney).ToString()).Replace("{1}", ((current + 1) * DefaultMoney).ToString()));
            
                    LogToFile("DailyBonus", $"{player.displayName} [{player.userID}] получил {current * DefaultMoney} рублей", this);
            
                    AddMoney(player.userID, current * DefaultMoney);
            
                    DailyGUI(player);
                });
            }
            else
            {
                Sql.Query(Core.Database.Sql.Builder.Append(string.Format($"INSERT INTO `{MySQL_DBName}`.`{MySQL_TBName}` (`userid`, `join`) VALUES ('{player.userID}', '{DateTime.Now.Day}');")), Sql_conn, lists =>
                {
                    DailyPlayer dailyPlayer = dailyPlayers[player.userID];
                    dailyPlayer.Joins[DateTime.Now.Day.ToString()] = true;

                    int current = 0;
                    int i = DateTime.Now.Day;
                    do
                    {
                        if (!dailyPlayer.Joins[i.ToString()])
                            break;
                
                        current++;
                        i--;
                    } while (dailyPlayer.Joins.ContainsKey(i.ToString()));

                    if (current * DefaultMoney > MaxDeposit)
                    {
                        player.ChatMessage(lang.GetMessage("ERROR", this, player.UserIDString).Replace("{0}", (current * DefaultMoney).ToString()));
                        return;
                    }
            
                    player.ChatMessage(lang.GetMessage("TODAY.SUCCESS", this, player.UserIDString).Replace("{0}", (current * DefaultMoney).ToString()).Replace("{1}", ((current + 1) * DefaultMoney).ToString()));
            
                    LogToFile("DailyBonus", $"{player.displayName} [{player.userID}] получил {current * DefaultMoney} рублей", this);
            
                    AddMoney(player.userID, current * DefaultMoney);
            
                    DailyGUI(player);
                });
            }
        }

        #endregion

        #region Functions

        [PluginReference] 
        private Plugin RustStore;
        private bool Moscow = false;

        private void AddMoney(ulong userId, int amount)
        {
            ExecuteApiRequest(new Dictionary<string, string>()
            {
                { "action", "moneys" },
                { "type", "plus" },
                { "steam_id", userId.ToString() },
                { "amount", amount.ToString() },
                { "mess", "Ежедневная награда! Спасибо что играете у нас!"}
            }, Moscow);
        }
        
        void ExecuteApiRequest(Dictionary<string, string> args, bool Moscow)
        {
            if (!Moscow)
            {
                string url = $"http://panel.gamestores.ru/api?shop_id={ServerID}&secret={APIKey}" +
                             $"{string.Join("",args.Select(arg => $"&{arg.Key}={arg.Value}").ToArray())}";
                LogToFile("test", url, this);
                string moscowUrl = "https://store-api.moscow.ovh/index.php";
                webrequest.EnqueueGet(url, (i, s) =>
                {
                    if (i != 200)
                    {
                        PrintError($"Ошибка соединения с сайтом GS!");
                    }
                    else
                    {
                        JObject jObject = JObject.Parse(s);
                        if (jObject["result"].ToString() == "fail")
                        {
                            PrintError($"Ошибка пополнения баланса для {args["steam_id"]}!");
                            PrintError($"Причина: {jObject["message"].ToString()}");
                        }
                        else
                            PrintWarning($"Игрок {args["steam_id"]} успешно получил {args["amount"]} рублей");
                    }
                }, this);
            }
            else
            {
                RustStore.Call("APIChangeUserBalance", Convert.ToUInt64(args["steam_id"]), Convert.ToInt32(args["amount"]), null);
            }
            
        }
        
        #endregion

        #region Initialization

        private void MySQL_Initialize()
        {
            if (Sql_conn == null)
            {
                // Открываем новое соединение
                Sql_conn = Sql.OpenDb(MySQL_IP, MySQL_Port, "", MySQL_Name, MySQL_Password, this);
            }
            
            if (Sql_conn?.Con == null)
            {
                if (Sql_conn != null)
                    Puts("Ошибка соединения с БД: " + Sql_conn.Con?.State.ToString());
                else
                    Puts("Ошибка соединения с БД не определена!");

                PrintError("Ошибка инициализации БД, плагин выгружается!");
                Interface.Oxide.UnloadPlugin(this.Name);
                return;
            }
            
            Sql.Query(Core.Database.Sql.Builder.Append($"CREATE DATABASE IF NOT EXISTS {MySQL_DBName};"), Sql_conn, lists =>
            {
                PrintWarning("База данных создана или обновлена!");
            });
            
            
            Sql.Query(Core.Database.Sql.Builder.Append($"CREATE TABLE IF NOT EXISTS `{MySQL_DBName}`.`{MySQL_TBName}` (`userid` VARCHAR(18) NOT NULL, `join` VARCHAR(3) NULL, PRIMARY KEY (`userid`));"), Sql_conn, lists =>
            {
                PrintWarning("Таблица данных создана или обновлена!");
            });
            
            Sql.Query(Core.Database.Sql.Builder.Append($"SELECT * FROM `{MySQL_DBName}`.`{MySQL_TBName}` WHERE `userid`={123456789};"), Sql_conn, lists =>
            {
                if (lists.Count == 0)
                {
                    PrintWarning("ТЕСТ №1 - Пройден успешно");
                    return;
                }
            });
            
            Sql.Query(Core.Database.Sql.Builder.Append(string.Format($"INSERT IGNORE INTO `{MySQL_DBName}`.`{MySQL_TBName}` (`userid`, `join`) VALUES ('{123456789}', '{DateTime.Now.AddDays(1).Day}');")), Sql_conn, lists =>
            {
            });
            
            Sql.Query(Core.Database.Sql.Builder.Append($"SELECT * FROM `{MySQL_DBName}`.`{MySQL_TBName}` WHERE `userid`={123456789};"), Sql_conn, lists =>
            {
                if (lists.Count == 1)
                {
                    PrintWarning("ТЕСТ №2 - Пройден успешно");
                    return;
                }
                PrintError("ТЕСТ №3 - Не пройден!");
            });
            
            Sql.Query(Core.Database.Sql.Builder.Append($"UPDATE `{MySQL_DBName}`.`{MySQL_TBName}` SET `join`= '{DateTime.Now.Day}' WHERE `userid`= {123456789};"), Sql_conn, lists =>
            {
                
            });
            
            Sql.Query(Core.Database.Sql.Builder.Append($"SELECT * FROM `{MySQL_DBName}`.`{MySQL_TBName}` WHERE `userid`={123456789};"), Sql_conn, lists =>
            {
                if (lists.Count == 1)
                {
                    foreach (var check in lists)
                    {
                        if (check.Values.ToList()[1].ToString() == DateTime.Now.Day.ToString())
                        {
                            PrintWarning("Тест №3 - Пройден успешно");
                            PrintWarning("База данных успешно работает!");
                            return;
                        }
                        PrintError("ТЕСТ №3 - Не пройден!");
                        return;
                    }
                    PrintError("ТЕСТ №3 - Не пройден!");
                    return;
                }
                PrintError("ТЕСТ №3 - Не пройден!");
            });
            
            Sql.Query(Core.Database.Sql.Builder.Append($"DELETE FROM `{MySQL_DBName}`.`{MySQL_TBName}` WHERE `userid`='123456789';"), Sql_conn,
            lists =>
            {
                
            });
        }
        
        private void OnServerInitialized() // xy
        {
            LoadDefaultConfig();

            if (APIKey == "Сюда АПИ ключ")
            {
                PrintError("Введите АПИ ключ магазина!");
                Interface.Oxide.UnloadPlugin(this.Name);
                return;
            }
            if (ServerID == "Сюда ID сервера")
            {
                PrintError("Введите ID сервера!");
                Interface.Oxide.UnloadPlugin(this.Name);
                return;
            }
            
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("DailyBonus/Players"))
                dailyPlayers = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, DailyPlayer>>("DailyBonus/Players");
            
            
            PrintWarning("Плагин - 'Ежедневная награда' загружен!");
            PrintWarning("Разработчик - HOUGAN!");
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TODAY.GOT"] = "<size=16><color=#FF5733>Ежедневный</color> бонус</size>" +
                                "\n" +
                                "\nВы уже <color=#FF5733>получили</color> награду за сегодня!",
                ["TODAY.SUCCESS"] = "<size=16><color=#FF5733>Ежедневный</color> бонус</size>" +
                                    "\n" +
                                    "\nВы <color=#FF5733>успешно</color> получили <color=#FF5733>{0}</color> рублей!" +
                                    "\n<size=10>Заходите <color=#FF5733>завтра</color> и получите <color=#FF5733>{1}</color> рублей</size>",
                ["ERROR"] = "Ошибка сервера, напишите в группу! [{0}]"
            }, this);
            if (MySQL_Use)
            {
                PrintWarning("Включен режим эксперта. Могут быть задержки в выполнении функций плагина!");
                MySQL_Initialize();
            }
            BasePlayer.activePlayerList.ForEach(OnPlayerInit);
        }
        
        protected override void LoadDefaultConfig()
        {
            Config["GS. API Ключ"] = APIKey = GetConfig("GS. API Ключ", "Сюда АПИ ключ");
            Config["GS. ID Магазина"] = ServerID = GetConfig("GS. ID Магазина", "Сюда ID магазина");
            Config["Moscow. У вас магазин ОВХ?"] = Moscow = GetConfig("Moscow. У вас магазин ОВХ?", false);
            Config["Награда - стартовый баланс за первый день"] = DefaultMoney = GetConfig("Награда - стартовый баланс за первый день", 1);
            Config["Защита от слишком большого пополнения"] = MaxDeposit = GetConfig("Защита от слишком большого пополнения", 10);
            
            
            Config["MySQL. Использовать MySQL (TRUE только если знаете что делаете!)"] = MySQL_Use = GetConfig("MySQL. Использовать MySQL (TRUE только если знаете что делаете!)", false);
            Config["MySQL. IP Сервера с БД"] = MySQL_IP = GetConfig("MySQL. IP Сервера с БД", "localhost");
            Config["MySQL. Порт сервера с БД"] = MySQL_Port = GetConfig("MySQL. Порт сервера с БД", 3306);
            Config["MySQL. Имя базы данных"] = MySQL_DBName = GetConfig("MySQL. Имя базы данных", "dailyreward");
            Config["MySQL. Название таблицы"] = MySQL_TBName = GetConfig("MySQL. Название таблицы", "jointable");
            Config["MySQL. Имя пользователя"] = MySQL_Name = GetConfig("MySQL. Имя пользователя", "root");
            Config["MySQL. Пароль пользователя"] = MySQL_Password = GetConfig("MySQL. Пароль пользователя", "root1234");
            
            SaveConfig();
        }

        private void Unload() => Interface.Oxide.DataFileSystem.WriteObject("DailyBonus/Players", dailyPlayers);

        private void OnPlayerInit(BasePlayer player)
        {
            if (!dailyPlayers.ContainsKey(player.userID))
            {
                dailyPlayers.Add(player.userID, new DailyPlayer
                {
                    DisplayName = player.displayName,
                    UserID = player.userID,

                    Joins = new Dictionary<string, bool>()
                });

                
                if (SaveRestore.SaveCreatedTime.Day - DateTime.Now.Day > 7)
                {
                    dailyPlayers[player.userID].Joins = new Dictionary<string, bool>
                    {
                        [SaveRestore.SaveCreatedTime.Day.ToString()] = false,
                        [SaveRestore.SaveCreatedTime.AddDays(1).Day.ToString()] = false,
                        [SaveRestore.SaveCreatedTime.AddDays(2).Day.ToString()] = false,
                        [SaveRestore.SaveCreatedTime.AddDays(3).Day.ToString()] = false,
                        [SaveRestore.SaveCreatedTime.AddDays(4).Day.ToString()] = false,
                        [SaveRestore.SaveCreatedTime.AddDays(5).Day.ToString()] = false,
                        [SaveRestore.SaveCreatedTime.AddDays(6).Day.ToString()] = false,
                    };
                }
                else
                {
                    dailyPlayers[player.userID].Joins = new Dictionary<string, bool>
                    {
                        [DateTime.Now.Day.ToString()] = false,
                        [DateTime.Now.AddDays(1).Day.ToString()] = false,
                        [DateTime.Now.AddDays(2).Day.ToString()] = false,
                        [DateTime.Now.AddDays(3).Day.ToString()] = false,
                        [DateTime.Now.AddDays(4).Day.ToString()] = false,
                        [DateTime.Now.AddDays(5).Day.ToString()] = false,
                        [DateTime.Now.AddDays(6).Day.ToString()] = false,
                    }; 
                }
            }

            if (!dailyPlayers[player.userID].Joins.ContainsKey(DateTime.Now.Day.ToString()))
            {
                dailyPlayers.Remove(player.userID);
                NextTick(() => OnPlayerInit(player));
                return;
            }

            if (dailyPlayers[player.userID].Joins[DateTime.Now.Day.ToString()])
                return;

            if (player.IsReceivingSnapshot)
            {
                NextTick(() =>
                {
                    OnPlayerInit(player);
                    return;
                });
            }

            DailyGUI(player);
        }

        #endregion

        #region GUI
        
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        [ChatCommand("daily")]
        private void DailyGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.3265625 0.4030093", AnchorMax = "0.6734375 0.5969907" },
                Image = { Color = HexToRustFormat("#A1A1A13F") }
            }, "Hud", Layer);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100" },
                Button = { Close = Layer, Color = "0 0 0 0" },
                Text = { Text = "" }
            }, Layer, Layer + ".Close");
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".Header.BG",
                Components =
                {
                    new CuiImageComponent { Color = HexToRustFormat("#D6D6D6FF") },
                    new CuiRectTransformComponent { AnchorMin = "0 0.7147974", AnchorMax = "0.997 1" },
                    new CuiOutlineComponent { Color = HexToRustFormat("#3434347D"), Distance = "0 3" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer + ".Header.BG",
                Name = Layer + ".Header.HEADER",
                Components =
                {
                    new CuiTextComponent { Text = "ЕЖЕДНЕВНАЯ НАГРАДА", Color = HexToRustFormat("#343434FF"), FontSize = 24, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent { AnchorMin = "0 0.2845186", AnchorMax = "1 1" },
                    new CuiOutlineComponent { Color = HexToRustFormat("#3434347D"), Distance = "0.155 0.155" }
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer + ".Header.BG",
                Name = Layer + ".Header.HELP",
                Components =
                {
                    new CuiTextComponent { Text = "Заходите каждый день, чтобы получить увеличенный бонус!", Color = HexToRustFormat("#343434FF"), FontSize = 14, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 0.4184099" },
                }
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".Container",
                Components =
                {
                    new CuiImageComponent() { Color = "0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.2261503", AnchorMax = "1 0.6843842" },
                }
            });
            
            int money = 0;
            int current = 0;
            foreach (var check in dailyPlayers[player.userID].Joins)
            {
                container.Add(new CuiElement
                {
                    Parent = Layer + ".Container",
                    Name = Layer + $".Container.{check.Key}",
                    Components =
                    {
                        new CuiImageComponent { Color = HexToRustFormat(check.Value ? "#3BA75BFF" : DateTime.Now.Day < Convert.ToInt32(check.Key) ? "#9A9A9AFF" : DateTime.Now.Day != Convert.ToInt32(check.Key) ? "#DC4444FF" : "#2B81B4FF") },
                        new CuiRectTransformComponent { AnchorMin = $"{0.007704161 + 0.1418 * current} 0.05208336", AnchorMax = $"{0.1377565 + 0.1418 * current} 0.9479166" },
                        new CuiOutlineComponent { Color = HexToRustFormat("#3434347D"), Distance = "1.5 1.5" }
                    }
                });
                container.Add(new CuiElement
                {
                    Parent = Layer + $".Container.{check.Key}",
                    Components =
                    {
                        new CuiTextComponent { Text = check.Key, Color = HexToRustFormat(DateTime.Now.Day == Convert.ToInt32(check.Key) ? "#343434FF" : "#FFFFFFFF"), FontSize = 35, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = $"0 0.2325586", AnchorMax = $"1 0.9069777" },
                        new CuiOutlineComponent { Color = HexToRustFormat("#3434347D"), Distance = DateTime.Now.Day == Convert.ToInt32(check.Key) ? "0.5 0.5" : "0 0" }
                    }
                });
                string status = !check.Value ? "ПРОПУСК" : "ПОЛУЧЕНО";
                if (Convert.ToInt32(check.Key) >= DateTime.Now.Day)
                {
                    money += 5;
                    if (!check.Value)
                        status = money + " РУБЛЕЙ";
                }
                
                container.Add(new CuiElement
                {
                    Parent = Layer + $".Container.{check.Key}",
                    Components =
                    {
                        new CuiTextComponent { Text = status, Color = "1 1 1 1", FontSize = 9, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = $"0 0.05813904", AnchorMax = $"1 0.3837207" }
                    }
                });

                current++;
            }
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".Get",
                Components =
                {
                    new CuiImageComponent { Color = HexToRustFormat("#D6D6D6FF") },
                    new CuiOutlineComponent { Color = HexToRustFormat("#3434347D"), Distance = "2 2" },
                    new CuiRectTransformComponent { AnchorMin = "0.289039 0.03699267", AnchorMax = "0.710961 0.2040572" },
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer + ".Get",
                Components =
                {
                    new CuiTextComponent { Text = "ЗАБРАТЬ ПРИЗ", Color = HexToRustFormat("#343434FF"), FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                    new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }
            });
            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = "db.get", Close = Layer },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = "" }
            }, Layer + ".Get");

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        #endregion
    }
}

// --- End of file: DailyReward.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Recycler.cs ---
// --- Original Local Path: Recycler.cs ---

﻿using System;
using UnityEngine;
using Oxide.Core;
using System.Text;
using System.Linq;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Recycler", "Fartus", "1.0.0")]
	[Description("Карманный переработчик ресурсов")]
    public class Recycler : RustPlugin
    {
        #region CLASSES

        public class RecyclerBox : MonoBehaviour
        {
            private const int SIZE = 1;

            StorageContainer storage;
            BasePlayer player;

            public void Init(StorageContainer storage, BasePlayer player)
            {
                this.storage = storage;
                this.player = player;
                storage.inventory.onItemAddedRemoved += (item, insert) => {if (insert)RecycleItem(item);};
            }

            public bool HasRecyclable(Item slot) => slot.info.Blueprint != null;
            void RecycleItem(Item slot)
            {
                    
                bool flag = false;
                if (!HasRecyclable(slot)) return;
                float single = 0.5f;
                if (slot.hasCondition)
                {
                    single = Mathf.Clamp01(single * slot.conditionNormalized * slot.maxConditionNormalized);
                }
                int num = 1;
                if (slot.amount > 1)
                {
                    num = slot.amount;
                }
                if (slot.info.Blueprint.scrapFromRecycle > 0)
                {
                    Item item = ItemManager.CreateByName("scrap", slot.info.Blueprint.scrapFromRecycle * num, (ulong)0);
                    MoveItemToOutput(item);
                }
                slot.UseItem(num);
                foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
                {
                    float blueprint = (float)ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
                    int num1 = 0;
                    if (blueprint > 1f)
                    {
                        num1 = Mathf.CeilToInt(Mathf.Clamp(blueprint * single * UnityEngine.Random.Range(1f, 1f), 1f, ingredient.amount) * (float)num);
                    }
                    else
                    {
                        for (int j = 0; j < num; j++)
                        {
                            if (UnityEngine.Random.Range(0f, 1f) <= single)
                            {
                                num1++;
                            }
                        }
                    }
                    if (num1 > 0)
                    {
                        MoveItemToOutput(ItemManager.Create(ingredient.itemDef, num1, (ulong)0));
                    }
                }
            }

            public void MoveItemToOutput(Item newItem)
            {
                if (!newItem.MoveToContainer(player.inventory.containerMain))
                    newItem.Drop(player.GetCenter(), player.GetDropVelocity());
            }

            public static RecyclerBox Spawn(BasePlayer player)
            {
                player.EndLooting();
                var storage = SpawnContainer(player);
                var box = storage.gameObject.AddComponent<RecyclerBox>();
                box.Init(storage, player);
                return box;
            }
            
            private static StorageContainer SpawnContainer(BasePlayer player)
            {
                var position = player.transform.position - new Vector3(0, 100, 0);
                
                var storage = GameManager.server.CreateEntity("assets/bundled/prefabs/static/recycler_static.prefab") as StorageContainer;
                if (storage == null) return null;
                storage.transform.position = position;
                storage.panelName = "recycler";
                ItemContainer container = new ItemContainer { playerOwner = player };
                container.ServerInitialize((Item)null, SIZE);
                if ((int)container.uid == 0)
                    container.GiveUID();
                storage.inventory = container;
                if (!storage) return null;
                storage.SendMessage("SetDeployedBy", player, (SendMessageOptions)1);
                storage.Spawn();
                return storage;
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                Close();
            }

            public void Close()
            {
                foreach (var item in Items)
                    item.MoveToContainer(player.inventory.containerMain);
                ClearItems();
                storage.Kill();
            }

            public void StartLoot()
            {
                storage.SetFlag(BaseEntity.Flags.Open, true, false);
                player.inventory.loot.StartLootingEntity(storage, false);
                player.inventory.loot.AddContainer(storage.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", storage.panelName);
                storage.SendNetworkUpdate();
                storage.DecayTouch();
            }

            public void Push(List<Item> items)
            {
                for (int i = items.Count - 1; i >= 0; i--)
                    items[i].MoveToContainer(storage.inventory);
            }

            public void ClearItems()
            {
                storage.inventory.itemList.Clear();
            }

            public List<Item> Items => storage.inventory.itemList.Where(i => i != null).ToList();

        }

        #endregion

        #region OXIDE HOOKS

        void OnServerInitialized()
        {
            permission.RegisterPermission(permissionName, this);
		}
		
	    const string permissionName = "recycler.use";
        
        #endregion

        #region COMMANDS

        [ChatCommand("rec")]
        void cmdChatRecycler(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                SendReply(player,"У вас нет доступа к переработчику!");
				return;
            }
            if (InDuel(player)) return;
            timer.Once(0.3f, () => { OpenRecycler(player); });
        }

        #endregion

        #region CORE

        void OpenRecycler(BasePlayer player)
        {
            var box = RecyclerBox.Spawn(player);
            box.StartLoot();
        }

        #endregion

        #region EXTERNAL CALLS

        [PluginReference] Plugin Duels;

        bool InDuel(BasePlayer player) => Duels?.Call<bool>("inDuel", player) ?? false;

        #endregion
    }
}


// --- End of file: Recycler.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPTeleportation.cs ---
// --- Original Local Path: TPTeleportation.cs ---

﻿using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("TPTeleportation", "Sempai#3239", "5.0.0")]
    class TPTeleportation : RustPlugin
    {
        [PluginReference] Plugin ImageLibrary, Clans;
        [PluginReference] Plugin Friends;
        Dictionary<ulong, Vector3> lastPositions = new Dictionary<ulong, Vector3>();
        Dictionary<BasePlayer, int> spectatingPlayers = new Dictionary<BasePlayer, int>();

        private const string Layer = "lay";

        private class ButtonEntry
        {
            public string Name;
            public string Sprite;
            public string Command;
            public string Color;
            public bool Close;
        }

        bool IsTeamate(BasePlayer player, ulong targetID)
        {
            if (player.currentTeam == 0) return false;
            //player.currentTeam
            var team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
            if (team == null) return false;

            var list = RelationshipManager.ServerInstance.FindTeam(player.currentTeam).members.Where(p => p == targetID).ToList();
            return list.Count > 0;
        }

        class TP
        {
            public BasePlayer Player;
            public BasePlayer Player2;
            public Vector3 pos;
            public bool EnabledShip;
            public int seconds;
            public bool TPL;
            public bool TownTp;
            public TP(BasePlayer player, Vector3 Pos, int Seconds, bool EnabledShip1, bool tpl, BasePlayer player2 = null, bool townTp = false)
            {
                Player = player;
                pos = Pos;
                seconds = Seconds;
                EnabledShip = EnabledShip1;
                Player2 = player2;
                TPL = tpl;
                TownTp = townTp;
            }
        }

        int homelimitDefault;
        bool homecupboardblock;
        Dictionary<string, int> homelimitPerms;
        int tpkdDefault;
        Dictionary<string, int> tpkdPerms;
        int tpkdhomeDefault;
        Dictionary<string, int> tpkdhomePerms;
        int teleportSecsDefault;
        int resetPendingTime;
        bool restrictCupboard;
        bool enabledTPR;
        bool homecupboard;
        bool adminsLogs;
        bool foundationOwner;
        bool foundationOwnerFC;

        bool restrictTPRCupboard;
        bool foundationEx;
        bool OutpostEnable;
        bool BanditEnable;
        string Info;
        bool wipedData;
        bool createSleepingBug;
        string EffectPrefab1;
        string EffectPrefab;
        bool EnabledShipTP;
        bool EnabledBallonTP;
        bool CancelTPMetabolism;
        bool CancelTPCold;
        bool CancelTPRadiation;
        bool FriendsEnabled;
        bool CancelTPWounded;
        bool EnabledTPLForPlayers;
        int TPLCooldown;
        int TplPedingTime;
        bool TPLAdmin;
//mazzepa new config
	int DefaultTpToTown;
	int DefaultCooldownTpToTown;
	Dictionary<string, int> TpTownsCooldowns;
	Dictionary<string, int> TeleportSecsTownsPerms;

        static DynamicConfigFile config;
        Dictionary<string, int> teleportSecsPerms;
        void OnNewSave()
        {
            if (wipedData)
            {
                PrintWarning("Обнаружен вайп. Очищаем данные с data/Teleportation");
                WipeData();
            }
        }
        void WipeData()
        {
            LoadData();
            tpsave = new List<TPList>();
            homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
            SaveData();
        }
        protected override void LoadDefaultConfig()
        {
            GetVariable(Config, "Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out homecupboard, true);
            GetVariable(Config, "Удалять точку телепрта если она в билде в какой не авторизован игрок", out homecupboardblock, true);
            GetVariable(Config, "Звук уведомления при получение запроса на телепорт (пустое поле = звук отключен)", out EffectPrefab1, "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab");
            GetVariable(Config, "Звук предупреждения (пустое поле = звук отключен)", out EffectPrefab, "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
            GetVariable(Config, "Разрешать телепортироваться в город НПС", out OutpostEnable, true);
            GetVariable(Config, "Разрешать телепортироваться в город Бандитов", out BanditEnable, false);
            GetVariable(Config, "Информация плагина", out Info, "Ахуенный плагин скилов всем советую, а кто не купит, тот гомосек");
            GetVariable(Config, "Разрешать сохранять местоположение только на фундаменте", out foundationEx, true);
            GetVariable(Config, "Создавать объект при сохранении местоположения в виде Sleeping Bag", out createSleepingBug, true);
            GetVariable(Config, "Автоматический вайп данных при генерации новой карты", out wipedData, true);
            GetVariable(Config, "Запрещать принимать запрос на телепортацию в зоне действия чужого шкафа", out restrictCupboard, true);
            GetVariable(Config, "Запрещать сохранять местоположение если игрок не является владельцем фундамента", out foundationOwner, true);
            GetVariable(Config, "Разрешать сохранять местоположение если игрок является другом или соклановцем или тимейтом владельца фундамента ", out foundationOwnerFC, true);
            GetVariable(Config, "Логировать использование команд для администраторов", out adminsLogs, true);
            GetVariable(Config, "Включить телепортацию (TPR/TPA) только к друзьям, соклановкам или тимейту", out FriendsEnabled, true);
            GetVariable(Config, "Разрешить команду TPR игрокам (false = /tpr не будет работать)", out enabledTPR, true);
            GetVariable(Config, "Разрешить отправку и приём телепорта и телепорт домой на корабле", out EnabledShipTP, true);
            GetVariable(Config, "Разрешить отправку и приём телепорта на воздушном шаре", out EnabledBallonTP, true);
            GetVariable(Config, "Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out restrictTPRCupboard, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если у него кровотечение", out CancelTPMetabolism, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если игрок ранен", out CancelTPWounded, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если ему холодно", out CancelTPCold, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если он облучен радиацией", out CancelTPRadiation, true);
            GetVariable(Config, "Время ответа на запрос телепортации (в секундах)", out resetPendingTime, 15);
            GetVariable(Config, "Ограничение на количество сохранённых местоположений", out homelimitDefault, 3);
            GetVariable(Config, "[TPL] Разрешить игрокам использовать TPL", out EnabledTPLForPlayers, false);
            GetVariable(Config, "[TPL] Задержка телепортации игрока на TPL", out TplPedingTime, 15);
            GetVariable(Config, "[TPL] Cooldown телепортации игрока на TPL", out TPLCooldown, 15);
            GetVariable(Config, "[TPL] Телепортировать админа без задержки и кулдауна?", out TPLAdmin, true);
            GetVariable(Config, "Дефолтная задержка перед телепортацией в город", out DefaultTpToTown, 15);
	    GetVariable(Config, "Дефолтное кд телепортации в город", out DefaultCooldownTpToTown, 150);
	    Config["Кулдаун на тп в город"] = TpTownsCooldowns = GetConfig("Кулдаун на тп в город", new Dictionary<string, object>()
	    {
	    {
	    "tpteleportation.vip", 50
	    },
	    {
	    "tpteleportation.advanced", 100
	    },
	    }).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
	    PermissionService.RegisterPermissions(this, TpTownsCooldowns.Keys.ToList());
	
	    Config["Задержка перед тп в город"] = TeleportSecsTownsPerms = GetConfig("Задержка перед тп в город", new Dictionary<string, object>()
	    {
	    {
	    "tpteleportation.vip", 10
	    },
	    {
	    "tpteleportation.advanced", 5
	    },
	    }).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
	    PermissionService.RegisterPermissions(this, TeleportSecsTownsPerms.Keys.ToList());
            Config["Ограничение на количество сохранённых местоположений с привилегией"] = homelimitPerms = GetConfig("Ограничение на количество сохранённых местоположений с привилегией", new Dictionary<string, object>() {
                    {
                    "tpteleportation.vip", 5
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, homelimitPerms.Keys.ToList());
            GetVariable(Config, "Длительность задержки перед телепортацией (в секундах)", out teleportSecsDefault, 15);
            Config["Длительность задержки перед телепортацией с привилегией (в секундах)"] = teleportSecsPerms = GetConfig("Длительность задержки перед телепортацией с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "tpteleportation.vip", 10
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, teleportSecsPerms.Keys.ToList());
            GetVariable(Config, "Длительность перезарядки телепорта (в секундах)", out tpkdDefault, 300);
            Config["Длительность перезарядки телепорта с привилегией (в секундах)"] = tpkdPerms = GetConfig("Длительность перезарядки телепорта с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "tpteleportation.vip", 150
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdPerms.Keys.ToList());
            GetVariable(Config, "Длительность перезарядки телепорта домой (в секундах)", out tpkdhomeDefault, 300);
            Config["Длительность перезарядки телепорта домой с привилегией (в секундах)"] = tpkdhomePerms = GetConfig("Длительность перезарядки телепорта домой с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "tpteleportation.vip", 150
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdhomePerms.Keys.ToList());
            SaveConfig();
        }
        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));
        public static void GetVariable<T>(DynamicConfigFile config, string name, out T value, T defaultValue)
        {
            config[name] = value = config[name] == null ? defaultValue : (T)Convert.ChangeType(config[name], typeof(T));
        }
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();
            public static bool HasPermission(ulong uid, string permissionName)
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(uid.ToString(), permissionName);
            }
            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");
                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        public BasePlayer FindBasePlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            return default(BasePlayer);
        }

        List<Vector3> OutpostSpawns = new List<Vector3>();
        List<Vector3> BanditSpawns = new List<Vector3>();

        void FindTowns()
        {
            foreach (MonumentInfo monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (monument.name.ToLower().Contains("compound"))
                {
                    List<BaseEntity> list = new List<BaseEntity>();
                    Vis.Entities(monument.transform.position, 20, list);
                    foreach (BaseEntity entity in list)
                    {
                        if (entity.name.Contains("researchtable_static"))
                        {
                            Vector3 chairPos = entity.transform.position;
                            chairPos.x += 10;
                            if (!OutpostSpawns.Contains(chairPos)) OutpostSpawns.Add(chairPos);
                        }
                    }
                }
                else if (monument.name.Contains("bandit"))
                {
                    var list = new List<BaseEntity>();
                    Vis.Entities(monument.transform.position, 20, list);
                    foreach (BaseEntity entity in list)
                    {
                        if (entity.name.Contains("chair_c.static"))
                        {
                            Vector3 chairPos = entity.transform.position;
                            chairPos.y += 1;
                            if (!BanditSpawns.Contains(chairPos)) BanditSpawns.Add(chairPos);
                        }
                    }
                }
            }
        }
        private readonly int groundLayer = LayerMask.GetMask("Terrain", "World");
        private readonly int buildingMask = Rust.Layers.Server.Buildings;
        Dictionary<ulong, Dictionary<string, Vector3>> homes;
        List<TPList> tpsave;
        class TPList
        {
            public string Name;
            public Vector3 pos;
        }
        Dictionary<ulong, int> cooldownsTP = new Dictionary<ulong, int>();
        Dictionary<ulong, int> cooldownsHOME = new Dictionary<ulong, int>();
        Dictionary<ulong, int> cooldownsTowns = new Dictionary<ulong, int>();
        List<TP> tpQueue = new List<TP>();
        List<TP> pendings = new List<TP>();
        List<ulong> sethomeBlock = new List<ulong>();

        public List<BasePlayer> OpenTeleportMenu = new List<BasePlayer>();

        private void DDrawMenu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            List<ButtonEntry> buttons = new List<ButtonEntry>();

            container.Add(new CuiElement
            {
                Name = Layer + ".Main",
                Parent = ".Mains",
                Components = 
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fontp") },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });  

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, Layer + ".Main"); 

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.78 0.805", AnchorMax = "0.795 0.833", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "tpdesc" },
                Text = { Text = "?", Color = "1 1 1 0.7", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Main");                     

            container.Add(new CuiElement
            {
                Name = "TPMENULAYER",
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiImageComponent { Color =  "0.35 0.34 0.32 0", Material = "assets/icons/iconmaterial.mat" },
                    new CuiRectTransformComponent {AnchorMin = "0.2 0.1", AnchorMax = "0.8 0.79"}
                }
            });

            container.Add(new CuiElement
            {
                Name = "TPMENULAYER1",
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiImageComponent { Color =  "0 0 0 0"},
                    new CuiRectTransformComponent {AnchorMin = "0.362 0.312", AnchorMax = "0.71 0.403"}
                }
            });
            container.Add(new CuiElement
            {
                Name = "TPMENULAYER2",
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiImageComponent { Color =  "0 0 0 0" },
                    new CuiRectTransformComponent {AnchorMin = "0.362 0.44", AnchorMax = "0.71 0.532"}
                }
            });                            

            container.Add(new CuiElement
            {
                Parent = "TPMENULAYER",
                Components = {
                    new CuiTextComponent() { Color = "1 1 1 0.45", Text = "Телепортация\nк другу", FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"  },
                    new CuiRectTransformComponent { AnchorMin = "0.145 0.2", AnchorMax = "0.25 0.85" },
                }
            });

            container.Add(new CuiElement
            {
                Parent = "TPMENULAYER",
                Components = {
                    new CuiTextComponent() { Color = "1 1 1 0.45", Text = "Телепортация\nдомой", FontSize = 12, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"  },
                    new CuiRectTransformComponent { AnchorMin = "0.145 0.285", AnchorMax = "0.25 0.4" },
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.311 0.73", AnchorMax = "0.396 0.863" },
                Button = { Close = Layer, Command = $"chat.say /banditcamp", Color = "0 0 0 0" },
                Text = { Text = $"\n\nГород бандитов", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.3", Font = "robotocondensed-bold.ttf" }
            }, "TPMENULAYER");   

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.409 0.73", AnchorMax = "0.494 0.863" },
                Button = { Close = Layer, Command = $"chat.say /outpost", Color = "0 0 0 0" },
                Text = { Text = $"\n\nГород\nNPC", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.45", Font = "robotocondensed-bold.ttf" }
            }, "TPMENULAYER");

            if (CheckGetHomes(player).Count < GetHomeLimit(player.userID))
            {
                var pos = GetGrid(player.transform.position, false);
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.507 0.73", AnchorMax = "0.592 0.863" },
                        Button = { Close = Layer, Command = $"tp.cmd sethome {pos}", Color = "0 0 0 0" },
                        Text = { Text = $"\n\nСохранить Дом", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.45", Font = "robotocondensed-bold.ttf" }
                    }, "TPMENULAYER");
                }  
            }

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.311 0.66", AnchorMax = "0.494 0.71" },
                Button = { Close = Layer, Command = $"chat.say /tpa", Color = "0 0 0 0" },
                Text = { Text = $"Принять ТП", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.45", Font = "robotocondensed-bold.ttf" }
            }, "TPMENULAYER");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.605 0.73", AnchorMax = "0.69 0.863" },
                Button = { Close = Layer, Command = $"chat.say /atp", Color = "0 0 0 0" },
                Text = { Text = $"\n\nАвто\n прием ТП", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.45", Font = "robotocondensed-bold.ttf" }
            }, "TPMENULAYER");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.507 0.66", AnchorMax = "0.69 0.71" },
                Button = { Close = Layer, Command = $"chat.say /tpc", Color = "0 0 0 0" },
                Text = { Text = "Отклонить ТП", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.45", Font = "robotocondensed-bold.ttf" }
            }, "TPMENULAYER");

            if (CheckGetHomes(player).Count >= 1)
            {
                float width = 0.15f, height = 1f, startxBox = 0.005f, startyBox = 1f - height, xmin = startxBox, ymin = startyBox;
                foreach (var check in CheckGetHomes(player))
                {
                    container.Add(new CuiButton
                    {   
                        RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMax = "0 0" },
                        Button = { Close = Layer, Command = $"tp.cmd home {check.Key}", Color = "0 0 0 0" },
                        Text = { Text = $"\n\n{check.Key}", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.3", Font = "robotocondensed-bold.ttf" }
                    }, "TPMENULAYER1", "Homes" );

                    container.Add(new CuiElement
                    {
                        Parent = "Homes",
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonhome") },
                            new CuiRectTransformComponent { AnchorMin = "0 0.3", AnchorMax = "1.01 1", OffsetMin = "24 13", OffsetMax = "-24 -13" },
                        }
                    }); 

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.8 0.8", AnchorMax = "1 1" },
                        Button = { Command = $"tp.cmd removehome {check.Key}", Color = "0.88 0.34 0.34 0.5" },
                        Text = { Text = "✕", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", Font = "robotocondensed-regular.ttf" }
                    }, "Homes"); 

                    xmin += width + 0.018f;
                    if (xmin + width >= 1)
                    {
                        xmin = startxBox + 0.1f;
                        ymin -= height;
                    }
                }  
            }

            RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
            if (player.currentTeam != 0 && playerTeam.members.Count >= 2)
            {
                float width = 0.15f, height = 1f, startxBox = 0.005f, startyBox = 1f - height, xmin = startxBox, ymin = startyBox;
                foreach (var check in playerTeam.members)
                {
                    BasePlayer friend = FindBasePlayer(check.ToString());
                    if (friend.displayName != player.displayName) {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMax = "0 0" },
                            Button = { Close = Layer, Color = "0 0 0 0.7", FadeIn = 0.1f },
                            Text = { Text = $"", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.45", Font = "robotocondensed-bold.ttf" }
                        }, "TPMENULAYER2", "Users");

                        container.Add(new CuiElement
                        {
                            Parent = "Users",
                            Components = 
                            {
                                new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", friend.UserIDString) },
                                new CuiRectTransformComponent { AnchorMin = "0 0.25", AnchorMax = "1 1", OffsetMin = "17 9", OffsetMax = "-17 -9" },
                            }
                        }); 

                        container.Add(new CuiElement
                        {
                            Parent = "Users",
                            Components = 
                            {
                                new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonavatar") },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            }
                        }); 

                        var online = friend.IsConnected ? "fononline" : "fonoffline";
                        container.Add(new CuiElement
                        {
                            Parent = "Users",
                            Components = 
                            {
                                new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", online) },
                                new CuiRectTransformComponent { AnchorMin = "0.35 0.7", AnchorMax = "0.68 0.9", OffsetMax = "0 0" },
                            }
                        });

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.78", OffsetMax = "0 0" },
                            Button = { Color = "0 0 0 0" },
                            Text = { Text = $"\n\n{friend.displayName}", Color = "1 1 1 0.3", Align = TextAnchor.UpperCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
                        }, "Users");

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { Color = "0 0 0 0", Command = $"tp.cmd tpr {friend.displayName}" },
                            Text = { Text = "" }
                        }, "Users");

                        xmin += width + 0.018f;
                        if (xmin + width >= 1)
                        {
                            xmin = startxBox + 0.1f;
                            ymin -= height;
                        }
                    }
                }
            } 

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("tpdesc")]
        void DescUI(ConsoleSystem.Arg args) {
            var player = args.Player();
            CuiHelper.DestroyUi(player, Layer + ".Main" + ".Description");
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = Layer + ".Main" + ".Description",
                Parent = Layer + ".Main",
                Components = {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonDescription") },
                    new CuiRectTransformComponent { AnchorMin = $"0.58 0.6", AnchorMax = $"0.8 0.8" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.9 1" },
                Text = { Text = $"Описание телепортации", Color = "1 1 1 0.65",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, Layer + ".Main" + ".Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0", AnchorMax = "1 0.7" },
                Text = { Text = $"{Info}", Color = "1 1 1 0.65",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, Layer + ".Main" + ".Description");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9 0.82", AnchorMax = "0.98 0.98" },
                Button = { Close = Layer + ".Main" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, Layer + ".Main" + ".Description");

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("tp.cmd")]
        void PlayerCMD(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            switch (args.Args[0].ToLower())
            {
                case "tpr":
                    player.Command($"chat.say \"/tpr {args.Args[1]}\"");
                    OpenTeleportMenu.Remove(player);
                    break;
                case "tpc":
                    player.Command($"chat.say \"/tpc\"");
                    OpenTeleportMenu.Remove(player);
                    break;
                case "tpa":
                    player.Command($"chat.say \"/tpa\"");
                    OpenTeleportMenu.Remove(player);
                    break;
                case "home":
                    player.Command($"chat.say \"/home {args.Args[1]}\"");
                    OpenTeleportMenu.Remove(player);
                    break;
                case "sethome":
                    player.Command($"chat.say \"/sethome {args.Args[1]}\"");
                    OpenTeleportMenu.Remove(player);
                    break;
                case "removehome":
                    player.Command($"chat.say \"/removehome {args.Args[1]}\"");
                    OpenTeleportMenu.Remove(player);
                    break;
                case "atp":
                    player.Command("chat.say /atp");
                    DDrawMenu(player);
                    break;
            }
        }

        Dictionary<string, Vector3> CheckGetHomes(BasePlayer player)
        {
            var homelist = GetHomes(player.userID) ?? new Dictionary<string, Vector3>();
            return homelist.GroupBy(p => p.Key).ToDictionary(p => p.Key, p => p.First().Value);
        }

        public List<ulong> GetFriends(ulong playerid = 2952192)
        {
            if (Friends)
            {
                var friends = Friends?.Call("GetFriends", playerid) as ulong[];
                return friends.ToList();
            }

            return new List<ulong>();
        }

        private string GetGrid(Vector3 position, bool addVector)
        {
            var roundedPos = new Vector2(World.Size / 2 + position.x, World.Size / 2 - position.z);
            var grid = $"{NumberToLetter((int)(roundedPos.x / 150))}{(int)(roundedPos.y / 150)}";
            if (addVector) grid += $" {position.ToString().Replace(",", "")}";

            return grid;
        }

        private string NumberToLetter(int num)
        {
            var num2 = Mathf.FloorToInt((float)(num / 26));
            var num3 = num % 26;
            var text = string.Empty;

            if (num2 > 0) for (var i = 0; i < num2; i++)
                    text += Convert.ToChar(65 + i);

            return text + Convert.ToChar(65 + num3);
        }

        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        void AddPlayerAutoTP(BasePlayer player)
        {
            if (!AutoTPA.ContainsKey(player.userID))
                AutoTPA.Add(player.userID, new AutoTPASettings());

            if (GetFriends(player.userID).Count >= 0)
            {
                foreach (var friend in GetFriends(player.userID))
                {
                    var covFriend = covalence.Players.FindPlayerById(friend.ToString());
                    if (covFriend == null) continue;

                    if (AutoTPA[player.userID].PlayersList.ContainsKey(covFriend.Name)) return;
                    AutoTPA[player.userID].PlayersList.Add(covFriend.Name, ulong.Parse(covFriend.Id));
                }
            }
        }

        [ChatCommand("atp")]
        void cmdAutoTPA(BasePlayer player, string com, string[] args)
        {
            if (!AutoTPA.ContainsKey(player.userID))
            {
                AutoTPA.Add(player.userID, new AutoTPASettings());
            }

            if (args == null || args.Length <= 0)
            {
                if (AutoTPA[player.userID].Enabled)
                {
                    AutoTPA[player.userID].Enabled = false;
                    SendReply(player, "Вы успешно <color=#FDAE37>отключили</color> автопринятие запроса на телепорт");
                    DDrawMenu(player);
                }
                else
                {
                    AutoTPA[player.userID].Enabled = true;
                    SendReply(player, "Вы успешно <color=#FDAE37>включили</color> автопринятие запроса на телепорт");
                    DDrawMenu(player);
                }
            }
        }



        [ConsoleCommand("sethome")]
        void cmdChatSetHome(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null || arg.Args.Length < 1) return;
            cmdChatSetHome(player, "", new[] {
                    arg.Args[0]
                }
            );
        }
        [ChatCommand("sethome")]
        void cmdChatSetHome(BasePlayer player, string command, string[] args)
        {
            var uid = player.userID;
            var pos = player.PivotPoint();
            var foundation = GetFoundation(pos);
            var bulds = GetBuldings(pos);
            if (foundationEx && foundation == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["foundationmissing"]);
                return;
            }
            if (!foundationEx && bulds == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["foundationmissing"]);
                return;
            }
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeArgsError"]);
                return;
            }
            if (CancelTPMetabolism && player.metabolism.bleeding.value > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.radiationLevel > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (sethomeBlock.Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeBlock"]);
                return;
            }

            if (foundationOwnerFC && foundationOwner)
            {
                if (!foundationEx && bulds.OwnerID != uid)
                {
                    if (!IsTeamate(player, bulds.OwnerID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["foundationownerFC"]);
                        return;
                    }
                }
                if (foundationEx && foundation.OwnerID != uid)
                {
                    if (!IsTeamate(player, bulds.OwnerID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["foundationownerFC"]);
                        return;
                    }
                }
            }
            if (foundationOwner)
            {
                if (foundationEx && foundation.OwnerID != uid && foundationOwnerFC == (IsTeamate(player, bulds.OwnerID)))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationowner"]);
                    return;
                }
                if (!foundationEx && bulds.OwnerID != uid && foundationOwnerFC == (IsTeamate(player, bulds.OwnerID)))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationowner"]);
                    return;
                }
            }
            var name = args[0];
            SetHome(player, name);
        }

        [ChatCommand("removehome")]
        void cmdChatRemoveHome(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["removehomeArgsError"]);
                return;
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
            {
                if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                {
                    sleepingBag.Kill();
                    break;
                }
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            playerHomes.Remove(name);
            SendReply(player, Messages["removehomesuccess"], name);
            DDrawMenu(player);
        }
        [ConsoleCommand("home")]
        void cmdHome(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null || arg.Args.Length < 1) return;
            cmdChatHome(player, "", new[] {
                    arg.Args[0]
                }
            );
        }
        [ConsoleCommand("tpa")]
        void cmdTpa(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            cmdChatTpa(player, "", new String[0]);
        }
        [ChatCommand("homelist")]
        private void cmdHomeList(BasePlayer player, string command, string[] args)
        {
            if (!homes.ContainsKey(player.userID) || homes[player.userID].Count == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var playerHomes = homes[player.userID];
            var time = (GetHomeLimit(player.userID) - playerHomes.Count);
            var homelist = playerHomes.Select(x => GetSleepingBag(x.Key, x.Value) != null ? $"{x.Key} {x.Value}" : $"Дом: {x.Key} {x.Value}");
            foreach (var home in playerHomes.ToList())
            {
                if (createSleepingBug)
                {
                    if (!GetSleepingBag(home.Key, home.Value)) playerHomes.Remove(home.Key);
                }
            }
            SendReply(player, Messages["homeslist"], time, string.Join("\n", homelist.ToArray()));
        }
        [ChatCommand("home")]
        void cmdChatHome(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.radiationLevel > 10)
            {
                SendReply(player, Messages["Radiation"]);
                return;
            }
            int seconds;
            if (cooldownsTowns.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (homecupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tphomecupboard"]);
                    return;
                }
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            var time = GetTeleportTime(player.userID);
            var pos = playerHomes[name];
            SleepingBag bag = GetSleepingBag(name, pos);
            if (createSleepingBug)
            {
                if (bag == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbagmissing"]);
                    playerHomes.Remove(name);
                    return;
                }
                if (homecupboardblock && bag.GetBuildingPrivilege() != null && !bag.GetBuildingPrivilege().IsAuthed(player))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbugbuildblock"]);
                    playerHomes.Remove(name);
                    bag.Kill();
                    return;
                }
            }
            if (!createSleepingBug)
            {
                var bulds = GetBuldings(pos);
                if (bulds == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationmissingR"]);
                    playerHomes.Remove(name);
                    return;
                }
                if (homecupboardblock && bulds.GetBuildingPrivilege() != null && !bulds.GetBuildingPrivilege().IsAuthed(player))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbugbuildblock"]);
                    playerHomes.Remove(name);
                    return;
                }
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (tpQueue.Any(p => p.Player == player) || pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }
            var lastTp = tpQueue.Find(p => p.Player == player);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            tpQueue.Add(new TP(player, pos, time, false, false));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, String.Format(Messages["homequeue"], name, TimeToString(time)));
        }
        [ChatCommand("outpost")]
        void ChatOutpost(BasePlayer player)
        {
            if (!OutpostEnable)
            {
                SendReply(player, "Телепортация в город нпс отключена!");
                return;
            }
            if (OutpostSpawns.Count == 0)
            {
                SendReply(player, "Позиция города нпс не найдена");
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.radiationLevel > 10)
            {
                SendReply(player, Messages["Radiation"]);
                return;
            }
            int seconds;
            if (cooldownsTowns.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            var lastTp = tpQueue.Find(p => p.Player == player);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            tpQueue.Add(new TP(player, OutpostSpawns[new System.Random().Next(OutpostSpawns.Count)], GetKDSecsToTpTown(player.userID), false, false, townTp: true));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, $"Телепортация в город npc будет через {GetKDSecsToTpTown(player.userID)} секунд");
        }
#region MAZZEPA WORKSPACE
	    /// <summary>
	    /// Кулдаун
	    /// </summary>
	    /// <param name="uid"></param>
	    /// <returns></returns>
	    int GetKDToTpTown(ulong uid)
	    {
	    int min = DefaultCooldownTpToTown;
	    foreach (var privilege in TpTownsCooldowns) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
	    return min;
	    }
	    /// <summary>
	    /// Задержка
	    /// </summary>
	    /// <param name="uid"></param>
	    /// <returns></returns>
	    int GetKDSecsToTpTown(ulong uid)
	    {
	    int min = DefaultTpToTown;
	    foreach (var privilege in TeleportSecsTownsPerms)
	    if (PermissionService.HasPermission(uid, privilege.Key))
	    min = Mathf.Min(min, privilege.Value);
	    return min;
	    }
	    #endregion
            [ChatCommand("banditcamp")]
            void ChatBanditcamp(BasePlayer player)
            {
            if (!BanditEnable)
            {
                SendReply(player, "Телепортация в город бандитов отключена!");
                return;
            }
            if (BanditSpawns.Count == 0)
            {
                SendReply(player, "Позиция города бандитов не найдена");
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.radiationLevel > 10)
            {
                SendReply(player, Messages["Radiation"]);
                return;
            }
            int seconds;
            if (cooldownsTowns.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            var lastTp = tpQueue.Find(p => p.Player == player);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            	tpQueue.Add(new TP(player, BanditSpawns[new System.Random().Next(BanditSpawns.Count)], GetKDToTpTown(player.userID), false, false, townTp: true));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, $"Телепортация в город бандитов будет через {GetKDSecsToTpTown(player.userID)} секунд");
        }
        [ChatCommand("tpr")]
        void cmdChatTpr(BasePlayer player, string command, string[] args)
        {
            if (!enabledTPR) return;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tprArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.radiationLevel > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (restrictTPRCupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tpcupboard"]);
                    return;
                }
            }
            var name = args[0];
            var target = FindBasePlayer(name);
            if (target == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["playermissing"]);
                return;
            }
            if (target == player)
            {
                SendReply(player, Messages["playerisyou"]);
                return;
            }
            if (FriendsEnabled)
                if (!IsTeamate(player, target.userID))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["PlayerNotFriend"]);
                    return;
                }
            int seconds = 0;
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpcupboard"]);
                return;
            }

            if (cooldownsTP.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (tpQueue.Any(p => p.Player == player) || pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }

            if (tpQueue.Any(p => p.Player == target) || pendings.Any(p => p.Player2 == target))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }
            SendReply(player, string.Format(Messages["tprrequestsuccess"], target.displayName));
            SendReply(target, string.Format(Messages["tprpending"], player.displayName));
            Effect.server.Run(EffectPrefab1, target, 0, Vector3.zero, Vector3.forward);


            pendings.Add(new TP(target, Vector3.zero, 15, false, false, player));
            if (IsTeamate(player, target.userID))
            {
                target.SendConsoleCommand("chat.say /tpa");
                target.ChatMessage($"Вы приняли телепорт автоматически!");
                return;
            }
        }
        [ChatCommand("tpa")]
        void cmdChatTpa(BasePlayer player, string command, string[] args)
        {
            if (!enabledTPR) return;
            var tp = pendings.Find(p => p.Player == player);
            if (tp == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }
            BasePlayer pendingPlayer = tp.Player2;
            if (pendingPlayer == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.radiationLevel > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpacupboard"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (FriendsEnabled)
                if (!IsTeamate(player, pendingPlayer.userID))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["PlayerNotFriend"]);
                    return;
                }
            if (player.isMounted)
	    {
	    player.ChatMessage("Нельзя принимать запрос на телепортацию пока вы сидите!");
   	    return;
	    }
            var time = GetTeleportTime(pendingPlayer.userID);
            pendings.Remove(tp);
            var lastTp = tpQueue.Find(p => p.Player == pendingPlayer);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            var Enabled = player.GetParentEntity() is CargoShip || player.GetParentEntity() is HotAirBalloon;
            tpQueue.Add(new TP(pendingPlayer, player.transform.position, time, Enabled, false, player));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            CuiHelper.DestroyUi(player, "teleportmenu");
            SendReply(pendingPlayer, string.Format(Messages["tpqueue"], player.displayName, TimeToString(time)));
            if (args.Length <= 0) SendReply(player, String.Format(Messages["tpasuccess"], pendingPlayer.displayName, TimeToString(time)));
        }
        [ChatCommand("tpc")]
        void cmdChatTpc(BasePlayer player, string command, string[] args)
        {
            var tp = pendings.Find(p => p.Player == player);
            BasePlayer target = tp?.Player2;
            if (target != null)
            {
                pendings.Remove(tp);
                SendReply(player, Messages["tpc"]);
                SendReply(target, string.Format(Messages["tpctarget"], player.displayName));
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.radiationLevel > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            foreach (var pend in pendings)
            {
                if (pend.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(pend.Player, string.Format(Messages["tpctarget"], player.displayName));

                    CuiHelper.DestroyUi(player, "teleportmenu");
                    pendings.Remove(pend);
                    return;
                }
            }
            foreach (var tpQ in tpQueue)
            {
                if (tpQ.Player2 != null && tpQ.Player2 == player)
                {
                    CuiHelper.DestroyUi(player, "teleportmenu");
                    SendReply(player, Messages["tpc"]);
                    SendReply(tpQ.Player, string.Format(Messages["tpctarget"], player.displayName));
                    tpQueue.Remove(tpQ);
                    return;
                }
                if (tpQ.Player == player)
                {
                    CuiHelper.DestroyUi(player, "teleportmenu");
                    SendReply(player, Messages["tpc"]);
                    if (tpQ.Player2 != null) SendReply(tpQ.Player2, string.Format(Messages["tpctarget"], player.displayName));
                    tpQueue.Remove(tpQ);
                    return;
                }
            }
        }
        void SpectateFinish(BasePlayer player)
        {
            player.Command("camoffset", "0,1,0");
            player.StopSpectating();
            player.SetParent(null);
            player.gameObject.SetLayerRecursive(17);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
            player.SendNetworkUpdateImmediate();
            player.metabolism.Reset();
            player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "StartLoading");
            player.StartSleeping();
            if (lastPositions.ContainsKey(player.userID))
            {
                Vector3 lastPosition = lastPositions[player.userID] + Vector3.up;
                player.MovePosition(lastPosition);
                if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "ForcePositionTo", lastPosition);
                lastPositions.Remove(player.userID);

            }

            if (player.net?.connection != null) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try
            {
                player.ClearEntityQueue(null);
            }
            catch { }
            player.SendFullSnapshot();

            SendReply(player, "Слежка закончена!");
        }


        private void OnUserConnected(IPlayer player) => ResetSpectate(player);

        private void OnUserDisconnected(IPlayer player) => ResetSpectate(player);

        private void ResetSpectate(IPlayer player)
        {
            player.Command("camoffset 0,1,0");

            if (lastPositions.ContainsKey(ulong.Parse(player.Id)))
            {
                lastPositions.Remove(ulong.Parse(player.Id));
            }
        }

        object OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            player.Command("camoffset", "0,1,0");
            return null;
        }

        [ChatCommand("tpl")]
        void cmdChattpGo(BasePlayer player, string command, string[] args)
        {
            if (!EnabledTPLForPlayers && !player.IsAdmin) return;
            if (args == null || args.Length == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpArgsError"]);
                return;
            }
            switch (args[0])
            {
                default:
                    if (tpsave.Count <= 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homesmissing"]);
                        return;
                    }
                    var nametp = args[0];
                    var tp = tpsave.Find(p => p.Name == nametp);
                    if (tp == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homenotexist"]);
                        return;
                    }
                    var position = tp.pos;
                    var ret = Interface.Call("CanTeleport", player) as string;
                    if (ret != null)
                    {
                        SendReply(player, ret);
                        return;
                    }
                    int seconds;
                    if (cooldownsHOME.TryGetValue(player.userID, out seconds) && seconds > 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                        return;
                    }
                    var lastTp = tpQueue.Find(p => p.Player == player);
                    if (lastTp != null) tpQueue.Remove(lastTp);
                    Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                    if (TPLAdmin && player.IsAdmin) Teleport(player, position);
                    else
                    {
                        tpQueue.Add(new TP(player, position, TplPedingTime, false, true));
                        SendReply(player, String.Format(Messages["homequeue"], nametp, TimeToString(TplPedingTime)));
                    }
                    return;
                case "add":
                    if (!player.IsAdmin) return;
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["settpArgsError"]);
                        return;
                    }
                    var nameAdd = args[1];
                    SetTpSave(player, nameAdd);
                    return;
                case "remove":
                    if (!player.IsAdmin) return;
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["removetpArgsError"]);
                        return;
                    }
                    nametp = args[1];
                    if (tpsave.Count > 0)
                    {
                        tp = tpsave.Find(p => p.Name == nametp);
                        if (tp == null)
                        {
                            Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                            SendReply(player, Messages["homesmissing"]);
                            return;
                        }
                        Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                        tpsave.Remove(tp);
                        SendReply(player, Messages["removehomesuccess"], nametp);
                    }
                    return;
                case "list":
                    if (tpsave.Count <= 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["TPLmissing"]);
                        return;
                    }
                    var tplist = tpsave.Select(x => $"{x.Name} {x.pos}");
                    SendReply(player, Messages["TPLList"], string.Join("\n", tplist.ToArray()));
                    return;
            }
        }
        [ChatCommand("tpspec")]
        void cmdTPSpec(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            if (!player.IsSpectating())
            {
                if (args.Length == 0 || args.Length != 1)
                {
                    SendReply(player, Messages["tpspecError"]);
                    return;
                }
                string name = args[0];
                BasePlayer target = FindBasePlayer(name);
                if (target == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["playermissing"]);
                    return;
                }
                switch (args.Length)
                {
                    case 1:
                        if (!target.IsConnected)
                        {
                            SendReply(player, Messages["playermissingOff"]);
                            return;
                        }
                        if (target.IsDead())
                        {
                            SendReply(player, Messages["playermissingOrDeath"]);
                            return;
                        }
                        if (ReferenceEquals(target, player))
                        {
                            SendReply(player, Messages["playerItsYou"]);
                            return;
                        }
                        if (target.IsSpectating())
                        {
                            SendReply(player, Messages["playerItsSpec"]);
                            return;
                        }
                        spectatingPlayers.Remove(target);
                        lastPositions[player.userID] = player.transform.position;
                        HeldEntity heldEntity = player.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                        heldEntity?.SetHeld(false);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                        player.gameObject.SetLayerRecursive(10);
                        player.CancelInvoke("MetabolismUpdate");
                        player.CancelInvoke("InventoryUpdate");
                        player.ClearEntityQueue();
                        player.SendEntitySnapshot(target);
                        player.gameObject.Identity();
                        player.SetParent(target);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
                        player.Command("camoffset", "0, 1.3, 0");
                        SendReply(player, $"Вы наблюдаете за игроком {target}! Что бы переключаться между игроками, нажимайте: Пробел\nЧтобы выйти с режима наблюдения, введите: /tpspec");
                        break;
                }
            }
            else SpectateFinish(player);
        }
        [ChatCommand("tp")]
        [Obsolete]
        void cmdTP(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            switch (args.Length)
            {
                case 1:
                    string name = args[0];
                    BasePlayer target = FindBasePlayer(name);
                    if (target == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        SendVKLogs($"[{DateTime.Now.ToShortTimeString()}] {player.displayName} ({player.userID}) телепортировался к {target.displayName} ({target.userID})");
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] {player} телепортировался к {target}", this, true);
                    }
                    Teleport(player, target);
                    break;
                case 2:
                    string name1 = args[0];
                    string name2 = args[1];
                    BasePlayer target1 = FindBasePlayer(name1);
                    BasePlayer target2 = FindBasePlayer(name2);
                    if (target1 == null || target2 == null)
                    {
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        SendVKLogs($"[{DateTime.Now.ToShortTimeString()}] {player.displayName} ({player.userID}) телепортировал {target1.displayName} ({target1.userID}) к {target2.displayName} ({target2.userID})");
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировал {target1} к {target2}", this, true);
                    }
                    Teleport(target1, target2);
                    break;
                case 3:
                    float x = float.Parse(args[0].Replace(",", ""));
                    float y = float.Parse(args[1].Replace(",", ""));
                    float z = float.Parse(args[2]);
                    if (adminsLogs)
                    {
                        SendVKLogs($"[{DateTime.Now.ToShortTimeString()}] {player.displayName} ({player.userID}) телепортировался на координаты: ({x} / {y} / {z})");
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировался на координаты: ({x} / {y} / {z})", this, true);
                    }
                    Teleport(player, x, y, z);
                    break;
            }
        }
        [ConsoleCommand("home.wipe")]
        private void CmdTest(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            PrintWarning("Запущен ручной вайп. Очищаем данные с data/Teleportation");
            WipeData();
        }
        public string TimeToString(double time)
        {
            TimeSpan elapsedTime = TimeSpan.FromSeconds(time);
            int hours = elapsedTime.Hours;
            int minutes = elapsedTime.Minutes;
            int seconds = elapsedTime.Seconds;
            int days = Mathf.FloorToInt((float)elapsedTime.TotalDays);
            string s = "";
            if (days > 0) s += $"{days} дн.";
            if (hours > 0) s += $"{hours} ч. ";
            if (minutes > 0) s += $"{minutes} мин. ";
            if (seconds > 0) s += $"{seconds} сек.";
            else s = s.TrimEnd(' ');
            return s;
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            pendings.RemoveAll(p => p.Player == player || p.Player2 == player);
            tpQueue.RemoveAll(p => p.Player == player || p.Player2 == player);
        }

        void OnServerInitialized()
        {
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/teleport_bg.png", "fontp");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/teleport_home_bg.png", "fonhome");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/teleport_ava.png", "fonavatar");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/teleport_online.png", "fononline");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/teleport_offline.png", "fonoffline");
            ImageLibrary.Call("AddImage", "https://rustage.su/img/server/ui/teleport_misc.png", "fonDescription");
            LoadData();
            LoadDefaultConfig();
            FindTowns();
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            cooldownsTowns = new Dictionary<ulong, int>();
            timer.Every(1f, TeleportationTimerHandle);
            timer.Every(300, SaveData);
        }

        void Unload() => SaveData();
        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner == null || gameobject == null) return;
            var player = planner.GetOwnerPlayer();
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (gameobject.name.Contains("foundation"))
            {
                var pos = gameobject.transform.position;
                foreach (var pending in tpQueue)
                {
                    if (Vector3.Distance(pending.pos, pos) < 3)
                    {
                        entity.Kill();
                        SendReply(planner.GetOwnerPlayer(), "Нельзя, тут телепортируется игрок!");
                        return;
                    }
                }
            }
        }
        [PluginReference] Plugin Duel;
        bool InDuel(BasePlayer player) => Duel?.Call<bool>("IsPlayerOnActiveDuel", player) ?? false;
        void TeleportationTimerHandle()
        {
            List<ulong> tpkdToRemove = new List<ulong>();
            foreach (var uid in cooldownsTP.Keys.ToList())
            
                if (--cooldownsTP[uid] <= 0)
                
                    tpkdToRemove.Add(uid);
                
            
            tpkdToRemove.ForEach(p => cooldownsTP.Remove(p));
            List<ulong> tpkdHomeToRemove = new List<ulong>();
            foreach (var uid in cooldownsHOME.Keys.ToList())
            
                if (--cooldownsHOME[uid] <= 0)
            tpkdHomeToRemove.Add(uid);
            tpkdHomeToRemove.ForEach(p => cooldownsHOME.Remove(p));
            List<ulong> tpkdTownsToRemove = new List<ulong>();
	    foreach (var uid in cooldownsTowns.Keys.ToList())
	    if (--cooldownsTowns[uid] <= 0)
	    tpkdTownsToRemove.Add(uid);
	    tpkdTownsToRemove.ForEach(p => cooldownsTowns.Remove(p));
            for (int i = pendings.Count - 1;
            i >= 0;
            i--)
            {
                var pend = pendings[i];
                if (pend.Player != null && pend.Player.IsConnected && pend.Player.IsWounded())
                {
                    CuiHelper.DestroyUi(pend.Player, "teleportmenu");
                    SendReply(pend.Player, Messages["tpwounded"]);
                    pendings.RemoveAt(i);
                    continue;
                }
                if (--pend.seconds <= 0)
                {
                    pendings.RemoveAt(i);

                    CuiHelper.DestroyUi(pend.Player, "teleportmenu");
                    if (pend.Player2 != null && pend.Player2.IsConnected) SendReply(pend.Player2, Messages["tppendingcanceled"]);
                    if (pend.Player != null && pend.Player.IsConnected) SendReply(pend.Player, Messages["tpacanceled"]);
                }
            }
            for (int i = tpQueue.Count - 1;
            i >= 0;
            i--)
            {
                var reply = 1;
                if (reply == 0) { }
                var tp = tpQueue[i];
                if (tp.Player != null)
                {
                    if (tp.Player.IsConnected && (CancelTPWounded && tp.Player.IsWounded()) || (tp.Player.metabolism.bleeding.value > 0 && CancelTPMetabolism) || (CancelTPRadiation && tp.Player.radiationLevel > 10))
                    {
                        SendReply(tp.Player, Messages["tpwounded"]);
                        if (tp.Player2 != null && tp.Player2.IsConnected) SendReply(tp.Player2, Messages["tpWoundedTarget"]);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (InDuel(tp.Player))
                    {
                        SendReply(tp.Player, Messages["InDuel"]);
                        if (tp.Player2 != null && tp.Player2.IsConnected) SendReply(tp.Player2, Messages["InDuelTarget"]);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (restrictTPRCupboard)
                    {
                        var privilege = tp.Player.GetBuildingPrivilege(tp.Player.WorldSpaceBounds());
                        if (privilege != null && !tp.Player.IsBuildingAuthed())
                        {
                            Effect.server.Run(EffectPrefab, tp.Player, 0, Vector3.zero, Vector3.forward);

                            SendReply(tp.Player, Messages["tpcupboard"]);
                            if (tp.Player2 != null && tp.Player2.IsConnected) SendReply(tp.Player2, Messages["tpcupboardTarget"]);
                            tpQueue.RemoveAt(i);
                            return;
                        }
                    }
                }

                if (tp.Player2 != null)
                {
                    if (tp.Player2.IsConnected && (tp.Player2.IsWounded() && CancelTPWounded) || (tp.Player2.metabolism.bleeding.value > 0 && CancelTPMetabolism) || (CancelTPRadiation && tp.Player2.radiationLevel > 10))
                    {
                        SendReply(tp.Player2, Messages["tpwounded"]);
                        if (tp.Player != null && tp.Player.IsConnected) SendReply(tp.Player, Messages["tpWoundedTarget"]);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (InDuel(tp.Player2))
                    {
                        SendReply(tp.Player2, Messages["InDuel"]);
                        if (tp.Player != null && tp.Player.IsConnected) SendReply(tp.Player, Messages["InDuelTarget"]);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (restrictTPRCupboard)
                    {
                        var privilege = tp.Player2.GetBuildingPrivilege(tp.Player2.WorldSpaceBounds());
                        if (privilege != null && !tp.Player2.IsBuildingAuthed())
                        {
                            Effect.server.Run(EffectPrefab, tp.Player2, 0, Vector3.zero, Vector3.forward);
                            if (tp.Player != null && tp.Player.IsConnected) SendReply(tp.Player, Messages["tpcupboardTarget"]);

                            SendReply(tp.Player2, Messages["tpcupboard"]);
                            return;
                        }
                    }
                }
                if (--tp.seconds <= 0)
                {
                    tpQueue.RemoveAt(i);
                    var ret = Interface.CallHook("CanTeleport", tp.Player) as string;
                    if (ret != null)
                    {
                        SendReply(tp.Player, ret);
                        continue;
                    }
                    if (CheckInsideInFoundation(tp.pos))
                    {
                        SendReply(tp.Player, Messages["InsideInFoundationTP"]);
                        continue;
                    }
                    if (tp.Player2 != null)
                    {
                        tp.Player.SetParent(tp.Player2.GetParentEntity());
                        if (tp.EnabledShip) tp.pos = tp.Player2.transform.position;
                    }
                    if (tp.Player2 != null && tp.Player != null && tp.Player.IsConnected && tp.Player2.IsConnected)
                    {
                        var seconds = GetKD(tp.Player.userID);
                        cooldownsTP[tp.Player.userID] = seconds;
                        SendReply(tp.Player, string.Format(Messages["tpplayersuccess"], tp.Player2.displayName));
                    }
                    else if (tp.Player != null && tp.Player.IsConnected)
                    {
                        tp.Player.SetParent(null);
                        if (tp.TPL)
                        {
                            var seconds = TPLCooldown;
                            cooldownsHOME[tp.Player.userID] = seconds;
                            SendReply(tp.Player, Messages["tplsuccess"]);
                        }
                        else if(tp.TownTp)
                        {
                            var seconds = GetKDToTpTown(tp.Player.userID);
                            cooldownsTowns[tp.Player.userID] = seconds;
                            SendReply(tp.Player, "Вы успешно телепортировались!");
                        }
                        else
                        {
                            tp.Player.ChatMessage("1");

                            var seconds = GetKDHome(tp.Player.userID);
                            cooldownsHOME[tp.Player.userID] = seconds;
                            SendReply(tp.Player, Messages["tphomesuccess"]);
                        }
                    }
                    Teleport(tp.Player, tp.pos);
                    NextTick(() => Interface.CallHook("OnPlayerTeleported", tp.Player));
                }
            }
        }
        void SetTpSave(BasePlayer player, string name)
        {
            var position = player.transform.position;
            if (tpsave.Count > 0)
            {
                var tp = tpsave.Find(p => p.Name == name);
                if (tp != null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["homeexist"]);
                    return;
                }
            }
            tpsave.Add(new TPList()
            {
                Name = name,
                pos = position
            }
            );
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }
        void SetHome(BasePlayer player, string name)
        {
            var uid = player.userID;
            var pos = player.transform.position;
            if (player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomecupboard"]);
                return;
            }
            Dictionary<string, Vector3> playerHomes;
            if (!homes.TryGetValue(uid, out playerHomes)) playerHomes = (homes[uid] = new Dictionary<string, Vector3>());
            if (GetHomeLimit(uid) == playerHomes.Count)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["maxhomes"]);
                return;
            }
            if (playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeexist"]);
                return;
            }
            if (CheckInsideInFoundation(player.transform.position))
            {
                SendReply(player, Messages["InsideInFoundation"]);
                return;
            }
            playerHomes.Add(name, pos);
            if (createSleepingBug)
            {
                CreateSleepingBag(player, pos, name);
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            sethomeBlock.Add(player.userID);
            DDrawMenu(player);
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }
        private bool CheckInsideInFoundation(Vector3 position)
        {
            foreach (var hit in Physics.RaycastAll(position, Vector3.up, 2f, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                if (hit.GetCollider().name.Contains("foundation")) return true;
            }
            foreach (var hit in Physics.RaycastAll(position + Vector3.up + Vector3.up + Vector3.up + Vector3.up, Vector3.down, 2f, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                if (hit.GetCollider().name.Contains("foundation")) return true;
            }
            return false;
        }
        int GetKDHome(ulong uid)
        {
            int min = tpkdhomeDefault;
            foreach (var privilege in tpkdhomePerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetKD(ulong uid)
        {
            int min = tpkdDefault;
            foreach (var privilege in tpkdPerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetHomeLimit(ulong uid)
        {
            int max = homelimitDefault;
            foreach (var privilege in homelimitPerms) if (PermissionService.HasPermission(uid, privilege.Key)) max = Mathf.Max(max, privilege.Value);
            return max;
        }
        int GetTeleportTime(ulong uid)
        {
            int min = teleportSecsDefault;
            foreach (var privilege in teleportSecsPerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        BaseEntity GetBuldings(Vector3 pos)
        {
            RaycastHit hit;
            if (Physics.Raycast(new Ray(pos, Vector3.down), out hit, 0.2f))
            {
                var entity = hit.GetEntity();
                if (entity != null) return entity;
                else return null;
            }
            return null;
        }
        private BaseEntity GetFoundation(Vector3 pos)
        {
            RaycastHit hit;
            if (Physics.Raycast(pos, Vector3.down, out hit, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                var entity = hit.GetEntity();
                if (entity != null) if (entity.PrefabName.Contains("foundation")) return entity;
            }
            return null;
        }
        SleepingBag GetSleepingBag(string name, Vector3 pos)
        {
            List<SleepingBag> sleepingBags = new List<SleepingBag>();
            Vis.Components(pos, .1f, sleepingBags);
            return sleepingBags.Count > 0 ? sleepingBags[0] : null;
        }
        void CreateSleepingBag(BasePlayer player, Vector3 pos, string name)
        {
            SleepingBag sleepingBag = GameManager.server.CreateEntity("assets/prefabs/deployable/sleeping bag/sleepingbag_leather_deployed.prefab", pos, Quaternion.identity) as SleepingBag;
            if (sleepingBag == null) return;
            sleepingBag.skinID = 1265527678;
            sleepingBag.deployerUserID = player.userID;
            sleepingBag.niceName = name;
            sleepingBag.OwnerID = player.userID;
            sleepingBag.Spawn();
            sleepingBag.SendNetworkUpdate();
        }
        Dictionary<string, Vector3> GetHomes(ulong uid)
        {
            Dictionary<string, Vector3> positions;
            if (!homes.TryGetValue(uid, out positions)) return null;
            return positions.ToDictionary(p => p.Key, p => p.Value);
        }
        public void Teleport(BasePlayer player, BasePlayer target) => Teleport(player, target.transform.position);
        public void Teleport(BasePlayer player, float x, float y, float z) => Teleport(player, new Vector3(x, y, z));
        public void Teleport(BasePlayer player, Vector3 position)
        {
            if (player.IsDead() && player.IsConnected)
            {
                player.RespawnAt(position, Quaternion.identity);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            BaseMountable mount = player.GetMounted();
            if (mount != null) mount.DismountPlayer(player);
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "StartLoading");
            player.StartSleeping();
            player.MovePosition(position);
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "ForcePositionTo", position);
            if (player.net?.connection != null) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try
            {
                player.ClearEntityQueue(null);
            }
            catch { }
            player.SendFullSnapshot();
        }
        DynamicConfigFile homesFile = Interface.Oxide.DataFileSystem.GetFile("Teleportation/Homes");
        DynamicConfigFile tpsaveFile = Interface.Oxide.DataFileSystem.GetFile("Teleportation/AdminTpSave");
        public Dictionary<ulong, AutoTPASettings> AutoTPA = new Dictionary<ulong, AutoTPASettings>();

        public class AutoTPASettings
        {
            public bool Enabled;
            public Dictionary<string, ulong> PlayersList = new Dictionary<string, ulong>();
        }


        void LoadData()
        {
            try
            {
                tpsave = tpsaveFile.ReadObject<List<TPList>>();
                if (tpsave == null)
                {
                    PrintError("File AdminTpSave is null! Create new data files");
                    tpsave = new List<TPList>();
                }
                homes = homesFile.ReadObject<Dictionary<ulong, Dictionary<string, Vector3>>>();
                if (homes == null)
                {
                    PrintError("File Homes is null! Create new data files");
                    homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
                }
                AutoTPA = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, AutoTPASettings>>($"Teleportation/AutoTPA");

            }
            catch
            {
                tpsave = new List<TPList>();
                homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
                AutoTPA = new Dictionary<ulong, AutoTPASettings>();
            }
        }
        void SaveData()
        {
            if (tpsave != null) tpsaveFile.WriteObject(tpsave);
            if (homes != null) homesFile.WriteObject(homes);
            if (AutoTPA != null) Interface.Oxide.DataFileSystem.WriteObject($"Teleportation/AutoTPA", AutoTPA);

        }

        private string URLEncode(string input)
        {
            if (input.Contains("#")) input = input.Replace("#", "%23");
            if (input.Contains("$")) input = input.Replace("$", "%24");
            if (input.Contains("+")) input = input.Replace("+", "%2B");
            if (input.Contains("/")) input = input.Replace("/", "%2F");
            if (input.Contains(":")) input = input.Replace(":", "%3A");
            if (input.Contains(";")) input = input.Replace(";", "%3B");
            if (input.Contains("?")) input = input.Replace("?", "%3F");
            if (input.Contains("@")) input = input.Replace("@", "%40");
            return input;
        }

        [Obsolete]
        void SendVKLogs(string Message)
        {
            if (String.IsNullOrEmpty("9") || String.IsNullOrEmpty("deecbfa826d6eec71fa2ae61e940cdefd35008ed417f50cd0bf2aa7dec0849d7b1297797ced8d74d11858")) return;

            while (Message.Contains("#")) Message = Message.Replace("#", "%23");
            webrequest.EnqueueGet($"https://api.vk.com/method/messages.send?chat_id=9&random_id={UnityEngine.Random.Range(0, 9999)}&message={URLEncode(Message)}&access_token=deecbfa826d6eec71fa2ae61e940cdefd35008ed417f50cd0bf2aa7dec0849d7b1297797ced8d74d11858&v=5.92", (code, response) => { }, this);
        }

        private const string GUI_TPACCEPT = @"
[
  {
    ""name"": ""teleportmenu"",
    ""parent"": ""Overlay"",
    ""components"": [
      {
        ""type"": ""UnityEngine.UI.Image"",
        ""sprite"": ""assets/content/ui/ui.background.transparent.radial.psd"",
        ""color"": ""0.1686275 0.1568628 0.1411765 0.3125492""
      },
      {
        ""type"": ""RectTransform"",
        ""anchormin"": ""0.5 0"",
        ""anchormax"": ""0.5 0"",
        ""offsetmin"": ""200 19"",
        ""offsetmax"": ""350 76""
      }
    ]
  },
  {
    ""name"": ""teleportmenuText"",
    ""parent"": ""teleportmenu"",
    ""components"": [
      {
        ""type"": ""UnityEngine.UI.Text"",
        ""text"": ""ТП: {0}"",
        ""align"": ""MiddleLeft"",
        ""color"": ""1.00 0.69 0.18 1.00""
      },
      {
        ""type"": ""RectTransform"",
        ""anchormin"": ""0 0.5438597"",
        ""anchormax"": ""1 1"",
        ""offsetmin"": ""8 0"",
        ""offsetmax"": ""0 0""
      }
    ]
  },
  {
    ""name"": ""teleportacceptMenu"",
    ""parent"": ""teleportmenu"",
    ""components"": [
      {
        ""type"": ""UnityEngine.UI.Button"",
        ""command"": ""tpa"",
        ""close"": ""teleportmenu"",
        ""sprite"": ""assets/content/ui/ui.background.transparent.radial.psd"",
        ""color"": ""0.1647059 0.1529412 0.1529412 0.489929"",
        ""imagetype"": ""Tiled""
      },
      {
        ""type"": ""RectTransform"",
        ""anchormin"": ""0 0"",
        ""anchormax"": ""0.5 0.5"",
        ""offsetmin"": ""0 0"",
        ""offsetmax"": ""0 0""
      }
    ]
  },
  {
    ""name"": ""teleportmenuTextAccept"",
    ""parent"": ""teleportacceptMenu"",
    ""components"": [
      {
        ""type"": ""UnityEngine.UI.Text"",
        ""text"": ""ПРИНЯТЬ"",
        ""font"": ""robotocondensed-bold.ttf"",
        ""align"": ""MiddleCenter"",
        ""color"": ""1.00 0.69 0.18 1.00""
      },
      {
        ""type"": ""RectTransform"",
        ""anchormin"": ""0 0"",
        ""anchormax"": ""1 1"",
        ""offsetmin"": ""0 0"",
        ""offsetmax"": ""0 0""
      }
    ]
  },
  {
    ""name"": ""teleportpcMenu"",
    ""parent"": ""teleportmenu"",
    ""components"": [
      {
        ""type"": ""UnityEngine.UI.Button"",
        ""command"": ""tpc"",
        ""close"": ""teleportmenu"",
        ""sprite"": ""assets/content/ui/ui.background.transparent.radial.psd"",
        ""color"": ""0.1647059 0.1529412 0.1529412 0.489929"",
        ""imagetype"": ""Tiled""
      },
      {
        ""type"": ""RectTransform"",
        ""anchormin"": ""0.5 0"",
        ""anchormax"": ""1 0.5"",
        ""offsetmin"": ""0 0"",
        ""offsetmax"": ""0 0""
      }
    ]
  },
  {
    ""name"": ""teleportmenuTextTpc"",
    ""parent"": ""teleportpcMenu"",
    ""components"": [
      {
        ""type"": ""UnityEngine.UI.Text"",
        ""text"": ""ОТКЛОНИТЬ"",
        ""font"": ""robotocondensed-bold.ttf"",
        ""align"": ""MiddleCenter"",
        ""color"": ""1.00 0.69 0.18 1.00""
      },
      {
        ""type"": ""RectTransform"",
        ""anchormin"": ""0 0"",
        ""anchormax"": ""1 1"",
        ""offsetmin"": ""0 0"",
        ""offsetmax"": ""0 0""
      }
    ]
  }
]";


        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "foundationmissing", "Фундамент не найден!"
            }
            ,
            {
                "InDuel", "Вы на Дуэли. Телепорт запрещен!"
            },
            {
                "InDuelTarget", "Игрок на Дуэли. Телепорт запрещен!"
            }
            ,
            {
                "foundationmissingR", "Фундамент не найден, местоположение было удалено!"
            }
            , {
                "playerisyou", "Нельзя отправлять телепорт самому себе!"
            }
            , {
                "maxhomes", "У вас максимальное кол-во местоположений!"
            }
            , {
                "homeexist", "Такое местоположение уже существует!"
            }
            , {
                "homesucces", "Местоположение {0} успешно установлено!"
            }
            , {
                "sethomeArgsError", "Для установки местоположения используйте /sethome ИМЯ"
            }
            , {
                "settpArgsError", "Для установки местоположения используйте /tpl add ИМЯ"
            }
            , {
                "homeArgsError", "Для телепортации на местоположение используйте /home ИМЯ"
            }
            , {
                "tpArgsError", "Для телепортации на местоположение используйте /tpl ИМЯ"
            }
            , {
                "tpError", "Запрещено! Вы в очереди на телепортацию"
            }
            , {
                "homenotexist", "Местоположение с таким названием не найдено!"
            }
            , {
                "homequeue", "Телепортация на {0} будет через {1}"
            }
            , {
                "tpwounded", "Вы получили ранение! Телепортация отменена!"
            }
            , {
                "tphomesuccess", "Вы телепортированы домой!"
            }
            , {
                "tplsuccess", "Вы успешно телепортированы!"
            }
            , {
                "tptpsuccess", "Вы телепортированы на указаное место!"
            }
            , {
                "homesmissing", "У вас нет доступных местоположений!"
            }
            , {
                "TPLmissing", "Для вас нет доступных местоположений!"
            }
            , {
                "TPLList", "Доступные точки местоположения:\n{0}"
            }
            , {
                "removehomeArgsError", "Для удаления местоположения используйте /removehome ИМЯ"
            }
            , {
                "removetpArgsError", "Для удаления местоположения используйте /tpl remove ИМЯ"
            }
            , {
                "removehomesuccess", "Местоположение {0} успешно удалено"
            }
            , {
                "sleepingbagmissing", "Спальный мешок не найден, местоположение удалено!"
            }
            , {
                "tprArgsError", "Для отправки запроса на телепортация используйте /tpr НИК"
            }
            , {
                "playermissing", "Игрок не найден"
            }
            , {
                "PlayerNotFriend", "Игрок не являеться Вашим другом! Телепорт запрещен!"
            }
            , {
                "tpspecError", "Не правильно введена команда. Используйте: /tpspec НИК"
            }
            , {
                "playermissingOff", "Игрок не в сети"
            }
            , {
                "playermissingOrDeath", "Игрок не найден, или он мёртв"
            }
            , {
                "playerItsYou", "Нельзя следить за самым собой"
            }
            , {
                " playerItsSpec", "Игрок уже за кем то наблюдает"
            }
            , {
                "tprrequestsuccess", "Запрос {0} успешно отправлен"
            }
            , {
                "tprpending", "{0} отправил вам запрос на телепортацию\nЧтобы принять используйте /tpa\nЧтобы отказаться используйте /tpc"
            }
            , {
                "tpanotexist", "У вас нет активных запросов на телепортацию!"
            }
            , {
                "tpqueue", "{0} принял ваш запрос на телепортацию\nВы будете телепортированы через {1}"
            }
            , {
                "tpc", "Телепортация успешно отменена!"
            }
            , {
                "tpctarget", "{0} отменил телепортацию!"
            }
            , {
                "tpplayersuccess", "Вы успешно телепортировались к {0}"
            }
            , {
                "tpasuccess", "Вы приняли запрос телепортации от {0}\nОн будет телепортирован через {1}"
            }
            , {
                "tppendingcanceled", "Запрос телепортации отменён"
            }
            , {
                "tpcupboard", "Телепортация в зоне действия чужого шкафа запрещена!"
            }, {
                "tpcupboardTarget", "Вы или игрок находитесь в зоне действия чужого шкафа!"
            }
            , {
                "tphomecupboard", "Телепортация домой в зоне действия чужого шкафа запрещена!"
            }
            , {
                "tpacupboard", "Принятие телепортации в зоне действия чужого шкафа запрещена!"
            }
            , {
                "sethomecupboard", "Установка местоположения в зоне действия чужого шкафа запрещена!"
            }
            , {
                "tpacanceled", "Вы не ответили на запрос."
            }
            , {
                "tpkd", "Телепортация на перезарядке!\nОсталось {0}"
            }
            , {
                "tpWoundedTarget", "Игрок ранен. Телепортация отменена!"
            }
            , {
                "woundedAction", "Вы ранены!"
            }
            , {
                "coldplayer", "Вам холодно!"
            }
            , {
                "Radiation", "Вы облучены радиацией!"
            }
            , {
                "sethomeBlock", "Нельзя использовать /sethome слишком часто, попробуйте позже!"
            }
            , {
                "foundationowner", "Нельзя использовать /sethome не на своих строениях!"
            }
            , {
                "foundationownerFC", "Создатель обьекта не являеться вашим соклановцем или другом, /sethome запрещен"
            }
            , {
                "homeslist", "Доступное количество местоположений: {0}\n{1}"
            }
            , {
                "tplist", "Ваши сохраненные метоположения:\n{0}"
            }
            , {
                "PlayerIsOnCargoShip", "Вы не можете телепортироваться на грузовом корабле."
            }
            , {
                "PlayerIsOnHotAirBalloon", "Вы не можете телепортироваться на воздушном шаре."
            }
            , {
                "InsideInFoundation", "Вы не можете устанавливать местоположение находясь в фундаменте"
            }
            , {
                "InsideInFoundationTP", "Телепортация запрещена, местоположение находится в фундаменте"
            }
            ,{
                "TPAPerm", "У Вас нету права использовать эту команду"
            },
            {
                "TPAEnabled", "Вы успешно <color=#FDAE37>включили</color> автопринятие запроса на телепорт\n{0}"
            },
            {
                "TPADisable", "Вы успешно <color=#FDAE37>отключили</color> автопринятие запроса на телепорт"
            },
            {
                "TPAEnabledInfo", "Добавление нового игрока <color=#FDAE37>/atp add Name/SteamID</color>\nУдаление игрока <color=#FDAE37>/atp remove Name</color>\nСписок игроков <color=#FDAE37>/apt list</color>"
            },
            {
                "TPAEnabledList", "Список игроков для каких у Вас включен автоматический приём телепорта:\n{0}"
            },
            {
                "TPAEListNotFound", "Вы пока еще не добавили не одного игрока в список, используйте <color=#FDAE37>/atp add Name/SteamID</color>"
            },
            {
                "TPAEAddError", "Вы не указали игрока, используйте <color=#FDAE37>/atp add Name/SteamID</color>"
            },{
                "TPARemoveError", "Вы не указали игрока, используйте <color=#FDAE37>/atp remove Name</color>"
            },
            {
                "TPARemoveNotFound", "Игрока <color=#FDAE37>{0}</color> нету в списке, используйте <color=#FDAE37>/atp remove Name</color>"
            },
            {
                "TPAEAddPlayerNotFound", "Игрок не найден! Попробуйте уточнить <color=#FDAE37>имя</color>\n{0}"
            },
            {
                "TPAEAddSuccess", "Игрок <color=#FDAE37>{0}</color> успешно добавлен в список"
            },
            {
                "TPAEAddContains", "Игрок <color=#FDAE37>{0}</color> уже добавлен в список"
            },
            {
                "TPAERemoveSuccess", "Игрок <color=#FDAE37>{0}</color> успешно удален со списока"
            },
            {
                "TPAEAddPlayers", "Найдено <color=#FDAE37>несколько</color> игроков с похожим ником:\n{0}"
            },
            {
                "TPASuccess", "Вы <color=#FDAE37>автоматически</color> приняли запрос на телепортацию так как у вас игрок в списке разрешенных."
            }
        }
        ;
    }
}

// --- End of file: TPTeleportation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQFakeActive.cs ---
// --- Original Local Path: IQFakeActive.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using ConVar;
using System.Linq;
using Oxide.Core;
using System.Collections;
using Newtonsoft.Json.Linq;
using System.Text;

namespace Oxide.Plugins
{
    [Info("IQFakeActive", "SkuliDropek", "1.2.15")]
    [Description("Актив вашего сервера, но немного не тот :)")]
    class IQFakeActive : RustPlugin
    {
        /// </summary>
        /// Обновленеи 1.0.х
        /// - Добавлена возможность выбора вариации генераций онлайна (Автоматическая, ручная, Автоматическая + ваш онлайн)
        /// - Изменен метод генерации онлайна
        /// 

        #region Vars
        private enum TypeOnline
        {
            Auto,
            Manual,
            Auto_Plus_Server,
        }
        public int FakeOnline = 0;
        public static DateTime TimeCreatedSave = SaveRestore.SaveCreatedTime.Date;
        public static DateTime RealTime = DateTime.Now.Date;
        public static int SaveCreated = RealTime.Subtract(TimeCreatedSave).Days;
        private Timer timeActivateMessage;
        private Timer timeActivateMessagePm;
        private Timer timerSynh;
        private Timer timerGenerateOnline;
        private Timer timerPlaySounds;
        private Coroutine RoutineInitPlugin;
        private Coroutine RoutineAddAvatars;
        private List<Configuration.ActiveSettings.SounActiveSettings.Sounds> SortedSoundList;

        #endregion

        #region Reference
        [PluginReference] Plugin IQChat, ImageLibrary;

        #region IQChat
        private enum IQChatGetType
        {
            Prefix,
            ChatColor,
            NickColor,
        }
        private string GetInfoIQChat(IQChatGetType TypeInfo)
        {
            if (!IQChat) return String.Empty;
            switch (TypeInfo)
            {
                case IQChatGetType.Prefix:
                    {
                        String Prefix = (String)IQChat?.Call("API_GET_DEFAULT_PREFIX");
                        return Prefix;
                    }
                case IQChatGetType.ChatColor:
                    {
                        String ChatColor = (String)IQChat?.Call("API_GET_DEFAULT_MESSAGE_COLOR");
                        return ChatColor;
                    }
                case IQChatGetType.NickColor:
                    {
                        String NickColor = (String)IQChat?.Call("API_GET_DEFAULT_NICK_COLOR");
                        return NickColor;
                    }
            }
            return "";
        }
        #endregion

        #region Image Library
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public bool HasImage(string imageName) => (bool)ImageLibrary?.Call("HasImage", imageName);


        #endregion

        #endregion

        #region Configuration 
        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройка создания фейковых игроков")]
            public FakePlayerSettings FakePlayers = new FakePlayerSettings();
            [JsonProperty("Настройка актива")]
            public ActiveSettings FakeActive = new ActiveSettings();
            [JsonProperty("Настройка онлайна")]
            public FakeOnlineSettings FakeOnline = new FakeOnlineSettings();
            [JsonProperty("Общая настройка")]
            public GeneralSettings GeneralSetting = new GeneralSettings();
            [JsonProperty("Включить лоигрование действий плагина в консоль")]
            public bool UseLogConsole;
            [JsonProperty("Введите ваш стимКлюч для подгрузки аватарок(https://steamcommunity.com/dev/apikey - взять тут.Если потребует домен на сайте - введите абсолютно любой)")]
            public string APIKeySteam;

            internal class GeneralSettings
            {
                [JsonProperty("IQChat : Steam64ID для аватарки в чате")]
                public String AvatarSteamID;
                [JsonProperty("IQChat : Отображаемый префикс в чате")]
                public String PrefixName;
                [JsonProperty("Максимально допустимый предел фейкового онлайна(если вам не нужно это значение, оставьвте 0 - по умолчанию)")]
                public Int32 MaximalOnline;
            }

            internal class FakeOnlineSettings
            {
                [JsonProperty("Настройка интервала обновления кол-во онлайна(сек)")]
                public int IntervalUpdateOnline;
                [JsonProperty("Детальная настройка типов онлайна")]
                public UpdateOnline SettingsUpdateOnline = new UpdateOnline();
                internal class UpdateOnline
                {
                    [JsonProperty("Настройка типа онлайна (0 - Автоматический, 1 - Ручная настройка, 2 - Автоматический + ваш онлайн)")]
                    public TypeOnline TypeOnline;
                    [JsonProperty("Настройка обновления онлайна")]
                    public StandartFormul StandartFormulSetting = new StandartFormul();
                    [JsonProperty("Ручная настройка онлайна")]
                    public ManualFormul ManualFormule = new ManualFormul();
                    internal class StandartFormul
                    {
                        [JsonProperty("Минимальный множитель онлайна(От этого показателя зависит скачок онлайна при обновлении)")]
                        public float MinimumFactor;
                        [JsonProperty("Максимальный множитель онлайна(От этого показателя зависит скачок онлайна при обновлении)")]
                        public float MaximumFactor;
                        [JsonProperty("Включить зависимость генерации оналйна от времени суток?")]
                        public bool DayTimeGerenation;
                    }
                    internal class ManualFormul
                    {
                        [JsonProperty("Ручная настройка онлайна (будет к вашему онлайну добавлять указанный в списке) | [время(цифра)] = количество онлайна ")]
                        public Dictionary<Int32, Int32> ManualTimeOnline = new Dictionary<Int32, Int32>();
                    }
                }
            }
            internal class FakePlayerSettings
            {
                [JsonProperty("Использовать игроков с общей базы игроков(true - да/false - нет, вы сами будете задавать параметры)")]
                public bool PlayersDB;
                [JsonProperty("Использовать сообщение с общей базы игроков(true - да/false - нет, вы сами будете задавать параметры)")]
                public bool ChatsDB;

                [JsonProperty("Локальный - список ников с которыми будут создаваться игроки(Общая база игроков должна быть отключена)")]
                public List<string> ListNickName = new List<string>();
                [JsonProperty("Локальный - список сообщений которые будут отправляться в чат(Общая база игроков должна быть отключена)")]
                public List<string> ListMessages = new List<string>();
            }
            internal class ActiveSettings
            {
                [JsonProperty("Настройка актива в чате")]
                public ChatActiveSetting ChatActive = new ChatActiveSetting();
                [JsonProperty("Настройка иммитации актива с помощью звуков(будь то рейд, будь то кто-то ходит рядом или добывает)")]
                public SounActiveSettings SoundActive = new SounActiveSettings();
                internal class SounActiveSettings
                {
                    [JsonProperty("Использовать звуки?")]
                    public bool UseLocalSoundBase;
                    [JsonProperty("Минимальный интервал проигрывания звука")]
                    public int MinimumIntervalSound;
                    [JsonProperty("Максимальный интервал проигрывания звука")]
                    public int MaximumIntervalSound;
                    [JsonProperty("Локальный лист звуков и их настройка")]
                    public List<Sounds> SoundLists = new List<Sounds>();
                    public class Sounds
                    {
                        [JsonProperty("Ваш звук")]
                        public string SoundPath;
                        [JsonProperty("Минимальная позиция от игрока")]
                        public int MinPos;
                        [JsonProperty("Максимальная позиция от игрока")]
                        public int MaxPos;
                        [JsonProperty("Шанс проигрывания данного звука")]
                        public int Rare;
                        [JsonProperty("На какой день после WIPE будет отыгрываться данный звук")]
                        public int DayFaktor;
                    }
                }
                internal class ChatActiveSetting
                {
                    [JsonProperty("HEX : Цвет ника для ботов")]
                    public String ColorChatNickDefault;
                    [JsonProperty("IQChat : Настройки подключения и отключения для IQChat")]
                    public IQChatNetwork IQChatNetworkSetting = new IQChatNetwork();
                    [JsonProperty("IQChat : Настройки личных сообщений для IQChat")]
                    public IQChatPM IQChatPMSettings = new IQChatPM();
                    [JsonProperty("Использовать черный список слов")]
                    public bool UseBlackList;
                    [JsonProperty("Укажите слова,которые будут запрещены в чате")]
                    public List<string> BlackList = new List<string>();
                    [JsonProperty("Укажите минимальный интервал отправки сообщения в чат(секунды)")]
                    public int MinimumInterval;
                    [JsonProperty("Укажите максимальный интервал отправки сообщения в чат(секунды)")]
                    public int MaximumInterval;

                    internal class IQChatNetwork
                    {
                        [JsonProperty("IQChat : Использовать подключение/отключение в чате")]
                        public bool UseNetwork;
                        [JsonProperty("IQChat : Список стран для подключения")]
                        public List<string> CountryListConnected = new List<string>();
                        [JsonProperty("IQChat : Список причин отсоединения от сервера")]
                        public List<string> ReasonListDisconnected = new List<string>();
                    }
                    internal class IQChatPM
                    {
                        [JsonProperty("IQChat : Использовать случайное сообщение в ЛС")]
                        public bool UseRandomPM;
                        [JsonProperty("IQChat : Список случайных сообщений в ЛС")]
                        public List<string> PMListMessage = new List<string>();
                        [JsonProperty("Укажите минимальный интервал отправки сообщения в ЛС(секунды)")]
                        public int MinimumInterval;
                        [JsonProperty("Укажите максимальный интервал отправки сообщения в ЛС(секунды)")]
                        public int MaximumInterval;
                    }
                }
            }
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    APIKeySteam = "",
                    UseLogConsole = true,
                    GeneralSetting = new GeneralSettings
                    {
                        MaximalOnline = 0,
                        PrefixName = "",
                        AvatarSteamID = "",
                    },
                    FakeOnline = new FakeOnlineSettings
                    {
                        
                        IntervalUpdateOnline = 20,
                        SettingsUpdateOnline = new FakeOnlineSettings.UpdateOnline
                        {
                            TypeOnline = TypeOnline.Auto,
                            ManualFormule = new FakeOnlineSettings.UpdateOnline.ManualFormul
                            {
                                ManualTimeOnline = new Dictionary<int, int>
                                {
                                    [00] = 3,
                                    [01] = 3,
                                    [02] = 3,
                                    [03] = 3,
                                    [04] = 2,
                                    [05] = 2,
                                    [06] = 5,
                                    [07] = 4,
                                    [08] = 5,
                                    [09] = 7,
                                    [10] = 7,
                                    [11] = 8,
                                    [12] = 12,
                                    [13] = 13,
                                    [14] = 16,
                                    [15] = 19,
                                    [16] = 20,
                                    [17] = 21,
                                    [18] = 24,
                                    [19] = 27,
                                    [20] = 29,
                                    [21] = 22,
                                    [22] = 15,
                                    [23] = 7,
                                }
                            },
                            StandartFormulSetting = new FakeOnlineSettings.UpdateOnline.StandartFormul
                            {
                                DayTimeGerenation = true,
                                MinimumFactor = 1.2f,
                                MaximumFactor = 1.35f,
                            },
                        }
                    },
                    FakePlayers = new FakePlayerSettings
                    {
                        ChatsDB = true,
                        PlayersDB = true,
                        ListNickName = new List<string>
                        {
                            "SkuliDropek",
                            "Debil",
                            "Fake#1",
                            "Fake#2",
                            "Fake#3",
                            "Fake#4",
                            "Fake#5s"
                        },
                        ListMessages = new List<string>
                        {
                            "hi",
                            "привет",
                            "классный сервер"
                        }
                    },
                    FakeActive = new ActiveSettings
                    {
                        SoundActive = new ActiveSettings.SounActiveSettings
                        {
                            UseLocalSoundBase = true,
                            MinimumIntervalSound = 228,
                            MaximumIntervalSound = 1337,
                            SoundLists = new List<ActiveSettings.SounActiveSettings.Sounds>
                            {
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 1,
                                    Rare = 30,
                                    MinPos = 30,
                                    MaxPos = 50,
                                    SoundPath = "assets/bundled/prefabs/fx/impacts/stab/concrete/concrete1.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 1,
                                    Rare = 60,
                                    MinPos = 30,
                                    MaxPos = 50,
                                    SoundPath = "assets/bundled/prefabs/fx/impacts/stab/concrete/concrete1.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 1,
                                    Rare = 50,
                                    MinPos = 30,
                                    MaxPos = 50,
                                    SoundPath = "assets/prefabs/deployable/campfire/effects/campfire-deploy.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 1,
                                    Rare = 50,
                                    MinPos = 45,
                                    MaxPos = 70,
                                    SoundPath = "assets/prefabs/locks/keypad/effects/lock.code.updated.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 1,
                                    Rare = 50,
                                    MinPos = 70,
                                    MaxPos = 100,
                                    SoundPath = "assets/prefabs/npc/sam_site_turret/effects/tube_launch.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 1,
                                    Rare = 80,
                                    MinPos = 10,
                                    MaxPos = 30,
                                    SoundPath = "assets/prefabs/weapons/bow/effects/fire.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 1,
                                    Rare = 80,
                                    MinPos = 10,
                                    MaxPos = 30,
                                    SoundPath = "assets/prefabs/weapons/bow/effects/fire.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 1,
                                    Rare = 80,
                                    MinPos = 10,
                                    MaxPos = 30,
                                    SoundPath = "assets/prefabs/weapons/knife/effects/strike-soft.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 2,
                                    Rare = 30,
                                    MinPos = 30,
                                    MaxPos = 50,
                                    SoundPath = "assets/bundled/prefabs/fx/impacts/stab/concrete/concrete1.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 3,
                                    Rare = 30,
                                    MinPos = 30,
                                    MaxPos = 50,
                                    SoundPath = "assets/bundled/prefabs/fx/impacts/stab/concrete/concrete1.prefab"
                                },
                                new ActiveSettings.SounActiveSettings.Sounds
                                {
                                    DayFaktor = 3,
                                    Rare = 30,
                                    MinPos = 30,
                                    MaxPos = 50,
                                    SoundPath = "assets/bundled/prefabs/fx/impacts/stab/concrete/concrete1.prefab"
                                },
                            }
                        },
                        ChatActive = new ActiveSettings.ChatActiveSetting
                        {
                            ColorChatNickDefault = "#44edc0",
                            UseBlackList = true,
                            BlackList = new List<string>
                            {
                                "читы",
                                "mercury",
                                "гадость",
                                "сука",
                                "блядь",
                                "тварь",
                                "сервер",
                                "говно",
                                "хуйня",
                                "накрутка",
                                "фейк",
                                "крутят",
                            },
                            MinimumInterval = 5,
                            MaximumInterval = 30,
                            IQChatNetworkSetting = new ActiveSettings.ChatActiveSetting.IQChatNetwork
                            {
                                UseNetwork = true,
                                CountryListConnected = new List<string>
                                {
                                    "Russia",
                                    "Ukraine",
                                    "Germany"
                                },
                                ReasonListDisconnected = new List<string>
                                {
                                    "Disconnected",
                                    "Time Out",
                                },
                            },
                            IQChatPMSettings = new ActiveSettings.ChatActiveSetting.IQChatPM
                            {
                                UseRandomPM = true,
                                MinimumInterval = 300,
                                MaximumInterval = 900,
                                PMListMessage = new List<string>
                                {
                                    "прив",
                                    "го в тиму",
                                    "хай",
                                    "трейд?",
                                }
                            }
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                else
                {
                    if(config.FakeOnline.SettingsUpdateOnline.ManualFormule.ManualTimeOnline == null || config.FakeOnline.SettingsUpdateOnline.ManualFormule.ManualTimeOnline.Count == 0)
                    {
                        config.FakeOnline.SettingsUpdateOnline.ManualFormule.ManualTimeOnline = new Dictionary<int, int>
                        {
                            [00] = 3,
                            [01] = 3,
                            [02] = 3,
                            [03] = 3,
                            [04] = 2,
                            [05] = 2,
                            [06] = 5,
                            [07] = 4,
                            [08] = 5,
                            [09] = 7,
                            [10] = 7,
                            [11] = 8,
                            [12] = 12,
                            [13] = 13,
                            [14] = 16,
                            [15] = 19,
                            [16] = 20,
                            [17] = 21,
                            [18] = 24,
                            [19] = 27,
                            [20] = 29,
                            [21] = 22,
                            [22] = 15,
                            [23] = 7,
                        };
                    }
                }
            }
            catch
            {
                PrintWarning($"Ошибка чтения # конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Core

        #region Generated Online

        public void GeneratedOnline()
        {
            timerGenerateOnline = timer.Every(config.FakeOnline.IntervalUpdateOnline, () =>
            {
                if (BasePlayer.activePlayerList.Count == 0)
                {
                    if (config.UseLogConsole)
                        PrintWarning("\n\nОбновление отоброжаемоего онлайна не было,т.к онлайн сервера составляет - 0\n\n");
                    return;
                }

                Int32 LastFakeOnline = FakeOnline;
                switch (config.FakeOnline.SettingsUpdateOnline.TypeOnline)
                {
                    case TypeOnline.Auto:
                        {
                            var SettingsOnline = config.FakeOnline.SettingsUpdateOnline.StandartFormulSetting;

                            int MaxOnline = config.GeneralSetting.MaximalOnline != 0 && config.GeneralSetting.MaximalOnline <= ConVar.Server.maxplayers ? config.GeneralSetting.MaximalOnline : ConVar.Server.maxplayers;
                            int ThisOnline = BasePlayer.activePlayerList.Count;
                            float Randoming = Oxide.Core.Random.Range(SettingsOnline.MinimumFactor, SettingsOnline.MaximumFactor);
                            float Time = float.Parse($"1.{DateTime.Now.Hour}{DateTime.Now.Minute}");
                            int DayFactor = SaveCreated <= 1 ? 2 : SaveCreated;
                            float AvaregeOnline = SettingsOnline.DayTimeGerenation ? (((MaxOnline - ThisOnline) / DayFactor * Randoming) / Time) : ((MaxOnline - ThisOnline) / DayFactor * Randoming);

                            FakeOnline = Convert.ToInt32(AvaregeOnline);
                            break;
                        }
                    case TypeOnline.Auto_Plus_Server:
                        {
                            var SettingsOnline = config.FakeOnline.SettingsUpdateOnline.StandartFormulSetting;

                            int MaxOnline = config.GeneralSetting.MaximalOnline != 0 && config.GeneralSetting.MaximalOnline <= ConVar.Server.maxplayers ? config.GeneralSetting.MaximalOnline : ConVar.Server.maxplayers;
                            int ThisOnline = BasePlayer.activePlayerList.Count;
                            float Randoming = Oxide.Core.Random.Range(SettingsOnline.MinimumFactor, SettingsOnline.MaximumFactor);
                            float Time = float.Parse($"1.{DateTime.Now.Hour}{DateTime.Now.Minute}");
                            int DayFactor = SaveCreated <= 1 ? 2 : SaveCreated;
                            float AvaregeOnline = SettingsOnline.DayTimeGerenation ? (((MaxOnline - ThisOnline) / DayFactor * Randoming) / Time) : ((MaxOnline - ThisOnline) / DayFactor * Randoming);

                            FakeOnline = (BasePlayer.activePlayerList.Count + Convert.ToInt32(AvaregeOnline));

                            break;
                        }
                    case TypeOnline.Manual:
                        {
                            Int32 Time = DateTime.Now.Hour;
                            Int32 ManualOnline = config.FakeOnline.SettingsUpdateOnline.ManualFormule.ManualTimeOnline.ContainsKey(Time) ? config.FakeOnline.SettingsUpdateOnline.ManualFormule.ManualTimeOnline[Time] : 0;
                            FakeOnline = BasePlayer.activePlayerList.Count + ManualOnline;
                            break;
                        }
                }

                foreach (var player in BasePlayer.activePlayerList)
                    if (LastFakeOnline > FakeOnline)
                        ChatNetworkConnected(player);
                    else ChatNetworkDisconnected(player);

                if (config.UseLogConsole)
                    PrintWarning($"\n\nКоличество онлайна обновлено :\nОтображаемый онлайн: {FakeOnline}\nНастоящий онлайн: {BasePlayer.activePlayerList.Count}\n\n");
            });
        }

        #endregion

        #region Generation Player Core

        public List<FakePlayer> ReservedPlayer = new List<FakePlayer>();
        public List<FakePlayer> FakePlayerList = new List<FakePlayer>();
        public List<Messages> FakeMessageList = new List<Messages>();
        public class Messages
        {
            public string Message;
        }
        public class FakePlayer
        {
            public String UserID;
            public string DisplayName;
        }
        void SyncReserved()
        {
            if (BasePlayer.activePlayerList.Count == 0)
            {
                if (config.UseLogConsole)
                {
                    PrintWarning("=============SYNC==================");
                    PrintWarning("Синхронизация и резервирование не было т.к онлайн сервера составляет - 0");
                    PrintWarning("=============SYNC==================");
                }
                return;
            }
            ReservedPlayer.Clear();
            for (int i = 0; i < FakeOnline - BasePlayer.activePlayerList.Count; i++)
            {
                int RandomIndex = Oxide.Core.Random.Range(0, FakePlayerList.Count);
                ReservedPlayer.Add(FakePlayerList[RandomIndex]);
            }
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                FakePlayer presetPlayer = new FakePlayer();
                presetPlayer.DisplayName = player.displayName;
                presetPlayer.UserID = player.UserIDString;
                ReservedPlayer.Add(presetPlayer);
            }
            string JSON = JsonConvert.SerializeObject(ReservedPlayer);
            if (config.UseLogConsole)
            {
                PrintWarning("=============SYNC==================");
                PrintWarning("Запущена синхронизация и резервирование игроков под онлайн..");
                PrintWarning($"Всего сгенерировано игроков: {FakePlayerList.Count}");
                PrintWarning($"Онлайн: {FakeOnline}");
                PrintWarning($"Синхронизация завершена, в резерве: {ReservedPlayer.Count}");
                PrintWarning("=============SYNC==================");
            }

            if (!String.IsNullOrWhiteSpace(config.APIKeySteam))
            {
                if (RoutineAddAvatars == null)
                    RoutineAddAvatars = ServerMgr.Instance.StartCoroutine(AddPlayerAvatar());
                else
                {
                    ServerMgr.Instance.StopCoroutine(RoutineAddAvatars);
                    RoutineAddAvatars = ServerMgr.Instance.StartCoroutine(AddPlayerAvatar());
                }
            }
            Interface.Oxide.CallHook("SyncReservedFinish", JSON);
        }
        private void GeneratedAll()
        {
            PrintWarning("Генерация активности..");

            if (config.FakePlayers.PlayersDB)
                GetPlayerDB();
            else GeneratedPlayer();

            if (config.FakePlayers.ChatsDB)
                GetMessageDB();
            else GeneratedMessage();

            PrintWarning("Генерация игроков сообщений в чате завершена..");
        }
        private void GenerateSounds()
        {
            Configuration.ActiveSettings.SounActiveSettings Sound = config.FakeActive.SoundActive;
            if (!Sound.UseLocalSoundBase) return;
            SortedSoundList = config.FakeActive.SoundActive.SoundLists.Where(x => x.SoundPath != null && !String.IsNullOrWhiteSpace(x.SoundPath)).OrderBy(x => x.DayFaktor == SaveCreated).ToList();
        }
        #region Local Base

        private ulong GeneratedSteam64ID()
        {
            ulong GeneratedID = (ulong)Oxide.Core.Random.Range(76561100000000011, 76561199999999999);
            return GeneratedID;
        }
        private string GeneratedNickName()
        {
            int RandomIndexNick = Oxide.Core.Random.Range(0, config.FakePlayers.ListNickName.Count);
            string NickName = config.FakePlayers.ListNickName[RandomIndexNick];
            return NickName;
        }

        private void GeneratedPlayer()
        {
            if (config.FakePlayers.ListNickName.Count == 0)
            {
                PrintError("Ошибка #14534 генерации локальной базы игроков! Введите ники в список ников"); //
                return;
            }
            for (int i = 0; i < config.FakePlayers.ListNickName.Count; i++)
            {
                string DisplayName = GeneratedNickName();
                ulong UserID = GeneratedSteam64ID();

                FakePlayerList.Add(new FakePlayer
                {
                    DisplayName = DisplayName,
                    UserID = UserID.ToString(),
                });
            }
            PrintWarning("Игроки с локальной базы сгенерированы успешно!");
        }

        private void GeneratedMessage()
        {
            if (config.FakePlayers.ListMessages.Count == 0)
            {
                PrintError("Ошибка #14533 генерации локальной базы сообщений! Введите в нее сообщения"); //
                return;
            }
            for (int i = 0; i < config.FakePlayers.ListMessages.Count; i++)
                FakeMessageList.Add(new Messages { Message = config.FakePlayers.ListMessages[i] });
        }

        #endregion

        #region Set Data Base

        private void DumpPlayers(BasePlayer player)
        {
            if (!config.FakePlayers.PlayersDB) return;
            if (player.IsAdmin) return;

            String DisplayName = player.displayName;
            String UserID = player.UserIDString;
            String Body = JsonConvert.SerializeObject(new FakePlayer
            {
                DisplayName = DisplayName,
                UserID = UserID
            });

            string API = $"http://iqsystem.skyplugins.ru/iqsystem/iqfakeactive/dumpplayer";
            Dictionary<string, string> Head = new Dictionary<string, string>
            {
                ["Content-Type"] = "application/json; charset=utf-8"
            };

            try { webrequest.Enqueue(API, Body, (code, response) => { }, this, Core.Libraries.RequestMethod.POST, Head); }
            catch (Exception ex) { }
        }

        internal class MessageToJson
        {
            public String Message;
        }

        private void DumpChat(string Message)
        {
            if (!config.FakePlayers.ChatsDB) return;
            if (config.FakeActive.ChatActive.BlackList.Contains(Message)) return;

            String MessageJson = JsonConvert.SerializeObject(new MessageToJson
            {
                Message = Message
            });
            string API = $"http://iqsystem.skyplugins.ru/iqsystem/iqfakeactive/dumpmessage";
            Dictionary<string, string> Head = new Dictionary<string, string>
            {
                ["Content-Type"] = "application/json"
            };
            try { webrequest.Enqueue(API, MessageJson, (code, response) => { }, this, Core.Libraries.RequestMethod.POST, Head); }
            catch (Exception ex) { }
        }

        #endregion

        #region Get Data Base

        private void GetPlayerDB()
        {
            if (!config.FakePlayers.PlayersDB) return;

            string API = $"http://iqsystem.skyplugins.ru/iqsystem/iqfakeactive/getplayers/v5rsBqzl7wCvFqb45b56bb45"; 

            try
            {
                webrequest.Enqueue(API, null, (code, response) =>
                {
                    if (code == 503)
                    {
                        PrintError("Вышло обновление плагина, обновите версию плагина чтобы вы могли подключаться в базе-данных!");
                        NextTick(() =>
                        {
                            Interface.Oxide.UnloadPlugin(Name);
                        });
                        return;
                    }
                    if (code == 404)
                    {
                        PrintError("Произошла ошибка на сервере базы-данных, сообщите разработчику - SkuliDropek#5212");
                        NextTick(() =>
                        {
                            Interface.Oxide.UnloadPlugin(Name);
                        });
                        return;
                    }
                    FakePlayerList = JsonConvert.DeserializeObject<List<FakePlayer>>(response);
                }, this);
            }
            catch (Exception ex)
            {
                PrintError($"Ошибка #2214538 с генерацией игроков в базе данных\n\n{ex.ToString()}");
            }

            PrintWarning("Игроки с базы данных успешно сгенерированы!");
        }

        private void GetMessageDB()
        {
            if (!config.FakePlayers.ChatsDB) return;

            string API = $"http://iqsystem.skyplugins.ru/iqsystem/iqfakeactive/getmessages/v5rsBqzl7wCvFqb45b56bb45"; 
            try
            {
                webrequest.Enqueue(API, null, (code, response) =>
                {
                    if (code == 503)
                    {
                        PrintError("Вышло обновление плагина, обновите версию плагина чтобы вы могли подключаться в базе-данных!");
                        NextTick(() =>
                        {
                            Interface.Oxide.UnloadPlugin(Name);
                        });
                        return;
                    }
                    if (code == 404)
                    {
                        PrintError("Произошла ошибка на сервере базы-данных, сообщите разработчику - SkuliDropek#5212");
                        NextTick(() =>
                        {
                            Interface.Oxide.UnloadPlugin(Name);
                        });
                        return;
                    }
                    FakeMessageList = JsonConvert.DeserializeObject<List<Messages>>(response);
                }, this);
            }
            catch (Exception ex)
            {
                PrintError($"Ошибка с генерацией игроков в базе данных\n\n{ex.ToString()}");
            }
            PrintWarning("Чат с базы данных успешно сгенерированы!");
        }

        #endregion

        #endregion

        #region Generate Avatart
        public IEnumerator AddPlayerAvatar()
        {
            if (ImageLibrary)
            {
                foreach (var p in ReservedPlayer)
                {
                    if (HasImage(p.UserID.ToString())) continue;

                    string url = "http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key=" + config.APIKeySteam + "&" + "steamids=" + p.UserID;
                    webrequest.Enqueue(url, null, (code, response) =>
                    {
                        string Avatar = (string)JObject.Parse(response)["response"]["players"][0]["avatarfull"];
                        AddImage(Avatar, p.UserID.ToString());
                    }, this);
                    yield return new WaitForSeconds(0.2f);
                }

                PrintWarning("Синхронизация аватарок заверешна");
                PrintWarning("=============SYNC==================");
            }
        }
        #endregion

        #endregion

        #region Active Metods

        private FakePlayer GetFake()
        {
            if (ReservedPlayer == null) return null;
            if (ReservedPlayer.Count == 0) return null;
            return ReservedPlayer[Oxide.Core.Random.Range(0, ReservedPlayer.Count)];
        }
        public bool IsRare(int Rare)
        {
            if (Oxide.Core.Random.Range(0, 100) >= (100 - Rare))
                return true;
            else return false;
        }

        #region Chat Active
        private void StartChat()
        {
            ActivateMessageChat();
            ActivateMessageChatPM();
        }

        private void ActivateMessageChatPM()
        {
            Int32 TimerRandomPM = Oxide.Core.Random.Range(config.FakeActive.ChatActive.IQChatPMSettings.MinimumInterval, config.FakeActive.ChatActive.IQChatPMSettings.MaximumInterval);

            if (timeActivateMessagePm == null || timeActivateMessagePm.Destroyed)
                timeActivateMessagePm = timer.Once(TimerRandomPM, ActivateMessageChatPM);
            else
            {
                timeActivateMessagePm.Destroy();
                timeActivateMessagePm = timer.Once(TimerRandomPM, ActivateMessageChatPM);
            }
            SendRandomPM();
        }
        private void ActivateMessageChat()
        {
            Int32 TimerRandom = Oxide.Core.Random.Range(config.FakeActive.ChatActive.MinimumInterval, config.FakeActive.ChatActive.MaximumInterval);

            if (timeActivateMessage == null || timeActivateMessage.Destroyed)
                timeActivateMessage = timer.Once(TimerRandom, ActivateMessageChat);
            else
            {
                timeActivateMessage.Destroy();
                timeActivateMessage = timer.Once(TimerRandom, ActivateMessageChat);
            }

            String Message = GetMessage();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                SendMessage(player, Message);
        }
        public void SendMessage(BasePlayer player, String Message) 
        {
            if (String.IsNullOrWhiteSpace(Message)) return;
            FakePlayer Player = GetFake();
            if (Player == null) return;
            BasePlayer RealUser = BasePlayer.Find(Player.DisplayName);
            if (RealUser != null && RealUser.IsConnected && !RealUser.IsSleeping())
            {
                ReservedPlayer.Remove(Player);
                return;
            }

            String Prefix = IQChat ? GetInfoIQChat(IQChatGetType.Prefix) : String.Empty;
            String ColorNick = IQChat ? GetInfoIQChat(IQChatGetType.NickColor) : config.FakeActive.ChatActive.ColorChatNickDefault;
            String ColorMessage = IQChat ? GetInfoIQChat(IQChatGetType.ChatColor) : "#ffffff";

            String DisplayName = !String.IsNullOrWhiteSpace(ColorNick) ? $"<color={ColorNick}>{Player.DisplayName}</color> " : Player.DisplayName;
            String FormatPlayer = $"{Prefix} {DisplayName}";
            String FormatMessage = !String.IsNullOrWhiteSpace(ColorMessage) ? $"<color={ColorMessage}>{Message}</color>" : $"{Message}";

            if (IQChat)
                IQChat?.Call("API_SEND_PLAYER", player, FormatPlayer, FormatMessage, $"{Player.UserID}");
            else player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, Player.UserID, $"{FormatPlayer}: {FormatMessage}");
        }
        public void ChatNetworkConnected(BasePlayer player)
        {
            var MessageSettings = config.FakeActive.ChatActive.IQChatNetworkSetting;
            if (!MessageSettings.UseNetwork) return;
            if (IQChat)
            {
                FakePlayer Player = GetFake();
                if (Player == null) return;
                BasePlayer RealUser = BasePlayer.Find(Player.DisplayName);
                if (RealUser != null && RealUser.IsConnected && !RealUser.IsSleeping())
                {
                    ReservedPlayer.Remove(Player);
                    return;
                }
                string Country = GetCountry();
                IQChat?.Call("API_SEND_PLAYER_CONNECTED", player, Player.DisplayName, Country, Player.UserID.ToString());

                if (config.UseLogConsole)
                    PrintWarning($"\nПодключение к серверу во время изменения онлайна Fake-Player: {Player.DisplayName}({Player.UserID})\n\n");
            }
        }
        public void ChatNetworkDisconnected(BasePlayer player)
        {
            var MessageSettings = config.FakeActive.ChatActive.IQChatNetworkSetting;
            if (!MessageSettings.UseNetwork) return;
            if (IQChat)
            {
                FakePlayer Player = GetFake();
                if (Player == null) return;
                BasePlayer RealUser = BasePlayer.Find(Player.DisplayName);
                if (RealUser != null && RealUser.IsConnected && !RealUser.IsSleeping())
                {
                    ReservedPlayer.Remove(Player);
                    return;
                }
                string Reason = GetReason();
                IQChat?.Call("API_SEND_PLAYER_DISCONNECTED", player, Player.DisplayName, Reason, Player.UserID.ToString());

                if (config.UseLogConsole)
                    PrintWarning($"\nОтсоединение от сервера во время изменения онлайна Fake-Player: {Player.DisplayName}({Player.UserID})\n\n");
                ReservedPlayer.Remove(Player);
            }
        }
        public void SendRandomPM()
        {
            if (!config.FakeActive.ChatActive.IQChatPMSettings.UseRandomPM) return;
            if (!IQChat) return;

            int IndexRandomPlayer = Oxide.Core.Random.Range(0, BasePlayer.activePlayerList.Count);
            BasePlayer RandomPlayer = BasePlayer.activePlayerList[IndexRandomPlayer];
            if (RandomPlayer == null) return;
            if (!RandomPlayer.IsConnected) return;
            string Message = GetPM();
            FakePlayer Player = GetFake();
            if (Player == null) return;
            BasePlayer RealUser = BasePlayer.Find(Player.DisplayName);
            if (RealUser != null && RealUser.IsConnected && !RealUser.IsSleeping())
            {
                ReservedPlayer.Remove(Player);
                return;
            }
            if (Player == null) return;
            IQChat?.Call("API_SEND_PLAYER_PM", RandomPlayer, Player.DisplayName, Message);

            if (config.UseLogConsole)
                PrintWarning($"\nОтправлено личное сообщение от Fake-Player: {Player.DisplayName}({Player.UserID}) для игрока : {RandomPlayer.displayName}({RandomPlayer.userID})\nСообщение: {Message}\n\n");
        }

        #region Help Metods Chat Active
        public string GetMessage()
        {
            var MessageSettings = config.FakeActive.ChatActive;
            string Message = FakeMessageList[Oxide.Core.Random.Range(0, FakeMessageList.Count)].Message;
            foreach (var BlackList in MessageSettings.BlackList)
                Message = Message.Replace(BlackList, "");
            return Message;
        }
        public string GetCountry()
        {
            var CountryList = config.FakeActive.ChatActive.IQChatNetworkSetting.CountryListConnected;
            int RandomCountry = Oxide.Core.Random.Range(0, CountryList.Count);
            return CountryList[RandomCountry];
        }
        public string GetReason()
        {
            var ReasonList = config.FakeActive.ChatActive.IQChatNetworkSetting.ReasonListDisconnected;
            int RandomReason = Oxide.Core.Random.Range(0, ReasonList.Count);
            return ReasonList[RandomReason];
        }
        public string GetPM()
        {
            var PMList = config.FakeActive.ChatActive.IQChatPMSettings.PMListMessage;
            int RnadomPM = Oxide.Core.Random.Range(0, PMList.Count);
            return PMList[RnadomPM];
        }
        #endregion

        #endregion

        #region Sound Active

        private Configuration.ActiveSettings.SounActiveSettings.Sounds GetSound()
        {
            Int32 RandomSoundList = Oxide.Core.Random.Range(0, SortedSoundList.Count());
            if (!IsRare(SortedSoundList[RandomSoundList].Rare)) return null;

            return SortedSoundList[RandomSoundList];
        }
        void StartSoundEffects()
        {
            Configuration.ActiveSettings.SounActiveSettings Sound = config.FakeActive.SoundActive;
            if (!Sound.UseLocalSoundBase) return;
            
            Int32 RandomTimer = Oxide.Core.Random.Range(Sound.MinimumIntervalSound, Sound.MaximumIntervalSound);

            if (timerPlaySounds == null || timeActivateMessagePm.Destroyed)
                timerPlaySounds = timer.Once(RandomTimer, StartSoundEffects);
            else
            {
                timerPlaySounds.Destroy();
                timerPlaySounds = timer.Once(RandomTimer, StartSoundEffects);
            }

            PlaySoundEffects();
        }
        private void PlaySoundEffects()
        {
            Configuration.ActiveSettings.SounActiveSettings.Sounds Sound = GetSound();
            if (Sound == null) return;

            foreach (var player in BasePlayer.activePlayerList)
            {
                Effect effect = new Effect();
                int RandomXZ = Oxide.Core.Random.Range(Sound.MinPos, Sound.MaxPos);
                Vector3 PosSound = new Vector3(player.transform.position.x + RandomXZ, player.transform.position.y, player.transform.position.z + RandomXZ);
                effect.Init(Effect.Type.Generic, PosSound, PosSound, (Network.Connection)null);
                effect.pooledString = Sound.SoundPath;
                EffectNetwork.Send(effect, player.net.connection);
            }

            if (config.UseLogConsole)
                PrintWarning($"\n\nДля игроков были проиграны звуки");
        }

        #endregion

        #region InfoMetods

        void ShowFakeOnline(BasePlayer player)
        {
            if (IQChat) return;
            if (ReservedPlayer == null) return;
            if (ReservedPlayer.Count == 0) return;

            String OnlinePlayers = String.Join(", ", ReservedPlayer.Select(p => p.DisplayName.Sanitize()).ToArray());
            String Message = GetLang("SHOW_ONLINE_USERS", player.UserIDString, OnlinePlayers, ReservedPlayer.Count);

            player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, 0, Message);
        }

        #endregion

        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            RoutineInitPlugin = ServerMgr.Instance.StartCoroutine(InitializePlugin());
        }
        
        public IEnumerator InitializePlugin()
        {
            PrintWarning("------------------------");
            PrintWarning("IQFakeActive by SkuliDropek");
            PrintWarning($"Текущий реальный онлайн : {BasePlayer.activePlayerList.Count}");
            PrintWarning("Сейчас начнется генерация активности, ожидайте..Process: ..");
            PrintWarning("------------------------");
            yield return new WaitForSeconds(0.3f);

            //Генерация игроков и чата
            GeneratedAll();

            yield return new WaitForSeconds(3f);

            //Генерируем онлайн от множителя и дополнительных факторов
            GeneratedOnline();

            yield return new WaitForSeconds(1f);

            GenerateSounds();

            yield return new WaitForSeconds(1f);

            //Запуск актива в чате
            StartChat();

            yield return new WaitForSeconds(30f);

            //Резервируем игроков
            SyncReserved();
            timerSynh = timer.Every(600f, () => { SyncReserved(); });

            yield return new WaitForSeconds(3f);

            //Запускаем звуки
            StartSoundEffects();
        }
        void Unload()
        {
            if (RoutineAddAvatars != null)
                ServerMgr.Instance.StopCoroutine(RoutineAddAvatars);
            if (RoutineInitPlugin != null)
                ServerMgr.Instance.StopCoroutine(RoutineInitPlugin);

            RoutineAddAvatars = null;
            RoutineInitPlugin = null;
            if (timeActivateMessage != null && !timeActivateMessage.Destroyed)
                timeActivateMessage.Destroy();
            if (timeActivateMessagePm != null && !timeActivateMessagePm.Destroyed)
                timeActivateMessagePm.Destroy();
            if (timerSynh != null && !timerSynh.Destroyed)
                timerSynh.Destroy();
            if (timerGenerateOnline != null && !timerGenerateOnline.Destroyed)
                timerGenerateOnline.Destroy();
            if (timerPlaySounds != null && !timerPlaySounds.Destroyed)
                timerPlaySounds.Destroy();
        }

        object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (player.IsAdmin) return null;
            if (String.IsNullOrWhiteSpace(message)) return null;
            if (channel == Chat.ChatChannel.Team || channel == Chat.ChatChannel.Server) return null;
            DumpChat(message);
            return null;
        }
        void OnPlayerConnected(BasePlayer player) => DumpPlayers(player);
        #endregion

        #region Commands
        [ChatCommand("online")]
        void ChatCommandShowOnline(BasePlayer player) => ShowFakeOnline(player);

        [ChatCommand("players")]
        void ChatCommandShowPlayers(BasePlayer player) => ShowFakeOnline(player);

        [ConsoleCommand("iqfa")]
        void IQFakeActiveCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning("===========SYNTAX===========");
                PrintWarning("Используйте команды:");
                PrintWarning("iqfa online - для показателя онлайна");
                PrintWarning("iqfa synh - синхронизация игроков в резерв");
                PrintWarning("===========SYNTAX===========");
                return;
            }
            string ActionCommand = arg.Args[0].ToLower();
            switch(ActionCommand)
            {
                case "online":
                case "player":
                case "players":
                    {
                        PrintWarning("===========INFORMATION===========");
                        PrintWarning($"Настоящий онлайн : {BasePlayer.activePlayerList.Count}");
                        PrintWarning($"Общий онлайн : {FakeOnline}");
                        PrintWarning("===========INFORMATION===========");
                        break;
                    }
                case "synh":
                case "synchronization":
                case "update":
                case "refresh":
                    {
                        SyncReserved();
                        break;
                    }
            }
        }
        #endregion

        #region API


        bool IsFake(ulong userID) => FakePlayerList.Where(x => x.UserID == userID.ToString()).Count() > 0;
        bool IsFake(string DisplayName) => FakePlayerList.Where(x => x.DisplayName.Contains(DisplayName)).Count() > 0;
        int GetOnline() => FakeOnline;
        ulong GetFakeIDRandom() => (ulong)ulong.Parse(FakePlayerList[Oxide.Core.Random.Range(0, FakePlayerList.Count)].UserID);
        string GetFakeNameRandom() => (string)FakePlayerList[Oxide.Core.Random.Range(0, FakePlayerList.Count)].DisplayName;
        string FindFakeName(ulong ID)
        {
            var Fake = ReservedPlayer.FirstOrDefault(x => x.UserID == ID.ToString());
            if (Fake == null) return null;
            return Fake.DisplayName;
        }
        int DayWipe() => SaveCreated;
        void RemoveReserver(UInt64 ID)
        {
            var Fake = ReservedPlayer.FirstOrDefault(x => x.UserID == ID.ToString());
            if (Fake == null) return;

            ReservedPlayer.Remove(Fake);
        }
        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<String, String>
            {
                ["SHOW_ONLINE_USERS"] = "Players Online: <color=#79d36b>{0}</color> (<color=#dda32e>{1}</color>)",
            }, this);

            lang.RegisterMessages(new Dictionary<String, String>
            {
                ["SHOW_ONLINE_USERS"] = "Игроки онлайн: <color=#79d36b>{0}</color> (<color=#dda32e>{1}</color>)",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }

        public static StringBuilder sb = new StringBuilder();
        public String GetLang(String LangKey, String userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        #endregion
    }
}


// --- End of file: IQFakeActive.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CupboardProtection.cs ---
// --- Original Local Path: CupboardProtection.cs ---

namespace Oxide.Plugins
{
    [Info("CupboardProtection", "Wulf/lukespragg", 0.1, ResourceId = 1390)]
    [Description("Makes cupboards invulnerable, unable to be destroyed.")]

    class CupboardProtection : RustPlugin
    {
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity.name.Contains("cupboard")) return false;
            return null;
        }
    }
}


// --- End of file: CupboardProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQTurret.cs ---
// --- Original Local Path: IQTurret.cs ---

using System.Diagnostics;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.Linq;
using System.Threading;
using System;
using System.Text;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("IQTurret", "Sempai#3239", "1.3.7")]
    [Description("Турели без электричества с лимитами на игрока/шкаф")]
    internal class IQTurret : RustPlugin
    {
        void OnEntitySpawned(AutoTurret turret) => SetupTurret(turret);
		   		 		  						  	   		  		 			  		 			  			 		  		  
        private Dictionary<BaseEntity, ElectricSwitch> GetPlayerTurretAndSwitch(BasePlayer player)
        {
            Dictionary<BaseEntity, ElectricSwitch> keyValuePairs = new Dictionary<BaseEntity, ElectricSwitch>();

            if (config.LimitController.typeLimiter == TypeLimiter.Player)
            {
                foreach (KeyValuePair<UInt64, List<ControllerInformation>> Turrets in TurretList)
                    foreach (ControllerInformation ControllerInformation in Turrets.Value)
                        if (ControllerInformation.PlayerID == player.userID
                        && ControllerInformation.turrel != null
                        && !ControllerInformation.turrel.IsDestroyed
                        && ControllerInformation.electricSwitch != null
                        && !ControllerInformation.electricSwitch.IsDestroyed
                        && !IsTurretElectricalTurned(ControllerInformation.electricSwitch))
                            keyValuePairs.Add(ControllerInformation.turrel, ControllerInformation.electricSwitch);
            }
            else
            {
                foreach (KeyValuePair<UInt64, List<ControllerInformation>> Turrets in TurretList)
                    foreach (ControllerInformation ControllerInformation in Turrets.Value)
                        if (ControllerInformation.BuildingID == (player.GetBuildingPrivilege() == null ? 0 : player.GetBuildingPrivilege().buildingID)
                        && ControllerInformation.turrel != null
                        && !ControllerInformation.turrel.IsDestroyed
                        && ControllerInformation.electricSwitch != null
                        && !ControllerInformation.electricSwitch.IsDestroyed
                        && !IsTurretElectricalTurned(ControllerInformation.electricSwitch))
                            keyValuePairs.Add(ControllerInformation.turrel, ControllerInformation.electricSwitch);
            }

            return keyValuePairs;
        }
        void OnEntitySpawned(SamSite samSite) => SetupTurret(samSite);
		   		 		  						  	   		  		 			  		 			  			 		  		  
        private ProtectionProperties ImmortalProtection;

        private Boolean IsTurretElectricalTurned(ElectricSwitch Switch)
        {
            if (Switch == null) return false;
            BaseEntity turrel = GetTurretForSwitch(Switch);

            if (turrel != null)
            {
                if (turrel is AutoTurret)
                    return (turrel as AutoTurret)?.GetConnectedInputCount() > 0;

                if (turrel is SamSite)
                    return (turrel as SamSite)?.GetConnectedInputCount() > 0;
            }

            return false;
        }

        object OnWireClear(BasePlayer player, IOEntity entity1, int connected, IOEntity entity2, bool flag)
        {
            ElectricSwitch switchConnected = entity1 as ElectricSwitch;
            if (switchConnected != null && switchConnected.skinID != 0 && TurretList.ContainsKey(switchConnected.skinID))
                return false;

            return null;
        }
        void OnServerShutdown() => UnloadPlugin();
        
                public Boolean IsRaidBlocked(BasePlayer player) 
        {
            if (!config.ReferencesPlugin.BlockedTumblerRaidblock) return false;
            String ret = Interface.Call("CanTeleport", player) as String;
            return ret != null;
        }
        private const Boolean LanguageEn = false;

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning(LanguageEn ? $"Error #84415 configuration readings 'oxide/config/{Name}', creating a new configuration!" : $"Ошибка #84415 чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!"); //
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }
        private void RegisteredTurret(UInt64 ID, UInt64 PlayerID, ElectricSwitch smartSwitch, BaseEntity turrel, BasePlayer player = null, Boolean IsInit = false)
        {
            ControllerInformation information = new ControllerInformation();
            information.turrel = turrel;
            information.electricSwitch = smartSwitch;
            information.PlayerID = PlayerID;

            UInt64 BuildingID = 0;
            if (player != null && player.GetBuildingPrivilege() != null)
                BuildingID = player.GetBuildingPrivilege().buildingID;
            else if (turrel != null && turrel.GetBuildingPrivilege() != null)
                BuildingID = turrel.GetBuildingPrivilege().buildingID;
            else if (smartSwitch != null && smartSwitch.GetBuildingPrivilege() != null)
                BuildingID = smartSwitch.GetBuildingPrivilege().buildingID;

            information.BuildingID = BuildingID;

            if (!TurretList.ContainsKey(ID))
                TurretList.Add(ID, new List<ControllerInformation> { information });
            else TurretList[ID].Add(information);

            if (IsInit)
                if (!IsLimitPlayer(PlayerID, BuildingID))
                {
                    if (turrel is AutoTurret && (turrel as AutoTurret).currentEnergy <= 0)
                    {
                        turrel.SetFlag(BaseEntity.Flags.On, true);
                        smartSwitch.SetFlag(BaseEntity.Flags.On, true);
                    }
                    else if (turrel is SamSite && (turrel as SamSite).currentEnergy <= 0)
                    {
                        turrel.SetFlag(BaseEntity.Flags.Reserved8, true);
                        smartSwitch.SetFlag(BaseEntity.Flags.On, true);
                    }
                }
        }

        private readonly List<UInt64> IDsPrefabs = new List<UInt64> { 3312510084, 2059775839 };
        internal class ControllerInformation
        {
            public BaseEntity turrel;
            public ElectricSwitch electricSwitch;
            public UInt64 PlayerID;
            public UInt64 BuildingID;
        }
        private readonly String PermissionTurnAllTurretsOff = "iqturret.turnoffall";
        void OnEntityKill(SamSite samSite) => RemoveSwitch(samSite);
		   		 		  						  	   		  		 			  		 			  			 		  		  
        
        
        private Dictionary<UInt64, List<ControllerInformation>> TurretList = new Dictionary<UInt64, List<ControllerInformation>>();
        
                void Init() => Unsubscribe(nameof(OnEntitySpawned));

        public void SendChat(String Message, BasePlayer player, ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
        {
            if (IQChat)
                if (config.ReferencesPlugin.IQChatSetting.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, config.ReferencesPlugin.IQChatSetting.CustomPrefix, config.ReferencesPlugin.IQChatSetting.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        /// <summary>
        /// Обновление 1.3.x
        /// - Исправлено удаление турелей из-за IQCraftSystem
        /// - Исправлен лимит на игроков, когда они могли его превышать использую чужие турели
        /// - Корректировка работы методов с лимитами
        /// </summary>
        
        
        [PluginReference] private Plugin IQChat;
        public string GetLang(String LangKey, String userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }

        
                private void RemoveSwitch(BaseEntity entity)
        {
            if (entity == null || entity.skinID == 0) return;
            UInt64 ID = entity.skinID;

            if (TurretList.ContainsKey(ID))
            {
                ControllerInformation controller = TurretList[ID].FirstOrDefault(x => x.electricSwitch.skinID == ID);
                if (controller != null)
                    controller.electricSwitch.Kill();

                TurretList.Remove(ID);
            }
        }

        private readonly String PermissionTurnAllTurretsOn = "iqturret.turnonall";

        [ConsoleCommand("t")]
        void TurretControllConsoleCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null || arg == null || arg.Args.Length == 0)
            {
                SendChat(GetLang("SYNTAX_COMMAND_ERROR", player.UserIDString), player);
                return;
            }

            String Action = arg.Args[0];
            if (String.IsNullOrWhiteSpace(Action)) return;
            switch (Action)
            {
                case "limit":
                    {
                        UInt64 ID = 0;
                        if (config.LimitController.typeLimiter == TypeLimiter.Building && player.GetBuildingPrivilege() != null)
                            ID = player.GetBuildingPrivilege().buildingID;

                        String Lang = GetLang("INFORMATION_MY_LIMIT", player.UserIDString, (GetLimitPlayer(player.userID) - GetAmountTurretPlayer(player.userID, ID)));
                        SendChat(Lang, player);
                        break;
                    }
                case "off":
                    {
                        if (!permission.UserHasPermission(player.UserIDString, PermissionTurnAllTurretsOff))
                        {
                            SendChat(GetLang("PERMISSION_COMMAND_ERROR", player.UserIDString), player);
                            return;
                        }

                        Int32 LimitPlayer = GetLimitPlayer(player.userID);
                        Dictionary<BaseEntity, ElectricSwitch> PlayerTurrets = GetPlayerTurretAndSwitch(player);
                        if (PlayerTurrets != null)
                        {
                            foreach (KeyValuePair<BaseEntity, ElectricSwitch> Item in PlayerTurrets.Where(x => x.Value.HasFlag(BaseEntity.Flags.On)).Take(LimitPlayer))
                                if (Item.Key is AutoTurret)
                                {
                                    if (Item.Key.HasFlag(BaseEntity.Flags.On))
                                    {
                                        Item.Key.SetFlag(BaseEntity.Flags.On, false);
                                        Item.Value.SetFlag(BaseEntity.Flags.On, false);
                                        LimitPlayer--;
                                    }
                                }
                                else if (Item.Key is SamSite)
                                {
                                    if (Item.Key.HasFlag(BaseEntity.Flags.Reserved8))
                                    {
                                        Item.Key.SetFlag(BaseEntity.Flags.Reserved8, false);
                                        Item.Value.SetFlag(BaseEntity.Flags.On, false);
                                        LimitPlayer--;
                                    }
                                }
                        }
                        break;
                    }
                case "on":
                    {
                        if (!permission.UserHasPermission(player.UserIDString, PermissionTurnAllTurretsOn))
                        {
                            SendChat(GetLang("PERMISSION_COMMAND_ERROR", player.UserIDString), player);
                            return;
                        }

                        Int32 LimitPlayer = GetLimitPlayer(player.userID);
                        Dictionary<BaseEntity, ElectricSwitch> PlayerTurrets = GetPlayerTurretAndSwitch(player);
                        if (PlayerTurrets != null)
                        {
                            foreach (KeyValuePair<BaseEntity, ElectricSwitch> Item in PlayerTurrets.Where(x => !x.Value.HasFlag(BaseEntity.Flags.On)).Take(LimitPlayer))
                                if (Item.Key is AutoTurret)
                                {
                                    if (!Item.Key.HasFlag(BaseEntity.Flags.On))
                                    {
                                        Item.Key.SetFlag(BaseEntity.Flags.On, true);
                                        Item.Value.SetFlag(BaseEntity.Flags.On, true);
                                        LimitPlayer--;
                                    }
                                }
                                else if (Item.Key is SamSite)
                                {
                                    if (!Item.Key.HasFlag(BaseEntity.Flags.Reserved8))
                                    {
                                        Item.Key.SetFlag(BaseEntity.Flags.Reserved8, true);
                                        Item.Value.SetFlag(BaseEntity.Flags.On, true);
                                        LimitPlayer--;
                                    }
                                }
                        }
                        break;
                    }
            }
        }


        
        
        private void UnloadPlugin()
        {
            UnityEngine.Object.Destroy(ImmortalProtection);

            foreach (List<ControllerInformation> TurretInformation in TurretList.Values)
            foreach (ControllerInformation controllerInformation in TurretInformation)
            {
                BaseEntity turrel = controllerInformation.turrel;

                if (turrel != null)
                {
                    if (turrel is AutoTurret && turrel.HasFlag(BaseEntity.Flags.On) &&
                        (turrel as AutoTurret).currentEnergy == 0)
                        turrel.SetFlag(BaseEntity.Flags.On, false);

                    if (turrel is SamSite && turrel.HasFlag(BaseEntity.Flags.Reserved8) &&
                        (turrel as SamSite).currentEnergy == 0)
                        turrel.SetFlag(BaseEntity.Flags.Reserved8, false);

                    turrel.SendNetworkUpdate();
                }

                ElectricSwitch electricSwitch = controllerInformation.electricSwitch;

                if (electricSwitch != null)
                    electricSwitch.Kill();
            }
        }


        
        
        [ChatCommand("t")]
        void TurretControllChatCommand(BasePlayer player, String cmd, String[] arg)
        {
            if (player == null || arg == null || arg.Length == 0)
            {
                SendChat(GetLang("SYNTAX_COMMAND_ERROR", player.UserIDString), player);
                return;
            }

            String Action = arg[0];
            if (String.IsNullOrWhiteSpace(Action)) return;
            switch (Action)
            {
                case "limit":
                    {
                        UInt64 ID = 0;
                        if (config.LimitController.typeLimiter == TypeLimiter.Building && player.GetBuildingPrivilege() != null)
                            ID = player.GetBuildingPrivilege().buildingID;

                        String Lang = GetLang("INFORMATION_MY_LIMIT", player.UserIDString, (GetLimitPlayer(player.userID) - GetAmountTurretPlayer(player.userID, ID)));
                        SendChat(Lang, player);
                        break;
                    }
                case "off":
                    {
                        if (!permission.UserHasPermission(player.UserIDString, PermissionTurnAllTurretsOff))
                        {
                            SendChat(GetLang("PERMISSION_COMMAND_ERROR", player.UserIDString), player);
                            return;
                        }

                        Int32 LimitPlayer = GetLimitPlayer(player.userID);
                        Dictionary<BaseEntity, ElectricSwitch> PlayerTurrets = GetPlayerTurretAndSwitch(player);
                        if (PlayerTurrets != null)
                        {
                            foreach (KeyValuePair<BaseEntity, ElectricSwitch> Item in PlayerTurrets.Where(x => x.Value.HasFlag(BaseEntity.Flags.On)).Take(LimitPlayer))
                                if (Item.Key is AutoTurret)
                                {
                                    if (Item.Key.HasFlag(BaseEntity.Flags.On))
                                    {
                                        Item.Key.SetFlag(BaseEntity.Flags.On, false);
                                        Item.Value.SetFlag(BaseEntity.Flags.On, false);
                                        LimitPlayer--;
                                    }
                                }
                                else if (Item.Key is SamSite)
                                {
                                    if (Item.Key.HasFlag(BaseEntity.Flags.Reserved8))
                                    {
                                        Item.Key.SetFlag(BaseEntity.Flags.Reserved8, false);
                                        Item.Value.SetFlag(BaseEntity.Flags.On, false);
                                        LimitPlayer--;
                                    }
                                }
                        }
                        break;
                    }
                case "on":
                    {
                        if (!permission.UserHasPermission(player.UserIDString, PermissionTurnAllTurretsOn))
                        {
                            SendChat(GetLang("PERMISSION_COMMAND_ERROR", player.UserIDString), player);
                            return;
                        }

                        Int32 LimitPlayer = GetLimitPlayer(player.userID);
                        Dictionary<BaseEntity, ElectricSwitch> PlayerTurrets = GetPlayerTurretAndSwitch(player);
                        if (PlayerTurrets != null)
                        {
                            foreach (KeyValuePair<BaseEntity, ElectricSwitch> Item in PlayerTurrets.Where(x => !x.Value.HasFlag(BaseEntity.Flags.On)).Take(LimitPlayer))
                                if (Item.Key is AutoTurret)
                                {
                                    if (!Item.Key.HasFlag(BaseEntity.Flags.On))
                                    {
                                        Item.Key.SetFlag(BaseEntity.Flags.On, true);
                                        Item.Value.SetFlag(BaseEntity.Flags.On, true);
                                        LimitPlayer--;
                                    }
                                }
                                else if (Item.Key is SamSite)
                                {
                                    if (!Item.Key.HasFlag(BaseEntity.Flags.Reserved8))
                                    {
                                        Item.Key.SetFlag(BaseEntity.Flags.Reserved8, true);
                                        Item.Value.SetFlag(BaseEntity.Flags.On, true);
                                        LimitPlayer--;
                                    }
                                }
                        }
                        break;
                    }
            }
        }

        bool CanPickupEntity(BasePlayer player, AutoTurret turret)
        {
            if (turret != null && turret.skinID != 0 && turret.OwnerID != 0 && TurretList.ContainsKey(turret.skinID))
            {
                RemoveSwitch(turret);

                turret.skinID = 0;
                return true;
            }
            return true;
        }
      
        private ElectricSwitch GetSwitchForTurret(BaseEntity Turret)
        {
            if (Turret == null || Turret.IsDestroyed || !TurretList.ContainsKey(Turret.skinID)) return null;
            List<ControllerInformation> InformationList = TurretList[Turret.skinID];
            if (InformationList == null) return null;
		   		 		  						  	   		  		 			  		 			  			 		  		  
            foreach (ControllerInformation Info in InformationList)
                if (Info.electricSwitch.skinID.Equals(Turret.skinID))
                    return Info.electricSwitch;

            return null;
        }

        
        
        
        private Boolean IsLimitPlayer(UInt64 playerID, UInt64 ID) => GetAmountTurretPlayer(playerID, ID) >= GetLimitPlayer(playerID);
                
        
                private enum TypeLimiter
        {
            Player,
            Building
        }

        private void TurretToggle(BasePlayer player, ElectricSwitch electricSwitch)
        {
            if(electricSwitch == null) return;

            BaseEntity turrel = GetTurretForSwitch(electricSwitch);
            Boolean IsFlag = false;

            if (turrel != null)
            {
                BaseEntity.Flags flags = BaseEntity.Flags.On;
                if (turrel is AutoTurret)
                    flags = BaseEntity.Flags.On;
               
                else if (turrel is SamSite)
                    flags = BaseEntity.Flags.Reserved8;

                if (!turrel.HasFlag(flags))
                    turrel.SetFlag(flags, true);
                else turrel.SetFlag(flags, false);

                IsFlag = turrel.HasFlag(flags);
            }

            if (config.LimitController.UseLimitControll)
            {
                UInt64 ID = 0;
                if (config.LimitController.typeLimiter == TypeLimiter.Building && player.GetBuildingPrivilege() != null)
                    ID = player.GetBuildingPrivilege().buildingID;
                
                Int32 LimitCount = (GetLimitPlayer(electricSwitch.OwnerID) - GetAmountTurretPlayer(electricSwitch.OwnerID, ID));
                SendChat(GetLang(IsFlag ? (electricSwitch.OwnerID != player.userID ? "INFORMATION_USER_ON_OTHER" : "INFORMATION_USER_ON") : (electricSwitch.OwnerID != player.userID ? "INFORMATION_USER_OFF_OTHER" : "INFORMATION_USER_OFF"), player.UserIDString, LimitCount), player);
            }
        }

        private BaseEntity GetTurretForSwitch(ElectricSwitch Switch)
        {
            if (Switch == null || Switch.IsDestroyed || !TurretList.ContainsKey(Switch.skinID)) return null;
            List<ControllerInformation> InformationList = TurretList[Switch.skinID];
            if (InformationList == null)
                return null;

            foreach (ControllerInformation Info in InformationList)
                if (Info.electricSwitch.skinID.Equals(Switch.skinID))
                    return Info.turrel;

            return null;
        }
        private class Configuration
        {

            internal class LimitControll
            {
                [JsonProperty(LanguageEn ? "The limit of turrets WITHOUT electricity by privileges [Permission] = Limit (Make a list from more to less)" : "Лимит турелей БЕЗ электричества по привилегиям [Права] = Лимит (Составляйте список от большего - к меньшему)")]
                public Dictionary<String, Int32> PermissionsLimits = new Dictionary<String, Int32>();
                [JsonProperty(LanguageEn ? "Use the limit on turrets WITHOUT electricity? (true - yes/false - no)" : "Использовать лимит на туррели БЕЗ электричества? (true - да/false - нет)")]
                public Boolean UseLimitControll;
                [JsonProperty(LanguageEn ? "Limit Type: 0 - Player, 1 - Building" : "Тип лимита : 0 - На игрока, 1 - На шкаф")]
                public TypeLimiter typeLimiter;
                [JsonProperty(LanguageEn ? "Limit turrets WITHOUT electricity (If the player does not have privileges)" : "Лимит турелей БЕЗ электричества (Если у игрока нет привилегий)")]
                public Int32 LimitAmount;
            }
            [JsonProperty(LanguageEn ? "Setting limits on turrets WITHOUT electricity" : "Настройка лимитов на турели БЕЗ электричества")]
            public LimitControll LimitController = new LimitControll();
            internal class ReferenceSettings
            {
                [JsonProperty(LanguageEn ? "Setting up collaboration with IQChat" : "Настройка совместной работы с IQChat")]
                public IQChatPlugin IQChatSetting = new IQChatPlugin();
                internal class IQChatPlugin
                {
                    [JsonProperty(LanguageEn ? "IQChat :Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
                    public String CustomPrefix;
                    [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat(If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
                    public String CustomAvatar;
                    [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI-уведомления")]
                    public Boolean UIAlertUse = false;
                }
                
                [JsonProperty(LanguageEn ? "Prohibit the use of a switch during a raidBlock?" : "Запретить использовать рубильник во время рейдблока?")]
                public Boolean BlockedTumblerRaidblock;
            }
            [JsonProperty(LanguageEn ? "Configuring plugins for Collaboration" : "Настройка плагинов для совместной работы")]
            public ReferenceSettings ReferencesPlugin = new ReferenceSettings();

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    LimitController = new LimitControll
                    {
                        typeLimiter = TypeLimiter.Building,
                        UseLimitControll = true,
                        LimitAmount = 3,
                        PermissionsLimits = new Dictionary<String, Int32>()
                        {
                            ["iqturret.ultra"] = 150,
                            ["iqturret.king"] = 15,
                            ["iqturret.premium"] = 10,
                            ["iqturret.vip"] = 6,
                        }
                    },
                    ReferencesPlugin = new ReferenceSettings
                    {
                        IQChatSetting = new ReferenceSettings.IQChatPlugin
                        {
                            CustomPrefix = "[<color=#ffff40>IQTurret</color>] ",
                            CustomAvatar = "0",
                            UIAlertUse = false,
                        },
                        BlockedTumblerRaidblock = true,
                    }
                };
            }
        }
        
        private Int32 GetAmountTurretPlayer(UInt64 playerID, UInt64 ID)
        {
            TypeLimiter Type = config.LimitController.typeLimiter;
            
            Int32 CountTurret = 0;

            if (Type == TypeLimiter.Player)
            {
                foreach (KeyValuePair<UInt64, List<ControllerInformation>> Turrets in TurretList)
                foreach (ControllerInformation ControllerInformation in Turrets.Value)
                {
                    if (ControllerInformation.PlayerID == playerID
                        && (ControllerInformation.turrel != null && !ControllerInformation.turrel.IsDestroyed)
                        && ControllerInformation.electricSwitch != null
                        && !ControllerInformation.electricSwitch.IsDestroyed
                        && !IsTurretElectricalTurned(ControllerInformation.electricSwitch)
                        && (ControllerInformation.turrel != null &&
                            ((ControllerInformation.turrel is SamSite &&
                              ControllerInformation.turrel.HasFlag(BaseEntity.Flags.Reserved8)) ||
                             (ControllerInformation.turrel is AutoTurret &&
                              ControllerInformation.turrel.HasFlag(BaseEntity.Flags.On)))))
                        CountTurret++;
                }
            }
            else
            {
                foreach (KeyValuePair<UInt64, List<ControllerInformation>> Turrets in TurretList)
                    foreach (ControllerInformation ControllerInformation in Turrets.Value)
                        if (ControllerInformation.BuildingID == ID
                        && (ControllerInformation.turrel != null && !ControllerInformation.turrel.IsDestroyed)
                        && ControllerInformation.electricSwitch != null
                        && !ControllerInformation.electricSwitch.IsDestroyed
                        && !IsTurretElectricalTurned(ControllerInformation.electricSwitch)
                        && (ControllerInformation.turrel != null && ((ControllerInformation.turrel is SamSite && ControllerInformation.turrel.HasFlag(BaseEntity.Flags.Reserved8)) || (ControllerInformation.turrel is AutoTurret && ControllerInformation.turrel.HasFlag(BaseEntity.Flags.On)))))
                            CountTurret++;
            }

            return CountTurret;
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            BasePlayer damager = hitInfo.InitiatorPlayer;
            if (entity == null || hitInfo == null || damager == null) return;

            ElectricSwitch Switch = entity as ElectricSwitch;
            if (Switch != null && Switch.skinID != 0 && TurretList.ContainsKey(Switch.skinID))
                hitInfo.damageTypes.ScaleAll(0);
        }
		   		 		  						  	   		  		 			  		 			  			 		  		  
        
        
        private static Configuration config = new Configuration();

        
        
                private static StringBuilder sb = new StringBuilder(); 

        void Unload() => UnloadPlugin();
        protected override void SaveConfig() => Config.WriteObject(config);
		   		 		  						  	   		  		 			  		 			  			 		  		  
        private Int32 GetLimitPlayer(UInt64 PlayerID)
        {
            foreach (KeyValuePair<String, Int32> LimitPrivilage in config.LimitController.PermissionsLimits)
                if (permission.UserHasPermission(PlayerID.ToString(), LimitPrivilage.Key))
                    return LimitPrivilage.Value;

            return config.LimitController.LimitAmount;
        }

        private void InitializeData()
        {
            List<BaseNetworkable> Turrets = BaseNetworkable.serverEntities.Where(b => b != null && IDsPrefabs.Contains(b.prefabID) && !TurretList.ContainsKey((b as BaseEntity).skinID)).ToList();
            if (Turrets == null) return;

            for (Int32 index = 0; index < Turrets.Count; index++)
            {
                BaseEntity turrel = Turrets[index] as BaseEntity;

                if (turrel != null)
                    SetupTurret(turrel, true);
            }
            Subscribe(nameof(OnEntitySpawned));
        }
        private void SetupTurret(BaseEntity turrel, Boolean IsInit = false)
        {
            if (turrel == null || turrel is NPCAutoTurret || !IDsPrefabs.Contains(turrel.prefabID) && TurretList.ContainsKey(turrel.skinID) || turrel.skinID == 1587601905) return;

            UInt64 PlayerID = turrel.OwnerID;
            UInt64 ID = PlayerID + (UInt64)Oxide.Core.Random.Range(999999999);

            Vector3 PositionSwitch = turrel is AutoTurret ? new Vector3(0f, -0.65f, 0.32f) : new Vector3(0f, -0.65f, 0.95f);

            ElectricSwitch smartSwitch = GameManager.server.CreateEntity(SwitchPrefab, turrel.transform.TransformPoint(PositionSwitch), Quaternion.Euler(turrel.transform.rotation.eulerAngles.x, turrel.transform.rotation.eulerAngles.y, 0f), true) as ElectricSwitch;
            if (smartSwitch == null) return;
		   		 		  						  	   		  		 			  		 			  			 		  		  
            smartSwitch.OwnerID = PlayerID;
            smartSwitch.skinID = ID;
            turrel.skinID = ID;

            smartSwitch.pickup.enabled = false;
            smartSwitch.SetFlag(IOEntity.Flag_HasPower, true);
            smartSwitch.baseProtection = ImmortalProtection;
		   		 		  						  	   		  		 			  		 			  			 		  		  
                        foreach (var meshCollider in smartSwitch.GetComponentsInChildren<MeshCollider>())
                UnityEngine.Object.DestroyImmediate(meshCollider);

            UnityEngine.Object.DestroyImmediate(smartSwitch.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(smartSwitch.GetComponent<GroundWatch>());
            
                        foreach (var input in smartSwitch.inputs)
                input.type = IOEntity.IOType.Generic;

            foreach (var output in smartSwitch.outputs)
                output.type = IOEntity.IOType.Generic;
            
            smartSwitch.Spawn();

            smartSwitch.SetFlag(BaseEntity.Flags.Reserved8, true);
            smartSwitch.SetFlag(BaseEntity.Flags.On, false);

            BasePlayer player = BasePlayer.FindByID(PlayerID);
            RegisteredTurret(ID, PlayerID, smartSwitch, turrel, player, IsInit);
        }

        object OnWireConnect(BasePlayer player, IOEntity entity1, int inputs, IOEntity entity2, int outputs)
        {
            if ((entity1 is AutoTurret) || (entity1 is SamSite))
            {
                ElectricSwitch Switch = GetSwitchForTurret(entity1);
                if (Switch == null) return null;

                if (Switch.HasFlag(BaseEntity.Flags.On))
                {
                    Switch.SetFlag(BaseEntity.Flags.On, false);
                    Switch.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    Switch.MarkDirty();
                }
            }
            return null;
        }

        void OnEntityKill(AutoTurret turret) => RemoveSwitch(turret);
        BaseEntity API_GET_TURRET(BasePlayer player, ElectricSwitch electricSwitch) => GetTurretForSwitch(electricSwitch);
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["IS_LIMIT_TRUE"] = "At you <color=#dd6363>exceeded</color> limit of active turrets <color=#dd6363>WITHOUT ELECTRICITY</color>",
                ["IS_TURRET_ELECTRIC_TRUE"] = "This turret is connected <color=#dd6363>to electricity</color>, you can't use the switch!",
                ["IS_BUILDING_BLOCK_TOGGLE"] = "You cannot use the switch in <color=#dd6363>someone else's house</color>",
                ["INFORMATION_USER_ON"] = "You have successfully <color=#66e28b>enabled</color> the turret, you can still enable <color=#dd6363>{0}</color> turret",
                ["INFORMATION_USER_OFF"] = "You have successfully <color=#dd6363>disabled</color> the turret, you can still enable <color=#dd6363>{0}</color> turret",
                ["INFORMATION_MY_LIMIT"] = "<color=#dd6363> is available to you</color> to enable <color=#dd6363>{0}</color> turrets",
                ["SYNTAX_COMMAND_ERROR"] = "<color=#dd6363>Syntax error : </color>\nUse the commands :\n1. t on - enables all disabled turrets\n2. t off - turns off all enabled turrets\n3. t limit - shows how many turrets are still available to you without electricity",
                ["PERMISSION_COMMAND_ERROR"] = "<color=#dd6363>Access error : </color>\nYou don't have enough rights to use this command!",

                ["IS_LIMIT_TRUE_OTHER"] = "The owner of the turret <color=#dd6363>exceeded</color> limit of active turrets <color=#dd6363>WITHOUT ELECTRICITY</color>",
                ["INFORMATION_USER_ON_OTHER"] = "You have successfully <color=#66e28b>enabled</color> the player's turret, the player can still turn on <color=#dd6363>{0}</color> turret",
                ["INFORMATION_USER_OFF_OTHER"] = "You have successfully <color=#dd6363>disabled</color> тthe player's turret, the player is still available for inclusion <color=#dd6363>{0}</color> turret",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["IS_LIMIT_TRUE"] = "У вас <color=#dd6363>превышен</color> лимит активных турелей <color=#dd6363>БЕЗ ЭЛЕКТРИЧЕСТВА</color>",
                ["IS_TURRET_ELECTRIC_TRUE"] = "Данная турель подключена <color=#dd6363>к электричеству</color>, вы не можете использовать рубильник!",
                ["IS_BUILDING_BLOCK_TOGGLE"] = "Вы не можете использовать рубильник в <color=#dd6363>чужом доме</color>",
                ["INFORMATION_USER_ON"] = "Вы успешно <color=#66e28b>включили</color> турель, вам доступно еще для включения <color=#dd6363>{0}</color> турели",
                ["INFORMATION_USER_OFF"] = "Вы успешно <color=#dd6363>выключили</color> турель, вам доступно еще для включения <color=#dd6363>{0}</color> турели",
                ["INFORMATION_MY_LIMIT"] = "Вам <color=#dd6363>доступно</color> для включения <color=#dd6363>{0}</color> турелей",
                ["SYNTAX_COMMAND_ERROR"] = "<color=#dd6363>Ошибка синтаксиса : </color>\nИспользуйте команды :\n1. t on - включает все выключенные\n2. t off - выключает все включенные турели\n3. t limit - показывает сколько вам еще доступно турелей без электричества",
                ["PERMISSION_COMMAND_ERROR"] = "<color=#dd6363>Ошибка доступа : </color>\nУ вас недостаточно прав для использования данной команды!",
                
                ["IS_LIMIT_TRUE_OTHER"] = "У владельца турели <color=#dd6363>превышен</color> лимит активных турелей <color=#dd6363>БЕЗ ЭЛЕКТРИЧЕСТВА</color>",
                ["INFORMATION_USER_ON_OTHER"] = "Вы успешно <color=#66e28b>включили</color> турель игрока, игроку доступно еще для включения <color=#dd6363>{0}</color> турели",
                ["INFORMATION_USER_OFF_OTHER"] = "Вы успешно <color=#dd6363>выключили</color> турель игрока, игрока доступно еще для включения <color=#dd6363>{0}</color> турели",

            }, this, "ru");
            PrintWarning("Logs : #3214412 | Языковой файл загружен успешно"); 
        }
        Boolean API_IS_TURRETLIST(BaseEntity entity)
        {
            if (entity.skinID == 0) return false;
            return TurretList.ContainsKey(entity.skinID);
        }
        ElectricSwitch API_GET_SWITCH(BasePlayer player, BaseEntity turret) => GetSwitchForTurret(turret);
        object OnSwitchToggle(IOEntity entity, BasePlayer player)
        {
            if (entity == null || player == null || entity.skinID == 0) return null;

            if (IsRaidBlocked(player))
                return false;
            
            ElectricSwitch Switch = entity as ElectricSwitch;
            if (Switch == null) return null;

            if (!player.IsBuildingAuthed())
            {
                SendChat(GetLang("IS_BUILDING_BLOCK_TOGGLE", player.UserIDString), player);
                return false;
            }

            if (Switch.HasFlag(BaseEntity.Flags.On))
            {
                TurretToggle(player, Switch);
                return null;
            }

            if (IsTurretElectricalTurned(Switch))
            {
                SendChat(GetLang("IS_TURRET_ELECTRIC_TRUE", player.UserIDString), player);
                return false;
            }

            if (config.LimitController.UseLimitControll)
            {
                UInt64 ID = 0;
                if (config.LimitController.typeLimiter == TypeLimiter.Building && player.GetBuildingPrivilege() != null)
                {
                    ID = player.GetBuildingPrivilege().buildingID;
                    UInt64 IDTurret = Switch.skinID;
                    if (TurretList.ContainsKey(IDTurret))
                    {
                        ControllerInformation controller = TurretList[IDTurret].FirstOrDefault(x => x.electricSwitch == Switch);
                        if (controller == null) return null;

                        controller.BuildingID = ID;
                    }
                }
		   		 		  						  	   		  		 			  		 			  			 		  		  
                // ["IS_LIMIT_TRUE_OTHER"] = "У владельца турели <color=#dd6363>превышен</color> лимит активных турелей <color=#dd6363>БЕЗ ЭЛЕКТРИЧЕСТВА</color>",
                // ["INFORMATION_USER_ON_OTHER"] = "Вы успешно <color=#66e28b>включили</color> турель игрока, игроку доступно еще для включения <color=#dd6363>{0}</color> турели",
                // ["INFORMATION_USER_OFF_OTHER"] = "Вы успешно <color=#dd6363>выключили</color> турель игрока, игрока доступно еще для включения <color=#dd6363>{0}</color> турели",
              
                if (IsLimitPlayer(Switch.OwnerID, ID))
                {
                    SendChat(GetLang(Switch.OwnerID != player.userID ? "IS_LIMIT_TRUE_OTHER" : "IS_LIMIT_TRUE", player.UserIDString), player);
                    return false;
                }
            }

            TurretToggle(player, Switch);
            return null;
        }
        void OnServerInitialized()
        {
            ImmortalProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            ImmortalProtection.name = "TurretsSwitchProtection";
            ImmortalProtection.Add(1);

            foreach (String Permissions in config.LimitController.PermissionsLimits.Keys)
                permission.RegisterPermission(Permissions, this);

            permission.RegisterPermission(PermissionTurnAllTurretsOn, this);
            permission.RegisterPermission(PermissionTurnAllTurretsOff, this);

            NextTick(InitializeData);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        
        
        Boolean API_IS_TURRETLIST(UInt64 ID)
        {
            if (ID == 0) return false;
            return TurretList.ContainsKey(ID);
        }
        private const String SwitchPrefab = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";

            }
}


// --- End of file: IQTurret.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RockEvent.cs ---
// --- Original Local Path: RockEvent.cs ---

﻿using System;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;

///Скачано с дискорд сервера Rust Edit [PRO+]
///discord.gg/9vyTXsJyKR

namespace Oxide.Plugins
{
    [Info("RockEvent", "Drop Dead & Deversive", "1.0.5")]
    public class RockEvent : RustPlugin
    {
        [PluginReference] private Plugin ComponentsEvent;

        bool EventHasStart = false;
        string WorkLayer = "RockEvent.Main";
        DateTime canceldate;
        int count;
        int allcount;
        private List<BaseEntity> SpawnedStones = new List<BaseEntity>();
        private HashSet<Tuple<Vector3, Quaternion>> _spawnData = new HashSet<Tuple<Vector3, Quaternion>>();
        private const int ScanHeight = 100;
        private static int GetBlockMask => LayerMask.GetMask("Construction", "Prevent Building", "Water");
        private static bool MaskIsBlocked(int mask) => GetBlockMask == (GetBlockMask | (1 << mask));
        private Dictionary<MonumentInfo, float> monuments { get; set; } = new Dictionary<MonumentInfo, float>();

        #region config

        private PluginConfig cfg;

        public class PluginConfig
        {
            [JsonProperty("Основные настройки")]
            public Settings MainSettings = new Settings();
            [JsonProperty("Настройки выигрышей")]
            public AccesSets AccesSettings = new AccesSets();
            [JsonProperty("Дополнительные настройки")]
            public AdditionalSettings AddSettings = new AdditionalSettings();

            public class Settings
            {
                [JsonProperty("Включить автоматичесский старт ивента?")]
                public bool AutoStartEvent = true;
                [JsonProperty("Включить ли минимальное количество игроков для старта ивента?")]
                public bool MinPlayers = true;
                [JsonProperty("Минимальное количество игроков для старта ивента")]
                public int MinPlayersCount = 5;
                [JsonProperty("Время для начала ивента после старта сервера, перезагрузки плагина (первый раз)")]
                public float FirstStartTime = 300f;
                [JsonProperty("Время для начала ивента в последующие разы (второй, третий и тд)")]
                public float RepeatTime = 86400f;
                [JsonProperty("Время до конца ивента (в минутах)")]
                public double EventDuration = 60.0;
            }
            public class AccesSets
            {
                [JsonProperty("Название пермишна для использования команды /rockevent (с приставкой RockEvent)")]
                public string StartPermission = "RockEvent.Use";
            }
            public class AdditionalSettings
            {
                [JsonProperty("Цвет выделения текста в интерфейсе")]
                public string Color = "#8e6874";
            }
        }

        private void Init()
        {
            cfg = Config.ReadObject<PluginConfig>();
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig(), true);
        }

        #endregion

        #region Hooks

        void Unload()
        {
            StopEvent();
            InvokeHandler.Instance.CancelInvoke(StartEvent);
            InvokeHandler.Instance.CancelInvoke(UpdateUI);
            InvokeHandler.Instance.CancelInvoke(SpawnStone);
            foreach (var player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, WorkLayer);
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(cfg.AccesSettings.StartPermission, this);
            if (cfg.MainSettings.AutoStartEvent) InvokeHandler.Instance.InvokeRepeating(StartEvent, cfg.MainSettings.FirstStartTime, cfg.MainSettings.RepeatTime);
            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);

            _spawnData.Clear();
            SpawnedStones.Clear();
            GeneratePositions();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsNpc) return;
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            if (EventHasStart)
            {
                InitializeUI(player);
            }
        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (SpawnedStones.Contains(entity))
            {
                allcount -= 1;
                SpawnedStones.Remove(entity);
            }
        }

        #endregion

        #region API

        [HookMethod("RockEventIsStart")]
        public object RockEventIsStart()
        {
            if (EventHasStart) return "";
            else return null;
        }

        bool ComponentsEventIsStart()
        {
            var result = ComponentsEvent?.Call("ComponentsEventIsStart");
            if (result != null) return true;
            else return false;
        }

        #endregion

        #region Methods

        void StartEvent()
        {
            if (EventHasStart == true) return;

            if (ComponentsEventIsStart() == true)
            {
                Puts("Невозможно начать ивент так как в данный момент запущен ивент \"Фарм компонентов\"");
                EventLog("Невозможно начать ивент так как в данный момент запущен ивент \"Фарм компонентов\"");
                return;
            }

            EventHasStart = true;
            if (cfg.MainSettings.MinPlayers == true)
            {
                if (BasePlayer.activePlayerList.Count < cfg.MainSettings.MinPlayersCount)
                {
                    EventLog("Недостаточно игроков для старта ивента \"Двойные камни\"");
                    Puts("Недостаточно игроков для старта ивента \"Двойные камни\"");
                    return;
                }
            }
            canceldate = DateTime.Now.AddMinutes(cfg.MainSettings.EventDuration);
            foreach (var player in BasePlayer.activePlayerList)
            {
                InitializeUI(player);
                player.ChatMessage("Инвент <color=#8e6874>\"Двойной фарм\"</color> успешно начался, фармите как можно больше!");
                //player.ChatMessage(Messages["StartEvent"]);
            }

            InvokeHandler.Instance.InvokeRepeating(UpdateUI, 1f, 1f);
            EventLog("Ивент \"Двойные камни\" успешно запущен и инициализирован!");
            Puts("Ивент \"Двойные камни\" успешно запущен и инициализирован!");

            InvokeHandler.Instance.InvokeRepeating(SpawnStone, 1f, 900f);
        }

        void StopEvent()
        {
            if (EventHasStart == false) return;
            EventHasStart = false;
            InvokeHandler.Instance.CancelInvoke(UpdateUI);
            InvokeHandler.Instance.CancelInvoke(SpawnStone);
            EventLog("Ивент \"Двойные камни\" остановлен или закончился!");
            Puts("Ивент \"Двойные камни\" остановлен или закончился!");
            foreach (var player in BasePlayer.activePlayerList) 
            {
                CuiHelper.DestroyUi(player, WorkLayer);
                player.ChatMessage("Инвент <color=#8e6874>\"Двойной фарм\"</color> успешно завершился, спасибо всем за участие!");
            }

            Puts($"Удалено: {allcount} камней");
            foreach (var entity in SpawnedStones)
                if (!entity.IsDestroyed) entity.AdminKill();

            _spawnData.Clear();
            SpawnedStones.Clear();
            count = 0;
            allcount = 0;
        }

        void UpdateUI()
        {
            if (EventHasStart == false) return;

            TimeSpan timetocancel = DateTime.Now - canceldate;
            if (timetocancel.ToString("mm\\:ss") == "00:00")
            {
                StopEvent();
                return;
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "time");
                var container = new CuiElementContainer();
                container.Add(new CuiElement
                {
                    Parent = WorkLayer,
                    Name = "time",
                    FadeOut = 0.1f,
                    Components =
                    {
                        new CuiTextComponent {  Text = $"[{timetocancel.ToString("mm\\:ss")}]", Align = TextAnchor.UpperLeft, FontSize = 12, Font = "RobotoCondensed-bold.ttf" },
                        new CuiRectTransformComponent {AnchorMin = "0.3214282 0.2399999", AnchorMax = "0.4595238 0.9066674"},
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "0.5 0.5" }
                    }
                });
                CuiHelper.AddUi(player, container);
            }
        }

        private void GeneratePositions()
        {
            _spawnData.Clear();
            var generationSuccess = 0;
            var islandSize = ConVar.Server.worldsize / 2;
            for (var i = 0; i < 500 * 6; i++)
            {
                if (generationSuccess >= 500 * 2)
                {
                    break;
                }
                var x = Core.Random.Range(-islandSize, islandSize);
                var z = Core.Random.Range(-islandSize, islandSize);
                var original = new Vector3(x, ScanHeight, z);

                while (IsMonumentPosition(original) || IsOnRoad(original))
                {
                    x = Core.Random.Range(-islandSize, islandSize);
                    z = Core.Random.Range(-islandSize, islandSize);
                    original = new Vector3(x, ScanHeight, z);
                }

                var data = GetClosestValidPosition(original);
                if (data.Item1 != Vector3.zero)
                {
                    _spawnData.Add(data);
                    generationSuccess++;
                }
            }
        }

        private bool IsMonumentPosition(Vector3 target)
        {
            foreach (var monument in monuments)
            {
                if (InRange(monument.Key.transform.position, target, monument.Value))
                {
                    return true;
                }
            }

            return false;
        }
        private void SetupMonuments()
        {
            foreach (var monument in TerrainMeta.Path?.Monuments?.ToArray() ?? UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
            {
                if (string.IsNullOrEmpty(monument.displayPhrase.translated))
                {
                    float size = monument.name.Contains("power_sub") ? 35f : Mathf.Max(monument.Bounds.size.Max(), 75f);
                    monuments[monument] = monument.name.Contains("cave") ? 75f : monument.name.Contains("OilrigAI") ? 150f : size;
                }
                else
                {
                    monuments[monument] = GetMonumentFloat(monument.displayPhrase.translated.TrimEnd());
                }
            }
        }
        private float GetMonumentFloat(string monumentName)
        {
            switch (monumentName)
            {
                case "Abandoned Cabins":
                    return 54f;
                case "Abandoned Supermarket":
                    return 50f;
                case "Airfield":
                    return 200f;
                case "Bandit Camp":
                    return 125f;
                case "Giant Excavator Pit":
                    return 225f;
                case "Harbor":
                    return 150f;
                case "HQM Quarry":
                    return 37.5f;
                case "Large Oil Rig":
                    return 200f;
                case "Launch Site":
                    return 300f;
                case "Lighthouse":
                    return 48f;
                case "Military Tunnel":
                    return 100f;
                case "Mining Outpost":
                    return 45f;
                case "Oil Rig":
                    return 100f;
                case "Outpost":
                    return 250f;
                case "Oxum's Gas Station":
                    return 65f;
                case "Power Plant":
                    return 140f;
                case "Satellite Dish":
                    return 90f;
                case "Sewer Branch":
                    return 100f;
                case "Stone Quarry":
                    return 27.5f;
                case "Sulfur Quarry":
                    return 27.5f;
                case "The Dome":
                    return 70f;
                case "Train Yard":
                    return 150f;
                case "Water Treatment Plant":
                    return 185f;
                case "Water Well":
                    return 24f;
                case "Wild Swamp":
                    return 24f;
            }

            return 300f;
        }

        private static bool InRange(Vector3 a, Vector3 b, float distance, bool ex = true)
        {
            if (!ex)
            {
                return (a - b).sqrMagnitude <= distance * distance;
            }

            return (new Vector3(a.x, 0f, a.z) - new Vector3(b.x, 0f, b.z)).sqrMagnitude <= distance * distance;
        }

        private Tuple<Vector3, Quaternion> GetClosestValidPosition(Vector3 original)
        {
            var target = original - new Vector3(0, 200, 0);
            RaycastHit hitInfo;
            if (Physics.Linecast(original, target, out hitInfo) == false)
            {
                return new Tuple<Vector3, Quaternion>(Vector3.zero, Quaternion.identity);
            }

            var position = hitInfo.point;
            var collider = hitInfo.collider;
            var colliderLayer = 4;
            if (collider != null && collider.gameObject != null)
            {
                colliderLayer = collider.gameObject.layer;
            }

            if (collider == null)
            {
                return new Tuple<Vector3, Quaternion>(Vector3.zero, Quaternion.identity);
            }

            if (MaskIsBlocked(colliderLayer) || colliderLayer != 23)
            {
                return new Tuple<Vector3, Quaternion>(Vector3.zero, Quaternion.identity);
            }

            if (IsValidPosition(position) == false)
            {
                return new Tuple<Vector3, Quaternion>(Vector3.zero, Quaternion.identity);
            }

            var rotation = Quaternion.FromToRotation(Vector3.up, hitInfo.normal) * Quaternion.Euler(Vector3.zero);
            return new Tuple<Vector3, Quaternion>(position, rotation);
        }

        private bool IsValidPosition(Vector3 position)
        {
            var entities = new List<BuildingBlock>();
            Vis.Entities(position, 25, entities);
            return entities.Count == 0;
        }

        bool IsOnRoad(Vector3 target)
        {
            RaycastHit hitInfo;
            if (!Physics.Raycast(target, Vector3.down, out hitInfo, 66f, LayerMask.GetMask("Terrain", "World", "Construction", "Water"), QueryTriggerInteraction.Ignore) || hitInfo.collider == null)
                return false;

            if (hitInfo.collider.name.ToLower().Contains("road"))
                return true;
            return false;
        }

        string RandomStonePrefab()
        {
            var number = Oxide.Core.Random.Range(1, 3);
            if (number == 1) return "assets/bundled/prefabs/autospawn/resource/ores/stone-ore.prefab";
            if (number == 2) return "assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab";
            if (number == 3) return "assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab";

            return "assets/bundled/prefabs/autospawn/resource/ores/stone-ore.prefab";
        }

        void SpawnStone()
        {
            GenerateStones();
            timer.Once(2f, () =>
            {
                Puts($"Сгенерировано: {count} камней, всего за ивент: {allcount}");
                count = 0;
            });
        }

        private int GenerateStones()
        {
            var counter = 0;
            var neededCount = 200;
            for (var i = 0; i < neededCount; i++)
            {
                var spawnData = GetValidSpawnData();
                if (spawnData.Item1 == Vector3.zero)
                {
                    GeneratePositions();
                }
                spawnData = GetValidSpawnData();

                var stone = GameManager.server.CreateEntity(RandomStonePrefab(), spawnData.Item1, spawnData.Item2);
                stone.Spawn();
                Vector3 pos = new Vector3(2, 0, 0);
                var stone2 = GameManager.server.CreateEntity(RandomStonePrefab(), stone.GetNetworkPosition() + pos, stone.GetNetworkRotation());
                stone2.Spawn();

                SpawnedStones.Add(stone);
                SpawnedStones.Add(stone2);
                count++;
                allcount++;
                count++;
                allcount++;
            }
            return counter;
        }



        private Tuple<Vector3, Quaternion> GetValidSpawnData()
        {
            if (!_spawnData.Any())
            {
                return new Tuple<Vector3, Quaternion>(Vector3.zero, Quaternion.identity);
            }
            for (var i = 0; i < 25; i++)
            {
                var number = Core.Random.Range(0, _spawnData.Count);
                var spawnData = _spawnData.ElementAt(number);
                _spawnData.Remove(spawnData);
                if (IsValidPosition(spawnData.Item1))
                    return spawnData;
            }
            return new Tuple<Vector3, Quaternion>(Vector3.zero, Quaternion.identity);
        }

        #endregion

        #region Commands [Команды]

        [ConsoleCommand("rockevent.start")]
        private void ConsoleForcedEventStart(ConsoleSystem.Arg args)
        {
            if (!args.IsAdmin || args.IsClientside) return;
            if (EventHasStart == true) return;

            Puts("Принудительный старт ивента \"Двойные камни\"");
            EventLog("CONSOLE запустил принудительный старт ивента \"Двойные камни\"");

            StartEvent();
        }

        [ConsoleCommand("rockevent.stop")]
        private void ConsoleForcedEventStop(ConsoleSystem.Arg args)
        {
            if (!args.IsAdmin || args.IsClientside) return;
            if (EventHasStart == false) return;
            Puts("Принудительная остановка ивента \"Двойные камни\"");
            EventLog("CONSOLE принудительно остановил ивент \"Двойные камни\"");
            StopEvent();
        }

        [ConsoleCommand("rockevent.ui.close")]
        void ConsoleUIClose(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            if (EventHasStart == false) return;

            CuiHelper.DestroyUi(player, "text");
            CuiHelper.DestroyUi(player, "button");
            CuiHelper.DestroyUi(player, "helptext");

            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                FadeOut = 0.1f,
                Parent = WorkLayer,
                Name = "text",
                Components =
                {
                    new CuiTextComponent { Text = ">", Align = TextAnchor.UpperLeft, FontSize = 12, Font = "RobotoCondensed-regular.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.478572 0.5733339", AnchorMax = "0.5404768 0.9200007"},
                    new CuiOutlineComponent { Color = "0 0 0 0.25", Distance = "0.5 0.5" }
                }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = "rockevent.ui.open", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "text", "button");
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("rockevent.ui.open")]
        void ConsoleUIOpen(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            if (EventHasStart == false) return;

            CuiHelper.DestroyUi(player, "text");
            CuiHelper.DestroyUi(player, "button");

            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Parent = WorkLayer,
                Name = "helptext",
                Components =
                {
                    new CuiTextComponent { Text = $"На карте спавнятся двойные камни, собирайте их пока есть время!", Align = TextAnchor.UpperLeft, FontSize = 12, Font = "RobotoCondensed-regular.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.02380949 0", AnchorMax = "1 0.5866665"},
                    new CuiOutlineComponent { Color = "0 0 0 0.25", Distance = "0.5 0.5" }
                }
            });
            container.Add(new CuiElement
            {
                FadeOut = 0.1f,
                Parent = WorkLayer,
                Name = "text",
                Components =
                {
                    new CuiTextComponent { Text = "x", Align = TextAnchor.UpperLeft, FontSize = 12, Font = "RobotoCondensed-regular.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.478572 0.5733339", AnchorMax = "0.5404768 0.9200007"},
                    new CuiOutlineComponent { Color = "0 0 0 0.25", Distance = "0.5 0.5" }
                }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = "rockevent.ui.close", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "text", "button");
            CuiHelper.AddUi(player, container);
        }

        [ChatCommand("rockevent")]
        void ChatForcedEventHandler(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, cfg.AccesSettings.StartPermission))
                return;

            if (args.Length < 1)
            {
                player.ChatMessage(" <color=#8e6874>/rockevent start</color> - запустить ивент Двойные камни\n <color=#8e6874>/rockevent stop</color> - остановить ивент Двойные камни\n <color=#8e6874>/rockevent tp</color> - телепортироваться к рандомному камню");
                return;
            }

            if (args[0] == "start")
            {
                if (EventHasStart == true)
                {
                    player.ChatMessage(" Ивент <color=#8e6874>Двойные камни</color> уже запущен");
                    return;
                }

                player.ChatMessage(" Вы успешно запустили ивент <color=#8e6874>Двойные камни</color>");
                Puts($"{player.displayName}/{player.userID} запустил принудительный старт ивента \"Двойные камни\"");
                EventLog($"{player.displayName}/{player.userID} запустил принудительный старт ивента \"Двойные камни\"");

                StartEvent();
            }
            if (args[0] == "stop")
            {
                if (EventHasStart == false)
                {
                    player.ChatMessage(" Ивент <color=#8e6874>Двойные камни</color> не был запущен");
                    return;
                }

                player.ChatMessage(" Вы успешно остановили ивент <color=#8e6874>Двойные камни</color>");
                Puts($"{player.displayName}/{player.userID} запустил принудительную остановку ивента \"Двойные камни\"");
                EventLog($"{player.displayName}/{player.userID} запустил принудительную остановку ивента \"Двойные камни\"");

                StopEvent();
            }

            if (args[0] == "tp")
            {
                if (EventHasStart == false)
                {
                    player.ChatMessage(" Ивент <color=#8e6874>Двойные камни</color> не был запущен");
                    return;
                }

                foreach (var entity in SpawnedStones)
                    player.Teleport(entity.transform.position);
            }
        }

        #endregion

        #region Helpers

        void EventLog(string text)
        {
            LogToFile("Events", text, this, true);
        }

        #endregion

        #region UI

        private void InitializeUI(BasePlayer player)
        {
            TimeSpan timetocancel = DateTime.Now - canceldate;

            CuiHelper.DestroyUi(player, WorkLayer);
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "20 -120", OffsetMax = "300 -70" },
                CursorEnabled = false,
            }, "Hud", WorkLayer);

            container.Add(new CuiElement
            {
                Parent = WorkLayer,
                Components =
                {
                    new CuiTextComponent { Text = $"<color={cfg.AddSettings.Color}>Двойной фарм </color> ", Align = TextAnchor.UpperLeft, FontSize = 14, Font = "RobotoCondensed-bold.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.02380949 0", AnchorMax = "0.4380953 0.933334"},
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "0.5 0.5" }
                }
            });
            container.Add(new CuiElement
            {
                Parent = WorkLayer,
                Name = "time",
                FadeOut = 0.1f,
                Components =
                {
                    new CuiTextComponent {  Text = $"[{timetocancel.ToString("mm\\:ss")}]", Align = TextAnchor.UpperLeft, FontSize = 12, Font = "RobotoCondensed-bold.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.3214282 0.2399999", AnchorMax = "0.4595238 0.9066674"},
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "0.5 0.5" }
                }
            });
            container.Add(new CuiElement
            {
                Parent = WorkLayer,
                Name = "helptext",
                Components =
                {
                    new CuiTextComponent { Text = $"На карте спавнятся двойные камни, собирайте их пока есть время!", Align = TextAnchor.UpperLeft, FontSize = 12, Font = "RobotoCondensed-regular.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.02380949 0", AnchorMax = "1 0.5866665"},
                    new CuiOutlineComponent { Color = "0 0 0 0.25", Distance = "0.5 0.5" }
                }
            });

            container.Add(new CuiElement
            {
                FadeOut = 0.1f,
                Parent = WorkLayer,
                Name = "text",
                Components =
                {
                    new CuiTextComponent { Text = "x", Align = TextAnchor.UpperLeft, FontSize = 12, Font = "RobotoCondensed-regular.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.478572 0.5733339", AnchorMax = "0.5404768 0.9200007"},
                    new CuiOutlineComponent { Color = "0 0 0 0.25", Distance = "0.5 0.5" }
                }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = "rockevent.ui.close", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "text", "button");

            CuiHelper.AddUi(player, container);
        }

        #endregion
    }
}

// --- End of file: RockEvent.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CupboardRestrictions.cs ---
// --- Original Local Path: CupboardRestrictions.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CupboardRestrictions", "DylanSMR", "1.0.4", ResourceId = 2020)]
    [Description("Confirms cupboards are only placed on foundations or floors.")]
    public class CupboardRestrictions : RustPlugin
    {
        void Loaded(){
            lang.RegisterMessages(messages, this);
        }

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"MayNotPlace", "You may not place a tool cupboard on anything but a floor/foundation!"},
        };

        void OnEntitySpawned(BaseEntity entity, UnityEngine.GameObject gameObject){
            try {
                if(entity.ToString().Contains("cupboard.tool")) {
                    if(entity.OwnerID == null) return;
                    var player = BasePlayer.FindByID(entity.OwnerID);
                    if(player.IsSleeping() || !player.IsConnected()) return;
                    var onbuildingblock = false;
                        List<BaseEntity> nearby = new List<BaseEntity>();
                        Vis.Entities(entity.transform.position, 1, nearby);
                        foreach (var ent in nearby){
                            if(ent.ShortPrefabName.Contains("cupboard") && nearby.Count == 1){ onbuildingblock = false; break; }
                            if(ent.ToString().Contains("foundation")){
                                List<BaseEntity> nerb = new List<BaseEntity>();
                                Vis.Entities(new Vector3(ent.transform.position.x, ent.transform.position.y + 0.5f, ent.transform.position.z), 1, nerb);
                                foreach(var ent2 in nerb) if(ent2.ToString().Contains("cupboard")) return;
                            }
                        }
                        if(onbuildingblock == false) {
                            SendReply(player, lang.GetMessage("MayNotPlace", this));  
                            entity.KillMessage();
                            player.inventory.GiveItem(ItemManager.CreateByItemID(1257201758, 1));
                            return;
                        }else return;
                }else return;
            }catch(System.Exception) {return;}
        }
    }
}

// --- End of file: CupboardRestrictions.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CobaltLaboratory-1.0.0.cs ---
// --- Original Local Path: CobaltLaboratory-1.0.0.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("N1KTO COMPANY - Cobalt Laboratory", "RustPlugin", "1.0.0")]
    [Description("Автоматическое событие с ботами и кастомным зданием от N1KTO COMPANY")]
    public class CobaltLaboratory : RustPlugin
    {
        #region Fields
        private Configuration config;
        private const string PermissionUse = "cobaltlaboratory.use";
        private const string PermissionAdmin = "cobaltlaboratory.admin";
        private Timer eventTimer;
        private Timer eventDurationTimer;
        private Timer radiationTimer;
        private Timer autoStartCheckTimer;
        private Vector3 eventPosition;
        private bool isEventActive;
        private List<BasePlayer> activeNPCs = new List<BasePlayer>();
        private List<BaseEntity> spawnedEntities = new List<BaseEntity>();
        private StorageContainer lootBox;
        private BaseEntity radiationEntity;
        private float eventEndTime;
        private string mapMarkerID;
        #endregion

        #region Configuration
        class Configuration
        {
            [JsonProperty("Setting up and stopping an event")]
            public EventSettings Event { get; set; }

            [JsonProperty("Configuring notifications")]
            public NotificationSettings Notifications { get; set; }

            [JsonProperty("Setting up radiation in the event area")]
            public RadiationSettings Radiation { get; set; }

            [JsonProperty("Event display on maps")]
            public MapSettings Map { get; set; }

            [JsonProperty("Bot settings")]
            public BotSettings Bots { get; set; }

            [JsonProperty("UI settings")]
            public UISettings UI { get; set; }

            [JsonProperty("Loot settings")]
            public LootSettings Loot { get; set; }

            [JsonProperty("Command settings")]
            public CommandSettings Commands { get; set; }

            public Configuration()
            {
                Event = new EventSettings();
                Notifications = new NotificationSettings();
                Radiation = new RadiationSettings();
                Map = new MapSettings();
                Bots = new BotSettings();
                UI = new UISettings();
                Loot = new LootSettings();
                Commands = new CommandSettings();
            }
        }

        class EventSettings
        {
            [JsonProperty("The minimum number of players to start an event")]
            public int MinPlayers { get; set; }

            [JsonProperty("Time before the start of the event (Minimum in seconds)")]
            public int MinStartTime { get; set; }

            [JsonProperty("Time before the start of the event (Maximum in seconds)")]
            public int MaxStartTime { get; set; }

            [JsonProperty("Enable auto-start at specific time")]
            public bool EnableAutoStart { get; set; }

            [JsonProperty("Auto-start time in seconds")]
            public int AutoStartTime { get; set; }
        }

        class NotificationSettings
        {
            [JsonProperty("Discord WebHook")]
            public string DiscordWebHook { get; set; }

            [JsonProperty("Enable UI Notifications?")]
            public bool EnableUINotifications { get; set; }

            [JsonProperty("Auto hide UI notifications?")]
            public bool AutoHideUI { get; set; }

            [JsonProperty("How long after the show will it hide? (sec)")]
            public float HideDelay { get; set; }
        }

        class RadiationSettings
        {
            [JsonProperty("Turn on radiation?")]
            public bool EnableRadiation { get; set; }

            [JsonProperty("Number of radiation particles")]
            public int RadiationParticles { get; set; }
        }

        class MapSettings
        {
            [JsonProperty("Mark the event on the G card")]
            public bool ShowOnMap { get; set; }

            [JsonProperty("Text for map G")]
            public string MapText { get; set; }
        }

        class BotSettings
        {
            [JsonProperty("Bot types")]
            public List<BotType> Types { get; set; } = new List<BotType>();

            [JsonProperty("Enable night vision")]
            public bool EnableNightVision { get; set; }

            [JsonProperty("Enable flashlights at night")]
            public bool EnableFlashlights { get; set; }

            [JsonProperty("Bot behavior settings")]
            public BotBehavior Behavior { get; set; }

            public BotSettings()
            {
                Types = new List<BotType>
                {
                    new BotType
                    {
                        Name = "Штурмовик",
                        Health = 150,
                        Accuracy = 0.7f,
                        RoamRange = 30,
                        ChaseRange = 50,
                        Equipment = new Equipment
                        {
                            Weapons = new List<string> { "rifle.ak", "pistol.python" },
                            Armor = new List<string> { "metal.facemask", "metal.plate.torso" }
                        }
                    },
                    new BotType
                    {
                        Name = "Снайпер",
                        Health = 100,
                        Accuracy = 0.9f,
                        RoamRange = 50,
                        ChaseRange = 100,
                        Equipment = new Equipment
                        {
                            Weapons = new List<string> { "rifle.bolt", "pistol.revolver" },
                            Armor = new List<string> { "metal.facemask", "roadsign.jacket" }
                        }
                    },
                    new BotType
                    {
                        Name = "Медик",
                        Health = 120,
                        Accuracy = 0.6f,
                        RoamRange = 20,
                        ChaseRange = 30,
                        Equipment = new Equipment
                        {
                            Weapons = new List<string> { "smg.mp5", "pistol.semiauto" },
                            Armor = new List<string> { "coffeecan.helmet", "roadsign.jacket" },
                            Items = new List<string> { "syringe.medical", "bandage" }
                        }
                    }
                };
                Behavior = new BotBehavior();
            }
        }

        class BotType
        {
            [JsonProperty("Bot name")]
            public string Name { get; set; }

            [JsonProperty("Health")]
            public float Health { get; set; }

            [JsonProperty("Accuracy (0.0-1.0)")]
            public float Accuracy { get; set; }

            [JsonProperty("Roam range")]
            public float RoamRange { get; set; }

            [JsonProperty("Chase range")]
            public float ChaseRange { get; set; }

            [JsonProperty("Equipment")]
            public Equipment Equipment { get; set; } = new Equipment();
        }

        class Equipment
        {
            [JsonProperty("Weapons")]
            public List<string> Weapons { get; set; } = new List<string>();

            [JsonProperty("Armor")]
            public List<string> Armor { get; set; } = new List<string>();

            [JsonProperty("Items")]
            public List<string> Items { get; set; } = new List<string>();
        }

        class BotBehavior
        {
            [JsonProperty("Use cover")]
            public bool UseCover { get; set; } = true;

            [JsonProperty("Help wounded allies")]
            public bool HelpAllies { get; set; } = true;

            [JsonProperty("Retreat when low health")]
            public bool RetreatWhenLowHealth { get; set; } = true;

            [JsonProperty("Low health threshold")]
            public float LowHealthThreshold { get; set; } = 0.3f;
        }

        class UISettings
        {
            [JsonProperty("Event timer color")]
            public string TimerColor { get; set; } = "1 1 1 1";

            [JsonProperty("Event notification color")]
            public string NotificationColor { get; set; } = "0.7 0.3 0.3 1";

            [JsonProperty("Show event timer")]
            public bool ShowEventTimer { get; set; } = true;

            [JsonProperty("Show kill feed")]
            public bool ShowKillFeed { get; set; } = true;

            [JsonProperty("Show minimap")]
            public bool ShowMinimap { get; set; } = true;
        }

        class LootSettings
        {
            [JsonProperty("Настройки ящиков")]
            public BoxSettings BoxSettings { get; set; } = new BoxSettings();

            [JsonProperty("Категории лута")]
            public List<LootCategory> Categories { get; set; }

            [JsonProperty("Минимум предметов в ящике")]
            public int MinItemsPerBox { get; set; } = 6;

            [JsonProperty("Максимум предметов в ящике")]
            public int MaxItemsPerBox { get; set; } = 12;

            public LootSettings()
            {
                BoxSettings = new BoxSettings();
                Categories = new List<LootCategory>
                {
                    new LootCategory
                    {
                        Name = "Оружие",
                        Weight = 30,
                        Items = new List<LootItem>
                        {
                            new LootItem { ShortName = "rifle.ak", MinAmount = 1, MaxAmount = 1, Chance = 20, Blueprint = true },
                            new LootItem { ShortName = "rifle.bolt", MinAmount = 1, MaxAmount = 1, Chance = 15, Blueprint = true },
                            new LootItem { ShortName = "rifle.l96", MinAmount = 1, MaxAmount = 1, Chance = 10, Blueprint = true },
                            new LootItem { ShortName = "rifle.lr300", MinAmount = 1, MaxAmount = 1, Chance = 20 },
                            new LootItem { ShortName = "smg.mp5", MinAmount = 1, MaxAmount = 1, Chance = 25 },
                            new LootItem { ShortName = "lmg.m249", MinAmount = 1, MaxAmount = 1, Chance = 5 },
                            new LootItem { ShortName = "rocket.launcher", MinAmount = 1, MaxAmount = 1, Chance = 8, Blueprint = true }
                        }
                    },
                    new LootCategory
                    {
                        Name = "Взрывчатка",
                        Weight = 20,
                        Items = new List<LootItem>
                        {
                            new LootItem { ShortName = "explosive.timed", MinAmount = 1, MaxAmount = 10, Chance = 15 },
                            new LootItem { ShortName = "ammo.rocket.basic", MinAmount = 5, MaxAmount = 15, Chance = 20 },
                            new LootItem { ShortName = "ammo.rocket.hv", MinAmount = 5, MaxAmount = 15, Chance = 15 },
                            new LootItem { ShortName = "ammo.rocket.fire", MinAmount = 5, MaxAmount = 15, Chance = 10 },
                            new LootItem { ShortName = "rocket.launcher", MinAmount = 1, MaxAmount = 1, Chance = 8, Blueprint = true }
                        }
                    },
                    new LootCategory
                    {
                        Name = "Боеприпасы",
                        Weight = 50,
                        Items = new List<LootItem>
                        {
                            new LootItem { ShortName = "ammo.rifle", MinAmount = 120, MaxAmount = 240, Chance = 50 },
                            new LootItem { ShortName = "ammo.rifle.hv", MinAmount = 60, MaxAmount = 120, Chance = 30 },
                            new LootItem { ShortName = "ammo.rifle.explosive", MinAmount = 20, MaxAmount = 40, Chance = 15 },
                            new LootItem { ShortName = "ammo.rocket.basic", MinAmount = 2, MaxAmount = 4, Chance = 10 },
                            new LootItem { ShortName = "ammo.rocket.hv", MinAmount = 2, MaxAmount = 4, Chance = 8 }
                        }
                    },
                    new LootCategory
                    {
                        Name = "Компоненты",
                        Weight = 40,
                        Items = new List<LootItem>
                        {
                            new LootItem { ShortName = "explosives", MinAmount = 20, MaxAmount = 50, Chance = 30 },
                            new LootItem { ShortName = "targeting.computer", MinAmount = 1, MaxAmount = 2, Chance = 20 },
                            new LootItem { ShortName = "rifle.body", MinAmount = 1, MaxAmount = 3, Chance = 40 },
                            new LootItem { ShortName = "tech.trash", MinAmount = 5, MaxAmount = 10, Chance = 50 }
                        }
                    },
                    new LootCategory
                    {
                        Name = "Ресурсы",
                        Weight = 70,
                        Items = new List<LootItem>
                        {
                            new LootItem { ShortName = "sulfur", MinAmount = 2000, MaxAmount = 4000, Chance = 60 },
                            new LootItem { ShortName = "metal.refined", MinAmount = 200, MaxAmount = 500, Chance = 40 },
                            new LootItem { ShortName = "gunpowder", MinAmount = 1000, MaxAmount = 2000, Chance = 50 },
                            new LootItem { ShortName = "metal.fragments", MinAmount = 2000, MaxAmount = 4000, Chance = 60 },
                            new LootItem { ShortName = "charcoal", MinAmount = 2000, MaxAmount = 4000, Chance = 70 }
                        }
                    }
                };
            }
        }

        class BoxSettings
        {
            [JsonProperty("Тип ящика (large.wooden/elite/military/...)")]
            public string BoxType { get; set; } = "box.wooden.large";

            [JsonProperty("Высота спавна ящика над землей")]
            public float BoxHeight { get; set; } = 1.0f;

            [JsonProperty("Можно ли подбирать ящик")]
            public bool IsPickupable { get; set; } = false;

            [JsonProperty("Время жизни ящика (в минутах, 0 = бесконечно)")]
            public float BoxLifetime { get; set; } = 0f;

            [JsonProperty("Защита ящика (0-1000)")]
            public float BoxHealth { get; set; } = 500f;

            [JsonProperty("Создавать несколько ящиков")]
            public bool EnableMultipleBoxes { get; set; } = false;

            [JsonProperty("Минимум ящиков")]
            public int MinBoxes { get; set; } = 1;

            [JsonProperty("Максимум ящиков")]
            public int MaxBoxes { get; set; } = 3;

            [JsonProperty("Радиус спавна ящиков")]
            public float BoxSpawnRadius { get; set; } = 10f;
        }

        class LootCategory
        {
            [JsonProperty("Category name")]
            public string Name { get; set; }

            [JsonProperty("Category weight (higher = more common)")]
            public int Weight { get; set; }

            [JsonProperty("Items in category")]
            public List<LootItem> Items { get; set; } = new List<LootItem>();
        }

        class LootItem
        {
            [JsonProperty("Item shortname")]
            public string ShortName { get; set; }

            [JsonProperty("Minimum amount")]
            public int MinAmount { get; set; }

            [JsonProperty("Maximum amount")]
            public int MaxAmount { get; set; }

            [JsonProperty("Drop chance (0-100)")]
            public float Chance { get; set; }

            [JsonProperty("Is blueprint")]
            public bool Blueprint { get; set; }

            [JsonProperty("Custom skin ID")]
            public ulong SkinID { get; set; }
        }

        class CommandSettings
        {
            [JsonProperty("Основная команда")]
            public string MainCommand { get; set; } = "cobaltlab";

            [JsonProperty("Команда старта")]
            public string StartCommand { get; set; } = "start";

            [JsonProperty("Команда остановки")]
            public string StopCommand { get; set; } = "stop";

            [JsonProperty("Команда статуса")]
            public string StatusCommand { get; set; } = "status";

            [JsonProperty("Команда настройки времени")]
            public string TimeCommand { get; set; } = "time";

            [JsonProperty("Команда настройки вебхука")]
            public string WebhookCommand { get; set; } = "webhook";

            [JsonProperty("Команда автостарта")]
            public string AutoStartCommand { get; set; } = "autostart";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration
            {
                Event = new EventSettings
                {
                    MinPlayers = 0,
                    MinStartTime = 3000,
                    MaxStartTime = 7200
                },
                Notifications = new NotificationSettings
                {
                    DiscordWebHook = "",
                    EnableUINotifications = true,
                    AutoHideUI = true,
                    HideDelay = 15.0f
                },
                Radiation = new RadiationSettings
                {
                    EnableRadiation = true,
                    RadiationParticles = 20
                },
                Map = new MapSettings
                {
                    ShowOnMap = true,
                    MapText = "Cobalt lab"
                },
                Bots = new BotSettings
                {
                    Types = new List<BotType>
                    {
                        new BotType
                        {
                            Name = "Штурмовик",
                            Health = 150,
                            Accuracy = 0.7f,
                            RoamRange = 30,
                            ChaseRange = 50,
                            Equipment = new Equipment
                            {
                                Weapons = new List<string> { "rifle.ak", "pistol.python" },
                                Armor = new List<string> { "metal.facemask", "metal.plate.torso" }
                            }
                        },
                        new BotType
                        {
                            Name = "Снайпер",
                            Health = 100,
                            Accuracy = 0.9f,
                            RoamRange = 50,
                            ChaseRange = 100,
                            Equipment = new Equipment
                            {
                                Weapons = new List<string> { "rifle.bolt", "pistol.revolver" },
                                Armor = new List<string> { "metal.facemask", "roadsign.jacket" }
                            }
                        },
                        new BotType
                        {
                            Name = "Медик",
                            Health = 120,
                            Accuracy = 0.6f,
                            RoamRange = 20,
                            ChaseRange = 30,
                            Equipment = new Equipment
                            {
                                Weapons = new List<string> { "smg.mp5", "pistol.semiauto" },
                                Armor = new List<string> { "coffeecan.helmet", "roadsign.jacket" },
                                Items = new List<string> { "syringe.medical", "bandage" }
                            }
                        }
                    },
                    Behavior = new BotBehavior
                    {
                        UseCover = true,
                        HelpAllies = true,
                        RetreatWhenLowHealth = true,
                        LowHealthThreshold = 0.3f
                    }
                },
                UI = new UISettings
                {
                    TimerColor = "1 1 1 1",
                    NotificationColor = "0.7 0.3 0.3 1",
                    ShowEventTimer = true,
                    ShowKillFeed = true,
                    ShowMinimap = true
                },
                Loot = new LootSettings
                {
                    BoxSettings = new BoxSettings(),
                    Categories = new List<LootCategory>
                    {
                        new LootCategory
                        {
                            Name = "Оружие",
                            Weight = 30,
                            Items = new List<LootItem>
                            {
                                new LootItem { ShortName = "rifle.ak", MinAmount = 1, MaxAmount = 1, Chance = 20, Blueprint = true },
                                new LootItem { ShortName = "rifle.bolt", MinAmount = 1, MaxAmount = 1, Chance = 15, Blueprint = true },
                                new LootItem { ShortName = "rifle.l96", MinAmount = 1, MaxAmount = 1, Chance = 10, Blueprint = true },
                                new LootItem { ShortName = "rifle.lr300", MinAmount = 1, MaxAmount = 1, Chance = 20 },
                                new LootItem { ShortName = "smg.mp5", MinAmount = 1, MaxAmount = 1, Chance = 25 },
                                new LootItem { ShortName = "lmg.m249", MinAmount = 1, MaxAmount = 1, Chance = 5 },
                                new LootItem { ShortName = "rocket.launcher", MinAmount = 1, MaxAmount = 1, Chance = 8, Blueprint = true }
                            }
                        },
                        new LootCategory
                        {
                            Name = "Взрывчатка",
                            Weight = 20,
                            Items = new List<LootItem>
                            {
                                new LootItem { ShortName = "explosive.timed", MinAmount = 1, MaxAmount = 10, Chance = 15 },
                                new LootItem { ShortName = "ammo.rocket.basic", MinAmount = 5, MaxAmount = 15, Chance = 20 },
                                new LootItem { ShortName = "ammo.rocket.hv", MinAmount = 5, MaxAmount = 15, Chance = 15 },
                                new LootItem { ShortName = "ammo.rocket.fire", MinAmount = 5, MaxAmount = 15, Chance = 10 },
                                new LootItem { ShortName = "rocket.launcher", MinAmount = 1, MaxAmount = 1, Chance = 8, Blueprint = true }
                            }
                        },
                        new LootCategory
                        {
                            Name = "Боеприпасы",
                            Weight = 50,
                            Items = new List<LootItem>
                            {
                                new LootItem { ShortName = "ammo.rifle", MinAmount = 120, MaxAmount = 240, Chance = 50 },
                                new LootItem { ShortName = "ammo.rifle.hv", MinAmount = 60, MaxAmount = 120, Chance = 30 },
                                new LootItem { ShortName = "ammo.rifle.explosive", MinAmount = 20, MaxAmount = 40, Chance = 15 },
                                new LootItem { ShortName = "ammo.rocket.basic", MinAmount = 2, MaxAmount = 4, Chance = 10 },
                                new LootItem { ShortName = "ammo.rocket.hv", MinAmount = 2, MaxAmount = 4, Chance = 8 }
                            }
                        },
                        new LootCategory
                        {
                            Name = "Компоненты",
                            Weight = 40,
                            Items = new List<LootItem>
                            {
                                new LootItem { ShortName = "explosives", MinAmount = 20, MaxAmount = 50, Chance = 30 },
                                new LootItem { ShortName = "targeting.computer", MinAmount = 1, MaxAmount = 2, Chance = 20 },
                                new LootItem { ShortName = "rifle.body", MinAmount = 1, MaxAmount = 3, Chance = 40 },
                                new LootItem { ShortName = "tech.trash", MinAmount = 5, MaxAmount = 10, Chance = 50 }
                            }
                        },
                        new LootCategory
                        {
                            Name = "Ресурсы",
                            Weight = 70,
                            Items = new List<LootItem>
                            {
                                new LootItem { ShortName = "sulfur", MinAmount = 2000, MaxAmount = 4000, Chance = 60 },
                                new LootItem { ShortName = "metal.refined", MinAmount = 200, MaxAmount = 500, Chance = 40 },
                                new LootItem { ShortName = "gunpowder", MinAmount = 1000, MaxAmount = 2000, Chance = 50 },
                                new LootItem { ShortName = "metal.fragments", MinAmount = 2000, MaxAmount = 4000, Chance = 60 },
                                new LootItem { ShortName = "charcoal", MinAmount = 2000, MaxAmount = 4000, Chance = 70 }
                            }
                        }
                    }
                },
                Commands = new CommandSettings
                {
                    MainCommand = "cobaltlab",
                    StartCommand = "start",
                    StopCommand = "stop",
                    StatusCommand = "status",
                    TimeCommand = "time",
                    WebhookCommand = "webhook",
                    AutoStartCommand = "autostart"
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
            permission.RegisterPermission(PermissionAdmin, this);
            cmd.AddChatCommand(config.Commands.MainCommand, this, nameof(CmdCobaltLab));

            // Запускаем таймер для проверки автозапуска
            if (config.Event.EnableAutoStart)
            {
                autoStartCheckTimer = timer.Every(60f, CheckAutoStart);
            }
        }

        private void OnServerInitialized(bool initial)
        {
            if (initial)
                ScheduleNextEvent();
        }

        void Unload()
        {
            // Принудительно останавливаем событие перед выгрузкой
            isEventActive = false;
            
            // Очищаем все таймеры
            eventTimer?.Destroy();
            eventDurationTimer?.Destroy();
            radiationTimer?.Destroy();
            autoStartCheckTimer?.Destroy();

            // Очищаем все сущности
            foreach (var npc in activeNPCs.ToList())
            {
                if (npc != null && !npc.IsDestroyed)
                    npc.Kill();
            }
            activeNPCs.Clear();

            foreach (var entity in spawnedEntities.ToList())
            {
                if (entity != null && !entity.IsDestroyed)
                    entity.Kill();
            }
            spawnedEntities.Clear();

            // Очищаем UI у всех игроков
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player != null && player.IsConnected)
                    CuiHelper.DestroyUi(player, "CobaltLabNotification");
            }

            // Очищаем маркер на карте
            RemoveMapMarker();
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var npc = entity as BasePlayer;
            if (npc == null || !activeNPCs.Contains(npc)) return;

            activeNPCs.Remove(npc);
            
            if (info?.InitiatorPlayer != null)
            {
                var killer = info.InitiatorPlayer;
                BroadcastKill(killer, npc.displayName);
            }

            // Если все боты мертвы, завершаем событие
            if (activeNPCs.Count == 0)
            {
                timer.Once(30f, () => StopEvent());
            }
        }
        #endregion

        #region Commands
        [Command("cobaltlab")]
        private void CmdCobaltLab(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionAdmin))
            {
                SendMessage(player, "У вас нет прав на использование этой команды");
                return;
            }

            if (args.Length == 0)
            {
                SendMessage(player, $"Используйте: /{config.Commands.MainCommand} {config.Commands.StartCommand}|{config.Commands.StopCommand}|{config.Commands.StatusCommand}|{config.Commands.TimeCommand}|{config.Commands.WebhookCommand}|{config.Commands.AutoStartCommand}");
                SendMessage(player, $"{config.Commands.StartCommand} [время_в_секундах] - Запустить событие");
                SendMessage(player, $"{config.Commands.StopCommand} - Остановить текущее событие");
                SendMessage(player, $"{config.Commands.StatusCommand} - Показать статус события");
                SendMessage(player, $"{config.Commands.TimeCommand} <min> <max> - Установить интервал появления (в секундах)");
                SendMessage(player, $"{config.Commands.WebhookCommand} <url> - Установить Discord webhook URL");
                SendMessage(player, $"{config.Commands.AutoStartCommand} <время_в_секундах> - Установить время автозапуска");
                SendMessage(player, $"{config.Commands.AutoStartCommand} disable - Отключить автозапуск");
                return;
            }

            switch (args[0].ToLower())
            {
                case var cmd when cmd == config.Commands.StartCommand.ToLower():
                    if (args.Length > 1 && int.TryParse(args[1], out int delay))
                    {
                        if (eventTimer != null) eventTimer.Destroy();
                        eventTimer = timer.Once(delay, StartEvent);
                        SendMessage(player, $"Событие запустится через {delay} секунд");
                    }
                    else
                    {
                        StartEvent();
                    }
                    break;

                case var cmd when cmd == config.Commands.StopCommand.ToLower():
                    StopEvent();
                    SendMessage(player, "Событие остановлено");
                    break;

                case var cmd when cmd == config.Commands.StatusCommand.ToLower():
                    ShowEventStatus(player);
                    if (eventTimer != null)
                    {
                        var nextEvent = config.Event.MinStartTime;
                        SendMessage(player, $"Следующее событие через: {nextEvent} секунд");
                    }
                    break;

                case var cmd when cmd == config.Commands.TimeCommand.ToLower():
                    if (args.Length >= 3 && int.TryParse(args[1], out int min) && int.TryParse(args[2], out int max))
                    {
                        if (min > max)
                        {
                            SendMessage(player, "Минимальное время не может быть больше максимального");
                            return;
                        }

                        config.Event.MinStartTime = min;
                        config.Event.MaxStartTime = max;
                        SaveConfig();
                        
                        SendMessage(player, $"Интервал появления установлен: {min}-{max} секунд");
                        
                        ScheduleNextEvent();
                    }
                    else
                    {
                        SendMessage(player, $"Используйте: /{config.Commands.MainCommand} {config.Commands.TimeCommand} <min> <max>");
                    }
                    break;

                case var cmd when cmd == config.Commands.WebhookCommand.ToLower():
                    if (args.Length >= 2)
                    {
                        string url = args[1];
                        config.Notifications.DiscordWebHook = url;
                        SaveConfig();
                        
                        SendDiscordMessage(":white_check_mark: **Webhook успешно настроен!**");
                        SendMessage(player, "Discord webhook URL обновлен и протестирован");
                    }
                    else
                    {
                        SendMessage(player, $"Используйте: /{config.Commands.MainCommand} {config.Commands.WebhookCommand} <url>");
                    }
                    break;

                case var cmd when cmd == config.Commands.AutoStartCommand.ToLower():
                    if (args.Length >= 2)
                    {
                        if (args[1].ToLower() == "disable")
                        {
                            config.Event.EnableAutoStart = false;
                            config.Event.AutoStartTime = 0;
                            SaveConfig();
                            SendMessage(player, "Автозапуск отключен");
                        }
                        else if (int.TryParse(args[1], out int autoStartTime))
                        {
                            config.Event.EnableAutoStart = true;
                            config.Event.AutoStartTime = autoStartTime;
                            SaveConfig();
                            SendMessage(player, $"Время автозапуска установлено на {autoStartTime} секунд");
                        }
                        else
                        {
                            SendMessage(player, $"Используйте: /{config.Commands.MainCommand} {config.Commands.AutoStartCommand} <время_в_секундах> или disable");
                        }
                    }
                    else
                    {
                        SendMessage(player, $"Используйте: /{config.Commands.MainCommand} {config.Commands.AutoStartCommand} <время_в_секундах> или disable");
                    }
                    break;

                default:
                    SendMessage(player, $"Неизвестная команда. Используйте: /{config.Commands.MainCommand} {config.Commands.StartCommand}|{config.Commands.StopCommand}|{config.Commands.StatusCommand}|{config.Commands.TimeCommand}|{config.Commands.WebhookCommand}|{config.Commands.AutoStartCommand}");
                    break;
            }
        }
        #endregion

        #region Core Methods
        private void ScheduleNextEvent()
        {
            if (eventTimer != null) eventTimer.Destroy();
            
            float delay = UnityEngine.Random.Range(config.Event.MinStartTime, config.Event.MaxStartTime);
            eventTimer = timer.Once(delay, StartEvent);
        }

        private void StartEvent()
        {
            if (isEventActive) return;
            if (BasePlayer.activePlayerList.Count < config.Event.MinPlayers) return;

            isEventActive = true;
            eventEndTime = Time.time + 900f; // 15 минут на событие
            
            FindEventPosition();
            SpawnBuilding();
            SpawnNPCs();
            CreateLootBox();
            
            if (config.Radiation.EnableRadiation)
                CreateRadiation();

            if (config.Map.ShowOnMap)
                CreateMapMarker();

            // Запускаем таймер события
            eventDurationTimer = timer.Once(900f, () => StopEvent());

            BroadcastEventStart();
        }

        private void StopEvent()
        {
            if (!isEventActive) return;

            // Отправляем сообщение в Discord
            var message = ":stop_sign: **Событие Cobalt Laboratory завершено!**";
            if (activeNPCs.Count == 0)
                message += "\nВсе боты были уничтожены!";
            SendDiscordMessage(message);

            CleanupEvent();
            ScheduleNextEvent();
        }

        private void CleanupEvent()
        {
            isEventActive = false;
            
            // Очищаем таймеры безопасно
            if (radiationTimer != null && !radiationTimer.Destroyed)
            {
                radiationTimer.Destroy();
                radiationTimer = null;
            }

            if (eventDurationTimer != null && !eventDurationTimer.Destroyed)
            {
                eventDurationTimer.Destroy();
                eventDurationTimer = null;
            }

            if (eventTimer != null && !eventTimer.Destroyed)
            {
                eventTimer.Destroy();
                eventTimer = null;
            }

            // Очищаем сущности с проверками
            if (activeNPCs != null)
            {
                foreach (var npc in activeNPCs.ToList())
                {
                    try
                    {
                        if (npc != null && !npc.IsDestroyed)
                        {
                            npc.Kill();
                            PrintWarning($"Удален бот: {npc.displayName}");
                        }
                    }
                    catch (Exception ex)
                    {
                        PrintError($"Ошибка при удалении бота: {ex.Message}");
                    }
                }
                activeNPCs.Clear();
            }

            if (spawnedEntities != null)
            {
                foreach (var entity in spawnedEntities.ToList())
                {
                    try
                    {
                        if (entity != null && !entity.IsDestroyed)
                        {
                            entity.Kill();
                            PrintWarning($"Удалена сущность: {entity.ShortPrefabName}");
                        }
                    }
                    catch (Exception ex)
                    {
                        PrintError($"Ошибка при удалении сущности: {ex.Message}");
                    }
                }
                spawnedEntities.Clear();
            }

            // Очищаем UI у всех игроков безопасно
            foreach (var player in BasePlayer.activePlayerList.ToList())
            {
                try
                {
                    if (player != null && player.IsConnected)
                    {
                        CuiHelper.DestroyUi(player, "CobaltLabNotification");
                        CuiHelper.DestroyUi(player, "CobaltLabMinimap");
                        CuiHelper.DestroyUi(player, "CobaltLabCompass");
                    }
                }
                catch (Exception ex)
                {
                    PrintError($"Ошибка при очистке UI у игрока {player?.displayName}: {ex.Message}");
                }
            }

            // Очищаем маркер на карте
            RemoveMapMarker();

            // Сбрасываем переменные
            eventPosition = Vector3.zero;
            lootBox = null;
            radiationEntity = null;
            eventEndTime = 0f;
            
            PrintWarning("Событие успешно очищено");
        }

        private void FindEventPosition()
        {
            var attempts = 0;
            const int maxAttempts = 100;
            const float minDistanceFromMonument = 50f;
            const float maxDistanceFromMonument = 150f;
            
            while (attempts < maxAttempts)
            {
                // Получаем случайную позицию на карте (исключая края)
                var randomPos = TerrainMeta.Position + new Vector3(
                    UnityEngine.Random.Range(TerrainMeta.Size.x * 0.2f, TerrainMeta.Size.x * 0.8f),
                    0f,
                    UnityEngine.Random.Range(TerrainMeta.Size.z * 0.2f, TerrainMeta.Size.z * 0.8f)
                );

                // Получаем высоту в этой точке
                var height = TerrainMeta.HeightMap.GetHeight(randomPos);
                randomPos.y = height;

                // Проверяем, что позиция не в воде
                if (WaterLevel.GetWaterDepth(randomPos, true, true, null) > 0.1f)
                {
                    attempts++;
                    continue;
                }

                // Проверяем уклон поверхности
                if (TerrainMeta.HeightMap.GetSlope(randomPos) > 40f)
                {
                    attempts++;
                    continue;
                }

                // Проверяем, что рядом нет построек
                var entities = Physics.OverlapSphere(randomPos, 20f, LayerMask.GetMask("Construction", "Deployed"));
                if (entities.Length > 0)
                {
                    attempts++;
                    continue;
                }

                // Проверяем расстояние до монументов
                bool validPosition = true;
                foreach (var monument in TerrainMeta.Path.Monuments)
                {
                    float distance = Vector3.Distance(randomPos, monument.transform.position);
                    if (distance < minDistanceFromMonument || distance > maxDistanceFromMonument)
                    {
                        validPosition = false;
                        break;
                    }
                }

                if (!validPosition)
                {
                    attempts++;
                    continue;
                }

                // Проверяем, что на этом месте можно строить
                var ray = new Ray(randomPos + new Vector3(0f, 5f, 0f), Vector3.down);
                RaycastHit hit;
                if (Physics.Raycast(ray, out hit, 10f, LayerMask.GetMask("Terrain", "World")))
                {
                    if (hit.GetEntity() == null)
                    {
                        eventPosition = hit.point;
                        PrintWarning($"Найдена подходящая позиция: {eventPosition}");
                        return;
                    }
                }

                attempts++;
            }

            // Если не нашли позицию, используем центр карты
            eventPosition = TerrainMeta.Position + TerrainMeta.Size / 2f;
            eventPosition.y = TerrainMeta.HeightMap.GetHeight(eventPosition);
            PrintWarning($"Используем центр карты как позицию: {eventPosition}");
        }

        private void SpawnBuilding()
        {
            var building = GameManager.server.CreateEntity("assets/prefabs/building core/foundation/foundation.prefab", eventPosition);
            if (building == null) return;
            
            building.Spawn();
            spawnedEntities.Add(building);
        }

        private void SpawnNPCs()
        {
            if (config?.Bots?.Types == null)
            {
                PrintError("Ошибка: Конфигурация ботов отсутствует");
                return;
            }

            foreach (var botType in config.Bots.Types)
            {
                try
                {
                    if (string.IsNullOrEmpty(botType?.Name))
                    {
                        PrintError("Ошибка: Имя бота не задано");
                        continue;
                    }

                    // Создаем НПС с правильным префабом
                    var npcPlayer = GameManager.server.CreateEntity("assets/prefabs/npc/scientist/scientistspawn.prefab", 
                        eventPosition + new Vector3(UnityEngine.Random.Range(-5f, 5f), 1f, UnityEngine.Random.Range(-5f, 5f))) as NPCPlayer;
                    
                    if (npcPlayer == null)
                    {
                        PrintError($"Не удалось создать бота {botType.Name}");
                        continue;
                    }

                    // Настраиваем базовые параметры с проверками
                    npcPlayer.displayName = $"Cobalt {botType.Name}";
                    npcPlayer.startHealth = Mathf.Max(1f, botType.Health);
                    npcPlayer.health = npcPlayer.startHealth;
                    npcPlayer._maxHealth = npcPlayer.startHealth;
                    npcPlayer.InitializeHealth(npcPlayer.startHealth, npcPlayer.startHealth);

                    // Спавним НПС
                    npcPlayer.Spawn();

                    // Проверяем валидность инвентаря
                    if (npcPlayer.inventory == null || 
                        npcPlayer.inventory.containerBelt == null || 
                        npcPlayer.inventory.containerWear == null)
                    {
                        PrintError($"Ошибка: Невалидный инвентарь у бота {botType.Name}");
                        npcPlayer.Kill();
                        continue;
                    }

                    // Экипировка бота с проверками
                    if (botType.Equipment?.Weapons != null)
                    {
                        foreach (var weapon in botType.Equipment.Weapons)
                        {
                            if (string.IsNullOrEmpty(weapon)) continue;

                            var item = ItemManager.CreateByName(weapon);
                            if (item != null)
                            {
                                if (!item.MoveToContainer(npcPlayer.inventory.containerBelt))
                                {
                                    PrintError($"Не удалось экипировать оружие {weapon} боту {botType.Name}");
                                    item.Remove();
                                    continue;
                                }

                                // Устанавливаем первое оружие как активное
                                if (npcPlayer.inventory.containerBelt.itemList.Count == 1)
                                {
                                    npcPlayer.UpdateActiveItem(item.uid);
                                }
                            }
                        }
                    }

                    if (botType.Equipment?.Armor != null)
                    {
                        foreach (var armor in botType.Equipment.Armor)
                        {
                            if (string.IsNullOrEmpty(armor)) continue;

                            var item = ItemManager.CreateByName(armor);
                            if (item != null)
                            {
                                if (!item.MoveToContainer(npcPlayer.inventory.containerWear))
                                {
                                    PrintError($"Не удалось экипировать броню {armor} боту {botType.Name}");
                                    item.Remove();
                                }
                            }
                        }
                    }

                    // Включаем фонарик ночью с проверками
                    if (config.Bots.EnableFlashlights && TOD_Sky.Instance != null && TOD_Sky.Instance.IsNight)
                    {
                        var flashlight = ItemManager.CreateByName("flashlight.held");
                        if (flashlight != null)
                        {
                            if (!flashlight.MoveToContainer(npcPlayer.inventory.containerBelt))
                            {
                                PrintError($"Не удалось экипировать фонарик боту {botType.Name}");
                                flashlight.Remove();
                            }
                        }
                    }

                    activeNPCs.Add(npcPlayer);
                    PrintWarning($"Создан бот {botType.Name} в позиции {npcPlayer.transform.position}");
                }
                catch (Exception ex)
                {
                    PrintError($"Ошибка при создании бота {botType?.Name}: {ex.Message}");
                }
            }
        }

        private void CreateLootBox()
        {
            try
            {
                // Определяем количество ящиков
                int boxCount = 1;
                if (config.Loot.BoxSettings.EnableMultipleBoxes)
                {
                    boxCount = UnityEngine.Random.Range(
                        config.Loot.BoxSettings.MinBoxes,
                        config.Loot.BoxSettings.MaxBoxes + 1
                    );
                }

                for (int i = 0; i < boxCount; i++)
                {
                    // Вычисляем позицию для ящика
                    Vector3 boxPosition = eventPosition;
                    if (boxCount > 1)
                    {
                        float angle = (360f / boxCount) * i;
                        float radius = config.Loot.BoxSettings.BoxSpawnRadius;
                        boxPosition += new Vector3(
                            Mathf.Cos(angle * Mathf.Deg2Rad) * radius,
                            config.Loot.BoxSettings.BoxHeight,
                            Mathf.Sin(angle * Mathf.Deg2Rad) * radius
                        );
                    }
                    else
                    {
                        boxPosition += new Vector3(0, config.Loot.BoxSettings.BoxHeight, 0);
                    }

                    // Создаем ящик
                    var box = GameManager.server.CreateEntity(
                        $"assets/prefabs/deployable/{config.Loot.BoxSettings.BoxType}/{config.Loot.BoxSettings.BoxType}.prefab",
                        boxPosition
                    ) as StorageContainer;

                    if (box == null)
                    {
                        PrintError($"Не удалось создать ящик с лутом #{i + 1}");
                        continue;
                    }

                    // Настраиваем параметры ящика
                    box.OwnerID = 0;
                    box.pickup.enabled = config.Loot.BoxSettings.IsPickupable;
                    box.health = config.Loot.BoxSettings.BoxHealth;

                    box.Spawn();
                    spawnedEntities.Add(box);

                    // Если это первый ящик, сохраняем его как основной
                    if (i == 0) lootBox = box;

                    // Устанавливаем время жизни ящика
                    if (config.Loot.BoxSettings.BoxLifetime > 0)
                    {
                        timer.Once(config.Loot.BoxSettings.BoxLifetime * 60f, () =>
                        {
                            if (box != null && !box.IsDestroyed)
                            {
                                box.Kill();
                                SendDiscordMessage($":boom: **Ящик с лутом #{i + 1} исчез!**");
                            }
                        });
                    }

                    // Заполняем ящик лутом
                    timer.Once(0.5f, () =>
                    {
                        if (box != null && !box.IsDestroyed)
                        {
                            PopulateLootBox(box);
                        }
                    });
                }

                // Отправляем сообщение о появлении ящиков
                string boxMessage = boxCount == 1
                    ? ":package: **Появился ящик с лутом!**"
                    : $":package: **Появилось {boxCount} ящиков с лутом!**";
                SendDiscordMessage($"{boxMessage}\nСодержимое будет доступно после уничтожения всех ботов.");
            }
            catch (Exception ex)
            {
                PrintError($"Ошибка при создании ящиков с лутом: {ex.Message}");
            }
        }

        private void PopulateLootBox(StorageContainer box)
        {
            if (box == null || box.inventory == null) return;

            try
            {
                // Очищаем инвентарь ящика
                box.inventory.Clear();

                // Определяем количество предметов
                int itemCount = UnityEngine.Random.Range(config.Loot.MinItemsPerBox, config.Loot.MaxItemsPerBox + 1);

                for (int i = 0; i < itemCount; i++)
                {
                    // Выбираем категорию
                    var category = SelectRandomCategory();
                    if (category == null) continue;

                    // Выбираем предмет из категории
                    var item = SelectRandomItem(category);
                    if (item == null) continue;

                    // Определяем количество
                    int amount = UnityEngine.Random.Range(item.MinAmount, item.MaxAmount + 1);

                    // Создаем предмет
                    Item newItem;
                    if (item.Blueprint)
                    {
                        var itemDef = ItemManager.FindItemDefinition(item.ShortName);
                        if (itemDef != null)
                        {
                            newItem = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0UL);
                            if (newItem != null)
                            {
                                newItem.blueprintTarget = itemDef.itemid;
                                newItem.MoveToContainer(box.inventory);
                            }
                        }
                    }
                    else
                    {
                        newItem = ItemManager.CreateByName(item.ShortName, amount);
                        if (newItem != null)
                        {
                            if (item.SkinID > 0)
                            {
                                newItem.skin = item.SkinID;
                            }
                            newItem.MoveToContainer(box.inventory);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                PrintError($"Ошибка при заполнении ящика лутом: {ex.Message}");
            }
        }

        private LootCategory SelectRandomCategory()
        {
            var totalWeight = config.Loot.Categories.Sum(c => c.Weight);
            var random = UnityEngine.Random.Range(0, totalWeight);
            var currentWeight = 0;

            foreach (var category in config.Loot.Categories)
            {
                currentWeight += category.Weight;
                if (random < currentWeight)
                    return category;
            }

            return config.Loot.Categories.FirstOrDefault();
        }

        private LootItem SelectRandomItem(LootCategory category)
        {
            foreach (var item in category.Items.OrderBy(x => UnityEngine.Random.value))
            {
                if (UnityEngine.Random.Range(0f, 100f) <= item.Chance)
                    return item;
            }

            return category.Items.FirstOrDefault();
        }

        private void CreateRadiation()
        {
            if (radiationEntity != null && !radiationEntity.IsDestroyed)
            {
                radiationEntity.Kill();
                radiationEntity = null;
            }

            // Создаем сферу радиации
            var sphere = GameManager.server.CreateEntity("assets/prefabs/visualization/sphere.prefab", eventPosition);
            if (sphere == null) return;

            sphere.Spawn();
            radiationEntity = sphere;
            spawnedEntities.Add(sphere);

            // Запускаем таймер для радиации
            if (radiationTimer != null)
                radiationTimer.Destroy();

            radiationTimer = timer.Every(1f, () =>
            {
                if (!isEventActive || radiationEntity == null)
                {
                    if (radiationTimer != null)
                    {
                        radiationTimer.Destroy();
                        radiationTimer = null;
                    }
                    return;
                }

                var radiationRange = 20f;
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (player == null || player.IsDestroyed || !player.IsConnected) continue;

                    if (Vector3.Distance(player.transform.position, eventPosition) <= radiationRange)
                    {
                        // Проверяем защиту от радиации
                        float protection = 0f;
                        var clothingMoveSpeed = player.clothingMoveSpeedReduction;
                        if (clothingMoveSpeed > 0)
                        {
                            // Чем больше брони, тем больше защита от радиации
                            protection = Mathf.Clamp01(clothingMoveSpeed / 0.5f);
                        }

                        // Применяем радиацию с учетом защиты
                        float radiationAmount = config.Radiation.RadiationParticles * (1f - protection);
                        if (radiationAmount > 0)
                        {
                            player.metabolism.radiation_poison.Add(radiationAmount);
                        }
                    }
                }
            });
        }

        private void CreateMapMarker()
        {
            if (!string.IsNullOrEmpty(mapMarkerID))
                RemoveMapMarker();

            mapMarkerID = $"cobaltlab_{eventPosition.x}_{eventPosition.z}";

            // Создаем маркер на карте
            rust.RunServerCommand($"marker.add {mapMarkerID} {eventPosition.x} {eventPosition.y} {eventPosition.z} 1 {config.Map.MapText}");
            PrintWarning($"Создан маркер на карте: {mapMarkerID} в позиции {eventPosition}");
        }

        private void RemoveMapMarker()
        {
            if (!string.IsNullOrEmpty(mapMarkerID))
            {
                rust.RunServerCommand($"marker.remove {mapMarkerID}");
                mapMarkerID = null;
            }
        }

        private void BroadcastEventStart()
        {
            var message = "Событие Cobalt Laboratory началось!";
            
            // Отправляем в чат
            foreach (var player in BasePlayer.activePlayerList)
                SendMessage(player, message);

            // Отправляем в Discord с эмбедом
            var discordMessage = $":radioactive: **{message}**\n\nПриходите за лутом и сразитесь с ботами!\nСобытие будет активно 15 минут.";
            SendDiscordMessage(discordMessage);
        }

        private void ShowEventStatus(BasePlayer player)
        {
            string status = isEventActive ? "активно" : "неактивно";
            SendMessage(player, $"Событие сейчас {status}");
        }

        private void SendMessage(BasePlayer player, string message)
        {
            if (config.Notifications.EnableUINotifications)
                CreateUI(player, message);
            else
                player.ChatMessage(message);
        }

        private void CreateUI(BasePlayer player, string message)
        {
            if (player == null || !player.IsConnected) return;

            try
            {
                CuiHelper.DestroyUi(player, "CobaltLabNotification");
                CuiHelper.DestroyUi(player, "CobaltLabMinimap");
                CuiHelper.DestroyUi(player, "CobaltLabCompass");

                var elements = new CuiElementContainer();
                
                // Основная панель
                elements.Add(new CuiElement
                {
                    Parent = "Hud",
                    Components = 
                    {
                        new CuiImageComponent { Color = config.UI.NotificationColor },
                        new CuiRectTransformComponent { AnchorMin = "0.3 0.8", AnchorMax = "0.7 0.85" }
                    },
                    Name = "CobaltLabNotification"
                });

                // Текст сообщения
                elements.Add(new CuiElement
                {
                    Parent = "CobaltLabNotification",
                    Components = 
                    {
                        new CuiTextComponent 
                        { 
                            Text = message, 
                            FontSize = 14, 
                            Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-bold.ttf"
                        },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });

                // Компас с направлением
                if (config.UI.ShowMinimap && isEventActive)
                {
                    var direction = GetDirectionToEvent(player.transform.position);
                    elements.Add(new CuiElement
                    {
                        Parent = "Hud",
                        Components = 
                        {
                            new CuiTextComponent 
                            { 
                                Text = $"↑ Событие: {direction}м", 
                                FontSize = 12,
                                Align = TextAnchor.MiddleCenter,
                                Color = "1 1 1 1"
                            },
                            new CuiRectTransformComponent { AnchorMin = "0.45 0.95", AnchorMax = "0.55 0.98" }
                        },
                        Name = "CobaltLabCompass"
                    });
                }

                CuiHelper.AddUi(player, elements);
                
                if (config.Notifications.AutoHideUI)
                {
                    timer.Once(config.Notifications.HideDelay, () =>
                    {
                        if (player != null && player.IsConnected)
                        {
                            CuiHelper.DestroyUi(player, "CobaltLabNotification");
                        }
                    });
                }
            }
            catch (Exception ex)
            {
                PrintError($"Ошибка при создании UI для игрока {player.displayName}: {ex.Message}");
            }
        }

        private string GetDirectionToEvent(Vector3 playerPos)
        {
            var delta = eventPosition - playerPos;
            var distance = Mathf.Round(delta.magnitude);
            return $"{distance}";
        }

        private void BroadcastKill(BasePlayer killer, string victimName)
        {
            if (!config.UI.ShowKillFeed) return;

            var message = $"{killer.displayName} уничтожил {victimName}!";

            // Отправляем в чат
            foreach (var player in BasePlayer.activePlayerList)
            {
                SendMessage(player, message);
            }

            // Отправляем в Discord
            var discordMessage = $":skull: **{message}**";
            SendDiscordMessage(discordMessage);
        }

        private void SendDiscordMessage(string message)
        {
            if (string.IsNullOrEmpty(config?.Notifications?.DiscordWebHook))
            {
                PrintWarning("Discord webhook не настроен");
                return;
            }

            try
            {
                var description = $"{message}\n\n";

                if (eventPosition != Vector3.zero)
                {
                    description += $"📍 **Координаты:** X: {Math.Round(eventPosition.x)}, Y: {Math.Round(eventPosition.y)}, Z: {Math.Round(eventPosition.z)}\n" +
                                 $"🏛️ **Ближайший монумент:** {GetNearestMonument()}\n";
                }

                if (message.Contains("Ящик с лутом") && config?.Loot?.Categories != null)
                {
                    description += "\n💎 **Возможный лут:**\n";
                    foreach (var category in config.Loot.Categories)
                    {
                        if (category?.Items == null) continue;

                        var topItems = category.Items
                            .Where(x => x != null)
                            .OrderByDescending(x => x.Chance)
                            .Take(3)
                            .Select(x => $"• {x.ShortName}" + (x.Blueprint ? " (BP)" : ""));

                        description += $"**{category.Name}:** {string.Join(", ", topItems)}\n";
                    }
                }

                // Ограничиваем длину сообщения
                if (description.Length > 2000)
                {
                    description = description.Substring(0, 1997) + "...";
                }

                var payload = new Dictionary<string, object>
                {
                    ["username"] = "N1KTO COMPANY - Cobalt Laboratory",
                    ["embeds"] = new List<Dictionary<string, object>>
                    {
                        new Dictionary<string, object>
                        {
                            ["title"] = "N1KTO COMPANY - Cobalt Laboratory",
                            ["description"] = description,
                            ["color"] = 16711680,
                            ["footer"] = new Dictionary<string, string>
                            {
                                ["text"] = $"Cobalt Laboratory Event • {DateTime.Now:dd.MM.yyyy HH:mm}"
                            }
                        }
                    }
                };

                webrequest.Enqueue(config.Notifications.DiscordWebHook, 
                    JsonConvert.SerializeObject(payload), 
                    (code, response) => 
                    {
                        if (code != 200 && code != 204)
                        {
                            PrintError($"Ошибка отправки в Discord: {code} {response}");
                        }
                        else
                        {
                            PrintWarning("Сообщение успешно отправлено в Discord");
                        }
                    }, 
                    this,
                    Core.Libraries.RequestMethod.POST,
                    new Dictionary<string, string>
                    {
                        ["Content-Type"] = "application/json"
                    });
            }
            catch (Exception ex)
            {
                PrintError($"Ошибка при отправке сообщения в Discord: {ex.Message}");
            }
        }

        private string GetNearestMonument()
        {
            var nearestMonument = "Неизвестно";
            var shortestDistance = float.MaxValue;

            foreach (var monument in TerrainMeta.Path.Monuments)
            {
                var distance = Vector3.Distance(eventPosition, monument.transform.position);
                if (distance < shortestDistance)
                {
                    shortestDistance = distance;
                    nearestMonument = monument.name;
                }
            }

            return $"{nearestMonument} ({Math.Round(shortestDistance)}m)";
        }

        private void CheckAutoStart()
        {
            if (!config.Event.EnableAutoStart || isEventActive) return;

            var currentTime = DateTime.Now;
            var autoStartTime = TimeSpan.FromSeconds(config.Event.AutoStartTime);
            var currentTimeOfDay = currentTime.TimeOfDay;

            // Если текущее время совпадает с временем автозапуска (с погрешностью в 1 минуту)
            if (Math.Abs((currentTimeOfDay - autoStartTime).TotalMinutes) < 1)
            {
                StartEvent();
            }
        }
        #endregion
    }
} 

// --- End of file: CobaltLaboratory-1.0.0.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MenuSystem.cs ---
// --- Original Local Path: MenuSystem.cs ---

using System.Collections.Generic;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("MenuSystem", "Sempai#3239", "1.0.0")]
    class MenuSystem : RustPlugin
    {
        #region Вар
        string Layer = "Menu";

        [PluginReference] Plugin ImageLibrary, OurServers, KitSystem, ShopSystem, WipeSchedule, Leaderboard;

        string Logo = "https://media.discordapp.net/attachments/845902962471075870/999489494044659803/unknown.png?width=676&height=676";
        string Banner = "https://media.discordapp.net/attachments/845902962471075870/999489783644553297/unknown.png";
        #endregion

        #region Кнопки
        Dictionary<string, string> ButtonMenu = new Dictionary<string, string>()
        {
            ["SERVERS"] = "server",
            ["KITS"] = "kit",
            ["SHOP"] = "shop",
            ["WIPE SCHEDULE"] = "wipe",
            ["LEADBOARD"] = "stat"
        };
        #endregion

        #region Хуки
        void OnServerInitialized()
        {
            ImageLibrary.Call("AddImage", Logo, "LogoImage");
            ImageLibrary.Call("AddImage", Banner, "WelcomeBanner");
            ImageLibrary.Call("AddImage", "https://imgur.com/bn9qREd.png", "123");

            foreach (var check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }
            MenuUI(player, "welcome");
        }

        void Unload()
        {
            foreach (var check in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(check, Layer);
        }
        #endregion

        #region Команды
        [ChatCommand("menu")]
        void ChatMenu(BasePlayer player) => MenuUI(player);

        [ChatCommand("server")]
        void ChatServer(BasePlayer player) => MenuUI(player, "server");

        [ChatCommand("kit")]
        void ChatKit(BasePlayer player) => MenuUI(player, "kit");

        [ChatCommand("shop")]
        void ChatShop(BasePlayer player) => MenuUI(player, "shop");

        [ChatCommand("wipe")]
        void ChatWipe(BasePlayer player) => MenuUI(player, "wipe");

        [ChatCommand("stat")]
        void ChatStat(BasePlayer player) => MenuUI(player, "stat");

        [ConsoleCommand("menu")]
        void ConsoleMenu(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            UI(player, args.Args[0]);
        }
        #endregion

        #region Интерфейс
        void MenuUI(BasePlayer player, string name = "")
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9", Material = "assets/content/ui/uibackgroundblur.mat" },
            }, "Overlay", Layer);

            

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.108 0.795", AnchorMax = $"0.185 0.92", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "menu welcome" },
                Text = { Text = "" }
            }, Layer, "Logo");

            container.Add(new CuiElement
            {
                Parent = "Logo",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "LogoImage"), FadeIn = 0.5f },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.031 0.7", AnchorMax = $"0.26 0.8", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"<color=#ee3e61><size=30>TOP PLUGINS</size></color>\n{BasePlayer.activePlayerList.Count()}/{ConVar.Server.maxplayers}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.031 0.045", AnchorMax = $"0.26 0.14", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.5", Close = Layer },
                Text = { Text = "CLOSE", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-bold.ttf" }
            }, Layer);

            float width = 0.2f, height = 0.09f, startxBox = 0.044f, startyBox = 0.655f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in ButtonMenu)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Button = { Color = "1 1 1 0", Command = $"menu {check.Value}" },
                    Text = { Text = check.Key, Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize =30, Font = "robotocondensed-bold.ttf" }
                }, Layer);

                xmin += width;
                if (xmin + width >= 0)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }

            CuiHelper.AddUi(player, container);
            UI(player, name);
        }

        void UI(BasePlayer player, string name)
        {
            DestroyUI(player);
            if (name == "welcome")
                WelcomeUI(player);
            if (name == "server")
                OurServers?.Call("UI_DrawInterface", player);
            if (name == "kit")
                KitSystem?.Call("KitUI", player);
            if (name == "shop")
                ShopSystem?.Call("ShopUI", player);
            if (name == "wipe")
                WipeSchedule?.Call("WipeUI", player);
            if (name == "stat")
                Leaderboard?.Call("LeaderboardUI", player);
        }

        void WelcomeUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Welcome");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = {  AnchorMin = "0.284 0", AnchorMax = "0.952 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.6" },
            }, "Menu", "Welcome");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0.65", AnchorMax = $"1 0.83", OffsetMax = "0 0" },
                Text = { Text = $"WELCOME TO <color=#db8c5a>RUST XYITA</color>\n5X NO BPS SERVER", Align = TextAnchor.MiddleCenter, FontSize = 50, Font = "robotocondensed-regular.ttf" }
            }, "Welcome");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.15 0.4", AnchorMax = $"0.49 0.6", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, "Welcome", "Shop");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.35 0.33", AnchorMax = $"0.65 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Shop", "ImageShop");

            container.Add(new CuiElement
            {
                Parent = "ImageShop",
                Components =
                {
                    new CuiImageComponent { Sprite = "assets/icons/open.png", FadeIn = 0.5f, Color = "0.86 0.55 0.35 1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 10", OffsetMax = "-10 -10" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0.1", AnchorMax = $"1 0.3", OffsetMax = "0 0" },
                Text = { Text = $"SHOP/XYITA", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Shop");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.51 0.4", AnchorMax = $"0.85 0.6", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, "Welcome", "Ds");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.35 0.33", AnchorMax = $"0.65 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Ds", "ImageDs");

            container.Add(new CuiElement
            {
                Parent = "ImageDs",
                Components =
                {
                    new CuiImageComponent { Sprite = "assets/icons/discord 1.png", FadeIn = 0.5f, Color = "0.86 0.55 0.35 1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 10", OffsetMax = "-10 -10" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0.1", AnchorMax = $"1 0.3", OffsetMax = "0 0" },
                Text = { Text = $"DISCORD/XYITA", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Ds");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.03 0.2", AnchorMax = $"0.97 0.35", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, "Welcome", "Banner");

            container.Add(new CuiElement
            {
                Parent = "Banner",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "WelcomeBanner"), FadeIn = 0.5f },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Хелпер
        void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Welcome");
            CuiHelper.DestroyUi(player, "UI_OurServersLayer");
            CuiHelper.DestroyUi(player, "Kit_UI");
            CuiHelper.DestroyUi(player, "Shop_UI");
            CuiHelper.DestroyUi(player, "Wipe_UI");
            CuiHelper.DestroyUi(player, "Leaderboard_UI");
        }
        #endregion
    }
}

// --- End of file: MenuSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/QuickSmelt.cs ---
// --- Original Local Path: QuickSmelt.cs ---

using System;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("QuickSmelt", "Wulf/lukespragg", "1.3.0", ResourceId = 1067)]
    [Description("Increases the speed of the furnace smelting")]

    class QuickSmelt : RustPlugin
    {
        #region Initialization

        const string permAllow = "quicksmelt.allow";

        float byproductModifier;
        int byproductPercent;
        float cookedModifier;
        int cookedPercent;
        int fuelUsageModifier;
        bool overcookMeat;
        bool usePermissions;

        protected override void LoadDefaultConfig()
        {
            // Default is *roughly* x2 production rate
            Config["ByproductModifier"] = byproductModifier = GetConfig("ByproductModifier", 1f);
            Config["ByproductPercent"] = byproductPercent = GetConfig("ByproductPercent", 50);
            Config["FuelUsageModifier"] = fuelUsageModifier = GetConfig("FuelUsageModifier", 1);
            Config["CookedModifier"] = cookedModifier = GetConfig("CookedModifier", 1f);
            Config["CookedPercent"] = cookedPercent = GetConfig("CookedPercent", 100);
            Config["OvercookMeat"] = overcookMeat = GetConfig("OvercookMeat", false);
            Config["UsePermissions"] = usePermissions = GetConfig("UsePermissions", false);

            // Remove old config entries
            Config.Remove("ChancePerConsumption");
            Config.Remove("CharcoalChance");
            Config.Remove("CharcoalChanceModifier");
            Config.Remove("CharcoalProductionModifier");
            Config.Remove("DontOvercookMeat");
            Config.Remove("ProductionModifier");

            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();
            permission.RegisterPermission(permAllow, this);
        }

        void OnServerInitialized()
        {
            // Reset fuel consumption and byproduct amount - fix for previous versions
            var wood = ItemManager.FindItemDefinition("wood");
            var burnable = wood?.GetComponent<ItemModBurnable>();
            if (burnable != null)
            {
                burnable.byproductAmount = 1;
                burnable.byproductChance = 0.5f;
            }

            // Check if meat should be overcooked
            if (overcookMeat) return;

            // Loop through item definitions
            var itemDefinitions = ItemManager.itemList;
            foreach (var item in itemDefinitions)
            {
                // Skip any item definitions other than cooked meat
                if (!item.shortname.Contains(".cooked")) continue;

                // Lower high temperature on item definition to prevent burning
                var cookable = item.GetComponent<ItemModCookable>();
                if (cookable != null) cookable.highTemp = 150;
            }
        }

        void Unload()
        {
            // Loop through item definitions
            var itemDefinitions = ItemManager.itemList;
            foreach (var item in itemDefinitions)
            {
                // Skip any item definitions other than cooked meat
                if (!item.shortname.Contains(".cooked")) continue;

                // Lower high temperature on item definition to prevent burning
                var cookable = item.GetComponent<ItemModCookable>();
                if (cookable != null) cookable.highTemp = 250;
            }
        }

        #endregion

        #region Smelting Magic

        void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            // Check if furnance is usable
            if (oven == null) return;

            // Check if permissions are enabled and player has permission
            if (usePermissions && !permission.UserHasPermission(oven.OwnerID.ToString(), permAllow)) return;

            // Modify the amount of fuel to use
            fuel.amount -= fuelUsageModifier - 1;

            // Modify the amount of byproduct to produce
            burnable.byproductAmount = 1 * (int)byproductModifier;
            burnable.byproductChance = (100 - byproductPercent) / 100f;

            // Loop through furance inventory slots
            for (var i = 0; i < oven.inventorySlots; i++)
            {
                try
                {
                    // Check for and ignore invalid items
                    var slotItem = oven.inventory.GetSlot(i);
                    if (slotItem == null || !slotItem.IsValid()) continue;

                    // Check for and ignore non-cookables
                    var cookable = slotItem.info.GetComponent<ItemModCookable>();
                    if (cookable == null) continue;

                    // Skip already cooked food items
                    if (slotItem.info.shortname.EndsWith(".cooked")) continue;

                    // The chance of consumption is going to result in a 1 or 0
                    var consumptionAmount = (int)Math.Ceiling(cookedModifier * (Random.Range(0f, 1f) <= cookedPercent ? 1 : 0));

                    // Check how many are actually in the furnace, before we try removing too many
                    var inFurnaceAmount = slotItem.amount;
                    if (inFurnaceAmount < consumptionAmount) consumptionAmount = inFurnaceAmount;

                    // Set consumption to however many we can pull from this actual stack
                    consumptionAmount = TakeFromInventorySlot(oven.inventory, slotItem.info.itemid, consumptionAmount, i);

                    // If we took nothing, then... we can't create any
                    if (consumptionAmount <= 0) continue;

                    // Create the item(s) that are now cooked
                    var cookedItem = ItemManager.Create(cookable.becomeOnCooked, cookable.amountOfBecome * consumptionAmount);
                    if (!cookedItem.MoveToContainer(oven.inventory)) cookedItem.Drop(oven.inventory.dropPosition, oven.inventory.dropVelocity);
                }
                catch (InvalidOperationException) { }
            }
        }

        int TakeFromInventorySlot(ItemContainer container, int itemId, int amount, int slot)
        {
            var item = container.GetSlot(slot);
            if (item.info.itemid != itemId) return 0;

            if (item.amount > amount)
            {
                item.MarkDirty();
                item.amount -= amount;
                return amount;
            }

            amount = item.amount;
            item.RemoveFromContainer();
            return amount;
        }

        #endregion

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));
    }
}


// --- End of file: QuickSmelt.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Harvester.cs ---
// --- Original Local Path: Harvester.cs ---

﻿using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info ( "Harvester", "TopPlugin.ru", "1.2.0" )]
    [Description ( "Use a harvester to cut your crops when they fully grow." )]
    public class Harvester : RustPlugin
    {
        public static Harvester Instance { get; private set; }

        public bool IsInitialized { get; set; }

        #region Plugins

        [PluginReference] public Plugin Friends;
        [PluginReference] public Plugin Clans;

        private void RefreshPlugins ()
        {
            if ( Friends == null || !Friends.IsLoaded ) Friends = plugins.Find ( "Friends" );
            if ( Clans == null || !Clans.IsLoaded ) Clans = plugins.Find ( "Clans" );
        }

        #endregion

        #region Overrides

        private void Init ()
        {
            Instance = this;

            InstallPermissions ();
            RefreshPlugins ();
        }
        private void Loaded ()
        {
            if ( !IsInitialized ) return;

            if ( ConfigFile == null ) ConfigFile = new Core.Configuration.DynamicConfigFile ( $"{Manager.ConfigPath}{Path.DirectorySeparatorChar}{Name}.json" );

            CreateBehaviour ();

            InitiateHarvesters ();

            if ( !ConfigFile.Exists () )
            {
                ResetConfig ();

                ConfigFile.WriteObject ( Config );
            }
            else
            {
                try
                {
                    Config = ConfigFile.ReadObject<RootConfig> ();

                    foreach ( var harvester in Config.Harvesters )
                    {
                        HarvesterManagerBehaviour.StartCoroutine ( harvester.RefreshEverything () );
                        var generator = harvester.GetGenerator ();
                        if ( generator != null && harvester.PreviousGeneratorSettings.IsOn ) generator?.TurnOn (); else generator?.TurnOff ();
                    }

                    Puts ( $"Initialized {Config.Harvesters.Count.ToString ( "n0" )} harvester{( Config.Harvesters.Count == 1 ? "" : "s" )}." );

                    RefreshHarvesters ();
                }
                catch ( Exception exception )
                {
                    Puts ( $"Broken configuration: {exception.Message}" );
                }
            }

        }
        private void Unload ()
        {
            RefreshHarvesters ();

            foreach ( var harvester in Config.Harvesters )
            {
                HarvesterManagerBehaviour.StartCoroutine ( harvester.RemoveOutputContainerSkin () );
                harvester.GetGenerator ().TurnOff ();
            }

            Instance = null;
            ServerMgr.Instance.Invoke ( () => ClearBehaviour (), 5f );
        }
        private void OnServerInitialized ()
        {
            IsInitialized = true;

            Loaded ();
        }
        private void OnServerSave ()
        {
            if ( !IsInitialized ) return;
            RefreshHarvesters ();

            foreach ( var harvester in Config.Harvesters.ToArray () ) { harvester.PreviousGeneratorSettings.IsOn = harvester.GetGenerator ().IsOn (); }

            ConfigFile.WriteObject ( Config );

        }
        private bool CanPickupEntity ( BasePlayer player, FuelGenerator entity )
        {
            var harvester = Config.Harvesters.FirstOrDefault ( x => x.GeneratorId == entity.net.ID );
            if ( harvester != null )
            {
                Config.Harvesters.Remove ( harvester );
                RefreshHarvesters ();
            }

            return true;
        }
        private void OnEntityKill ( FuelGenerator entity )
        {
            if ( Config.Harvesters.Any ( x => x.GeneratorId == entity.net.ID ) )
            {
                RefreshHarvesters ();
            }
        }
        private void OnEntityDeath ( FuelGenerator entity, HitInfo info )
        {
            if ( Config.Harvesters.Any ( x => x.GeneratorId == entity.net.ID ) )
            {
                RefreshHarvesters ();
            }
        }
        private void OnServerShutdown ()
        {
            OnServerSave ();
        }
        private void OnPlayerDisconnected ( BasePlayer player, string reason )
        {
            StopEditing ( player.userID );
        }
        private object OnPlayerSleep ( BasePlayer player )
        {
            StopEditing ( player.userID );
            return null;
        }
        private object OnHammerHit ( BasePlayer player, HitInfo info )
        {
            var harvester = ( RootConfig.Harvester )null;
            var planterEntity = info?.HitEntity as PlanterBox;
            var smallGenerator = info?.HitEntity as FuelGenerator;

            if ( smallGenerator != null )
            {
                if ( IsEditing ( player.userID, out harvester ) ) { StopEditing ( player.userID ); if ( harvester != null && harvester.GeneratorId == smallGenerator.net.ID ) return false; }

                if ( Config.Harvesters.Any ( x => x.GeneratorId == smallGenerator.net.ID ) )
                {
                    if ( StartEditing ( player.userID, smallGenerator ) )
                    {
                        var settings = GetIdealSetting ( player.userID );
                        EditorTimer.Add ( player.userID, timer.Once ( settings.EditorTimeout, () => { StopEditing ( player.userID ); } ) );
                        return false;
                    }
                }

                return null;
            }

            if ( IsEditing ( player.userID, out harvester ) )
            {
                if ( harvester == null ) { StopEditing ( player.userID ); return null; }

                var ownerPlayer = BasePlayer.FindByID ( harvester.OwnerPlayerId );
                var isInTeam = ownerPlayer.Team?.members.Contains ( player.userID );

                var isFriends = false;
                var isClan = false;

                try { isFriends = Friends != null && Friends.IsLoaded && ( bool )Friends?.Call ( "AreFriends", player.userID, harvester.OwnerPlayerId ); } catch { }
                try { isClan = Clans != null && Clans.IsLoaded && ( bool )Clans?.Call ( "IsMemberOrAlly", player.userID.ToString (), harvester.OwnerPlayerId.ToString () ); } catch { }

                if ( planterEntity == null )
                {
                    Print ( $"You're not hitting a Planter!", player );
                    return false;
                }

                if ( Config.Harvesters.Any ( x => x.Planters.Any ( y => y.PlanterId == planterEntity.net.ID ) && x != harvester ) )
                {
                    Print ( $"This planter is already linked to a different Harvester!", player );
                    return false;
                }

                var distance = 0f;
                var setting = ( RootConfig.Setting )null;

                if ( !ValidDistance ( harvester.OwnerPlayerId, planterEntity, harvester, out distance, out setting ) )
                {
                    Print ( $"The planter is too far away from the Harvester — {distance.ToString ( "0.0" )}m. It needs to be under or equal to {setting.PlanterDistance}m.", player );
                    return false;
                }

                var planter = harvester.Planters.FirstOrDefault ( x => x.PlanterId == planterEntity.net.ID );
                if ( planter != null )
                {
                    if ( player.userID != harvester.OwnerPlayerId )
                    {
                        //
                        // Check if the owner of the Harvester owns the planter
                        //
                        if ( player.userID != planter.OwnerPlayerId )
                        {
                            if ( planter.OwnerPlayerId == harvester.OwnerPlayerId )
                            {
                                Print ( $"You cannot remove a planter assigned by the owner of this Harvester.", player );
                                return false;
                            }
                        }

                        //
                        // Check if the Harvester owner allows us to do it
                        //
                        if ( ownerPlayer != null )
                        {
                            var allow = harvester.AllowTeamToManage && isInTeam != null && isInTeam.Value;
                            if ( !allow ) allow = harvester.AllowFriendsToManage && isFriends;
                            if ( !allow ) allow = harvester.AllowClanToManage && isClan;
                            if ( !allow )
                            {
                                Print ( $"The owner of the Harvester does not allow you to execute this action.", player );
                                return false;
                            }
                        }
                    }

                    harvester.Planters.Remove ( planter );
                    harvester.RefreshEverything ();

                    Print ( $"You've unlinked this planter from this Harvester! Currently {harvester.Planters.Count.ToString ( "n0" )} out of {( setting.PlantersPerHarvester == -1 ? "unlimited" : setting.PlantersPerHarvester.ToString ( "n0" ) )} planters.", player );
                    OnServerSave ();
                    return false;
                }
                else
                {
                    if ( setting.PlantersPerHarvester != -1 && harvester.Planters.Count >= setting.PlantersPerHarvester )
                    {
                        Print ( $"You've reached the maximum amount of planters for this Harvester.", player );
                        return false;
                    }

                    harvester.Planters.Add ( new RootConfig.Planter ( planterEntity.net.ID, player.userID ) );
                    harvester.RefreshEverything ();

                    Print ( $"You've linked this planter with this Harvester! Currently {harvester.Planters.Count.ToString ( "n0" )} out of {( setting.PlantersPerHarvester == -1 ? "unlimited" : setting.PlantersPerHarvester.ToString ( "n0" ) )} planters.", player );
                    OnServerSave ();
                    return false;
                }
            }

            return null;
        }
        private void OnPluginLoaded ( Plugin name )
        {
            if ( name.Name == "Friends" || name.Name == "Clans" ) RefreshPlugins ();
        }
        private void OnPluginUnloaded ( Plugin name )
        {
            if ( name.Name == "Friends" || name.Name == "Clans" ) RefreshPlugins ();
        }

        private void InitiateHarvesters ()
        {
            timer.Every ( 1f, () =>
            {
                foreach ( var harvester in Config.Harvesters.ToArray () )
                {
                    var generator = harvester.GetGenerator ();

                    if ( generator == null )
                    {
                        HarvesterManagerBehaviour.StartCoroutine ( harvester.RemoveOutputContainerSkin () );
                        RefreshHarvesters ();
                        break;
                    }

                    HarvesterManagerBehaviour.StartCoroutine ( harvester.ApplyOutputContainerSkin () );

                    if ( !harvester.IsGeneratorRunning () || !harvester.HasOutputContainerAssigned () ) { continue; }

                    HarvesterManagerBehaviour.StartCoroutine ( harvester.RefreshPlanterGrowables () );
                }

                HarvesterManagerBehaviour.StartCoroutine ( CheckPlanters () );
            } );
        }

        private void ResetConfig ()
        {
            Config = new RootConfig ();

            Config.Settings.Add ( "admin", new RootConfig.Setting { MaximumHarvesters = -1, PlantersPerHarvester = -1, FuelPerSecond = -1, PlanterDistance = 50, EditorTimeout = 120 } );
            Config.Settings.Add ( "vip", new RootConfig.Setting { MaximumHarvesters = 5, PlantersPerHarvester = 4, FuelPerSecond = 0.01f, PlanterDistance = 35, EditorTimeout = 35 } );
            Config.Settings.Add ( "default", new RootConfig.Setting { MaximumHarvesters = 1, PlantersPerHarvester = 3, FuelPerSecond = 0.02f, PlanterDistance = 15, EditorTimeout = 20 } );
        }

        #endregion

        public void Print ( object message, BasePlayer player = null )
        {
            if ( player == null ) PrintToChat ( $"<color=orange>{Name}</color>: {message}" );
            else PrintToChat ( player, $"<color=orange>{Name}</color> (OY): {message}" );
        }

        public HarvesterManager HarvesterManagerBehaviour { get; private set; }
        private void CreateBehaviour ()
        {
            ClearBehaviour ();

            var gameObject = new GameObject ( "HarvesterManager" );
            HarvesterManagerBehaviour = gameObject.AddComponent<HarvesterManager> ();
        }
        private void ClearBehaviour ()
        {
            if ( HarvesterManagerBehaviour != null )
            {
                UnityEngine.Object.Destroy ( HarvesterManagerBehaviour.gameObject );
            }
        }

        public class HarvesterManager : MonoBehaviour { }

        private IEnumerator CheckPlanters ()
        {
            foreach ( var harvester in Config.Harvesters.ToArray () )
            {
                if ( !harvester.IsGeneratorRunning () && !harvester.HasOutputContainerAssigned () ) continue;

                var growables = harvester.GetPlanterGrowables ();
                if ( growables == null ) yield break;

                foreach ( var growable in growables )
                {
                    var somethingDied = false;

                    switch ( growable.State )
                    {
                        case PlantProperties.State.Ripe:
                            {
                                if ( growable.StageProgressFraction < 1.0f ) continue;

                                ItemManager.CreateByName ( growable.SourceItemDef.shortname, growable.CurrentPickAmount ).MoveToContainer ( harvester.GetOutputContainer ().inventory );
                                growable.ChangeState ( PlantProperties.State.Dying, false );
                                break;
                            }

                        case PlantProperties.State.Dying:
                            {
                                if ( Config.HarvestDyingPlants )
                                {
                                    ItemManager.CreateByName ( "plantfiber", 1 ).MoveToContainer ( harvester.GetOutputContainer ().inventory );

                                    growable.Kill ();
                                    somethingDied = true;
                                }

                                break;
                            }
                    }

                    if ( somethingDied ) { break; }

                    yield return new WaitForSeconds ( 0.5f );
                }

                yield return new WaitForSeconds ( 2 );
            }
        }
        public void RefreshHarvesters ()
        {
            var changed = false;

            Config.Harvesters.RemoveAll ( ( x ) =>
            {
                if ( x.GetGenerator () == null || x.GetGenerator ().IsDead () || x.GetGenerator ().IsDestroyed )
                {
                    if ( IsEditing ( x.OwnerPlayerId ) ) StopEditing ( x.OwnerPlayerId );

                    HarvesterManagerBehaviour.StartCoroutine ( x.RemoveOutputContainerSkin () );
                    changed = true;
                    return true;
                }

                return false;
            } );

            if ( changed ) OnServerSave ();
        }

        private static bool TryGetPlayerView ( BasePlayer player, out Quaternion viewAngle )
        {
            viewAngle = new Quaternion ( 0f, 0f, 0f, 0f );

            var input = player.serverInput;

            if ( input == null )
                return false;
            if ( input.current == null )
                return false;

            viewAngle = Quaternion.Euler ( input.current.aimAngles );
            return true;
        }
        private bool TryGetClosestRayPoint ( Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint )
        {
            Vector3 sourceEye = sourcePos + new Vector3 ( 0f, 1.5f, 0f );
            UnityEngine.Ray ray = new UnityEngine.Ray ( sourceEye, sourceDir * Vector3.forward );

            var hits = UnityEngine.Physics.RaycastAll ( ray );
            var closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;

            foreach ( var hit in hits )
            {
                if ( hit.collider.GetComponentInParent<TriggerBase> () == null && !hit.collider.name.Contains ( "prevent" ) )
                {
                    if ( hit.distance < closestdist )
                    {
                        closestdist = hit.distance;
                        closestEnt = hit.collider;
                        closestHitpoint = hit.point;
                    }
                }
            }

            if ( closestEnt is bool )
                return false;

            return true;
        }
        private bool ValidDistance ( ulong playerId, BaseEntity entity, RootConfig.Harvester harvester, out float distance, out RootConfig.Setting setting )
        {
            setting = GetIdealSetting ( playerId );
            distance = Vector3.Distance ( harvester.GetGenerator ().ServerPosition, entity.ServerPosition );

            return distance <= setting.PlanterDistance;
        }

        #region Permission

        public const string AdminPerm = "harvester.admin";
        public const string UsePerm = "harvester.use";

        private void InstallPermissions ()
        {
            permission.RegisterPermission ( AdminPerm, this );
            permission.RegisterPermission ( UsePerm, this );
        }
        private bool HasPermission ( BasePlayer player, string perm )
        {
            if ( !permission.UserHasPermission ( player.UserIDString, perm ) )
            {
                SendReply ( player, $"You need to have the \"{perm}\" permission to run this command." );
                return false;
            }

            return true;
        }
        private RootConfig.Setting GetIdealSetting ( ulong player )
        {
            return Config.Settings.FirstOrDefault ( x => permission.UserHasGroup ( player.ToString (), x.Key ) ).Value;
        }

        #endregion

        #region Commands

        [ChatCommand ( "allowteamaccess" )]
        private void AllowTeamAccess ( BasePlayer player, string command, string [] args )
        {
            var harvester = ( RootConfig.Harvester )null;

            if ( IsEditing ( player.userID, out harvester ) )
            {
                harvester.AllowTeamToManage = !harvester.AllowTeamToManage;
                Print ( $"You've <color={( harvester.AllowTeamToManage ? "#91D930>enabled" : "#D93E30>disabled" )}</color> Team Access for this harvester.", player );
            }
            else
            {
                Print ( $"You're not editing a Harvester. Please do that first, then retry.", player );
            }
        }

        [ChatCommand ( "allowfriendsaccess" )]
        private void AllowFriendsAccess ( BasePlayer player, string command, string [] args )
        {
            var harvester = ( RootConfig.Harvester )null;

            if ( IsEditing ( player.userID, out harvester ) )
            {
                harvester.AllowFriendsToManage = !harvester.AllowFriendsToManage;
                Print ( $"You've <color={( harvester.AllowFriendsToManage ? "#91D930>enabled" : "#D93E30>disabled" )}</color> Friends Access for this harvester.", player );
            }
            else
            {
                Print ( $"You're not editing a Harvester. Please do that first, then retry.", player );
            }
        }

        [ChatCommand ( "allowclanaccess" )]
        private void AllowClanAccess ( BasePlayer player, string command, string [] args )
        {
            var harvester = ( RootConfig.Harvester )null;

            if ( IsEditing ( player.userID, out harvester ) )
            {
                harvester.AllowClanToManage = !harvester.AllowClanToManage;
                Print ( $"You've <color={( harvester.AllowClanToManage ? "#91D930>enabled" : "#D93E30>disabled" )}</color> Clan Access for this harvester.", player );
            }
            else
            {
                Print ( $"You're not editing a Harvester. Please do that first, then retry.", player );
            }
        }

        [ChatCommand ( "setharvester" )]
        private void SetHarvester ( BasePlayer player, string command, string [] args )
        {
            if ( !HasPermission ( player, UsePerm ) ) return;

            Quaternion currentRot;
            object closestEnt;
            Vector3 closestHitpoint;

            if ( !TryGetPlayerView ( player, out currentRot ) ) return;
            if ( !TryGetClosestRayPoint ( player.transform.position, currentRot, out closestEnt, out closestHitpoint ) ) return;

            var entity = ( closestEnt as Collider )?.gameObject;
            if ( closestEnt == null || entity == null ) return;

            var generator = entity.GetComponent<FuelGenerator> ();
            if ( generator == null )
            {
                Print ( $"You're not looking at a Small Generator!", player );
                return;
            }

            if ( Config.Harvesters.Any ( x => x.GeneratorId == generator.net.ID ) )
            {
                Print ( $"This Harvester has already been set!", player );
                return;
            }

            var setting = GetIdealSetting ( player.userID );
            var harvesters = Config.Harvesters.Count ( x => x.OwnerPlayerId == player.userID );
            if ( setting.MaximumHarvesters != -1 && harvesters >= setting.MaximumHarvesters )
            {
                Print ( $"You've reached the maximum Harvester amount! You've got <color=orange>{harvesters.ToString ( "n0" )}</color> harvester{( harvesters == 1 ? "" : "s" )}.", player );
                return;
            }

            var harvester = new RootConfig.Harvester ( player, generator );
            harvester.BackSettingsUp ();

            generator.outputEnergy = 0;

            Config.Harvesters.Add ( harvester );
            harvesters = Config.Harvesters.Count ( x => x.OwnerPlayerId == player.userID );
            Print ( $"You've set this Harvester! You've got <color=orange>{harvesters.ToString ( "n0" )}</color> out of {( setting.MaximumHarvesters == -1 ? "unlimited" : setting.MaximumHarvesters.ToString ( "n0" ) )} harvester{( setting.MaximumHarvesters == 1 ? "" : "s" )}.", player );

            if ( IsEditing ( player.userID ) ) StopEditing ( player.userID );
            if ( StartEditing ( player.userID, generator ) )
            {
                var settings = GetIdealSetting ( player.userID );
                EditorTimer.Add ( player.userID, timer.Once ( settings.EditorTimeout, () => { StopEditing ( player.userID ); } ) );
            }

            OnServerSave ();
        }

        [ChatCommand ( "unsetharvester" )]
        private void UnsetHarvester ( BasePlayer player, string command, string [] args )
        {
            if ( !HasPermission ( player, UsePerm ) ) return;

            Quaternion currentRot;
            object closestEnt;
            Vector3 closestHitpoint;

            if ( !TryGetPlayerView ( player, out currentRot ) ) return;
            if ( !TryGetClosestRayPoint ( player.transform.position, currentRot, out closestEnt, out closestHitpoint ) ) return;

            var entity = ( closestEnt as Collider )?.gameObject;
            if ( closestEnt == null || entity == null ) return;

            var generator = entity.GetComponent<FuelGenerator> ();
            if ( generator == null )
            {
                Print ( $"You're not looking at a Small Generator!", player );
                return;
            }

            var harvester = Config.Harvesters.FirstOrDefault ( x => x.GeneratorId == generator.net.ID );
            if ( harvester == null )
            {
                Print ( $"This Small Generator is not a Harvester!", player );
                return;
            }
            if ( harvester.OwnerPlayerId != player.userID )
            {
                Print ( $"You cannot perform this action since you're not the owner of this Harvester!", player );
                return;
            }

            harvester.GetGenerator ().TurnOff ();
            harvester.LoadBackupSettings ();
            HarvesterManagerBehaviour.StartCoroutine ( harvester.RemoveOutputContainerSkin () );

            Config.Harvesters.Remove ( harvester );
            StopEditing ( player.userID );

            Print ( $"You've removed this Harvester!", player );
            OnServerSave ();
        }

        [ChatCommand ( "setoutput" )]
        private void SetOutputContainer ( BasePlayer player, string command, string [] args )
        {
            if ( !HasPermission ( player, AdminPerm ) ) return;

            if ( !IsEditing ( player.userID ) )
            {
                Print ( $"You're not editing a Harvester. Please do that first, then retry.", player );
                return;
            }
            var harvester = GetEdit ( player );

            Quaternion currentRot;
            object closestEnt;
            Vector3 closestHitpoint;

            if ( !TryGetPlayerView ( player, out currentRot ) ) return;
            if ( !TryGetClosestRayPoint ( player.transform.position, currentRot, out closestEnt, out closestHitpoint ) ) return;

            var entity = ( closestEnt as Collider )?.gameObject;
            if ( closestEnt == null || entity == null ) return;

            var boxStorage = entity.GetComponent<BoxStorage> ();
            if ( boxStorage == null )
            {
                Print ( $"You're not looking at a Box Storage!", player );
                return;
            }
            if ( boxStorage.net.ID == harvester.OutputContainerId )
            {
                Print ( $"You've already set this Box Storage for this Harvester!", player );
                return;
            }
            if ( Config.Harvesters.Any ( x => x.OutputContainerId == boxStorage.net.ID ) )
            {
                Print ( $"This storage is already linked with an another Harvester!", player );
                return;
            }
            if ( player.userID != harvester.OwnerPlayerId )
            {
                Print ( $"You're not the owner of this Harvester!", player );
                StopEditing ( player.userID );
                return;
            }

            harvester.RemoveOutputContainerSkin ();

            harvester.OutputContainerId = boxStorage.net.ID;
            harvester.PreviousOutputContainerSkinId = boxStorage.skinID;

            harvester.RefreshEverything ();
            harvester.ApplyOutputContainerSkin ();

            Print ( $"You've set the output container for this Harvester!", player );
            OnServerSave ();
        }

        [ChatCommand ( "unsetoutput" )]
        private void UnsetOutputContainer ( BasePlayer player, string command, string [] args )
        {
            if ( !HasPermission ( player, AdminPerm ) ) return;

            if ( !IsEditing ( player.userID ) )
            {
                Print ( $"You're not editing a Harvester. Please do that first, then retry.", player );
                return;
            }
            var harvester = GetEdit ( player );

            if ( player.userID != harvester.OwnerPlayerId )
            {
                Print ( $"You're not the owner of this Harvester!", player );
                StopEditing ( player.userID );
                return;
            }

            harvester.RemoveOutputContainerSkin ();
            harvester.OutputContainerId = 0;
            harvester.RefreshEverything ();

            Print ( $"You've removed the output container for this Harvester!", player );
            OnServerSave ();
        }

        #endregion

        #region Editor 

        public bool StartEditing ( ulong playerId, FuelGenerator generator )
        {
            if ( Editor.ContainsKey ( playerId ) )
            {
                Print ( $"You're already editing a Harvester!" );
                return false;
            }

            var harvester = Config.Harvesters.FirstOrDefault ( x => x.GeneratorId == generator.net.ID );
            var ownerPlayer = BasePlayer.FindByID ( harvester.OwnerPlayerId );
            if ( harvester.OwnerPlayerId != playerId )
            {
                var isInTeam = ownerPlayer?.Team?.members.Contains ( playerId );
                var isFriends = false;
                var isClan = false;
                try { isFriends = Friends != null && Friends.IsLoaded && ( bool )Friends?.Call ( "AreFriends", playerId, harvester.OwnerPlayerId ); } catch { }
                try { isClan = Clans != null && Clans.IsLoaded && ( bool )Clans?.Call ( "IsMemberOrAlly", playerId.ToString (), harvester.OwnerPlayerId.ToString () ); } catch { }

                var allow = harvester.AllowTeamToManage && isInTeam != null && isInTeam.Value;
                if ( !allow ) allow = harvester.AllowFriendsToManage && isFriends;
                if ( !allow ) allow = harvester.AllowClanToManage && isClan;
                if ( !allow ) return false;
            }

            Editor.Add ( playerId, generator.net.ID );

            Print ( $"You started editing a Harvester.", BasePlayer.FindByID ( playerId ) );
            return true;
        }
        public bool StopEditing ( ulong playerId )
        {
            if ( !Editor.ContainsKey ( playerId ) )
            {
                // Print ( $"You're not editing a Harvester!" );
                return false;
            }

            if ( EditorTimer.ContainsKey ( playerId ) ) { EditorTimer [ playerId ].Destroy (); EditorTimer.Remove ( playerId ); }

            Editor.Remove ( playerId );
            Print ( $"You stopped editing a Harvester.", BasePlayer.FindByID ( playerId ) );
            return true;
        }
        public bool IsEditing ( ulong playerId )
        {
            return Editor.ContainsKey ( playerId );
        }
        public bool IsEditing ( ulong playerId, out RootConfig.Harvester harvester )
        {
            harvester = GetEdit ( playerId );
            return IsEditing ( playerId );
        }
        public RootConfig.Harvester GetEdit ( ulong playerId )
        {
            if ( !IsEditing ( playerId ) ) return null;

            return Config.Harvesters.FirstOrDefault ( x => x.GeneratorId == Editor [ playerId ] );
        }
        public RootConfig.Harvester GetEdit ( BasePlayer player )
        {
            return GetEdit ( player.userID );
        }

        #endregion

        #region Config

        public Core.Configuration.DynamicConfigFile ConfigFile { get; set; }
        public new RootConfig Config { get; set; } = new RootConfig ();
        public Dictionary<ulong, uint> Editor { get; set; } = new Dictionary<ulong, uint> ();
        public Dictionary<ulong, Timer> EditorTimer { get; set; } = new Dictionary<ulong, Timer> ();

        public class RootConfig
        {
            public bool HarvestDyingPlants { get; set; } = true;
            public Dictionary<string, Setting> Settings { get; set; } = new Dictionary<string, Setting> ();

            public OutputContainerSkins GeneratorOnSkin { get; set; } = new OutputContainerSkins ( 2101522859, 1262018145 );
            public OutputContainerSkins GeneratorOffSkin { get; set; } = new OutputContainerSkins ( 1312998395, 826323166 );

            public List<Harvester> Harvesters { get; set; } = new List<Harvester> ();

            public class OutputContainerSkins
            {
                public ulong WoodStorageBox { get; set; }
                public ulong LargeWoodBox { get; set; }

                public OutputContainerSkins () { }
                public OutputContainerSkins ( ulong woodStorageBoxSkin, ulong largeWoodBoxSkin )
                {
                    WoodStorageBox = woodStorageBoxSkin;
                    LargeWoodBox = largeWoodBoxSkin;
                }
            }

            public class Harvester
            {
                public Harvester () { }
                public Harvester ( BasePlayer player, FuelGenerator generator ) { OwnerPlayerId = player.userID; GeneratorId = generator.net.ID; }

                public ulong OwnerPlayerId { get; set; }
                public uint GeneratorId { get; set; }
                public uint OutputContainerId { get; set; }
                public List<Planter> Planters { get; set; } = new List<Planter> ();

                public bool AllowTeamToManage { get; set; } = false;
                public bool AllowFriendsToManage { get; set; } = false;
                public bool AllowClanToManage { get; set; } = false;

                #region Backup

                public FuelGeneratorSettings PreviousGeneratorSettings { get; set; } = new FuelGeneratorSettings ();
                public ulong PreviousOutputContainerSkinId { get; set; }

                public void BackSettingsUp ()
                {
                    var generator = GetGenerator ();
                    PreviousGeneratorSettings.OutputEnergy = generator.outputEnergy;
                    PreviousGeneratorSettings.FuelPerSecond = generator.fuelPerSec;
                }
                public void LoadBackupSettings ()
                {
                    var generator = GetGenerator ();
                    generator.outputEnergy = PreviousGeneratorSettings.OutputEnergy;
                    generator.fuelPerSec = PreviousGeneratorSettings.FuelPerSecond;
                }

                #endregion

                private FuelGenerator _generator { get; set; }
                private StorageContainer _storageContainer { get; set; }
                private PlanterBox [] _planters { get; set; }
                private GrowableEntity [] _planterGrowables { get; set; }

                public FuelGenerator GetGenerator ()
                {
                    var generator = _generator ?? ( _generator = ( FuelGenerator )BaseNetworkable.serverEntities.Find ( GeneratorId ) );
                    if ( generator != null )
                    {
                        generator.fuelPerSec = Instance.GetIdealSetting ( OwnerPlayerId ).FuelPerSecond;

                        if ( !HasOutputContainerAssigned () )
                        {
                            generator.TurnOff ();
                        }
                    }

                    return generator;
                }
                public StorageContainer GetOutputContainer () { return _storageContainer ?? ( _storageContainer = ( StorageContainer )BaseNetworkable.serverEntities.Find ( OutputContainerId ) ); }
                public PlanterBox [] GetPlanters ()
                {
                    Planters.RemoveAll ( ( Planter planter ) =>
                    {
                        if ( planter == null ) return false;

                        var planterEntity = BaseNetworkable.serverEntities.Find ( planter.PlanterId );
                        if ( planterEntity == null || planterEntity.IsDestroyed ) return true;

                        return false;
                    } );

                    return _planters ?? ( _planters = BaseNetworkable.serverEntities.Where ( x => Planters.Any ( y => y.PlanterId == x.net.ID ) ).Select ( x => ( PlanterBox )x ).ToArray () );
                }
                public GrowableEntity [] GetPlanterGrowables ()
                {
                    if ( _planterGrowables == null )
                    {
                        var planters = GetPlanters ();
                        if ( planters == null ) return null;

                        var list = new List<GrowableEntity> ();
                        foreach ( var planter in planters )
                        {
                            list.AddRange ( planter.GetComponentsInChildren<GrowableEntity> () );
                        }

                        _planterGrowables = list.ToArray ();
                    }

                    return _planterGrowables;
                }

                #region Methods

                public bool HasOutputContainerAssigned ()
                {
                    return OutputContainerId != 0 && GetOutputContainer () != null;
                }

                public IEnumerator RefreshEverything ()
                {
                    _generator = null;
                    _storageContainer = null;
                    _planters = null;
                    _planterGrowables = null;

                    yield return GetGenerator ();
                    yield return GetOutputContainer ();
                    yield return GetPlanters ();
                    yield return GetPlanterGrowables ();
                }
                public IEnumerator RefreshPlanterGrowables ()
                {
                    _planterGrowables = null;
                    yield return GetPlanterGrowables ();
                }

                public IEnumerator ApplyOutputContainerSkin ()
                {
                    var container = ( StorageContainer )null;
                    yield return container = GetOutputContainer ();

                    if ( container == null ) yield break;

                    var skin = 0uL;

                    if ( container.PrefabName.Contains ( "woodbox_deployed" ) )
                        skin = IsGeneratorRunning () ? Instance.Config.GeneratorOnSkin.WoodStorageBox : Instance.Config.GeneratorOffSkin.WoodStorageBox;
                    else if ( container.PrefabName.Contains ( "box.wooden.large" ) )
                        skin = IsGeneratorRunning () ? Instance.Config.GeneratorOnSkin.LargeWoodBox : Instance.Config.GeneratorOffSkin.LargeWoodBox;

                    if ( skin == 0 || container.skinID == skin ) yield break;

                    container.skinID = skin;
                    container.SendNetworkUpdateImmediate ();
                }
                public IEnumerator RemoveOutputContainerSkin ()
                {
                    var container = ( StorageContainer )null;
                    yield return container = GetOutputContainer ();

                    if ( container == null ) yield break;

                    container.skinID = PreviousOutputContainerSkinId;
                    container.SendNetworkUpdateImmediate ();
                }

                public bool IsGeneratorRunning ()
                {
                    return _generator != null && _generator.IsOn ();
                }

                #endregion

                public class FuelGeneratorSettings
                {
                    public bool IsOn { get; set; }
                    public int OutputEnergy { get; set; }
                    public float FuelPerSecond { get; set; }
                }
            }
            public class Planter
            {
                public uint PlanterId { get; set; }
                public ulong OwnerPlayerId { get; set; }

                public Planter () { }
                public Planter ( uint planterId, ulong ownerPlayerId )
                {
                    PlanterId = planterId;
                    OwnerPlayerId = ownerPlayerId;
                }
            }
            public class Setting
            {
                public int MaximumHarvesters { get; set; }
                public int PlantersPerHarvester { get; set; }
                public float FuelPerSecond { get; set; }
                public float PlanterDistance { get; set; }
                public float EditorTimeout { get; set; } = 20f;
            }
        }

        #endregion
    }
}


// --- End of file: Harvester.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SpectatorPlus.cs ---
// --- Original Local Path: SpectatorPlus.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("SpectatorPlus", "https://shoprust.ru/", "0.0.4")]
    class SpectatorPlus : RustPlugin
    {
        [PluginReference] Plugin MultiFighting;

        #region CFG

        private static Configuration config = new Configuration();

        public class Configuration
        {
            [JsonProperty("Положение панели")] public Settings Setting = new Settings();
            [JsonProperty("Настройка кнопок")] public List<Buttons> ButtonsSet = new List<Buttons>();
            [JsonProperty("Причины бана")] public List<BanReason> ReasonBan = new List<BanReason>();

            [JsonProperty("Другие настройки")] public AnotherSettings Another = new AnotherSettings();


            [JsonProperty(
                "Положения кнопок с дествиями(нужно для размещения кнопок в заданном порядке) не рекомендую менять это, а то кнопки могут быть отрисованы неправильно")]
            public List<ButtonPos> Positions = new List<ButtonPos>();

            internal class Settings
            {
                [JsonProperty("AnchorMin")] public string MainAnchorMin;
                [JsonProperty("AnchorMax")] public string MainAnchorMax;
                [JsonProperty("OffsetMin")] public string MainOffsetMin;
                [JsonProperty("OffsetMax")] public string MainOffsetMax;
            }

            internal class Buttons
            {
                [JsonProperty("Надпись на кнопке")] public string Title;

                [JsonProperty("Спец-Функция(если нужна просто команда оставьте поле пустым)")]
                public string Funk;

                [JsonProperty("Команда ([ID] заменяется на ID наблюдюдаемого)")]
                public string Command;

                [JsonProperty("Пермишн на отображение")]
                public string Perm;
            }

            internal class BanReason
            {
                [JsonProperty("Название")] public string ReasonName;
                [JsonProperty("Команда")] public string BanCommand;
            }

            internal class AnotherSettings
            {
                [JsonProperty("На сколько хп хилять/ранить наблюдаемого по кнопке Heal/Hurt")]
                public float HP;
            }


            internal class ButtonPos
            {
                [JsonProperty("OffsetMin")] public string oMin;
                [JsonProperty("OffsetMax")] public string oMax;
            }


            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    Setting = new Settings
                    {
                        MainAnchorMin = "1 0.5",
                        MainAnchorMax = "1 0.5",
                        MainOffsetMin = "-200 -170",
                        MainOffsetMax = "-10 170"
                    },
                    ButtonsSet = new List<Buttons>
                    {
                        new Buttons
                        {
                            Title = "BAN",
                            Funk = "BanMenu",
                            Command = "",
                            Perm = "SpectatorPlus.canban"
                        },
                        new Buttons
                        {
                            Title = "",
                            Funk = "HPControl",
                            Command = "",
                            Perm = "SpectatorPlus.CanHPControl"
                        },
                        new Buttons
                        {
                            Title = "CALL",
                            Funk = "",
                            Command = "call [ID]",
                            Perm = "SpectatorPlus.Cancall"
                        }
                    },
                    ReasonBan = new List<BanReason>
                    {
                        new BanReason
                        {
                            ReasonName = "СОФТ",
                            BanCommand = "ban [ID] 30d cheats",
                        },
                        new BanReason
                        {
                            ReasonName = "МАКРОС",
                            BanCommand = "ban [ID] 30d macros",
                        }
                    },
                    Another = new AnotherSettings
                    {
                        HP = 10f
                    },
                    Positions = new List<ButtonPos>
                    {
                        new ButtonPos
                        {
                            oMin = "-92 83",
                            oMax = "-2 108"
                        },
                        new ButtonPos
                        {
                            oMin = "2 83",
                            oMax = "92 108"
                        },
                        new ButtonPos
                        {
                            oMin = "-92 55",
                            oMax = "-2 80"
                        },
                        new ButtonPos
                        {
                            oMin = "2 55",
                            oMax = "92 80"
                        },
                        new ButtonPos
                        {
                            oMin = "-92 27",
                            oMax = "-2 52"
                        },
                        new ButtonPos
                        {
                            oMin = "2 27",
                            oMax = "92 52"
                        },
                        new ButtonPos
                        {
                            oMin = "-92 -1",
                            oMax = "-2 24"
                        },
                        new ButtonPos
                        {
                            oMin = "2 -1",
                            oMax = "92 24"
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                Puts("!!!!ОШИБКА КОНФИГУРАЦИИ!!!! создаем новую");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
        #region LANG

        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"NO_ADM", "You not admin!"},
                {"NO_PERM", "You dont have permission"},
                {"NOT_FOUND", "Not found"},
                {"NOT_FOUND_RAYCAST", "Not found in line of sight"},
                {"CANT_SPEC_ADMIN", "You cant spectating another admin"},
                {"START_SPEC", "Start spectating"}
            }, this, "en");
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"NO_ADM", "НЕ АДМИН!"},
                {"NO_PERM", "НЕТ РАЗРЕШЕНИЯ!"},
                {"NOT_FOUND", "Не найден!"},
                {"NOT_FOUND_RAYCAST", "Не найден по линии взгляда!"},
                {"CANT_SPEC_ADMIN", "Вы не можете наблюдать за другим админом"},
                {"START_SPEC", "Начинаем слежку"}
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно!");
        }

        #endregion
        #region Load/Unload

        void OnServerInitialized()
        {
            for (int i = 0; i < config.ButtonsSet.Count; i++)
            {
                if (config.ButtonsSet[i].Perm.Length <= 0) return;
                permission.RegisterPermission(config.ButtonsSet[i].Perm, this);
            }

            permission.RegisterPermission("SpectatorPlus.canspectate", this);
        }

        string spectateLayer = "specLayer";
        string spectateLayerBan = "specLayerBan";
        private string spectateHPControl = "specHPControl";

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, spectateLayer);
                CuiHelper.DestroyUi(player, spectateLayerBan);
            }
        }

        #endregion
        #region Commands

        [ChatCommand("spec")]
        void StartSpectate(BasePlayer admin, string command, string[] args)
        {
            if (!admin.IsAdmin)
            {
                admin.ChatMessage(lang.GetMessage("NO_ADM", this, admin.UserIDString));
                return;
            }

            if (!permission.UserHasPermission(admin.UserIDString, "SpectatorPlus.canspectate"))
            {
                admin.ChatMessage(lang.GetMessage("NO_PERM", this, admin.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                RaycastHit hit;
                if (!Physics.Raycast(admin.eyes.HeadRay(), out hit, float.MaxValue,
                        LayerMask.GetMask("Player (Server)")))
                {
                    admin.ChatMessage(lang.GetMessage("NOT_FOUND_RAYCAST", this, admin.UserIDString));
                    return;
                }
                else
                {
                    var targetPlayer = hit.GetEntity() as BasePlayer;
                    if (targetPlayer == null)
                    {
                        admin.ChatMessage(lang.GetMessage("NOT_FOUND_RAYCAST", this, admin.UserIDString));
                        return;
                    }
                    else
                    {
                        if (targetPlayer.IsAdmin)
                        {
                            admin.ChatMessage(lang.GetMessage("CANT_SPEC_ADMIN", this, admin.UserIDString));
                            return;
                        }

                        rust.RunClientCommand(admin, $"spectate {targetPlayer.userID}");
                    }
                }
            }
            else
            {
                var targetPlayer = BasePlayer.Find(args[0]);
                if (targetPlayer == null)
                {
                    admin.ChatMessage("Не найден!");
                    return;
                }
                else
                {
                    admin.ChatMessage("Начинаем слежку!");
                    rust.RunClientCommand(admin, $"spectate {targetPlayer.userID}");
                }
            }
        }

        [ChatCommand("specstop")]
        private void SpectatingEnd(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, spectateLayer);
            rust.RunClientCommand(player, "respawn");
        }

        object OnPlayerSpectateEnd(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, spectateLayer);
            return null;
        }

        private object CanSpectateTarget(BasePlayer player, string filter)
        {
            var target = BasePlayer.Find(filter);
            if (player == target)
            {
                player.ChatMessage("Вы не можете следить за самим собой.");
                return false;
            }

            if (target.IsAdmin)
            {
                player.ChatMessage("Вы не можете следить за другими админами.");
                return false;
            }
            if(target.IsDead() || target.IsSleeping())
            {
                player.ChatMessage("Игрок не валидный!");
                return false;
            }
            CuiHelper.DestroyUi(player, spectateLayer);

            if (permission.UserHasPermission(player.UserIDString, "SpectatorPlus.canspectate"))
            {
                
                timer.Once(0.1f, () =>  
                    {
                        if (string.IsNullOrEmpty(filter))
                        {
                            Puts($"{player.displayName} tries to spectate with a nulled player!");
                            rust.RunClientCommand(player, "respawn");
                        }
                        else
                        {
                            Puts($"{player.displayName} tries to spectate with a filter: {filter}");
                            DrawBlockInfo(player, filter);
                        }
                    });
            }
            else
            {
                player.ChatMessage(lang.GetMessage("NO_PERM", this, player.UserIDString));
                return false;
            }

            return null;
            }

            #endregion

            #region GUI

            private void DrawBlockInfo(BasePlayer player, string filter)
            {
                var currentSuspect = BasePlayer.Find(filter);
                CuiHelper.DestroyUi(player, spectateLayer);

                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    RectTransform =
                    {
                        AnchorMin = $"{config.Setting.MainAnchorMin}", AnchorMax = $"{config.Setting.MainAnchorMax}",
                        OffsetMin = $"{config.Setting.MainOffsetMin}", OffsetMax = $"{config.Setting.MainOffsetMax}"
                    },
                    Image = {Color = "0, 0, 0, 0.5"},
                }, "Overlay", spectateLayer);

                container.Add(new CuiLabel
                {
                    Text =
                    {
                        Text = "SPECTATOR+",
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-bold.ttf"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-95 0", OffsetMax = "95 25"
                    }
                }, spectateLayer);

                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-92 3", OffsetMax = "92 28"},
                    Button = {Color = "250, 0, 0, 0.70", Command = "chat.say /specstop"},
                    Text =
                    {
                        Text = $"STOP", Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#FFFFFF"),
                        Align = TextAnchor.MiddleCenter, FontSize = 18
                    },
                }, spectateLayer);
                if (MultiFighting)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform =
                            {AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-92 -28", OffsetMax = "62 -3"},
                        Button = {Color = "50, 50, 50, 0.36", Command = ""},
                        Text =
                        {
                            Text = $"{currentSuspect.displayName}", Font = "robotocondensed-bold.ttf",
                            Color = HexToRustFormat("#FFFFFF"), Align = TextAnchor.MiddleCenter, FontSize = 18
                        },
                    }, spectateLayer);
                    string suspectid = currentSuspect.userID.ToString();
                    var isSteamSprite = IsSteam(suspectid) == "IS_STEAM"
                        ? "assets/icons/steam.png"
                        : "assets/icons/poison.png";

                    container.Add(new CuiElement
                        {
                            Parent = spectateLayer,
                            Components =
                            {
                                new CuiImageComponent {Color = HexToRustFormat("#FFFFFF"), Sprite = isSteamSprite},
                                new CuiRectTransformComponent
                                    {AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "65 -28", OffsetMax = "92 -3"},
                            }
                        }
                    );
                }
                else
                {
                    container.Add(new CuiButton
                    {
                        RectTransform =
                            {AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-92 -28", OffsetMax = "92 -3"},
                        Button = {Color = "50, 50, 50, 0.36", Command = ""},
                        Text =
                        {
                            Text = $"{currentSuspect.displayName}", Font = "robotocondensed-bold.ttf",
                            Color = HexToRustFormat("#FFFFFF"), Align = TextAnchor.MiddleCenter, FontSize = 18
                        },
                    }, spectateLayer);
                }

                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-92 -59", OffsetMax = "92 -32"},
                    Button = {Color = "50, 50, 50, 0.36", Command = $""},
                    Text =
                    {
                        Text = $"{currentSuspect.userID}", Font = "robotocondensed-bold.ttf",
                        Color = HexToRustFormat("#FFFFFF"), Align = TextAnchor.MiddleCenter, FontSize = 18
                    },
                }, spectateLayer);
                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-92 31", OffsetMax = "-20 55"},
                    Button = {Color = "50, 50, 50, 0.36", Command = $"spectatorbutton {currentSuspect.UserIDString} prevplayer"},
                    Text =
                    {
                        Text = "<<<", Font = "robotocondensed-bold.ttf",
                        Color = HexToRustFormat("#FFFFFF"), Align = TextAnchor.MiddleCenter, FontSize = 18
                    },
                }, spectateLayer);
                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "20 31", OffsetMax = "92 55"},
                    Button = {Color = "50, 50, 50, 0.36", Command = $"spectatorbutton {currentSuspect.UserIDString} nextplayer"},
                    Text =
                    {
                        Text = ">>>", Font = "robotocondensed-bold.ttf",
                        Color = HexToRustFormat("#FFFFFF"), Align = TextAnchor.MiddleCenter, FontSize = 18
                    },
                }, spectateLayer);
                container.Add(new CuiButton
                {
                    RectTransform = {AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-18 31", OffsetMax = "18 55"},
                    Button = {Color = "50, 50, 50, 0.36", Command = ""},
                    Text =
                    {
                        Text = (BasePlayer.activePlayerList.IndexOf(currentSuspect) + 1).ToString(), Font = "robotocondensed-bold.ttf",
                        Color = HexToRustFormat("#FFFFFF"), Align = TextAnchor.MiddleCenter, FontSize = 18
                    },
                }, spectateLayer);
                for (int i = 0; i < config.ButtonsSet.Count; i++)
                {
                    DrawButtons(player, container, currentSuspect, i);
                }
                CuiHelper.AddUi(player, container);
            }
            
            void DrawButtons(BasePlayer player, CuiElementContainer container, BasePlayer currentSuspect, int i)
            {
                if (!permission.UserHasPermission(player.UserIDString, config.ButtonsSet[i].Perm))
                {
                    container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5", 
                            AnchorMax = "0.5 0.5", 
                            OffsetMin = config.Positions[i].oMin,
                            OffsetMax = config.Positions[i].oMax
                        },

                        Button =
                        {
                            Color = "50, 50, 50, 0.36",
                            Command = ""
                        },

                        Text =
                        {
                            Text = "---", Font = "robotocondensed-bold.ttf",
                            Color = HexToRustFormat("#FFFFFF"),
                            Align = TextAnchor.MiddleCenter, FontSize = 18
                        },
                    }, spectateLayer);
                    return;
                }

                if (config.ButtonsSet[i].Funk.Length <= 0)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = config.Positions[i].oMin,
                            OffsetMax = config.Positions[i].oMax
                        },

                        Button =
                        {
                            Color = "100, 0, 0, 0.36",
                            Command = config.ButtonsSet[i].Command.Replace("[ID]", currentSuspect.UserIDString)
                        },

                        Text =
                        {
                            Text = config.ButtonsSet[i].Title, Font = "robotocondensed-bold.ttf",
                            Color = HexToRustFormat("#FFFFFF"),
                            Align = TextAnchor.MiddleCenter, FontSize = 18
                        },
                    }, spectateLayer);
                }
                else if (config.ButtonsSet[i].Funk == "BanMenu")
                {
                    container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = config.Positions[i].oMin,
                            OffsetMax = config.Positions[i].oMax
                        },

                        Button =
                        {
                            Color = "100, 0, 0, 0.36", Command = $"spectatorbutton {currentSuspect.UserIDString} BanMenu"
                        },

                        Text =
                        {
                            Text = config.ButtonsSet[i].Title, Font = "robotocondensed-bold.ttf",
                            Color = HexToRustFormat("#FFFFFF"),
                            Align = TextAnchor.MiddleCenter, FontSize = 18
                        },
                    }, spectateLayer);
                }
                else if (config.ButtonsSet[i].Funk == "HPControl")
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = config.Positions[i].oMin,
                            OffsetMax = config.Positions[i].oMax
                        },
                        Image = {Color = "0, 0, 0, 0.3"}
                    }, spectateLayer, spectateHPControl);
                    container.Add(new CuiButton
                    {
                        RectTransform =
                            {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-45 -12", OffsetMax = "-2 12"},

                        Button =
                        {
                            Color = "0, 100, 0, 0.36",
                            Command = $"spectatorbutton {currentSuspect.UserIDString} HPControll heal"
                        },

                        Text =
                        {
                            Text = "HEAL", Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#FFFFFF"),
                            Align = TextAnchor.MiddleCenter, FontSize = 18
                        },
                    }, spectateHPControl);
                    container.Add(new CuiButton
                    {
                        RectTransform =
                            {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "2 -12", OffsetMax = "45 12"},

                        Button =
                        {
                            Color = "100, 0, 0, 0.36",
                            Command = $"spectatorbutton {currentSuspect.UserIDString} HPControll hurt"
                        },

                        Text =
                        {
                            Text = "HURT", Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#FFFFFF"),
                            Align = TextAnchor.MiddleCenter, FontSize = 18
                        },
                    }, spectateHPControl);
                }
                else
                    PrintWarning(
                        $"Спец-Функции с именем {config.ButtonsSet[i].Funk} не существует. Проверьте параметр Спец-Функция в Параметре кнопки {i}  конфиге плагина");
            }
            
            #region InterfaceButtons
            
            [ConsoleCommand("spectatorbutton")]
            void Button(ConsoleSystem.Arg arg)
            {
                BasePlayer player = arg.Player();
                if (!player.IsAdmin) return;
                var target = BasePlayer.Find(arg.Args[0]);
                switch (arg.Args[1])
                {
                    case "HPControll":
                        switch (arg.Args[2])
                        {
                            case "heal":
                                target.Heal(config.Another.HP);
                                player.ChatMessage($"Вы похиляли наблюдаемого");
                                return;

                            case "hurt":
                                target.Hurt(config.Another.HP);
                                player.ChatMessage($"Вы ранили наблюдаемого");
                                return;
                        }

                        break;
                    case "BanMenu":
                        CuiElementContainer bancontainer = new CuiElementContainer();
                        CuiHelper.DestroyUi(player, spectateLayerBan);
                        bancontainer.Add(new CuiPanel
                        {
                            CursorEnabled = true,
                            RectTransform =
                                {AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "-195 -170", OffsetMax = "-5 170"},
                            Image = {Color = "0, 0, 0, 0"},
                        }, spectateLayer, spectateLayerBan);

                        for (int i = 0; i < config.ReasonBan.Count; i++)
                        {
                            bancontainer.Add(new CuiButton
                            {
                                RectTransform =
                                {
                                    AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-92 {(-28 - (31 * i))}",
                                    OffsetMax = $"92 {(-3 - (29 * i))}"
                                },
                                Button =
                                {
                                    Color = "70, 0, 0, 1",
                                    Command = config.ReasonBan[i].BanCommand.Replace("[ID]", $"{target.UserIDString}")
                                },
                                Text =
                                {
                                    Text = $"{config.ReasonBan[i].ReasonName}", Font = "robotocondensed-bold.ttf",
                                    Color = HexToRustFormat("#FFFFFF"), Align = TextAnchor.MiddleCenter, FontSize = 18
                                },
                            }, spectateLayerBan);
                        }
                        CuiHelper.AddUi(player, bancontainer);
                        break;
                    case "nextplayer":
                    {
                        int index = BasePlayer.activePlayerList.IndexOf(target) + 1;
                        if (index == BasePlayer.activePlayerList.Count) index = 0;
                        if (BasePlayer.activePlayerList[index].IsAdmin) index++;
                        if (target.IsDead() || target.IsSleeping()) index++;
                        rust.RunClientCommand(player, $"spectate {BasePlayer.activePlayerList[index].userID}");
                        break;
                    }
                    case "prevplayer":
                    {
                        int index = BasePlayer.activePlayerList.IndexOf(target) - 1;
                        if (index < 0) index = BasePlayer.activePlayerList.Count - 1;
                        if (BasePlayer.activePlayerList[index].IsAdmin) index--;
                        if (target.IsDead() || target.IsSleeping()) index--;
                        rust.RunClientCommand(player, $"spectate {BasePlayer.activePlayerList[index].userID}");
                        break;
                    }
                }
            }

            #endregion

            #endregion
            #region HelpMethods

            private static string HexToRustFormat(string hex)
            {
                if (string.IsNullOrEmpty(hex))
                {
                    hex = "#FFFFFFFF";
                }

                var str = hex.Trim('#');

                if (str.Length == 6)
                    str += "FF";

                if (str.Length != 8)
                {
                    throw new Exception(hex);
                    throw new InvalidOperationException("Cannot convert a wrong format.");
                }

                var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
                var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
                var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
                var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

                Color color = new Color32(r, g, b, a);

                return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
            }

            string IsSteam(string suspectid)
            {
                if (MultiFighting != null)
                {
                    var player = BasePlayer.Find(suspectid);
                    if (player == null)
                    {
                        return "ERROR #1";
                    }

                    var obj = MultiFighting.CallHook("IsSteam", player.Connection);
                    if (obj is bool)
                    {
                        if ((bool) obj)
                        {
                            return ("IS_STEAM");
                        }
                        else
                        {
                            return ("IS_PIRATE");
                        }
                    }
                    else
                    {
                        return "ERROR #2";
                    }
                }
                else return ("IS_STEAM");
            }

            #endregion
    }
}

// --- End of file: SpectatorPlus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerInformations.cs ---
// --- Original Local Path: PlayerInformations.cs ---

using System.Collections.Generic;
using System;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("PlayerInformations", "Reneb", "1.0.5", ResourceId = 1345)]
    [Description("Logs players informations.")]
    public class PlayerInformations : RustPlugin
    {
        [PluginReference]
        Plugin PlayerDatabase;

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Configs
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        private static bool IPuse = true;
        private static string IPpermission = "canips";
        private static int IPauthlevel = 1;
        private static int IPmaxLogs = 5;

        private static bool NAMESuse = true;
        private static string NAMESpermission = "cannames";
        private static int NAMESauthlevel = 1;
        private static int NAMESmaxLogs = 5;

        private static bool FCuse = true;
        private static string FCpermission = "canlastseen";
        private static int FCauthlevel = 1;

        private static bool LSuse = true;
        private static string LSpermission = "canlastseen";
        private static int LSauthlevel = 1;

        private static bool LPuse = true;
        private static string LPpermission = "canlastposition";
        private static int LPauthlevel = 1;

        private static bool TPuse = true;
        private static string TPpermission = "cantimeplayed";
        private static int TPauthlevel = 0;

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        void Loaded()
        {
            if (!permission.PermissionExists(IPpermission)) permission.RegisterPermission(IPpermission, this);
            if (!permission.PermissionExists(NAMESpermission)) permission.RegisterPermission(NAMESpermission, this);
            if (!permission.PermissionExists(FCpermission)) permission.RegisterPermission(FCpermission, this);
            if (!permission.PermissionExists(LSpermission)) permission.RegisterPermission(LSpermission, this);
            if (!permission.PermissionExists(LSpermission)) permission.RegisterPermission(LPpermission, this);
        }

        void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else 
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<bool>("IP Logs - activated", ref IPuse);
            CheckCfg<string>("IP Logs - Permission - oxide permission", ref IPpermission);
            CheckCfg<int>("IP Logs - Permission - authlevel", ref IPauthlevel);
            CheckCfg<int>("IP Logs - Max Logs per player", ref IPmaxLogs);

            CheckCfg<bool>("Names Logs - activated", ref NAMESuse);
            CheckCfg<string>("Names Logs - Permission - oxide permission", ref NAMESpermission);
            CheckCfg<int>("Names Logs - Permission - authlevel", ref NAMESauthlevel);
            CheckCfg<int>("Names Logs - Max Logs per player", ref NAMESmaxLogs);

            CheckCfg<bool>("First Connection - activated", ref FCuse);
            CheckCfg<string>("First Connection - Permission - oxide permission", ref FCpermission);
            CheckCfg<int>("First Connection - Permission - authlevel", ref FCauthlevel);

            CheckCfg<bool>("Last Seen - activated", ref LSuse);
            CheckCfg<string>("Last Seen - Permission - oxide permission", ref LSpermission);
            CheckCfg<int>("Last Seen - Permission - authlevel", ref LSauthlevel);

            CheckCfg<bool>("Last Position - activated", ref LPuse);
            CheckCfg<string>("Last Position - Permission - oxide permission", ref LPpermission);
            CheckCfg<int>("Last Position - Permission - authlevel", ref LPauthlevel);

            CheckCfg<bool>("Time Played - activated", ref TPuse);
            CheckCfg<string>("Time Played - Permission - oxide permission", ref TPpermission);
            CheckCfg<int>("Time Played - Permission - authlevel", ref TPauthlevel);

            SaveConfig();
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Oxide Hooks
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        void OnServerInitialized()
        {
            if (TPuse)
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    StartRecordTime(player);
                }
            }
        }

        void OnEntityDeath(BaseCombatEntity ent, HitInfo info)
        {
            if (!LPuse) return;
            BasePlayer player = ent.GetComponent<BasePlayer>();
            if (player != null)
            {
                if (!player.IsConnected())
                {
                    var LastPos = new Dictionary<string, object>
                    {
                        {"x", player.transform.position.x.ToString() },
                        {"y", player.transform.position.y.ToString() },
                        {"z", player.transform.position.z.ToString() }
                    };
                    PlayerDatabase.Call("SetPlayerData", player.userID.ToString(), "Last Position", LastPos);
                }
            }
        }

        void Unload()
        {
            if (TPuse)
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    EndRecordTime(player);
                }
            }
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (IPuse)
                RecordIP(player);
            if (NAMESuse)
                RecordName(player);
            if (FCuse)
                RecordFirstConnection(player);
            if (TPuse)
                StartRecordTime(player);
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (LSuse)
                RecordLastSeen(player);
            if (TPuse)
                EndRecordTime(player);
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            string msg = string.Empty;
            if (hasPermission(player, IPauthlevel, IPpermission)) { msg += "<color=\"#ffd479\">/lastips steamid/name</color> - get the last ips used by a user\n<color=\"#ffd479\">/ipowners XX.XX.XX.XX </color>- know what players used this ip\n"; }
            if (hasPermission(player, LSauthlevel, LSpermission)) { msg += "<color=\"#ffd479\">/lastseen steamid/name</color> - know when was this player last seen online\n"; }
            if (hasPermission(player, LPauthlevel, LPpermission)) { msg += "<color=\"#ffd479\">/lastposition steamid/name</color> - know where is the last position of a player\n"; }
            if (hasPermission(player, FCauthlevel, FCpermission)) { msg += "<color=\"#ffd479\">/firstconnection steamid/name</color> - know when was this player first seen online\n"; }
            if (hasPermission(player, TPauthlevel, TPpermission)) { msg += "<color=\"#ffd479\">/played steamid/name</color> - know how much time a player has played on this server\n"; }
            if (hasPermission(player, NAMESauthlevel, NAMESpermission)) { msg += "<color=\"#ffd479\">/lastnames steamid/name</color> - know the last names used by a user\n"; }
            if (msg != string.Empty)
            {
                msg = "<size=18>Players Information</size>\n" + msg;
                SendReply(player, msg);
            }
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// General Functions
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        static double LogTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }

        string TimeMinToString(string time) { return TimeMinToString(double.Parse(time)); }
        string TimeMinToString(double time)
        {
            TimeSpan timespan = TimeSpan.FromSeconds(time);
            DateTime date = new DateTime(1970, 1, 1, 0, 0, 0) + timespan;
            return string.Format("{0}:{1} {2}/{3}/{4}", date.Hour.ToString(), date.Minute.ToString(), date.Month.ToString(), date.Day.ToString(), date.Year.ToString());
        }

        string SecondsToString(string time) { return SecondsToString(decimal.Parse(time)); }
        string SecondsToString(decimal time)
        {
            decimal days = Math.Floor(time / 86400);
            time -= days * 86400;
            decimal hours = Math.Floor(time / 3600);
            time -= hours * 3600;
            decimal minutes = Math.Floor(time / 60);
            time -= minutes * 60;
            return string.Format("{0}d {1}h {2}m {3}s", days.ToString(), hours.ToString(), minutes.ToString(), Math.Floor(time).ToString());
        }

        private object FindPlayer(string arg)
        {
            string success = PlayerDatabase.Call("FindPlayer", arg) as string;
            if (success.Length == 17)
            {
                return ulong.Parse(success);
            }
            else
                return success;
        }
        private BasePlayer FindBasePlayerPlayer(ulong steamid)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.userID == steamid)
                    return player;
            }
            foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
            {
                if (player.userID == steamid)
                    return player;
            }
            return null;
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Permission
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        bool hasPermission(BasePlayer player, int authlevel, string permissionName)
        {
            if (player.net.connection.authLevel >= authlevel) return true;
            return permission.UserHasPermission(player.userID.ToString(), permissionName);
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Record IP Related
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        void RecordIP(BasePlayer player)
        {
            string playerip = player.net.connection.ipaddress;
            playerip = playerip.Substring(0, playerip.IndexOf(":"));
            var IPlist = new Dictionary<string, object>();

            var success = PlayerDatabase.Call("GetPlayerData", player.userID.ToString(), "IPs");
            if (success is Dictionary<string, object>)
                IPlist = (Dictionary<string, object>)success;

            if (IPlist.ContainsValue(playerip)) return;
            if (IPlist.Count >= IPmaxLogs)
            {
                var tempList = new Dictionary<string, object>();
                foreach (KeyValuePair<string, object> pair in IPlist)
                {
                    tempList.Add(pair.Key, pair.Value);
                }
                IPlist.Clear();
                for (int i = tempList.Count - IPmaxLogs + 1; i < tempList.Count; i++)
                {
                    IPlist.Add(IPlist.Count.ToString(), tempList[i.ToString()]);
                }
            }
            IPlist.Add(IPlist.Count.ToString(), playerip);
            PlayerDatabase.Call("SetPlayerData", player.userID.ToString(), "IPs", IPlist);
        }

        [ChatCommand("lastips")]
        void cmdChatLastIps(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, IPauthlevel, IPpermission)) { SendReply(player, "You don't have access to this command"); return; }
            if (!IPuse) { SendReply(player, "The database isn't set to record the IPs of players"); return; }
            if (args.Length == 0)
            {
                SendReply(player, "/lastips STEAMID/NAME");
                return;
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                SendReply(player, findplayer is string ? (string)findplayer : "Couldn't find a player that matches this name.");
                return;
            }
            var IPlist = new Dictionary<string, object>();
            var success = PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "IPs");
            if (success is Dictionary<string, object>)
                IPlist = (Dictionary<string, object>)success;
            if (IPlist.Count == 0)
            {
                SendReply(player, "No IPs logged for this player");
                return;
            }
            var name = (PlayerDatabase.Call("GetPlayerData", player.userID.ToString(), "default") as Dictionary<string, object>)["name"] as string;
            SendReply(player, string.Format("IP List for {0} - {1}", name, findplayer.ToString()));
            foreach (KeyValuePair<string, object> pair in IPlist)
            {
                SendReply(player, string.Format("{0} - {1}", pair.Key, pair.Value.ToString()));
            }
        }

        [ChatCommand("ipowners")]
        void cmdChatIps(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, IPauthlevel, IPpermission)) { SendReply(player, "You don't have access to this command"); return; }
            if (!IPuse) { SendReply(player, "The database isn't set to record the IPs of players"); return; }
            if (args.Length == 0)
            {
                SendReply(player, "/ipowners XX.XX.XX.XX");
                return;
            }
            HashSet<string> knownPlayers = new HashSet<string>();
            var success = PlayerDatabase.Call("GetAllKnownPlayers");
            if (success is HashSet<string>)
                knownPlayers = (HashSet<string>)success;
            if (knownPlayers.Count == 0)
            {
                SendReply(player, "Couldn't get the list of players");
                return;
            }

            var foundPlayers = new List<string>();
            foreach (string playerID in knownPlayers)
            {
                var playerIPs = new Dictionary<string, object>();
                var successs = PlayerDatabase.Call("GetPlayerData", playerID, "IPs");
                if (successs is Dictionary<string, object>)
                    playerIPs = (Dictionary<string, object>)successs;
                if (playerIPs.Count == 0) { continue; }
                if (playerIPs.ContainsValue(args[0]))
                {
                    foundPlayers.Add(playerID);
                }
            }
            SendReply(player, string.Format("Found {0} players with this matching ip", foundPlayers.Count.ToString()));
            foreach (string userid in foundPlayers)
            {
                var playerData = new Dictionary<string, object>();
                var successs = PlayerDatabase.Call("GetPlayerData", userid, "default");
                if (successs is Dictionary<string, object>)
                    playerData = (Dictionary<string, object>)successs;
                if (playerData.Count == 0) { continue; }

                SendReply(player, string.Format("{0} - {1}", userid, playerData.ContainsKey("name") ? playerData["name"] : "Unknown"));
            }
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Last Seen Related
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        void RecordLastSeen(BasePlayer player)
        {
            var LastSeenTable = new Dictionary<string, object>
            {
                { "0" , LogTime().ToString() }
            };
            PlayerDatabase.Call("SetPlayerData", player.userID.ToString(), "Last Seen", LastSeenTable);
        }

        [ChatCommand("lastseen")]
        private void cmdChatLastseen(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, LSauthlevel, LSpermission)) { SendReply(player, "You don't have access to this command"); return; }
            if (!LSuse) { SendReply(player, "This command has been deactivated"); return; }
            if (args.Length == 0)
            {
                SendReply(player, "/lastseen STEAMID/NAME");
                return;
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                SendReply(player, findplayer is string ? (string)findplayer : "Couldn't find a player that matches this name.");
                return;
            }
            BasePlayer targetPlayer = FindBasePlayerPlayer((ulong)findplayer);
            if (targetPlayer != null && targetPlayer.IsConnected())
            {
                SendReply(player, "This player is connected!");
                return;
            }
            var LastSeen = new Dictionary<string, object>();
            var success = PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "Last Seen");
            if (success is Dictionary<string, object>)
                LastSeen = (Dictionary<string, object>)success;
            if (LastSeen.Count == 0)
            {
                SendReply(player, "This player doesn't have a last seen logged");
                return;
            }
            var name = (PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "default") as Dictionary<string, object>)["name"] as string;
            SendReply(player, string.Format("{0} - {1} was last seen: {2}", name, findplayer.ToString(), TimeMinToString(LastSeen["0"] as string)));
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// First Connection
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        void RecordFirstConnection(BasePlayer player)
        {
            var success = PlayerDatabase.Call("GetPlayerData", player.userID.ToString(), "First Connection");
            if (success is Dictionary<string, object>)
                return;

            var FirstConnectionTable = new Dictionary<string, object>
            {
                { "0" , LogTime().ToString() } 
            };
            PlayerDatabase.Call("SetPlayerData", player.userID.ToString(), "First Connection", FirstConnectionTable);
        }

        [ChatCommand("firstconnection")]
        private void cmdChatfirstconnection(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, FCauthlevel, FCpermission)) { SendReply(player, "You don't have access to this command"); return; }
            if (!FCuse) { SendReply(player, "This command has been deactivated"); return; }
            if (args.Length == 0)
            {
                SendReply(player, "/firstconnection STEAMID/NAME");
                return;
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                SendReply(player, findplayer is string ? (string)findplayer : "Couldn't find a player that matches this name.");
                return;
            }
            var FC = new Dictionary<string, object>();
            var success = PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "First Connection");
            if (success is Dictionary<string, object>)
                FC = (Dictionary<string, object>)success;
            if (FC.Count == 0)
            {
                SendReply(player, "This player doesn't have a first connection logged");
                return;
            }
            var name = (PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "default") as Dictionary<string, object>)["name"] as string;
            SendReply(player, string.Format("{0} - {1} first connected: {2}", name, findplayer.ToString(), TimeMinToString(FC["0"] as string)));
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Record Names
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        void RecordName(BasePlayer player)
        {
            string playername = player.displayName;
            var NameList = new Dictionary<string, object>();

            var success = PlayerDatabase.Call("GetPlayerData", player.userID.ToString(), "Names");
            if (success is Dictionary<string, object>)
                NameList = (Dictionary<string, object>)success;

            if (NameList.ContainsValue(playername)) return;
            if (NameList.Count >= NAMESmaxLogs)
            {
                var tempList = new Dictionary<string, object>();
                foreach (KeyValuePair<string, object> pair in NameList)
                {
                    tempList.Add(pair.Key, pair.Value);
                }
                NameList.Clear();
                for (int i = tempList.Count - NAMESmaxLogs + 1; i < tempList.Count; i++)
                {
                    NameList.Add(NameList.Count.ToString(), tempList[i.ToString()]);
                }
            }
            NameList.Add(NameList.Count.ToString(), playername);
            PlayerDatabase.Call("SetPlayerData", player.userID.ToString(), "Names", NameList);
        }

        [ChatCommand("lastnames")]
        private void cmdChatLastname(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, NAMESauthlevel, NAMESpermission)) { SendReply(player, "You don't have access to this command"); return; }
            if (!NAMESuse) { SendReply(player, "This command has been deactivated"); return; }
            if (args.Length == 0)
            {
                SendReply(player, "/lastnames STEAMID/NAME");
                return;
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                SendReply(player, findplayer is string ? (string)findplayer : "Couldn't find a player that matches this name.");
                return;
            }
            var NameList = new Dictionary<string, object>();
            var success = PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "Names");
            if (success is Dictionary<string, object>)
                NameList = (Dictionary<string, object>)success;
            if (NameList.Count == 0)
            {
                SendReply(player, "No Names logged for this player");
                return;
            }
            var name = (PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "default") as Dictionary<string, object>)["name"] as string;
            SendReply(player, string.Format("Name List for {0} - {1}", name, findplayer.ToString()));
            foreach (KeyValuePair<string, object> pair in NameList)
            {
                SendReply(player, string.Format("{0} - {1}", pair.Key, pair.Value.ToString()));
            }
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Record Time Played
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        Dictionary<BasePlayer, double> recordPlayTime = new Dictionary<BasePlayer, double>();
        void StartRecordTime(BasePlayer player)
        {
            if (recordPlayTime.ContainsKey(player))
                recordPlayTime.Remove(player);
            recordPlayTime.Add(player, LogTime());
        }
        void EndRecordTime(BasePlayer player)
        {
            if (!recordPlayTime.ContainsKey(player)) return;

            var TimePlayed = new Dictionary<string, object>();
            var success = PlayerDatabase.Call("GetPlayerData", player.userID.ToString(), "Time Played");
            if (success is Dictionary<string, object>)
                TimePlayed = (Dictionary<string, object>)success;

            double totaltime = LogTime() - recordPlayTime[player];
            if (TimePlayed.ContainsKey("0"))
                totaltime += double.Parse((string)TimePlayed["0"]);

            TimePlayed.Clear();
            TimePlayed.Add("0", totaltime.ToString());
            PlayerDatabase.Call("SetPlayerData", player.userID.ToString(), "Time Played", TimePlayed);
        }

        [ChatCommand("played")]
        private void cmdChatPlayed(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, TPauthlevel, TPpermission)) { SendReply(player, "You don't have access to this command"); return; }
            if (!TPuse) { SendReply(player, "This command has been deactivated"); return; }
            if (args.Length == 0)
            {
                SendReply(player, "/played STEAMID/NAME");
                return;
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                SendReply(player, findplayer is string ? (string)findplayer : "Couldn't find a player that matches this name.");
                return;
            }
            var TimePlayed = new Dictionary<string, object>();
            var success = PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "Time Played");
            if (success is Dictionary<string, object>)
                TimePlayed = (Dictionary<string, object>)success;
            if (TimePlayed.Count == 0)
            {
                SendReply(player, "This player doesn't have any time played recorded");
                return;
            }
            var name = (PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "default") as Dictionary<string, object>)["name"] as string;
            double tplayed = double.Parse(TimePlayed["0"] as string);
            if (recordPlayTime.ContainsKey(player))
                tplayed += LogTime() - recordPlayTime[player];
            SendReply(player, string.Format("{0} - {1} played: {2}", name, findplayer.ToString(), SecondsToString(tplayed.ToString())));
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// Position Related
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        [ChatCommand("lastposition")]
        private void cmdChatLastPosition(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player, LSauthlevel, LSpermission)) { SendReply(player, "You don't have access to this command"); return; }
            if (!LPuse) { SendReply(player, "This command has been deactivated"); return; }
            if (args.Length == 0)
            {
                SendReply(player, "/lastseen STEAMID/NAME");
                return;
            }
            var findplayer = FindPlayer(args[0]);
            if (!(findplayer is ulong))
            {
                SendReply(player, findplayer is string ? (string)findplayer : "Couldn't find a player that matches this name.");
                return;
            }
            BasePlayer targetPlayer = FindBasePlayerPlayer((ulong)findplayer);
            if (targetPlayer != null && targetPlayer.IsConnected())
            {
                SendReply(player, "This player is connected!");
                return;
            }
            else if (targetPlayer != null && !targetPlayer.IsConnected())
            {
                SendReply(player, string.Format("{0} - {1} current position is: {2} {3} {4}", targetPlayer.displayName, findplayer.ToString(), targetPlayer.transform.position.x.ToString(), targetPlayer.transform.position.y.ToString(), targetPlayer.transform.position.z.ToString()));
                return;
            }
            var LastPos = new Dictionary<string, object>();
            var success = PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "Last Position");
            if (success is Dictionary<string, object>)
                LastPos = (Dictionary<string, object>)success;
            if (LastPos.Count == 0)
            {
                SendReply(player, "This player doesn't have a position logged");
                return;
            }
            var name = (PlayerDatabase.Call("GetPlayerData", findplayer.ToString(), "default") as Dictionary<string, object>)["name"] as string;
            SendReply(player, string.Format("{0} - {1} last position was: {2} {3} {4}", name, findplayer.ToString(), LastPos["x"].ToString(), LastPos["y"].ToString(), LastPos["z"].ToString()));
        }     
    }
}


// --- End of file: PlayerInformations.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQRankSystem.cs ---
// --- Original Local Path: IQRankSystem.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System.Linq;
using System;
using ConVar;
using System.Text;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("IQRankSystem", "SkuliDropek", "0.0.3")]
    [Description("Ваши ранги для сенрвера")]
    class IQRankSystem : RustPlugin
    {
        /// <summary>
        /// Обновление 0.0.3
        /// - Обновил API под новую версию плагина IQHeadReward
        /// - Добавлена связка с IQHeadReward на создание объявления
        /// - Добавлена возможность в условиях с добычей (добыча + время) указать конкретные шортнеймы, которые трубеются
        /// - Добавлена возможность менять формат сообщений
        /// - Убрал дебаг сообщение 
        /// - Добавлен английский конфиг
        /// - Добавлена поддержка IQKits
        /// - Добавлена связка с IQKits на использование определенных наборов с наличием ранга
        /// </summary>

        #region Reference
        [PluginReference] Plugin IQChat, IQCases, IQHeadReward, IQEconomic;

        #region IQChat
        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.Setting.ReferenceSetting.IQChatSetting;
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region IQCases
        void OpenCase(BasePlayer player, string DisplayNameCase)
        {
            if (!DataInformation.ContainsKey(player.userID)) return;
            var Data = DataInformation[player.userID];
            Data.InformationUser.IQCasesOpenCase++;
        }
        #endregion

        #region IQHeadReward
        void KilledTask(BasePlayer player)
        {
            if (!DataInformation.ContainsKey(player.userID)) return;
            var Data = DataInformation[player.userID];
            Data.InformationUser.IQHeadRewardKillAmount++;
        }
        #endregion

        #region IQEconomic
        void SET_BALANCE_USER(ulong userID, int SetBalance)
        {
            if (!DataInformation.ContainsKey(userID)) return;
            var Data = DataInformation[userID];
            Data.InformationUser.IQEconomicAmountBalance += SetBalance;
        }
        #endregion

        #endregion

        #region Vars
        public enum Obtaining
        {
            Gather,
            Time,
            GatherAndTime,
            IQCases,
            IQHeadReward,
            IQEconomic,
        }
        StringBuilder sb = new StringBuilder();
        private string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }

        void RegisteredPermissions()
        {
            foreach(var Perm in config.RankList.Where(p => !String.IsNullOrWhiteSpace(p.Value.PermissionRank)))
                if (!permission.PermissionExists(Perm.Value.PermissionRank, this))
                    permission.RegisterPermission(Perm.Value.PermissionRank, this);
        }
        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Формат для отображения рангов в чате (В IQChat настраивается отдельно) [Не добавляйте значения в {} и не меняйте их порядок, если не уверены в своих возможностях или не знаете что это!!].Все что не внутри {} - можете смело вертеть")]
            public String FormatRanks = "{0} {1} {2} {3}: {4}";
            [JsonProperty("Список рангов и их настройка")]
            public Dictionary<string, RankSettings> RankList = new Dictionary<string, RankSettings>();
            [JsonProperty("Настройки плагина")]
            public Settings Setting = new Settings();

            internal class RankSettings
            {
                [JsonProperty("Название ранга")]
                public String DisplayNameRank;
                [JsonProperty("Права с которыми доступен данный ранг")]
                public String PermissionRank;
                [JsonProperty("Настройки получения ранга")]
                public Obtainings Obtaining = new Obtainings();
                internal class Obtainings
                {
                    [JsonProperty("Выберите за что возможно получить доступ к данному рангу" +
                                  "(0 - Добыча, " +
                                  "1 - Время игры на сервере, " +
                                  "2 - Вермя игры на сервере и добыча вместе," +
                                  "3 - IQCases , открыть N количество кейсов," +
                                  "4 - IQHeadReward , убить N количество игроков в розыске" +
                                  "5 - IQEconomic, собрать за все время N количество валюты")]
                    public Obtaining ObtainingType;
                    [JsonProperty("Настройки получения ранга за время")]
                    public ObtainingsTime ObtainingsTimes = new ObtainingsTime();
                    [JsonProperty("Настройки получения ранга за добычу")]
                    public ObtainingsGather ObtainingsGathers = new ObtainingsGather();
                    [JsonProperty("Настройки получения ранга за открытие кейсов IQCases")]
                    public ObtainingsIQCases ObtainingsIQCase = new ObtainingsIQCases();
                    [JsonProperty("Настройки получения ранга за убийство разыскиваемых IQHeadReward")]
                    public ObtainingsIQHeadReward ObtainingsIQHeadRewards = new ObtainingsIQHeadReward();
                    [JsonProperty("Настройки получения ранга за собранную валюту IQEconomic")]
                    public ObtainingsIQEconomic ObtainingsIQEconomics = new ObtainingsIQEconomic();
                    internal class ObtainingsIQEconomic
                    {
                        [JsonProperty("Сколько собрать валюты для получения этого ранга")]
                        public Int32 IQEconomicBalance;
                    }

                    internal class ObtainingsIQCases
                    {
                        [JsonProperty("Сколько кейсов открыть для получения этого ранга")]
                        public Int32 OpenCaseAmount;
                    }
                    internal class ObtainingsIQHeadReward
                    {
                        [JsonProperty("Сколько нужно убить разыскиваемых для получения этого ранга")]
                        public Int32 KillHeadAmount;
                    }
                    internal class ObtainingsTime
                    {
                        [JsonProperty("Время, которое нужно отыграть для получения этого ранга")]
                        public Int32 TimeGame;
                    }
                    internal class ObtainingsGather
                    {
                        [JsonProperty("Сколько нужно добыть всего ресурсов для ранга")]
                        public Int32 Amount;
                        [JsonProperty("Использовать детальную добычу true - да(из списка, по критериям)/false - нет(учитывается на все ресурсы)")]
                        public Boolean UseDetalisGather;
                        [JsonProperty("Настройки детальной добычи : Shortname = Amount")]
                        public Dictionary<String, Int32> GatherDetalis = new Dictionary<String, Int32>();
                    }
                }
            }

            internal class Settings
            {
                [JsonProperty("Настройки плагинов совместимости")]
                public ReferenceSettings ReferenceSetting = new ReferenceSettings();
                [JsonProperty("Общие настройки")]
                public GeneralSettings GeneralSetting = new GeneralSettings();
                internal class GeneralSettings
                {
                    [JsonProperty("Отображать время игры на сервере перед рангом")]
                    public Boolean ShowTimeGame;
                    [JsonProperty("При получении нового ранга сразу устанавливать его(true - да/false - нет)")]
                    public Boolean RankSetupNew;
                }
                internal class ReferenceSettings
                {
                    [JsonProperty("Настройки IQChat")]
                    public IQChatSettings IQChatSetting = new IQChatSettings();
                    internal class IQChatSettings
                    {
                        [JsonProperty("IQChat : Кастомный префикс в чате")]
                        public String CustomPrefix;
                        [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                        public String CustomAvatar;
                    }
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    FormatRanks = "{0} {1} {2} {3}: {4}",
                    #region General Settings
                    Setting = new Settings
                    {
                        GeneralSetting = new Settings.GeneralSettings
                        {
                            ShowTimeGame = false,
                            RankSetupNew = true,
                        },
                        ReferenceSetting = new Settings.ReferenceSettings
                        {
                            IQChatSetting = new Settings.ReferenceSettings.IQChatSettings
                            {
                                CustomAvatar = "",
                                CustomPrefix = "",
                            },
                        },
                    },
                    #endregion

                    #region Rank List
                    RankList = new Dictionary<String, RankSettings>
                    {
                        ["newmember"] = new RankSettings
                        {
                            DisplayNameRank = "Новобранец",
                            PermissionRank = "",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.Time,
                                ObtainingsTimes = new RankSettings.Obtainings.ObtainingsTime
                                {
                                    TimeGame = 0,
                                },
                            },
                        },
                        ["member"] = new RankSettings
                        {
                            DisplayNameRank = "Местный",
                            PermissionRank = "",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.Time,
                                ObtainingsTimes = new RankSettings.Obtainings.ObtainingsTime
                                {
                                    TimeGame = 300,
                                },
                            },
                        },
                        ["experienced"] = new RankSettings
                        {
                            DisplayNameRank = "Бывалый",
                            PermissionRank = "",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.Time,
                                ObtainingsTimes = new RankSettings.Obtainings.ObtainingsTime
                                {
                                    TimeGame = 600,
                                },
                            },
                        },
                        ["farmer"] = new RankSettings
                        {
                            DisplayNameRank = "Фармила",
                            PermissionRank = "",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.Gather,
                                ObtainingsGathers = new RankSettings.Obtainings.ObtainingsGather
                                {
                                   Amount = 5000,
                                   UseDetalisGather = true,
                                   GatherDetalis = new Dictionary<String, Int32>
                                   {
                                       ["wood"] = 500,
                                       ["stones"] = 1000,
                                   }
                                }
                            },
                        },
                        ["adminFriend"] = new RankSettings
                        {
                            DisplayNameRank = "Кент Админа",
                            PermissionRank = "iqranksystem.vip",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.Time,
                                ObtainingsTimes = new RankSettings.Obtainings.ObtainingsTime
                                {
                                    TimeGame = 600,
                                }
                            },
                        },
                        ["gamer"] = new RankSettings
                        {
                            DisplayNameRank = "Задрот",
                            PermissionRank = "",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.GatherAndTime,
                                ObtainingsTimes = new RankSettings.Obtainings.ObtainingsTime
                                {
                                    TimeGame = 500,
                                },
                                ObtainingsGathers = new RankSettings.Obtainings.ObtainingsGather
                                {
                                    Amount = 5000,
                                    UseDetalisGather = true,
                                    GatherDetalis = new Dictionary<String, Int32>
                                    {
                                        ["sulfur.ore"] = 500,
                                    }
                                }
                            },
                        },
                        ["azart"] = new RankSettings
                        {
                            DisplayNameRank = "Азартный игрок",
                            PermissionRank = "",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.IQCases,
                                ObtainingsIQCase = new RankSettings.Obtainings.ObtainingsIQCases
                                {
                                    OpenCaseAmount = 3
                                }
                            },
                        },
                        ["killer"] = new RankSettings
                        {
                            DisplayNameRank = "Шериф",
                            PermissionRank = "",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.IQHeadReward,
                                ObtainingsIQHeadRewards = new RankSettings.Obtainings.ObtainingsIQHeadReward
                                {
                                    KillHeadAmount = 5,
                                }
                            },
                        },
                        ["IqEconomicMillioner"] = new RankSettings
                        {
                            DisplayNameRank = "Скрудж Макдак",
                            PermissionRank = "",
                            Obtaining = new RankSettings.Obtainings
                            {
                                ObtainingType = Obtaining.IQEconomic,
                                ObtainingsIQEconomics = new RankSettings.Obtainings.ObtainingsIQEconomic
                                {
                                    IQEconomicBalance = 350,
                                }
                            },
                        },
                    }
                    #endregion
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения # конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!"); //1465
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Data
        [JsonProperty("Информация о пользователях")] 
        public Dictionary<UInt64, DataClass> DataInformation = new Dictionary<UInt64, DataClass>();
        public class DataClass
        {
            [JsonProperty("Активный ранг")]
            public String RankActive;
            [JsonProperty("Доступные ранги")]
            public List<String> RankAccessList = new List<String>();
            [JsonProperty("Информация о прогрессе игроков")]
            public Infromation InformationUser = new Infromation();
            internal class Infromation
            {
                [JsonProperty("Время на сервере")]
                public Int32 TimeGame;
                [JsonProperty("Добыто всего")]
                public Int32 GatherAll;
                [JsonProperty("Добыто всего : детально")]
                public Dictionary<String, Int32> GatherDetalis = new Dictionary<String, Int32>();
                [JsonProperty("IQCases : Открыто кейсов")]
                public Int32 IQCasesOpenCase;
                [JsonProperty("IQHeadReward : Убито разыскиваемых")]
                public Int32 IQHeadRewardKillAmount;
                [JsonProperty("IQEconomic : Собрано валюты")]
                public Int32 IQEconomicAmountBalance;
            }
        }
        void ReadData() => DataInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, DataClass>>("IQRankSystem/DataPlayers");
        void WriteData() => Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQRankSystem/DataPlayers", DataInformation);
        void RegisteredDataUser(UInt64 userID)
        {
            if (!DataInformation.ContainsKey(userID))
                DataInformation.Add(userID, new DataClass { RankActive = "", RankAccessList = new List<String> { }, InformationUser = new DataClass.Infromation { GatherAll = 0, GatherDetalis = new Dictionary<String, Int32> { }, TimeGame = 0, IQCasesOpenCase = 0, IQHeadRewardKillAmount = 0, IQEconomicAmountBalance = 0 } });

            foreach (var List in config.RankList.Where(x => x.Value.Obtaining.ObtainingsGathers.UseDetalisGather))
                foreach (var GatherList in List.Value.Obtaining.ObtainingsGathers.GatherDetalis.Where(g => !DataInformation[userID].InformationUser.GatherDetalis.ContainsKey(g.Key)))
                    DataInformation[userID].InformationUser.GatherDetalis.Add(GatherList.Key, 0);
        }
        #endregion

        #region Hooks
        private void Init() => Unsubscribe(nameof(OnPlayerChat));
        private void OnServerInitialized()
        {
            if (!IQChat)
                Subscribe(nameof(OnPlayerChat));
            RegisteredPermissions();
            ReadData();

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            WriteData();
            TrackerTime();
        }
        void OnPlayerConnected(BasePlayer player) => RegisteredDataUser(player.userID);
        object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity as BasePlayer;
            if (player == null) return null;
            if (item == null) return null;
            if (entity == null) return null;
            if (!DataInformation.ContainsKey(player.userID)) return null;
            var Data = DataInformation[player.userID].InformationUser;
            Data.GatherAll += item.amount;
            if (Data.GatherDetalis.ContainsKey(item.info.shortname))
                Data.GatherDetalis[item.info.shortname] += item.amount;
            return null;
        }
        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (player == null) return;
            if (item == null) return;
            if (!DataInformation.ContainsKey(player.userID)) return;
            var Data = DataInformation[player.userID].InformationUser;
            Data.GatherAll += item.amount;
            if (Data.GatherDetalis.ContainsKey(item.info.shortname))
                Data.GatherDetalis[item.info.shortname] += item.amount;
        }
        private void Unload() => WriteData();
        #endregion

        #region Metods

        #region ChatMetods
        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;
            SeparatorChat(channel, player, message);
            return false;
        }
        private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, string Message)
        {
            if (IQChat) return;
            var Data = DataInformation[player.userID];
            String Rank = config.RankList[Data.RankActive].DisplayNameRank;
            String Time = API_GET_TIME_GAME(player.userID);


            String ModifiedChannel = channel == Chat.ChatChannel.Team ? "<color=#a5e664>[Team]</color>" : "";
            String MessageSeparator = String.Format(config.FormatRanks, ModifiedChannel, Time, Rank, player.displayName, Message);
            if (channel == Chat.ChatChannel.Global)
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                    p.SendConsoleCommand("chat.add", new object[] { (int)channel, player.userID, MessageSeparator });
            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) continue;

                    TeamPlayer.SendConsoleCommand("chat.add", channel, player.userID, MessageSeparator);
                }
            }
        }
        #endregion

        public void RankAccess(BasePlayer player)
        {
            var Ranks = config.RankList;
            if (Ranks == null) return;
            var Data = DataInformation[player.userID];
            if (Data == null) return;

            foreach(var Rank in Ranks.Where(r => !Data.RankAccessList.Contains(r.Key) && (String.IsNullOrEmpty(Ranks[r.Key].PermissionRank) || permission.UserHasPermission(player.UserIDString, Ranks[r.Key].PermissionRank))))
            {
                var ObtainingSetup = Rank.Value.Obtaining;
                switch (ObtainingSetup.ObtainingType)
                {
                    case Obtaining.Time:
                        {
                            if (ObtainingSetup.ObtainingsTimes.TimeGame <= Data.InformationUser.TimeGame)
                                SetupRank(player, Rank.Key);
                            break;
                        };
                    case Obtaining.Gather:
                        {
                            if (!ObtainingSetup.ObtainingsGathers.UseDetalisGather)
                            {
                                if (ObtainingSetup.ObtainingsGathers.Amount <= Data.InformationUser.GatherAll)
                                    SetupRank(player, Rank.Key);
                            }
                            else
                            {
                                Int32 ConditionSuccess = 0;
                                foreach (KeyValuePair<String, Int32> DataGather in ObtainingSetup.ObtainingsGathers.GatherDetalis)
                                    if (DataGather.Value <= Data.InformationUser.GatherDetalis[DataGather.Key])
                                        ConditionSuccess++;

                                if (ConditionSuccess == ObtainingSetup.ObtainingsGathers.GatherDetalis.Count)
                                    SetupRank(player, Rank.Key);
                            }
                            break;
                        };
                    case Obtaining.GatherAndTime:
                        {
                            if (!ObtainingSetup.ObtainingsGathers.UseDetalisGather)
                            {
                                if (ObtainingSetup.ObtainingsGathers.Amount <= Data.InformationUser.GatherAll && ObtainingSetup.ObtainingsTimes.TimeGame <= Data.InformationUser.TimeGame)
                                    SetupRank(player, Rank.Key);
                            }
                            else
                            {
                                if (ObtainingSetup.ObtainingsTimes.TimeGame <= Data.InformationUser.TimeGame)
                                {
                                    Int32 ConditionSuccess = 0;
                                    foreach (KeyValuePair<String, Int32> DataGather in ObtainingSetup.ObtainingsGathers.GatherDetalis)
                                        if (DataGather.Value <= Data.InformationUser.GatherDetalis[DataGather.Key])
                                            ConditionSuccess++;

                                    if (ConditionSuccess == ObtainingSetup.ObtainingsGathers.GatherDetalis.Count)
                                        SetupRank(player, Rank.Key);
                                }
                            }
                            break;
                        }
                    case Obtaining.IQCases:
                        {
                            if (!IQCases) return;
                            if(ObtainingSetup.ObtainingsIQCase.OpenCaseAmount <= Data.InformationUser.IQCasesOpenCase)
                                SetupRank(player, Rank.Key);
                            break;
                        }
                    case Obtaining.IQHeadReward:
                        {
                            if (!IQHeadReward) return;
                            if (ObtainingSetup.ObtainingsIQHeadRewards.KillHeadAmount <= Data.InformationUser.IQHeadRewardKillAmount)
                                SetupRank(player, Rank.Key);
                            break;
                        }
                    case Obtaining.IQEconomic:
                        {
                            if (!IQEconomic) return;
                            if (ObtainingSetup.ObtainingsIQEconomics.IQEconomicBalance <= Data.InformationUser.IQEconomicAmountBalance)
                                SetupRank(player, Rank.Key);
                            break;
                        }
                }
            }             
        }
        void SetupRank(BasePlayer player, string RankKey)
        {
            var Data = DataInformation[player.userID];
            string NameRank = config.RankList[RankKey].DisplayNameRank;
            var GeneralSetting = config.Setting.GeneralSetting;

            Data.RankAccessList.Add(RankKey);
            SendChat(player, GetLang("RANK_NEW", player.UserIDString, NameRank));
            if (GeneralSetting.RankSetupNew)
                Data.RankActive = RankKey;
        }
        public void TrackerTime()
        {
            timer.Every(60f, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (!DataInformation.ContainsKey(player.userID))
                        RegisteredDataUser(player.userID);
                    else DataInformation[player.userID].InformationUser.TimeGame += 60;
                    RankAccess(player);
                }
            });
        }

        void RankSetUp(BasePlayer player, string RankName)
        {
            var Data = DataInformation[player.userID];
            string RankKey = config.RankList.FirstOrDefault(r => r.Value.DisplayNameRank.Contains(RankName)).Key;
            if (String.IsNullOrWhiteSpace(RankName) || String.IsNullOrWhiteSpace(RankKey) || !Data.RankAccessList.Contains(RankKey))
            {
                SendChat(player, GetLang("COMMAND_RANK_LIST_NO_ANY", player.UserIDString));
                return;
            }
            Data.RankActive = RankKey;
            SendChat(player, GetLang("COMMAND_RANK_LIST_TO_ACTIVE", player.UserIDString, config.RankList[RankKey].DisplayNameRank));
        }

        #region HelpMetods
        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result = $"{Format(time.Days, "дней", "дня", "день")}";

            if (time.Hours != 0 && time.Days == 0)
                result = $"{Format(time.Hours, "часов", "часа", "час")}";

            if (time.Minutes != 0 && time.Hours == 0 && time.Days == 0)
                result = $"{Format(time.Minutes, "минут", "минуты", "минута")}";

            if (time.Seconds != 0 && time.Days == 0 && time.Minutes == 0 && time.Hours == 0)
                result = $"{Format(time.Seconds, "секунд", "секунды", "секунда")}";

            return result;
        }
        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        #endregion

        #endregion

        #region Commands
        [ChatCommand("rank")]
        void ChatRankCommand(BasePlayer player, string cmd, string[] arg)
        {
            if (arg.Length == 0 || arg == null)
            {
                SendChat(player, GetLang("COMMAND_RANK_NO_ARG", player.UserIDString));
                return;
            }
            string Action = arg[0];
            switch(Action)
            {
                case "list":
                    {
                        if (!DataInformation.ContainsKey(player.userID) || DataInformation[player.userID].RankAccessList.Count == 0)
                        {
                            SendChat(player, GetLang("COMMAND_RANK_LIST_NO_ACCES", player.UserIDString));
                            return;
                        }
                        StringBuilder RankListString = new StringBuilder();
                        var RankList = DataInformation[player.userID].RankAccessList;
                        foreach(string RankMe in RankList.Where(r => config.RankList.ContainsKey(r)))
                        {
                            string NameRankInConfig = config.RankList[RankMe].DisplayNameRank;
                            RankListString.Append($"\n- {NameRankInConfig}");
                        }
                        SendChat(player, GetLang("COMMAND_RANK_LIST", player.UserIDString, RankListString));
                        break;
                    }
                case "add":
                case "take":
                case "set":
                case "setup":
                    {
                        RankSetUp(player, arg[1]);
                        break;
                    }
                case "remove":
                case "clear":
                case "stop":
                case "revoke":
                    {
                        if(!DataInformation.ContainsKey(player.userID) || String.IsNullOrWhiteSpace(DataInformation[player.userID].RankActive))
                        {
                            SendChat(player, GetLang("COMMAND_RANK_LIST_NO_CLEAR", player.UserIDString));
                            return;
                        }
                        DataInformation[player.userID].RankActive = string.Empty;
                        SendChat(player, GetLang("COMMAND_RANK_LIST_CLEAR", player.UserIDString));
                        break;
                    }
            }
        }
        #endregion

        #region Lang    
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["RANK_NEW"] = "Поздравляем, вы получили ранг {0}",

                ["COMMAND_RANK_NO_ARG"] = "\n<size=15>Используйте синтаксис</size>\n- rank list - список доступных рангов" +
                                          "\n- rank add НазваниеРанга - устанавливает нужнный вам ранг" +
                                          "\n- rank remove - очищает ваш активный ранг",
                ["COMMAND_RANK_LIST"] = "\n<size=15>Список доступных рангов:</size>{0}",
                ["COMMAND_RANK_LIST_NO_ACCES"] = "У вас нет доступных рангов",
                ["COMMAND_RANK_LIST_NO_ANY"] = "Вы ввели неправильно название ранга , либо такого ранга у вас нет",
                ["COMMAND_RANK_LIST_TO_ACTIVE"] = "Вы успешно установили себе ранг: {0}",
                ["COMMAND_RANK_LIST_NO_CLEAR"] = "У вас нет установленного ранга",
                ["COMMAND_RANK_LIST_CLEAR"] = "Вы успешно очистили ранг",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["RANK_NEW"] = "Поздравляем, вы получили ранг {0}",

                ["COMMAND_RANK_NO_ARG"] = "\n<size=15>Используйте синтаксис</size>\n- rank list - список доступных рангов" +
                                          "\n- rank add НазваниеРанга - устанавливает нужнный вам ранг" +
                                          "\n- rank remove - очищает ваш активный ранг",
                ["COMMAND_RANK_LIST"] = "\n<size=15>Список доступных рангов:</size>{0}",
                ["COMMAND_RANK_LIST_NO_ACCES"] = "У вас нет доступных рангов",
                ["COMMAND_RANK_LIST_NO_ANY"] = "Вы ввели неправильно название ранга , либо такого ранга у вас нет",
                ["COMMAND_RANK_LIST_TO_ACTIVE"] = "Вы успешно установили себе ранг: {0}",
                ["COMMAND_RANK_LIST_NO_CLEAR"] = "У вас нет установленного ранга",
                ["COMMAND_RANK_LIST_CLEAR"] = "Вы успешно очистили ранг",

            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region API

        string API_GET_RANK_NAME(ulong userID)
        {
            string Rank = DataInformation[userID].RankActive;
            if (!config.RankList.ContainsKey(Rank)) return null;
            string RankDisplayName = config.RankList[Rank].DisplayNameRank;
            return RankDisplayName;
        }
        string API_GET_RANK_NAME(string Key)
        {
            if (!config.RankList.ContainsKey(Key)) return null;
            string Rank = config.RankList[Key].DisplayNameRank;
            return Rank;
        }
        void API_ADD_RANK(UInt64 userID, String Key)
        {
            if (!DataInformation.ContainsKey(userID)) return;
            if (!API_IS_RANK_REALITY(Key)) return;
            DataInformation[userID].RankAccessList.Add(Key);
        }
        bool API_IS_RANK_REALITY(string Key)
        {
            if (!config.RankList.ContainsKey(Key)) return false;
            else return true;
        }
        string API_GET_RANK_PERM(string Key)
        {
            if (!config.RankList.ContainsKey(Key)) return null;
            string RankPermission = config.RankList[Key].PermissionRank;
            return RankPermission;
        }
        bool API_GET_RANK_ACCESS(ulong userID, string Key)
        {
            if (!config.RankList.ContainsKey(Key)) return false;
            string RankPermission = config.RankList[Key].PermissionRank;
            if (String.IsNullOrWhiteSpace(RankPermission)) return true;
            return permission.UserHasPermission(userID.ToString(), RankPermission);
        }
        bool API_GET_AVAILABILITY_RANK_USER(ulong userID, string Key)
        {
            if (!config.RankList.ContainsKey(Key)) return false;
            if (!DataInformation.ContainsKey(userID)) return false;
            var RankAccesList = DataInformation[userID].RankAccessList;
            return RankAccesList.Contains(Key);
        }
        string API_GET_TIME_GAME(ulong userID)
        {
            if (!config.Setting.GeneralSetting.ShowTimeGame) return "";
            string TimeGame = FormatTime(TimeSpan.FromSeconds(DataInformation[userID].InformationUser.TimeGame));
            return TimeGame;
        }
        int API_GET_SECONDGAME(ulong userID)
        {
            string Rank = DataInformation[userID].RankActive;
            if(!config.RankList.ContainsKey(Rank)) return 0;
            int SecondGame = DataInformation[userID].InformationUser.TimeGame;
            return SecondGame;
        }
        List<string> API_RANK_USER_KEYS(ulong userID)
        {
            if (!DataInformation.ContainsKey(userID)) return null;
            List<string> RankList = DataInformation[userID].RankAccessList;
            return RankList;
        }
        void API_SET_ACTIVE_RANK(ulong userID, string RankKey)
        {
            if (!DataInformation.ContainsKey(userID)) return;
            if (String.IsNullOrWhiteSpace(RankKey)) return;
            if (!config.RankList.ContainsKey(RankKey)) return;
            var Data = DataInformation[userID];
            Data.RankActive = RankKey;
            BasePlayer player = BasePlayer.FindByID(userID);
            if (player != null)
                SendChat(player, GetLang("COMMAND_RANK_LIST_TO_ACTIVE", player.UserIDString, config.RankList[RankKey].DisplayNameRank));
        }
        #endregion
    }
}


// --- End of file: IQRankSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XRaidProtection.cs ---
// --- Original Local Path: XRaidProtection.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Oxide.Core.Plugins;
using System.Globalization;

///Скачано с дискорд сервера Rust Edit [PRO+]
///discord.gg/9vyTXsJyKR

namespace Oxide.Plugins
{
    [Info("XRaidProtection", "discord.gg/9vyTXsJyKR", "1.0.9")]
    class XRaidProtection : RustPlugin
	{	
		#region Reference
		
		[PluginReference] private Plugin IQChat;
		
        #endregion
		
	    #region Configuration

        private RaidConfig config;

        private class RaidConfig
        {													
			internal class MessageSetting
			{			
				[JsonProperty("Интервал между сообщениями. Мин - 10 сек")] public int TimeMessage;
			}			
			
			internal class TimeSetting
			{
				[JsonProperty("Начало защиты по МСК | Часы")] public int HourStart;				
				[JsonProperty("Начало защиты по МСК | Минуты")] public int MinuteStart;				
				[JsonProperty("Конец защиты по МСК | Часы")] public int HourEnd;				
				[JsonProperty("Конец защиты по МСК | Минуты")] public int MinuteEnd;
			}			
			
			internal class Settings
			{
				[JsonProperty("Звуковой эффект")] public string Effect;				
				[JsonProperty("Процент защиты для всех игроков. 1.0 - 100%")] public float Damage;				
				[JsonProperty("Включить звуковой эффект")] public bool TEffect;				
				[JsonProperty("Первые N дни активности защиты после вайпа")] public int PDays;				
				[JsonProperty("Защита только в первые N дней после вайпа")] public bool PDay;				
				[JsonProperty("Включить GUI сообщение")] public bool TGUIMessage;				
				[JsonProperty("Включить чат сообщение")] public bool TMessage;				
				[JsonProperty("0 - Защита только для игроков с пермишеном, 1 - Защита для всех игроков, 2 - Защита для игроков с пермишеном и для всех игроков")] public int TypeProtection;
			}			
			
			internal class GUISettings
			{
				[JsonProperty("AnchorMin")] public string AnchorMin;				
				[JsonProperty("AnchorMax")] public string AnchorMax;				
				[JsonProperty("OffsetMin")] public string OffsetMin;				
				[JsonProperty("OffsetMax")] public string OffsetMax;				
				[JsonProperty("Цвет текста")] public string ColorText;				
				[JsonProperty("Размер текста")] public int SizeText;				
				[JsonProperty("Использовать иконки")] public bool Icon;
			}			
			
			internal class PrefabSetting
			{
				[JsonProperty("Префабы")] public List<string> Prefabs;
			}			
			
			internal class PermisssionSetting
			{
				[JsonProperty("Процент защиты по пермишену")] public float PermisssionDamage;
			}
			
			[JsonProperty("Сообщения в чат и GUI")]
            public MessageSetting Message = new MessageSetting();			
			[JsonProperty("Настройка времени действия защиты")]
            public TimeSetting Time = new TimeSetting();			
			[JsonProperty("Общее")]
            public Settings Setting = new Settings();			
			[JsonProperty("Настройка GUI")]
            public GUISettings GUI = new GUISettings();			
			[JsonProperty("Список префабов которые будут под защитой")]
            public PrefabSetting Prefab = new PrefabSetting();
            [JsonProperty("Настройка пермишенов")]			
			public Dictionary<string, PermisssionSetting> Permisssion = new Dictionary<string, PermisssionSetting>();
			[JsonProperty("Дата вайпа")]
            public string DateWipe;
			[JsonProperty("Время по МСК")]			
			public DateTime MSCTime;

			public static RaidConfig GetNewConfiguration()
            {
                return new RaidConfig
                {
					Message = new MessageSetting
					{
						TimeMessage = 30
					},
					Time = new TimeSetting
					{
						HourStart = 22,
						MinuteStart = 0,
						HourEnd = 7,
						MinuteEnd = 0
					},
					Setting = new Settings
					{
						Effect = "assets/bundled/prefabs/fx/invite_notice.prefab",
						Damage = 0.5f,
						TEffect = true,
						PDays = 3,
						PDay = false,
						TGUIMessage = true,
						TMessage = false,
						TypeProtection = 1
						
					},					
					GUI = new GUISettings
					{
						AnchorMin = "0.5 0",
						AnchorMax = "0.5 0",
						OffsetMin = "-194.5 80",
						OffsetMax = "175.5 110",
						ColorText = "1 1 1 0.4",
						SizeText = 12,
						Icon = true
					},
					Prefab = new PrefabSetting
					{
					    Prefabs = new List<string>
					    {
						    "cupboard.tool.deployed",
							"wall.frame.shopfront.metal"
					    }
					},
					Permisssion = new Dictionary<string, PermisssionSetting>
					{
						["xraidprotection.vip"] = new PermisssionSetting
						{
							PermisssionDamage = 0.70f
						}
					}
				}; 
			}			 
		}			

		protected override void LoadConfig()
        {
            base.LoadConfig(); 
			 
			try 
			{ 
				config = Config.ReadObject<RaidConfig>();
			}
			catch  
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = RaidConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{		
			PrintWarning("\n-----------------------------\n" +
			"     Author - Monster\n" +
			"     VK - vk.com/idannopol\n" +
			"     Discord - Monster#4837\n" +
			"     Config - v.2857\n" +
			"-----------------------------");
			
			foreach(var perm in config.Permisssion)
			    permission.RegisterPermission(perm.Key, this);
			
			MSC();
			InitializeLang();
			config.DateWipe = SaveRestore.SaveCreatedTime.ToString("dd/MM/yyyy");
		}
		
		private void OnServerSave() => MSC();
		
		private void MSC()
		{
			webrequest.Enqueue("https://time100.ru/api.php", null, (code, response) =>
            {
                if (code != 200 || response == null) return;
				
			    config.MSCTime = new DateTime(1970, 1, 1, 0, 0, 0, 0).ToLocalTime().AddSeconds(double.Parse(response));
			    Config.WriteObject(config, true);
            }, this);
		} 
		
		private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			if (entity == null || info == null || info.InitiatorPlayer == null) return;
				
			if (config.Setting.TypeProtection == 0 || config.Setting.TypeProtection == 2)
				foreach(var perm in config.Permisssion)
					if(permission.UserHasPermission(entity.OwnerID.ToString(), perm.Key))
					{
					    Protection(entity, info, perm.Value.PermisssionDamage);
						
						return;
					}			
			
			if (config.Setting.TypeProtection == 1 || config.Setting.TypeProtection == 2)
				Protection(entity, info, 1.0f - config.Setting.Damage);		
		}
		
		private void Protection(BaseCombatEntity entity, HitInfo info, float damage)
		{
			if (Time())
			{
				BasePlayer player = info.InitiatorPlayer;
				
				Effect x = new Effect(config.Setting.Effect, player, 0, new Vector3(), new Vector3());
				
		        if (entity is Door || entity is BuildingBlock || entity is SimpleBuildingBlock || config.Prefab.Prefabs.Contains(entity.ShortPrefabName))
			    {				
					info.damageTypes.ScaleAll(damage);
					
					if (Cooldowns.ContainsKey(player))
                        if (Cooldowns[player].Subtract(DateTime.Now).TotalSeconds >= 0) return;
				
		            if (config.Setting.TEffect) EffectNetwork.Send(x, player.Connection);
			        if (config.Setting.TGUIMessage) Message(player);
			        if (config.Setting.TMessage) 
				    	if (IQChat)
				            IQChatPuts(player, lang.GetMessage("CHAT_MESSAGE", this, player.UserIDString));
			            else
			        	    SendReply(player, lang.GetMessage("CHAT_MESSAGE", this, player.UserIDString));
					
				    if (config.Message.TimeMessage < 10)
			    		Cooldowns[player] = DateTime.Now.AddSeconds(10);
				    else
			    		Cooldowns[player] = DateTime.Now.AddSeconds(config.Message.TimeMessage);
			    }
			}
		}
		
		#endregion
		
		#region DateTime
		
		private Dictionary<BasePlayer, DateTime> Cooldowns = new Dictionary<BasePlayer, DateTime>();
		
		private bool Time()
		{ 
			if(config.Setting.PDay)
			{
				DateTime days = config.MSCTime - DateTime.ParseExact(config.DateWipe, "dd/MM/yyyy", CultureInfo.InvariantCulture).Subtract(new DateTime(1970, 1, 1));
				int d = days.Subtract(new DateTime(1970, 1, 1)).Days;
				 
				return config.Setting.PDays >= d;
			}
			else
			{
				var Now = config.MSCTime.TimeOfDay;
				var On = new TimeSpan(config.Time.HourStart, config.Time.MinuteStart, 0);
				var Off = new TimeSpan(config.Time.HourEnd, config.Time.MinuteEnd, 0);
			
				if (On < Off)
					return On <= Now && Now <= Off;
     
				return !(Off < Now && Now < On);
			}
		}
		
		#endregion 
		 
		#region Message

        private void Message(BasePlayer player) 
        {
            CuiHelper.DestroyUi(player, ".MessagePanel");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
				FadeOut = 0.75f,
                RectTransform = { AnchorMin = config.GUI.AnchorMin, AnchorMax = config.GUI.AnchorMax, OffsetMin = config.GUI.OffsetMin, OffsetMax = config.GUI.OffsetMax },
                Text = { FadeIn = 0.75f, Text = lang.GetMessage("UI_MESSAGE", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = config.GUI.SizeText, Color = config.GUI.ColorText }
            }, "Hud", ".MessagePanel");
			
			if (config.GUI.Icon) 
			{
			    container.Add(new CuiButton
                {
				    FadeOut = 0.75f,
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-180 2", OffsetMax = "-154 28" },
                    Button = { Color = "0.8 0.5 0.5 0.8", Sprite = "assets/icons/vote_down.png" },
                    Text = { Text = "" }
                }, ".MessagePanel", ".Icon1");			
			
			    container.Add(new CuiButton
                {
				    FadeOut = 0.75f,
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "154 2", OffsetMax = "180 28" },
                    Button = { Color = "0.8 0.5 0.5 0.8", Sprite = "assets/icons/vote_down.png" },
                    Text = { Text = "" }
                }, ".MessagePanel", ".Icon2");
			}

            CuiHelper.AddUi(player, container);  

            timer.Once(7.5f, () => { CuiHelper.DestroyUi(player, ".MessagePanel"); CuiHelper.DestroyUi(player, ".Icon1"); CuiHelper.DestroyUi(player, ".Icon2"); });
        }

        #endregion
		
		#region Lang
 
        private void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI_MESSAGE"] = "NIGHT RIDING PROTECTION ACTIVE: 80%. FROM 21:30 TO 08:00!",
                ["CHAT_MESSAGE"] = "NIGHT RIDING PROTECTION ACTIVE: 80%. FROM 21:30 TO 08:00!"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI_MESSAGE"] = "АКТИВНА НОЧНАЯ ЗАЩИТА ОТ РЕЙДА: 80%. С 21:30 ДО 08:00!",
                ["CHAT_MESSAGE"] = "АКТИВНА НОЧНАЯ ЗАЩИТА ОТ РЕЙДА: 80%. С 21:30 ДО 08:00!"
            }, this, "ru");
        }

        #endregion
		
		#region IQChat API
		
		private void IQChatPuts(BasePlayer player, string Message) => IQChat?.Call("API_ALERT_PLAYER", player, Message);
		
		#endregion
	}
}

// --- End of file: XRaidProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PrivateZones.cs ---
// --- Original Local Path: PrivateZones.cs ---

using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("PrivateZones", "k1lly0u", "0.1.3", ResourceId = 1703)]
    class PrivateZones : RustPlugin
    {
        [PluginReference]
        Plugin ZoneManager;
		
		[PluginReference]
		Plugin PopupNotifications;

        private bool Changed;

        ZoneDataStorage data;
        private DynamicConfigFile ZoneData;

        private static LayerMask GROUND_MASKS = LayerMask.GetMask("Terrain", "World", "Construction");

        #region oxide hooks
        void Loaded()
        {
            permission.RegisterPermission("privatezones.admin", this);
            lang.RegisterMessages(messages, this);
            ZoneData = Interface.Oxide.DataFileSystem.GetFile("privatezone_data");
        }
        void OnServerInitialized()
        {
            LoadData();
            InitPerms();
        }
        void InitPerms()
        {
            foreach (var entry in data.zones)
            {
                permission.RegisterPermission(entry.Value, this);
            }
        }
        void Unload()
        {
            SaveData();
        }
        #endregion

        #region functions
        private void TPPlayer(BasePlayer player, Vector3 pos)
        {
            player.MovePosition(pos);
            player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
            player.TransformChanged();
            player.SendNetworkUpdateImmediate();
        }
        private Vector3 CalculateOutsidePos(BasePlayer player, string zoneID)
        {
            float distance = 0;
			Vector3 zonePos = (Vector3) ZoneManager?.Call("GetZoneLocation", new object[] { zoneID });
			object zoneRadius = ZoneManager?.Call("GetZoneRadius", new object[] { zoneID });
            Vector3 zoneSize = (Vector3) ZoneManager?.Call("GetZoneSize", new object[] { zoneID });
			var playerPos = player.transform.position;
            var cachedDirection = playerPos - zonePos;
			if (zoneSize != Vector3.zero)
                distance = zoneSize.x > zoneSize.z ? zoneSize.x : zoneSize.z;
            else
				distance = (float)zoneRadius;
			
			var newPos = zonePos + (cachedDirection / cachedDirection.magnitude * (distance + 2f));
            newPos.y = TerrainMeta.HeightMap.GetHeight(newPos);
            return newPos;
        }
        static Vector3 CalculateGroundPos(Vector3 sourcePos) // credit Wulf & Nogrod
        {
            RaycastHit hitInfo;

            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, GROUND_MASKS))
            {
                sourcePos.y = hitInfo.point.y;
            }
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }

        #endregion
        #region zonemanager hooks
        //////////////////////////////////////////////////////////////////////////////////////
        // ZoneManager Hooks /////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
               
        void OnEnterZone(string ZoneID, BasePlayer player)
        {            
            if (player == null || string.IsNullOrEmpty(ZoneID)) return;
            if (player.IsSleeping()) return; 
            if (data.zones.ContainsKey(ZoneID))
            {
                string perm = data.zones[ZoneID];
                if (permission.UserHasPermission(player.userID.ToString(), perm) || isAuth(player)) return;                
				if (PopupNotifications)
                    PopupNotifications?.Call("CreatePopupNotification", lang.GetMessage("noPerms", this, player.UserIDString), player);
                else SendMsg(player, lang.GetMessage("noPerms", this, player.UserIDString));
                Vector3 newPos = CalculateOutsidePos(player, ZoneID);
                TPPlayer(player, newPos);
            }
        }
        #endregion

        #region chat commands
        [ChatCommand("pz")]
        private void cmdPZ(BasePlayer player, string command, string[] args)
        {
            if (!hasPermission(player)) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, lang.GetMessage("synAdd", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synRem", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synList", this, player.UserIDString));
                return;
            }
            switch (args[0].ToLower())
            {
                case "add":
                    if (args.Length == 3)
                    {
                        object zoneid = ZoneManager.Call("CheckZoneID", new object[] { args[1] });

                        if (zoneid is string && (string)zoneid != "")
                        {
                            string perm = args[2].ToLower();
                            if (!perm.StartsWith("privatezones."))
                                perm = "privatezones." + perm;
                            Puts(perm);

                            data.zones.Add((string)zoneid, perm);

                            SendMsg(player, string.Format(lang.GetMessage("newZone", this, player.UserIDString), (string)zoneid, perm));
                            permission.RegisterPermission(perm, this);
                            SaveData();
                            return;
                        }
                        SendMsg(player, lang.GetMessage("invID", this, player.UserIDString));
                        return;
                    }
                    SendMsg(player, lang.GetMessage("synError", this, player.UserIDString));
                    return;
                case "remove":
                    if (args.Length == 2)
                    {
                        if (data.zones.ContainsKey(args[1].ToLower()))
                        {
                            data.zones.Remove(args[1].ToLower());
                            SendMsg(player, string.Format(lang.GetMessage("remZone", this, player.UserIDString), args[1]));
                            SaveData();
                            return;
                        }
                        SendMsg(player, lang.GetMessage("invID", this, player.UserIDString));
                        return;
                    }
                    SendMsg(player, lang.GetMessage("synError", this, player.UserIDString));
                    return;
                case "list":
                    foreach(var entry in data.zones)
                    {
                        SendReply(player, string.Format(lang.GetMessage("list", this, player.UserIDString), entry.Key, entry.Value));
                    }
                    return;
            }
        }
        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel != 2) return false;
            return true;
        }
        bool hasPermission(BasePlayer player)
        {
            if (isAuth(player)) return true;
            else if (permission.UserHasPermission(player.userID.ToString(), "privatezones.admin")) return true;
            return false;
        }
        #endregion

        #region data
        //////////////////////////////////////////////////////////////////////////////////////
        // Data Management ///////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        void SaveData()
        {
            ZoneData.WriteObject(data);
        }
        void LoadData()
        {
            try
            {
                data = Interface.GetMod().DataFileSystem.ReadObject<ZoneDataStorage>("privatezone_data");
            }
            catch
            {
                data = new ZoneDataStorage();
            }
        }
        class ZoneDataStorage
        {
            public Dictionary<string, string> zones = new Dictionary<string, string>();
            public ZoneDataStorage() { }
        }
        #endregion
        #region messages
        private void SendMsg(BasePlayer player, string msg)
        {
            SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("MsgColor", this, player.UserIDString) + msg + "</color>");
        }
        private Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "<color=#afff00>PrivateZones:</color> " },
            {"list", "ZoneID: {0}, Permission: {1}" },
            {"synError", "Syntax Error" },
            {"invID", "Invalid ZoneID" },
            {"remZone", "Removed Zone: {0}" },
            {"newZone", "Created new private zone for ZoneID: {0}, using permission: {1}" },
            {"synAdd", "/pz add <zoneid> <permission>" },
            {"synRem", "/pz remove <zoneid>" },
            {"synList", "/pz list" },
            {"noPerms", "You don't have permission to enter this zone, bought a HL Pass or become a VIP." },
            {"MsgColor", "<color=#d3d3d3>" }
        };
        #endregion

    }
}


// --- End of file: PrivateZones.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RSVote.cs ---
// --- Original Local Path: RSVote.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RustServer.gg Vote", "NightHawk@Codefling", "1.2.2")]
    [Description("Voting reward plugin for RustServers.gg")]
    public class RSVote: RustPlugin
    {
        #region Vars

        private Dictionary<ulong, DateTime> cooldown = new Dictionary<ulong, DateTime>();

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            foreach (var command in config.commands)
            {
                cmd.AddChatCommand(command, this, cmdChat);
            }
            
            timer.Every(Core.Random.Range(300, 500), () => { cooldown.Clear(); });
            Puts($"Loaded server with id '{config.serverId}'");
        }

        #endregion

        #region Commands

        private void cmdChat(BasePlayer player, string command, string[] args)
        {
            if (cooldown.ContainsKey(player.userID) == true)
            {
                var nextUse = cooldown[player.userID];
                if (nextUse > DateTime.UtcNow)
                {
                    player.ChatMessage("Cooldown...");
                    return;
                }

                cooldown[player.userID] = DateTime.UtcNow.AddSeconds(5);
            }
            else
            {
                cooldown.Add(player.userID, DateTime.UtcNow.AddSeconds(5));
            }

            player.ChatMessage("Trying to claim reward...");
            var url = CheckUrl(player.UserIDString);
            Execute(url, "status", player);
        }

        #endregion

        #region Core

        private string CheckUrl(string steamId)
        {
            return BuildUrl("status", steamId);
        }

        private string ClaimUrl(string steamId)
        {
            return BuildUrl("claim", steamId);
        }

        private string BuildUrl(string action, string userId)
        {
            var url = ConfigData.baseUrl;
            url += $"action={action}";
            url += $"&key={config.apiKey}";
            url += $"&server={config.serverId}";
            url += $"&steamid={userId}";
            return url;
        }

        private void Execute(string url, string action, BasePlayer player)
        {
            webrequest.Enqueue(url, null, (i, s) => { HandleResponse(url, i, s, action, player); }, this);
        }

        private void HandleResponse(string url, int code, string response, string action, BasePlayer player)
        {
            var rInt = 0;
            if (int.TryParse(response, out rInt) == false)
            {
                PrintWarning($"Failed to parse response from '{response}'");
                return;
            }

            if (action == "status")
            {
                switch (rInt)
                {
                    case 0:
                        player.ChatMessage($"Vote at the servers page to claim reward!\n" +
                                           $"https://rustservers.gg/server/{config.serverId}");
                        break;

                    case 1:
                        GiveRandomReward(player);
                        break;

                    case 2:
                        player.ChatMessage("You already claimed your reward(s)");
                        break;
                }
            }

            if (action == "claim")
            {
                switch (rInt)
                {
                    case 0:
                        // Ignore
                        break;

                    case 1:
                        // Ignore
                        break;

                    case 2:
                        // Ignore
                        break;
                }
            }
        }

        private void GiveRandomReward(BasePlayer player)
        {
            IReward reward;
            if (Core.Random.Range(0, 101) > 50)
            {
                reward = config.rewardCommands.GetRandom();
            }
            else
            {
                reward = config.rewardItems.GetRandom();
            }

            var userId = player.UserIDString;
            var result = reward.GiveTo(userId);
            if (result == false)
            {
                PrintWarning($"Failed to give reward to '{userId}' ({reward.Info()})");
                player.ChatMessage("Failed to claim reward, please contact the server owner!");
                return;
            }

            Puts($"Player {userId} received reward for voting");
            player.ChatMessage($"You received {reward.Info()} for voting!");
            var url = ClaimUrl(userId);
            Execute(url, "claim", player);
        }

        #endregion

        #region Config

        private class ConfigData
        {
            [JsonProperty("API Key")] 
            public string apiKey = string.Empty;

            [JsonProperty("Server Id")] 
            public string serverId = string.Empty;

            [JsonProperty("Chat Commands")] 
            public string[] commands =
            {
                "claim",
                "vote",
                "votes",
            };

            [JsonProperty("Reward items")] 
            public RewardItem[] rewardItems = new[]
            {
                new RewardItem
                {
                    shortname = "wood",
                    amountMin = 1000,
                    amountMax = 2000,
                },
                new RewardItem
                {
                    shortname = "stones",
                    amountMin = 1000,
                    amountMax = 2000,
                },
                new RewardItem
                {
                    shortname = "metal.refined",
                    amountMin = 1000,
                    amountMax = 2000,
                },
            };

            [JsonProperty("Reward Commands Help")] 
            public string commandHelp = "use {steamid} to add user steam id\n" +
                                        "Examples:\n" +
                                        "sr add {steamid} 10 - to add ServerRewards points\n" +
                                        "deposit {steamid} 10 - to add Economics points\n";

            [JsonProperty("Reward Commands")] 
            public RewardCommand[] rewardCommands = new[]
            {
                new RewardCommand(),
                new RewardCommand(),
                new RewardCommand()
            };

            [JsonIgnore] 
            public const string baseUrl = "https://rustservers.gg/vote-api.php?";
        }

        private static ConfigData config = new ConfigData();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Rewards

        private interface IReward
        {
            bool GiveTo(string userId);

            string Info();
        }

        private class RewardItem : IReward
        {
            [JsonProperty("Item Shortname")] public string shortname;
            [JsonProperty("Description")] public string description;

            [JsonProperty("Item Amount Min")] public int amountMin;

            [JsonProperty("Item Amount Max")] public int amountMax;

            [JsonProperty("Item Skin id")] public ulong skinId;

            public Item GetItem()
            {
                var def = ItemManager.FindItemDefinition(shortname);
                if (def == null)
                {
                    return null;
                }

                var amount = amountMax > amountMin
                    ? Core.Random.Range(amountMin, amountMax)
                    : Core.Random.Range(amountMax, amountMin);

                var item = ItemManager.Create(def, amount);
                if (item == null)
                {
                    return null;
                }

                item.skin = skinId;
                return item;
            }

            public bool GiveTo(string userId)
            {
                var player = BasePlayer.Find(userId);
                if (player == null)
                {
                    return false;
                }

                var item = GetItem();
                if (item == null)
                {
                    return false;
                }

                player.GiveItem(item);
                return true;
            }

            public string Info()
            {
                return $"Item: {description}";
            }
        }

        private class RewardCommand : IReward
        {
            [JsonProperty("Command")] public string command = "example {steamid} 1d";
            [JsonProperty("Description")] public string description = "example Description (will appear on Message)";
            [JsonProperty("Type")] public string type = "example type of Reward (Kit, Permission etc.)";

            public bool GiveTo(string userId)
            {
                var cmd = command;
                cmd = cmd.Replace("{steamid}", userId, StringComparison.OrdinalIgnoreCase);
                cmd = cmd.Replace("{steam}", userId, StringComparison.OrdinalIgnoreCase);
                cmd = cmd.Replace("{id}", userId, StringComparison.OrdinalIgnoreCase);
                ConsoleSystem.Run(ConsoleSystem.Option.Server, cmd);
                return true;
            }

            public string Info()
            {
                return $"{type}: {description}";
            }
        }

        #endregion
    }
}

// --- End of file: RSVote.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutomatedSearchlights.cs ---
// --- Original Local Path: AutomatedSearchlights.cs ---

﻿//Requires: RustNET
using Facepunch;
using Rust;
using System.Collections.Generic;
using System.Diagnostics;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("AutomatedSearchlights", "k1lly0u", "0.2.30")]
    [Description("Create searchlights that will automatically turn on and follow a variety of objects")]
    class AutomatedSearchlights : RustPlugin
    {
        #region Fields
        private StoredData storedData;
        private DynamicConfigFile data;

        private static AutomatedSearchlights ins;
        private static LinkManager linkManager;
        private static int ctrlLayerMask;

        private FrameBudgeter frameBudgeter;

        private bool wipeDetected;
        private bool automationEnabled;
        private bool isInitialized;
        private bool nlConsume;

        private const string PERM_USE = "automatedsearchlights.use";
        private const string PERM_IGNORE = "automatedsearchlights.ignorelimit";

        private const string FX_OFFLINE = "assets/prefabs/npc/autoturret/effects/offline.prefab";
        private const string FX_ONLINE = "assets/prefabs/npc/autoturret/effects/online.prefab";
        private const string FX_ACQUIRED = "assets/prefabs/npc/autoturret/effects/targetacquired.prefab";
        private const string FX_LOST = "assets/prefabs/npc/autoturret/effects/targetlost.prefab";

        private const string ASUI_OVERLAY = "ASUI_Overlay";
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission(PERM_USE, this);
            permission.RegisterPermission(PERM_IGNORE, this);
            foreach (string key in configData.Management.Max.Keys)
            {
                if (permission.PermissionExists(key, this))
                    continue;
                permission.RegisterPermission(key, this);
            }

            lang.RegisterMessages(Messages, this);
            data = Interface.Oxide.DataFileSystem.GetFile("RustNET/searchlights");

            linkManager = new LinkManager();
        }

        private void OnServerInitialized()
        {
            ins = this;

            frameBudgeter = new GameObject("AutomatedSearchlights.FrameBudgeter").AddComponent<FrameBudgeter>();
            LightManager.allManagers = new List<LightManager>();

            LoadData();

            ctrlLayerMask = LayerMask.GetMask("Default", "Water", "Deployed", "AI", "Player_Movement", "Vehicle_Movement", "World", "Player_Server", "Construction", "Terrain", "Clutter", "Debris", "Tree");
                        
            if (wipeDetected)
            {
                storedData = new StoredData();
                SaveData();
            }

            MonitorTime(true);

            LoadDefaultImages();

            InvokeHandler.Invoke(ServerMgr.Instance, InitializeAllLinks, 10f);

            RustNET.RegisterModule(Title, this);

            if (!configData.Management.AutoRegister)
                Unsubscribe(nameof(OnEntitySpawned));
        }

        private void OnNewSave(string filename) => wipeDetected = true;

        private void OnServerSave() => SaveData();

        private void OnEntitySpawned(SearchLight searchLight)
        {
            if (searchLight == null)
                return;

            BasePlayer owner = BasePlayer.FindByID(searchLight.OwnerID);
            if (owner == null)
                return;

            BuildingManager.Building building = RustNET.GetBuilding(searchLight);
            if (building == null)
                return;

            if (!building.GetDominatingBuildingPrivilege()?.IsAuthed(owner) ?? false)            
                return;

            RustNET.LinkManager.Link link = RustNET.linkManager.GetLinkOf(building);
            if (link == null)            
                return;            

            if (Vector3.Distance(searchLight.transform.position, link.terminal.DroppedItem.transform.position) > configData.Management.DistanceFromTerminal)            
                return;            

            LinkManager.LightLink lightLink = linkManager.GetLinkOf(link.terminal.TerminalID);
            if (lightLink == null)
                lightLink = new LinkManager.LightLink(link.terminal.TerminalID, searchLight, "");
            else
            {
                int lightLimit = GetMaxLights(owner.userID);
                if (!permission.UserHasPermission(owner.UserIDString, PERM_IGNORE) && lightLink.Managers.Count >= lightLimit)                
                    return;                

                lightLink.AddLightToLink(searchLight, link.terminal.TerminalID, "");
            }

            searchLight.GetComponent<LightManager>().ToggleAutomation(automationEnabled);

            SendReply(owner, msg("Success.Set", owner.userID));
            SaveData();
        }

        private void OnEntityKill(BaseNetworkable networkable)
        {
            if (networkable != null)
                linkManager.OnEntityDeath(networkable);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            Controller controller = player.GetComponent<Controller>();
            if (controller != null)
            {
                LinkManager.LightLink link = linkManager.GetLinkOf(controller);
                if (link != null)
                    link.CloseLink(controller);
            }
        }

        private object OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (player != null && player.GetComponent<Controller>())
                return false;
            return null;
        }

        private object OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
        {
            Controller controller = player.GetComponent<Controller>();
            if (controller != null)
                return false;
            return null;
        }

        private void Unload()
        {
            UnityEngine.Object.Destroy(frameBudgeter.gameObject);

            if (InvokeHandler.IsInvoking(ServerMgr.Instance, InitializeAllLinks))
                InvokeHandler.CancelInvoke(ServerMgr.Instance, InitializeAllLinks);

            if (isInitialized)
                SaveData();

            linkManager.DestroyAllLinks();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, ASUI_OVERLAY);

            LightManager.allManagers?.Clear();
            LightManager.allManagers = null;

            ins = null;
            linkManager = null;
        }
        #endregion

        #region Functions
        private void InitializeAllLinks()
        {
            for (int i = storedData.registeredSearchlights.Length - 1; i >= 0; i--)
            {
                LightManager.LightData lightData = storedData.registeredSearchlights.ElementAt(i);

                SearchLight searchLight = BaseEntity.serverEntities.Find(lightData.lightId) as SearchLight;
                if (searchLight == null || (lightData.terminalId != 0 && !RustNET.linkManager.IsValidTerminal(lightData.terminalId)))                
                    continue;                

                LinkManager.LightLink link = linkManager.GetLinkOf(lightData.terminalId);
                if (link == null)
                    link = new LinkManager.LightLink(lightData.terminalId, searchLight, lightData.lightName);
                else link.AddLightToLink(searchLight, lightData.terminalId, lightData.lightName);
            }
            MonitorTime(true);
            isInitialized = true;
        }

        private void MonitorTime(bool firstLoad = false)
        {
            if (!configData.Options.NightOnly)
            {
                automationEnabled = true;
                return;
            }

            float currentTime = TOD_Sky.Instance.Cycle.Hour;

            bool isNight = (currentTime > 0 && currentTime < configData.Options.Sunrise) || currentTime > configData.Options.Sunset;

            if (automationEnabled != isNight || firstLoad)
            {
                automationEnabled = isNight;
                ServerMgr.Instance.StartCoroutine(ToggleAllLights(automationEnabled));
            }
            timer.In(10, ()=> MonitorTime());
        }

        private IEnumerator ToggleAllLights(bool status)
        {
            foreach(LinkManager.LightLink link in linkManager.links)
            {
                foreach(LightManager manager in link.Managers)
                {
                    yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 0.2f));

                    if (manager == null)
                        continue;

                    manager.ToggleAutomation(status);
                }
            }            
        }       
             
        private int GetMaxLights(ulong playerId)
        {
            int max = 0;
            foreach (var entry in configData.Management.Max)
            {
                if (permission.UserHasPermission(playerId.ToString(), entry.Key))
                {
                    if (max < entry.Value)
                        max = entry.Value;
                }
            }
            return max;
        }
        #endregion

        #region RustNET Integration       
        private void DestroyAllLinks() => linkManager.DestroyAllLinks();        

        private void OnLinkShutdown(int terminalId)
        {
            LinkManager.LightLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
                link.OnLinkTerminated(false);
        }

        private void OnLinkDestroyed(int terminalId)
        {
            LinkManager.LightLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
                link.OnLinkTerminated(true);
        }

        private LightManager[] GetAvailableSearchlights(int terminalId)
        {
            LinkManager.LightLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
                return link.Managers.ToArray();
            return new LightManager[0];
        }

        private bool IsEntityEnabled(int terminalId, uint managerId)
        {
            LinkManager.LightLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
            {
                LightManager manager = link.Managers.Find(x => x.Searchlight.net.ID == managerId);
                if (manager != null)
                    return manager.IsEnabled();
            }
            return false;
        }

        private void InitializeController(BasePlayer player, uint managerId, int terminalId)
        {
            LinkManager.LightLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
                link.InitiateLink(player, managerId);
        }

        private void ToggleAutomation(uint managerId, int terminalId, bool active)
        {
            LinkManager.LightLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
            {
                LightManager manager = link.Managers.Find(x => x.Searchlight.net.ID == managerId);
                if (manager != null)
                {
                    manager.ToggleSearchAutomation(active);
                }
            }
        }

        private string GetHelpString(ulong playerId, bool title) => title ? msg("UI.Help.Title", playerId) : msg("UI.Help", playerId);

        private bool AllowPublicAccess() => true;
        #endregion

        #region Component
        private class LinkManager
        {
            public List<LightLink> links = new List<LightLink>();

            public LightLink GetLinkOf(LightManager manager) => links.Find(x => x.Managers.Contains(manager)) ?? null;

            public LightLink GetLinkOf(Controller controller) => links.Find(x => x.Controllers.Contains(controller)) ?? null;

            public LightLink GetLinkOf(int terminalId) => links.Find(x => x.TerminalID == terminalId) ?? null;

            public LightLink GetLinkOf(SearchLight searchLight)
            {
                LightManager component = searchLight.GetComponent<LightManager>();
                if (component == null)
                    return null;
                return GetLinkOf(component);
            }

            public void OnEntityDeath(BaseNetworkable networkable)
            {
                for (int i = links.Count - 1; i >= 0; i--)
                    links.ElementAt(i).OnEntityDeath(networkable);
            }

            public void DestroyAllLinks()
            {
                foreach (LightLink link in links)
                    link.OnLinkTerminated(false);
            }

            public class LightLink
            {
                public int TerminalID { get; private set; }
                public List<Controller> Controllers { get; private set; }
                public List<LightManager> Managers { get; private set; }

                public LightLink() { }
                public LightLink(int terminalId, SearchLight searchLight, string lightName)
                {
                    this.TerminalID = terminalId;
                    this.Controllers = new List<Controller>();
                    this.Managers = new List<LightManager>();

                    AddLightToLink(searchLight, terminalId, lightName);
                    linkManager.links.Add(this);
                }

                public void AddLightToLink(SearchLight searchLight, int terminalId, string lightName)
                {
                    LightManager manager = searchLight.gameObject.AddComponent<LightManager>();
                    manager.lightName = lightName;
                    manager.terminalId = terminalId;
                    Managers.Add(manager);
                }

                public void InitiateLink(BasePlayer player, uint managerId)
                {
                    LightManager manager = Managers.FirstOrDefault(x => x.Searchlight.net.ID == managerId);
                    if (manager != null)
                    {
                        player.inventory.crafting.CancelAll(true);
                        Controller controller = player.gameObject.AddComponent<Controller>();
                        Controllers.Add(controller);
                        controller.InitiateLink(TerminalID);
                        controller.SetLightLink(this);
                        controller.SetSpectateTarget(Managers.IndexOf(manager));
                    }
                }

                public void CloseLink(Controller controller, bool isDead = false)
                {
                    if (controller != null)
                    {                        
                        Controllers.Remove(controller);
                        controller.FinishSpectating(isDead);
                    }
                }

                public void OnEntityDeath(BaseNetworkable networkable)
                {
                    LightManager manager = networkable.GetComponent<LightManager>();
                    if (manager != null && Managers.Contains(manager))
                    {
                        if (manager.Controller != null)
                        {
                            manager.Controller.player.ChatMessage(ins.msg("Warning.SearchlightDestroyed", manager.Controller.player.userID));
                            CloseLink(manager.Controller);
                        }
                        Managers.Remove(manager);
                        return;
                    }

                    if (networkable.GetComponent<BaseCombatEntity>())
                    {
                        foreach (LightManager lightManager in Managers)
                            lightManager.OnEntityDeath(networkable as BaseCombatEntity);
                    }
                }

                public void OnLinkTerminated(bool isDestroyed)
                {
                    for (int i = Controllers.Count - 1; i >= 0; i--)
                    {
                        Controller controller = Controllers.ElementAt(i);
                        controller.player.ChatMessage(isDestroyed ? ins.msg("Warning.TerminalDestroyed", controller.player.userID) : ins.msg("Warning.TerminalShutdown", controller.player.userID));
                        CloseLink(controller);
                    }

                    DestroyLightManagers(isDestroyed);
                }

                private void DestroyLightManagers(bool isDestroyed)
                {
                    foreach (LightManager manager in Managers)
                    {                        
                        UnityEngine.Object.Destroy(manager);
                    }
                }
            }
        }

        private class FrameBudgeter : MonoBehaviour
        {
            private double maxMilliseconds = 0.2;

            private Stopwatch sw = Stopwatch.StartNew();

            private int lastIndex = 0;

            private void Update()
            {
                sw.Reset();
                sw.Start();

                int count = LightManager.allManagers?.Count ?? 0;
                if (lastIndex >= count)
                    lastIndex = 0;

                for (int i = lastIndex; i < count; i++)
                {
                    if (sw.Elapsed.TotalMilliseconds > maxMilliseconds)
                    {
                        lastIndex = i;
                        return;
                    }

                    LightManager.allManagers[i].DoUpdate();
                }

                lastIndex = 0;
            }
        }

        private class LightManager : MonoBehaviour
        {
            internal static List<LightManager> allManagers;

            public SearchLight Searchlight { get; private set; }
            public Controller Controller { get; private set; }

            private SphereCollider collider;
            private Rigidbody rb;

            private BaseCombatEntity targetEntity;
            private float maxTargetDistance;
            private int threatLevel = 10;

            private float searchRadius;
            private bool requiresPower;
            private ConfigData.LightOptions.FlickerMode flicker;
            private ConfigData.LightOptions.SearchMode search;
            private ConfigData.DetectionOptions detection;

            private Hash<int, HashSet<BaseCombatEntity>> threats;
            private Hash<int, float> threatRadius;

            private float[] visabilityOffsets = new float[] { 0, 0.2f, -0.2f };

            private float nextCheckTime;
            private float threatProbabilityRate;

            private float idleTime = 0;
            private float lostTargetTime = 0;

            private Vector3[] searchPattern = new Vector3[9];
            private int lastSearchPoint = 0;
            private int nextSearchPoint = 1;
            private bool searchForwards;
         
            private float searchTime;
            private bool resetSearch = true;
            private bool isSearching;

            public string lightName;
            public int terminalId;

            public bool isDisabled;            

            private void Awake()
            {
                Searchlight = GetComponent<SearchLight>();

                threatProbabilityRate = 3f + UnityEngine.Random.Range(0.1f, 1.0f);

                InitializeSettings();

                allManagers.Add(this);
            }

            internal void DoUpdate()
            {
                if (Searchlight.IsMounted() || Searchlight.HasFlag(BaseEntity.Flags.Reserved5) || !Searchlight.IsPowered())                
                    return;

                if (Controller != null && !Controller.lightsOn)
                    return;

                if (!flicker.Enabled)
                {
                    if (!Searchlight.IsOn())
                        Searchlight.SetFlag(BaseEntity.Flags.On, true);
                }
                else
                {
                    float healthPercent = Searchlight.health / Searchlight.MaxHealth();
                    if (healthPercent * 100 <= flicker.Health)
                    {
                        if (healthPercent * 100 <= flicker.Health / 2)
                            Searchlight.SetFlag(BaseEntity.Flags.On, UnityEngine.Random.Range(1, 5) != 2);
                        else Searchlight.SetFlag(BaseEntity.Flags.On, UnityEngine.Random.Range(1, 10) != 2);
                    }
                    else
                    {
                        if (!Searchlight.IsOn())
                            Searchlight.SetFlag(BaseEntity.Flags.On, true);
                    }
                }

                if (Controller != null)
                    return;
                else
                {
                    nextCheckTime += Time.deltaTime;
                    if (nextCheckTime > threatProbabilityRate)
                    {
                        CalculateThreatProbability();
                        nextCheckTime = 0;
                    }

                    if (targetEntity == null)
                    {
                        if (search.Enabled)
                        {
                            idleTime += Time.deltaTime;

                            if (idleTime > 3f)
                            {
                                if (isSearching)
                                {
                                    searchTime = searchTime + Time.deltaTime;
                                    var single = Mathf.InverseLerp(0f, search.Speed / 9, searchTime);

                                    Searchlight.SetTargetAimpoint(Vector3.Lerp(searchPattern[lastSearchPoint], searchPattern[nextSearchPoint], single));
                                    Searchlight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                                    if (single >= 1)
                                    {
                                        searchTime = 0;
                                        SetNextSearchPoint();
                                    }
                                }
                                else if (resetSearch)
                                {
                                    lastSearchPoint = 4;
                                    nextSearchPoint = searchForwards ? 5 : 3;
                                    searchTime = 0;
                                    Searchlight.SetTargetAimpoint(searchPattern[4]);
                                    Searchlight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                                    resetSearch = false;
                                    isSearching = true;
                                }
                            }
                        }
                    }
                    else
                    {
                        if (IsObjectVisible(targetEntity) && Vector3.Distance(Searchlight.transform.position, targetEntity.transform.position) <= maxTargetDistance)
                        {
                            Searchlight.SetTargetAimpoint(targetEntity.transform.position);
                            Searchlight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            lostTargetTime = 0;
                        }
                        else
                        {
                            lostTargetTime += Time.deltaTime;
                            if (lostTargetTime > 3f)
                                ClearAimTarget();
                        }
                    }
                }
            }
                        
            private void OnDestroy()
            {
                Destroy(collider);
                Destroy(rb);

                allManagers?.Remove(this);
            }
              
            private void OnTriggerEnter(Collider col)
            {
                BaseCombatEntity potentialTarget = col.gameObject?.GetComponentInParent<BaseCombatEntity>();
                if (potentialTarget == null || potentialTarget.IsDestroyed)
                    return;

                float threatDistance = Vector3.Distance(Searchlight.transform.position, potentialTarget.transform.position);

                if (potentialTarget is BasePlayer)
                {
                    if (RustNET.IsFriendlyPlayer(Searchlight.OwnerID, potentialTarget.ToPlayer().userID))
                    {
                        if (detection.Friends.Enabled && threatDistance <= detection.Friends.Radius)
                        {
                            if (threats[detection.Friends.Threat].Contains(potentialTarget))
                                return;
                            threats[detection.Friends.Threat].Add(potentialTarget);
                        }
                    }
                    else if (detection.Enemies.Enabled && threatDistance <= detection.Enemies.Radius)
                    {
                        if (threats[detection.Enemies.Threat].Contains(potentialTarget))
                            return;
                        threats[detection.Enemies.Threat].Add(potentialTarget);
                    }
                }
                else if (potentialTarget is BaseNpc)
                {
                    if (detection.Animals.Enabled && threatDistance <= detection.Animals.Radius)
                    {
                        if (threats[detection.Animals.Threat].Contains(potentialTarget))
                            return;
                        threats[detection.Animals.Threat].Add(potentialTarget);
                    }
                }
                else if (potentialTarget is BasicCar || potentialTarget is BradleyAPC)
                {
                    if (detection.Vehicles.Enabled && threatDistance <= detection.Vehicles.Radius)
                    {
                        if (threats[detection.Vehicles.Threat].Contains(potentialTarget))
                            return;
                        threats[detection.Vehicles.Threat].Add(potentialTarget);
                    }
                }
                else if (potentialTarget is BaseHelicopter)
                {
                    if (detection.Helicopters.Enabled && threatDistance <= detection.Helicopters.Radius)
                    {
                        if (threats[detection.Helicopters.Threat].Contains(potentialTarget))
                            return;
                        threats[detection.Helicopters.Threat].Add(potentialTarget);
                    }
                }                
            }

            private void OnTriggerExit(Collider col)
            {
                BaseCombatEntity potentialTarget = col.gameObject.GetComponent<BaseCombatEntity>();
                if (potentialTarget == null)
                    return;

                foreach(var threatType in threats)
                {
                    if (threatType.Value.Contains(potentialTarget))
                    {
                        threatType.Value.Remove(potentialTarget);
                        break;
                    }
                }

                if (potentialTarget == targetEntity)
                    ClearAimTarget();
            }

            private void InitializeSettings()
            {
                requiresPower = ins.configData.Options.RequirePower;
                flicker = ins.configData.Options.Flicker;
                search = ins.configData.Options.Search;
                detection = ins.configData.Detection;

                searchRadius = detection.Animals.Radius;
                if (detection.Enemies.Radius > searchRadius)
                    searchRadius = detection.Enemies.Radius;
                if (detection.Friends.Radius > searchRadius)
                    searchRadius = detection.Friends.Radius;
                if (detection.Helicopters.Radius > searchRadius)
                    searchRadius = detection.Helicopters.Radius;
                if (detection.Vehicles.Radius > searchRadius)
                    searchRadius = detection.Vehicles.Radius;

                if (search.Enabled)
                    GenerateSearchPattern();

                threats = new Hash<int, HashSet<BaseCombatEntity>>
                {
                    [detection.Animals.Threat] = new HashSet<BaseCombatEntity>(),
                    [detection.Enemies.Threat] = new HashSet<BaseCombatEntity>(),
                    [detection.Friends.Threat] = new HashSet<BaseCombatEntity>(),
                    [detection.Helicopters.Threat] = new HashSet<BaseCombatEntity>(),
                    [detection.Vehicles.Threat] = new HashSet<BaseCombatEntity>()
                };

                threatRadius = new Hash<int, float>
                {
                    [detection.Animals.Threat] = detection.Animals.Radius,
                    [detection.Enemies.Threat] = detection.Enemies.Radius,
                    [detection.Friends.Threat] = detection.Friends.Radius,
                    [detection.Helicopters.Threat] = detection.Helicopters.Radius,
                    [detection.Vehicles.Threat] = detection.Vehicles.Radius
                };

                rb = Searchlight.gameObject.AddComponent<Rigidbody>();
                rb.useGravity = false;
                rb.isKinematic = true;

                collider = Searchlight.gameObject.AddComponent<SphereCollider>();
                collider.gameObject.layer = (int)Layer.Reserved1;
                collider.radius = searchRadius;
                collider.isTrigger = true;
            }

            private void GenerateSearchPattern()
            {
                int count = 0;
                for (int i = -40; i <= 40; i += 10)
                {
                    searchPattern[count] = Searchlight.transform.position + (Searchlight.transform.rotation * (new Vector3(Mathf.Cos(i * Mathf.Deg2Rad), -0.3f, Mathf.Sin(i * Mathf.Deg2Rad)) * 30));
                    count++;
                }
            }

            private void SetNextSearchPoint()
            {
                if (nextSearchPoint == 0 || nextSearchPoint == 8)
                    searchForwards = !searchForwards;

                lastSearchPoint = nextSearchPoint;
                nextSearchPoint = searchForwards ? nextSearchPoint += 1 : nextSearchPoint -= 1;
            }

            private void CalculateThreatProbability()
            {
                BaseCombatEntity target = null;
                float targetDistance = searchRadius;
                int threatRating = 10;

                foreach (var list in threats.Where(x => x.Key <= threatLevel && x.Value.Count > 0).OrderByDescending(x => x.Key))
                {
                    foreach (BaseCombatEntity potentialTarget in list.Value)
                    {
                        if (potentialTarget == null || potentialTarget.IsDestroyed || !IsObjectVisible(potentialTarget))
                            continue;

                        float distance = Vector3.Distance(Searchlight.transform.position, potentialTarget.transform.position);

                        if (distance < threatRadius[list.Key])
                        {
                            target = potentialTarget;
                            targetDistance = distance;
                            threatRating = list.Key;
                        }
                    }
                }

                if (target == targetEntity) 
                    return;                

                if (target != null)
                {
                    if (targetEntity != null)
                    {
                        if (threatRating < threatLevel || (threatRating == threatLevel && targetDistance < Vector3.Distance(Searchlight.transform.position, target.transform.position)))
                            SetAimTarget(target, threatRating);
                    }
                    else SetAimTarget(target, threatRating);
                }
            }

            private void SetAimTarget(BaseCombatEntity target, int threatRating)
            {
                nextCheckTime = 0;
                idleTime = 0;
                isSearching = false;
                targetEntity = target;

                if (Searchlight.HasFlag(BaseEntity.Flags.On))
                    Effect.server.Run(FX_ACQUIRED, Searchlight, 0, Vector3.zero, Vector3.zero, null, false);
                maxTargetDistance = target is BasePlayer ? (RustNET.IsFriendlyPlayer(Searchlight.OwnerID, targetEntity.ToPlayer().userID) ? detection.Friends.Radius : detection.Enemies.Radius) : target is BaseNpc ? detection.Animals.Radius : (target is BasicCar || target is BradleyAPC) ? detection.Vehicles.Radius : detection.Helicopters.Radius;
                threatLevel = threatRating;
            }

            private void ClearAimTarget()
            {
                resetSearch = true;
                if (targetEntity != null && Searchlight.HasFlag(BaseEntity.Flags.On))
                    Effect.server.Run(FX_LOST, Searchlight, 0, Vector3.zero, Vector3.zero, null, false);
                targetEntity = null;
                threatLevel = 10;
            }

            private bool IsObjectVisible(BaseCombatEntity obj)
            {               
                List<RaycastHit> list = Pool.GetList<RaycastHit>();

                Vector3 castPoint = Searchlight.transform.position + (Vector3.up * 1.4f);
                Vector3 aimPoint = AimOffset(obj);                
                Vector3 direction = aimPoint - castPoint;
                Vector3 cross = Vector3.Cross(direction.normalized, Vector3.up);

                float distance = Vector3.Distance(aimPoint, castPoint);                
                for (int i = 0; i < 3; i++)
                {
                    Vector3 altCastPoint = aimPoint + (cross * visabilityOffsets[i]);
                    Vector3 altDirection = (altCastPoint - castPoint).normalized;
                    
                    list.Clear();
                    GamePhysics.TraceAll(new Ray(castPoint, altDirection), 0f, list, distance * 1.1f, 1084434689, QueryTriggerInteraction.UseGlobal);
                    int num = 0;
                    while (num < list.Count)
                    {
                        BaseEntity foundEntity = list[num].GetEntity();
                        if (foundEntity != null && (foundEntity == obj || foundEntity.EqualNetID(obj)))
                        {
                            Pool.FreeList<RaycastHit>(ref list);
                            return true;
                        }
                        if (foundEntity == Searchlight)
                        {
                            num++;
                            continue;
                        }
                        if (!(foundEntity != null) || foundEntity.ShouldBlockProjectiles())                        
                            break;                        
                        else num++;                        
                    }
                }
                Pool.FreeList<RaycastHit>(ref list);
                return false;
            }
          
            private Vector3 AimOffset(BaseCombatEntity aimat)
            {
                BasePlayer basePlayer = aimat as BasePlayer;
                if (basePlayer != null)
                {
                    return basePlayer.eyes.position;
                }
                return aimat.transform.position + new Vector3(0f, 0.3f, 0f);
            }
            
            public void ToggleAutomation(bool status)
            {
                if (isDisabled || enabled == status)
                    return;

                if (requiresPower)
                {
                    if (!Searchlight.HasFlag(BaseEntity.Flags.Reserved8))
                        return;
                }
                else Searchlight.SetFlag(BaseEntity.Flags.Reserved8, status);

                enabled = status;

                Effect.server.Run(status ? FX_ONLINE : FX_OFFLINE, Searchlight, 0, Vector3.zero, Vector3.zero, null, false);                    
                
                Searchlight.SetFlag(BaseEntity.Flags.On, status);
            }

            public void AdjustLightRotation(float rotation)
            {
                bool wasEnabled = enabled;
                if (enabled)
                    ToggleAutomation(false);

                Searchlight.transform.eulerAngles = new Vector3(0, rotation - 90, 0);
                Searchlight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                if (search.Enabled)
                {
                    GenerateSearchPattern();
                    lastSearchPoint = 4;
                    nextSearchPoint = searchForwards ? 5 : 3;
                    searchTime = 0;
                }

                if (wasEnabled)
                    ToggleAutomation(true);
            }

            public void SetController(Controller controller) => this.Controller = controller;

            public bool IsEnabled()
            {
                return !isDisabled;
            }

            public void ToggleSearchAutomation(bool status)
            {
                print($"toggle3 {status}");
                if (status)
                {
                    isDisabled = false;
                    if (Controller == null)
                    {
                        if (!enabled && ins.automationEnabled)                        
                            ToggleAutomation(true);
                    }
                }
                else
                {
                    print($"toggle4 {enabled} && {Controller == null}");
                    isDisabled = true;
                    if (enabled && Controller == null)
                    {
                        print("toggle ioff");
                        enabled = false;
                        if (Searchlight.HasFlag(BaseEntity.Flags.On))
                        {
                            Searchlight.SetFlag(BaseEntity.Flags.On, false);
                            Searchlight.SendNetworkUpdate();
                        }
                    }
                }
            }

            public void OnEntityDeath(BaseCombatEntity baseCombatEntity)
            {
                if (baseCombatEntity == targetEntity)                
                    ClearAimTarget();                
            }

            public LightData GetLightData()
            {
                if (Searchlight == null || Searchlight.IsDestroyed)
                    return null;

                return new LightData(this);
            }

            public class LightData
            {
                public uint lightId;
                public int terminalId;
                public string lightName;

                public LightData() { }
                public LightData(LightManager manager)
                {
                    lightId = manager.Searchlight.net.ID;
                    terminalId = manager.terminalId;
                    lightName = manager.lightName;
                }
            }
        }

        class Controller : RustNET.Controller
        {
            public LightManager manager { get; private set; }

            private LinkManager.LightLink link;
            private int spectateIndex = 0;
            private bool switchingTargets;

            private bool wasEnabled = false;
            private bool canCycle;
            private Vector3 offset = new Vector3(0, 0.3f, 0); 
            
            public bool lightsOn { get; private set; }
                       
            public override void Awake()
            {
                base.Awake();
                enabled = false;
                canCycle = ins.configData.Management.Remote.CanCycle;
                player.ClearEntityQueue(null);                
            }
           
            private void FixedUpdate()
            {
                if (player == null || player.serverInput == null || switchingTargets)
                    return;

                InputState input = player.serverInput; 
                if (manager != null && manager.Controller == this)
                {
                    if (input.WasJustPressed(BUTTON.FIRE_PRIMARY))
                    {
                        lightsOn = !lightsOn;
                        if (lightsOn)
                        {
                            if (manager.Searchlight.IsPowered())
                                manager.Searchlight.SetFlag(BaseEntity.Flags.On, true);
                        }
                        else manager.Searchlight.SetFlag(BaseEntity.Flags.On, false);
                    }
                  
                    Vector3 aimTarget = player.transform.position + (Quaternion.Euler(input.current.aimAngles) * (Vector3.forward * 10));
                    
                    manager.Searchlight.SetTargetAimpoint(aimTarget);
                    manager.Searchlight.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                }

                if (input.WasJustPressed(BUTTON.USE))
                {
                    enabled = false;
                    link.CloseLink(this);
                }
                else
                {
                    if (canCycle)
                    {
                        if (input.WasJustPressed(BUTTON.JUMP))
                            UpdateSpectateTarget(1);
                        else if (input.WasJustPressed(BUTTON.DUCK))
                            UpdateSpectateTarget(-1);
                    }
                }
            }

            public override void OnDestroy()
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);

                if (manager != null && manager.Controller == this)
                    manager.SetController(null);
                base.OnDestroy();
            }

            public void SetLightLink(LinkManager.LightLink link)
            {
                this.link = link;
                BeginSpectating();
            }

            public void SetSpectateTarget(int spectateIndex)
            {
                this.spectateIndex = spectateIndex;
                manager = link.Managers[spectateIndex];

                player.SendEntitySnapshot(manager.Searchlight);
                player.gameObject.Identity();
                //player.SetParent(manager.searchLight, 0);

                RustNET.MovePosition(player, manager.Searchlight.transform.position + (Vector3.up * 1.5f), false);

                if (manager.Controller == null)                
                    manager.SetController(this);                
                else player.ChatMessage(ins.msg("Warning.InUse", player.userID));

                CreateCameraOverlay();
            }

            public void UpdateSpectateTarget(int index = 0)
            {
                switchingTargets = true;
                player.Invoke(() => switchingTargets = false, 0.25f);

                int newIndex = spectateIndex + index;

                if (newIndex > link.Managers.Count - 1)
                    newIndex = 0;
                else if (newIndex < 0)
                    newIndex = link.Managers.Count - 1;

                if (spectateIndex == newIndex)
                    return;

                if (manager.Controller == this)                
                    manager.SetController(null);

                manager = null;
                SetSpectateTarget(newIndex);                
            }

            public void BeginSpectating()
            {
                RustNET.StripInventory(player);

                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                player.gameObject.SetLayerRecursive(10);
                player.CancelInvoke("InventoryUpdate");
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
                //player.Command("client.camoffset", new object[] { new Vector3(0, 2.2f, 0) });

                if (Network.Net.sv.write.Start())
                {
                    Network.Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                    Network.Net.sv.write.EntityID(player.net.ID);
                    Network.Net.sv.write.UInt8((byte)BaseNetworkable.DestroyMode.None);
                    Network.Net.sv.write.Send(new Network.SendInfo(player.net.group.subscribers.Where(x => x.userid != player.userID).ToList()));
                }

                player.ChatMessage(ins.msg("Help.Toggle", player.userID));

                if (canCycle)
                    player.ChatMessage(ins.msg("Help.ControlInfo", player.userID));
                else player.ChatMessage(ins.msg("Help.ControlInfo.NoCycle", player.userID));

                enabled = true;
            }

            public void FinishSpectating(bool isDead)
            {
                enabled = false;

                //player.SetParent(null, 0);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                player.gameObject.SetLayerRecursive(17);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
                player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
                player.Command("client.camoffset", new object[] { new Vector3(0, 1.2f, 0) });

                CuiHelper.DestroyUi(player, ASUI_OVERLAY);

                if (manager.Controller == this)                
                    manager.SetController(null);                

                if (!isDead)
                    Destroy(this);               
            }

            public override void OnPlayerDeath(HitInfo info)
            {
                enabled = false;
                link.CloseLink(this, true);

                base.OnPlayerDeath(info);
            }

            private void CreateCameraOverlay()
            {
                if (!ins.configData.Management.Remote.Overlay)
                    return;

                CuiElementContainer container = RustNET.UI.Container("0 0 0 0", "0 0", "1 1", false, "Under", ASUI_OVERLAY);
                RustNET.UI.Image(ref container, ins.GetImage("searchlightoverlay"), "0 0", "1 1", ASUI_OVERLAY);

                RustNET.UI.Panel(ref container, "0 0 0 0.4", "0.82 0.9", "0.96 0.94", ASUI_OVERLAY);
                RustNET.UI.Label(ref container, string.IsNullOrEmpty(manager.lightName) ? string.Format(ins.msg("UI.SearchlightName", player.userID), spectateIndex + 1) : manager.lightName, 13, "0.82 0.9", "0.96 0.94", TextAnchor.MiddleCenter, ASUI_OVERLAY);

                CuiHelper.DestroyUi(player, ASUI_OVERLAY);
                CuiHelper.AddUi(player, container);
            }
        }
        #endregion

        #region UI
        private void CreateConsoleWindow(BasePlayer player, int terminalId, int page)
        {
            CuiElementContainer container = RustNET.ins.GetBaseContainer(player, terminalId, Title);

            LightManager[] entityIds = GetAvailableSearchlights(terminalId);

            RustNET.UI.Panel(ref container, RustNET.uiColors[RustNET.Colors.Panel], "0.04 0.765", "0.96 0.8");
            RustNET.UI.Label(ref container, msg("UI.Select.Searchlight", player.userID), 12, "0.05 0.765", "0.5 0.8", TextAnchor.MiddleLeft);
            RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], RustNET.msg("UI.MainMenu", player.userID), 11, "0.82 0.765", "0.96 0.8", $"rustnet.changepage {terminalId}");

            if (entityIds == null || entityIds.Length == 0)
                RustNET.UI.Label(ref container, msg("UI.NoSearchlights", player.userID), 12, "0.05 0.5", "0.95 0.7");
            else
            {
                int count = 0;
                int startAt = page * 18;
                for (int i = startAt; i < (startAt + 18 > entityIds.Length ? entityIds.Length : startAt + 18); i++)
                {
                    LightManager manager = entityIds.ElementAt(i);
                    RustNET.UI.Panel(ref container, RustNET.uiColors[RustNET.Colors.Panel], $"0.04 {(0.725f - (count * 0.04f))}", $"0.96 {(0.755f - (count * 0.04f))}");
                    RustNET.UI.Label(ref container, string.IsNullOrEmpty(manager.lightName) ? string.Format(msg("UI.Searchlight", player.userID), count + 1) : $"> {manager.lightName}", 11, $"0.05 {0.725f - (count * 0.04f)}", $"0.31 {0.755f - (count * 0.04f)}", TextAnchor.MiddleLeft);

                    if (configData.Management.Remote.ToggleEnabled)
                    {
                        bool isEnabled = manager.IsEnabled();
                        RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], isEnabled ? RustNET.msg("UI.Enable", player.userID) : RustNET.msg("UI.Disable", player.userID), 11, $"0.32 {0.725f - (count * 0.04f)}", $"0.53 {0.755f - (count * 0.04f)}", $"automatedsearchlights.toggle {manager.Searchlight.net.ID} {terminalId} {page} {!isEnabled}");
                    }

                    if (configData.Management.Remote.RemoteControl)
                        RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], RustNET.msg("UI.Control", player.userID), 11, $"0.54 {0.725f - (count * 0.04f)}", $"0.75 {0.755f - (count * 0.04f)}", $"automatedsearchlights.control {manager.Searchlight.net.ID} {terminalId}");

                    count++;
                }

                int totalPages = entityIds.Length / 18;

                RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], RustNET.msg("UI.Back", player.userID), 11, "0.3 0.01", "0.44 0.04", page > 0 ? $"rustnet.changepage {terminalId} {Title} {page - 1}" : "");
                RustNET.UI.Label(ref container, string.Format(RustNET.msg("UI.Page", player.userID), page + 1, totalPages + 1), 11, "0.44 0.01", "0.56 0.04");
                RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], RustNET.msg("UI.Next", player.userID), 11, "0.56 0.01", "0.7 0.04", page + 1 <= totalPages ? $"rustnet.changepage {terminalId} {Title} {page + 1}" : "");
            }

            CuiHelper.DestroyUi(player, RustNET.RustNET_Panel);
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("automatedsearchlights.toggle")]
        private void ccmdToggle(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!RustNET.linkManager.IsValidTerminal(arg.GetInt(1)))
            {
                CuiHelper.DestroyUi(player, RustNET.RustNET_Panel);
                SendReply(player, RustNET.msg("Warning.TerminalDestroyed", player.userID));
                return;
            }

            ToggleAutomation(arg.GetUInt(0), arg.GetInt(1), arg.GetBool(3));
            RustNET.ins.DisplayToPlayer(player, arg.GetInt(1), Title, arg.GetInt(2));            
        }

        [ConsoleCommand("automatedsearchlights.control")]
        private void ccmdControl(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!RustNET.linkManager.IsValidTerminal(arg.GetInt(1)))
            {
                CuiHelper.DestroyUi(player, RustNET.RustNET_Panel);
                SendReply(player, RustNET.msg("Warning.TerminalDestroyed", player.userID));
                return;
            }

            CuiHelper.DestroyUi(player, RustNET.RustNET_Panel);
            InitializeController(player, arg.GetUInt(0), arg.GetInt(1));
        }
        #endregion

        #region Commands
        [ChatCommand("sl")]
        private void cmdSL(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERM_USE)) 
                return;

            if (args.Length == 0)
            {
                SendReply(player, $"<color=#ce422b>{Title}</color><color=#939393>  v{Version}  -</color> <color=#ce422b>{Author} @ www.chaoscode.io</color>");
                SendReply(player, msg("Help.Main", player.userID));
                if (configData.Management.NoTerminal)
                    SendReply(player, msg("Help.Add", player.userID));
                SendReply(player, msg("Help.AddTerminal", player.userID));
                SendReply(player, msg("Help.Remove", player.userID));
                SendReply(player, msg("Help.Rotate", player.userID));
                SendReply(player, msg("Help.Name", player.userID));
                return;
            }            

            SearchLight searchLight = RustNET.FindEntityFromRay(player) as SearchLight;
            if (searchLight == null)
            {
                SendReply(player, msg("Error.NoEntity", player.userID));
                return;
            };

            if (searchLight.OwnerID != player.userID && !RustNET.IsFriendlyPlayer(searchLight.OwnerID, player.userID))
            {
                SendReply(player, msg("Error.NotOwner", player.userID));
                return;
            }

            switch (args[0].ToLower())
            {
                case "add":
                    {
                        if (args.Length != 2)
                        {
                            if (configData.Management.NoTerminal)
                            {
                                if (searchLight.GetComponent<LightManager>())
                                {
                                    SendReply(player, msg("Error.AlreadyRegistered", player.userID));
                                    return;
                                }

                                LinkManager.LightLink lightLink = linkManager.GetLinkOf(0);
                                if (lightLink == null)
                                    lightLink = new LinkManager.LightLink(0, searchLight, "");
                                else lightLink.AddLightToLink(searchLight, 0, "");

                                searchLight.GetComponent<LightManager>().ToggleAutomation(automationEnabled);

                                SendReply(player, msg("Success.Set", player.userID));
                                SaveData();
                            }
                            else
                            {
                                SendReply(player, msg("Error.TerminalID", player.userID));
                                SendReply(player, msg("Help.AddTerminal", player.userID));
                                return;
                            }
                        }
                        else
                        {
                            if (searchLight.GetComponent<LightManager>())
                            {
                                SendReply(player, msg("Error.AlreadyRegistered", player.userID));
                                return;
                            }

                            int terminalId;
                            if (!int.TryParse(args[1], out terminalId))
                            {
                                SendReply(player, msg("Error.TerminalID", player.userID));
                                return;
                            }

                            if (!RustNET.linkManager.IsValidTerminal(terminalId))
                            {
                                SendReply(player, msg("Error.RustNETID", player.userID));
                                return;
                            }

                            RustNET.LinkManager.Link link = RustNET.linkManager.GetLinkOf(terminalId);
                            if (link == null)
                            {
                                SendReply(player, msg("Error.NoLink", player.userID));
                                return;
                            }

                            if (!link.IsPublicLink)
                            {
                                BuildingManager.Building building = link.terminal.ParentEntity.GetBuilding();
                                if (building == null)
                                {
                                    SendReply(player, msg("Error.NoBuilding", player.userID));
                                    return;
                                }

                                if (!building.GetDominatingBuildingPrivilege()?.IsAuthed(player) ?? false)
                                {
                                    SendReply(player, msg("Error.NoPrivilege", player.userID));
                                    return;
                                }

                                if (Vector3.Distance(searchLight.transform.position, link.terminal.DroppedItem.transform.position) > configData.Management.DistanceFromTerminal)
                                {
                                    SendReply(player, msg("Error.Distance", player.userID));
                                    return;
                                }
                            }

                            LinkManager.LightLink lightLink = linkManager.GetLinkOf(terminalId);
                            if (lightLink == null)
                                lightLink = new LinkManager.LightLink(terminalId, searchLight, "");
                            else
                            {
                                int lightLimit = GetMaxLights(player.userID);
                                if (!permission.UserHasPermission(player.UserIDString, PERM_IGNORE) && lightLink.Managers.Count >= lightLimit)
                                {
                                    SendReply(player, msg("Error.Limit", player.userID));
                                    return;
                                }

                                lightLink.AddLightToLink(searchLight, terminalId, "");
                            }

                            searchLight.GetComponent<LightManager>().ToggleAutomation(automationEnabled);

                            SendReply(player, msg("Success.Set", player.userID));
                            SaveData();
                        }
                    }
                    return;                
                case "remove":
                    {                        
                        if (!searchLight.GetComponent<LightManager>())
                        {
                            SendReply(player, msg("Error.NotRegistered", player.userID));
                            return;
                        }

                        LinkManager.LightLink link = linkManager.GetLinkOf(searchLight);
                        if (link == null)
                        {
                            SendReply(player, msg("Error.NoLink", player.userID));
                            return;
                        }

                        LightManager manager = searchLight.GetComponent<LightManager>();
                        if (manager == null)
                        {
                            SendReply(player, msg("Error.NoComponent", player.userID));
                            return;
                        }

                        if (manager.Controller != null)
                            link.CloseLink(manager.Controller);

                        link.Managers.Remove(manager);
                        UnityEngine.Object.Destroy(manager);

                        SaveData();
                        SendReply(player, msg("Success.Remove", player.userID));                               
                    }
                    return;
                case "rotate":
                    {              
                        if (!searchLight.GetComponent<LightManager>())
                        {
                            SendReply(player, msg("Error.NoComponent", player.userID));
                            return;
                        }

                        LightManager follower = searchLight.GetComponent<LightManager>();
                        follower.AdjustLightRotation(player?.eyes?.rotation.eulerAngles.y ?? 0);                       
                        SendReply(player, msg("Warning.Rotation", player.userID));
                    }
                    return;
                case "name":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, msg("Error.NoNameSpecified", player.userID));
                            return;
                        }

                        LightManager manager = RustNET.FindEntityFromRay(player)?.GetComponent<LightManager>();
                        if (manager == null)
                        {
                            SendReply(player, msg("Error.NoEntity", player.userID));
                            return;
                        }

                        manager.lightName = args[1];

                        SendReply(player, string.Format(msg("Success.NameSet", player.userID), args[1]));
                    }
                    return;
                default:
                    SendReply(player, msg("Error.InvalidCommand", player.userID));
                    return;
            }
        }
        #endregion

        #region Image Management
        private void LoadDefaultImages(int attempts = 0)
        {
            if (!configData.Management.Remote.Overlay)
                return;

            if (attempts > 3)
            {
                PrintError("ImageLibrary not found. Unable to load camera overlay UI");
                configData.Management.Remote.Overlay = false;
                return;
            }

            if (configData.Management.Remote.Overlay && !string.IsNullOrEmpty(configData.Management.Remote.OverlayImage))                            
                AddImage("searchlightoverlay", configData.Management.Remote.OverlayImage);

            if (!string.IsNullOrEmpty(configData.Management.Remote.RustNETIcon))
                AddImage(Title, configData.Management.Remote.RustNETIcon);
        }

        private void AddImage(string imageName, string fileName) => RustNET.ins.AddImage(imageName, fileName);

        private string GetImage(string name) => RustNET.ins.GetImage(name);
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Detection Options")]
            public DetectionOptions Detection { get; set; }

            [JsonProperty(PropertyName = "Management Options")]
            public LightManagement Management { get; set; }

            [JsonProperty(PropertyName = "Light Options")]
            public LightOptions Options { get; set; }            

            public class DetectionOptions
            {               
                [JsonProperty(PropertyName = "Animals")]
                public DetectSettings Animals { get; set; }

                [JsonProperty(PropertyName = "Enemy players and NPCs")]
                public DetectSettings Enemies { get; set; }

                [JsonProperty(PropertyName = "Friends and owner")]
                public DetectSettings Friends { get; set; }

                [JsonProperty(PropertyName = "Cars and tanks")]
                public DetectSettings Vehicles { get; set; }

                [JsonProperty(PropertyName = "Helicopters")]
                public DetectSettings Helicopters { get; set; }

                public class DetectSettings
                {
                    [JsonProperty(PropertyName = "Enable this detection type")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Range of detection")]
                    public float Radius { get; set; }

                    [JsonProperty(PropertyName = "Threat rating for priority targeting (1 - 5, 1 being the highest threat)")]
                    public int Threat { get; set; }
                }
            }
            public class LightManagement
            {
                [JsonProperty(PropertyName = "Automatically register light to terminal when placed (if meets other requirements)")]
                public bool AutoRegister { get; set; }

                [JsonProperty(PropertyName = "Allow lights to be set without requiring a terminal")]
                public bool NoTerminal { get; set; }

                [JsonProperty(PropertyName = "Maximum allowed searchlights per base (Permission | Amount)")]
                public Dictionary<string, int> Max { get; set; }

                [JsonProperty(PropertyName = "Maximum distance a searchlight controller can be set away from the terminal")]
                public float DistanceFromTerminal { get; set; }

                [JsonProperty(PropertyName = "Remote Settings")]
                public RemoteOptions Remote { get; set; }

                public class RemoteOptions
                {
                    [JsonProperty(PropertyName = "Allow players to cycle through all linked searchlights")]
                    public bool CanCycle { get; set; }

                    [JsonProperty(PropertyName = "Can players toggle searchlight automation")]
                    public bool ToggleEnabled { get; set; }

                    [JsonProperty(PropertyName = "Can players control the searchlight remotely")]
                    public bool RemoteControl { get; set; }

                    [JsonProperty(PropertyName = "Display camera overlay UI")]
                    public bool Overlay { get; set; }

                    [JsonProperty(PropertyName = "Camera overlay image URL")]
                    public string OverlayImage { get; set; }

                    [JsonProperty(PropertyName = "Searchlight icon URL for RustNET menu")]
                    public string RustNETIcon { get; set; }
                }
            }
            public class LightOptions
            {
                [JsonProperty(PropertyName = "Require power for light automation")]
                public bool RequirePower { get; set; }

                [JsonProperty(PropertyName = "Sunrise hour")]
                public float Sunrise { get; set; }

                [JsonProperty(PropertyName = "Sunset hour")]
                public float Sunset { get; set; }

                [JsonProperty(PropertyName = "Only automate lights at night time")]
                public bool NightOnly { get; set; }

                [JsonProperty(PropertyName = "Search mode")]
                public SearchMode Search { get; set; }

                [JsonProperty(PropertyName = "Flicker mode")]
                public FlickerMode Flicker { get; set; }

                public class SearchMode
                {
                    [JsonProperty(PropertyName = "Enable search mode when no targets are visable")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Rotation speed of search mode")]
                    public float Speed { get; set; }
                }

                public class FlickerMode
                {
                    [JsonProperty(PropertyName = "Enable flickering lights when damaged")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Percentage of health before flickering starts")]
                    public float Health { get; set; }
                }
            }     
            
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Detection = new ConfigData.DetectionOptions
                {
                    Animals = new ConfigData.DetectionOptions.DetectSettings
                    {
                        Enabled = true,
                        Radius = 30,
                        Threat = 4
                    },
                    Enemies = new ConfigData.DetectionOptions.DetectSettings
                    {
                        Enabled = true,
                        Radius = 45,
                        Threat = 2,
                    },
                    Friends = new ConfigData.DetectionOptions.DetectSettings
                    {
                        Enabled = true,
                        Radius = 45,
                        Threat = 5,
                    },
                    Helicopters = new ConfigData.DetectionOptions.DetectSettings
                    {
                        Enabled = true,
                        Radius = 100,
                        Threat = 3
                    },
                    Vehicles = new ConfigData.DetectionOptions.DetectSettings
                    {
                        Enabled = true,
                        Radius = 60,
                        Threat = 1
                    }
                },
                Management = new ConfigData.LightManagement
                {
                    AutoRegister = false,
                    Max = new Dictionary<string, int>
                    {
                        ["automatedsearchlights.use"] = 4,
                        ["automatedsearchlights.pro"] = 10
                    },
                    DistanceFromTerminal = 50,
                    NoTerminal = false,
                    Remote = new ConfigData.LightManagement.RemoteOptions
                    {
                        CanCycle = true,
                        RemoteControl = true,
                        ToggleEnabled = true,
                        OverlayImage = "http://www.rustedit.io/images/RustNET/camera.png",
                        Overlay = true,
                        RustNETIcon = "http://www.rustedit.io/images/RustNET/searchlighticon.png"
                    }
                },
                Options = new ConfigData.LightOptions
                {
                    RequirePower = false,
                    Flicker = new ConfigData.LightOptions.FlickerMode
                    {
                        Enabled = true,
                        Health = 50
                    },
                    NightOnly = true,
                    Search = new ConfigData.LightOptions.SearchMode
                    {
                        Enabled = true,
                        Speed = 15f
                    },
                    Sunrise = 8f,
                    Sunset = 19f
                },               
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 2, 0))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(0, 2, 02))
                configData.Management.NoTerminal = baseConfig.Management.NoTerminal;

            if (configData.Version < new VersionNumber(0, 2, 04))
                configData.Management.Max = baseConfig.Management.Max;

            if (configData.Version < new VersionNumber(0, 2, 10))
                configData.Management.Remote = baseConfig.Management.Remote;

            if (configData.Version < new VersionNumber(0, 2, 13))
                configData.Management.Remote.CanCycle = baseConfig.Management.Remote.CanCycle;

            if (configData.Version < new VersionNumber(0, 2, 27))
                configData.Options.RequirePower = true;
            
            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private void SaveData()
        {
            if (storedData == null || storedData.registeredSearchlights == null)
                storedData = new StoredData();

            storedData.registeredSearchlights = LightManager.allManagers?.Where(x => x != null && x.Searchlight != null && !x.Searchlight.IsDestroyed)?.Select(x => x.GetLightData())?.ToArray() ?? new LightManager.LightData[0];
            data.WriteObject(storedData);
        }

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }            
        }

        private class StoredData
        {
            public LightManager.LightData[] registeredSearchlights = new LightManager.LightData[0];            
        }        
        #endregion

        #region Localization
        string msg(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());
        
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Help.Main"] = "<color=#ce422b>/rustnet</color><color=#939393> - Display the help menu for using RustNET</color>",
            ["Help.Add"] = "<color=#ce422b>/sl add</color><color=#939393> - Turn the light into an standalone automatic searchlight</color>",
            ["Help.AddTerminal"] = "<color=#ce422b>/sl add <terminal ID></color><color=#939393> - Turn the light into an automatic searchlight registered to a terminal</color>",
            ["Help.Remove"] = "<color=#ce422b>/sl remove</color><color=#939393> - Remove the lights automation</color>",
            ["Help.Rotate"] = "<color=#ce422b>/sl rotate</color><color=#939393> - Rotates the light you are looking at to the direction you are facing (adjust auto-rotation)</color>",
            ["Help.Name"] = "<color=#ce422b>/sl name <name></color><color=#939393> - Set a name for the searchlight you are looking at</color>",
            ["Help.ControlInfo"] = "<color=#939393>Press <color=#ce422b>'JUMP'</color> and <color=#ce422b>'DUCK'</color> to cycle through available searchlights.\nPress <color=#ce422b>'USE'</color> to exit the controller!</color>",
            ["Help.ControlInfo.NoCycle"] = "Press <color=#ce422b>'USE'</color> to exit the controller!</color>",
            ["Help.Toggle"] = "<color=#939393>You can toggle the light on/off by pressing <color=#ce422b>'FIRE'</color></color>",
            ["Success.Set"] = "<color=#939393>You have successfully registered this searchlight to the terminal</color>",
            ["Success.Remove"] = "<color=#939393>You have successfully removed this searchlight from the terminal</color>",
            ["Warning.TerminalDestroyed"] = "<color=#ce422b>The terminal has been destroyed!</color>",
            ["Warning.TerminalShutdown"] = "<color=#ce422b>The terminal has been shutdown</color>",
            ["Warning.SearchlightDestroyed"] = "<color=#ce422b>The searchlight you were controlling has been destroyed</color>",
            ["Warning.Rotation"] = "<color=#939393>The rotation has been adjusted!</color>",
            ["Warning.NoRemoval"] = "<color=#939393>You can not remove fuel from a automated searchlight when fuel consumption is disabled</color>",
            ["Warning.InUse"] = "<color=#939393>This searchlight is already in use!</color>",
            ["Error.NotOwner"] = "<color=#939393>This searchlight does not belong to you!</color>",
            ["Error.Limit"] = "<color=#939393>This building already has the maximum number of automated search lights!</color>",
            ["Error.AlreadyRegistered"] = "<color=#939393>This light is already a automated searchlight!</color>",
            ["Error.NoComponent"] = "<color=#939393>This light is not a automated searchlight!</color>",
            ["Error.InvalidCommand"] = "<color=#939393>Invalid command! Type <color=#ce422b>/sl</color> for available commands</color>",
            ["Error.TerminalID"] = "<color=#939393>You need to enter a valid terminal ID</color>",
            ["Error.RustNETID"] = "<color=#939393>Invalid terminal ID selected! You can find the terminal ID by opening the terminal</color>",
            ["Error.NoLink"] = "<color=#939393>[ERROR] Unable to find building link</color>",
            ["Error.NoBuilding"] = "<color=#939393>[ERROR] The selected terminal does not have a building</color>",
            ["Error.NoPrivilege"] = "<color=#939393>You do not have building privilege in the terminal building</color>",           
            ["Error.NotRegistered"] = "<color=#939393>The searchlight you are looking at has not been registered</color>",
            ["Error.NoNameSpecified"] = "<color=#939393>You must enter a name for the searchlight!</color>",
            ["Error.NoEntity"] = "<color=#939393>You are not looking at a automated searchlight</color>",
            ["Error.Distance"] = "<color=#939393>This searchlight is too far away from the terminal</color>",
            ["Success.NameSet"] = "<color=#939393>You have set the name of this searchlight to <color=#ce422b>{0}</color></color>",
            ["UI.Searchlight"] = "> Searchlight {0}",
            ["UI.SearchlightName"] = "Searchlight {0}",
            ["UI.Select.Searchlight"] = "> <color=#28ffa6>Searchlights</color> <",
            ["UI.NoSearchlights"] = "No searchlights registered to this terminal",
            ["UI.Help.Title"] = "> <color=#28ffa6>Searchlight Help Menu</color> <",
            ["UI.Help"] = "> To register a searchlight you will need the terminal ID noted above.\n\n> Creating a Automated Searchlight\nStep 1. Deploy a searchlight in or around your base.\nStep 2. Look at your searchlight and type <color=#28ffa6>/sl add <terminal ID></color> replacing <terminal ID> with the ID of the terminal you are using.\n\nYour searchlight is now registered to the terminal, It will search for targets at night time and can be accessed remotely via this control panel.\n\n> Removing a searchlight and restoring it to default\nTo remove a searchlight look at it and type <color=#28ffa6>/sl remove</color>. This will remove its automation and remote functionality and restore it to default",
        };
        #endregion        
    }
}


// --- End of file: AutomatedSearchlights.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PrivateMessage.cs ---
// --- Original Local Path: PrivateMessage.cs ---

using System.Collections.Generic;
using System.Globalization;
using Oxide.Core;
using Oxide.Core.Plugins;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PrivateMessage", "Nogrod", "2.0.4", ResourceId = 659)]
    class PrivateMessage : RustPlugin
    {
        private readonly Dictionary<ulong, ulong> pmHistory = new Dictionary<ulong, ulong>();

        [PluginReference]
        private Plugin Ignore;
        [PluginReference]
        private Plugin BetterChat;

        private void Init()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"PMTo", "<color=#00FFFF>PM to {0}</color>: {1}"},
                {"PMFrom", "<color=#00FFFF>PM from {0}</color>: {1}"},
                {"PlayerNotOnline", "{0} is not online."},
                {"NotOnlineAnymore", "The last person you was talking to is not online anymore."},
                {"NotMessaged", "You haven't messaged anyone or they haven't messaged you."},
                {"IgnoreYou", "<color=red>{0} is ignoring you and cant recieve your PMs</color>"},
                {"SelfPM", "You can not send messages to yourself."},
                {"SyntaxR", "Incorrect Syntax use: /r <msg>"},
                {"SyntaxPM", "Incorrect Syntax use: /pm <name> <msg>"}
            }, this);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (pmHistory.ContainsKey(player.userID)) pmHistory.Remove(player.userID);
        }

        [ChatCommand("pm")]
        void cmdPm(BasePlayer player, string command, string[] args)
        {
            if (args.Length > 1)
            {
                var name = args[0];
                var p = FindPlayer(name);
                if (p == player)
                {
                    PrintMessage(player, "SelfPM");
                    return;
                }
                if (p != null)
                {
                    if (!(bool) (Interface.Oxide.CallHook("CanChat", player) ?? true))
                    {
                        SendReply(player, "You are not allowed to chat here");
                        return;
                    }
                    var hasIgnore = Ignore?.CallHook("HasIgnored", p.userID, player.userID);
                    if (hasIgnore != null && (bool) hasIgnore)
                    {
                        PrintMessage(player, "IgnoreYou", p.displayName);
                        return;
                    }
                    hasIgnore = BetterChat?.CallHook("API_PlayerIgnores", p.UserIDString, player.UserIDString);
                    if (hasIgnore != null && (bool)hasIgnore)
                    {
                        PrintMessage(player, "IgnoreYou", p.displayName);
                        return;
                    }
                    var msg = string.Empty;
                    for (var i = 1; i < args.Length; i++)
                        msg = $"{msg} {args[i]}";
                    pmHistory[player.userID] = p.userID;
                    pmHistory[p.userID] = player.userID;
                    PrintMessage(player, "PMTo", p.displayName, msg);
                    PrintMessage(p, "PMFrom", player.displayName, msg);
                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", p, 0, Vector3.zero, Vector3.zero);
                    Puts("[PM]{0}->{1}:{2}", player.displayName, p.displayName, msg);
                }
                else
                    PrintMessage(player, "PlayerNotOnline", name);
            }
            else
                PrintMessage(player, "SyntaxPM");
        }

        [ChatCommand("r")]
        void cmdPmReply(BasePlayer player, string command, string[] args)
        {
            if (args.Length > 0)
            {
                ulong steamid;
                if (pmHistory.TryGetValue(player.userID, out steamid))
                {
                    var p = FindPlayer(steamid);
                    if (p != null)
                    {
                        if (!(bool) (Interface.Oxide.CallHook("CanChat", player) ?? true))
                        {
                            SendReply(player, "You are not allowed to chat here");
                            return;
                        }
                        var hasIgnore = Ignore?.CallHook("HasIgnored", p.userID, player.userID);
                        if (hasIgnore != null && (bool)hasIgnore)
                        {
                            PrintMessage(player, "IgnoreYou", p.displayName);
                            return;
                        }
                        hasIgnore = BetterChat?.CallHook("API_PlayerIgnores", p.UserIDString, player.UserIDString);
                        if (hasIgnore != null && (bool)hasIgnore)
                        {
                            PrintMessage(player, "IgnoreYou", p.displayName);
                            return;
                        }
                        var msg = string.Empty;
                        for (var i = 0; i < args.Length; i++)
                            msg = $"{msg} {args[i]}";
                        PrintMessage(player, "PMTo", p.displayName, msg);
                        PrintMessage(p, "PMFrom", player.displayName, msg);
                        Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", p, 0, Vector3.zero, Vector3.zero);
                        Puts("[PM]{0}->{1}:{2}", player.displayName, p.displayName, msg);
                    }
                    else
                        PrintMessage(player, "NotOnlineAnymore");
                }
                else
                    PrintMessage(player, "NotMessaged");
            }
            else
                PrintMessage(player, "SyntaxR");
        }

        private void PrintMessage(BasePlayer player, string msgId, params object[] args)
        {
            PrintToChat(player, lang.GetMessage(msgId, this, player.UserIDString), args);
        }

        private static BasePlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.UserIDString == nameOrIdOrIp)
                    return activePlayer;
                if (activePlayer.displayName.Contains(nameOrIdOrIp, CompareOptions.OrdinalIgnoreCase))
                    return activePlayer;
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrIdOrIp)
                    return activePlayer;
            }
            return null;
        }

        private static BasePlayer FindPlayer(ulong id)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.userID == id)
                    return activePlayer;
            }
            return null;
        }
    }
}


// --- End of file: PrivateMessage.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NightNoFog.cs ---
// --- Original Local Path: NightNoFog.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NightNoFog", "BaseCheaters", "1.0.0")]
    class NightNoFog : RustPlugin
    {
        void OnServerInitialized()
        {
			timer.Repeat(60f, 0, () =>
			{
				ConsoleSystem.Run(ConsoleSystem.Option.Server, "weather.fog 0");
			});
        }
    }
}


// --- End of file: NightNoFog.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Tickets.cs ---
// --- Original Local Path: Tickets.cs ---

using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Tickets", "LaserHydra", "2.0.0", ResourceId = 1065)]
    [Description("Gives players the opportunity to send Tickets to admins.")]
    class Tickets : RustPlugin
    {
		class Ticket
		{
			public int ticketID;
			public string steamID;
			public string player;
			public string profile;
			public string position;
			public string message;
			public string reply;
			public float x;
			public float y;
			public float z;
			public string timestamp;
			
			public Ticket(int id, BasePlayer Player, string msg)
			{
				ticketID = id;
				player = Player.displayName;
				steamID = Player.userID.ToString();
				profile = "https://steamcommunity.com/profiles/" + Player.userID.ToString();
				position = $"X: {Player.transform.position.x.ToString()}, Y: {Player.transform.position.y.ToString()}, Z: {Player.transform.position.z.ToString()}";
				x = Player.transform.position.x;
				y = Player.transform.position.y;
				z = Player.transform.position.z;
				message = msg;
				reply = "This Ticket has not been replied to yet.";
				timestamp = System.DateTime.Now.ToString();
			}
			
			public Ticket()
			{
			}
		}
		
		class Data
		{
			public List<Ticket> tickets = new List<Ticket>();
			
			public Data()
			{
			}
		}
		
		Data data;
		
		void Loaded()
		{
			data = LoadData();
			if(!permission.PermissionExists("ticket.admin")) permission.RegisterPermission("ticket.admin", this);
			LoadConfig();
			timer.Once(5 * 60, () => {
					if(CheckUnrepliedTickets())
					{
						foreach(BasePlayer player in BasePlayer.activePlayerList)
						{
							if(IsAdmin(player, false))
							{
								SendChatMessage(player, "Tickets", "There are unreplied tickets! Type /ticket list to see them.");
							}
						}
						
						foreach(BasePlayer player in BasePlayer.activePlayerList)
						{
							CheckRepliedTickets(player);
						}
					}
				}
			);
		}
		
		Data LoadData() 
		{
			return Interface.GetMod().DataFileSystem.ReadObject<Data>("Tickets_Data");
		}
		
		void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject("Tickets_Data", data);
			//BroadcastChat("Saved data.");
		}	
		
		void LoadConfig()
		{
			SetConfig("Extras", "Enable PushAPI", false);
			SetConfig("Extras", "Enable EmailAPI", false);
		}
		
		void LoadDefaultConfig()
		{
			Puts("Generating new config file...");
		}
		
		void OnPlayerInit(BasePlayer player)
		{
			CheckRepliedTickets(player);
		}
		
		void SendToAPI(Ticket ticket)
		{
			string message = $"A new Ticket has been submitted. Ticket ID {ticket.ticketID}\n" +
								$"Timestamp: {ticket.timestamp}\n" +
								$"Player: {ticket.player}\n" +
								$"SteamID: {ticket.steamID}\n" +
								$"Steam Profile: {ticket.profile}\n" +
								$"Position: {ticket.position}\n" +
								$"Message: {ticket.message}\n";
			
			if ((bool)Config["Extras", "Enable PushAPI"] == true)
			{
				if (!plugins.Exists("PushAPI"))
				{
					Puts("You enabled support for the PushAPI in the config, but PushAPI is not installed! Get it here: http://oxidemod.org/plugins/705/");
				}
				else
				{
					var PushAPI = plugins.Find("PushAPI");
					PushAPI?.CallHook("PushMessage", "Admin Tickets | A new Ticket has been submitted!", message, "high", "gamelan");
				}
			}
				
			if ((bool)Config["Extras", "Enable EmailAPI"] == true)
			{
				if (!plugins.Exists("EmailAPI"))
				{
					Puts("You enabled support for the EmailAPI in the config, but EmailAPI is not installed! Get it here: http://oxidemod.org/plugins/712/");
				}
				else
				{
					var EmailAPI = plugins.Find("EmailAPI");
					EmailAPI?.CallHook("EmailMessage", "Admin Tickets | A new Ticket has been submitted!", message);
				}
			}
		}
				
		void CheckRepliedTickets(BasePlayer player)
		{
			foreach(Ticket ticket in data.tickets)
			{
				if(ticket.steamID == player.userID.ToString() && ticket.reply != "This Ticket has not been replied to yet.")
				{
					SendChatMessage(player, "Tickets", $"A reply to your Ticket has been made. To view it type <color=#00FF8D>/ticket view {ticket.ticketID.ToString()}</color>");
				}
			}
		}
		
		bool CheckUnrepliedTickets()
		{
			foreach(Ticket ticket in data.tickets)
			{
				if(ticket.reply == "This Ticket has not been replied to yet.") return true;
			}
			
			return false;
		}
		
		int GetNewID()
		{
			int id = 0;
			foreach(Ticket ticket in data.tickets)
			{
				if(ticket.ticketID > id) id = ticket.ticketID;
			}
			
			return id + 1;
		}
		
		Ticket GetTicketByID(int id)
		{
			foreach(Ticket ticket in data.tickets)
			{
				if(ticket.ticketID == id) return ticket;
			}
			
			return null;
		}
		
		bool IsAdmin(BasePlayer player, bool reply)
		{
			if(reply && permission.UserHasPermission(player.userID.ToString(), "ticket.admin") == false) SendChatMessage(player, "Tickets", "You do not have permission to use this command.");
			if(permission.UserHasPermission(player.userID.ToString(), "ticket.admin")) return true;
			return false;
		}
		
		void ShowSyntax(BasePlayer player)
		{
			if(IsAdmin(player, false))
			{
				SendChatMessage(player, "Tickets", "\n/ticket reply <ID> <Message>\n" +
					"/ticket add <Message>\n" +
					"/ticket remove <ID>\n" +
					"/ticket view <ID>\n" +
					"/ticket tp <ID>\n" +
					"/ticket list\n" +
					"/ticket clear\n"
				);
			}					
			else 
			{
				SendChatMessage(player, "Tickets", "\n/ticket add <Message>\n" +
					"/ticket remove <ID>\n" +
					"/ticket view <ID>\n" +
					"/ticket list\n"
				);
			}
		}
		
		[ChatCommand("clear")]
		void Clear(BasePlayer player)
		{
			for(int i = 200; i > 0; i--)
			{
				player.ConsoleMessage("<color=white>Â²</color>\n");
			}
		}

		[ChatCommand("ticket")]
		void cmdTicket(BasePlayer player, string cmd, string[] args)
		{
			if(args.Length == 0)
			{
				ShowSyntax(player);
				
				return;
			}
			
			if(args.Length == 1)
			{
				switch(args[0])
				{
					case "list":
						TicketFunction("list", "none", player);
						break;
						
					case "clear":
						if(!IsAdmin(player, true)) return; 
						TicketFunction("clear", "none", player);
						break;
						
					default:
						ShowSyntax(player);
						break;
				}
				
				return;
			}
			
			if(args.Length >= 2 && args[0] == "add")
			{
				TicketFunction("add", ListToString(args.ToList(), 1, " "), player);
				
				return;
			}
			
			if(args.Length == 2)
			{
				switch(args[0])
				{			
					case "remove":
						TicketFunction("remove", args[1], player);
						break;
						
					case "view":
						TicketFunction("view", args[1], player);
						break;
						
					case "tp":
						if(!IsAdmin(player, true)) return;
						TicketFunction("tp", args[1], player);
						break;
						
					default:
						ShowSyntax(player);
						break;
				}
				
				return;
			}
			
			if(args.Length >= 3 && args[0] == "reply")
			{
				if(!IsAdmin(player, true)) return;
				TicketFunction("reply", ListToString(args.ToList(), 1, " "), player);
				
				return;
			}
		}
		
		void TicketFunction(string function, string arg, BasePlayer player)
		{
			switch(function)
			{
				case "reply":
					SendTicketReply(arg);
					SendChatMessage(player, "Tickets", "Your reply has been submitted.");
					break;
					
				case "add":
					int id = GetNewID();
					Puts(player.transform.position.x.ToString());
					data.tickets.Add(new Ticket(id, player, arg));
					SendToAPI(new Ticket(id, player, arg));
					SendChatMessage(player, "Tickets", $"Your Ticket has been submitted. <color=#00FF8D>Ticket ID {id}</color>");
					
					foreach(BasePlayer current in BasePlayer.activePlayerList)
					{
						if(IsAdmin(current, false)) SendChatMessage(current, "Tickets", $"A new Ticket has been submitted. <color=#00FF8D>Ticket ID {id}</color>. To view it type <color=#00FF8D>/ticket view {id}</color>");
					}
					
					break;
						
				case "remove":
					if(IsAdmin(player, false))
					{
						foreach(Ticket ticket in data.tickets)
						{
							if(ticket.ticketID.ToString() == arg) 
							{
								data.tickets.Remove(ticket);
								SendChatMessage(player, "Tickets", $"Removed Ticket {ticket.ticketID.ToString()}");
								break;
							}
						}
					}
					else
					{
						foreach(Ticket ticket in data.tickets)
						{
							if(ticket.ticketID.ToString() == arg && ticket.steamID == player.userID.ToString())
							{
								data.tickets.Remove(ticket);
								SendChatMessage(player, "Tickets", $"Removed Ticket {ticket.ticketID.ToString()}");
								break;
							}
						}
					}
					break;
						
				case "view":
					if(IsAdmin(player, false))
					{
						foreach(Ticket ticket in data.tickets)
						{
							if(ticket.ticketID.ToString() == arg)
							{
								SendChatMessage(player, "Tickets", $"<color=white><color=#00FF8D>------------------ Ticket {ticket.ticketID} ------------------</color>\n" +
									$"<color=#00FF8D>Timestamp:</color> {ticket.timestamp}\n" +
									$"<color=#00FF8D>Player:</color> {ticket.player}\n" +
									$"<color=#00FF8D>SteamID:</color> {ticket.steamID}\n" +
									$"<color=#00FF8D>Steam Profile:</color> {ticket.profile}\n" +
									$"<color=#00FF8D>Position</color>: {ticket.position}\n" +
									$"<color=#00FF8D>Message</color>: {ticket.message}\n" +
									$"<color=#00FF8D>Reply</color>: {ticket.reply}</color>"
								);
								
								player.ConsoleMessage($"<color=white><color=#00FF8D>------------------ Ticket {ticket.ticketID} ------------------</color>\n" +
									$"<color=#00FF8D>Timestamp:</color> {ticket.timestamp}\n" +
									$"<color=#00FF8D>Player:</color> {ticket.player}\n" +
									$"<color=#00FF8D>SteamID:</color> {ticket.steamID}\n" +
									$"<color=#00FF8D>Steam Profile:</color> {ticket.profile}\n" +
									$"<color=#00FF8D>Position</color>: {ticket.position}\n" +
									$"<color=#00FF8D>Message</color>: {ticket.message}\n" +
									$"<color=#00FF8D>Reply</color>: {ticket.reply}</color>"
								);
							}
						}
					}
					else
					{
						foreach(Ticket ticket in data.tickets)
						{
							if(ticket.ticketID.ToString() == arg && ticket.steamID == player.userID.ToString())
							{
								SendChatMessage(player, "Tickets", $"<color=white><color=#00FF8D>------------------ Ticket {ticket.ticketID} ------------------</color>\n" +
									$"<color=#00FF8D>Timestamp:</color> {ticket.timestamp}\n" +
									$"<color=#00FF8D>Message</color>: {ticket.message}\n" +
									$"<color=#00FF8D>Reply</color>: {ticket.reply}</color>"
								);
							}
							
						}
					}
					break;
						
				case "tp":
					foreach(Ticket ticket in data.tickets)
					{
						if(ticket.ticketID.ToString() == arg)
						{
							Teleport(player, new Vector3(ticket.x, ticket.y, ticket.z));
							SendChatMessage(player, "Tickets", $"Teleported to the position where <color=#00FF8D>Ticket {ticket.ticketID.ToString()}</color> has been submitted.");
							break;
						}
					}
					break;
				
				case "list":
					if(IsAdmin(player, false))
					{
						if(data.tickets.Count == 0) SendChatMessage(player, "Tickets", $"There are no active tickets.");
						else SendChatMessage(player, "Tickets", $"Tickets are shown in your player console. Press F1.");
						
						foreach(Ticket ticket in data.tickets)
						{
							player.ConsoleMessage($"\n\n<color=white><color=#00FF8D>------------------------------- Ticket {ticket.ticketID} -------------------------------</color>\n" +
								$"<color=#00FF8D>Timestamp:</color> {ticket.timestamp}\n" +
								$"<color=#00FF8D>Player</color>: {ticket.player}\n" +
								$"<color=#00FF8D>SteamID</color>: {ticket.steamID}\n" +
								$"<color=#00FF8D>Steam Profile</color>: {ticket.profile}\n" +
								$"<color=#00FF8D>Position</color>: {ticket.position}\n" +
								$"<color=#00FF8D>Message</color>: {ticket.message}\n" +
								$"<color=#00FF8D>Reply</color>: {ticket.reply}</color>\n\n"
							);
						}
					}
					else
					{
						int count = 0;
						
						foreach(Ticket ticket in data.tickets)
						{
							if(ticket.steamID != player.userID.ToString()) continue;
							count++;
							
							player.ConsoleMessage($"\n\n<color=white><color=#00FF8D>------------------------------- Ticket {ticket.ticketID} -------------------------------</color>\n" +
								$"<color=#00FF8D>Timestamp:</color> {ticket.timestamp}\n" +
								$"<color=#00FF8D>Message</color>: {ticket.message}\n" +
								$"<color=#00FF8D>Reply</color>: {ticket.reply}</color>\n\n"
							);
						}
						
						if(count == 0) SendChatMessage(player, "Tickets", $"There are no active tickets.");
						else SendChatMessage(player, "Tickets", $"Tickets are shown in your player console. <color=#00FF8D>Press F1.</color>");
					}
					break;
						
				case "clear":
					data.tickets.Clear();
					SendChatMessage(player, "Tickets", "Cleared all tickets.");
					break;
				
				default:
					break;
			}
			
			SaveData();
		}
		
		void SendTicketReply(string arg)
		{
			List<string> args = arg.Split(' ').ToList();
			
			int id = Convert.ToInt32(args[0]);
			string message = ListToString(args.ToList(), 1, " ");
			
			Ticket ticket = GetTicketByID(id);
			BasePlayer player = BasePlayer.Find(ticket.player);
			
			foreach(Ticket current in data.tickets)
			{
				if(current.ticketID == id) current.reply = message;
			}
			
			SaveData();
			
			if(player.IsConnected())
			{
				SendChatMessage(player, "Tickets", $"A reply to your Ticket has been made. To view it type <color=#00FF8D>/ticket view {ticket.ticketID.ToString()}</color>");
			}
		}
		
		void Teleport(BasePlayer player, Vector3 destination)
		{
			player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
			if(!BasePlayer.sleepingPlayerList.Contains(player))	BasePlayer.sleepingPlayerList.Add(player);
			
			player.CancelInvoke("InventoryUpdate");
			player.inventory.crafting.CancelAll(true);
			
			player.MovePosition(destination);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", destination, null, null, null, null);
			player.TransformChanged();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
			player.UpdateNetworkGroup();
			
			player.SendNetworkUpdateImmediate(false);
			player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
			player.SendFullSnapshot();
		}
		
        #region UsefulMethods
        //--------------------------->   Player finding   <---------------------------//

		BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix)
        {
            BasePlayer targetPlayer = null;
            List<string> foundPlayers = new List<string>();
            string searchedLower = searchedPlayer.ToLower();
            
			foreach(BasePlayer player in BasePlayer.activePlayerList)
			{
				if(player.displayName.ToLower().Contains(searchedLower)) foundPlayers.Add(player.displayName);
			}
			
			switch(foundPlayers.Count)
			{
				case 0:
					SendChatMessage(executer, prefix, "The Player can not be found.");
					break;
					
				case 1:
					targetPlayer = BasePlayer.Find(foundPlayers[0]);
					break;
				
				default:
					string players = ListToString(foundPlayers, 0, ", ");
					SendChatMessage(executer, prefix, "Multiple matching players found: \n" + players);
					break;
			}
			
            return targetPlayer;
        }

        //---------------------------->   Converting   <----------------------------//

        string ListToString(List<string> list, int first, string seperator)
		{
			return String.Join(seperator, list.Skip(first).ToArray());
		}

        //------------------------------>   Config   <------------------------------//

        void SetConfig(string Arg1, object Arg2, object Arg3 = null, object Arg4 = null)
		{
			if(Arg4 == null) 
			{
				Config[Arg1, Arg2.ToString()] = Config[Arg1, Arg2.ToString()] ?? Arg3;
			}
			else if(Arg3 == null) 
			{
				Config[Arg1] = Config[Arg1] ?? Arg2;
			}
			else
			{
				Config[Arg1, Arg2.ToString(), Arg3.ToString()] = Config[Arg1, Arg2.ToString(), Arg3.ToString()] ?? Arg4;
			} 
		}

        //---------------------------->   Chat Sending   <----------------------------//

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        //---------------------------------------------------------------------------//
        #endregion
    }
}


// --- End of file: Tickets.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlockRemover.cs ---
// --- Original Local Path: BlockRemover.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Block Remover", "bawNg / Nogrod", "0.4.1")]
    class BlockRemover : RustPlugin
    {
        private ConfigData configData;
        private readonly FieldInfo entityListField = typeof(BaseNetworkable.EntityRealm).GetField("entityList", BindingFlags.Instance | BindingFlags.NonPublic);
        private readonly FieldInfo instancesField = typeof(MeshColliderBatch).GetField("instances", BindingFlags.Instance | BindingFlags.NonPublic);
        private readonly Collider[] colBuffer = (Collider[])typeof(Vis).GetField("colBuffer", (BindingFlags.Static | BindingFlags.NonPublic)).GetValue(null);
        private const string PermCount = "blockremover.count";
        private const string PermRemove = "blockremover.remove";

        class ConfigData
        {
            public float CupboardDistance { get; set; }
            public VersionNumber Version { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new ConfigData
            {
                CupboardDistance = 30f,
                Version = Version
            }, true);
        }

        void Loaded()
        {
            configData = Config.ReadObject<ConfigData>();
            if (configData.Version != Version)
            {
                configData.Version = Version;
                Config.WriteObject(configData, true);
            }
            permission.RegisterPermission(PermCount, this);
            permission.RegisterPermission(PermRemove, this);
        }

        [ConsoleCommand("block.countall")]
        void cmdCountBlockAll(ConsoleSystem.Arg arg)
        {
            if (!CheckAccess(arg, PermCount)) return;
            var stabilityEntities = FindAllCupboardlessStabilityEntities();
            SendReply(arg, $"There are {stabilityEntities.Count} blocks outside of cupboard range");
        }

        [ConsoleCommand("block.count")]
        void cmdCountBlock(ConsoleSystem.Arg arg)
        {
            if (!CheckAccess(arg, PermCount)) return;
            BuildingGrade.Enum grade;
            if (!ParseGrade(arg, out grade)) return;
            var blocks = FindAllCupboardlessBlocks(grade);
            SendReply(arg, $"There are {blocks.Count} {grade} blocks outside of cupboard range");
        }

        [ConsoleCommand("block.remove")]
        void cmdRemoveBlock(ConsoleSystem.Arg arg)
        {
            if (!CheckAccess(arg, PermRemove)) return;
            BuildingGrade.Enum grade;
            if (!ParseGrade(arg, out grade)) return;
            PrintToChat($"<color=red>Admin is removing all {grade} blocks outside of cupboard range...</color>");
            var blocks = FindAllCupboardlessBlocks(grade);
            var started_at = Time.realtimeSinceStartup;
            foreach (var building_block in blocks)
                building_block.Kill();
            Puts($"Destroyed {blocks.Count} {grade} blocks in {Time.realtimeSinceStartup - started_at:0.000} seconds");
            PrintToChat($"<color=yellow>Admin has removed {blocks.Count} {grade} blocks from the map</color>");
        }

        [ConsoleCommand("block.removeall")]
        void cmdRemoveBlockAll(ConsoleSystem.Arg arg)
        {
            if (!CheckAccess(arg, PermRemove)) return;
            PrintToChat("<color=red>Admin is removing all blocks outside of cupboard range...</color>");
            var stabilityEntities = FindAllCupboardlessStabilityEntities();
            var started_at = Time.realtimeSinceStartup;
            foreach (var building_block in stabilityEntities)
                building_block.Kill();
            Puts($"Destroyed {stabilityEntities.Count} blocks in {Time.realtimeSinceStartup - started_at:0.000} seconds");
            PrintToChat($"<color=yellow>Admin has removed {stabilityEntities.Count} blocks from the map</color>");
        }

        HashSet<BuildingBlock> FindAllCupboardlessBlocks(BuildingGrade.Enum grade)
        {
            var blocks = FindAllBuildingBlocks(grade);
            FilterAllCupboardless(blocks);
            return blocks;
        }

        HashSet<StabilityEntity> FindAllCupboardlessStabilityEntities()
        {
            var stabilityEntities = FindAllStabilityEntities();
            FilterAllCupboardless(stabilityEntities);
            return stabilityEntities;
        }

        void FilterAllCupboardless<T>(HashSet<T> blocks) where T : StabilityEntity
        {
            var toolCupboards = FindAllToolCupboards();
            float squaredDist = configData.CupboardDistance * configData.CupboardDistance;
            var started_at = Time.realtimeSinceStartup;
            foreach (var cupboard in toolCupboards)
            {
                var count = Physics.OverlapSphereNonAlloc(cupboard.transform.position, configData.CupboardDistance, colBuffer, 270532864);
                for (var i = 0; i < count; i ++)
                {
                    var collider = colBuffer[i];
                    colBuffer[i] = null;
                    if (!collider.transform.CompareTag("MeshColliderBatch"))
                    {
                        var buildingBlock = collider.GetComponentInParent<T>();
                        if (buildingBlock) blocks.Remove(buildingBlock);
                    }
                    else
                    {
                        var batch = collider.transform.GetComponent<MeshColliderBatch>();
                        var instances = (ListDictionary<Component, ColliderCombineInstance>)instancesField.GetValue(batch);
                        foreach (var item in instances.Values)
                        {
                            if ((item.bounds.ClosestPoint(cupboard.transform.position) - cupboard.transform.position).sqrMagnitude <= squaredDist)
                            {
                                var buildingBlock = item.collider?.GetComponentInParent<T>();
                                if (buildingBlock) blocks.Remove(buildingBlock);
                            }
                        }
                    }
                }
            }
            Puts($"Finding {blocks.Count} cupboardless blocks took {Time.realtimeSinceStartup - started_at:0.000} seconds");
        }

        HashSet<BuildingBlock> FindAllBuildingBlocks(BuildingGrade.Enum grade)
        {
            var started_at = Time.realtimeSinceStartup;
            var blocks = new HashSet<BuildingBlock>(((ListDictionary<uint, BaseNetworkable>)entityListField.GetValue(BaseNetworkable.serverEntities)).Values.OfType<BuildingBlock>().Where(block => block.grade == grade));
            Puts($"Finding {blocks.Count} {grade} blocks took {Time.realtimeSinceStartup - started_at:0.000} seconds");
            return blocks;
        }

        HashSet<StabilityEntity> FindAllStabilityEntities()
        {
            var started_at = Time.realtimeSinceStartup;
            var stabilityEntities = new HashSet<StabilityEntity>(((ListDictionary<uint, BaseNetworkable>)entityListField.GetValue(BaseNetworkable.serverEntities)).Values.OfType<StabilityEntity>());
            Puts($"Finding {stabilityEntities.Count} blocks took {Time.realtimeSinceStartup - started_at:0.000} seconds");
            return stabilityEntities;
        }

        BuildingPrivlidge[] FindAllToolCupboards()
        {
            var started_at = Time.realtimeSinceStartup;
            var toolCupboards = UnityEngine.Object.FindObjectsOfType<BuildingPrivlidge>();
            Puts($"Finding {toolCupboards.Length} tool cupboards took {Time.realtimeSinceStartup - started_at:0.000} seconds");
            return toolCupboards;
        }

        bool CheckAccess(ConsoleSystem.Arg arg, string perm)
        {
            if (arg != null && arg.connection == null || arg.Player() != null && (arg.Player().IsAdmin() || permission.UserHasPermission(arg.Player().UserIDString, perm)))
                return true;
            SendReply(arg, "You need to be admin to use that command");
            return false;
        }

        bool ParseGrade(ConsoleSystem.Arg arg, out BuildingGrade.Enum grade)
        {
            grade = BuildingGrade.Enum.Twigs;
            if (arg.HasArgs())
            {
                try
                {
                    grade = (BuildingGrade.Enum)Enum.Parse(typeof(BuildingGrade.Enum), arg.GetString(0), true);
                }
                catch (Exception)
                {
                    SendReply(arg, $"Unknown grade '{arg.GetString(0)}'");
                    return false;
                }
            }
            return true;
        }
    }
}


// --- End of file: BlockRemover.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XDGoldenskull.cs ---
// --- Original Local Path: XDGoldenskull.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using ConVar;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("XDGoldenskull", "Sempai#3239", "1.0.9")]
    public class XDGoldenskull : RustPlugin
    {


        
        
        [ChatCommand("g.give")]
        private void cmdChatEmerald(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;
            config.CreateItem(player, Vector3.zero, 10);
        }
        [PluginReference] Plugin IQChat;
        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, "");
            else
                player.SendConsoleCommand("chat.add", channel, 0, Message);
        }

        object CanBeRecycled(Item item, Recycler recycler)
        {
            if (item == null)
                return false;
            if (item.info.shortname == ReplaceShortName && item.skin == config.ReplaceID)
                return true;
            return null;
        }
        private class Configuration
        {

            public void CreateItem(BasePlayer player, Vector3 position, int amount)
            {
                Item x = ItemManager.CreateByPartialName(ReplaceShortName, amount);
                x.skin = ReplaceID;
                x.name = DisplayName;
                x.info.stackable = StackItem;

                if (player != null)
                {
                    if (player.inventory.containerMain.itemList.Count < 24)
                        x.MoveToContainer(player.inventory.containerMain);
                    else
                        x.Drop(player.transform.position, Vector3.zero);
                    return;
                }

                if (position != Vector3.zero)
                {
                    x.Drop(position, Vector3.down);
                    return;
                }
            }
            [JsonProperty("Стак предмета")]
            public int StackItem;
            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("Из каких бочек будет падать и процент выпадения")]
            public Dictionary<string, int> barellList = new Dictionary<string, int>();
            [JsonProperty("Призы за переработку")]
            public List<string> itemsrec = new List<string>();
            [JsonProperty("Призы за потрошения")]
            public List<string> itempot = new List<string>();

            public int GetItemId() => ItemManager.FindItemDefinition(ReplaceShortName).itemid;
            [JsonProperty("Скин ID черепа")]
            public ulong ReplaceID;
            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    DisplayName = "Золотой череп",
                    StackItem = 5,
                    ReplaceID = 1683645276,
                    barellList = new Dictionary<string, int>
                    {
                        ["loot-barrel-1"] = 50,
                        ["loot-barrel-2"] = 20,
                    },
                    cratelList = new Dictionary<string, int>
                    {
                        ["bradley_crate"] = 50,
                        ["codelockedhackablecrate_oilrig"] = 20,
                        ["crate_elite"] = 20,
                    },
                    itemsrec = new List<string>
                    {
                        "weapon.mod.small.scope",
                        "rifle.ak",
                        "rifle.l96",
                        "smg.thompson",
                        "rifle.semiauto",
                        "pistol.revolver",
                        "rifle.lr300",
                    },
                    itempot = new List<string>
                    {
                        "shotgun.double",
                        "grenade.f1",
                        "smg.2",
                        "shotgun.pump",
                        "pistol.semiauto",
                        "pistol.python",
                        "weapon.mod.lasersight",
                        "weapon.mod.muzzlebrake",
                    },
                };
            }
            [JsonProperty("Из каких ящиков будет падать и процент выпадения")]
            public Dictionary<string, int> cratelList = new Dictionary<string, int>();

            public Item Copy(int amount = 1)
            {
                Item x = ItemManager.CreateByPartialName(ReplaceShortName, amount);
                x.skin = ReplaceID;
                x.name = DisplayName;
                x.info.stackable = StackItem;

                return x;
            }
        }
        private const string ReplaceShortName = "skull.human";

        
               
        void OnServerInitialized() => lootContainerList = config.cratelList.Concat(config.barellList);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #495" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        
                private Item CreateItem()
        {
            return config.Copy(1);
        }

        private static System.Random random = new System.Random();
        private IEnumerable<KeyValuePair<string, int>> lootContainerList = null;
        private void OnLootSpawn(LootContainer container)
        {
            if (container == null || lootContainerList == null)
                return;
		   		 		  						  	   		  		 			  	  			  						  		  
            foreach (var crate in lootContainerList)
            {
                if (container.PrefabName.Contains(crate.Key))
                {
                    if (random.Next(0, 100) >= (100 - crate.Value))
                    {
                        InvokeHandler.Instance.Invoke(() =>
                        {
                            if (container.inventory.capacity <= container.inventory.itemList.Count)
                            {
                                container.inventory.capacity = container.inventory.itemList.Count + 1;
                            }
                            Item item = (Item)CreateItem();
                            item?.MoveToContainer(container.inventory);
                        }, 0.21f);
                    }
                }
            }
        }

        object OnRecycleItem(Recycler recycler, Item item)
        {
            if (item.info.shortname == ReplaceShortName && item.skin == config.ReplaceID)
            {
                item.UseItem(1);
                int RandomItem = random.Next(config.itemsrec.Count);
                recycler.MoveItemToOutput(ItemManager.CreateByName(config.itemsrec[RandomItem], 1));
                return true;
            }
            return null;
        }
		   		 		  						  	   		  		 			  	  			  						  		  
        [ConsoleCommand("goldenskul")]
        void FishCommand(ConsoleSystem.Arg arg)
        {

            BasePlayer player = BasePlayer.Find(arg.Args[0]);
            if (player == null || !player.IsConnected)
            {
                Puts("Игрок не найден");
                return;
            }
            int count = int.Parse(arg.Args[1]);
            config.CreateItem(player, Vector3.zero, count);
            SendChat(player, $"Вы успешно получили {config.DisplayName}");
            Puts($"Игроку выдана {config.DisplayName}");
        }

        object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (action == "crush" && item.skin == config.ReplaceID)
            {
                Item itemS = ItemManager.CreateByName(config.itempot[random.Next(config.itempot.Count)], 1, 0);
                player.GiveItem(itemS, BaseEntity.GiveItemReason.PickedUp);
                ItemRemovalThink(item, player, 1);
                Interface.CallHook("OnSkullOpen", player);
                return false;
            }
            return null;
        }
        object CanRecycle(Recycler recycler, Item item)
        {
            if (item.info.shortname == ReplaceShortName && item.skin == config.ReplaceID)
                return true;
            return null;
        }
        private static void ItemRemovalThink(Item item, BasePlayer player, int itemsToTake)
        {
            if (item.amount == itemsToTake)
            {
                item.RemoveFromContainer();
                item.Remove();
            }
            else
            {
                item.amount = item.amount - itemsToTake;
                player.inventory.SendSnapshot();
            }
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();

        
        private static Configuration config = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(config);
            }
}


// --- End of file: XDGoldenskull.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/1Logger.cs ---
// --- Original Local Path: 1Logger.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Security;


namespace Oxide.Plugins
{
    [Info("Logger", "Frizen", "1.0.0")]
    [Description("Отправляет логи всех комманд сервера")]
    public class Logger : RustPlugin
    {
        #region Конфиг
        [JsonProperty("Токен от группы ВК(От группы будут идти сообщения в беседу.Вам нужно добавить свою группу в беседу!)")]
        public string Token = "vk1.a.YOBvY6tuSILbwgJExldgCEcqqWC23lVkf61rdvF6vgfvGr0wfH2DShguYsLy8dlxfkEEWDJArDHMhxh-TV_HnYP14RysqMzMMZcI1bRfhbg3Ts7KDsj8NtI72QFJnQB_2F2MEEtU1OHtRyrRHtail4VdmuIjLHWtmiTAUhucxmVyIa5eRcxTsTrO3CZgJzEx6GujaNm8oe8mI3_p83xsQQ";

        [JsonProperty("ID беседы для группы")]
        public string ChatID = "1";


        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Логировать сообщения в чате (true/false)")]
            public bool LogChat { get; set; } = true;

            [JsonProperty(PropertyName = "Логировать использования комманд (true/false)")]
            public bool LogCommands { get; set; } = true;

            [JsonProperty(PropertyName = "Логировать заходы (true/false)")]
            public bool LogConnections { get; set; } = true;

            [JsonProperty(PropertyName = "Логировать выходы (true/false)")]
            public bool LogDisconnections { get; set; } = true;


            [JsonProperty(PropertyName = "Вывод логов вк и сохранение файла с логами (true/false)")]
            public bool LogToConsole { get; set; } = false;

            [JsonProperty("Причина кика за VPN")]
            public string KickPlayerMessage = "Вход с VPN запрещён!";

            [JsonProperty("Причина кика за AdminAbuse")]
            public string AdminAbuse = "Хуй тебе,а не админка";

            [JsonProperty(PropertyName = "Логировать по дням (true/false)")]
            public bool RotateLogs { get; set; } = true;

            [JsonProperty(PropertyName = "Лист комманд (полные или краткие)")]
            public List<string> CommandList { get; set; } = new List<string>
            {
                /*"help", "version", "chat.say", "global.kill",
                "global.status", "global.wakeup",
                "inventory.endloot", "inventory.unlockblueprint"*/
            };
            [JsonProperty("Список SteamID которых не нужно проверять")]

            public List<ulong> IgnoreList { get; set; } = new List<ulong>() { };

            [JsonProperty(PropertyName = "Тип списка команд (blacklist or whitelist)")]
            public string CommandListType { get; set; } = "blacklist";

            //[JsonProperty(PropertyName = "Item list (full or short names)")]
            //public List<string> ItemList { get; set; } = new List<string>
            //{
            //    /*"rock", "torch"*/
            //};

            //[JsonProperty(PropertyName = "Item list type (blacklist or whitelist)")]
            //public string ItemListType { get; set; } = "blacklist";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            string configPath = $"{Interface.Oxide.ConfigDirectory}{Path.DirectorySeparatorChar}{Name}.json";
            Puts($"Конфиг кривой,создаём новый по пути: {configPath}");
            config = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion Configuration

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandReason"] = "причина",
                ["ItemDropped"] = "{0} ({1}) dropped {2} {3}",
                ["NotAllowed"] = "тебе нельзя выполнять команду '{0}'",
                ["PlayerCommand"] = "{0} ({1}) выполненная команда: {2} {3}",
                ["PlayerConnected"] = "{0} ({1}) зашёл на сервер с {2}",
                ["PlayerDisconnected"] = "{0} ({1}) вышел с сервера",
                ["PlayerMessage"] = "{0} ({1}) написал: {2}",
                ["RconCommand"] = "{0} выполнил команду: {1} {2}",
                ["ServerCommand"] = "SERVER выполнил команду: {0} {1}"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string commandReason = "loggerreason";
        private const string permReason = "logger.reason";

        private void Init()
        {
            permission.RegisterPermission(permReason, this);

            AddCovalenceCommand(commandReason, "ReasonCommand");
            AddLocalizedCommand("CommandReason", "ReasonCommand");

            if (!config.LogChat) Unsubscribe("OnUserChat");
            if (!config.LogCommands) Unsubscribe("OnServerCommand");
            if (!config.LogConnections) Unsubscribe("OnUserConnected");
            if (!config.LogDisconnections) Unsubscribe("OnUserDisconnected");
        }

        #endregion Initialization

        #region Logging

        private void OnUserChat(IPlayer player, string message) => Log("chat", "PlayerMessage", player.Name, player.Id, message);

        private void OnUserConnected(IPlayer player) => Log("connections", "PlayerConnected", player.Name, player.Id, player.Address);

        private void OnUserDisconnected(IPlayer player) => Log("disconnections", "PlayerDisconnected", player.Name, player.Id);



        private void OnRconCommand(IPEndPoint ip, string command, string[] args)
        {
            if (command == "chat.say" || command == "say")
            {
                return;
            }

            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains(command))
            {
                return;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains(command))
            {
                return;
            }

            Log("commands", "RconCommand", ip.Address, command, string.Join(" ", args));
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;
            var serverCommand = ConsoleSystem.Index.Server.Find(command);

            if (serverCommand != null &&
                serverCommand.ServerAdmin && serverCommand.ServerUser == false)
            {
                if(arg.Connection != null)
                {
                    var player = arg.Connection.player as global::BasePlayer;

                    if (player != null)
                    {
                        if (config.IgnoreList.Contains(player.userID) == false)
                        {
                            Puts($"Обнаружена нелегальная админа({player.userID}): " + fullCommand);
                            VKSendMessage($"Обнаружена нелегальная админа({player.userID}): " + fullCommand);
                            return false;
                        }
                    }
                }
            }

            if (fullCommand == "chat.say")
            {
                return null;
            }

            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains(fullCommand))
            {
                return null;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains(fullCommand))
            {
                return null;
            }

            if (arg.Connection != null)
            {
                Log("commands", "PlayerCommand", arg.Connection.username.Sanitize(), arg.Connection.userid, fullCommand, arg.FullString);
            }
            else
            {
                Log("commands", "ServerCommand", fullCommand, arg.FullString);
            }
            return null;
        }
        private void OnUserCommand(IPlayer player, string command, string[] args)
        {
            if (config.CommandListType.ToLower() == "blacklist" && config.CommandList.Contains(command) || config.CommandList.Contains("/" + command))
            {
                return;
            }

            if (config.CommandListType.ToLower() == "whitelist" && !config.CommandList.Contains(command) && !config.CommandList.Contains("/" + command))
            {
                return;
            }

            Log("commands", "PlayerCommand", player.Name, player.Id, command, string.Join(" ", args));
        }

        #endregion Logging

        #region Command

        private void ReasonCommand(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permReason))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            Log("reasons", "Reason");
            Message(player, "ReasonLogged", string.Join(" ", args));
        }

        #endregion Command

        #region Helpers

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void AddLocalizedCommand(string key, string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages.Where(m => m.Key.Equals(key)))
                {
                    if (!string.IsNullOrEmpty(message.Value))
                    {
                        AddCovalenceCommand(message.Value, command);
                    }
                }
            }
        }
        void VKSendMessage(string Message)
        {
            if (String.IsNullOrEmpty(ChatID) || String.IsNullOrEmpty(Token))
            {
                PrintWarning("Вы не настроили конфигурацию,в пункте с ВК");
                return;
            }
            int RandomID = UnityEngine.Random.Range(0, 9999);
            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");
            webrequest.EnqueueGet($"https://api.vk.com/method/messages.send?chat_id={ChatID}&random_id={RandomID}&message={Message}&access_token={Token}&v=5.92", (code, response) => { }, this);
        }

        private void Log(string filename, string key, params object[] args)
        {
            if (config.LogToConsole)
            {
                VKSendMessage(Lang(key, null, args));
            }
            LogToFile(filename, $"[{DateTime.Now}] {Lang(key, null, args)}", this);
        }

        private void Message(IPlayer player, string key, params object[] args)
        {
            player.Reply(Lang(key, player.Id, args));
        }


        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsAdmin)
            {
                if (config.IgnoreList.Contains(player.userID)) return;

                timer.Every(5, () =>
                {
                    player.Kick(config.AdminAbuse);
                    VKSendMessage($"Игрок {player.displayName} [{player.UserIDString}] был кикнут за попытку админ абуза");
                });
            }



            string url = $"http://proxycheck.io/v2/{player.net.connection.ipaddress.Split(':')}?key=495220-1i36da-318095-341615&vpn=1&asn=1&risk=1&port=1&seen=1&days=7&tag=msg";
            webrequest.EnqueueGet(url, (code, response) =>
            {
                if (response == null || code != 200) { return; }

                if (response.Contains("VPN") || response.Contains("yes"))
                {
                    VKSendMessage($"Игрок {player.displayName} [{player.UserIDString}] был кикнут за использования VPN");
                    player.Kick(config.KickPlayerMessage);
                }
            }, this);
        }



        #endregion Helpers
    }
}


// --- End of file: 1Logger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Payback.cs ---
// --- Original Local Path: Payback.cs ---

﻿
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;
using System.Collections;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using System;
using System.Linq;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using Rust;
using Rust.Ai;
using Network;

namespace Oxide.Plugins
{
    [Info("Payback", "Sempai#3239", "1.9.7")]
    [Description("Специальные команды администратора для борьбы с читерами")]
    class Payback : RustPlugin
    {

        //| ==============================================================
        //| Definitions
        //| ==============================================================
        public enum Card
        {
            Pacifism = 0,//обнуляет весь исходящий урон от целевого игрока
            Butterfingers = 1,//при нанесении урона любому игроку, шанс бросить текущее оружие.
            InstantKarma = 4,//отражает урон обратно игроку
            Dud = 5,//предотвращает повреждение неигровых объектов
            DogDoo = 6,//мина под игроком-мишенью, когда тот получает доступ к тайникам
            BSOD = 7,//дать целевому игроку поддельное сообщение о критическом сбое в ОС
            Sit = 8,//заставить игрока сесть
            Naked = 9,//заставить игрока бросить все, что у него есть в инвентаре
            Camomo = 10,//применить комбинацию способностей, которую выбрал Камомо
            HigherGround = 11,//целевой игрок телепортируется на 100 м в воздух
            Thirsty = 12,//целевой игрок очень быстро испытывает жажду
            DrNo = 13, // целевой игрок больше не получает здоровье от исцеляющих предметов
            Dana = 14, // украсть инвентарь целевого игрока и поместить его в свой
            Pinyata = 15, // инвентарь целевого игрока вылетает из него, когда он умирает
            Rocketman, // привяжите целевого игрока к ракете и запустите его!
            NoRest, // Нет мира для нечестивых! Заставьте игрока переродиться!
            ChickenChaser, // Порождает орду цыплят с суперскоростью, которые атакуют только целевого игрока!
            ViewLoot, // Просмотреть добычу целевых объектов
            Burn, // Дает игроку огнемет, который заставит его врагов кричать и гореть.
            Hammer, // молот - дает целевому игроку молот, который уничтожает все сущности, принадлежащие цели молота
            Bag, // Мешок — вывести всех игроков, в которых попал целевой игрок, и всех игроков, которые попали в мешки. Включите «discord» после команды для записи результатов в discord.
            Shocker, // Шокер - поразить игрока до смерти.  Затрагивает игроков поблизости, поэтому будьте осторожны.  Обязательно отключите его после использования.
            //Cowboy, // Ковбой - оседлайте целевого игрока как дикую свинью -> не удалось заставить это работать
            Masochist, // Мазохист - остановить игрока от самоубийства в F1
            Emote, // Эмоция - варианты:
            Shark, // Челюсти - акула приходит, чтобы съесть мошенника
        }

        Dictionary<Card, string> descriptions = new Dictionary<Card, string>() {
            {Card.Butterfingers, "% шанс для целевого игрока бросить оружие при нанесении урона противнику" },
            {Card.Dud, "целевой игрок не наносит урона существам НЕ-ИГРОКАМ. Также предотвращает фермерство / tool use" },
            {Card.InstantKarma, "целевой игрок не наносит врагам никакого урона, а 35% урона отражается обратно к нему" },
            {Card.Pacifism, "целевой игрок не наносит игрового урона товарищам по команде; добавьте 'silent', чтобы не посылать сообщение об этом другим игрокам." },
            {Card.DogDoo, "мина под целевым игроком, когда он получает доступ к тайнику" },
            {Card.BSOD, "целевой игрок получает фальшивый синий экран смерти" },
            {Card.Sit, "Порождает стул перед вами и заставляет читера сесть.  Не позволяет ему встать и усаживает его обратно, если он умирает." },
            {Card.Naked, "заставить игрока бросить все, что у него есть в инвентаре" },
            {Card.Camomo, "применять комбинацию способностей, выбранных Камомо [pf,bf,in,dog,dud,dr]" },
            {Card.HigherGround, "целевой игрок телепортируется на 100 м в воздух" },
            {Card.Thirsty, "целевой игрок очень быстро испытывает жажду" },
            {Card.DrNo, "целевой игрок больше не может лечиться" },
            {Card.Dana, "украсть инвентарь целевого игрока и поместить его в свой" },
            {Card.Pinyata, "инвентарь целевого игрока вылетает из него, когда он умирает" },
            {Card.Rocketman, "привяжите целевого игрока к ракете и запустите его!" },
            {Card.NoRest, "Нет покоя злым! Заставьте игрока возрождаться после смерти!" },
            {Card.ChickenChaser, "Порождает орду цыплят с супер скоростью, которые атакуют только целевого игрока! добавить «волк» «олень» «медведь» или «кабан» после команды смены животного" },
            {Card.ViewLoot, "Просмотр добычи целевого игрока" },
            {Card.Burn, "Дает игроку огнемет, который заставит его врагов кричать и гореть." },
            {Card.Hammer, "Дает администратору молот, который уничтожит все объекты, принадлежащие цели молота. Добавьте -noloot, чтобы также удалить добычу" },
            {Card.Bag, "Выведите всех игроков, которые забили целевого игрока, и выведите всех игроков, которые попали в мешки. Включите \"discord\" после команды, чтобы записать результаты в дискорд" },
            {Card.Shocker, "Поразить игрока до смерти.  Поражает игроков, находящихся поблизости, поэтому будьте осторожны.  Обязательно отключите его после использования." },
            //{Card.Cowboy, "Ковбой - ездить на целевом игроке, как на дикой свинье" },
            {Card.Masochist, "Мазохист - остановить игрока из F1 убить себя" },
            {Card.Emote, "Эмоция - заставить игрока использовать эмоцию. "},
            {Card.Shark, "акула приходит съесть мошенника"},
        };

        Dictionary<string, Card> cardAliases = new Dictionary<string, Card>() {
            { "bf", Card.Butterfingers },
            { "dud", Card.Dud },
            { "in", Card.InstantKarma},
            { "pf", Card.Pacifism},
            { "dog", Card.DogDoo},
            { "bs", Card.BSOD},
            { "nk", Card.Naked},
            { "cumnum", Card.Camomo},
            { "hg", Card.HigherGround},
            { "th", Card.Thirsty},
            { "dr", Card.DrNo},
            { "dana", Card.Dana},
            { "steal", Card.Dana},
            { "pin", Card.Pinyata},
            { "rm", Card.Rocketman},
            { "nr", Card.NoRest},
            { "res", Card.NoRest},
            { "ch", Card.ChickenChaser},
            { "loot", Card.ViewLoot},
            { "bu", Card.Burn},
            { "ham", Card.Hammer},
            { "bg", Card.Bag},
            { "sh", Card.Shocker},
            //{ "cow", Card.Cowboy},
            { "ms", Card.Masochist},
            { "em", Card.Emote},
            { "jaws", Card.Shark},
        };

        //| ==============================================================
        //| Giving
        //| ==============================================================
        public void GiveCard(ulong userID, Card card, string[] args = null, BasePlayer admin = null)
        {
            HashSet<Card> cards;
            if (!cardMap.TryGetValue(userID, out cards))
            {
                cards = new HashSet<Card>();
                cardMap[userID] = cards;
            }
            cards.Add(card);
            //Puts($"Payback card {card} given to {userID}");

            BasePlayer player = BasePlayer.FindByID(userID);
            if (player != null)
            {

                if (card == Card.BSOD)
                {
                    bool playPublic = args.Contains("public");

                    DoBSOD(player, playPublic);
                }
                else if (card == Card.Sit)
                {
                    DoSitCommand(player, admin);
                }
                else if (card == Card.Naked)
                {
                    DoNakedCommand(player);
                }
                else if (card == Card.Camomo)
                {
                    DoCamomoCommand(player);
                }
                else if (card == Card.HigherGround)
                {
                    DoHigherGround(player);
                }
                else if (card == Card.Thirsty)
                {
                    DoThirsty(player);
                }
                else if (card == Card.Dana)
                {
                    DoDana(player, admin);
                }
                else if (card == Card.Pacifism)
                {
                    silentPacifism = false;
                    if (args != null)
                    {
                        if (args.Contains("silent"))
                        {
                            silentPacifism = true;
                        }
                    }
                }
                else if (card == Card.Rocketman)
                {
                    RocketManTarget(player);
                }
                else if (card == Card.NoRest)
                {
                    if (player.IsDead())
                    {
                        player.Respawn();
                    }
                }
                else if (card == Card.ChickenChaser)
                {
                    AdminSpawnChickens(admin, player, args);
                    TakeCard(player, Card.ChickenChaser);
                }
                else if (card == Card.ViewLoot)
                {
                    ViewTargetPlayerInventory(player, admin);
                    TakeCard(player, Card.ViewLoot);
                }
                else if (card == Card.Burn)
                {
                    GivePlayerFlamethrower(player);
                }
                else if (card == Card.Hammer)
                {
                    GiveAdminHammer(player);
                    if (args.Contains("noloot"))
                    {
                        flag_kill_no_loot = true;
                        PrintToPlayer(admin, $"Молоток для удаления добычи!");
                    }
                    else
                    {
                        flag_kill_no_loot = false;
                    }
                }
                else if (card == Card.Shocker)
                {
                    DoShocker(player, args, admin);
                }
                else if (card == Card.Emote)
                {
                    DoEmote(player, args, admin);
                }
                else if (card == Card.Shark)
                {
                    DoShark(player, args, admin);
                }

                //if (card == Card.Cowboy)
                //{
                //    DoCowboy(player, args, admin);
                //}

            }


        }

        bool silentPacifism = false;


        //| ==============================================================
        //| COMMAND Implementation
        //| ==============================================================

        void DoShark(BasePlayer player, string[] args, BasePlayer admin = null)
        {
            Worker.StaticStartCoroutine(SharkCo2(player, args, admin));
        }
        IEnumerator SharkCo2(BasePlayer player, string[] args, BasePlayer admin = null)
        {

            TakeCard(player, Card.Shark);

            ////| KILL ALL EXISTING SHARKS FOR DEBUGGING
            //SimpleShark[] sharks = GameObject.FindObjectsOfType<SimpleShark>();
            //foreach (var s in sharks)
            //{
            //    s.Kill();
            //}

            //| SPAWN THE SHARK
            SimpleShark shark;
            string sharkPrefab = "assets/rust.ai/agents/fish/simpleshark.prefab";

            BaseEntity entity = GameManager.server.CreateEntity(sharkPrefab, player.transform.position + new Vector3(-100, -100, -100));

            shark = entity as SimpleShark;
            entity.Spawn();

            shark.enabled = false;

            Vector3 playerForward = player.eyes.HeadForward();
            playerForward.y = 0;
            playerForward.Normalize();

            shark.transform.LookAt(player.transform.position + Vector3.up * 100 + playerForward);

            yield return Worker.StaticStartCoroutine(MoveSharkCo(shark, player));



        }
        string sfx_bloodHit = "assets/bundled/prefabs/fx/impacts/stab/flesh/fleshbloodimpact.prefab";
        string sfx_watersplash = "assets/bundled/prefabs/fx/explosions/water_bomb.prefab";
        IEnumerator MoveSharkCo(SimpleShark shark, BasePlayer player)
        {

            float duration = 4f;
            //float duration = 20f;
            float ts = Time.realtimeSinceStartup;
            Vector3 sharkStartPos = player.transform.position + Vector3.down * 30f;
            Vector3 playerStartPosition = player.transform.position;

            Vector3 playerForward = player.eyes.HeadForward();
            playerForward.y = 0;
            playerForward.Normalize();

            bool didSit = false;
            BaseEntity chair = null;

            //bool didEmote = false;

            float p;
            float y;
            while (Time.realtimeSinceStartup - ts < duration && player != null && shark != null)
            {
                p = (Time.realtimeSinceStartup - ts) / duration;
                y = Mathf.Sin(p * Mathf.PI);

                //if (p < 0.34)
                if (p < 0.24)
                {
                    //playerStartPosition = player.transform.position + Vector3.up * 4f;//|V2
                    playerStartPosition = player.transform.position + Vector3.up * 10f;
                    shark.transform.LookAt(player.transform.position + Vector3.up * 100 + playerForward);

                }
                else
                {
                    if (!didSit)
                    {
                        //| PLAY SFX
                        //PlaySound(sfx_bloodHit, player, false, player.transform.position + Vector3.up);
                        //PlaySound(sfx_watersplash, player, false, player.transform.position);
                        global::Effect.server.Run(shark.bloodCloud.resourcePath, player.transform.position + Vector3.up, Vector3.forward, null, false);
                        global::Effect.server.Run(sfx_watersplash, player.transform.position + Vector3.up, Vector3.forward, null, false);

                        timer.Once(0.2f, () =>
                        {
                            if (player == null) return;
                            PlayGesture(player, "friendly");

                        });

                        //| Dismount the player if mounted
                        if (HasCard(player.userID, Card.Sit))
                        {
                            TakeCard(player.userID, Card.Sit);
                        }

                        Vector3 playerFacing = player.eyes.HeadForward();
                        playerFacing.y = 0;
                        playerFacing.Normalize();

                        //| Sit the player
                        chair = InvisibleSit(player);

                        chair.SetParent(shark, true, true);

                        //| V2

                        chair.transform.LookAt(chair.transform.position + playerFacing);

                        didSit = true;
                    }



                    //chair.transform.position = shark.transform.position + shark.transform.forward * 0.88f + shark.transform.up * 0.15f;
                    chair.transform.position = shark.transform.position + shark.transform.forward * 0.88f + shark.transform.up * 0.19f;

                    //chair.transform.LookAt(shark.transform.up * -1 + shark.transform.position + Vector3.up * 0.25f);
                    chair.transform.LookAt(shark.transform.position + shark.transform.up * -1 + Vector3.up * 0.15f);

                }

                shark.transform.position = Vector3.Lerp(sharkStartPos, playerStartPosition, y);
                shark.transform.LookAt(player.transform.position + Vector3.up * 100 + playerForward);

                shark.transform.Rotate(shark.transform.right, -15f);

                yield return new WaitForFixedUpdate();
            }


            shark.transform.position += Vector3.down * 100000;
            shark.SendNetworkUpdate();

            yield return null;

            player?.GetMounted()?.DismountPlayer(player, true);
            chair?.Kill();
            player?.Die();
            shark?.Kill();
        }

        void DoEmote(BasePlayer player, string[] args, BasePlayer admin = null)
        {
            if (player == null) return;

            string gesture = "wave";

            if (args.Length > 1)
            {
                gesture = args[1];

                var g = player.gestureList.StringToGesture(gesture);
                if (g == null)
                {

                    string output = "\n";
                    foreach (var gg in player.gestureList.AllGestures)
                    {
                        output += gg.convarName + "\n";
                    }

                    PrintToPlayer(admin, $"Жест не найден: {gesture}\nДоступные жесты:{output}");
                }

            }
            else
            {
                PrintToPlayer(admin, $"чтобы увидеть, как используются все эмоции: /emote <target> список");
            }

            PlayGesture(player, gesture);
            TakeCard(player, Card.Emote);
        }

        bool? CanUseGesture(BasePlayer player, GestureConfig gesture)
        {
            if (HasAnyCard(player.userID)) return true;
            return null;
        }


        void ResolveConflictingCommands(BasePlayer player, BasePlayer admin = null)
        {
            bool hasSit = false;
            if (HasCard(player.userID, Card.Sit))
            {
                hasSit = true;
                TakeCard(player, Card.Sit);
            }

            if (player.isMounted)
            {
                var car = player.GetMountedVehicle();
                if (car != null)
                {
                    car.Kill(BaseNetworkable.DestroyMode.Gib);
                }
            }
            TakeCard(player, Card.Rocketman);

        }

        //object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        //{
        //    if (cowboynetworkables.ContainsKey(target.userID) && cowboynetworkables[target.userID].Contains(entity))
        //    {
        //        PrintToChat($"CanNetworkTo: {entity.ShortPrefabName} {target.displayName}");
        //        return true;
        //    }
        //    return null;
        //}

        //Dictionary<ulong, List<BaseNetworkable>> cowboynetworkables = new Dictionary<ulong, List<BaseNetworkable>>();
        //void DoCowboy(BasePlayer player, string[] args, BasePlayer admin = null) {

        //    //disabled for testing
        //    if (player == null) return;

        //    if (HasCard(admin.userID, Card.Cowboy))
        //    {
        //        List<BaseNetworkable> existing;
        //        if (cowboynetworkables.TryGetValue(admin.userID, out existing))
        //        {
        //            if (existing != null)
        //            {
        //                existing.ForEach(x => x.Kill());
        //                existing.Clear();
        //            }
        //            cowboynetworkables.Remove(admin.userID);
        //        }
        //    }

        //    //down target player
        //    //disabled for testing
        //    player.BecomeWounded();
        //    player.ProlongWounding(100000000000);

        //    ResolveConflictingCommands(player, admin);

        //    //|====================================================
        //    //| create the chair for the person to ride
        //    //string innertube = "assets/prefabs/misc/summer_dlc/inner_tube/innertube.deployed.prefab";

        //    var chair = GameManager.server.CreateEntity(invisibleChairPrefab, player.transform.position + Vector3.up * 0.5f);
        //    //var chair = GameManager.server.CreateEntity(chairPrefab, player.transform.position + Vector3.up * 0.5f);
        //    //var chair = GameManager.server.CreateEntity(innertube, player.transform.position + Vector3.up * 0.75f);
        //    var mount = chair as BaseMountable;
        //    chair.Spawn();

        //    GameObject.DestroyImmediate(chair.GetComponentInChildren<DestroyOnGroundMissing>());
        //    GameObject.DestroyImmediate(chair.GetComponentInChildren<GroundWatch>());

        //    chair.GetComponentInChildren<Collider>().enabled = false;

        //    //|====================================================
        //    //| create something for the chair to parent to

        //    Item muzzle = ItemManager.CreateByPartialName("muzzlebrake");
        //    var dropped = muzzle.Drop(player.transform.position, Vector2.zero);
        //    DroppedItem droppedItem = dropped as DroppedItem;

        //    droppedItem.allowPickup = false;
        //    droppedItem.GetComponent<Rigidbody>().collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
        //    droppedItem.GetComponent<Rigidbody>().isKinematic = true;
        //    droppedItem.GetComponent<Rigidbody>().useGravity = false;

        //    SetDespawnDuration(droppedItem, 60 * 15);

        //    //|====================================================
        //    //| Do the parenting
        //    dropped.transform.position += Vector3.up * 0.5f;
        //    //chair.SetParent(dropped, true, true);


        //    //now we can either parent to the player, or we need to run a coroutine to bind the chair to the player

        //    //may need to replace this with something to track a downed player instead of rocket
        //    //Worker.StaticStartCoroutine(AccelerateRocketOverTime(projectile));


        //    //dropped.SetParent(player, true, true);

        //    //chair.SetParent(player, true, true);

        //    //timer.Once (3f, () => {
        //    //    //chair.limitNetworking = true;

        //    //});

        //    //timer.Once(0.25f, () => {

        //    //    if (chair != null && admin != null)
        //    //    {
        //    //        PrintToChat("on");
        //    //        chair.net.SwitchGroup(Net.sv.visibility.Get(13371));
        //    //        admin.net.SwitchGroup(Net.sv.visibility.Get(13371));
        //    //        //admin.net.AddVisibleFromNear(Net.sv.visibility.GetGroup(admin.transform.position), new List<Network.Visibility.Group>());
        //    //        admin.net.subscriber.Subscribe(Net.sv.visibility.GetGroup(player.transform.position));
        //    //    }
        //    //});


        //    //timer.Once(15f, () => {
        //    //    if (chair != null && admin != null)
        //    //    {
        //    //        //chair.limitNetworking = true;
        //    //        PrintToChat("off");
        //    //        chair.net.SwitchGroup(Net.sv.visibility.GetGroup(admin.transform.position));
        //    //        admin.net.SwitchGroup(Net.sv.visibility.GetGroup(admin.transform.position));
        //    //    }

        //    //});
        //    //chair._limitedNetworking = true;
        //    Worker.StaticStartCoroutine(MoveCowboyOverTime(player, chair));

        //    //mount.MountPlayer(admin);

        //    cowboynetworkables[admin.userID] = new List<BaseNetworkable>() { chair };

        //}

        //IEnumerator MoveCowboyOverTime(BasePlayer player, BaseEntity entity)
        //{
        //    Vector3 offset = entity.transform.position - player.transform.position;
        //    ulong userid = player.userID;
        //    while (HasCard(player.userID, Card.Cowboy))
        //    {
        //        if (player != null && player.net.connection != null)
        //        {
        //            //entity.transform.position += Vector3.forward * 0.01f;
        //            entity.transform.position = player.transform.position + offset;
        //            var forward = player.eyes.HeadForward();
        //            forward.y = 0;
        //            entity.transform.LookAt(entity.transform.position + forward);
        //            entity.SendNetworkUpdateImmediate();
        //            yield return new WaitForFixedUpdate();
        //        } else
        //        {
        //            break;
        //        }
        //    }
        //    if (entity != null)
        //    {
        //        entity?.Kill();
        //    }
        //    TakeCard(userid, Card.Cowboy);
        //}


        Dictionary<ulong, BaseEntity> coilMap = new Dictionary<ulong, BaseEntity>();
        void DoShocker(BasePlayer player, string[] args, BasePlayer admin = null)
        {
            if (player == null) return;

            BaseEntity coilEnt;
            if (coilMap.TryGetValue(player.userID, out coilEnt))
            {
                if (coilEnt != null)
                {
                    coilEnt.Kill();
                }
                coilMap.Remove(player.userID);
                return;
            }

            TeslaCoil coil = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/teslacoil/teslacoil.deployed.prefab", player.transform.position) as TeslaCoil;

            coil.transform.position += Vector3.down * 1;

            coil.Spawn();


            coil.SetFlag(BaseEntity.Flags.Reserved8, true);
            coil.UpdateFromInput(7, 0);
            coilMap.Add(player.userID, coil);

            coil.SetParent(player, true, true);
            coil.SendNetworkUpdateImmediate();

            var los = coil.GetComponentInChildren<TargetTrigger>();
            los.losEyes = null;

            los.OnEntityEnter(player);

            DestroyGroundCheck(coil);

            Timer t = null;
            t = timer.Every(0.2f, () => {
                if (coil == null || player == null)
                {
                    t.Destroy();
                    return;
                }
                else
                {
                    if (Vector3.Distance(player.transform.position, coil.transform.position) < 5)
                    {
                        los.OnEntityEnter(player);
                    }
                    else
                    {
                        los.OnEntityLeave(player);
                    }
                }
            });

        }


        void DoBagSearch(ulong userID, string[] args, BasePlayer admin = null)
        {
            if (userID == 0) return;
            TakeCard(userID, Card.Bag);

            if (args.Contains("discord"))
            {
                Worker.StaticStartCoroutine(BagSearchCo(userID, true, admin));
            }
            else
            {
                Worker.StaticStartCoroutine(BagSearchCo(userID, false, admin));
            }
        }
        IEnumerator BagSearchCo(ulong userID, bool logToDiscord = false, BasePlayer admin = null)
        {
            yield return null;


            float timestamp = Time.realtimeSinceStartup;
            float maxTimeBetweenFrames = 1 / 20f;

            //| Get bags owned by player

            var allBags = BaseNetworkable.serverEntities.OfType<SleepingBag>();
            //var deployedByTargetBags = new List<SleepingBag>();

            var useridsBaggedByTarget = new HashSet<ulong>();
            var useridsWhoBaggedTarget = new HashSet<ulong>();

            //find the bags that target placed
            foreach (var bag in allBags)
            {
                //| ==============================================================
                if (Time.realtimeSinceStartup - timestamp > maxTimeBetweenFrames)
                {
                    yield return null;
                    timestamp = Time.realtimeSinceStartup;
                }
                //| ==============================================================

                ulong ownerid = 0;
                var creator = bag.creatorEntity;
                if (creator != null)
                {
                    var player = creator as BasePlayer;
                    if (player != null)
                    {
                        ownerid = player.userID;
                    }
                }
                else
                {
                    ownerid = bag.OwnerID;
                }

                //target bagged someone else
                if (ownerid == userID && bag.deployerUserID != userID)
                {
                    //deployedByTargetBags.Add(bag);
                    useridsBaggedByTarget.Add(bag.deployerUserID);
                }

                //someone bagged in target
                if (userID == bag.deployerUserID && ownerid != userID)
                {
                    useridsWhoBaggedTarget.Add(ownerid);
                }
            }

            var messageData = new Dictionary<string, string>();
            string targetInfo = $"{TryGetDisplayName(userID)}";
            string baggedByString = "";
            string output = $"Players bagged by {targetInfo}:";
            foreach (var userid in useridsBaggedByTarget)
            {
                var displayname = TryGetDisplayName(userid);
                output += $"\n{userid} : {displayname}";

                baggedByString += $"{userid} : {displayname}\n";
            }
            if (baggedByString.Length > 0)
            {
                messageData.Add($"Players bagged by {targetInfo}", baggedByString);
            }
            else
            {
                messageData.Add($"Players bagged by {targetInfo}", "none");
            }

            output += $"\nSteamids who bagged in {targetInfo}:";
            string baggedInString = "";
            foreach (var userid in useridsWhoBaggedTarget)
            {
                var displayname = TryGetDisplayName(userid);
                output += $"\n{userid} : {displayname}";
                baggedInString += $"\n{userid} : {displayname}";
            }
            if (baggedInString.Length > 0)
            {
                messageData.Add($"Players who bagged in {targetInfo}", baggedInString);
            }
            else
            {
                messageData.Add($"Players who bagged in {targetInfo}", "none");
            }

            PrintToPlayer(admin, $"{output}");

            if (logToDiscord)
            {
                SendToDiscordWebhook(messageData, $"Bag Search [{userID}]");
            }

        }

        bool flag_kill_no_loot = false;

        void GiveAdminHammer(BasePlayer admin)
        {
            if (admin == null) return;
            var item = ItemManager.CreateByName("hammer", 1, 2375073548);
            if (item != null)
            {
                GiveItemOrDrop(admin, item, false);
            }
        }
        object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {

            if (HasCard(player.userID, Card.Hammer))
            {
                Worker.StaticStartCoroutine(DeleteByCo(entity.OwnerID, player.transform.position, player));
            }
            return null;
        }

        IEnumerator DeleteByCo(ulong steamid, Vector3 position, BasePlayer admin = null)
        {
            yield return null;
            if (steamid == 0UL)
            {
                yield break;
            }


            float maxTimeBetweenFrames = 1 / 60f;
            int maxEntitiesPerFrame = 1;
            float delayBetweenFrames = 1 / 20f;
            float timestamp = Time.realtimeSinceStartup;

            var entities = new List<BaseNetworkable>(BaseNetworkable.serverEntities);

            float fxTimestamp = Time.realtimeSinceStartup;
            float fxCooldown = 0.75f;
            //float fxCooldown = 0.2f;

            var ownedEntities = new List<BaseEntity>();
            foreach (var x in entities)
            {
                var entity = x as BaseEntity;
                if (!(entity == null) && entity.OwnerID == steamid)
                {
                    ownedEntities.Add(entity);
                }
                if (Time.realtimeSinceStartup - timestamp > maxTimeBetweenFrames)
                {
                    yield return null;
                    timestamp = Time.realtimeSinceStartup;
                }
            }

            ownedEntities.Sort((x, y) => Vector3.Distance(x.transform.position, position).CompareTo(Vector3.Distance(y.transform.position, position)));

            timestamp = Time.realtimeSinceStartup;

            int i = 0;

            int count = 0;

            bool playSound = true;

            if (admin != null)
                PlaySound("assets/bundled/prefabs/fx/headshot.prefab", admin, false);

            Vector3 lastPosition = Vector3.zero;


            //| LOOT REMOVAL PASS
            if (flag_kill_no_loot)
            {
                foreach (var baseEntity in ownedEntities)
                {
                    var storage = baseEntity as StorageContainer;
                    if (storage != null)
                    {
                        foreach (var item in new List<Item>(storage.inventory.itemList))
                        {
                            //PrintToPlayer(admin, $"Removing: {item.info.displayName.english}");
                            item.GetHeldEntity()?.KillMessage();
                            //item.DoRemove();
                            //item.Remove();
                            ItemManager.RemoveItem(item);
                        }
                        ItemManager.DoRemoves();
                        //storage.inventory.Clear();
                    }
                }
            }


            while (i < ownedEntities.Count)
            {
                if (Time.realtimeSinceStartup - timestamp > maxTimeBetweenFrames || count >= maxEntitiesPerFrame)
                {
                    yield return new WaitForSeconds(delayBetweenFrames);
                    timestamp = Time.realtimeSinceStartup;
                    count = 0;
                }

                var baseEntity = ownedEntities[i];
                if (!(baseEntity == null) && baseEntity.OwnerID == steamid)
                {

                    if (admin != null && playSound)
                    {
                        if (Time.realtimeSinceStartup - fxTimestamp > fxCooldown)
                        {

                            //var effect = GameManager.server.CreateEntity("assets/prefabs/deployable/fireworks/mortarred.prefab", baseEntity.transform.position);
                            //effect.Spawn();
                            //var firework = effect as BaseFirework;
                            //firework.fuseLength = 0;
                            //firework.Ignite();


                            //var effect = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_basic.prefab", baseEntity.transform.position);
                            //effect.Spawn();
                            //var explosive = effect as TimedExplosive;
                            //explosive.Explode();

                            PlaySound("assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab", admin, true);

                            fxTimestamp = Time.realtimeSinceStartup;

                            //"assets/bundled/prefabs/fx/impacts/blunt/glass/glass1.prefab"
                            ////PlaySound(new List<string>() { "assets/bundled/prefabs/fx/survey_explosion.prefab" }, admin,  admin.transform.position - baseEntity.transform.position, false);
                            //PlaySound(new List<string>() { "assets/bundled/prefabs/fx/survey_explosion.prefab" }, admin, baseEntity.transform.position, false);

                            //PlaySound(new List<string>() { "assets/bundled/prefabs/fx/impacts/bullet/glass/glass1.prefab" }, admin, baseEntity.transform.position, false);
                            //PlaySound(new List<string>() { "assets/content/effects/weather/pfx_lightning_strong.prefab" }, admin, baseEntity.transform.position + Vector3.back * 300, false);
                            //PlaySound(new List<string>() { "assets/content/effects/weather/pfx_lightningstorm_looptest.prefab" }, admin, baseEntity.transform.position + Vector3.back * 300, false);
                            //PlaySound(new List<string>() { "assets/bundled/prefabs/fx/impacts/blunt/glass/glass1.prefab" }, admin, baseEntity.transform.position, false);
                            ///sound assets/content/effects/weather/pfx_lightning_strong.prefab
                        }
                    }

                    //baseEntity.Invoke(new Action(baseEntity.KillMessage), 0);
                    lastPosition = baseEntity.transform.position;

                    baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);

                    count++;

                    //assets/bundled/prefabs/fx/building/stone_gib.prefab

                }
                i++;

            }
            if (admin != null)
            {
                PlaySound("assets/prefabs/locks/keypad/effects/lock.code.lock.prefab", admin, true);

                timer.Once(0.75f, () => {
                    PlaySound("assets/prefabs/npc/autoturret/effects/targetacquired.prefab", admin, true);

                    if (!flag_kill_no_loot)
                    {
                        var effect = GameManager.server.CreateEntity("assets/prefabs/deployable/fireworks/mortarred.prefab", lastPosition);
                        effect.Spawn();
                        var firework = effect as BaseFirework;
                        firework.fuseLength = 0;
                        firework.Ignite(new Vector3());
                    }

                });
            }
            yield return null;
        }



        HashSet<ulong> currentlyScreamingPlayers = new HashSet<ulong>();
        public const string sound_scream = "assets/bundled/prefabs/fx/player/beartrap_scream.prefab";
        public const string effect_onfire = "assets/bundled/prefabs/fx/player/onfire.prefab";

        void GivePlayerFlamethrower(BasePlayer player)
        {
            if (player == null) return;
            GiveItemOrDrop(player, ItemManager.CreateByName("flamethrower", 1, 0), false);
        }

        public void Line(BasePlayer player, Vector3 from, Vector3 to, Color color, float duration)
        {
            player.SendConsoleCommand("ddraw.line", duration, color, from, to);
        }
        void AdminSpawnChickens(BasePlayer player, BasePlayer target, string[] args)
        {
            if (player == null) return;
            RaycastHit hit;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit))
            {
                //Line(player, hit.point, hit.point + Vector3.up * 10, Color.white, 5);
                SpawnChickens(target, hit.point, args);
            }
        }
        HashSet<BaseCombatEntity> chickens = new HashSet<BaseCombatEntity>();
        void SpawnChickens(BasePlayer player, Vector3 spawnposition, string[] args)
        {
            //if (!IsAdmin(player)) return;


            for (int i = 0; i < 10; i++)
            {
                Worker.StaticStartCoroutine(AnimalAttackCo(player, spawnposition, args));
            }

        }
        IEnumerator AnimalAttackCo(BasePlayer player, Vector3 spawnposition, string[] args)
        {
            RaycastHit hit;
            Ray ray = new Ray(UnityEngine.Random.Range(-5f, 5f) * Vector3.forward + UnityEngine.Random.Range(-5f, 5f) * Vector3.left + spawnposition + Vector3.up * 20, Vector3.down);
            if (Physics.Raycast(ray, out hit))
            {
                string aiPrefab = "assets/rust.ai/agents/chicken/chicken.prefab";
                if (args.Contains("bear"))
                {
                    aiPrefab = "assets/rust.ai/agents/bear/bear.prefab";
                }
                else if (args.Contains("boar"))
                {
                    aiPrefab = "assets/rust.ai/agents/boar/boar.prefab";

                }
                else if (args.Contains("wolf"))
                {
                    aiPrefab = "assets/rust.ai/agents/wolf/wolf.prefab";

                }
                else if (args.Contains("stag"))
                {
                    aiPrefab = "assets/rust.ai/agents/stag/stag.prefab";
                }
                //assets/rust.ai/agents/wolf/wolf.prefab
                var entity = GameManager.server.CreateEntity(aiPrefab, hit.point + Vector3.up * 0.2f);
                //var entity = GameManager.server.CreateEntity("assets/rust.ai/agents/wolf/wolf.prefab", hit.point + Vector3.up * 0.2f);
                //var entity = GameManager.server.CreateEntity("assets/rust.ai/agents/bear/bear.prefab", hit.point + Vector3.up * 0.2f);

                BaseAnimalNPC chicken = entity as BaseAnimalNPC;
                entity.Spawn();

                //chicken.Stats.Speed = 20;
                chicken.Stats.Speed = 200;
                chicken.Stats.TurnSpeed = 100;
                chicken.Stats.Acceleration = 50;
                chicken.AttackRange = 3;
                chicken.AttackDamage *= 2;
                chicken.Stats.VisionRange = 300;

                chickens.Add(chicken);

                chicken.AttackTarget = player;
                chicken.ChaseTransform = player.transform;


                chicken.Stats.AggressionRange = 100000;
                chicken.Stats.DeaggroRange = 100000;
                chicken.Stats.IsAfraidOf = new BaseNpc.AiStatistics.FamilyEnum[0];
                chicken.Destination = player.transform.position;

                chicken.Stats.VisionCone = -1;

                yield return new WaitForSeconds(0.25f);
                //chicken.LegacyNavigation = true;
                //chicken.Stats.DistanceVisibility = AnimationCurve.Linear(0, 0, 1, 1);
                chicken.LegacyNavigation = true;

                bool doLoop = true;
                while (doLoop)
                {
                    if (chicken != null && player != null)
                    {
                        if (player.IsDead())
                        {
                            if (chicken != null)
                            {
                                chicken.Kill();
                            }
                            doLoop = false;
                        }
                        else
                        {
                            if (chicken.NavAgent != null && chicken.NavAgent.isOnNavMesh)
                            {
                                chicken.ChaseTransform = player.transform;
                                chicken.AttackTarget = player;
                                chicken.Destination = player.transform.position;
                                chicken.TargetSpeed = chicken.Stats.Speed * 100;
                                //if (chicken.AiContext == null)
                                //{
                                //    chicken.AiContext = new BaseContext(chicken);
                                //}
                                //if (chicken.AiContext != null)
                                //{
                                //    chicken.AiContext.EnemyPlayer = player;
                                //    chicken.AiContext.LastEnemyPlayerScore = float.MaxValue;
                                //    chicken.AiContext.AIAgent.AttackTarget = player;

                                //    chicken.SetFact(BaseNpc.Facts.HasEnemy, 1, true, true);
                                //}

                                //chicken.SetFact(BaseNpc.Facts.EnemyRange, (byte)enemyRangeEnum, true, true);
                                //chicken.SetFact(BaseNpc.Facts.AfraidRange, (byte)value, true, true);

                                //chicken.SetFact(BaseNpc.Facts.IsAggro, 0, true, false);
                                //chicken.SetFact(BaseNpc.Facts.HasEnemy, 0, true, false);
                                //chicken.SetFact(BaseNpc.Facts.IsAfraid, 0, true, false);


                                //chicken.Attack(player);

                                //chicken.CurrentBehaviour = BaseNpc.Behaviour.Attack;
                                //chicken.TargetSpeed = chicken.Stats.Speed;

                                //Puts($"TSpeed: {chicken.TargetSpeed} s: {chicken.NavAgent.speed}  statspeed: {chicken.Stats.Speed}");
                            }
                        }
                        //Puts($"Attack target: {chicken.AttackTarget} Chase: {chicken.ChaseTransform} ARate: {chicken.AttackRate} CombatTarget: {chicken.CombatTarget}");
                        //chicken.TickNavigation();

                    }
                    else
                    {
                        if (chicken != null)
                        {
                            chicken.Kill();
                        }
                        doLoop = false;
                    }
                    yield return null;
                    //yield return new WaitForSeconds(0.25f);
                }


                timer.Once(120, () => {
                    if (chicken != null)
                    {
                        chicken.Kill();
                    }
                });

                timer.Once(130f, () => {
                    chickens.RemoveWhere(x => x == null);
                });
            }
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (HasCard(player.userID, Card.NoRest))
            {
                player.EndSleeping();
                player.SendNetworkUpdate();
            }
        }

        void OnEntityKill(BaseNetworkable entity, HitInfo info)
        {

            if (entity == null) return;
            if (entitiesWatchingForKilledMounts.Contains(entity))
            {
                var chair = entity.GetComponentInChildren<BaseMountable>();
                if (chair.IsMounted())
                {
                    var player = chair.GetMounted();
                    player.GetMounted().DismountPlayer(player, true);
                    player.Teleport(chair.transform.position);
                    player.Die();
                }
                entitiesWatchingForKilledMounts.Remove(entity);

                timer.Once(0.5f, () => {
                    if (entitiesWatchingForKilledMounts.Count == 0)
                        Unsubscribe($"OnEntityKill");
                });
            }
        }

        HashSet<BaseNetworkable> entitiesWatchingForKilledMounts = new HashSet<BaseNetworkable>();
        void RocketManTarget(BasePlayer player)
        {
            bool hasSit = false;
            if (HasCard(player.userID, Card.Sit))
            {
                hasSit = true;
                TakeCard(player, Card.Sit);
            }

            if (player.isMounted)
            {
                var mount = player.GetMounted();
                mount.DismountPlayer(player, true);
                //var car = player.GetMountedVehicle();
                //if (car != null)
                //{
                //    car.Kill(BaseNetworkable.DestroyMode.Gib);
                //}
            }

            TakeCard(player, Card.Rocketman);

            Subscribe("OnEntityKill");

            player.Teleport(player.transform.position + Vector3.up * 0.25f);

            var rocket = GameManager.server.CreateEntity("assets/prefabs/ammo/rocket/rocket_hv.prefab", player.transform.position + Vector3.up * 1f);

            rocket.creatorEntity = player;
            //rocket.GetComponent<ServerProjectile>().initialVelocity = Vector3.up * 100f;
            ServerProjectile projectile = rocket.GetComponent<ServerProjectile>();
            projectile.InitializeVelocity(Vector3.up * 1f);

            rocket.Spawn();
            rocket.transform.LookAt(Vector3.up + rocket.transform.position);

            entitiesWatchingForKilledMounts.Add(rocket as BaseNetworkable);

            //| Attempt to solve instant kill sometimes
            var collider = rocket.GetComponent<Collider>();
            if (collider != null)
            {
                collider.enabled = false;
            }

            TimedExplosive explosive = rocket as TimedExplosive;
            explosive.SetCollisionEnabled(false);

            timer.Once(1f, () => {
                explosive?.SetCollisionEnabled(false);
            });
            //|============================================


            var chair = InvisibleSit(player);
            chair.SetParent(rocket, true);
            chair.transform.LookAt(chair.transform.position + Vector3.up);
            chair.transform.position += chair.transform.up * -0.35f;
            chair.transform.position += chair.transform.forward * 0.7f;
            chair.transform.LookAt(chair.transform.position + Vector3.up + chair.transform.up * -1f);

            rocket.transform.position = player.transform.position;
            if (hasSit)
            {
                rocket.transform.position += Vector3.up * 1;
            }

            Worker.StaticStartCoroutine(AccelerateRocketOverTime(projectile));
        }

        IEnumerator AccelerateRocketOverTime(ServerProjectile projectile)
        {
            float duration = 5f;
            float startTime = Time.realtimeSinceStartup;
            while (Time.realtimeSinceStartup - startTime < duration)
            {
                float p = (Time.realtimeSinceStartup - startTime) / duration;
                if (projectile != null)
                {
                    projectile.InitializeVelocity(Vector3.up * 20f * p);
                }
                yield return new WaitForFixedUpdate();
            }
        }

        public const string invisibleChairPrefab = "assets/bundled/prefabs/static/chair.invisible.static.prefab";

        HashSet<BaseMountable> chairsPreventingDismount = new HashSet<BaseMountable>();
        BaseEntity InvisibleSit(BasePlayer targetPlayer)
        {
            var chair = GameManager.server.CreateEntity(invisibleChairPrefab, targetPlayer.transform.position);
            var mount = chair as BaseMountable;
            chair.Spawn();

            chairsPreventingDismount.Add(mount);

            GameObject.DestroyImmediate(chair.GetComponentInChildren<DestroyOnGroundMissing>());
            GameObject.DestroyImmediate(chair.GetComponentInChildren<GroundWatch>());

            if (targetPlayer.isMounted)
            {
                targetPlayer.GetMounted().DismountPlayer(targetPlayer, true);
            }

            Timer t = null;
            t = timer.Every(0.25f, () => {
                if (chair == null || chair.IsDestroyed)
                {
                    t.Destroy();
                    return;
                }
                if (targetPlayer != null)
                {
                    if (!targetPlayer.isMounted)
                    {
                        targetPlayer.Teleport(chair.transform.position);
                        mount.MountPlayer(targetPlayer);
                        chair.SendNetworkUpdateImmediate();
                    }
                }
                else
                {
                    //Puts("Attempted to mount player to chair, but they were null!");
                    chair.Kill();
                    t.Destroy();
                }

            });
            return chair;
        }

        //[ChatCommand("p")]
        //void CommandTestPinyata(BasePlayer player)
        //{
        //    if (!IsAdmin(player)) return;

        //    timer.Once(2f, () =>
        //    {
        //        DoPinyataEffect(player);
        //    });
        //}

        public List<string> sounds_kill_quad = new List<string>() {
            "assets/prefabs/weapons/python/effects/close_cylinder.prefab",
            "assets/prefabs/weapons/mace/effects/hit.prefab",
            "assets/prefabs/misc/halloween/lootbag/effects/gold_open.prefab",
        };
        void DoPinyataEffect(BasePlayer player)
        {
            float baseMagnitude = 1.35f;
            float baseForceUp = 0.1f;
            float randomForceUp = 8f * baseMagnitude;
            float forceHorz = 10f * baseMagnitude;
            var q = Quaternion.Euler(new Vector3(360 * Random(), 360 * Random(), 360 * Random()));
            Vector3 seedVelocity = Vector3.up * baseForceUp + q * Vector3.forward;

            //fill up items with shit
            int itemCount = player.inventory.AllItems().Length;
            List<Item> items = new List<Item>(player.inventory.AllItems());
            List<Item> literalShit = new List<Item>();
            int targetItems = 20;
            if (itemCount < targetItems)
            {
                for (int count = 0; count < (targetItems - itemCount); count++)
                {
                    var item = ItemManager.CreateByName("horsedung", 1, 0);
                    //var item = ItemManager.CreateByName("coal", 1, 0);
                    //var item = ItemManager.CreateByName("hoodie", 1, 0);
                    GiveItemOrDrop(player, item);
                    literalShit.Add(item);
                    items.Add(item);
                }
            }

            float angleIncrement = 360f / Mathf.Max(itemCount, targetItems);

            //List<BaseEntity> stuff = new List<BaseEntity>();
            PlaySound(sounds_kill_quad, player, false);

            float mag = 0;


            int i = 0;
            foreach (var item in player.inventory.AllItems())
            {
                Vector3 velocity = Quaternion.Euler(0, angleIncrement * i, 0) * seedVelocity;
                Vector3 randomUp = Vector3.up * Mathf.Max(0.5f, Random()) * randomForceUp;

                mag += velocity.magnitude;


                velocity.y = 0;
                velocity *= Mathf.Max(0.55f, Random()) * forceHorz;
                velocity += randomUp;

                Vector3 horz = velocity;
                horz.y = 0;

                var entity = item.Drop(player.transform.position + Vector3.up * 1f + horz.normalized * 0.55f, velocity, Quaternion.Euler(new Vector3(360 * Random(), 360 * Random(), 360 * Random())));
                //entity.SendNetworkUpdate();
                ////timer.Once(0.5f, () =>
                //{

                //});

                i++;

                //var body = entity.GetComponentInChildren<Rigidbody>();
                //if (body != null)
                //{
                //    //body.useGravity = false;
                //}
                //stuff.Add(entity);
            }

            timer.Once(10f, () => {
                literalShit.ForEach(x => {
                    x?.RemoveFromContainer();
                    x?.Remove();
                });
            });

            //PrintToChat($"Mag: {mag}");

            //timer.Once(3f, () =>
            //{
            //    foreach (var entity in stuff)
            //    {
            //        if (entity != null)
            //        {
            //            DroppedItem d = entity as DroppedItem;
            //            d.item.MoveToContainer(player.inventory.containerMain);

            //            //var body = entity.GetComponentInChildren<Rigidbody>();
            //            //body.useGravity = true;
            //        }
            //    }
            //});
        }
        void DoDana(BasePlayer player, BasePlayer admin)
        {
            if (player != null && admin != null)
            {
                foreach (var item in new List<Item>(player.inventory.containerBelt.itemList))
                {
                    GiveItemOrDrop(admin, item);
                }
                foreach (var item in new List<Item>(player.inventory.AllItems()))
                {
                    GiveItemOrDrop(admin, item);
                }
            }
            TakeCard(player, Card.Dana);
        }

        void GiveItemOrDrop(BasePlayer player, Item item, bool stack = false)
        {
            bool success = item.MoveToContainer(player.inventory.containerBelt, -1, stack);
            if (!success)
            {
                success = item.MoveToContainer(player.inventory.containerMain, -1, stack);
            }
            if (!success)
            {
                success = item.MoveToContainer(player.inventory.containerWear, -1, stack);
            }
            if (!success)
            {
                item.Drop(player.transform.position + Vector3.up, Vector3.zero);
            }
        }


        HashSet<ulong> thirstyPlayers = new HashSet<ulong>();
        Dictionary<ulong, BasePlayer> basePlayerMap = new Dictionary<ulong, BasePlayer>();
        Coroutine thirstyCoroutine = null;
        void DoThirsty(BasePlayer player)
        {
            thirstyPlayers.Add(player.userID);

            if (thirstyCoroutine == null)
            {
                thirstyCoroutine = Worker.StaticStartCoroutine(DoThirstyCo());
            }
        }
        IEnumerator DoThirstyCo()
        {

            while (thirstyPlayers.Count > 0)
            {
                foreach (var userID in new HashSet<ulong>(thirstyPlayers))
                {
                    if (HasCard(userID, Card.Thirsty))
                    {
                        BasePlayer player;
                        if (!basePlayerMap.TryGetValue(userID, out player))
                        {
                            player = BasePlayer.FindByID(userID);
                        }

                        if (player != null)
                        {
                            player.metabolism.hydration.MoveTowards(0, 10f);
                            player.SendNetworkUpdateImmediate();
                        }
                        else
                        {
                            thirstyPlayers.Remove(userID);
                        }

                    }
                    else
                    {
                        thirstyPlayers.Remove(userID);
                    }
                }

                yield return new WaitForSeconds(0.25f);
            }
            thirstyCoroutine = null;
        }

        void DoHigherGround(BasePlayer player)
        {
            player.Teleport(player.transform.position + Vector3.up * 100);
            TakeCard(player, Card.HigherGround);
        }

        void DoCamomoCommand(BasePlayer player)
        {
            List<Card> camomoCards = new List<Card>() {
                Card.Pacifism,
                Card.Butterfingers,
                Card.InstantKarma,
                Card.DogDoo,
                Card.Dud,
                Card.DrNo,
            };
            foreach (var card in camomoCards)
            {
                GiveCard(player.userID, card, new string[0], null);
            }
            TakeCard(player.userID, Card.Camomo, null, null);

        }

        void DoNakedCommand(BasePlayer targetPlayer)
        {
            Worker.StaticStartCoroutine(NakedOverTime(targetPlayer));
            TakeCard(targetPlayer.userID, Card.Naked, null, null);
        }
        IEnumerator NakedOverTime(BasePlayer targetPlayer)
        {

            yield return new WaitForSeconds(2);


            ////print all gestures
            //foreach (var g in targetPlayer.gestureList.AllGestures)
            //{
            //    Puts($"{g.convarName} - {g.gestureCommand} - {g.gestureName}");
            //}



            //            (10:49:59) | [Payback] clap - clap - Translate + Phrase
            //(10:50:00) | [Payback] friendly - friendly - Translate + Phrase
            //(10:50:00) | [Payback] hurry - hurry - Translate + Phrase
            //(10:50:00) | [Payback] ok - ok - Translate + Phrase
            //(10:50:00) | [Payback] point - point - Translate + Phrase
            //(10:50:00) | [Payback] shrug - shrug - Translate + Phrase
            //(10:50:00) | [Payback] thumbsdown - thumbsdown - Translate + Phrase
            //(10:50:00) | [Payback] thumbsup - thumbsup - Translate + Phrase
            //(10:50:00) | [Payback] victory - victory - Translate + Phrase
            //(10:50:00) | [Payback] wave - wave - Translate + Phrase
            //(10:50:00) | [Payback] - dance_01 - Translate + Phrase
            //(10:50:00) | [Payback] raiseroof - hiphopdance - Translate + Phrase
            //(10:50:00) | [Payback] cabbagepatch - sillydance - Translate + Phrase
            //(10:50:00) | [Payback] twist - sillydance2 - Translate + Phrase

            //Clients now block this :'(
            //targetPlayer.SendConsoleCommand("gesture wave");


            foreach (var item in targetPlayer.inventory.AllItems())
            {
                if (item != null)
                {
                    var droppedEntity = item.Drop(targetPlayer.eyes.HeadRay().origin, targetPlayer.eyes.HeadRay().direction * 5 + Vector3.up * 5 + new Vector3(UnityEngine.Random.Range(-1f, 1f), 0, UnityEngine.Random.Range(-1f, 1f)));
                    droppedEntity.transform.LookAt(targetPlayer.eyes.HeadRay().origin + Quaternion.Euler(0, UnityEngine.Random.Range(-90, 90), UnityEngine.Random.Range(-90, 90)) * targetPlayer.eyes.HeadRay().direction * 2);
                    var body = droppedEntity.GetComponentInChildren<Rigidbody>();
                    if (body != null)
                    {
                        float power = 1;
                        body.AddForceAtPosition(targetPlayer.eyes.HeadRay().direction * power, droppedEntity.transform.position + Vector3.up * 10f);
                    }
                    droppedEntity.SendNetworkUpdate();
                    yield return null;
                }
            }


            float startTime = Time.realtimeSinceStartup;
            while (Time.realtimeSinceStartup - startTime < 15)
            {
                //targetPlayer.SendConsoleCommand("gesture wave");
                yield return new WaitForSeconds(0.5f);
            }


        }


        //string chairPrefab = "assets/prefabs/deployable/chair/chair.deployed.prefab";
        string chairPrefab = "assets/prefabs/deployable/secretlab chair/secretlabchair.deployed.prefab";

        Dictionary<ulong, BaseEntity> sitChairMap = new Dictionary<ulong, BaseEntity>();

        void DoSitCommand(BasePlayer targetPlayer, BasePlayer adminPlayer)
        {
            if (targetPlayer == null) return;

            if (HasCard(targetPlayer.userID, Card.Sit))
            {
                if (adminPlayer == null) return;

                if (targetPlayer.isMounted)
                {
                    targetPlayer.GetMounted().DismountPlayer(targetPlayer, true);

                    var car = targetPlayer.GetMountedVehicle();
                    if (car != null)
                    {
                        car.Kill(BaseNetworkable.DestroyMode.Gib);
                    }

                    BaseEntity chair = null;
                    if (sitChairMap.TryGetValue(targetPlayer.userID, out chair))
                    {
                        chair?.Kill();
                    }
                }

                RaycastHit hitinfo;
                if (Physics.Raycast(adminPlayer.eyes.HeadRay(), out hitinfo, 50))
                {


                    var chair = GameManager.server.CreateEntity(chairPrefab, hitinfo.point);
                    var mount = chair as BaseMountable;
                    chair.Spawn();
                    sitChairMap[targetPlayer.userID] = chair;
                    //targetPlayer.Teleport(chair.transform.position + chair.transform.forward * 0.5f);
                    targetPlayer.EndSleeping();

                    GameObject.DestroyImmediate(chair.GetComponentInChildren<DestroyOnGroundMissing>());
                    GameObject.DestroyImmediate(chair.GetComponentInChildren<GroundWatch>());

                    Vector3 lookAtPosition = adminPlayer.transform.position;
                    lookAtPosition.y = mount.transform.position.y;

                    timer.Once(0.25f, () => {

                        if (targetPlayer != null)
                        {
                            mount.MountPlayer(targetPlayer);


                            chair.transform.LookAt(lookAtPosition);
                            chair.SendNetworkUpdateImmediate();

                            Worker.StaticStartCoroutine(SitCo(targetPlayer));
                        }
                        else
                        {
                            //Puts("Attempted to mount player to chair, but they were null!");
                            chair.Kill();
                        }

                    });

                }

            }
            else
            {
                BaseEntity chair = null;
                if (sitChairMap.TryGetValue(targetPlayer.userID, out chair))
                {
                    if (chair != null)
                    {
                        chair.Kill();
                    }
                }

            }
        }

        IEnumerator SitCo(BasePlayer player)
        {
            yield return new WaitForSeconds(0.25f);
            BaseEntity chair;
            sitChairMap.TryGetValue(player.userID, out chair);
            BaseMountable mount = chair as BaseMountable;

            while (player != null && chair != null && HasCard(player.userID, Card.Sit))
            {
                if (player != null)
                {
                    if (player.IsSleeping())
                    {
                        player.EndSleeping();
                    }
                    if (player.isMounted)
                    {
                        var playerMount = player.GetMounted();
                        if (playerMount != mount)
                        {
                            player.GetMounted().DismountPlayer(player, true);
                            //PrintToChat($"Dismount player for sit: {playerMount}");

                        }
                    }

                    var dist = Vector3.Distance(chair.transform.position, player.transform.position);
                    if (dist > 2)
                    {
                        player.Teleport(chair.transform.position + chair.transform.forward * 0.5f);
                        //yield return new WaitForSeconds(1);
                    }
                    if (!player.isMounted && dist < 2)
                    {

                        //mount.AttemptMount(player, false);
                        player.MountObject(mount);

                        //PrintToChat($"Attempt mount: {mount} pmount:  {player.GetMounted()}");
                        //yield return new WaitForSeconds(0.25f);
                    }

                }
                else
                {
                    chair.Kill();
                }
                yield return new WaitForSeconds(0.25f);
            }
            if (chair != null)
            {
                chair.Kill();
            }

        }

        object CanDismountEntity(BasePlayer player, BaseMountable entity)
        {
            if (cardMap.Count == 0 && chairsPreventingDismount.Count == 0) return null;//early out for maximum perf

            if (HasCard(player.userID, Card.Sit))
            {
                return false;
            }

            //cleanup dead chairs
            foreach (var chair in new HashSet<BaseMountable>(chairsPreventingDismount))
            {
                if (chair == null || chair.IsDestroyed)
                {
                    chairsPreventingDismount.Remove(chair);
                }
            }

            if (chairsPreventingDismount.Contains(entity))
            {
                return false;
            }

            return null;
        }


        string guid_BSOD = "guid_BSOD";
        string url_bsod = "https://i.imgur.com/36oaKDW.png";
        void DoBSOD(BasePlayer player, bool playPublic)
        {
            if (player.net.connection == null) return;

            UI2.guids.Add(guid_BSOD);

            var elements = new CuiElementContainer();

            UI2.CreatePanel(elements, "Overlay", guid_BSOD, "1 1 1 1", UI2.vectorFullscreen, url_bsod, true, 0, 0, false);
            UI2.CreatePanel(elements, guid_BSOD, "blackpreloader", "0 0 0 1", UI2.vectorFullscreen, null, true, 0, 0, false);

            //add a way out for admins
            if (IsAdmin(player))
            {
                UI2.CreateButton(elements, guid_BSOD, "exitbutton", "0 0 0 0", "", 12, UI2.vectorFullscreen, "uipaybackcommand bsod");
            }

            //clear out any old UI that is getting updated
            foreach (var id in elements)
            {
                CuiHelper.DestroyUi(player, id.Name);
            }

            //send the ui updates
            if (elements.Count > 0)
            {
                CuiHelper.AddUi(player, elements);
            }

            timer.Once(0.2f, () => {
                if (player != null)
                {
                    CuiHelper.DestroyUi(player, "blackpreloader");
                }
            });

            Worker.StaticStartCoroutine(PlayBSODSounds(player, playPublic));
        }


        //sounds like fapping
        string sound_bsod = "assets/bundled/prefabs/fx/impacts/physics/phys-impact-meat-hard.prefab";
        string sound_fall = "assets/bundled/prefabs/fx/player/fall-damage.prefab";
        IEnumerator PlayBSODSounds(BasePlayer player, bool playPublic)
        {
            float timeStart = Time.realtimeSinceStartup;
            while (Time.realtimeSinceStartup - timeStart < 30)
            {
                PlaySound(sound_fall, player, !playPublic);
                yield return new WaitForSeconds(0.2f);
            }
            yield return null;
        }

        [ConsoleCommand("uipaybackcommand")]
        void CommandUICommand(ConsoleSystem.Arg arg)
        {

            var player = arg.Connection?.player as BasePlayer;
            if (player != null)
            {
                if (arg.Args.Length >= 1)
                {
                    string command = arg.Args[0];
                    if (command == "bsod")
                    {
                        TakeCard(player.userID, Card.BSOD, arg.Args, null);
                    }
                }
            }
        }


        [ChatCommand("setdroppercent")]
        void Command_SetDropPercent(BasePlayer player, string cmd, string[] args)
        {
            if (!IsAdmin(player)) return;
            SetDropPercent(player, args);
        }

        [ConsoleCommand("setdroppercent")]
        void Console_CommandSetDropPercent(ConsoleSystem.Arg arg)
        {

            //Puts($"Console_CommandSetDropPercent: {arg} {arg.Connection} {arg.Connection?.player}");

            var player = arg.Connection?.player as BasePlayer;
            if (player != null)
            {
                if (!IsAdmin(player)) return;
            }

            SetDropPercent(player, arg.Args);
        }

        void SetDropPercent(BasePlayer player, string[] args)
        {
            if (args.Length == 1)
            {
                float p;
                if (float.TryParse(args[0], out p))
                {
                    if (p > 1)
                    {
                        p = p / 100f;//assume the user is trying to put 42 for 42% instead of 0.42
                    }
                    p = Mathf.Clamp(p, 0f, 1f);

                    paybackData.percent_butterfingers_dropchance = p;

                    if (player != null) PrintToPlayer(player, $"Установите процент выпадения оружия с пальцами-бабочками на : %{p * 100}");
                    //Puts($"Set percent to drop weapon with butterfingers to : %{p * 100}");

                }
                else
                {
                    if (player != null) PrintToPlayer(player, "Необходимо ввести действительный % величины <0 - 100>");
                }
            }
            else
            {
                if (player != null) PrintToPlayer(player, "использование: setdroppercent <0-100>");
            }

        }


        Dictionary<ulong, float> playerMessageTimestamps = new Dictionary<ulong, float>();
        void SendPlayerLimitedMessage(ulong userID, string message, float rate = 5)
        {
            float ts = float.NegativeInfinity;
            if (playerMessageTimestamps.TryGetValue(userID, out ts))
            {
                if (Time.realtimeSinceStartup - ts > rate)
                {
                    ts = Time.realtimeSinceStartup;
                    playerMessageTimestamps[userID] = ts;
                    SendReply(BasePlayer.FindByID(userID), message);
                }
            }
            else
            {
                playerMessageTimestamps[userID] = ts;
                SendReply(BasePlayer.FindByID(userID), message);
            }
        }




        void AdminCommandToggleCard(BasePlayer admin, Card card, string[] args)
        {

            //| Special Commands
            if (card == Card.Bag)
            {
                ulong userID;
                if (!ulong.TryParse(args[0], out userID))
                {
                    PrintToPlayer(admin, "использование: /bag <steamid>");
                    return;
                }
                DoBagSearch(userID, args, admin);
            }

            //| Requires target commands
            if (args.Length == 0 && admin != null)
            {

                var entity = RaycastFirstEntity(admin.eyes.HeadRay(), 100);
                if (entity is BasePlayer)
                {
                    var targetPlayer = entity as BasePlayer;
                    AdminToggleCard(admin, targetPlayer, card, args);
                }
                else
                {
                    //raycast target in front of you
                    //SendReply(admin, "did not find player from head raycast, either look at your target or do /<cardname> <playername>");
                    PrintToPlayer(admin, "не нашел игрока из рейкаста головы, либо смотри на свою цель, либо делай /<cardname> <playername>");
                }

                return;
            }

            if (args.Length >= 1)
            {
                var targetPlayer = GetPlayerWithName(args[0]);
                if (targetPlayer != null)
                {

                    if (args.Length == 2 && args[1] == "team")
                    {

                        var members = GetPlayerTeam(targetPlayer.userID);

                        string teamMatesPrintout = "";
                        foreach (var member in members)
                        {
                            BasePlayer p = BasePlayer.FindByID(member);
                            if (p != null && p.IsConnected)
                            {
                                teamMatesPrintout += p.displayName + " ";
                            }
                        }
                        PrintToPlayer(admin, $"Передача {card} команде {targetPlayer.displayName}  - {members.Count} товарищам по команде: {teamMatesPrintout}");

                        foreach (var member in members)
                        {
                            BasePlayer p = BasePlayer.FindByID(member);
                            if (p != null && p.IsConnected)
                            {
                                AdminToggleCard(admin, p, card, args);
                            }

                        }

                    }
                    else
                    {
                        AdminToggleCard(admin, targetPlayer, card, args);
                    }
                }
                else
                {

                    ulong userID;
                    if (ulong.TryParse(args[0], out userID))
                    {
                        targetPlayer = BasePlayer.FindByID(userID);
                        if (targetPlayer != null)
                        {

                            if (args.Length == 2 && args[1] == "team")
                            {

                                var members = GetPlayerTeam(targetPlayer.userID);
                                PrintToPlayer(admin, $"Передача {card} команде {targetPlayer.displayName} имеет {members.Count} товарищей по команде");
                                foreach (var member in members)
                                {
                                    BasePlayer p = BasePlayer.FindByID(member);
                                    if (p != null && p.IsConnected)
                                    {
                                        AdminToggleCard(admin, p, card, args);
                                    }

                                }

                            }
                            else
                            {
                                AdminToggleCard(admin, targetPlayer, card, args);
                            }


                            return;
                        }
                        else
                        {

                        }

                    }
                    else
                    {

                    }

                    PrintToPlayer(admin, $"не смог найти игрока : {args[0]}");
                }
            }
        }
        void AdminToggleCard(BasePlayer admin, BasePlayer targetPlayer, Card card, string[] args)
        {
            if (HasCard(targetPlayer.userID, card))
            {
                TakeCard(targetPlayer.userID, card, args, admin);
                PrintToPlayer(admin, $"Удалена {card} из {targetPlayer.displayName}");
            }
            else
            {
                GiveCard(targetPlayer.userID, card, args, admin);
                PrintToPlayer(admin, $"Дал {card} to {targetPlayer.displayName}");
            }
        }



        [ConsoleCommand("payback")]
        void Console_Payback(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if (player != null)
            {
                if (!IsAdmin(player)) return;
            }
            CommandPayback(player, "", arg.Args);
        }

        [ChatCommand("payback")]
        void ChatCommandPayback(BasePlayer player, string cmd, string[] args)
        {
            if (!IsAdmin(player)) return;
            SendReply(player, "Проверьте вывод Payback в консоли F1!");
            CommandPayback(player, cmd, args);
        }
        void CommandPayback(BasePlayer player, string cmd, string[] args)
        {
            if (player != null && !IsAdmin(player)) return;
            // list all cards

            if (args == null || args.Length == 0)
            {
                DoPaybackPrintout(player, args);
                return;
            }

            List<string> argsList = new List<string>(args);
            if (argsList.FirstOrDefault(x => x == "show") != null)
            {
                string output = "Активные карты:\n";
                // show all active cards and players
                foreach (var userid in cardMap.Keys)
                {
                    var targetPlayer = BasePlayer.FindByID(userid);
                    string playername = "";
                    if (targetPlayer != null)
                    {
                        playername = targetPlayer.displayName;
                    }
                    HashSet<Card> cards = cardMap[userid];
                    output += $"{userid} : {playername}\n";
                    foreach (var card in cards)
                    {
                        output += $"\n{card.ToString()} : {UI2.ColorText(descriptions[card], "white")}";
                    }
                    output += "\n\n";
                }
                PrintToPlayer(player, output);

            }

            if (argsList.FirstOrDefault(x => x == "clear") != null)
            {

                foreach (var userid in new List<ulong>(cardMap.Keys))
                {
                    var targetPlayer = BasePlayer.FindByID(userid);
                    string playername = "";
                    if (targetPlayer != null)
                    {
                        playername = targetPlayer.displayName;
                    }

                    if (player != null)
                    {
                        HashSet<Card> cards = cardMap[userid];
                        foreach (var card in new HashSet<Card>(cards))
                        {
                            TakeCard(player, card);
                        }
                    }

                }

                cardMap.Clear();
                PrintToPlayer(player, "удалены все карты у всех игроков");
            }

        }
        void DoPaybackPrintout(BasePlayer player, string[] args)
        {


            Dictionary<Card, List<string>> cardToAliases = new Dictionary<Card, List<string>>();
            foreach (var alias in cardAliases.Keys)
            {
                Card c = cardAliases[alias];
                List<string> aliases;
                if (!cardToAliases.TryGetValue(c, out aliases))
                {
                    aliases = new List<string>();
                    cardToAliases[c] = aliases;
                }
                aliases.Add(alias);
            }

            var cards = Enum.GetValues(typeof(Card));
            string output = "";

            output += "\n" + "Добавьте \"team\" после команды, чтобы применить эффект к команде целевого игрока, а также к нему самому.  Пример: /butterfingers <steamid> team";
            output += "\n" + "/setdroppercent <1-100>% чтобы изменить шанс выпадения баттерфингов";
            output += "\n" + $"администраторам требуется разрешение {permission_admin} для использования этих команд!";
            output += "\n" + $"используйте '/payback show' чтобы узнать, у кого из игроков какие карты";
            output += "\n" + $"используйте '/payback clear' чтобы удалить все карты у всех игроков.";
            output += "\n" + $"НЕ обязательно снимать эффекты с игроков после завершения.";
            output += "\n" + $"Белый список временно забаненных игроков с: bancheckexception <id>";

            output += "\n\nPayback Cards:";

            foreach (Card card in cards)
            {
                string desc;
                descriptions.TryGetValue(card, out desc);

                List<string> aliases = cardToAliases[card];
                string aliasesTogether = "";
                aliases.ForEach(x => aliasesTogether += $"[ {UI2.ColorText(x, "yellow")} ] ");


                output += "\n\n" + $"{aliasesTogether}: { UI2.ColorText(desc, "white")}";
            }
            output += "\n\n" + UI2.ColorText("вы также можете использовать /listen для циклического переключения между игроками, которые недавно использовали микрофон (отлично подходит для bind!)", "white");


            PrintToPlayer(player, output);
        }

        //| ==============================================================
        //| PAYBACK OPTIONS
        //| ==============================================================

        Dictionary<ulong, HashSet<Card>> cardMap = new Dictionary<ulong, HashSet<Card>>();
        public bool HasAnyCard(ulong userID)
        {
            HashSet<Card> cards = null;
            if (cardMap.TryGetValue(userID, out cards))
            {
                if (cards.Count > 0)
                {
                    return true;
                }
            }
            return false;
        }
        public bool HasCard(ulong userID, Card card)
        {
            HashSet<Card> cards;
            if (cardMap.TryGetValue(userID, out cards))
            {
                if (cards.Contains(card))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }

        public void TakeCard(BasePlayer player, Card card, string[] args = null, BasePlayer admin = null)
        {
            TakeCard(player.userID, card, args, admin);
        }
        public void TakeCard(ulong userID, Card card, string[] args = null, BasePlayer admin = null)
        {
            HashSet<Card> cards;
            if (!cardMap.TryGetValue(userID, out cards))
            {
                cards = new HashSet<Card>();
                cardMap[userID] = cards;
            }
            cards.Remove(card);

            var player = BasePlayer.FindByID(userID);

            if (cards.Count == 0)
            {
                cardMap.Remove(userID);
            }
            if (card == Card.BSOD)
            {
                if (player != null)
                {
                    CuiHelper.DestroyUi(player, guid_BSOD);
                }
            }
            else if (card == Card.Sit)
            {
                if (player != null)
                {
                    DoSitCommand(player, admin);
                }
            }
            else if (card == Card.Shocker)
            {
                DoShocker(player, null, admin);
            }


            //Puts($"Payback card {card} taken from {userID}");
        }



        HashSet<ulong> recentPlayerVoices = new HashSet<ulong>();
        Dictionary<ulong, float> recentPlayerVoiceTimestamps = new Dictionary<ulong, float>();

        Dictionary<ulong, HashSet<ulong>> listenedPlayersMap = new Dictionary<ulong, HashSet<ulong>>();

        Timer listenTimer = null;
        bool isListening = false;



        [ConsoleCommand("listen")]
        void ConsoleCommandListenNext(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if (player != null)
            {
                if (!IsAdmin(player)) return;
                CommandListenNext(player);
            }
        }

        [ChatCommand("listen")]
        void CommandListenNext(BasePlayer player)
        {
            if (!IsAdmin(player)) return;

            if (!isListening)
            {
                isListening = true;
                PrintToPlayer(player, $"Payback не слушал, теперь начинает слушать!");
                Subscribe("OnPlayerVoice");
                return;
            }
            else
            {
                if (listenTimer != null)
                {
                    listenTimer.Destroy();
                }
                listenTimer = timer.Once(60 * 15, () => {
                    isListening = false;
                    this.Unsubscribe("OnPlayerVoice");
                    if (player != null)
                    {
                        PrintToPlayer(player, "Payback перестал прислушиваться к голосам игроков.");
                    }
                });
            }

            HashSet<ulong> alreadyListenedToPlayers = null;
            if (!listenedPlayersMap.TryGetValue(player.userID, out alreadyListenedToPlayers))
            {
                alreadyListenedToPlayers = new HashSet<ulong>();
                listenedPlayersMap[player.userID] = alreadyListenedToPlayers;
            }

            recentPlayerVoices.RemoveWhere(x => Time.realtimeSinceStartup - recentPlayerVoiceTimestamps[x] > 60);
            List<ulong> voices = new List<ulong>(recentPlayerVoices);
            voices.RemoveAll(x => alreadyListenedToPlayers.Contains(x));
            voices.Sort((x, y) => recentPlayerVoiceTimestamps[y].CompareTo(recentPlayerVoiceTimestamps[x]));

            if (voices.Count == 0 && alreadyListenedToPlayers.Count > 0)
            {
                listenedPlayersMap[player.userID] = new HashSet<ulong>();
                if (recentPlayerVoices.Count > 0)
                {
                    CommandListenNext(player);
                    return;
                }
                else
                {
                    PrintToPlayer(player, "Никто больше ничего не сказал за последние 60 секунд!");
                }
            }
            else
            {
                if (voices.Count > 0)
                {
                    ulong playerID = voices[0];

                    BasePlayer targetPlayer = BasePlayer.FindByID(playerID);

                    if (targetPlayer != null)
                    {
                        alreadyListenedToPlayers.Add(playerID);

                        player.SendConsoleCommand($"spectate {playerID}");
                        PrintToPlayer(player, $"Listening in on ... {targetPlayer.displayName} [{(int)(Time.realtimeSinceStartup - recentPlayerVoiceTimestamps[playerID])}s] \n{(alreadyListenedToPlayers.Count)} / {(alreadyListenedToPlayers.Count + voices.Count - 1)}");
                    }
                    else
                    {
                        recentPlayerVoices.Remove(playerID);
                        PrintToPlayer(player, $"Player отключился, попробуйте еще раз...");
                    }

                }
                else
                {
                    PrintToPlayer(player, "Никто ничего не сказал за последние 60 секунд!");
                }
            }

        }




        //| ==============================================================
        //| OXIDE HOOKS
        //| ==============================================================

        private object OnPlayerViolation(BasePlayer player, AntiHackType type)
        {
            if (type == AntiHackType.InsideTerrain && HasAnyCard(player.userID)) return false;
            return null;
        }

        object OnPlayerDeath(BasePlayer player, HitInfo hitinfo)
        {
            if (HasAnyCard(player.userID))
            {
                if (HasCard(player.userID, Card.Pinyata))
                {
                    DoPinyataEffect(player);
                }
                if (player.isMounted)
                {
                    player.GetMounted().DismountPlayer(player, true);
                }

                //if (HasCard(player.userID, Card.Cowboy))
                //{
                //    DoCowboy(player, null);
                //}

                if (HasCard(player.userID, Card.NoRest))
                {
                    timer.Once(3f, () => {
                        if (player != null)
                        {
                            if (player.IsDead())
                            {
                                player.Respawn();
                            }
                        }
                    });
                }

                if (HasCard(player.userID, Card.Shocker))
                {
                    BaseEntity coil;
                    if (coilMap.TryGetValue(player.userID, out coil))
                    {
                        if (coil != null)
                        {
                            coil.SetParent(null, true, true);
                            var trigger = coil.GetComponentInChildren<TriggerBase>();
                            trigger.OnEntityLeave(player);
                        }
                    }
                }
            }

            return null;
        }



        float Random()
        {
            return UnityEngine.Random.Range(0f, 1f);
        }

        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            recentPlayerVoices.Add(player.userID);
            recentPlayerVoiceTimestamps[player.userID] = Time.realtimeSinceStartup;
            return null;
        }


        object OnHealingItemUse(MedicalTool tool, BasePlayer player)
        {
            if (HasAnyCard(player.userID))
            {
                if (HasCard(player.userID, Card.DrNo))
                {
                    return false;
                }
            }
            return null;
        }
        object OnPlayerHealthChange(BasePlayer player, float oldValue, float newValue)
        {
            if (HasAnyCard(player.userID))
            {

                if (HasCard(player.userID, Card.DrNo))
                {
                    if (oldValue < newValue)
                    {

                        NextTick(() => {
                            if (player != null)
                            {
                                if (player.health > oldValue)
                                {
                                    player.health = oldValue;
                                    player.metabolism.pending_health.SetValue(0);
                                    player.SendNetworkUpdateImmediate();

                                }
                            }

                        });
                        return false;

                    }
                }

            }
            return null;
        }


        [ChatCommand("TestBanned")]
        void CommandTestBanned(BasePlayer player, string cmd, string[] args)
        {
            if (!IsAdmin(player)) return;
            CheckPublisherBan(player.name, player.userID, player.net.connection.ipaddress, "PublisherBanned");
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            //if (player != null)
            //{
            //    CheckPublisherBan(player.displayName, player.userID, player.net?.connection?.ipaddress, reason);
            //}
            if (player != null && HasCard(player.userID, Card.Shocker))
            {
                TakeCard(player.userID, Card.Shocker);
            }
            if (player != null && HasCard(player.userID, Card.Sit))
            {
                TakeCard(player, Card.Sit);
            }
        }

        //Interface.CallHook("OnPlayerBanned", connection, status.ToString());        
        void OnPlayerBanned(Network.Connection connection, string reason)
        {
            if (connection != null)
            {
                var player = connection.player as BasePlayer;
                if (player != null)
                {
                    OnPlayerBanned(player.displayName, player.userID, connection.ipaddress, reason);
                }
            }
        }

        void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            //force the banned player dead and out of any chairs, else the model seems to stay behind
            var player = BasePlayer.FindByID(id);
            if (player != null)
            {
                if (sitChairMap.ContainsKey(id))
                {
                    player.GetMounted().DismountPlayer(player, true);
                    player.Die();
                }
            }
            CheckPublisherBan(name, id, address, reason);
        }
        void OnPlayerKicked(BasePlayer player, string reason)
        {
            //force the banned player dead and out of any chairs, else the model seems to stay behind
            if (sitChairMap.ContainsKey(player.userID))
            {
                player.GetMounted().DismountPlayer(player, true);
                player.Die();
            }

            CheckPublisherBan(player?.name, player.userID, player?.net?.connection?.ipaddress, reason);
        }

        List<string> banReasons = new List<string>() {
            "kickbanned",
            "cheat detected",
            "PublisherBanned",
        };

        void CheckPublisherBan(string name, ulong id, string address, string reason)
        {
            bool reasonIsPublisherBan = banReasons.Any(x => reason.ToLower().Contains(x.ToLower()));
            //Puts($"[Payback Detected Player Ban] {player.name} : {id} : {address} - {reason} | notifygb: {config.notify_game_ban} onlyteams: {config.notify_only_if_has_team}");
            if (reasonIsPublisherBan)
            {

                if (!config.notify_game_ban) return;

                string serverHostName = ConsoleSystem.Run(ConsoleSystem.Option.Server, $"hostname", new object[0]);

                var team = RelationshipManager.ServerInstance.FindPlayersTeam(id);

                var payload = new Dictionary<string, string>() {
                    { "Server", $"{serverHostName}" },
                    //{ "Banned Player", $"{name} : {id}" },
                    { "Забаненный игрок", $"[Info](https://steamid.uk/profile/{id}) - {id} : [{TryGetDisplayName(id)}](https://www.battlemetrics.com/rcon/players?filter[search]={id})" },

                };

                int number = 1;
                string playerOutput = "";

                if (team != null)
                {
                    foreach (var userID in new HashSet<ulong>(team.members))
                    {
                        if (userID != id)
                        {
                            //playerOutput += $"\n{number} -> {userID} : {TryGetDisplayName(userID)}";

                            if (config.notify_ban_include_bm)
                            {
                                //playerOutput += $"\nhttps://www.battlemetrics.com/rcon/players?filter[search]={userID}";
                                playerOutput += $"\n[{userID}](https://steamid.uk/profile/{userID}) : [{TryGetDisplayName(userID)}](https://www.battlemetrics.com/rcon/players?filter[search]={userID})";

                            }

                            number++;
                        }
                    }
                }
                if (number == 1)
                {
                    if (config.notify_only_if_has_team)
                    {
                        return;
                    }
                }
                else
                {
                    payload.Add($"teaminfo", playerOutput);
                }

                //Puts($"[Payback Detected Player Ban] sending to webhook");

                SendToDiscordWebhook(payload, "GAME BAN");
            }
        }


        string TryGetDisplayName(ulong userID)
        {
            return covalence.Players.FindPlayerById(userID.ToString())?.Name;
        }


        [ConsoleCommand("bancheckexception")]
        void CommandBanCheckException(ConsoleSystem.Arg arg)
        {

            var player = arg.Connection?.player as BasePlayer;
            if (player != null)
            {
                if (!IsAdmin(player)) return;
            }
            if (arg.Args.Length >= 1)
            {
                ulong id;
                if (ulong.TryParse(arg.Args[0], out id))
                {
                    paybackData.bancheck_exceptions.Add(id);
                    PrintToPlayer(player, $"Добавлено исключение банчека: {id} всего: {paybackData.bancheck_exceptions.Count}");
                }
                else
                {
                    PrintToPlayer(player, $"не удалось разобрать id");
                }
            }
            else
            {
                PrintToPlayer(player, $"недостаточно аргументов");
            }
        }


        bool test_connect = false;
        [ChatCommand("testconnect")]
        void CommandTestConnect(BasePlayer player)
        {
            if (!IsAdmin(player)) return;

            test_connect = true;
            OnPlayerConnected(player);
            test_connect = false;
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (config.enabled_nexus_gamebancheck)
            {
                if (paybackData.bancheck_exceptions.Contains(player.userID)) return;

                string url = $"https://www.nexusonline.co.uk/bans/profile/?id={player.userID}";
                if (test_connect)
                {
                    url = $"https://www.nexusonline.co.uk/bans/profile/?id=76561199128818380";
                }
                //string url = $"https://www.nexusonline.co.uk/bans/profile/?id=76561199128818380";

                webrequest.Enqueue(url, "", (code, response) =>
                {
                    if (code == 200)
                    {
                        if (response == null) return;

                        //Puts(response);
                        if (response.Contains("В НАСТОЯЩЕЕ ВРЕМЯ ИГРА ЗАПРЕЩЕНА".ToLower()))
                        {

                            Regex regex = new Regex($"<a.+?<a.+?\">(.+?)<\\/a><\\/blockquote>");
                            var match = regex.Match(response);
                            DateTime date = DateTime.Now;
                            foreach (var g in match.Groups)
                            {
                                if (g == null) continue;
                                //Puts($"G: {g}");
                                if (DateTime.TryParse(g.ToString(), out date))
                                {
                                    //Puts($"Parsed date: {date}");
                                    break;
                                }
                            }

                            if (date != null && date.AddDays(config.nexus_ban_days) > DateTime.Now)
                            {
                                string serverHostName = ConsoleSystem.Run(ConsoleSystem.Option.Server, $"hostname", new object[0]);
                                if (player == null) return;
                                //Puts($"Detected game-banned user: {player.userID} {player.displayName}");
                                SendToDiscordWebhook(new Dictionary<string, string>() {
                                    { "Server", $"{serverHostName}" },
                                    //{ "Url", $"{url}" },
                                    //{ "Player", $"{player.displayName} : {player.userID}" },
                                    { "Player", $"[Info](https://steamid.uk/profile/{player.userID}) - {player.userID} : [{TryGetDisplayName(player.userID)}](https://www.battlemetrics.com/rcon/players?filter[search]={player.userID})" },

                                });
                            }

                        }

                    }
                    else
                    {
                        PrintError($"nexusonline HTTP CODE: {code}");
                    }
                }, this);
            }

        }

        void SendToDiscordWebhook(Dictionary<string, string> messageData, string title = "ОБНАРУЖЕН ВРЕМЕННЫЙ ИГРОВОЙ ЗАПРЕТ")
        {
            if (config.webhooks == null || config.webhooks.Count == 0)
            {
                Puts($"Не удалось отправить Discord Webhook: webhook не настроен");
                return;
            }

            string discordEmbedTitle = title;


            List<object> fields = new List<object>();

            foreach (var key in messageData.Keys)
            {
                string data = messageData[key];
                fields.Add(new { name = $"{key}", value = $"{data}", inline = false });
            }

            object f = fields.ToArray();


            foreach (var webhook in config.webhooks)
            {
                SendWebhook(webhook, (string)discordEmbedTitle, f);
            }
        }

        private void SendWebhook(string WebhookUrl, string title, object fields)
        {
            if (string.IsNullOrEmpty(WebhookUrl))
            {
                Puts("Ошибка: Кто-то пытался использовать команду, но WebhookUrl не задан!");
                return;
            }

            //test
            string json = new SendEmbedMessage(13964554, title, fields).ToJson();

            webrequest.Enqueue(WebhookUrl, json, (code, response) =>
            {
                if (code == 429)
                {
                    Puts("Отправлено слишком много запросов, пожалуйста, подождите");
                    return;
                }

                if (code != 204)
                {
                    Puts(code.ToString());
                }
                if (code == 400)
                {
                    Puts(response + "\n\n" + json);
                }
            }, this, Oxide.Core.Libraries.RequestMethod.POST, new Dictionary<string, string> { ["Content-Type"] = "application/json" });
        }

        private class SendEmbedMessage
        {
            public SendEmbedMessage(int EmbedColour, string discordMessage, object _fields)
            {
                object embed = new[]
                {
                    new
                    {
                        title = discordMessage,
                        fields = _fields,
                        color = EmbedColour,
                        thumbnail = new Dictionary<object, object>() { { "url", "https://i.imgur.com/ruy7N2Z.png" } },
                    }
                };
                Embeds = embed;
            }

            [JsonProperty("embeds")] public object Embeds { get; set; }

            public string ToJson() => JsonConvert.SerializeObject(this);
        }


        private void OnEntityTakeDamage(BaseEntity entity, HitInfo hitinfo)
        {
            if (entity == null || hitinfo == null) return;

            if (chickens.Count > 0)
            {
                if (chickens.Contains(entity))
                {
                    hitinfo.damageTypes.Clear();
                    hitinfo.DoHitEffects = false;
                    return;
                }
            }

            if (cardMap.Count == 0) return;//early out for maximum perf


            if (hitinfo != null)
            {

                if (protectedStashes.Contains(entity))
                {
                    hitinfo.damageTypes.Clear();
                    hitinfo.DoHitEffects = false;
                }
                if (sitChairMap.Values.Contains(entity))
                {
                    hitinfo.damageTypes.Clear();
                    hitinfo.DoHitEffects = false;
                }


                var player = entity as BasePlayer;
                var attacker = hitinfo.InitiatorPlayer;

                if (player != null && HasCard(player.userID, Card.Masochist) && hitinfo.damageTypes != null && hitinfo.damageTypes.GetMajorityDamageType() == DamageType.Suicide)
                {
                    hitinfo.damageTypes.Clear();
                    hitinfo.DoHitEffects = false;
                }

                if (player != null && HasCard(player.userID, Card.Shocker) && hitinfo.damageTypes != null && hitinfo.damageTypes.GetMajorityDamageType() == DamageType.ElectricShock)
                {
                    DoScreaming(player, null, false, true);
                }

                //flamethrower
                if (hitinfo.WeaponPrefab != null && hitinfo.WeaponPrefab.prefabID == 3717106868 && entity is BasePlayer && attacker != null && player != null)
                {
                    if (hitinfo.InitiatorPlayer != null)
                    {
                        if (HasCard(hitinfo.InitiatorPlayer.userID, Card.Burn))
                        {

                            if (hitinfo.InitiatorPlayer == entity)
                            {
                                hitinfo.damageTypes.Scale(DamageType.Heat, 0f);//prevent heat damage to self
                            }
                            else
                            {

                                DoScreaming(player, attacker, true);

                                FlameThrower t = attacker.GetHeldEntity() as FlameThrower;
                                if (t == null) return;

                                t.ammo = t.maxAmmo;

                                var ammoItem = t.GetAmmo();
                                if (ammoItem != null)
                                {
                                    ammoItem.amount = 100;
                                    ammoItem.MarkDirty();
                                }
                                t.SendNetworkUpdate();

                            }
                        }
                    }

                }



                //PrintToChat($"OnEntityTakeDamage {player} attacker {hitinfo?.InitiatorPlayer}");

                if (attacker != null && HasAnyCard(attacker.userID))
                {
                    var members = GetPlayerTeam(attacker.userID);
                    members.Remove(attacker.userID);

                    bool friendlyFire = false;
                    if (player != null)
                    {
                        friendlyFire = members.Contains(player.userID);
                    }

                    bool isSuicide = hitinfo.damageTypes.GetMajorityDamageType() == Rust.DamageType.Suicide;

                    //no suicide!
                    //if (isSuicide && HasCard(player.userID, Card.Sit))
                    //{
                    //    hitinfo.damageTypes.Clear();
                    //    hitinfo.DoHitEffects = false;
                    //}

                    if (player != null && attacker != null && attacker != player)
                    {


                        if (HasCard(attacker.userID, Card.InstantKarma))
                        {

                            if (!friendlyFire)
                            {

                                float newHealth = attacker.health - hitinfo.damageTypes.Total() * 0.35f;
                                if (newHealth < 5)
                                {
                                    attacker.Die();
                                }
                                else
                                {
                                    attacker.SetHealth(newHealth);
                                    attacker.metabolism.SendChangesToClient();
                                    attacker.SendNetworkUpdateImmediate();
                                    //PlaySound("assets/bundled/prefabs/fx/headshot.prefab", attacker, false);
                                    PlaySound("assets/bundled/prefabs/fx/headshot_2d.prefab", attacker, true);
                                }

                                hitinfo.damageTypes.Clear();
                                hitinfo.DoHitEffects = false;

                            }

                        }

                        if (HasCard(attacker.userID, Card.Butterfingers) && !friendlyFire)
                        {
                            var roll = UnityEngine.Random.Range(0f, 1f);


                            //manipulate target based on clip size

                            BaseProjectile weapon = hitinfo.Weapon as BaseProjectile;
                            float magazineMultiplier = 1;
                            if (weapon != null)
                            {
                                magazineMultiplier = Mathf.Clamp(20f / weapon.primaryMagazine.capacity, 1, 10);
                            }


                            if (roll < paybackData.percent_butterfingers_dropchance * magazineMultiplier)
                            {
                                //chance to drop weapon.

                                var heldEntity = attacker.GetHeldEntity();


                                if (heldEntity != null)
                                {
                                    var item = heldEntity.GetItem();
                                    if (item != null)
                                    {
                                        var droppedEntity = item.Drop(attacker.eyes.HeadRay().origin, attacker.eyes.HeadRay().direction * 5 + Vector3.up * 5);
                                        droppedEntity.transform.LookAt(attacker.eyes.HeadRay().origin + Quaternion.Euler(0, UnityEngine.Random.Range(-90, 90), UnityEngine.Random.Range(-90, 90)) * attacker.eyes.HeadRay().direction * 2);
                                        var body = droppedEntity.GetComponentInChildren<Rigidbody>();
                                        if (body != null)
                                        {
                                            float power = 1;
                                            body.AddForceAtPosition(attacker.eyes.HeadRay().direction * power, droppedEntity.transform.position + Vector3.up * 10f);
                                        }
                                        droppedEntity.SendNetworkUpdate();

                                    }
                                }



                            }
                        }

                    }

                    if (HasCard(attacker.userID, Card.Pacifism) && attacker != player && player != null)
                    {

                        if (!friendlyFire)
                        {
                            hitinfo.damageTypes.Clear();
                            hitinfo.DoHitEffects = false;

                            if (config.notifyCheaterAttacking && !silentPacifism)
                            {
                                SendPlayerLimitedMessage(player.userID, $"На вас напал [{UI2.ColorText(attacker.displayName, "yellow")}] a known cheater!\n{UI2.ColorText("Tommygun's Payback Plugin", "#7A2E30")} has prevented all damage to you.");
                            }
                            //Puts($"{player.displayName} attacked by [{attacker.displayName}] a known cheater! Tommygun's Payback has prevented all damage from the cheater");

                        }

                    }


                    //prevent damage to non-player entities
                    if (HasCard(attacker.userID, Card.Dud) && player == null)
                    {
                        hitinfo.damageTypes.Clear();
                        //hitinfo.DoHitEffects = false;
                        hitinfo.gatherScale = 0;
                    }


                }

                //make landmines from dog doo kill the player
                if (player != null && HasAnyCard(player.userID))
                {
                    if (hitinfo.Initiator is Landmine && player != null && HasCard(player.userID, Card.DogDoo))
                    {
                        hitinfo.damageTypes.ScaleAll(10);
                    }
                }


            }
        }

        void DoScreaming(BasePlayer player, BasePlayer attacker, bool fire = false, bool screamSourceIsTarget = false)
        {
            if (!currentlyScreamingPlayers.Contains(player.userID))
            {

                PlayGesture(player, "friendly");
                timer.Once(2f, () => {
                    if (player != null)
                        PlayGesture(player, "friendly");
                });
                timer.Once(4f, () => {
                    if (player != null)
                        PlayGesture(player, "friendly");
                });

                if (screamSourceIsTarget)
                {
                    PlaySound(sound_scream, player, false);
                }
                else
                {
                    PlaySound(sound_scream, attacker, false);
                }

                if (fire)
                {
                    PlaySound(effect_onfire, player, false);
                }

                currentlyScreamingPlayers.Add(player.userID);

                timer.Once(5f, () => {
                    if (player != null)
                        currentlyScreamingPlayers.Remove(player.userID);
					});
            }
        }

        HashSet<BaseEntity> protectedStashes = new HashSet<BaseEntity>();
        void OnStashExposed(StashContainer stash, BasePlayer player)
        {
            if (HasCard(player.userID, Card.DogDoo))
            {
                if (protectedStashes.Contains(stash)) return;//once only.
                protectedStashes.Add(stash);
                timer.Once(2f, () => {

                    if (player != null)
                    {
                        var entity = GameManager.server.CreateEntity("assets/prefabs/deployable/landmine/landmine.prefab", player.transform.position);
                        Landmine landmine = entity as Landmine;
                        entity.Spawn();
                        landmine.Arm();
                        landmine.SendNetworkUpdateImmediate();
                    }

                });

                timer.Once(120f, () => {

                    if (stash != null && !stash.IsDead())
                    {
                        protectedStashes.Remove(stash);
                    }

                });

            }
        }

        //| ==============================================================
        //| UTILITY
        //| ==============================================================

        public BasePlayer GetPlayerWithName(string displayName)
        {
            foreach (var p in BasePlayer.allPlayerList)
            {
                if (p.displayName.ToLower().Contains(displayName.ToLower()))
                {
                    return p;
                }
            }
            return null;
        }
        BaseEntity RaycastFirstEntity(Ray ray, float distance)
        {
            RaycastHit hit;
            if (Physics.Raycast(ray.origin, ray.direction, out hit, distance))
            {
                return hit.GetEntity();
            }
            return null;
        }


        //| ==============================================================
        //| INIT
        //| ==============================================================
        void Initialize()
        {
            //Puts("Tommygun's Payback Initialized");

            Unsubscribe("OnPlayerVoice");
            Unsubscribe($"OnEntityKill");

            LoadData();

            permission.RegisterPermission(permission_admin, this);

            var cards = Enum.GetValues(typeof(Card));

            foreach (Card card in cards)
            {
                cardAliases[card.ToString().ToLower()] = card;
            }
            foreach (var alias in cardAliases.Keys)
            {
                cmd.AddChatCommand(alias, this, nameof(GenericChatCommand));
                cmd.AddConsoleCommand(alias, this, nameof(GenericConsoleCommand));
            }

            //Puts("Tommygun's Payback Finished Initialization");

        }
        void GenericChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!IsAdmin(player)) return;
            string argsTogether = "";
            foreach (var arg in args)
            {
                argsTogether += arg + " ";
            }
            //SendReply(player, $"cmd: {cmd} args {argsTogether}");
            Card card;
            if (cardAliases.TryGetValue(cmd.ToLower(), out card))
            {
                AdminCommandToggleCard(player, card, args);
            }
        }
        void GenericConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (player != null)
            {
                if (!IsAdmin(player)) return;
            }
            if (arg == null) return;
            if (arg.cmd == null) return;

            string argsTogether = "";

            if (arg.Args != null)
            {
                foreach (var param in arg.Args)
                {
                    argsTogether += param + " ";
                }
            }

            string cmd = string.Empty;
            if (arg.cmd.Name != null)
            {
                cmd = arg.cmd.Name;
            }

            Card card;
            if (cardAliases.TryGetValue(cmd.ToLower(), out card))
            {
                if (arg.Args == null)
                {
                    arg.Args = new string[0];
                }
                AdminCommandToggleCard(player, card, arg.Args);
            }
        }
        void OnServerInitialized(bool serverIsNOTinitialized)
        {
            bool serverHasInitialized = !serverIsNOTinitialized;
            Initialize();
        }






        //| ==============================================================
        //| ViewInventory - Copied from Whispers88 and modified here
        //| ==============================================================
        private static List<string> _viewInventoryHooks = new List<string> { "OnLootEntityEnd", "CanMoveItem", "OnEntityDeath" };

        void ViewTargetPlayerInventory(BasePlayer target, BasePlayer admin)
        {
            if (admin == null) return;
            if (admin.IsSpectating())
            {
                PrintToPlayer(admin, $"{UI2.ColorText($"[PAYBACK WARNING] ", "yellow") } : {UI2.ColorText($"cannot open target's inventory while spectating! you must respawn", "white")}");
                return;
            }
            PrintToPlayer(admin, $"{UI2.ColorText($"[PAYBACK WARNING] ", "yellow") } : {UI2.ColorText($"you must exit the F1 console immediately after using the command to view inventory", "white")}");

            ViewInvCmd(admin.IPlayer, "ViewInvCmd", new string[] { $"{target.userID}" });
        }


        #region ViewInventoryCommands
        private void ViewInvCmd(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;
            if (player == null) return;

            //if (!HasPerm(player.UserIDString, permission_admin))
            //{
            //    ChatMessage(iplayer, GetLang("NoPerms"));
            //    return;
            //}


            if (args.Length == 0 || string.IsNullOrEmpty(args[0]))
            {
                RaycastHit hitinfo;
                if (!Physics.Raycast(player.eyes.HeadRay(), out hitinfo, 3f, (int)Layers.Server.Players))
                {
                    ChatMessage(iplayer, "NoPlayersFoundRayCast");
                    return;
                }
                BasePlayer targetplayerhit = hitinfo.GetEntity().ToPlayer();
                if (targetplayerhit == null)
                {
                    ChatMessage(iplayer, "NoPlayersFoundRayCast");
                    return;
                }
                //ChatMessage(iplayer, "ViewingPLayer", targetplayerhit.displayName);
                ViewInventory(player, targetplayerhit);
                return;
            }
            IPlayer target = FindPlayer(args[0]);
            if (target == null)
            {
                //ChatMessage(iplayer, "NoPlayersFound", args[0]);
                return;
            }
            BasePlayer targetplayer = target.Object as BasePlayer;
            if (targetplayer == null)
            {
                //ChatMessage(iplayer, "NoPlayersFound", args[0]);
                return;
            }
            //ChatMessage(iplayer, "ViewingPLayer", targetplayer.displayName);
            ViewInventory(player, targetplayer);
        }

        #endregion Commands

        #region Methods
        private List<LootableCorpse> _viewingcorpse = new List<LootableCorpse>();
        private void ViewInventory(BasePlayer player, BasePlayer targetplayer)
        {
            if (_viewingcorpse.Count == 0)
                SubscribeToHooks();

            player.EndLooting();

            var corpse = GetLootableCorpse(targetplayer.displayName);
            corpse.SendAsSnapshot(player.Connection);

            timer.Once(1f, () =>
            {
                StartLooting(player, targetplayer, corpse);
            });
        }

        LootableCorpse GetLootableCorpse(string title = "")
        {
            LootableCorpse corpse = GameManager.server.CreateEntity(StringPool.Get(2604534927), Vector3.zero) as LootableCorpse;
            corpse.CancelInvoke("RemoveCorpse");
            corpse.syncPosition = false;
            corpse.limitNetworking = true;
            //corpse.playerName = targetplayer.displayName;
            corpse.playerName = title;
            corpse.playerSteamID = 0;
            corpse.enableSaving = false;
            corpse.Spawn();
            corpse.SetFlag(BaseEntity.Flags.Locked, true);
            Buoyancy bouyancy;
            if (corpse.TryGetComponent<Buoyancy>(out bouyancy))
            {
                UnityEngine.Object.Destroy(bouyancy);
            }
            Rigidbody ridgidbody;
            if (corpse.TryGetComponent<Rigidbody>(out ridgidbody))
            {
                UnityEngine.Object.Destroy(ridgidbody);
            }
            return corpse;
        }

        private void StartLooting(BasePlayer player, BasePlayer targetplayer, LootableCorpse corpse)
        {
            player.inventory.loot.AddContainer(targetplayer.inventory.containerMain);
            player.inventory.loot.AddContainer(targetplayer.inventory.containerWear);
            player.inventory.loot.AddContainer(targetplayer.inventory.containerBelt);
            player.inventory.loot.entitySource = corpse;
            player.inventory.loot.PositionChecks = false;
            player.inventory.loot.MarkDirty();
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer<string>(null, player, "RPC_OpenLootPanel", "player_corpse");
            _viewingcorpse.Add(corpse);
        }
        private void StartLootingContainer(BasePlayer player, ItemContainer container, LootableCorpse corpse)
        {
            player.inventory.loot.AddContainer(container);
            player.inventory.loot.entitySource = corpse;
            player.inventory.loot.PositionChecks = false;
            player.inventory.loot.MarkDirty();
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer<string>(null, player, "RPC_OpenLootPanel", "player_corpse");
            _viewingcorpse.Add(corpse);
        }

        #endregion Methods

        #region Hooks
        private void OnLootEntityEnd(BasePlayer player, LootableCorpse corpse)
        {
            if (!_viewingcorpse.Contains(corpse)) return;

            _viewingcorpse.Remove(corpse);
            if (corpse != null)
                corpse.Kill();

            if (_viewingcorpse.Count == 0)
                UnSubscribeFromHooks();

        }


        void OnEntityDeath(LootableCorpse corpse, HitInfo info)
        {
            if (!_viewingcorpse.Contains(corpse)) return;
            _viewingcorpse.Remove(corpse);
            if (corpse != null)
                corpse.Kill();
            if (_viewingcorpse.Count == 0)
                UnSubscribeFromHooks();
        }
        #endregion Hooks

        #region Helpers

        private IPlayer FindPlayer(string nameOrId)
        {
            return BasePlayer.activePlayerList.FirstOrDefault(x => x.UserIDString == nameOrId || x.displayName.Contains(nameOrId)).IPlayer;
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private string GetLang(string langKey, string playerId = null, params object[] args) => string.Format(lang.GetMessage(langKey, this, playerId), args);
        private void ChatMessage(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }

        private void UnSubscribeFromHooks()
        {
            foreach (var hook in _viewInventoryHooks)
                Unsubscribe(hook);
        }

        private void SubscribeToHooks()
        {
            foreach (var hook in _viewInventoryHooks)
                Subscribe(hook);
        }
        #endregion

        //| ==============================================================
        //| DATA
        //| ==============================================================


        string filename_data {
            get
            {
                return $"Payback/Payback.dat";
            }
        }


        DynamicConfigFile file_payback_data;

        public PaybackData paybackData = new PaybackData();

        public class PaybackData
        {
            public float percent_butterfingers_dropchance = 0.3f;
            public HashSet<ulong> bancheck_exceptions = new HashSet<ulong>();
        }

        void Unload()
        {
            //Puts("Unload Tommygun's Payback");

            Worker.GetSingleton()?.StopAllCoroutines();
            GameObject.Destroy(Worker.GetSingleton());

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                UI2.ClearUI(player);
            }

            SaveData();
        }



        private void SaveData()
        {
            //| WRITE SERVER FILE
            file_payback_data.WriteObject(paybackData);
        }
        private void LoadData()
        {
            //Puts("Load Data");

            ReadDataIntoDynamicConfigFiles();
            LoadFromDynamicConfigFiles();
        }
        void ReadDataIntoDynamicConfigFiles()
        {
            file_payback_data = Interface.Oxide.DataFileSystem.GetFile(filename_data);
        }
        void LoadFromDynamicConfigFiles()
        {
            try
            {
                paybackData = file_payback_data.ReadObject<PaybackData>();
            }
            catch (Exception e)
            {
                paybackData = new PaybackData();
                //Puts($"Creating new data {e}");
            }

        }


        public const string permission_admin = "payback.admin";

        public bool IsAdmin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.Connection.userid.ToString(), permission_admin))
            {
                return true;
            }
            return false;
        }


        //| ==============================================================
        //| UTILITIES
        //| ==============================================================
        void SetDespawnDuration(DroppedItem dropped, float seconds)
        {
            dropped.Invoke(new Action(dropped.IdleDestroy), seconds);//prevent dropped item from despawn
        }
        void DestroyGroundCheck(BaseEntity entity)
        {
            GameObject.DestroyImmediate(entity.GetComponentInChildren<DestroyOnGroundMissing>());
            GameObject.DestroyImmediate(entity.GetComponentInChildren<GroundWatch>());
        }

        [ChatCommand("sound")]
        void SoundCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!IsAdmin(player)) return;

            if (args.Length == 0)
            {
                SendReply(player, "/sound <asset>");
                return;
            }
            for (int i = 0; i < args.Length; i++)
            {
                string sound = args[i];
                PlaySound(sound, player, false);
            }
        }

        void PrintToPlayer(BasePlayer player, string text)
        {
            if (player == null)
            {
                Puts($"{text}");
                return;
            }
            //SendReply(player, text);
            player.SendConsoleCommand($"echo {text}");
        }
        public HashSet<ulong> GetPlayerTeam(ulong userID)
        {
            BasePlayer player = BasePlayer.FindByID(userID);

            RelationshipManager.PlayerTeam existingTeam = RelationshipManager.ServerInstance.FindPlayersTeam(player.userID);
            if (existingTeam != null)
            {
                return new HashSet<ulong>(existingTeam.members);
            }
            return new HashSet<ulong>() { userID };
        }

        public void PlaySound(List<string> effects, BasePlayer player, Vector3 worldPosition, bool playlocal = true)
        {
            if (player == null) return;//ai
            foreach (var effect in effects)
            {
                //var sound = new Effect(effect, player, 0, localPosition, localPosition.normalized);
                var sound = new Effect(effect, worldPosition, Vector3.up);
                if (playlocal)
                {
                    EffectNetwork.Send(sound, player.net.connection);
                }
                else
                {
                    EffectNetwork.Send(sound);
                }
            }
        }

        public void PlaySound(List<string> effects, BasePlayer player, bool playlocal = true)
        {
            if (player == null) return;//ai
            foreach (var effect in effects)
            {
                var sound = new Effect(effect, player, 0, Vector3.zero + Vector3.up * 0.5f, Vector3.forward);
                if (playlocal)
                {
                    EffectNetwork.Send(sound, player.net.connection);
                }
                else
                {
                    EffectNetwork.Send(sound);
                }
            }
        }
        public void PlaySound(string effect, ListHashSet<BasePlayer> players, bool playlocal = true)
        {
            //all players
            foreach (var player in players)
            {
                PlaySound(effect, player, playlocal);
            }
        }

        bool test = false;

        public void PlaySound(string effect, BasePlayer player, bool playlocal = true, Vector3 posLocal = default(Vector3))
        {
            if (player == null) return;//ai

            var sound = new Effect(effect, player, 0, Vector3.zero, Vector3.forward);

            if (posLocal != Vector3.zero)
            {
                sound = new Effect(effect, player.transform.position + posLocal, Vector3.forward);
            }


            if (playlocal)
            {
                EffectNetwork.Send(sound, player.net.connection);
            }
            else
            {
                EffectNetwork.Send(sound);
            }
        }

        //[ChatCommand("gesture")]
        //void CommandGesture(BasePlayer player)
        //{
        //    if (!IsAdmin(player)) return;
        //    //foreach (var g in player.gestureList.AllGestures)
        //    //{
        //    //    PrintToChat($"{g.convarName} - {g.gestureCommand} - {g.gestureName} : {g.gestureId}");
        //    //}
        //    PlayGesture(player, "friendly");
        //}
        public void PlayGesture(BasePlayer target, string gestureName, bool canCancel = false)
        {
            if (target == null) return;
            if (target.gestureList == null) return;
            var gesture = target.gestureList.StringToGesture(gestureName);
            if (gesture == null)
            {
                return;
            }
            bool saveCanCancel = gesture.canCancel;
            gesture.canCancel = canCancel;
            target.SendMessage("Server_StartGesture", gesture);
            gesture.canCancel = saveCanCancel;
        }

        public class Worker : MonoBehaviour
        {
            public static Worker GetSingleton()
            {
                if (_singleton == null)
                {
                    GameObject worker = new GameObject();
                    worker.name = "Worker Singleton";
                    _singleton = worker.AddComponent<Worker>();
                }
                return _singleton;
            }
            static Worker _singleton;
            public static Coroutine StaticStartCoroutine(IEnumerator c)
            {
                return Worker.GetSingleton().StartCoroutine(c);
            }

        }




        #region Config

        private void Init()
        {
            LoadConfig();
        }

        private PluginConfig config;

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {

            };
            SaveConfig();
        }

        private class PluginConfig
        {
            [JsonProperty("Check temporary game bans and notify via Discord Webhook")]
            public bool enabled_nexus_gamebancheck = true;

            [JsonProperty("Only report temp bans younger than days")]
            public int nexus_ban_days = 60;

            [JsonProperty("Notify Game Ban + Team")]
            public bool notify_game_ban = true;

            [JsonProperty("Only notify ban if has team")]
            public bool notify_only_if_has_team = false;

            [JsonProperty("Include bm links in ban notification")]
            public bool notify_ban_include_bm = false;

            [JsonProperty("These discord webhooks will get notified")]
            public List<string> webhooks = new List<string>();

            [JsonProperty("notify player being attacked by cheater")]
            public bool notifyCheaterAttacking = true;
        }

        #endregion Config

        //| ===================

        //| =======================================
        //| TOMMYGUN'S PROPRIETARY UI CLASSES
        //| =======================================
        //| 
        //| Code contained below this line is not licensed to be used, copied, or modified.
        //| 
        //| 
        //| =======================================

        //| ===================



        public class UI2
        {
            public static Vector4 vectorFullscreen = new Vector4(0, 0, 1, 1);

            public static string ColorText(string input, string color)
            {
                return "<color=" + color + ">" + input + "</color>";
            }

            public static void ClearUI(BasePlayer player)
            {
                foreach (var guid in UI2.guids)
                {
                    CuiHelper.DestroyUi(player, guid);
                }
            }

            //| =============================
            //| DIRT 
            //| =============================
            public static Dictionary<ulong, HashSet<string>> dirtyMap = new Dictionary<ulong, HashSet<string>>();
            public static HashSet<string> GetDirtyBitsForPlayer(BasePlayer player)
            {
                if (player == null) return new HashSet<string>();
                if (!dirtyMap.ContainsKey(player.userID))
                {
                    dirtyMap[player.userID] = new HashSet<string>();
                }
                return dirtyMap[player.userID];
            }

            //| =============================
            //| LAYOUT 
            //| =============================

            public class Layout
            {

                public Vector2 startPosition;

                public Vector4 cellBounds;
                public Vector2 padding;
                public Vector4 cursor;
                public int maxRows;

                public int row = 0;
                public int col = 0;

                public void Init(Vector2 _startPosition, Vector4 _cellBounds, int _maxRows, Vector2 _padding = default(Vector2))
                {
                    startPosition = _startPosition;
                    cellBounds = _cellBounds;
                    maxRows = _maxRows;
                    padding = _padding;
                    row = 0;
                    col = 0;
                }

                public void NextCell(System.Action<Vector4, int, int> populateAction)
                {
                    float cellX = startPosition.x + (col * (cellBounds.z + padding.x)) + padding.x / 2f;
                    float cellY = startPosition.y - (row * (cellBounds.w + padding.y)) - cellBounds.w - padding.y;

                    cursor = new Vector4(cellX, cellY, cellX, cellY);

                    populateAction(cursor, row, col);

                    //move to next element
                    row++;
                    if (row == maxRows)
                    {
                        row = 0;
                        col++;
                    }

                }

                public void Reset()
                {
                    row = 0;
                    col = 0;
                }
            }



            //| =============================
            //| COLOR FUNCTIONS
            //| =============================

            public static string ColorToHex(Color color)
            {
                return ColorUtility.ToHtmlStringRGB(color);
            }
            public static string HexToRGBAString(string hex)
            {
                Color color = Color.white;
                ColorUtility.TryParseHtmlString("#" + hex, out color);
                string c = $"{String.Format("{0:0.000}", color.r)} {String.Format("{0:0.000}", color.g)} {String.Format("{0:0.000}", color.b)} {String.Format("{0:0.000}", color.a)}";
                return c;
            }


            //| =============================
            //| RECT FUNCTIONS
            //| =============================
            public static Vector4 GetOffsetVector4(Vector2 offset)
            {
                return new Vector4(offset.x, offset.y, offset.x, offset.y);
            }
            public static Vector4 GetOffsetVector4(float x, float y)
            {
                return new Vector4(x, y, x, y);
            }

            public static Vector4 SubtractPadding(Vector4 input, float padding)
            {
                float verticalPadding = GetSquareFromWidth(padding);
                return new Vector4(input.x + padding / 2f, verticalPadding / 2f, input.z - padding / 2f, input.w - verticalPadding / 2f);
            }

            public static float GetSquareFromWidth(float width, float aspect = 16f / 9f)
            {
                //return width * 1f / aspect;
                return width * aspect;
            }
            public static float GetSquareFromHeight(float height, float aspect = 16f / 9f)
            {
                //return height * aspect;
                return height * 1f / aspect;
            }

            //specify the screen-space x1, x2, y1 and it will populate y2
            public static Vector4 MakeSquareFromWidth(Vector4 bounds, float aspect = 16f / 9f)
            {
                return new Vector4(bounds.x, bounds.y, bounds.z, bounds.y + GetSquareFromWidth(bounds.z - bounds.x));
            }
            //specify the screen-space x1, y1, and y2 and it will populate the x2
            public static Vector4 MakeSquareFromHeight(Vector4 bounds, float aspect = 16f / 9f)
            {
                return new Vector4(bounds.x, bounds.y, bounds.x + GetSquareFromHeight(bounds.z - bounds.y), bounds.w);
            }
            //make any sized rect from x1, x2, and y1
            public static Vector4 MakeRectFromWidth(Vector4 bounds, float ratio, float aspect = 16f / 9f)
            {
                Vector4 square = MakeSquareFromWidth(bounds, aspect);
                return new Vector4(square.x, square.y, square.z, square.y + (square.w - square.y) * ratio);
            }
            //make any sized rect from y1, y2 and x1
            public static Vector4 MakeRectFromHeight(Vector4 bounds, float ratio, float aspect = 16f / 9f)
            {
                Vector4 square = MakeSquareFromHeight(bounds, aspect);
                return new Vector4(square.x, square.y, square.x + (square.z - square.x) * ratio, square.w);
            }


            //| =============================
            //| UI PANELS
            //| =============================
            public static HashSet<string> guids = new HashSet<string>();

            public static string GetMinUI(Vector4 panelPosition)
            {
                return panelPosition.x.ToString("0.####") + " " + panelPosition.y.ToString("0.####");
            }
            public static string GetMaxUI(Vector4 panelPosition)
            {
                return panelPosition.z.ToString("0.####") + " " + panelPosition.w.ToString("0.####");
            }
            public static string GetColorString(Vector4 color)
            {
                return color.x.ToString("0.####") + " " + color.y.ToString("0.####") + " " + color.z.ToString("0.####") + " " + color.w.ToString("0.####");
            }
            public static CuiElement CreateInputField(CuiElementContainer container, string parent, string panelName, string message, int textSize, string color, Vector4 bounds, string command)
            {

                CuiElement element = new CuiElement
                {
                    Name = panelName,
                    Parent = parent,
                    Components = {
                        new CuiInputFieldComponent {
                            Align = TextAnchor.MiddleLeft,
                            Color = color,
                            Command = command,
							//Text = message,
							FontSize = textSize,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = GetMinUI(bounds),
                            AnchorMax = GetMaxUI(bounds),
                        }
                    }
                };
                container.Add(element
                );

                return element;
            }

            public static void CreateOutlineLabel(CuiElementContainer container, string parent, string panelName, string message, string color, int size, Vector4 bounds, TextAnchor textAlignment = TextAnchor.MiddleCenter, float fadeOut = 0, float fadeIn = 0, string outlineColor = "0 0 0 0.8", string outlineDistance = "0.7 -0.7")
            {

                container.Add(new CuiElement
                {
                    Name = panelName,
                    Parent = parent,
                    FadeOut = fadeOut,
                    Components = {

                        new CuiTextComponent {
                            Align = textAlignment,
                            Color = color,
                            FadeIn = fadeIn,
                            FontSize = size,
                            Text = message
                        },
                        new CuiOutlineComponent {
                            Color = outlineColor,
                            Distance = outlineDistance,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = GetMinUI(bounds),
                            AnchorMax = GetMaxUI(bounds),
                        }
                    }
                });
            }

            public static void CreateLabel(CuiElementContainer container, string parent, string panelName, string message, string color, int size, string aMin, string aMax, TextAnchor textAlignment = TextAnchor.MiddleCenter, float fadeIn = 0, float fadeOut = 0)
            {


                CuiLabel label = new CuiLabel();
                label.Text.Text = message;
                label.RectTransform.AnchorMin = aMin;
                label.RectTransform.AnchorMax = aMax;
                label.Text.Align = textAlignment;
                label.Text.Color = color;
                label.Text.FontSize = size;
                label.Text.FadeIn = fadeIn;
                label.FadeOut = fadeOut;

                container.Add(label, parent, panelName);

            }
            public static CuiButton CreateButton(CuiElementContainer container, string parent, string panelName, string color, string text, int size, Vector4 bounds, string command, TextAnchor align = TextAnchor.MiddleCenter, string textColor = "1 1 1 1")
            {

                container.Add(new CuiElement
                {
                    Name = panelName,
                    Parent = parent,
                    Components = {


                            new CuiButtonComponent {
                                Color = color,
                                Command = command,
                            },

                            new CuiRectTransformComponent
                            {
                                AnchorMin = GetMinUI(bounds),
                                AnchorMax = GetMaxUI(bounds),
                            }
                        }
                });

                CreateOutlineLabel(container, panelName, "text", text, textColor, size, new Vector4(0, 0, 1, 1), align);

                return null;

            }


            public static CuiPanel CreatePanel(CuiElementContainer container, string parent, string panelName, string color, Vector4 bounds, string imageUrl = "", bool cursor = false, float fadeOut = 0, float fadeIn = 0, bool png = false, bool blur = false, bool outline = true)
            {

                if (!string.IsNullOrEmpty(imageUrl))
                {
                    //hack to get images working
                    if (png)
                    {
                        if (outline)
                        {
                            container.Add(new CuiElement
                            {
                                Name = panelName,
                                Parent = parent,
                                FadeOut = fadeOut,
                                Components = {
																
								//new CuiRawImageComponent { Color = "0 0 0 0.5", Sprite = "assets/content/materials/highlight.png", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },

								new CuiRawImageComponent
                                {
                                    Color = color,
                                    Png = imageUrl,
                                    FadeIn = fadeIn
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = GetMinUI(bounds),
                                    AnchorMax = GetMaxUI(bounds),
                                },
                                new CuiOutlineComponent {
                                    Color = "0 0 0 0.9",
                                    Distance = "0.7 -0.7",
                                },
                            }
                            });
                        }
                        else
                        {
                            container.Add(new CuiElement
                            {
                                Name = panelName,
                                Parent = parent,
                                FadeOut = fadeOut,
                                Components = {
																
								//new CuiRawImageComponent { Color = "0 0 0 0.5", Sprite = "assets/content/materials/highlight.png", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },

								new CuiRawImageComponent
                                {
                                    Color = color,
                                    Png = imageUrl,
                                    FadeIn = fadeIn
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = GetMinUI(bounds),
                                    AnchorMax = GetMaxUI(bounds),
                                }
                            }
                            });
                        }


                    }
                    else
                    {
                        container.Add(new CuiElement
                        {
                            Name = panelName,
                            Parent = parent,
                            FadeOut = fadeOut,
                            Components = {


                                new CuiRawImageComponent
                                {
                                    Color = color,
                                    Url = imageUrl,
                                    FadeIn = fadeIn
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = GetMinUI(bounds),
                                    AnchorMax = GetMaxUI(bounds),
                                }
                            }
                        });
                    }


                    return null;

                }
                else
                {

                    if (blur)
                    {

                        //BLURS
                        //assets/content/ui/uibackgroundblur-ingamemenu.mat
                        //assets/content/ui/uibackgroundblur-notice.mat
                        //assets/content/ui/uibackgroundblur.mat
                        // dirty bg blur, can't stretch large
                        string mat = "assets/content/ui/uibackgroundblur-ingamemenu.mat";// MEDIUM BLURRY 
                                                                                         //string mat = "assets/content/ui/uibackgroundblur.mat";//VERY BLURRY

                        //string sprite = "assets/content/ui/ui.white.tga";//kind of boxy outline
                        //string sprite = "assets/content/ui/ui.white.tga";//


                        container.Add(new CuiElement
                        {
                            Name = panelName,
                            Parent = parent,
                            FadeOut = fadeOut,
                            Components = {
                                    new CuiImageComponent {
                                        Color = color,
                                        Material = mat,
                                        FadeIn = fadeIn
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = GetMinUI(bounds),
                                        AnchorMax = GetMaxUI(bounds),
                                    }
                                }
                        });

                    }
                    else
                    {

                        CuiPanel element = new CuiPanel();
                        element.RectTransform.AnchorMin = GetMinUI(bounds);
                        element.RectTransform.AnchorMax = GetMaxUI(bounds);
                        //element.FadeOut = 1f;
                        element.Image.Color = color;
                        element.CursorEnabled = cursor;
                        element.Image.FadeIn = fadeIn;
                        element.FadeOut = fadeOut;

                        container.Add(element, parent, panelName);
                        return element;

                    }

                    return null;

                }

            }

        }


    }
}


// --- End of file: Payback.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagicTree.cs ---
// --- Original Local Path: MagicTree.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("MagiсTree", "OxideBro", "1.0.1")]
    public class MagicTree : RustPlugin
    {
        #region Configuration

        public class Seed
        {
            public string shortname;
            public string name;
            public ulong skinId;
        }

        public class Wood
        {
            [JsonProperty("UID Дерева")]
            public uint woodId;
            [JsonProperty("Осталось времени")]
            public int NeedTime;
            [JsonProperty("Этап")]
            public int CurrentStage;
            [JsonProperty("Позиция")]
            public Vector3 woodPos;
            [JsonProperty("Ящики")]
            public Dictionary<uint, BoxItemsList> BoxListed = new Dictionary<uint, BoxItemsList>();
        }

        public class BoxItemsList
        {
            [JsonProperty("Shortname предмета")]
            public string ShortName;
            [JsonProperty("Минимальное количество")]
            public int MinAmount;
            [JsonProperty("Максимальное количество")]
            public int MaxAmount;
            [JsonProperty("Шанс что предмет будет добавлен (максимально 100%)")]
            public int Change;
            [JsonProperty("SkinID предмета")]
            public ulong SkinID;
            [JsonProperty("Имя предмета при создании (Оставьте поле пустым чтобы использовать стандартное название итема)")]
            public string Name;
            [JsonProperty("Это чертеж")]
            public bool IsBlueprnt;
            [JsonIgnore] public BaseEntity box;
        }


        public Dictionary<ulong, Dictionary<uint, Wood>> WoodsList = new Dictionary<ulong, Dictionary<uint, Wood>>();

        public Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"CmdError", "Неправильно ввели команду." },
            {"CountError", "Неверное кол-во!" },
            {"Permission", "У вас нет прав!" },
            {"SeedGived", "Вам выпала семечка магического дерева!\nПосадите ее и у вас выростет необычное дерево на каком растут ящики с ценными предметами!" },
            {"Wood", "Вы посадили магическое дерево\nСкоро оно вырастет, и даст плоды!" },
            {"InfoTextFull",  "<size=25><b>Магическое дерево</b></size>\n<size=17>\nПЛОДЫ ДОЗРЕЛИ, ВЫ МОЖЕТЕ ИХ СОБРАТЬ</size>"},
            {"InfoDdraw", "<size=25><b>Магическое дерево</b></size>\n<size=17>Этап созревания дерева: {0}/{1}\n\nВремя до полного созревания: {2}</size>" }
        };

        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина на сайте RustPlugin.ru. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Время роста дерева в секундах")]
            public int Time;

            [JsonProperty("Количество вещей в ящике")]
            public int ItemsCount;

            [JsonProperty("Кол-во ящиков на дереве")]
            public int BoxCount;

            [JsonProperty("Список префабов этапов дерева")]
            public List<string> Stages;

            [JsonProperty("Права на выдачу")]
            public string Permission = "seed.perm";

            [JsonProperty("Тип ящика")]
            public string CrateBasic = "assets/bundled/prefabs/radtown/crate_basic.prefab";

            [JsonProperty("Шанс выпадения зерна с дерева (макс-100)")]
            public int Chance;

            [JsonProperty("Настройка лута в ящиках")]
            public List<BoxItemsList> casesItems;
            [JsonProperty("Ссылка на удачный эффект")]
            public string SucEffect;
            [JsonProperty("Ссылка на эффект ошибки")]
            public string ErrorEffect;
            [JsonProperty("Настройка зерна")]
            public Seed seed;
            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    PluginVersion = new VersionNumber(),
                    ItemsCount = 2,
                    Permission = "MagicTree.perm",
                    CrateBasic = "assets/bundled/prefabs/radtown/crate_underwater_basic.prefab",
                    BoxCount = 4,
                    Chance = 5,
                    Time = 10,
                    seed = new Seed()
                    {
                        shortname = "seed.hemp",
                        name = "Семена магического дерева",
                        skinId = 1787823357
                    },
                    casesItems = new List<BoxItemsList>()
                {
                new BoxItemsList
                {
                ShortName = "stones",
                MinAmount = 300,
                MaxAmount = 1000,
                Change = 100,
                Name = "",
                SkinID = 0,
                IsBlueprnt = false
                },
                },
                    SucEffect = "assets/prefabs/misc/xmas/candy cane club/effects/hit.prefab",
                    ErrorEffect = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab",
                    Stages = new List<string>()
                    {
                      "assets/prefabs/plants/hemp/hemp.entity.prefab",
                      "assets/bundled/prefabs/autospawn/resource/v2_tundra_forest_small/american_beech_e_dead.prefab",
                      "assets/bundled/prefabs/autospawn/resource/v2_tundra_forest_small/american_beech_d_dead.prefab",
                      "assets/bundled/prefabs/autospawn/resource/v2_tundra_forest_small/oak_a_tundra.prefab",
                      "assets/bundled/prefabs/autospawn/resource/v2_tundra_forest/oak_b_tundra.prefab"
                    },
                };
            }
        }
        #endregion

        #region Oxide

        void LoadData()
        {
            try
            {
                WoodsList = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<uint, Wood>>>($"{Title}_Players");
                if (WoodsList == null)
                    WoodsList = new Dictionary<ulong, Dictionary<uint, Wood>>();
            }
            catch
            {
                WoodsList = new Dictionary<ulong, Dictionary<uint, Wood>>();
            }
        }

        void SaveData()
        {
            if (WoodsList != null)
                Interface.Oxide.DataFileSystem.WriteObject($"{Title}_Players", WoodsList);
        }

        public static MagicTree ins;

        void OnEntityKill(BaseNetworkable entity)
        {
            try
            {
                if (entity == null || entity?.net.ID == null) return;
                if (entity.GetComponent<TreeEntity>() != null && entity.GetComponent<TreeConponent>() != null)
                {
                    var tree = entity.GetComponent<TreeEntity>();
                    if (WoodsList.ContainsKey(tree.OwnerID) && WoodsList[tree.OwnerID].ContainsKey(tree.net.ID))
                        WoodsList[tree.OwnerID].Remove(tree.net.ID);
                }
            }
            catch (NullReferenceException)
            {
            }

        }


        private void OnServerInitialized()
        {
            ins = this;
            permission.RegisterPermission(config.Permission, this);
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            LoadData();

            var plants = GameObject.FindObjectsOfType<PlantEntity>();
            if (plants != null)
                plants.ToList().ForEach(plant =>
                {
                    if (plant.skinID == config.seed.skinId)
                        AddOrRemoveComponent("add", null, plant, plant.OwnerID);
                });

            var treeList = GameObject.FindObjectsOfType<TreeEntity>();
            if (treeList != null)
                treeList.ToList().ForEach(tree =>
                {
                    AddOrRemoveComponent("add", null, tree, tree.OwnerID);
                });
        }

        void AddOrRemoveComponent(string type, TreeConponent component, BaseEntity tree = null, ulong playerid = 1)
        {
            if (!WoodsList.ContainsKey(playerid)) return;
            switch (type)
            {
                case "add":
                    var data = WoodsList[playerid][tree.net.ID];
                    if (tree != null && data != null)
                    {
                        if (WoodsList[playerid][tree.net.ID].CurrentStage > 2 && WoodsList[playerid][tree.net.ID].BoxListed.Count > 0)
                        {
                            if (tree.GetComponent<TreeConponent>() == null)
                            {
                                tree.gameObject.AddComponent<TreeConponent>().Init(WoodsList[playerid][tree.net.ID]);
                                SpawnBox(data, WoodsList[playerid][tree.net.ID].BoxListed.Count, tree.GetComponent<TreeConponent>().tree, playerid, WoodsList[playerid][tree.net.ID].BoxListed.Count);
                            }
                            return;
                        }
                        else
                            if (tree.GetComponent<TreeConponent>() == null)
                            tree.gameObject.AddComponent<TreeConponent>().Init(WoodsList[playerid][tree.net.ID]);
                    }
                    break;
                case "remove":
                    if (WoodsList[playerid][component.tree.net.ID].BoxListed.Count > 0)
                    {
                        foreach (var ent in WoodsList[playerid][component.tree.net.ID].BoxListed)
                        {
                            if (ent.Value.box != null && !ent.Value.box.IsDestroyed)
                            {
                                ent.Value.box.Kill();
                            }
                        }
                        if (component != null)
                            component.DestroyComponent();
                    }
                    else
                    {
                        if (component != null)
                            component.DestroyComponent();
                    }
                    break;
            }
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject, Vector3 Pos)
        {
            if (planner == null || gameobject == null) return;
            var player = planner.GetOwnerPlayer();
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (entity.skinID == config.seed.skinId)
            {
                SpawnWood(planner.GetOwnerPlayer().userID, entity.transform.position, null, entity);
                SendReply(player, string.Format(Messages["Wood"]));
            }
        }

        object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenser == null || player == null || item == null) return null;
            switch (item.info.shortname)
            {
                case "wood":
                    if (UnityEngine.Random.Range(0f, 100f) < config.Chance)
                    {
                        var activeitem = player.GetActiveItem();
                        if (activeitem != null && !activeitem.info.shortname.Contains("chainsaw"))
                            AddSeed(player, 1);
                    }
                    TreeEntity wood1 = dispenser.GetComponentInParent<TreeEntity>();
                    if (wood1 != null && wood1.GetComponent<TreeConponent>() != null)
                        item.amount = item.amount * 20;
                    break;
            }
            return null;
        }

        object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (dispenser == null || item == null) return null;
            BasePlayer player = entity?.ToPlayer();
            if (player == null) return null;
            switch (item.info.shortname)
            {
                case "wood":
                    TreeEntity wood1 = dispenser.GetComponentInParent<TreeEntity>();
                    if (wood1 != null && wood1.GetComponent<TreeConponent>() != null)
                    {
                        var component = wood1.GetComponent<TreeConponent>();
                        if (component.data.BoxListed.Count > 0 && component.data.BoxListed.Count < 5)
                        {
                            var box = component.data.BoxListed.ToList().GetRandom();

                            if (box.Value.box != null && component.data.CurrentStage == config.Stages.Count)
                            {
                                box.Value.box.SetFlag(BaseEntity.Flags.Busy, false, true);
                                Rigidbody rb = box.Value.box.GetComponent<Rigidbody>();
                                if (rb != null)
                                {
                                    rb.isKinematic = false;
                                    rb.useGravity = true;
                                    rb.WakeUp();
                                    box.Value.box.SendNetworkUpdate();
                                }
                                box.Value.box.SendNetworkUpdateImmediate();
                                component.data.BoxListed.Remove(box.Key);
                            }
                            return false;
                        }
                        else if (component.data.BoxListed.Count > 5 && component.data.CurrentStage == config.Stages.Count)
                        {
                            foreach (var box in component.data.BoxListed)
                            {
                                if (box.Value.box != null)
                                {
                                    box.Value.box.SetFlag(BaseEntity.Flags.Busy, false, true);
                                    Rigidbody rb = box.Value.box.GetComponent<Rigidbody>();
                                    if (rb != null)
                                    {
                                        rb.isKinematic = false;
                                        rb.useGravity = true;
                                        rb.WakeUp();
                                        box.Value.box.SendNetworkUpdateImmediate();
                                    }
                                }
                            }

                            component.data.BoxListed.Clear();
                            return false;
                        }
                        else
                        {
                            if (component.data.CurrentStage == config.Stages.Count)
                            {
                                dispenser.AssignFinishBonus(player, 1);
                                HitInfo hitInfo = new global::HitInfo(player, wood1, Rust.DamageType.Generic, wood1.Health(), wood1.transform.position);
                                wood1.OnAttacked(hitInfo);
                                return false;

                            }

                        }
                    }
                    break;
            }
            return null;
        }

        void Unload()
        {
            var AllTree = GameObject.FindObjectsOfType<TreeConponent>();
            if (AllTree != null)
                AllTree.ToList().ForEach(tree =>
                {
                    AddOrRemoveComponent("remove", tree, tree.tree,tree.tree.OwnerID);
                });
            SaveData();
        }

        #endregion

        #region MyMethods

        public void SpawnWood(ulong player, Vector3 pos, BaseEntity tree, BaseEntity seed)
        {
            if (tree == null)
            {
                if (!WoodsList.ContainsKey(player))

                    WoodsList.Add(player, new Dictionary<uint, Wood>()
                    {
                        [seed.net.ID] = new Wood() { woodId = seed.net.ID, CurrentStage = 0, NeedTime = config.Time / config.Stages.Count, woodPos = seed.transform.position }
                    });

                else
                    WoodsList[player].Add(seed.net.ID, new Wood() { woodId = seed.net.ID, CurrentStage = 0, NeedTime = config.Time / config.Stages.Count, woodPos = seed.transform.position });
                seed.gameObject.AddComponent<TreeConponent>()?.Init(WoodsList[player][seed.net.ID]);
            }
            else
            {
                if (tree == null) return;
                var old = WoodsList[player][tree.net.ID];
                var current = ++old.CurrentStage;
                TreeEntity Wood = GameManager.server.CreateEntity(config.Stages[current], pos) as TreeEntity;
                WoodsList[player].Remove(tree.net.ID);
                Wood.Spawn();
                Wood.GetComponent<TreeEntity>().OwnerID = player;
                WoodsList[player].Add(Wood.net.ID, new Wood() { woodId = Wood.net.ID, CurrentStage = current, NeedTime = config.Time / config.Stages.Count, woodPos = Wood.transform.position });
                Wood.gameObject.AddComponent<TreeConponent>()?.Init(WoodsList[player][Wood.net.ID]);
                Wood.SendNetworkUpdateImmediate();
                tree.Kill();
            }
        }


        [ChatCommand("seed")]
        void GiveSeed(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, config.Permission))
            {
                if (args.Length == 1)
                {
                    int amount;
                    if (!int.TryParse(args[0], out amount))
                    {
                        SendReply(player, "Вы не указали количество, используйте /seed AMOUNT");

                        return;
                    }
                    AddSeed(player, amount);
                    return;
                }
                if (args.Length > 0 && args.Length == 2)
                {
                    var target = BasePlayer.Find(args[0]);
                    if (target == null)
                    {
                        SendReply(player, "Данный игрок не найден, попробуйте уточнить имя или SteamID, используйте /seed TARGETNAME/ID AMOUNT");
                        return;
                    }

                    int amount;
                    if (!int.TryParse(args[1], out amount))
                    {
                        SendReply(player, "Вы не указали количество, используйте /seed TARGETNAME/ID AMOUNT");
                        return;
                    }
                    AddSeed(target, amount);
                }
            }
            else
            {
                SendReply(player, string.Format(Messages["Permission"]));
                Effect.server.Run(config.ErrorEffect, player, 0, Vector3.zero, Vector3.forward);
            }
        }

        void AddSeed(BasePlayer player, int amount)
        {
            if (player == null) return;
            Item sd = ItemManager.CreateByName(config.seed.shortname, amount, config.seed.skinId);
            sd.name = config.seed.name;
            player.GiveItem(sd, BaseEntity.GiveItemReason.Crafted);
            SendReply(player, string.Format(Messages["SeedGived"]));
            Effect.server.Run(config.SucEffect, player, 0, Vector3.zero, Vector3.forward);
        }

        public void SpawnBox(Wood wood, int i, BaseEntity tree, ulong ownerID, int countBox = 0)
        {
            if (wood == null) return;
            if (wood != null)
            {
                wood.BoxListed.Clear();
                if (countBox == 0) countBox = config.BoxCount;
                for (int count = 0; count < countBox; count++)
                {
                    Vector3 pos = new Vector3(UnityEngine.Random.Range(-9, 9), UnityEngine.Random.Range(5f, 9.0f), UnityEngine.Random.Range(-9, 9));
                    BaseEntity boxed = GameManager.server.CreateEntity(config.CrateBasic, wood.woodPos + pos);
                    boxed.GetComponent<LootContainer>().initialLootSpawn = false;
                    boxed.Spawn();
                    AddLoot(boxed);
                    boxed.SetFlag(BaseEntity.Flags.Reserved8, false, true);
                    boxed.SetFlag(BaseEntity.Flags.Busy, true, true);
                    boxed.SendNetworkUpdateImmediate();
                    wood.BoxListed.Add(boxed.net.ID, new BoxItemsList() { box = boxed });
                    var reply = 1;
                    if (reply == 0) { }
                }
            }
        }

        public void AddLoot(BaseEntity box)
        {
            if (box == null) return;
            int count = 0;
            LootContainer container = box.GetComponent<LootContainer>();
            if (container == null) return;
            container.inventory.itemList.Clear();

            foreach (var item in config.casesItems)
            {
                if (UnityEngine.Random.Range(0, 100) > item.Change) continue;
                if (count >= config.ItemsCount) break;
                var amount = UnityEngine.Random.Range(item.MinAmount, item.MaxAmount);

                var newItem = item.IsBlueprnt ? ItemManager.CreateByName("blueprintbase") : ItemManager.CreateByName(item.ShortName, amount, item.SkinID);
                if (newItem == null)
                {
                    PrintError($"Предмет {item.ShortName} не найден!");
                    return;
                }

                if (item.IsBlueprnt)
                {
                    var bpItemDef = ItemManager.FindItemDefinition(ItemManager.CreateByName(item.ShortName, amount, item.SkinID).info.itemid);
                    if (bpItemDef == null)
                    {
                        PrintError($"Предмет {item.ShortName} для создания чертежа не найден!");
                        return;
                    }
                    newItem.blueprintTarget = bpItemDef.itemid;
                }

                if (!string.IsNullOrEmpty(item.Name))
                    newItem.name = item.Name;

                if (container.inventory.IsFull())
                    container.inventory.capacity++;
                newItem.MoveToContainer(container.inventory, -1);
                count++;
            }
        }

        class TreeConponent : BaseEntity
        {
            public Dictionary<BasePlayer, bool> ColliderPlayersList = new Dictionary<BasePlayer, bool>();
            public BaseEntity tree;
            SphereCollider sphereCollider;

            public Wood data;

            void Awake()
            {
                tree = gameObject.GetComponent<BaseEntity>();
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Rust.Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = 4