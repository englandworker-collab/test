f;
                InvokeRepeating(DrawInfo, 1f, 1);
            }

            public void Init(Wood wood)
            {
                data = wood;
            }

            private void OnTriggerEnter(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target != null && !ColliderPlayersList.ContainsKey(target))
                    ColliderPlayersList.Add(target, !target.IsAdmin);
            }

            private void OnTriggerExit(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target != null && ColliderPlayersList.ContainsKey(target))
                    ColliderPlayersList.Remove(target);
            }


            void DrawInfo()
            {
                if (data == null) return;
                if (data.NeedTime <= 0 && data.CurrentStage == ins.config.Stages.FindIndex(x => x == ins.config.Stages.Last()) && data.BoxListed.ToList().Count <= 0)
                {
                    ins.SpawnBox(data, 3, tree, tree.OwnerID);
                    CreateInfo(tree.OwnerID);
                    data.CurrentStage = ins.config.Stages.Count;
                }
                if (data.NeedTime <= 0 && data.CurrentStage < ins.config.Stages.FindIndex(x => x == ins.config.Stages.Last()))
                {
                    ins.SpawnWood(tree.OwnerID, tree.transform.position, tree, null);
                }
                foreach (var player in ColliderPlayersList)
                {
                    if (data.CurrentStage == ins.config.Stages.Count && data.BoxListed.ToList().Count > 0)
                    {
                        if (player.Value) SetPlayerFlag(player.Key, BasePlayer.PlayerFlags.IsAdmin, true);
                        player.Key.SendConsoleCommand("ddraw.text", 1.01f, Color.white, tree.transform.position + Vector3.up,ins.Messages["InfoTextFull"]);
                        continue;
                    }

                    if (data.NeedTime > 0)
                    {
                        if (player.Value) SetPlayerFlag(player.Key, BasePlayer.PlayerFlags.IsAdmin, true);
                        player.Key.SendConsoleCommand("ddraw.text", 1.01f, Color.white, tree.transform.position + Vector3.up, string.Format(ins.Messages["InfoDdraw"], data.CurrentStage + 1, ins.config.Stages.Count, FormatShortTime(TimeSpan.FromSeconds(data.NeedTime))));
                    }
                    if (player.Value) SetPlayerFlag(player.Key, BasePlayer.PlayerFlags.IsAdmin, false);
                }

                data.NeedTime--;
            }

            void SetPlayerFlag(BasePlayer player, BasePlayer.PlayerFlags f, bool b)
            {
                if (b)
                {
                    if (player.HasPlayerFlag(f)) return;
                    player.playerFlags |= f;
                }
                else
                {
                    if (!player.HasPlayerFlag(f)) return;
                    player.playerFlags &= ~f;
                }
                player.SendNetworkUpdateImmediate(false);
            }

            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;

                result += $"{time.Hours.ToString("00")}:";

                result += $"{time.Minutes.ToString("00")}:";

                result += $"{time.Seconds.ToString("00")}";

                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units} {form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units} {form2}";

                return $"{units} {form3}";
            }

            public void DestroyComponent() => DestroyImmediate(this);

            void OnDestroy()
            {
                if (data != null)
                    foreach (var box in data.BoxListed)
                    {
                        box.Value.box.SetFlag(BaseEntity.Flags.Busy, false, true);
                        Rigidbody rb = box.Value.box.GetComponent<Rigidbody>();
                        if (rb != null)
                        {
                            rb.isKinematic = false;
                            rb.useGravity = true;
                            rb.WakeUp();
                            box.Value.box.SendNetworkUpdateImmediate();
                        }
                    }
                Destroy(this);
            }
        }


        static void CreateInfo(ulong playeId)
        {
            var player = BasePlayer.FindByID(playeId);

            if (player != null)
            {
                CuiHelper.DestroyUi(player, "MagicTree");
                CuiElementContainer container = new CuiElementContainer();
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.3447913 0.112037", AnchorMax = "0.640625 0.15", OffsetMax = "0 0" },
                    Image = { Color = "1 1 1 0.2" }
                }, "Hud", "MagicTree");
                container.Add(new CuiLabel
                {
                    FadeOut = 2,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "ВАШЕ ДЕРЕВО СОЗРЕЛО, И ДАЛО ПЛОДЫ!", FontSize = 17, Align = TextAnchor.MiddleCenter, FadeIn = 2, Color = "1 1 1 0.8", Font = "robotocondensed-regular.ttf" }
                }, "MagicTree");

                CuiHelper.AddUi(player, container);

                ins.timer.Once(5f, () => { if (player != null) CuiHelper.DestroyUi(player, "MagicTree"); });
            }
        }
        #endregion
    }
}                                                                                                                                                                 

// --- End of file: MagicTree.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BypassQueue.cs ---
// --- Original Local Path: BypassQueue.cs ---

﻿using Network;

namespace Oxide.Plugins
{
    [Info("BypassQueue", "Nogrod", "1.0.1", ResourceId = 1855)]
    class BypassQueue : RustPlugin
    {
        private const string Perm = "bypassqueue.allow";

        void OnServerInitialized()
        {
            permission.RegisterPermission(Perm, this);
        }

        object CanBypassQueue(Connection connection)
        {
            if (permission.UserHasPermission(connection.userid.ToString(), Perm))
                return true;
            return null;
        }
    }
}


// --- End of file: BypassQueue.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CraftSystem.cs ---
// --- Original Local Path: CraftSystem.cs ---

﻿using System;
using System.Linq;
using System.Globalization;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CraftSystem", "Chibubrik", "1.2.0")]
    class CraftSystem : RustPlugin
    {
        #region Вар
        string Layer = "Craft_UI";
        string LayerCraftInfo = "CraftInfo_UI";

        [PluginReference] Plugin ImageLibrary;
        #endregion

        #region Класс
        public class CraftSettings
        {
            [JsonProperty("Включить крафт этого предмета?")] public bool Enable;
            [JsonProperty("Название")] public string Name;
            [JsonProperty("Ссылка на префаб")] public string Prefab;
            [JsonProperty("Короткое название предмета")] public string ShortName;
            [JsonProperty("Описание предмета")] public string Info;
            [JsonProperty("SkinID предмета")] public ulong SkinID;
            [JsonProperty("Кол-во предмета")] public int Amount;
            [JsonProperty("Какой верстак нужен для крафта (Если 0 то не нужен)")] public int LevelWorkBench;
            [JsonProperty("Ссылка на изображение")] public string Url;
            [JsonProperty("Список предметов для крафта")] public Dictionary<string, int> ItemsList;
        }
        #endregion

        #region Конфиг
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Список предметов")] public List<CraftSettings> craftSettings;
            public static Configuration GetNewCong()
            {
                return new Configuration
                {
                    craftSettings = new List<CraftSettings>
                    {
                        new CraftSettings
                        {
                            Enable = true,
                            Name = "ВЕРТОЛЁТ",
                            Prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                            ShortName = "electric.flasherlight",
                            Info = "Описание",
                            SkinID = 1663370375,
                            Amount = 1,
                            LevelWorkBench = 3,
                            Url = "https://imgur.com/Yp2WJl5.png",
                            ItemsList = new Dictionary<string, int>
                            {
                                ["wood"] = 100,
                                ["sulfur"] = 1000,
                                ["stones"] = 100,
                                ["metal.ore"] = 1000,
                                ["scrap"] = 100
                            }
                        },
                        new CraftSettings
                        {
                            Enable = true,
                            Name = "Переработчик",
                            Prefab = "assets/bundled/prefabs/static/recycler_static.prefab",
                            ShortName = "research.table",
                            Info = "Вы получите полноценный переработчик, который Вы сможете установить у себя\nдома.",
                            SkinID = 1789555932,
                            Amount = 1,
                            LevelWorkBench = 2,
                            Url = "https://i.imgur.com/xXL3d47.png",
                            ItemsList = new Dictionary<string, int>
                            {
                                ["wood"] = 100,
                                ["sulfur"] = 1000,
                                ["scrap"] = 100
                            }
                        },
                        new CraftSettings
                        {
                            Enable = true,
                            Name = "Военная лодка",
                            Prefab = "assets/content/vehicles/boats/rhib/rhib.prefab",
                            ShortName = "electric.sirenlight",
                            Info = "Описание",
                            SkinID = 1789555583,
                            Amount = 1,
                            LevelWorkBench = 2,
                            Url = "https://i.imgur.com/u5QgVGS.png",
                            ItemsList = new Dictionary<string, int>
                            {
                                ["wood"] = 100,
                                ["sulfur"] = 1000
                            }
                        },
                        new CraftSettings
                        {
                            Enable = true,
                            Name = "Деревянная лодка",
                            Prefab = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                            ShortName = "coffin.storage",
                            Info = "Описание",
                            SkinID = 1789554931,
                            Amount = 1,
                            LevelWorkBench = 2,
                            Url = "https://i.imgur.com/UGuYMkA.png",
                            ItemsList = new Dictionary<string, int>
                            {
                                ["wood"] = 100,
                                ["sulfur"] = 1000
                            }
                        },
                        new CraftSettings
                        {
                            Enable = true,
                            Name = "Воздушный шар",
                            Prefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab",
                            ShortName = "wall.graveyard.fence",
                            Info = "Описание",
                            SkinID = 1789557339,
                            Amount = 1,
                            LevelWorkBench = 3,
                            Url = "https://i.imgur.com/86CDnDd.png",
                            ItemsList = new Dictionary<string, int>
                            {
                                ["wood"] = 100,
                                ["sulfur"] = 1000
                            }
                        },
                        new CraftSettings
                        {
                            Enable = true,
                            Name = "Машина",
                            Prefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab",
                            ShortName = "woodcross",
                            Info = "Описание",
                            SkinID = 1789556977,
                            Amount = 1,
                            LevelWorkBench = 3,
                            Url = "https://i.imgur.com/KMDl39b.png",
                            ItemsList = new Dictionary<string, int>
                            {
                                ["wood"] = 100,
                                ["sulfur"] = 1000
                            }
                        },
                        new CraftSettings
                        {
                            Enable = true,
                            Name = "Гранатомёт",
                            Prefab = null,
                            ShortName = "multiplegrenadelauncher",
                            Info = "Описание",
                            SkinID = 0,
                            Amount = 1,
                            LevelWorkBench = 3,
                            Url = null,
                            ItemsList = new Dictionary<string, int>
                            {
                                ["wood"] = 100,
                                ["sulfur"] = 1000
                            }
                        },
                    }
                };
            }
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.craftSettings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewCong();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        void OnServerInitialized()
        {
            foreach (var check in config.craftSettings)
            {
                ImageLibrary.Call("AddImage", check.Url, check.Url);
            }
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player,LayerCraftInfo);
            }
        }

        class BasesEntity : MonoBehaviour
        {
            private DestroyOnGroundMissing desGround;
            private GroundWatch groundWatch;
            public ulong OwnerID;

            void Awake()
            {
                OwnerID = GetComponent<BaseEntity>().OwnerID;
                desGround = GetComponent<DestroyOnGroundMissing>();
                if (!desGround) gameObject.AddComponent<DestroyOnGroundMissing>();
                groundWatch = GetComponent<GroundWatch>();
                if (!groundWatch) gameObject.AddComponent<GroundWatch>();
            }
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            var entity = go.ToBaseEntity();

            foreach (var check in config.craftSettings)
            {
                if (entity != null && entity.skinID == check.SkinID && entity.skinID != 0)
                {
                    BaseEntity all = GameManager.server.CreateEntity(check.Prefab, entity.transform.position, entity.transform.rotation) as BaseEntity;
                    all.Spawn();
                    entity.Kill();
                    all.gameObject.AddComponent<BasesEntity>();
                }
            }
        }
        #endregion

        #region Команды
        [ChatCommand("craft")]
        void cmdCraft(BasePlayer player, string command, string[] args)
        {
            CraftUI(player, 1);
        }

        [ConsoleCommand("craft")]
        void ConsoleCraft(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "item")
                {
                    bool enable = true;
                    var items = config.craftSettings.FirstOrDefault(p => p.ShortName == args.Args[1]);
                    if (player.currentCraftLevel < items.LevelWorkBench)
                    {
                        SendReply(player, $"Нужен верстак {items.LevelWorkBench} уровня");
                        return;
                    }
                    foreach (var check in items.ItemsList)
                    {
                        var haveCount = player.inventory.GetAmount(ItemManager.FindItemDefinition(check.Key).itemid);
                        if (haveCount >= check.Value) continue;
                        enable = false;
                    }
                    if (!enable)
                    {
                        SendReply(player, "У вас не хватает ресурсов для крафта");
                        return;
                    }
                    foreach (var check in items.ItemsList)
                    {
                        player.inventory.Take(null, ItemManager.FindItemDefinition(check.Key).itemid, check.Value);
                    }
                    var skinId = items.SkinID != 0 ? items.SkinID : 0;
                    var item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(items.ShortName).itemid, 1, skinId);
                    item.name = items.Name;
                    if (!player.inventory.GiveItem(item))
                    {
                        item.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity, new Quaternion());
                        return;
                    }
                    player.SendConsoleCommand("closs");
                    SendReply(player, $"Вы успешно скрафтили: {items.Name}");
                    return;
                }
                if (args.Args[0] == "info")
                {
                    string craft = args.Args[1];
                    CraftInfoUI(player, craft);
                }
                if (args.Args[0] == "skip")
                {
                    int page = 0;
                    if (!args.HasArgs(2) || !int.TryParse(args.Args[1], out page)) return;
                    CraftUI(player, page);
                }
            }
        }

        [ConsoleCommand("closs")]
        void ConsoleCloss(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            CuiHelper.DestroyUi(player, LayerCraftInfo);
        }
        #endregion

        #region Интерфейс
        private void CraftUI(BasePlayer player, int page = 1)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            int CraftCount = config.craftSettings.Count(), CountCraft = 0, Count = 4;
            float Position = 0.2f, Width = (0.146f), Height = 0.3f, Margin = 0.005f, MinHeight = 0.503f;

            if (CraftCount >= Count) Position = 0.5f - Count / 2f * Width - (Count - 1) / 2f * Margin;
            else Position = 0.5f - CraftCount / 2f * Width - (CraftCount - 1) / 2f * Margin;
            CraftCount -= Count;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-2 -2", AnchorMax = "2 2", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.9", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.9", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"<b><size=30>Система крафта предметов</size></b>\nСтраница: {page} из {(config.craftSettings.Count() / 9) + 1}".ToUpper(), Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
            }, Layer);

            #region Скип
            if (page > 1)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0.45", AnchorMax = "0.057 0.55", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"craft skip {page - 1}" },
                    Text = { Text = $"<", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 60 }
                }, Layer);
            }

            if (page < (int)Math.Ceiling((double)config.craftSettings.ToList().Count / 8))
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.943 0.45", AnchorMax = "1 0.55", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"craft skip {page + 1}" },
                    Text = { Text = $">", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 60 }
                }, Layer);
            }
            #endregion

            foreach (var check in config.craftSettings.Skip((page - 1) * 8).Take(8))
            {
                if (check.Enable)
                {
                    container.Add(new CuiButton()
                    {
                        RectTransform = { AnchorMin = $"{Position} {MinHeight}", AnchorMax = $"{Position + Width} {MinHeight + Height}", OffsetMax = "0 0" },
                        Button = { Color = "1 1 1 0.1" },
                        Text = { Text = $" " }
                    }, Layer, $"{check.ShortName}");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.1 0.21", AnchorMax = "0.9 0.84", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0" },
                        Text = { Text = "", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                    }, $"{check.ShortName}", "Image");

                    var images = check.Url != null ? $"{check.Url}" : $"{check.ShortName}";
                    container.Add(new CuiElement
                    {
                        Parent = "Image",
                        Components =
                            {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", images) },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1 1", OffsetMax = "-1 -1" }
                            }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.028 0.03", AnchorMax = "0.972 0.2", OffsetMax = "0 0" },
                        Button = { Color = "0.39 0.73 0.49 0.9", Material = "assets/content/ui/uibackgroundblur.mat", Command = $"craft info {check.ShortName}", Close = Layer },
                        Text = { Text = "ОТКРЫТЬ", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
                    }, $"{check.ShortName}");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0.85", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "1 1 1 0" },
                        Text = { Text = $"{check.Name}", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
                    }, $"{check.ShortName}");

                    CountCraft += 1;
                    if (CountCraft % Count == 0)
                    {
                        if (CraftCount > Count)
                        {
                            Position = 0.5f - Count / 2f * Width - (Count - 1) / 2f * Margin;
                            CraftCount -= Count;
                        }
                        else
                        {
                            Position = 0.5f - CraftCount / 2f * Width - (CraftCount - 1) / 2f * Margin;
                        }
                        MinHeight -= ((Margin * 2) + Height);
                    }
                    else
                    {
                        Position += (Width + Margin);
                    }
                }
            }

            CuiHelper.AddUi(player, container);
        }

        #region Предмет
        private void CraftInfoUI(BasePlayer player, string craft)
        {
            CuiHelper.DestroyUi(player, LayerCraftInfo);
            CuiElementContainer container = new CuiElementContainer();
            CraftSettings check = config.craftSettings.Find(p => p.ShortName == craft);
            int ItemCount = check.ItemsList.Count(), Count = 6;
            float Position = 0.2f, Width = 0.08f, Height = 0.14f, Margin = 0.005f, MinHeight = 0.26f;
            Position = 0.5f - ItemCount / 2f * Width - (ItemCount - 1) / 2f * Margin;
            int current = 1;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" },
            }, "Overlay", LayerCraftInfo);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-2 -2", AnchorMax = "2 2", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.9", Command = "chat.say /craft", Close = LayerCraftInfo },
                Text = { Text = "" }
            }, LayerCraftInfo);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.43 0.65", AnchorMax = "0.57 0.895", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "" }
            }, LayerCraftInfo, "Image");

            var images = check.Url != null ? $"{check.Url}" : $"{check.ShortName}";
            container.Add(new CuiElement
            {
                Parent = "Image",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", images) },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.59", AnchorMax = "1 0.63", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"{check.Name}", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, FontSize = 25, Font = "robotocondensed-bold.ttf" }
            }, LayerCraftInfo);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.465", AnchorMax = "1 0.585", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"{check.Info}", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.UpperCenter, FontSize = 18, Font = "robotocondensed-regular.ttf" }
            }, LayerCraftInfo);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.425", AnchorMax = "1 0.46", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"Предметы необходимые для крафта", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, FontSize = 22, Font = "robotocondensed-bold.ttf" }
            }, LayerCraftInfo);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.4 0.13", AnchorMax = "0.6 0.18", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Command = $"craft item {check.ShortName}" },
                Text = { Text = "СКРАФТИТЬ", Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, FontSize = 22, Font = "robotocondensed-bold.ttf" }
            }, LayerCraftInfo);

            var textWork = 0 < check.LevelWorkBench ? $"Нужен верстак {check.LevelWorkBench} уровня" : "Верстак не нужен";
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.03", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = textWork, Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
            }, LayerCraftInfo);

            foreach (var item in check.ItemsList)
            {
                int haveCount = player.inventory.GetAmount(ItemManager.FindItemDefinition(item.Key).itemid);
                var colors = haveCount >= item.Value ? "0.39 0.73 0.49 0.3" : "0.76 0.24 0.24 0.3";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{Position} {MinHeight}", AnchorMax = $"{Position + Width} {MinHeight + Height}", OffsetMax = "0 0" },
                    Button = { Color = colors, Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { Text = $"", Align = TextAnchor.LowerCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
                }, LayerCraftInfo, "Images");

                container.Add(new CuiElement
                {
                    Parent = "Images",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.Key) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2 2", OffsetMax = "-2 -2" }
                    }
                });

                var text = haveCount >= item.Value ? "СОБРАНО " : $"X{item.Value} ";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = text, Color = HexToUiColor("#FFFFFF5A"), Align = TextAnchor.LowerRight, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, "Images");
                Position += (Width + Margin);
                current++;
                if (current > 6)
                {
                    break;
                }
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #endregion

        #region Helpers
        private static string HexToUiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}

// --- End of file: CraftSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AAlertRaid-1.0.0.cs ---
// --- Original Local Path: AAlertRaid-1.0.0.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using CompanionServer;
using Oxide.Ext.Discord.Entities;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using ru = Oxide.Game.Rust;
using ConVar;
using Oxide.Ext.Discord.Builders;
using Oxide.Ext.Discord.Clients;
using Oxide.Ext.Discord.Connections;
using Oxide.Ext.Discord.Interfaces;

namespace Oxide.Plugins
{
    [Info("AAlertRaid", "Raid", "1.0.0")]
    public class AAlertRaid : RustPlugin, IDiscordPlugin
    {
        #region CONFIG
        const bool fermensEN = false;

        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }


        class VK
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "API" : "API от группы")]
            public string api;

            [JsonProperty(fermensEN ? "Link to the group" : "Ссылка на группу")]
            public string link;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;
        }
        class RUSTPLUS
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;
        }
        class INGAME
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;

            [JsonProperty(fermensEN ? "Send game effect when notification are received" : "Эффект при получении уведомления")]
            public string effect;

            [JsonProperty(fermensEN ? "Time after the UI is destroyed" : "Время, через которое пропадает UI [секунды]")]
            public float destroy;

            [JsonProperty("UI")]
            public string UI;
        }

        class DISCORD
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;

            [JsonProperty(fermensEN ? "Invitation link" : "Приглашение в группу")]
            public string link;

            [JsonProperty(fermensEN ? "Token (https://discordapp.com/developers/applications)" : "Токен бота (https://discordapp.com/developers/applications)")]
            public string token;

            [JsonProperty(fermensEN ? "Channel ID, where the player will take the code to confirm the profile" : "ID канала, гле игрок будет брать код, для подтверджения профиля")]
            public string channel;

            [JsonProperty(fermensEN ? "Info text" : "Дискорд канал с получением кода - текст")]
            public string channeltext;

            [JsonProperty(fermensEN ? "Info text - line color on the left" : "Дискорд канал с получением кода - цвет линии слева (https://gist.github.com/thomasbnt/b6f455e2c7d743b796917fa3c205f812#file-code_colors_discordjs-md)")]
            public uint channelcolor;

            [JsonProperty(fermensEN ? "Text on button" : "Дискорд канал с получением кода - кнопка")]
            public string channelbutton;

            [JsonProperty(fermensEN ? "Reply after button click" : "Дискорд канал с получением кода - ответ")]
            public string channelex;

            [JsonProperty(fermensEN ? "Don't touch this field" : "Дискорд канал с получением кода - ID сообщения (не трогаем! сам заполнится!)")]
            public string channelmessageid;
        }

        class TELEGRAM
        {
            [JsonProperty(fermensEN ? "Enable?" : "Включить?")]
            public bool enable;

            [JsonProperty(fermensEN ? "Cooldown for sending" : "Кд на отправку")]
            public float cooldown;

            [JsonProperty(fermensEN ? "Bot tag" : "Тэг бота")]
            public string bottag;

            [JsonProperty(fermensEN ? "Token" : "Токен")]
            public string token;
        }

        class UIMenu
        {
            [JsonProperty(fermensEN ? "Background color" : "Цвет фона")]
            public string background;

            [JsonProperty(fermensEN ? "Strip color" : "Цвет полоски")]
            public string stripcolor;

            [JsonProperty(fermensEN ? "Rectangular container background color" : "Цвет фона прямоугольного контейнера")]
            public string rectangularcolor;

            [JsonProperty(fermensEN ? "Button text color" : "Цвет текста в кнопке")]
            public string buttoncolortext;

            [JsonProperty(fermensEN ? "Text color" : "Цвет текста")]
            public string textcolor;

            [JsonProperty(fermensEN ? "Green button color" : "Цвет зелёной кнопки")]
            public string greenbuttoncolor;

            [JsonProperty(fermensEN ? "Red button color" : "Цвет красной кнопки")]
            public string redbuttoncolor;

            [JsonProperty(fermensEN ? "Gray button color" : "Цвет серой кнопки")]
            public string graybuttoncolor;

            [JsonProperty(fermensEN ? "Header text color" : "Цвет текста заголовка")]
            public string headertextcolor;

            [JsonProperty(fermensEN ? "Error text color" : "Цвет текста ошибки")]
            public string errortextcolor;

            [JsonProperty(fermensEN ? "Text color of <exit> and <back> buttons" : "Цвет текста кнопок <выход> и <назад>")]
            public string colortextexit;

            [JsonProperty(fermensEN ? "Rectangular container text color" : "Цвет текст прямоугольного контейнера")]
            public string rectangulartextcolor;

            [JsonProperty(fermensEN ? "The color of the text with hints at the bottom of the screen" : "Цвет текста с подсказками внизу экрана")]
            public string hintstextcolor;

            [JsonProperty(fermensEN ? "Abbreviations and their colors" : "Аббревиатуры и их цвета")]
            public UIMainMenu uIMainMenu;
        }

        class UIMainMenu
        {
            [JsonProperty(fermensEN ? "Abbreviation for telegram" : "Аббревиатура для телеграма")]
            public string abr_telegram;

            [JsonProperty(fermensEN ? "Telegram icon color" : "Цвет иконки телеграма")]
            public string color_telegram;

            [JsonProperty(fermensEN ? "Abbreviation for vk.com" : "Аббревиатура для вконтакте")]
            public string abr_vk;

            [JsonProperty(fermensEN ? "Vk.com icon color" : "Цвет иконки вконтакте")]
            public string color_vk;

            [JsonProperty(fermensEN ? "Abbreviation for rust+" : "Аббревиатура для rust+")]
            public string abr_rustplus;

            [JsonProperty(fermensEN ? "Rust+ icon color" : "Цвет иконки rust+")]
            public string color_rustplus;

            [JsonProperty(fermensEN ? "Abbreviation for discord" : "Аббревиатура для дискорда")]
            public string abr_discord;

            [JsonProperty(fermensEN ? "Discord icon color" : "Цвет иконки дискорда")]
            public string color_discord;

            [JsonProperty(fermensEN ? "Abbreviation for in game" : "Аббревиатура для графическое отображение в игре")]
            public string abr_ui;

            [JsonProperty(fermensEN ? "In game icon color" : "Цвет иконки графическое отображение в игре")]
            public string color_ui;
        }

        private class PluginConfig
        {
            [JsonProperty(fermensEN ? "Server name, will using for alerts" : "Название сервера - для оповещений")]
            public string servername;

            [JsonProperty(fermensEN ? "Raid alert works only for those who have permission" : "Оповещение о рейде работает только для тех, у кого есть разрешение")]
            public bool needpermission;

            [JsonProperty(fermensEN ? "VK.com" : "Оповещание о рейде в ВК")]
            public VK vk;

            [JsonProperty(fermensEN ? "Rust+" : "Оповещание о рейде в Rust+")]
            public RUSTPLUS rustplus;

            [JsonProperty(fermensEN ? "In game" : "Оповещание о рейде в игре")]
            public INGAME ingame;

            [JsonProperty(fermensEN ? "Discord" : "Оповещание о рейде в дискорд")]
            public DISCORD discord;

            [JsonProperty(fermensEN ? "Telegram" : "Оповещание о рейде в телеграм")]
            public TELEGRAM telegram { get; set; } = new TELEGRAM
            {
                token = "",
                cooldown = 1200f,
                enable = true,
                bottag = "@haxlite_bot"
            };

            [JsonProperty(fermensEN ? "Menu UI" : "Настройка UI")]
            public UIMenu ui { get; set; } = new UIMenu
            {
                background = "0.07843138 0.06666667 0.1098039 0.9490196",
                stripcolor = "0.8784314 0.9843137 1 0.5686275",
                rectangularcolor = "0.8901961 0.8901961 0.8901961 0.4156863",
                graybuttoncolor = "0.8901961 0.8901961 0.8901961 0.4156863",
                buttoncolortext = "1 1 1 0.9056942",
                rectangulartextcolor = "1 1 1 0.7843137",
                textcolor = "1 1 1 1",
                headertextcolor = "1 1 1 1",
                hintstextcolor = "1 1 1 0.6699298",
                greenbuttoncolor = "0.5450981 1 0.6941177 0.509804",
                errortextcolor = "1 0.5429931 0.5429931 0.787812",
                colortextexit = "0.5938045 0.5789595 0.5789595 1",
                redbuttoncolor = "1 0.5450981 0.5450981 0.509804",
                uIMainMenu = new UIMainMenu
                {
                    abr_discord = "DS",
                    abr_rustplus = "R+",
                    abr_telegram = "TG",
                    abr_ui = "UI",
                    abr_vk = "VK",
                    color_discord = "0.6313726 0.5764706 1 0.4156863",
                    color_rustplus = "1 0.5803921 0.6013725 0.4156863",
                    color_vk = "0.5803922 0.6627451 1 0.4156863",
                    color_ui = "1 0.7843137 0.5764706 0.4156863",
                    color_telegram = "0.5479987 0.9459876 1 0.4156863"
                }
            };


            [JsonProperty(fermensEN ? "Additional list" : "Дополнительный список предметов, которые учитывать")]
            public string[] spisok;

            [JsonProperty(fermensEN ? "Notification when usual items are destroyed" : "Оповещение при уничтожении обычных предметов")]
            public bool extralist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    servername = "HaxLite X10",
                    vk = new VK
                    {
                        api = "",
                        cooldown = 1200f,
                        enable = true,
                    },
                    rustplus = new RUSTPLUS
                    {
                        cooldown = 600f,
                        enable = true
                    },
                    ingame = new INGAME
                    {
                        cooldown = 60f,
                        enable = true,
                        effect = "assets/prefabs/weapons/toolgun/effects/repairerror.prefab",
                        destroy = 4f,
                        UI = "[{\"name\":\"UIA\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"material\":\"assets/content/ui/uibackgroundblur.mat\", \"sprite\":\"assets/content/ui/ui.background.transparent.linearltr.tga\",\"color\":\"0 0 0 0.6279221\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0.5\",\"anchormax\":\"1 0.5\",\"offsetmin\":\"-250 -30\",\"offsetmax\":\"0 30\"}]},{\"name\":\"D\",\"parent\":\"UIA\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 0 0 0.392904\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 5\"}]},{\"name\":\"T\",\"parent\":\"UIA\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":12,\"align\":\"MiddleLeft\",\"color\":\"1 1 1 0.8644356\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"U\",\"parent\":\"UIA\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 0 0 0.3921569\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -5\",\"offsetmax\":\"0 0\"}]}]"
                    },
                    discord = new DISCORD
                    {
                        cooldown = 600f,
                        enable = true,
                        token = "",
                        channel = "",
                        channelbutton = fermensEN ? "Get code" : "Получить код",
                        channelex = fermensEN ? "Your code: {code}" : "Ваш код: {code}",
                        channelmessageid = "",
                        channeltext = fermensEN ? "Enter the received code in the integration menu for raid alerts.\nChat command /raid\nEnter it in the game itself, not in the discord!" : "Введите полученый код в меню интеграции дискорда с игровым профилем.\nЧат команда /raid\nВводить в самой игре, а не в дискорде!",
                        channelcolor = 14177041
                    },
                    spisok = _spisok
                };
            }
        }
        private static string[] _spisok = new string[] { "wall.external.high", "wall.external.high.stone", "gates.external.high.wood", "gates.external.high.stone", "wall.window.bars.metal", "wall.window.bars.toptier", "wall.window.glass.reinforced", "wall.window.bars.wood" };

        #endregion

        #region DISCORD
        private readonly BotConnection _discordSettings = new BotConnection();
        private DiscordGuild _guild;
        public DiscordClient Client { get; set; }
        private void CreateClient()
        {
            _discordSettings.ApiToken = config.discord.token;
            _discordSettings.Intents = GatewayIntents.GuildMessages | GatewayIntents.DirectMessages | GatewayIntents.Guilds | GatewayIntents.GuildMembers;
            _discordSettings.LogLevel = Ext.Discord.Logging.DiscordLogLevel.Error;
            Client.Connect(_discordSettings);

            timer.Once(5f, () =>
            {
                if (Client == null)
                {
                    CreateClient();
                    Debug.Log("Discord reconnecting in 5 sec...");
                }
                else
                {
                    DiscordChannel channel;
                    if (!_guild.Channels.TryGetValue(new Snowflake(config.discord.channel), out channel))
                    {
                        Debug.Log(fermensEN ? $"CHANNEL NOT FOUND! ({_guild.Channels.Count})" : $"КАНАЛ НЕ СУЩЕСТВУЕТ! ({_guild.Channels.Count})");
                        return;
                    }

                    var embeds = new List<DiscordEmbed> { new DiscordEmbed { Color = new DiscordColor(config.discord.channelcolor), Description = config.discord.channeltext } };
                    var components = CreateComponents(config.discord.channelbutton);
                    if (!string.IsNullOrEmpty(config.discord.channelmessageid))
                    {
                        channel.GetMessage(Client, new Snowflake(config.discord.channelmessageid)).Then(message =>
                        {
                            message.Embeds = embeds;
                            message.Components.Clear();
                            message.Components = components;
                            message.Edit(Client, new MessageUpdate
                            {
                                Embeds = embeds,
                                Components = components
                            });
                        }).Catch<ResponseError>(error =>
                        {
                            if (error.HttpStatusCode == DiscordHttpStatusCode.NotFound)
                            {
                                Debug.Log("all ok");
                                channel?.CreateMessage(Client, new MessageCreate { Embeds = embeds, Components = components }).Then(message =>
                                {
                                    config.discord.channelmessageid = message.Id;
                                    SaveConfig();
                                });
                            }
                        });
                    }
                    else
                    {
                        channel?.CreateMessage(Client, new MessageCreate { Embeds = embeds, Components = components }).Then(
                         message =>
                         {
                             config.discord.channelmessageid = message.Id;
                             SaveConfig();
                         });
                    }
                }
            });
        }
        private void OnDiscordInteractionCreated(DiscordInteraction interaction)
        {
            if (interaction.Type != InteractionType.MessageComponent)
            {
                return;
            }

            if (!interaction.Data.ComponentType.HasValue || interaction.Data.ComponentType.Value != MessageComponentType.Button || interaction.Data.CustomId != $"{Name}_{ConVar.Server.ip}_{ConVar.Server.port}")
            {
                return;
            }

            DiscordUser user = interaction.User ?? interaction.Member?.User;
            HandleAcceptLinkButton(interaction, user);

        }
        private void HandleAcceptLinkButton(DiscordInteraction interaction, DiscordUser user)
        {
            string num;
            if (!DISCORDCODES.TryGetValue(user.Id.Id, out num))
            {
                num = DISCORDCODES[user.Id.Id] = RANDOMNUM();
            }
            string linkMessage = Formatter.ToPlaintext(config.discord.channelex.Replace("{code}", num));
            interaction.CreateResponse(Client, new InteractionResponse
            {
                Type = InteractionResponseType.ChannelMessageWithSource,
                Data = new InteractionCallbackData
                {
                    Content = linkMessage,
                    Flags = MessageFlags.Ephemeral
                }
            });
        }

        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            _guild = ready.Guilds.FirstOrDefault().Value;
            Debug.Log(fermensEN ? $"DISCORD BOT CONNECTED TO ID{_guild.Id}." : $"DISCORD БОТ АВТОРИЗОВАН НА СЕРВЕРЕ ID{_guild.Id}.");
        }

        private void CloseClient()
        {
            if (Client != null) Client.Disconnect();
        }

        private void CREATECHANNEL(string dsid, string text)
        {
            Snowflake ss = new Snowflake(dsid);
            if (!_guild.Members.Any(x => x.Value.User.Id == ss)) return;
            _guild.Members.First(x => x.Value.User.Id == ss).Value.User.SendDirectMessage(Client, new MessageCreate { Content = text });
        }

        private void SENDMESSAGE(string dsid, string text)
        {
            DiscordChannel channel = _guild.GetChannel(dsid);

            if (channel != null)
            {
                channel?.CreateMessage(Client, text);
            }
            else
            {
                CREATECHANNEL(dsid, text);
            }
        }

        public List<ActionRowComponent> CreateComponents(string button)
        {
            MessageComponentBuilder builder = new MessageComponentBuilder();
            builder.AddActionButton(ButtonStyle.Success, button, $"{Name}_{ConVar.Server.ip}_{ConVar.Server.port}", false);

            return builder.Build();
        }

        private readonly List<Regex> _regexTags = new List<Regex>
        {
            new Regex("<color=.+?>", RegexOptions.Compiled),
            new Regex("<size=.+?>", RegexOptions.Compiled)
        };

        private readonly List<string> _tags = new List<string>
        {
            "</color>",
            "`",
            "</size>",
            "<i>",
            "</i>",
            "<b>",
            "</b>"
        };

        private string STRIP(string original)
        {
            if (string.IsNullOrEmpty(original))
            {
                return string.Empty;
            }

            foreach (string tag in _tags)
            {
                original = original.Replace(tag, "");
            }

            foreach (Regex regexTag in _regexTags)
            {
                original = regexTag.Replace(original, "");
            }

            return original;
        }

        private DiscordChannel GetChannel(string id)
        {
            return _guild.Channels.FirstOrDefault(x => x.Key.ToString() == id).Value;
        }
        #endregion

        #region STORAGE
        string connect = "14.02.22:1406";

        //{fon}

        string FON = "";
        string MAIN = "";
        string UI = "";
        string IF2 = "";
        string IF2A = "";
        string BTN = "";
        string ER = "";
        string IBLOCK = "";
        string MAINH = "";
        string AG = "";
        string EXIT = "";
        string BACK = "";

        #region Data
        class Storage
        {
            public string vk;
            public string telegram;
            public ulong discord;
            public bool rustplus;
            public bool ingamerust { get; set; } = true;
        }

        #region fermens#8767
        #endregion

        private Storage GetStorage(ulong userid)
        {
            Storage storage;
            if (datas.TryGetValue(userid, out storage)) return storage;

            string useridstring = userid.ToString();
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"AAlertRaid/{useridstring}"))
            {
                storage = new Storage();
                datas.Add(userid, storage);
                return storage;
            }

            storage = Interface.Oxide.DataFileSystem.ReadObject<Storage>($"AAlertRaid/{useridstring}");
            datas.Add(userid, storage);
            return storage;
        }

        private void SaveStorage(BasePlayer player)
        {
            Storage storage;
            if (datas.TryGetValue(player.userID, out storage))
            {
                ServerMgr.Instance.StartCoroutine(Saving(player.UserIDString, storage));
            }
        }

        private IEnumerator Saving(string userid, Storage storage)
        {
            yield return new WaitForSeconds(1f);
            Interface.Oxide.DataFileSystem.WriteObject($"AAlertRaid/{userid}", storage);
        }

        Dictionary<ulong, Storage> datas = new Dictionary<ulong, Storage>();
        #endregion
        #endregion

        #region API TELEGRAM 
        private void GetRequestTelegram(string reciverID, string msg, BasePlayer player = null, bool accept = false) => webrequest.Enqueue($"https://api.telegram.org/bot" + config.telegram.token + "/sendMessage?chat_id=" + reciverID + "&text=" + Uri.EscapeDataString(msg), null, (code2, response2) => ServerMgr.Instance.StartCoroutine(GetCallbackTelegram(code2, response2, reciverID, player, accept)), this);

        private IEnumerator GetCallbackTelegram(int code, string response, string id, BasePlayer player = null, bool accept = false)
        {
            if (player == null || response == null) yield break;

            if (code == 401)
            {
                Debug.LogError("[AlertRaid] Telegram token not valid!");
            }
            else if (code == 200)
            {
                if (!response.Contains("error_code"))
                {
                    ALERT aLERT;
                    if (alerts.TryGetValue(player.userID, out aLERT))
                    {
                        aLERT.vkcodecooldown = DateTime.Now.AddMinutes(1);
                    }
                    else
                    {
                        alerts.Add(player.userID, new ALERT { telegramcodecooldown = DateTime.Now.AddMinutes(1) });
                    }

                    Storage storage = GetStorage(player.userID);
                    storage.telegram = id;
                    SaveStorage(player);

                    write[player.userID] = "";
                    OpenMenu(player, false);
                }
            }
            else
            {
                SendError(player, "telegramuseridnotfound");
            }
            yield break;
        }
        #endregion

        #region API VK
        const string connects = "001.002.2022:1508";
        class ALERT
        {
            public DateTime gamecooldown;
            public DateTime rustpluscooldown;
            public DateTime vkcooldown;
            public DateTime discordcooldown;
            public DateTime vkcodecooldown;

            public DateTime telegramcooldown;
            public DateTime telegramcodecooldown;
        }

        private static Dictionary<ulong, ALERT> alerts = new Dictionary<ulong, ALERT>();
        class CODE
        {
            public string id;
            public ulong gameid;
        }

        private Dictionary<string, CODE> VKCODES = new Dictionary<string, CODE>();
        private Dictionary<ulong, string> DISCORDCODES = new Dictionary<ulong, string>();

        private void GetRequest(string reciverID, string msg, BasePlayer player = null, string num = null) => webrequest.Enqueue("https://api.vk.com/method/messages.send?domain=" + reciverID + "&message=" + Uri.EscapeDataString(msg) + "&v=5.81&access_token=" + config.vk.api, null, (code2, response2) => ServerMgr.Instance.StartCoroutine(GetCallbackVK(code2, response2, reciverID, player, num)), this);

        private void SendError(BasePlayer player, string key)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "ER");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", ER.Replace("{e0}", GetMessage(key, player.UserIDString)));
        }
        private IEnumerator GetCallbackVK(int code, string response, string id, BasePlayer player = null, string num = null)
        {
            if (player == null) yield break;
            if (response == null || code != 200)
            {
                ALERT alert;
                if (alerts.TryGetValue(player.userID, out alert)) alert.vkcooldown = DateTime.Now;
                Debug.Log("НЕ ПОЛУЧИЛОСЬ ОТПРАВИТЬ СООБЩЕНИЕ В ВК! => обнулили кд на отправку");
                yield break;
            }
            yield return new WaitForEndOfFrame();
            if (!response.Contains("error"))
            {
                ALERT aLERT;
                if (alerts.TryGetValue(player.userID, out aLERT))
                {
                    aLERT.vkcodecooldown = DateTime.Now.AddMinutes(1);
                }
                else
                {
                    alerts.Add(player.userID, new ALERT { vkcodecooldown = DateTime.Now.AddMinutes(1) });
                }
                if (VKCODES.ContainsKey(num)) VKCODES.Remove(num);
                VKCODES.Add(num, new CODE { gameid = player.userID, id = id });
                write[player.userID] = "";
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "ER");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "BTN");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", IBLOCK);
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BTN.Replace("{text1}", GetMessage("{text1}", player.UserIDString)).Replace("{color}", "1 1 1 0.509804"));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", IF2.Replace("{t3}", GetMessage("{t4}", player.UserIDString)).Replace("{coma}", "").Replace("{text2}", GetMessage("{text2}", player.UserIDString)));
            }
            else if (response.Contains("PrivateMessage"))
            {
                SendError(player, "rnprivate");
            }
            else if (response.Contains("ErrorSend"))
            {
                SendError(player, "rnerror");
            }
            else if (response.Contains("BlackList"))
            {
                SendError(player, "rnblack");
            }
            else
            {
                SendError(player, "rnerror2");
            }
            yield break;
        }
        #endregion

        #region COMMANDS
        private string perm = "discord fermens#8767";
        [PluginReference] Plugin BMenu;

        private void callcommandrn(BasePlayer player, string command, string[] arg)
        {
            OpenMenu(player);
        }

        private bool HasAcces(string id)
        {
            if (!config.needpermission) return true;
            return permission.UserHasPermission(id, perm);
        }

        private void OpenMenu(BasePlayer player, bool first = true)
        {
            if (!HasAcces(player.UserIDString))
            {
                player.ChatMessage(GetMessage("permission", player.UserIDString));
                return;
            }

            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SubContent_UI");
            if (first)
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "Main_UI");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", FON);
                if (BMenu != null)
                {
                    BMenu.Call("DestroyProfileLayers", player);
                    BMenu.Call("SetPage", player.userID, "raid");
                    BMenu.Call("SetActivePButton", player, "raid");
                }
            }
            //0.5450981 1 0.6941177 0.509804
            //{\"name\":\"Main_UI\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.07843138 0.06666667 0.1098039 0.9490196\",\"material\":\"assets/content/ui/uibackgroundblur.mat\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAIN);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "E");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", EXIT.Replace("{t7}", GetMessage("{t7}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAINH.Replace("{a0}", GetMessage("{amain}", player.UserIDString)));
            int num = 0;
            Storage storage = GetStorage(player.userID);
            #region VK
            if (config.vk.enable && !string.IsNullOrEmpty(config.vk.api))
            {
                if (!string.IsNullOrEmpty(storage.vk)) AddElementUI(player, GetMessage("{element_vk}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.vkdelete", config.ui.uIMainMenu.abr_vk, config.ui.uIMainMenu.color_vk, num);
                else AddElementUI(player, GetMessage("{element_vk}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_setup}", player.UserIDString), "raid.vkadd", config.ui.uIMainMenu.abr_vk, config.ui.uIMainMenu.color_vk, num);
                num++;
            }
            #endregion

            #region Telegram
            if (config.telegram.enable && !string.IsNullOrEmpty(config.telegram.token))
            {
                if (!string.IsNullOrEmpty(storage.telegram)) AddElementUI(player, GetMessage("{element_telegram}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.tgdelete", config.ui.uIMainMenu.abr_telegram, config.ui.uIMainMenu.color_telegram, num);
                else AddElementUI(player, GetMessage("{element_telegram}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_setup}", player.UserIDString), "raid.tgadd", config.ui.uIMainMenu.abr_telegram, config.ui.uIMainMenu.color_telegram, num);
                num++;
            }
            #endregion

            #region Rust+
            if (config.rustplus.enable && !string.IsNullOrEmpty(App.serverid) && App.port > 0 && App.notifications)
            {
                if (!storage.rustplus) AddElementUI(player, GetMessage("{element_rustplus}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_enable}", player.UserIDString), "raid.rustplus", config.ui.uIMainMenu.abr_rustplus, config.ui.uIMainMenu.color_rustplus, num);
                else AddElementUI(player, GetMessage("{element_rustplus}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.rustplus", config.ui.uIMainMenu.abr_rustplus, config.ui.uIMainMenu.color_rustplus, num);
                num++;
            }
            #endregion

            #region InGame
            if (config.ingame.enable)
            {
                if (!storage.ingamerust) AddElementUI(player, GetMessage("{element_ingame}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_enable}", player.UserIDString), "raid.ingame", config.ui.uIMainMenu.abr_ui, config.ui.uIMainMenu.color_ui, num);
                else AddElementUI(player, GetMessage("{element_ingame}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.ingame", config.ui.uIMainMenu.abr_ui, config.ui.uIMainMenu.color_ui, num);
                num++;
            }
            #endregion

            #region Discord
            if (config.discord.enable && !string.IsNullOrEmpty(config.discord.token))
            {
                if (storage.discord == 0UL) AddElementUI(player, GetMessage("{element_discord}", player.UserIDString), config.ui.greenbuttoncolor, GetMessage("{element_setup}", player.UserIDString), "raid.discordadd", config.ui.uIMainMenu.abr_discord, config.ui.uIMainMenu.color_discord, num);
                else
                {
                    AddElementUI(player, GetMessage("{element_discord}", player.UserIDString), config.ui.graybuttoncolor, GetMessage("{element_disable}", player.UserIDString), "raid.discorddelete", config.ui.uIMainMenu.abr_discord, config.ui.uIMainMenu.color_discord, num);
                }
                num++;
            }
            #endregion
        }

        class C
        {
            public string min;
            public string max;
        }

        Dictionary<int, C> _caddele = new Dictionary<int, C>();

        private void AddElementUI(BasePlayer player, string name, string color, string button, string command, string ico, string icocolor, int num)
        {
            C ce;
            if (!_caddele.TryGetValue(num, out ce))
            {
                ce = new C();
                float start = 60f;
                float e = 30f;
                float p = 35f;
                float max = start - (num * p);
                ce.min = (max - e).ToString();
                ce.max = max.ToString();
                _caddele.Add(num, ce);
            }

            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", AG.Replace("{num}", num.ToString()).Replace("{id}", name).Replace("{coma}", command).Replace("{ico}", ico).Replace("{icocolor}", icocolor).Replace("{color}", color).Replace("{text1}", button).Replace("{min}", ce.min).Replace("{max}", ce.max));
        }

        Dictionary<ulong, string> write = new Dictionary<ulong, string>();

        [ConsoleCommand("raid.input")]
        void ccmdopeinput(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            string text = arg.HasArgs() ? string.Join(" ", arg.Args) : null;
            write[player.userID] = text;
        }

        private void SendError2(BasePlayer player, string key)
        {
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "BTN2");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", IF2A.Replace("{text2}", GetMessage(key, player.UserIDString)).Replace("{coma}", "").Replace("{color}", config.ui.redbuttoncolor));
            timer.Once(1f, () =>
            {
                if (!player.IsConnected) return;
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "BTN2");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", IF2A.Replace("{text2}", GetMessage("{text2}", player.UserIDString)).Replace("{coma}", "raid.accept").Replace("{color}", config.ui.greenbuttoncolor));
            });
        }

        #region InGame Comand
        [ConsoleCommand("raid.ingame")]
        void raplsgame(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.ingamerust = !storage.ingamerust;
            SaveStorage(player);
            OpenMenu(player, false);
        }
        #endregion


        #region Rust+ Comand
        [ConsoleCommand("raid.rustplus")]
        void rapls(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.rustplus = !storage.rustplus;
            SaveStorage(player);
            OpenMenu(player, false);
        }
        #endregion

        #region Discord command
        [ConsoleCommand("raid.discordadd")]
        void ccmdadiscoradd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SubContent_UI");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "E");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAIN);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BACK.Replace("{t7}", GetMessage("{back}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", UI.Replace("{t7}", GetMessage("{d7}", player.UserIDString)).Replace("{t6}", GetMessage("{d6}", player.UserIDString)).Replace("{t5}", GetMessage("{d5}", player.UserIDString)).Replace("{t4}", GetMessage("{d3}", player.UserIDString)).Replace("{t2}", config.discord.link).Replace("{t1}", GetMessage("{d1}", player.UserIDString)).Replace("{t0}", GetMessage("{d0}", player.UserIDString))); ;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BTN.Replace("{text1}", GetMessage("{text2}", player.UserIDString)).Replace("{coma}", "raid.acceptds").Replace("{color}", config.ui.greenbuttoncolor));
        }

        [ConsoleCommand("raid.acceptds")]
        void raidacceptds(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            //0.8901961 0.8901961 0.8901961 0.4156863
            //1 0.5450981 0.5450981 0.509804
            // raid.accept
            string text;
            if (!write.TryGetValue(player.userID, out text) || string.IsNullOrEmpty(text))
            {
                SendError(player, "rnnocode");
                return;
            }


            ulong user = DISCORDCODES.FirstOrDefault(x => x.Value == text).Key;
            if (user != 0UL)
            {
                Storage storage = GetStorage(player.userID);
                storage.discord = user;
                SaveStorage(player);
                DISCORDCODES.Remove(user);
                OpenMenu(player, false);
            }
            else
            {
                SendError(player, "rncancel");
            }
        }

        [ConsoleCommand("raid.discorddelete")]
        void vdiscorddelete(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.discord = 0;
            SaveStorage(player);
            OpenMenu(player, false);
        }
        #endregion

        #region Telegram COmand
        [ConsoleCommand("raid.tgdelete")]
        void rgdelete(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.telegram = null;
            SaveStorage(player);
            OpenMenu(player, false);
        }

        [ConsoleCommand("raid.tgadd")]
        void ccmdtgadd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SubContent_UI");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "E");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAIN);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BACK.Replace("{t7}", GetMessage("{back}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", UI.Replace("{t7}", GetMessage("{teleg7}", player.UserIDString)).Replace("{t6}", GetMessage("{teleg6}", player.UserIDString)).Replace("{t5}", GetMessage("{teleg5}", player.UserIDString)).Replace("{t4}", GetMessage("{teleg3}", player.UserIDString)).Replace("{t2}", GetMessage("{teleg2}", player.UserIDString).Replace("{tag}", config.telegram.bottag)).Replace("{t1}", GetMessage("{teleg1}", player.UserIDString).Replace("{tag}", config.telegram.bottag)).Replace("{t0}", GetMessage("{teleg0}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BTN.Replace("{text1}", GetMessage("{text2}", player.UserIDString)).Replace("{coma}", "raid.accepttg").Replace("{color}", config.ui.greenbuttoncolor));
        }

        [ConsoleCommand("raid.accepttg")]
        void ccmdaccepttg(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            ALERT aLERT;
            if (alerts.TryGetValue(player.userID, out aLERT) && aLERT.telegramcodecooldown > DateTime.Now)
            {
                SendError(player, "rnaddcooldown");
                return;
            }

            string text;
            if (!write.TryGetValue(player.userID, out text) || string.IsNullOrEmpty(text))
            {
                SendError(player, "telegid");
                return;
            }

            GetRequestTelegram(text, GetMessage("telegramadd", player.UserIDString), player, true);
        }
        #endregion

        #region Vk COmand
        [ConsoleCommand("raid.vkdelete")]
        void vkdelete(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            Storage storage = GetStorage(player.userID);
            storage.vk = null;
            SaveStorage(player);
            OpenMenu(player, false);
        }

        [ConsoleCommand("raid.vkadd")]
        void ccmdavkadd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "SubContent_UI");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "E");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", MAIN);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BACK.Replace("{t7}", GetMessage("{back}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", UI.Replace("{t7}", GetMessage("{t7}", player.UserIDString)).Replace("{t6}", GetMessage("{t6}", player.UserIDString)).Replace("{t5}", GetMessage("{t5}", player.UserIDString)).Replace("{t4}", GetMessage("{t3}", player.UserIDString)).Replace("{t2}", config.vk.link).Replace("{t1}", GetMessage("{t1}", player.UserIDString)).Replace("{t0}", GetMessage("{t0}", player.UserIDString)));
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", BTN.Replace("{text1}", GetMessage("{text1}", player.UserIDString)).Replace("{coma}", "raid.send").Replace("{color}", config.ui.greenbuttoncolor));
        }

        [ConsoleCommand("raid.accept")]
        void ccmdaccept(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            //0.8901961 0.8901961 0.8901961 0.4156863
            //1 0.5450981 0.5450981 0.509804
            // raid.accept
            string text;
            if (!write.TryGetValue(player.userID, out text) || string.IsNullOrEmpty(text))
            {
                SendError2(player, "rnnocode");
                return;
            }

            CODE cODE;
            if (VKCODES.TryGetValue(text, out cODE) && cODE.gameid == player.userID)
            {
                Storage storage = GetStorage(player.userID);
                storage.vk = cODE.id;
                SaveStorage(player);
                VKCODES.Remove(text);
                OpenMenu(player, false);
            }
            else
            {
                SendError2(player, "rncancel");
            }
        }

        [ConsoleCommand("raid.send")]
        void ccmdopesendt(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            ALERT aLERT;
            if (alerts.TryGetValue(player.userID, out aLERT) && aLERT.vkcodecooldown > DateTime.Now)
            {
                SendError(player, "rnaddcooldown");
                return;
            }

            string text;
            if (!write.TryGetValue(player.userID, out text) || string.IsNullOrEmpty(text))
            {
                SendError(player, "null");
                return;
            }

            string vkid = text.ToLower().Replace("vk.com/", "").Replace("https://", "").Replace("http://", "");
            string num = RANDOMNUM();
            GetRequest(vkid, GetMessage("code", player.UserIDString).Replace("{code}", num), player, num);
        }
        #endregion

        private string RANDOMNUM() => UnityEngine.Random.Range(1000, 99999).ToString();
        #endregion

        #region OXIDE HOOKS
        private void Unload()
        {
            CloseClient();
            //CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main_UI");
        }

        private void OnServerInitialized()
        {
            ServerMgr.Instance.StartCoroutine(GetCallback());
        }

        #region WEBCONFIG

        public Dictionary<string, string> messagesEN = new Dictionary<string, string>
        {
            { "{t0}", "Join a group" },
            { "{element_vk}", "Vkontakte" },
            { "{element_telegram}", "Telegram" },
            { "{element_discord}", "Discord" },
            { "{element_rustplus}", "Rust+ app" },
            { "{element_ingame}", "Show in game" },
            { "{element_setup}", "Set up" },
            { "{element_disable}", "Disable" },
            { "{element_enable}", "Enable" },
            { "permission", "You do not have permission to use this command!" },
            { "{t1}", "Write any message to the group" },
            { "{t2}", "VK.COM/HAXLITE" },
            { "{t3}", "Link to your profile" },
            { "{t4}", "Check your mail in vk.com and enter the received code" },
            { "{t5}", "Enter text via Ctrl + V, so that commands binded on the keys that you press are not executed during input" },
            { "{t6}", "Set up alert" },
            { "{d0}", "Join the discord server" },
            { "{d1}", "Get the code in the 'Game Profile Integration' channel" },
            { "{d2}", "DISCORD.GG/CyFmAqGBED" },
            { "{d3}", "Enter the received code" },
            { "{d5}", "Enter text via Ctrl + V, so that commands binded on the keys that you press are not executed during input" },
            { "{d6}", "Set up alert" },
            { "{t7}", "EXIT" },
            { "{teleg0}", "Add the @userinfobot bot, press /start and copy the resulting Id" },
            { "{teleg1}", "Add bot {tag} and press /start" },
            { "{teleg2}", "{tag}" },
            { "{teleg3}", "Enter the copied Id" },
            { "{teleg5}", "Enter text via Ctrl + V, so that commands binded on the keys that you press are not executed during input" },
            { "{teleg6}", "Set up alert" },
            { "{back}", "BACK" },
            { "telegramuseridnotfound", "User id not found!" },
            { "telegramadd", "Now you will receive alert raid here" },
            { "telegid", "Enter the copied Id!" },
            { "{amain}", "Raid Alerts Control Panel" },
            { "{text1}", "Get code" },
            { "code", "Account verification code: {code}." },
            { "{text2}", "Confirm" },
            { "notallow", "Buy privilige to enable raid alerts in the store!" },
            { "rncancel", "Incorrect code!" },
            { "alertvk", "Attention! Player {name} destroyed {destroy} in square {quad}\nconnect {ip}" },
            { "alerttelegram", "Attention! Player {name} destroyed {destroy} in square {quad}\nconnect {ip}" },
            { "alertdiscord", "Attention! Player {name} destroyed {destroy} in square {quad}\nconnect {ip}" },
            { "alertrustplus", "Attention! Player {name} destroyed {destroy} in {quad}" },
            { "alertingame", "Player {name} destroyed {destroy} in {quad}" },
            { "null", "Enter the link to your profile!" },
            { "rnnocode", "No code provided!" },
            { "rnprivate", "Your privacy settings do not allow you to send a message." },
            { "rnerror", "The message could not be sent.\nPlease check the link is correct or try again later." },
            { "rnblack", "Unable to send message.\nYou have added a group to the black list or are not subscribed to it, if this is not the case, then simply write any message to the server group and try again." },
            { "rnerror2", "You have specified an incorrect link to your VK, if this is not the case, then simply write any message to the server group and try again." },
            { "rnaddcooldown", "You recently generated a verification code, please try again in a minute." },
            { "+wall Stone", "your stone wall" },
            { "+wall.low Stone", "your low stone wall" },
            { "+wall.frame Stone", "your stone wall frame" },
            { "+foundation Stone", "your stone foundation" },
            { "+roof Stone", "your stone roof" },
            { "+wall.doorway Stone", "your stone doorway" },
            { "+foundation.steps Stone", "your stone steps" },
            { "+block.stair.lshape Stone", "your stone L-stairs" },
            { "+block.stair.ushape Stone", "your stone U-ladder" },
            { "+foundation.triangle Stone", "your stone triangular foundation" },
            { "+wall.window Stone", "your stone window" },
            { "+wall.half Stone", "your stone half-wall" },
            { "+wall Metal", "your metal wall" },
            { "+wall.low Metal", "your metal low wall" },
            { "+wall.frame Metal", "your metal wall frame" },
            { "+foundation Metal", "your metal foundation" },
            { "+roof Metal", "your metal roof" },
            { "+wall.doorway Metal", "your metal doorway" },
            { "+foundation.steps Metal", "your metal stairs" },
            { "+block.stair.lshape Metal", "your metal L-ladder" },
            { "+block.stair.ushape Metal", "your metal U-ladder" },
            { "+foundation.triangle Metal", "your metal triangular foundation" },
            { "+wall.window Metal", "your metal window" },
            { "+wall.half Metal", "your metal half wall" },
            { "+wall TopTier", "your armored wall" },
            { "+wall.low TopTier", "your armored low wall" },
            { "+wall.frame TopTier", "your armored wall frame" },
            { "+foundation TopTier", "your armored foundation" },
            { "+roof TopTier", "your armored roof" },
            { "+wall.doorway TopTier", "your armored doorway" },
            { "+foundation.steps TopTier", "your armored steps" },
            { "+block.stair.lshape TopTier", "your armored L-ladder" },
            { "+block.stair.ushape TopTier", "your armored U-ladder" },
            { "+foundation.triangle TopTier", "your armored triangular foundation" },
            { "+wall.window TopTier", "your armored window" },
            { "+wall.half TopTier", "your armored half-wall" },
            { "+wall Wood", "your wooden wall" },
            { "+wall.low Wood", "your wooden low wall" },
            { "+wall.frame Wood", "your wooden wall frame" },
            { "+foundation Wood", "your wooden foundation" },
            { "+roof Wood", "your wooden roof" },
            { "+wall.doorway Wood", "your wooden doorway" },
            { "+foundation.steps Wood", "your wooden steps" },
            { "+block.stair.lshape Wood", "your wooden L-ladder" },
            { "+block.stair.ushape Wood", "your wooden U-ladder" },
            { "+foundation.triangle Wood", "your wooden triangular foundation" },
            { "+wall.window Wood", "your wooden window" },
            { "+door.hinged.metal", "" },
            { "+floor Wood", "your metal door" },
            { "+floor Metal", "your metal floor" },
            { "+door.hinged.wood", "your wooden door" },
            { "+floor Stone", "your stone floor" },
            { "+door.double.hinged.wood", "your double wooden door" },
            { "+door.double.hinged.metal", "your double metal door" },
            { "+shutter.wood.a", "your wooden shutters" },
            { "+wall.frame.garagedoor", "your garage door" },
            { "+wall.window.bars.wood", "your wood grate" },
            { "+floor.triangle Stone", "your stone triangular ceiling" },
            { "+wall.external.high.wood", "your high wooden gate" },
            { "+door.double.hinged.toptier", "your double armored door" },
            { "+floor.triangle Metal", "your metal triangular ceiling" },
            { "+wall.frame.netting", "your frame netting wall" },
            { "+door.hinged.toptier", "your armored door" },
            { "+shutter.metal.embrasure.a", "your metal shutters" },
            { "+wall.external.high.stone", "your external high stone wall" },
            { "+gates.external.high.stone", "your external high stone gates" },
            { "+floor.ladder.hatch", "your hatch with a ladder" },
            { "+floor.grill", "your floor grill" },
            { "+floor.triangle Wood", "your wooden triangular ceiling" },
            { "+floor.triangle TopTier", "your armored triangular ceiling" },
            { "+gates.external.high.wood", "your high wooden gate" },
            { "+wall.half Wood", "your wooden half wall" },
            { "+floor TopTier", "your triangular armored ceiling" },
            { "+wall.frame.cell", "your frame wall" },
            { "+wall.window.bars.metal", "your metal grill" },
            { "+wall.frame.fence", "your frame fence" },
            { "+shutter.metal.embrasure.b", "your metal shutter embrasure" },
            { "+wall.window.glass.reinforced", "your reinforced glass window" },
            { "+wall.frame.fence.gate", "your frame fence gate" },
            { "+floor.frame Stone", "your stone floor frame" },
            { "+wall.frame.cell.gate", "your wall frame cell gate" },
            { "+floor.frame Metal", "your metal floor frame" },
            { "+floor.frame Wood", "your wooden floor frame" },
            { "+wall.frame.shopfront", "your shopfront" },
            { "+wall.window.bars.toptier", "your window bars" },
            { "+autoturret_deployed", "your autoturret" },
            { "+sam_site_turret_deployed", "your sam site turret" },
            { "+ramp TopTier", "your armored ramp" },
            { "+floor.triangle.ladder.hatch", "your triangular hatch with stairs" },
            { "+block.stair.spiral Wood", "your wooden spiral staircase" },
            { "+ramp Metal", "your metal ramp" },
            { "+block.stair.spiral.triangle Wood", "your wooden triangular spiral staircase" },
            { "+block.stair.spiral.triangle Metal", "your metal triangular spiral staircase" },
            { "+block.stair.spiral Stone", "your stone spiral staircase" },
            { "+block.stair.spiral Metal", "your metal spiral staircase" },
            { "+floor.triangle.frame Stone", "your stone triangular ceiling frame" },
            { "+roof.triangle Metal", "your metal roof" },
            { "+floor.triangle.frame Metal", "your metal triangular ceiling frame" },
            { "+block.stair.spiral.triangle Stone", "your stone triangular spiral staircase" },
            { "+block.stair.spiral.triangle TopTier", "your armored triangular spiral staircase" },
            { "+ramp Wood", "your wooden ramp" },
            { "+roof.triangle Stone", "your stone roof" },
            { "+floor.triangle.frame TopTier", "your armored triangular ceiling frame" },
            { "+door.hinged.industrial.a", "your industrial door" },
            { "+roof.triangle TopTier", "your armored roof" },
            { "+ramp Stone", "your stone ramp" },
            { "+block.stair.spiral TopTier", "your armored spiral staircase" },
            { "+roof.triangle Wood", "your wooden roof" },
            { "+floor.frame TopTier", "your armored ceiling frame" }
        };

        public Dictionary<string, string> messagesRU = new Dictionary<string, string>
        {
            { "{t0}", "Вступить в группу" },
            { "{element_vk}", "Вконтакте" },
            { "{element_telegram}", "Телеграм" },
            { "{element_discord}", "Discord" },
            { "{element_rustplus}", "Приложение Rust+" },
            { "{element_ingame}", "Графическое отображение в игре" },
            { "{element_setup}", "Подключить" },
            { "{element_disable}", "Отключить" },
            { "{element_enable}", "Включить" },
            { "permission", "У вас нет разрешения для использования этой команды!" },
            { "{t1}", "Написать любое сообщение в группу" },
            { "{t2}", "VK.COM/HAXLITE" },
            { "{t3}", "Ссылка на ваш профиль" },
            { "{t4}", "Проверьте вашу почту в vk.com и введите полученый код" },
            { "{t5}", "Вводите текст через Ctrl+V, что бы во время ввода не выполнялись команды забинженые на клавиши, которые вы нажимаете" },
            { "{t6}", "Подключение оповещения о рейдах" },
            { "{d0}", "Присоединитесь к дискорд серверу" },
            { "{d1}", "Получить код в канале 'Интеграция с игровым профилем'" },
            { "{d2}", "DISCORD.GG/CyFmAqGBED" },
            { "{d3}", "Введите полученный код" },
            { "{d5}", "Вводите текст через Ctrl+V, что бы во время ввода не выполнялись команды забинженые на клавиши, которые вы нажимаете" },
            { "{d6}", "Подключение оповещения о рейдах" },
            { "{t7}", "ВЫХОД" },
            { "{teleg0}", "Добавьте бота @userinfobot, нажмите /start и скопируйте полученный Id" },
            { "{teleg1}", "Добавьте бота {tag} и нажать /start" },
            { "{teleg2}", "{tag}" },
            { "{teleg3}", "Введите скопированный Id" },
            { "{teleg5}", "Вводите текст через Ctrl+V, что бы во время ввода не выполнялись команды забинженые на клавиши, которые вы нажимаете" },
            { "{teleg6}", "Подключение оповещения о рейдах" },
            { "{back}", "НАЗАД" },
            { "telegramuseridnotfound", "User id не найден" },
            { "telegramadd", "Теперь вы будете получать рейд-оповещение здесь" },
            { "telegid", "Введите скопированный Id!" },
            { "{amain}", "Панель управления оповещений о рейде" },
            { "{text1}", "Получить код" },
            { "code", "Код для подтверджения аккаунта: {code}." },
            { "{text2}", "Подтвердить" },
            { "notallow", "Купите возможность подключить оповещения о рейде в магазине!" },
            { "rncancel", "Неверный код!" },
            { "alertvk", "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}" },
            { "alerttelegram", "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}" },
            { "alertdiscord", "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}" },
            { "alertrustplus", "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}" },
            { "alertingame", "Игрок {name} разрушил {destroy} в квадрате {quad}" },
            { "null", "Введите ссылку на ваш профиль!" },
            { "rnnocode", "Не указали код!" },
            { "rnprivate", "Ваши настройки приватности не позволяют отправить вам сообщение." },
            { "rnerror", "Невозможно отправить сообщение.\nПроверьте правильность ссылки или повторите попытку позже." },
            { "rnblack", "Невозможно отправить сообщение.\nВы добавили группу в черный список или не подписаны на нее, если это не так, то просто напишите в группу сервера любое сообщение и попробуйте еще раз." },
            { "rnerror2", "Вы указали неверную ссылку на ваш Вк, если это не так, то просто напишите в группу сервера любое сообщение и попробуйте еще раз." },
            { "rnaddcooldown", "Вы недавно создавали код для подтверждения, попробуйте еще раз через минуту." },
            { "+wall Stone", "вашу каменную стену" },
            { "+wall.low Stone", "вашу каменную низкую стену" },
            { "+wall.frame Stone", "ваш каменный настенный каркас" },
            { "+foundation Stone", "ваш каменный фундамент" },
            { "+roof Stone", "вашу каменную крышу" },
            { "+wall.doorway Stone", "ваш каменный дверной проём" },
            { "+foundation.steps Stone", "ваши каменные ступеньки" },
            { "+block.stair.lshape Stone", "вашу каменную L-лестницу" },
            { "+block.stair.ushape Stone", "вашу каменную U-лестницу" },
            { "+foundation.triangle Stone", "ваш каменный треугольный фундамент" },
            { "+wall.window Stone", "ваше каменное окно" },
            { "+wall.half Stone", "вашу каменную полустену" },
            { "+wall Metal", "вашу металлическую стену" },
            { "+wall.low Metal", "вашу металлическую низкую стену" },
            { "+wall.frame Metal", "ваш металлический настенный каркас" },
            { "+foundation Metal", "ваш металлический фундамент" },
            { "+roof Metal", "вашу металлическую крышу" },
            { "+wall.doorway Metal", "ваш металлический дверной проём" },
            { "+foundation.steps Metal", "ваши металлические ступеньки" },
            { "+block.stair.lshape Metal", "вашу металлическую L-лестницу" },
            { "+block.stair.ushape Metal", "вашу металлическую U-лестницу" },
            { "+foundation.triangle Metal", "ваш металлический треугольный фундамент" },
            { "+wall.window Metal", "ваше металлическое окно" },
            { "+wall.half Metal", "вашу металлическую полустену" },
            { "+wall TopTier", "вашу бронированную стену" },
            { "+wall.low TopTier", "вашу бронированную низкую стену" },
            { "+wall.frame TopTier", "ваш бронированный настенный каркас" },
            { "+foundation TopTier", "ваш бронированный фундамент" },
            { "+roof TopTier", "вашу бронированную крышу" },
            { "+wall.doorway TopTier", "ваш бронированный дверной проём" },
            { "+foundation.steps TopTier", "ваши бронированные ступеньки" },
            { "+block.stair.lshape TopTier", "вашу бронированную L-лестницу" },
            { "+block.stair.ushape TopTier", "вашу бронированную U-лестницу" },
            { "+foundation.triangle TopTier", "ваш бронированный треугольный фундамент" },
            { "+wall.window TopTier", "ваше бронированное окно" },
            { "+wall.half TopTier", "вашу бронированную полустену" },
            { "+wall Wood", "вашу деревянную стену" },
            { "+wall.low Wood", "вашу деревянную низкую стену" },
            { "+wall.frame Wood", "ваш деревянный настенный каркас" },
            { "+foundation Wood", "ваш деревянный фундамент" },
            { "+roof Wood", "вашу деревянную крышу" },
            { "+wall.doorway Wood", "ваш деревянный дверной проём" },
            { "+foundation.steps Wood", "ваши деревянные ступеньки" },
            { "+block.stair.lshape Wood", "вашу деревянную L-лестницу" },
            { "+block.stair.ushape Wood", "вашу деревянную U-лестницу" },
            { "+foundation.triangle Wood", "ваш деревянный треугольный фундамент" },
            { "+wall.window Wood", "ваше деревянное окно" },
            { "+door.hinged.metal", "вашу металлическую дверь" },
            { "+floor Wood", "ваш деревянный пол" },
            { "+floor Metal", "ваш металлический пол" },
            { "+door.hinged.wood", "вашу деревянную дверь" },
            { "+floor Stone", "ваш каменный пол" },
            { "+door.double.hinged.wood", "вашу двойную деревянную дверь" },
            { "+door.double.hinged.metal", "вашу двойную металлическую дверь" },
            { "+shutter.wood.a", "ваши деревянные ставни" },
            { "+wall.frame.garagedoor", "вашу гаражную дверь" },
            { "+wall.window.bars.wood", "вашу деревянную решетку" },
            { "+floor.triangle Stone", "ваш каменный треугольный потолок" },
            { "+wall.external.high.wood", "ваши высокие деревянные ворота" },
            { "+door.double.hinged.toptier", "вашу двойную бронированную дверь" },
            { "+floor.triangle Metal", "ваш металлический треугольный потолок" },
            { "+wall.frame.netting", "вашу сетчатую стену" },
            { "+door.hinged.toptier", "вашу бронированную дверь" },
            { "+shutter.metal.embrasure.a", "ваши металлические ставни" },
            { "+wall.external.high.stone", "вашу высокую каменную стену" },
            { "+gates.external.high.stone", "ваши высокие каменные ворота" },
            { "+floor.ladder.hatch", "ваш люк с лестницей" },
            { "+floor.grill", "ваш решетчатый настил" },
            { "+floor.triangle Wood", "ваш деревянный треугольный потолок" },
            { "+floor.triangle TopTier", "ваш бронированный треугольный потолок" },
            { "+gates.external.high.wood", "ваши высокие деревянные ворота" },
            { "+wall.half Wood", "вашу деревянную полустену" },
            { "+floor TopTier", "ваш треугольный бронированный потолок" },
            { "+wall.frame.cell", "вашу тюремную стену" },
            { "+wall.window.bars.metal", "вашу металлическую решетку" },
            { "+wall.frame.fence", "ваш сетчатый забор" },
            { "+shutter.metal.embrasure.b", "вашу металлическую бойницу" },
            { "+wall.window.glass.reinforced", "ваше окно из укрепленного стекла" },
            { "+wall.frame.fence.gate", "вашу сетчатую дверь" },
            { "+floor.frame Stone", "ваш каменный потолочный каркас" },
            { "+wall.frame.cell.gate", "вашу тюремную решетку" },
            { "+floor.frame Metal", "ваш металический потолочный каркас" },
            { "+floor.frame Wood", "ваш деревянный потолочный каркас" },
            { "+wall.frame.shopfront", "вашу витрину" },
            { "+wall.window.bars.toptier", "ваши оконные решетки" },
            { "+autoturret_deployed", "вашу турель" },
            { "+sam_site_turret_deployed", "вашу зенитную турель" },
            { "+ramp TopTier", "вашу бронированную рампу" },
            { "+floor.triangle.ladder.hatch", "ваш треугольный люк с лестницей" },
            { "+block.stair.spiral Wood", "вашу деревянную спиральную лестницу" },
            { "+ramp Metal", "вашу металлическую рампу" },
            { "+block.stair.spiral.triangle Wood", "вашу деревянную треугольную спиральную лестницу" },
            { "+block.stair.spiral.triangle Metal", "вашу металлическую треугольную спиральную лестницу" },
            { "+block.stair.spiral Stone", "вашу каменную спиральную лестницу" },
            { "+block.stair.spiral Metal", "вашу металлическую спиральную лестницу" },
            { "+floor.triangle.frame Stone", "ваш каменный треугольный потолочный каркас" },
            { "+roof.triangle Metal", "вашу металлическую крышу" },
            { "+floor.triangle.frame Metal", "ваш металлический треугольный потолочный каркас" },
            { "+block.stair.spiral.triangle Stone", "вашу каменную треугольную спиральную лестницу" },
            { "+block.stair.spiral.triangle TopTier", "вашу бронированную треугольную спиральную лестницу" },
            { "+ramp Wood", "вашу деревянную рампу" },
            { "+roof.triangle Stone", "вашу каменную крышу" },
            { "+floor.triangle.frame TopTier", "ваш бронированный треугольный потолочный каркас" },
            { "+door.hinged.industrial.a", "вашу промышленную дверь" },
            { "+roof.triangle TopTier", "вашу бронированную крышу" },
            { "+ramp Stone", "вашу каменную  рампу" },
            { "+block.stair.spiral TopTier", "вашу бронированную спиральную лестницу" },
            { "+roof.triangle Wood", "вашу деревянную крышу" },
            { "+floor.frame TopTier", "ваш бронированный потолочный каркас" }
        };

        IEnumerator GetCallback()
        {
            if (config.discord.link == null)
            {
                config.discord.link = GetMessage("{t2}", "0");
                if (config.vk.link == "{t2}") config.vk.link = "VK.COM/YOURLINK";
            }

            if (config.vk.link == null)
            {
                config.vk.link = GetMessage("{d2}", "0");
                if (config.vk.link == "{d2}") config.vk.link = "DISCORD.GG/YOURLINK";
            }
            SaveConfig();

            lang.RegisterMessages(messagesEN, this, "en");
            lang.RegisterMessages(messagesRU, this, "ru");
            perm = Name + ".use";
            permission.RegisterPermission(perm, this);

            FON = "[{\"name\":\"Main_UI\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"NeedsCursor\"},{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\",\"material\":\"assets/content/ui/uibackgroundblur.mat\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{color}", config.ui.background);
            MAIN = "[{\"name\":\"SubContent_UI\",\"parent\":\"Main_UI\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.6\",\"anchormax\":\"0.5 0.6\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]";
            UI = "[{\"name\":\"IF\",\"parent\":\"SubContent_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{rectangularcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-120 -100\",\"offsetmax\":\"120 -70\"}]},{\"name\":\"D\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 1\"}]},{\"name\":\"U\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 0\"}]},{\"name\":\"R\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"-1 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"I\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.InputField\",\"align\":\"MiddleLeft\",\"color\":\"{colorcontainertext}\",\"command\":\"raid.input\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"L1\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-40 17\",\"offsetmax\":\"-5 18\"}]},{\"name\":\"L4\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-40 84\",\"offsetmax\":\"-5 85\"}]},{\"name\":\"P1\",\"parent\":\"L4\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{rectangularcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -15\",\"offsetmax\":\"245 15\"}]},{\"name\":\"D\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 1\"}]},{\"name\":\"U\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 0\"}]},{\"name\":\"R\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"-1 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"T\",\"parent\":\"P1\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t2}\",\"align\":\"MiddleCenter\",\"color\":\"{colorcontainertext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"L5\",\"parent\":\"L4\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 35\"}]},{\"name\":\"L6\",\"parent\":\"L5\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"35 1\"}]},{\"name\":\"T\",\"parent\":\"L6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t1}\", \"color\":\"{colortext}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"align\":\"MiddleLeft\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -10\",\"offsetmax\":\"720 10\"}]},{\"name\":\"L7\",\"parent\":\"L5\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 35\"}]},{\"name\":\"L8\",\"parent\":\"L7\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"35 1\"}]},{\"name\":\"T\",\"parent\":\"L8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t0}\", \"color\":\"{colortext}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"align\":\"MiddleLeft\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -10\",\"offsetmax\":\"720 10\"}]},{\"name\":\"H\",\"parent\":\"L7\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t6}\", \"color\":\"{colorheader}\",\"fontSize\":24},{\"type\":\"RectTransform\",\"anchormin\":\"40 1\",\"anchormax\":\"720 1\",\"offsetmin\":\"0 20\",\"offsetmax\":\"0 60\"}]},{\"name\":\"L2\",\"parent\":\"L1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 35\"}]},{\"name\":\"L3\",\"parent\":\"L2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"35 1\"}]},{\"name\":\"T1\",\"parent\":\"L3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t4}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"align\":\"MiddleLeft\",\"color\":\"{colortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -10\",\"offsetmax\":\"720 10\"}]},{\"name\":\"DESC\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t5}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"color\":\"{colordesctext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"-160 -200\",\"offsetmax\":\"250 -100\"}]}]".Replace("{colorline}", config.ui.stripcolor).Replace("{rectangularcolor}", config.ui.rectangularcolor).Replace("{colordesctext}", config.ui.hintstextcolor).Replace("{colortext}", config.ui.textcolor).Replace("{colorcontainertext}", config.ui.rectangulartextcolor).Replace("{colorheader}", config.ui.headertextcolor).Replace("{colordesctext}", config.ui.hintstextcolor);
            IF2 = "[{\"name\":\"IF2\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{rectangularcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"-120 -70\",\"offsetmax\":\"120 -40\"}]},{\"name\":\"D\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 1\"}]},{\"name\":\"U\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 0\"}]},{\"name\":\"R\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"-1 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"I\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.InputField\",\"command\":\"raid.input\",\"align\":\"MiddleLeft\",\"color\":\"{colorcontainertext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"BTN2\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"raid.accept\",\"color\":\"{greenbuttoncolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 -30\",\"offsetmax\":\"125 0\"}]},{\"name\":\"T\",\"parent\":\"BTN2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text2}\",\"align\":\"MiddleCenter\",\"color\":\"{buttoncolortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L1\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-40 17\",\"offsetmax\":\"-5 18\"}]},{\"name\":\"L2\",\"parent\":\"L1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 35\"}]},{\"name\":\"L3\",\"parent\":\"L2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"35 1\"}]},{\"name\":\"T1\",\"parent\":\"L3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t3}\",\"font\":\"RobotoCondensed-Regular.ttf\",\"align\":\"MiddleLeft\",\"color\":\"{colortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 -10\",\"offsetmax\":\"500 10\"}]}]".Replace("{rectangularcolor}", config.ui.rectangularcolor).Replace("{colorline}", config.ui.stripcolor).Replace("{colorcontainertext}", config.ui.rectangulartextcolor).Replace("{colortext}", config.ui.textcolor).Replace("{greenbuttoncolor}", config.ui.greenbuttoncolor).Replace("{buttoncolortext}", config.ui.buttoncolortext);
            IF2A = "[{\"name\":\"BTN2\",\"parent\":\"IF2\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{coma}\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 -30\",\"offsetmax\":\"125 0\"}]},{\"name\":\"T\",\"parent\":\"BTN2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text2}\",\"align\":\"MiddleCenter\",\"color\":\"{buttoncolortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{buttoncolortext}", config.ui.buttoncolortext);
            BTN = "[{\"name\":\"BTN\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{coma}\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 -30\",\"offsetmax\":\"125 0\"}]},{\"name\":\"T\",\"parent\":\"BTN\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text1}\",\"align\":\"MiddleCenter\",\"color\":\"{buttoncolortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{buttoncolortext}", config.ui.buttoncolortext);
            ER = "[{\"name\":\"ER\",\"parent\":\"IF\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{e0}\",\"fontSize\":16,\"font\":\"RobotoCondensed-Regular.ttf\",\"color\":\"{errortextcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-160 -95\",\"offsetmax\":\"245 -35\"}]}]".Replace("{errortextcolor}", config.ui.errortextcolor);
            MAINH = "[{\"name\":\"AG\",\"parent\":\"SubContent_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{a0}\",\"fontSize\":24},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-155 60\",\"offsetmax\":\"500 115\"}]}]";
            IBLOCK = "[{\"name\":\"E\",\"parent\":\"Main_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"Main_UI\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"-300 -100\",\"offsetmax\":\"-150 -50\"}]},{\"name\":\"ET\",\"parent\":\"E\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t7}\",\"fontSize\":30,\"align\":\"MiddleCenter\",\"color\":\"{colortextexit}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"10 0\",\"offsetmax\":\"0 0\"}]}]";
            BACK = "[{\"name\":\"E\",\"parent\":\"Main_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /raid\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"-300 -100\",\"offsetmax\":\"-150 -50\"}]},{\"name\":\"ET\",\"parent\":\"E\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t7}\",\"fontSize\":30,\"align\":\"MiddleCenter\",\"color\":\"{colortextexit}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"10 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{colortextexit}", config.ui.colortextexit);
            EXIT = "[{\"name\":\"E\",\"parent\":\"Main_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"Main_UI\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"-300 -100\",\"offsetmax\":\"-150 -50\"}]},{\"name\":\"ET\",\"parent\":\"E\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{t7}\",\"fontSize\":30,\"align\":\"MiddleCenter\",\"color\":\"{colortextexit}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"10 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{colortextexit}", config.ui.colortextexit);
            AG = "[{\"name\":\"AGG{num}\",\"parent\":\"SubContent_UI\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{rectangularcolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 0\",\"offsetmin\":\"-120 {min}\",\"offsetmax\":\"120 {max}\"}]},{\"name\":\"D\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 1\"}]},{\"name\":\"R\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"-1 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"U\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 -1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"L\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{colorline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 0\"}]},{\"name\":\"AT\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{id}\",\"align\":\"MiddleLeft\",\"color\":\"{colorcontainertext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"5 0\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"BTN{num}\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{coma}\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0\",\"anchormax\":\"1 0\",\"offsetmin\":\"5 0\",\"offsetmax\":\"125 30\"}]},{\"name\":\"T\",\"parent\":\"BTN{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text1}\",\"align\":\"MiddleCenter\",\"color\":\"{buttoncolortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"AL\",\"parent\":\"AGG{num}\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{icocolor}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"-35 -30\",\"offsetmax\":\"-5 0\"}]},{\"name\":\"ALT\",\"parent\":\"AL\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{ico}\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]".Replace("{colorline}", config.ui.stripcolor).Replace("{rectangularcolor}", config.ui.rectangularcolor).Replace("{colorcontainertext}", config.ui.rectangulartextcolor).Replace("{buttoncolortext}", config.ui.buttoncolortext);

            if (!string.IsNullOrEmpty(config.discord.token)) CreateClient();
            else Debug.LogError(fermensEN ? "AALERTRAID - TOKEN FOR DISCORD BOT IS NULL!" : "AALERTRAID - Не указан токен для Discord бота!");

            connect = ConVar.Server.ip + ":" + ConVar.Server.port;
            CreateSpawnGrid();

            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("raid", this, "callcommandrn");

            Debug.Log(">>AlertRaid<< OK!");

            yield break;
        }
        #endregion

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null) return;
            BasePlayer player = info.InitiatorPlayer;
            if (player == null) return;
            if (entity is BuildingBlock)
            {
                int tt = (int)(entity as BuildingBlock).grade;
                if (tt <= 0) return;
                ServerMgr.Instance.StartCoroutine(Alerting(entity, player, tt));
            }
            else if (config.extralist && (entity is DecayEntity || entity is IOEntity) || entity is AnimatedBuildingBlock || entity is SamSite || entity is AutoTurret || config.spisok.Contains(entity.ShortPrefabName))
            {
                ServerMgr.Instance.StartCoroutine(Alerting(entity, player));
            }
        }
        #endregion

        #region FUNCTIONS

        private IEnumerator Alerting(BaseCombatEntity entity, BasePlayer player, int tt = 0)
        {
            Vector3 position = entity.transform.position;
            string dname = entity.ShortPrefabName;

            if (tt == 1) dname += " Wood";
            else if (tt == 2) dname += " Stone";
            else if (tt == 3) dname += " Metal";
            else if (tt == 4) dname += " TopTier";

            BuildingPrivlidge buildingPrivlidge = entity is BuildingPrivlidge ? entity as BuildingPrivlidge : entity.GetBuildingPrivilege(entity.WorldSpaceBounds());
            if (buildingPrivlidge == null) yield break;
            if (!buildingPrivlidge.AnyAuthed()) yield break;

            var list = buildingPrivlidge.authorizedPlayers.ToList();

            yield return CoroutineEx.waitForSeconds(0.5f);

            string name = player.displayName;
            string attackerid = player.UserIDString;
            string quad = GetNameGrid(position);
            string connect = ConVar.Server.ip + ":" + ConVar.Server.port;

            string key = "+" + dname;

            foreach (var z in list)
            {
                string destroy = GetMessage(key, z.userid.ToString());
                if (destroy == key) destroy = entity.ShortPrefabName.Replace(".deployed", "");

                ALERTPLAYER(z.userid, name, quad, connect, destroy, attackerid);

                yield return CoroutineEx.waitForEndOfFrame;
            }
        }

        List<ulong> block = new List<ulong>();
        private void ALERTPLAYER(ulong ID, string name, string quad, string connect, string destroy, string attackerid)
        {
            string IDstring = ID.ToString();

            if (!HasAcces(IDstring)) return;

            ALERT alert;
            if (!alerts.TryGetValue(ID, out alert))
            {
                alerts.Add(ID, new ALERT());
                alert = alerts[ID];
            }
            Storage storage = GetStorage(ID);

            #region ОПОВЕЩЕНИЕ В ВК
            if (config.vk.enable && !string.IsNullOrEmpty(config.vk.api) && alert.vkcooldown < DateTime.Now)
            {
                if (!string.IsNullOrEmpty(storage.vk))
                {
                    GetRequest(storage.vk, GetMessage("alertvk", IDstring).Replace("{ip}", connect).Replace("{steamid}", attackerid).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername));
                    alert.vkcooldown = DateTime.Now.AddSeconds(config.vk.cooldown);
                }
            }
            #endregion

            #region ОПОВЕЩЕНИЕ В ТЕЛЕГРАМ
            if (config.telegram.enable && !string.IsNullOrEmpty(config.telegram.token) && alert.telegramcooldown < DateTime.Now)
            {
                if (!string.IsNullOrEmpty(storage.telegram))
                {
                    GetRequestTelegram(storage.telegram, GetMessage("alerttelegram", IDstring).Replace("{ip}", connect).Replace("{steamid}", attackerid).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername));
                    alert.telegramcooldown = DateTime.Now.AddSeconds(config.telegram.cooldown);
                }
            }
            #endregion

            #region ОПОВЕЩЕНИЕ В RUST+
            if (!string.IsNullOrEmpty(App.serverid) && App.port > 0 && App.notifications && storage.rustplus && config.rustplus.enable && alert.rustpluscooldown < DateTime.Now)
            {
                NotificationList.SendNotificationTo(ID, NotificationChannel.SmartAlarm, GetMessage("alertrustplus", IDstring).Replace("{steamid}", attackerid).Replace("{ip}", connect).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername), config.servername, Util.GetServerPairingData());
                alert.rustpluscooldown = DateTime.Now.AddSeconds(config.rustplus.cooldown);
            }
            #endregion

            #region ОПОВЕЩЕНИЕ В DISCORD
            if (config.discord.enable && !block.Contains(ID) && !string.IsNullOrEmpty(config.discord.token) && alert.discordcooldown < DateTime.Now)
            {
                if (storage.discord != 0UL)
                {
                    Snowflake ss = new Snowflake(storage.discord);
                    if (!_guild.Members.Any(x => x.Value.User.Id == ss))
                        return;

                    var user = _guild.Members.First(x => x.Value.User.Id == ss).Value.User;
                    try
                    {
                        // Формируем сообщение
                        string messageContent = GetMessage("alertdiscord", IDstring)
                            .Replace("{steamid}", attackerid)
                            .Replace("{ip}", connect)
                            .Replace("{name}", name)
                            .Replace("{destroy}", destroy)
                            .Replace("{quad}", quad)
                            .Replace("{servername}", config.servername);

                        // Отправляем сообщение
                        user.SendDirectMessage(Client, new MessageCreate
                        {
                            Content = messageContent
                        });

                        // Устанавливаем cooldown
                        alert.discordcooldown = DateTime.Now.AddSeconds(config.discord.cooldown);
                    }
                    catch (Exception ex)
                    {
                        // Обрабатываем известную ошибку 50007 (не удается отправить сообщение пользователю)
                        if (ex.Message.Contains("50007"))
                        {
                            block.Add(ID);
                        }
                        else
                        {
                            // Логируем любую другую ошибку для отладки
                            Puts($"Ошибка при отправке сообщения: {ex.Message}");
                        }
                    }
                }
            }
            #endregion

            #region ОПОВЕЩЕНИЕ В ИГРЕ
            if (storage.ingamerust && config.ingame.enable && alert.gamecooldown < DateTime.Now)
            {
                BasePlayer player = BasePlayer.FindByID(ID);
                if (player != null && player.IsConnected)
                {
                    Timer ss;
                    if (timal.TryGetValue(player.userID, out ss))
                    {
                        if (!ss.Destroyed) ss.Destroy();
                    }
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "UIA");
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", config.ingame.UI.Replace("{text}", GetMessage("alertingame", IDstring).Replace("{steamid}", attackerid).Replace("{ip}", connect).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername)));
                    if (!string.IsNullOrEmpty(config.ingame.effect)) EffectNetwork.Send(new Effect(config.ingame.effect, player, 0, Vector3.up, Vector3.zero) { scale = 1f }, player.net.connection);
                    timal[player.userID] = timer.Once(config.ingame.destroy, () => CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "UIA"));
                    alert.gamecooldown = DateTime.Now.AddSeconds(config.ingame.cooldown);
                }
            }
            #endregion
        }

        private Dictionary<ulong, Timer> timal = new Dictionary<ulong, Timer>();
        #endregion

        #region Lang
        private string GetMessage(string key, string userId) => lang.GetMessage(key, this, userId);
        #endregion

        #region GRID
        private static Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        private void CreateSpawnGrid()
        {
            Grids.Clear();
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (0.0066666666666667f * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz + 20f));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos) => Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        #endregion
    }
}
/* Boosty - https://boosty.to/skulidropek 
Discord - https://discord.gg/k3hXsVua7Q 
Discord The Rust Bay - https://discord.gg/Zq3TVjxKWk  */

// --- End of file: AAlertRaid-1.0.0.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TimedItemsBlocker.cs ---
// --- Original Local Path: TimedItemsBlocker.cs ---

using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TimedItemsBlocker", "Vlad-00003", "1.0.0")]
    [Description("Prevents some items from being used for a limited period of time.")]
    //Author info:
    //E-mail: Vlad-00003@mail.ru
    //Vk: vk.com/vlad_00003

    class TimedItemsBlocker : RustPlugin
    {

        #region Config setup
        //private Dictionary<BasePlayer, string> Panels = new Dictionary<BasePlayer, string>();
        private string PanelName = "BlockerUI";
        private Dictionary<string, int> BlockedItems = new Dictionary<string, int>();
        private Dictionary<string, int> BlockedClothes = new Dictionary<string, int>();
        private DateTime DateOfWipe;
        private bool UseChat = false;
        private bool Wipe = false;
        private string Prefix = "[Items Blocker]";
        private string PrefixColor = "#f44253";
        private string BypassPermission = "timeditemsblocker.bypass";

        #endregion

        #region Init

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created, Block Start now and will remain for 30 hours. You can change it into the config.");
        }

        private void LoadConfigValues()
        {
            Dictionary<string, object> blockedItems = new Dictionary<string, object>()
            {
                ["Satchel Charge"] = 30,
                ["Timed Explosive Charge"] = 30,
                ["Eoka Pistol"] = 30,
                ["Custom SMG"] = 30,
                ["Assault Rifle"] = 30,
                ["Bolt Action Rifle"] = 30,
                ["Waterpipe Shotgun"] = 30,
                ["Revolver"] = 30,
                ["Thompson"] = 30,
                ["Semi-Automatic Rifle"] = 30,
                ["Semi-Automatic Pistol"] = 30,
                ["Pump Shotgun"] = 30,
                ["M249"] = 30,
                ["Rocket Launcher"] = 30,
                ["Flame Thrower"] = 30,
                ["Double Barrel Shotgun"] = 30,
                ["Beancan Grenade"] = 30,
                ["F1 Grenade"] = 30,
                ["MP5A4"] = 30,
                ["LR-300 Assault Rifle"] = 30,
                ["M92 Pistol"] = 30,
                ["Python Revolver"] = 30
            };
            Dictionary<string, object> blockedClothes = new Dictionary<string, object>()
            {
                ["Metal Facemask"] = 30,
                ["Road Sign Kilt"] = 30,
                ["Road Sign Jacket"] = 30,
                ["Metal Chest Plate"] = 30,
                ["Heavy Plate Pants"] = 30,
                ["Heavy Plate Jacket"] = 30,
                ["Heavy Plate Helmet"] = 30,
                ["Riot Helmet"] = 30,
                ["Bucket Helmet"] = 30,
                ["Coffee Can Helmet"] = 30
            };
            DateOfWipe = DateTime.Now;
            string DateOfWipeStr = DateOfWipe.ToString("dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture);

            GetConfig("Wipe date", ref DateOfWipeStr);
            GetConfig("Bypass permission", ref BypassPermission);
            GetConfig("Wipe?(If set to true all timers would be automaticly set to current time + Hours of block", ref Wipe);
            GetConfig("Chat prefix", ref Prefix);
            GetConfig("Chat prefix color", ref PrefixColor);
            GetConfig("Use chat insted of GUI", ref UseChat);
            GetConfig("List of blocked items", ref blockedItems);
            GetConfig("List of blocked clothes", ref blockedClothes);
            SaveConfig();

            foreach (var item in blockedItems)
            {
                int hour;
                if(!int.TryParse(item.Value.ToString(), out hour))
                {
                    PrintWarning($"Item {item} has incorrect time format. Shoud be int");
                    continue;
                }
                BlockedItems.Add(item.Key, hour);
            }
            foreach(var item in blockedClothes)
            {
                int hour;
                if(!int.TryParse(item.Value.ToString(), out hour))
                {
                    PrintWarning($"Item {item} has incorrect time format. Shoud be int");
                    continue;
                }
                BlockedClothes.Add(item.Key, hour);
            }
            if (!DateTime.TryParseExact(DateOfWipeStr, "dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateOfWipe))
            {
                DateOfWipe = DateTime.Now;
                PrintWarning($"Unable to parse Wipe date format, wipe date set to {DateOfWipe.ToString("dd.MM.yyyy HH:mm:ss")}");
            }
        }

        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"ItemBlocked", "Using this item is blocked!"},
                {"BlockTimeLeft","{0}d {1:00}:{2:00}:{3:00} until unblock." },
                {"Weapon line 2", "You can only use Hunting bow and Crossbow" },
                {"Cloth line 2","You can only use wood and bone armor!" }
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"ItemBlocked", "Использование данного предмета заблокировано!"},
                {"BlockTimeLeft", "До окончания блокировки осталось {0}д. {1:00}:{2:00}:{3:00}" },
                {"Weapon line 2", "Вы можете использовать только Лук и Арбалет" },
                {"Cloth line 2","Используйте только деревянную и костяную броню!" }
            }, this, "ru");
        }

        void Loaded()
        {
            LoadConfigValues();
            LoadMessages();
            if (Wipe)
            {
                DateOfWipe = DateTime.Now;
                string DateOfWipeStr = DateOfWipe.ToString("dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture);
                Config["Wipe date"] = DateOfWipeStr;
                Config["Wipe?(If set to true all timers would be automaticly set to current time + Hours of block"] = false;
                SaveConfig();
            }
            permission.RegisterPermission(BypassPermission, this);
        }

        #endregion

        #region Equipcontrol

        object CanEquipItem(PlayerInventory inventory, Item item)
        {
            string name = null;
            if (BlockedItems.ContainsKey(item.info.displayName.english))
            {
                name = item.info.displayName.english;
            }
            if(BlockedItems.ContainsKey(item.info.shortname))
            {
                name = item.info.shortname;
            }
            if(name != null)
            {
                int BlockEnd = BlockedItems[name];
                if (InBlock(BlockEnd))
                {
                    TimeSpan timeleft = TimeLeft(BlockEnd);
                    var player = inventory.GetComponent<BasePlayer>();
                    if (permission.UserHasPermission(player.UserIDString, BypassPermission))
                        return null;
                    string reply = GetMsg("ItemBlocked", player.UserIDString) + "\n";
                    reply += string.Format(GetMsg("BlockTimeLeft", player.UserIDString), timeleft.Days, timeleft.Hours, timeleft.Minutes, timeleft.Seconds);
                    reply += "\n" + GetMsg("Weapon line 2", player.UserIDString);
                    if (UseChat)
                    {
                        SendToChat(player, reply);
                    }
                    else
                    {
                        BlockerUi(player, reply);
                    }                    
                    return false;
                }
            }
            return null;
        }

        object CanWearItem(PlayerInventory inventory, Item item)
        {
            string name = null;
            if (BlockedClothes.ContainsKey(item.info.displayName.english))
            {
                name = item.info.displayName.english;
            }
            if (BlockedClothes.ContainsKey(item.info.shortname))
            {
                name = item.info.shortname;
            }
            if (name != null)
            {
                int BlockEnd = BlockedClothes[name];
                if (InBlock(BlockEnd))
                {
                    TimeSpan timeleft = TimeLeft(BlockEnd);
                    var player = inventory.GetComponent<BasePlayer>();
                    if (permission.UserHasPermission(player.UserIDString, BypassPermission))
                        return null;
                    string reply = GetMsg("ItemBlocked", player.UserIDString) + "\n";
                    reply += string.Format(GetMsg("BlockTimeLeft", player.UserIDString), timeleft.Days, timeleft.Hours, timeleft.Minutes, timeleft.Seconds);
                    reply += "\n" + GetMsg("Cloth line 2", player.UserIDString);
                    if (UseChat)
                    {
                        SendToChat(player, reply);
                    }else
                    {
                        BlockerUi(player, reply);
                    }                    
                    return false;
                }
            }
            return null;
        }

        #endregion

        #region Blocker UI

        private void BlockerUi(BasePlayer player, string inputText)
        {
            CuiHelper.DestroyUi(player, PanelName);
            var elements = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image =
                        {
                            Color = "0.1 0.1 0.1 0.5"
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                        CursorEnabled = true
                    },
                    new CuiElement().Parent = "Overlay", PanelName
                }
            };
            elements.Add(new CuiButton
            {
                Button =
                {
                    Close = PanelName,
                    Color = "0.8 0.8 0.8 0"
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                },
                Text =
                {
                    Text = "",
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                }
            }, PanelName);
            elements.Add(new CuiLabel
            {
                Text =
                {
                    Text = inputText,
                    FontSize = 16,
                    Align = TextAnchor.MiddleCenter,
                    Color = "0.443 0.867 0.941 1.0"
                },
                RectTransform =
                {
                    AnchorMin = "0.35 0.47",
                    AnchorMax = "0.65 0.57"
                }
            }, PanelName);
            CuiHelper.AddUi(player, elements);
            //timer.Once(1f, () =>
            //{
            //    BlockerUi(player, inputText);
            //});
        }

        #endregion

        #region Helpers
        private bool InBlock(int EndTime)
        {
            if (TimeLeft(EndTime).TotalSeconds >= 0)
            {
                return true;
            }
            return false;
        }
        TimeSpan TimeLeft(int hours) => DateOfWipe.AddHours(hours).Subtract(DateTime.Now);
        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());
        string TimeToString (DateTime time) => time.ToString("dd.MM.yyyy HH:mm:ss", CultureInfo.InvariantCulture);
        //Функция, отправляющая сообщение в чат конкретному пользователю, добавляет префикс
        private void SendToChat(BasePlayer Player, string Message)
        {
            PrintToChat(Player, "<color=" + PrefixColor + ">" + Prefix + "</color> " + Message);
        }

        //Перезгрузка функции отправки собщения в чат - отправляет сообщение всем пользователям
        private void SendToChat(string Message)
        {
            PrintToChat("<color=" + PrefixColor + ">" + Prefix + "</color> " + Message);
        }
        private void GetConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null)
            {
                var = (T)Convert.ChangeType(Config[Key], typeof(T));
            }
            Config[Key] = var;
        }
        //private void GetConfig<T>(ref T value, params object[] args)
        //{
        //    List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
        //    if (Config.Get(stringArgs.ToArray()) != null)
        //    {
        //        value = (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        //    }
        //    Config.Set(args, value);
        //}
        #endregion
    }
}


// --- End of file: TimedItemsBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Purge.cs ---
// --- Original Local Path: Purge.cs ---

using System;
using UnityEngine;
using Oxide.Core.Plugins;
using Rust;

namespace Oxide.Plugins {
    [Info("Purge", "innominata", "0.0.1")] //concept by /u/leftysix on reddit.com/r/playrust
    class Purge : RustPlugin {
        public int sunset = 18; // hour to start purge
        public int sunrise = 8; // hour to end purge
        private int tickCount = 0;
        private bool night;
        
        void startPurge() {
            Announce("Night has fallen. PVP Enabled. Buildings Take Damage.");
        }
        void endPurge() {
            Announce("Night has ended. PVP Disabled. Buildings Invulnerable.");
        }

        private bool isNight(){
        	return !(isDay());
        }
        private bool isDay(){
        	return (TOD_Sky.Instance.Cycle.Hour <= sunset && TOD_Sky.Instance.Cycle.Hour >= sunrise);
        }

        private void checkTime(){
        	if (isNight() && night) return;
        	if (isDay() && !night)  return;
        	if (isDay() && night) { 
        		night = false;
        		endPurge();
        	 	return; }
        	if (isNight() && !night) { 
        		night = true;
        		startPurge();
        		return; 
        	}
        }

        [HookMethod("OnTick")]
        private void OnTick() {
            try {
                if (tickCount < 60) {
                	tickCount++;
                }
                else {
                	checkTime();
                	tickCount = 0;
                }
            }
            catch (Exception ex) {
                PrintError("{0}: {1}", Title,"OnTick failed: " + ex.Message); //Sure, lets keep this in, just in case :)
            }
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
        	if (night) return; //Free for all
			if (entity is BasePlayer && info.Initiator == null) return; //World damage (Drowning, falling, radiation...)
			if (!(entity is BasePlayer)) {
	        	string name = entity.name.ToString();
	        	if (name.Contains("loot")) return; //We want loot barrels to be breakable during day

	            var block = entity as BuildingBlock;
	            if (block) {
	            	if (block.grade.ToString() == "Twigs") return; //We want to be able to use twigs as building templates
	            }
	        }
            info.damageTypes = new DamageTypeList(); //Otherwise set all damages to 0
        }

        private void Announce(string msg) {
            foreach (BasePlayer player in BasePlayer.activePlayerList) {
                SendReply(player, msg);
            }
        }
    }

}



// --- End of file: Purge.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XL96Plus.cs ---
// --- Original Local Path: XL96Plus.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XL96Plus", "Я", "1.0.1")]
    class XL96Plus : RustPlugin
	{		
		#region Configuration

        private L96Config config;

        private class L96Config
        {				
			internal class L96Setting
            {
                [JsonProperty("SkinID улучшенной винтовки")]
                public ulong SkinIDL96;
				[JsonProperty("Имя улучшенной винтовки")]
                public string NameL96;						
            }			
			
			internal class SettingsSetting
            {
                [JsonProperty("Убивать игрока при попадании в голову")]
                public bool KillL96;                
				[JsonProperty("Оставлять 1-хп при попадании в в тело")]
                public bool HealL96;
				[JsonProperty("Включить выпадение улучшенной винтовки из ящиков с определенным шансом")] 
                public bool CrateL96;				
				[JsonProperty("Сбивать регенерацию")] 
                public bool PendingHealth;				
            } 

			internal class Crates
			{
				[JsonProperty("Имя ящика")]
                public string NameCrate = "crate_normal";				
				[JsonProperty("Шанс выпадения")]
                public int ChanceDrop;				
				[JsonProperty("Износ улучшенной винтовки. 60.0 - 100%")]
                public float MConditionL96;				
				[JsonProperty("ХП улучшенной винтовки. 60.0 - 100%")]
                public float ConditionL96;	
			}			
            
			[JsonProperty("Настройка улучшенной винтовки")]
            public L96Setting L96 = new L96Setting();			
			[JsonProperty("Общее")]
            public SettingsSetting Settings = new SettingsSetting();
			[JsonProperty("Настройка шанса выпадения в ящиках")]
            public List<Crates> Crate = new List<Crates>();			

			public static L96Config GetNewConfiguration()
            {
                return new L96Config
                {
					L96 = new L96Setting
					{
						SkinIDL96 = 2132508217,
						NameL96 = "ПУШКА ГОНКА Marllboro",
					},
					Settings = new SettingsSetting
					{
						KillL96 = true,
						HealL96 = true,
						CrateL96 = false,
						PendingHealth = false
					},
					Crate = new List<Crates>
					{
						new Crates
						{
							NameCrate = "foodbox",
							ChanceDrop = 15,
							MConditionL96 = 0.1f,
							ConditionL96 = 0.1f
						},						
						new Crates
						{
							NameCrate = "crate_normal_2",
							ChanceDrop = 5,
							MConditionL96 = 0.1f,
							ConditionL96 = 0.1f
						}
					}
				};
			}			
        }

        protected override void LoadDefaultConfig()
        {
            config = L96Config.GetNewConfiguration();

            PrintWarning("Создание начальной конфигурации плагина!!!");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<L96Config>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion	

        #region Commands
		
		[ConsoleCommand("w_give")]
        void GlovesGive(ConsoleSystem.Arg args)
        {
			if (args.Player() != null) return;
						
			BasePlayer player = BasePlayer.FindByID(ulong.Parse(args.Args[0]));

			if (player == null) return;
			
            Item item = ItemManager.CreateByName("rifle.l96", 1, config.L96.SkinIDL96);
            item.name = config.L96.NameL96;
			item.maxCondition = float.Parse(args.Args[1]);			
			item.condition = float.Parse(args.Args[2]);
			
            player.GiveItem(item);
        }
			
		#endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{
			PrintWarning("\n-----------------------------\n" +
			"     Author - https://topplugin.ru/\n" +
			"     VK - https://vk.com/rustnastroika\n" +
			"     Config - v.2369\n" +
			"-----------------------------");
		}
		
		void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			BasePlayer player = info.InitiatorPlayer;
			Item weapon = player?.GetActiveItem();
			var eplayer = entity as BasePlayer;
			
			if (entity == null || info == null || player == null || eplayer == null || weapon == null) return;
			
			if (player == eplayer) return;
			
			if (weapon.skin == config.L96.SkinIDL96)
			{				
				if (eplayer.health < 5) return;
					
				if (info.isHeadshot)
				{
					if (config.Settings.KillL96)
					{
					    info.damageTypes.Set(info.damageTypes.GetMajorityDamageType(), 1000f);
					}
				}
				else
				{
					if (config.Settings.HealL96)
					{
					    info.damageTypes.Set(info.damageTypes.GetMajorityDamageType(), 1000f);
					    eplayer.health = 0;
						
						if (config.Settings.PendingHealth) eplayer.metabolism.pending_health.value = 0;
					}
				}
			}
		}
		
		#endregion
		
		#region L96
		
		private void OnLootSpawn(LootContainer lootContainer)
		{
			if (config.Settings.CrateL96)
		    {
			    for (int i = 0; i < config.Crate.Count; i++)
			    {
				    if (config.Crate[i].NameCrate == lootContainer.ShortPrefabName)
				    {
	                    if (config.Crate[i].NameCrate.Contains(lootContainer.ShortPrefabName))
                        {
                            if (UnityEngine.Random.Range(0, 100) <= config.Crate[i].ChanceDrop)
                            {
                                Item item = ItemManager.CreateByName("rifle.l96", 1, config.L96.SkinIDL96);
                                item.name = config.L96.NameL96;
								item.maxCondition = config.Crate[i].MConditionL96;			
			                    item.condition = config.Crate[i].ConditionL96;
								
                                item.MoveToContainer(lootContainer.inventory);
                            }
                        }
				    }
			    }
		    }
		}
		
		#endregion
	}
}

// --- End of file: XL96Plus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GatherPlus.cs ---
// --- Original Local Path: GatherPlus.cs ---

using System; using System.Collections.Generic; using Oxide.Core; using Oxide.Core.Plugins; using UnityEngine; using System.Linq; using Newtonsoft.Json; namespace Oxide.Plugins { [Info("GatherPlus", "TopPlugin.ru", "1.0.7")] class GatherPlus : RustPlugin { private Dictionary<ulong, List<string>> TYReHSqOfhKNYycZjKGW = new Dictionary<ulong, List<string>>(); private bool xMdWdaMcelnqZnUuvuOsHR = false; private void Init() { jZoFNoouxQhUThiNJqLltoHJD(); var yFGvmEQGvzngCm = false; if (SPHgwVuINoiDcmDXsr.CqIOOIesPdbhnhrMuKHyq == null) { SPHgwVuINoiDcmDXsr.YePbxylRVLx = 1f; SPHgwVuINoiDcmDXsr.aiuVXFJwFIcdLiNxGeGGBAfI = 1f; SPHgwVuINoiDcmDXsr.CqIOOIesPdbhnhrMuKHyq = new Dictionary<string, float>() { { "High Quality Metal Ore", 1f }, { "Metal Fragments", 1f }, { "Metal Ore", 1f }, { "Stones", 1f }, { "Sulfur Ore", 1f } }; yFGvmEQGvzngCm = true; } if (yFGvmEQGvzngCm) hjsHLbYXjEvKDwaSsfAyDa(SPHgwVuINoiDcmDXsr); LoadDefaultMessages(); foreach(var TZFkeqqdgsaloEVqSgnOkQDyPaYSD in SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Keys) permission.RegisterPermission(TZFkeqqdgsaloEVqSgnOkQDyPaYSD.ToLower(), this); } private void OnPlayerConnected(BasePlayer ruBBmSHSLwcJlcApwXQPCmW) => yiVutxeRQI(ruBBmSHSLwcJlcApwXQPCmW.UserIDString); private void OnPlayerDisconnected(BasePlayer ruBBmSHSLwcJlcApwXQPCmW, string TvglATzKckIYnDyotjfjlwWP) => TYReHSqOfhKNYycZjKGW.Remove(ruBBmSHSLwcJlcApwXQPCmW.userID); private void OnServerInitialized() { UTrMSfubwzyW(true); foreach (var ruBBmSHSLwcJlcApwXQPCmW in BasePlayer.activePlayerList) OnPlayerConnected(ruBBmSHSLwcJlcApwXQPCmW); } private void OnDispenserGather(ResourceDispenser WmxvpKiWoq, BaseEntity CAjbiFlusXCJXaPjS, Item LbDHbbXgOVNBHbagtiQtViVd) { if (CAjbiFlusXCJXaPjS == null || LbDHbbXgOVNBHbagtiQtViVd == null) return; BasePlayer ruBBmSHSLwcJlcApwXQPCmW = CAjbiFlusXCJXaPjS.ToPlayer(); if (ruBBmSHSLwcJlcApwXQPCmW == null) return; var qzaurjSwsgnPo = cIfJbJRDtwIgyvMifYLP(WmxvpKiWoq, ruBBmSHSLwcJlcApwXQPCmW, LbDHbbXgOVNBHbagtiQtViVd); VAIOrIBMFBRDzWjWcreirermt(LbDHbbXgOVNBHbagtiQtViVd); var AapKTgjGaklWxnyKU = PGrbPtTOXSARhfHLPNQjQdLhjfH(ruBBmSHSLwcJlcApwXQPCmW); var lFUwovWtRpPgCfhBepAylcyZoDot = zFxEtHNxxGJUxewKBKvGvBFGvJqcw(ruBBmSHSLwcJlcApwXQPCmW.userID); if (lFUwovWtRpPgCfhBepAylcyZoDot < 0) return; kBDzvmUtgW(LbDHbbXgOVNBHbagtiQtViVd, lFUwovWtRpPgCfhBepAylcyZoDot * SPHgwVuINoiDcmDXsr.NFkuMJTnoGvVUuvZrXThjErqHaUBC[LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english] * (AapKTgjGaklWxnyKU != null ? SPHgwVuINoiDcmDXsr.wLlCIDXEeclqeiFSXKo[AapKTgjGaklWxnyKU.info.displayName.english] : 1f), uczyrWoSXbuADxECLN() * qzaurjSwsgnPo); } private void OnDispenserBonus(ResourceDispenser WmxvpKiWoq, BasePlayer ruBBmSHSLwcJlcApwXQPCmW, Item LbDHbbXgOVNBHbagtiQtViVd) { if (ruBBmSHSLwcJlcApwXQPCmW == null || LbDHbbXgOVNBHbagtiQtViVd == null) return; var qzaurjSwsgnPo = cIfJbJRDtwIgyvMifYLP(WmxvpKiWoq, ruBBmSHSLwcJlcApwXQPCmW, LbDHbbXgOVNBHbagtiQtViVd); VAIOrIBMFBRDzWjWcreirermt(LbDHbbXgOVNBHbagtiQtViVd); var AapKTgjGaklWxnyKU = PGrbPtTOXSARhfHLPNQjQdLhjfH(ruBBmSHSLwcJlcApwXQPCmW); var lFUwovWtRpPgCfhBepAylcyZoDot = zFxEtHNxxGJUxewKBKvGvBFGvJqcw(ruBBmSHSLwcJlcApwXQPCmW.userID); if (lFUwovWtRpPgCfhBepAylcyZoDot < 0) return; kBDzvmUtgW(LbDHbbXgOVNBHbagtiQtViVd, lFUwovWtRpPgCfhBepAylcyZoDot * SPHgwVuINoiDcmDXsr.NFkuMJTnoGvVUuvZrXThjErqHaUBC[LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english] * (AapKTgjGaklWxnyKU != null ? SPHgwVuINoiDcmDXsr.wLlCIDXEeclqeiFSXKo[AapKTgjGaklWxnyKU.info.displayName.english] : 1f), uczyrWoSXbuADxECLN() * qzaurjSwsgnPo); } private void OnCollectiblePickup(Item LbDHbbXgOVNBHbagtiQtViVd, BasePlayer ruBBmSHSLwcJlcApwXQPCmW) { if (ruBBmSHSLwcJlcApwXQPCmW == null || LbDHbbXgOVNBHbagtiQtViVd == null) return; UzfOPDWISeexjvRnZ(LbDHbbXgOVNBHbagtiQtViVd); var lFUwovWtRpPgCfhBepAylcyZoDot = mTAoUXIVPGCaZ(ruBBmSHSLwcJlcApwXQPCmW.userID); if (lFUwovWtRpPgCfhBepAylcyZoDot < 0) return; kBDzvmUtgW(LbDHbbXgOVNBHbagtiQtViVd, lFUwovWtRpPgCfhBepAylcyZoDot * SPHgwVuINoiDcmDXsr.HqoCWvBbWlkfIIU[LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english]); } private void OnGrowableGathered(GrowableEntity GSpwrTFFoifcdL, Item LbDHbbXgOVNBHbagtiQtViVd, BasePlayer ruBBmSHSLwcJlcApwXQPCmW) { if (GSpwrTFFoifcdL == null || ruBBmSHSLwcJlcApwXQPCmW == null || LbDHbbXgOVNBHbagtiQtViVd == null) return; UzfOPDWISeexjvRnZ(LbDHbbXgOVNBHbagtiQtViVd); var lFUwovWtRpPgCfhBepAylcyZoDot = mTAoUXIVPGCaZ(ruBBmSHSLwcJlcApwXQPCmW.userID); if (lFUwovWtRpPgCfhBepAylcyZoDot < 0) return; kBDzvmUtgW(LbDHbbXgOVNBHbagtiQtViVd, lFUwovWtRpPgCfhBepAylcyZoDot * SPHgwVuINoiDcmDXsr.HqoCWvBbWlkfIIU[LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english]); } private void OnQuarryGather(MiningQuarry qizRzFxlkyVUceOYIblgn, Item LbDHbbXgOVNBHbagtiQtViVd) { if (qizRzFxlkyVUceOYIblgn == null || LbDHbbXgOVNBHbagtiQtViVd == null) return; oetGHOimIAMYUTjlYTNKYPuneezp(LbDHbbXgOVNBHbagtiQtViVd); var lFUwovWtRpPgCfhBepAylcyZoDot = cQeERfeDlJmMbJiER(qizRzFxlkyVUceOYIblgn.OwnerID); if (lFUwovWtRpPgCfhBepAylcyZoDot < 0) return; kBDzvmUtgW(LbDHbbXgOVNBHbagtiQtViVd, lFUwovWtRpPgCfhBepAylcyZoDot * SPHgwVuINoiDcmDXsr.PxUYNMKyKGoBvuROafdhXXXUjYN[LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english]); } private void OnExcavatorGather(ExcavatorArm TzPOMJoGKgdmq, Item LbDHbbXgOVNBHbagtiQtViVd) { if (TzPOMJoGKgdmq == null || LbDHbbXgOVNBHbagtiQtViVd == null) return; sfqFhPZYku(LbDHbbXgOVNBHbagtiQtViVd); var lFUwovWtRpPgCfhBepAylcyZoDot = GetExcavRate(); if (lFUwovWtRpPgCfhBepAylcyZoDot < 0) return; kBDzvmUtgW(LbDHbbXgOVNBHbagtiQtViVd, lFUwovWtRpPgCfhBepAylcyZoDot * SPHgwVuINoiDcmDXsr.CqIOOIesPdbhnhrMuKHyq[LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english]); } private void OnUserPermissionGranted(string MxvYIoqwpZBPTyDwwifjqptLpQNnNN, string TZFkeqqdgsaloEVqSgnOkQDyPaYSD) { if (SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Where(x=> x.Key.ToLower() == TZFkeqqdgsaloEVqSgnOkQDyPaYSD.ToLower()).Count() > 0) timer.Once(0.1f, ()=> yiVutxeRQI(MxvYIoqwpZBPTyDwwifjqptLpQNnNN)); } private void OnUserPermissionRevoked(string MxvYIoqwpZBPTyDwwifjqptLpQNnNN, string TZFkeqqdgsaloEVqSgnOkQDyPaYSD) { if (SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Where(x=> x.Key.ToLower() == TZFkeqqdgsaloEVqSgnOkQDyPaYSD.ToLower()).Count() > 0) timer.Once(0.1f, ()=> yiVutxeRQI(MxvYIoqwpZBPTyDwwifjqptLpQNnNN)); } private void OnUserGroupAdded(string MxvYIoqwpZBPTyDwwifjqptLpQNnNN, string FGCfNoxvlvTdiPTFSlJQGcC) => timer.Once(0.1f, ()=> yiVutxeRQI(MxvYIoqwpZBPTyDwwifjqptLpQNnNN)); private void OnUserGroupRemoved(string MxvYIoqwpZBPTyDwwifjqptLpQNnNN, string FGCfNoxvlvTdiPTFSlJQGcC) => timer.Once(0.1f, ()=> yiVutxeRQI(MxvYIoqwpZBPTyDwwifjqptLpQNnNN)); private void OnGroupPermissionGranted(string FGCfNoxvlvTdiPTFSlJQGcC, string TZFkeqqdgsaloEVqSgnOkQDyPaYSD) { if (SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Where(x=> x.Key.ToLower() == TZFkeqqdgsaloEVqSgnOkQDyPaYSD.ToLower()).Count() > 0) timer.Once(0.1f, ()=> hiIKXJeifXPCnjFYcqanjwOAIllrA(FGCfNoxvlvTdiPTFSlJQGcC)); } private void OnGroupPermissionRevoked(string FGCfNoxvlvTdiPTFSlJQGcC, string TZFkeqqdgsaloEVqSgnOkQDyPaYSD) { if (SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Where(x=> x.Key.ToLower() == TZFkeqqdgsaloEVqSgnOkQDyPaYSD.ToLower()).Count() > 0) timer.Once(0.1f, ()=> hiIKXJeifXPCnjFYcqanjwOAIllrA(FGCfNoxvlvTdiPTFSlJQGcC)); } private void VAIOrIBMFBRDzWjWcreirermt(Item LbDHbbXgOVNBHbagtiQtViVd) { if (!SPHgwVuINoiDcmDXsr.NFkuMJTnoGvVUuvZrXThjErqHaUBC.ContainsKey(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)) { SPHgwVuINoiDcmDXsr.NFkuMJTnoGvVUuvZrXThjErqHaUBC.Add(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english, 1f); hjsHLbYXjEvKDwaSsfAyDa(SPHgwVuINoiDcmDXsr); PrintWarning(string.Format("В конфигурационный файл, в раздел добываемых ресурсов добавлен новый ресурс '{0}'", LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)); } } private Item PGrbPtTOXSARhfHLPNQjQdLhjfH(BasePlayer ruBBmSHSLwcJlcApwXQPCmW) { if (ruBBmSHSLwcJlcApwXQPCmW == null) return null; var LbDHbbXgOVNBHbagtiQtViVd = ruBBmSHSLwcJlcApwXQPCmW.GetActiveItem(); if (LbDHbbXgOVNBHbagtiQtViVd == null) return null; if (SPHgwVuINoiDcmDXsr.wLlCIDXEeclqeiFSXKo == null) SPHgwVuINoiDcmDXsr.wLlCIDXEeclqeiFSXKo = new Dictionary<string, float>(); if (!SPHgwVuINoiDcmDXsr.wLlCIDXEeclqeiFSXKo.ContainsKey(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)) { SPHgwVuINoiDcmDXsr.wLlCIDXEeclqeiFSXKo.Add(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english, 1f); hjsHLbYXjEvKDwaSsfAyDa(SPHgwVuINoiDcmDXsr); PrintWarning(string.Format("В конфигурационный файл, в раздел инструментов добычи добавлен новый ресурс '{0}'", LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)); } return LbDHbbXgOVNBHbagtiQtViVd; } private void UzfOPDWISeexjvRnZ(Item LbDHbbXgOVNBHbagtiQtViVd) { if (!SPHgwVuINoiDcmDXsr.HqoCWvBbWlkfIIU.ContainsKey(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)) { SPHgwVuINoiDcmDXsr.HqoCWvBbWlkfIIU.Add(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english, 1f); hjsHLbYXjEvKDwaSsfAyDa(SPHgwVuINoiDcmDXsr); PrintWarning(string.Format("В конфигурационный файл, в раздел поднимаемых ресурсов добавлен новый ресурс '{0}'", LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)); } } private void oetGHOimIAMYUTjlYTNKYPuneezp(Item LbDHbbXgOVNBHbagtiQtViVd) { if (!SPHgwVuINoiDcmDXsr.PxUYNMKyKGoBvuROafdhXXXUjYN.ContainsKey(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)) { SPHgwVuINoiDcmDXsr.PxUYNMKyKGoBvuROafdhXXXUjYN.Add(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english, 1f); hjsHLbYXjEvKDwaSsfAyDa(SPHgwVuINoiDcmDXsr); PrintWarning(string.Format("В конфигурационный файл, в раздел добываемых ресурсов в карьере добавлен новый ресурс '{0}'", LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)); } } private void sfqFhPZYku(Item LbDHbbXgOVNBHbagtiQtViVd) { if (!SPHgwVuINoiDcmDXsr.CqIOOIesPdbhnhrMuKHyq.ContainsKey(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)) { SPHgwVuINoiDcmDXsr.CqIOOIesPdbhnhrMuKHyq.Add(LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english, 1f); hjsHLbYXjEvKDwaSsfAyDa(SPHgwVuINoiDcmDXsr); PrintWarning(string.Format("В конфигурационный файл, в раздел добываемых ресурсов экскаватором добавлен новый ресурс '{0}'", LbDHbbXgOVNBHbagtiQtViVd.info.displayName.english)); } } private void kBDzvmUtgW(Item LbDHbbXgOVNBHbagtiQtViVd, float lFUwovWtRpPgCfhBepAylcyZoDot, float teaAmount = 0f) { if (lFUwovWtRpPgCfhBepAylcyZoDot <= 0) { LbDHbbXgOVNBHbagtiQtViVd.RemoveFromContainer(); LbDHbbXgOVNBHbagtiQtViVd.Remove(0f); } else { var HrNsgkAmrheUphzz = (int)Math.Round(lFUwovWtRpPgCfhBepAylcyZoDot * LbDHbbXgOVNBHbagtiQtViVd.amount + teaAmount); if (HrNsgkAmrheUphzz <= 0) { LbDHbbXgOVNBHbagtiQtViVd.RemoveFromContainer(); LbDHbbXgOVNBHbagtiQtViVd.Remove(0f); } else LbDHbbXgOVNBHbagtiQtViVd.amount = HrNsgkAmrheUphzz; } } private float uczyrWoSXbuADxECLN() => (SPHgwVuINoiDcmDXsr.zsoHZjExDiuKdluUKGKsqYO && xMdWdaMcelnqZnUuvuOsHR) ? SPHgwVuINoiDcmDXsr.WiWfZmecQrreCVAYHyiMnWgbl : SPHgwVuINoiDcmDXsr.XNtQFnLuUtBJXwyQhATerGZll; private int cIfJbJRDtwIgyvMifYLP(ResourceDispenser WmxvpKiWoq, BasePlayer ruBBmSHSLwcJlcApwXQPCmW, Item LbDHbbXgOVNBHbagtiQtViVd) { int qzaurjSwsgnPo = 0; if (uczyrWoSXbuADxECLN() > 0) { var DqOrnPPfbHySPYARnGwkgpJUf = false; Modifier.ModifierType modifierType = 0; if (WmxvpKiWoq.gatherType == ResourceDispenser.GatherType.Tree) modifierType = Modifier.ModifierType.Wood_Yield; else if (WmxvpKiWoq.gatherType == ResourceDispenser.GatherType.Ore) modifierType = Modifier.ModifierType.Ore_Yield; else DqOrnPPfbHySPYARnGwkgpJUf = true; if (!DqOrnPPfbHySPYARnGwkgpJUf) { float value = 1f + ruBBmSHSLwcJlcApwXQPCmW.modifiers.GetValue(modifierType, 0f); if (value > 1f) { qzaurjSwsgnPo = LbDHbbXgOVNBHbagtiQtViVd.amount - (int)Math.Round(LbDHbbXgOVNBHbagtiQtViVd.amount / value); int amount = LbDHbbXgOVNBHbagtiQtViVd.amount - qzaurjSwsgnPo; LbDHbbXgOVNBHbagtiQtViVd.amount = amount > 0 ? amount : 1; } } } return qzaurjSwsgnPo; } private float zFxEtHNxxGJUxewKBKvGvBFGvJqcw(ulong OYlWblKfCabL) { float jxcAvsZrdojsjCY = (SPHgwVuINoiDcmDXsr.zsoHZjExDiuKdluUKGKsqYO && xMdWdaMcelnqZnUuvuOsHR) ? SPHgwVuINoiDcmDXsr.oaGDCSwHhwXSImaGtwdFTxVCo : SPHgwVuINoiDcmDXsr.sGegktmleMXZOZVqD; if (!TYReHSqOfhKNYycZjKGW.ContainsKey(OYlWblKfCabL)) return jxcAvsZrdojsjCY; else { float lFUwovWtRpPgCfhBepAylcyZoDot = -1; foreach(var DZbRMoVkbtPXdUgAaOZpmbUWYBF in SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Where(x=> TYReHSqOfhKNYycZjKGW[OYlWblKfCabL].Contains(x.Key.ToLower()))) { if (SPHgwVuINoiDcmDXsr.zsoHZjExDiuKdluUKGKsqYO && xMdWdaMcelnqZnUuvuOsHR) { if (lFUwovWtRpPgCfhBepAylcyZoDot < DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.oaGDCSwHhwXSImaGtwdFTxVCo) lFUwovWtRpPgCfhBepAylcyZoDot = DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.oaGDCSwHhwXSImaGtwdFTxVCo; } else { if (lFUwovWtRpPgCfhBepAylcyZoDot < DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.sGegktmleMXZOZVqD) lFUwovWtRpPgCfhBepAylcyZoDot = DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.sGegktmleMXZOZVqD; } } return lFUwovWtRpPgCfhBepAylcyZoDot >= 0 ? lFUwovWtRpPgCfhBepAylcyZoDot : jxcAvsZrdojsjCY; } return jxcAvsZrdojsjCY; } private float mTAoUXIVPGCaZ(ulong OYlWblKfCabL) { float jxcAvsZrdojsjCY = (SPHgwVuINoiDcmDXsr.zsoHZjExDiuKdluUKGKsqYO && xMdWdaMcelnqZnUuvuOsHR) ? SPHgwVuINoiDcmDXsr.BxEvRbOqskmfFblXoZUJuDWuJY : SPHgwVuINoiDcmDXsr.efujbsOqvXjaRW; if (!TYReHSqOfhKNYycZjKGW.ContainsKey(OYlWblKfCabL)) return jxcAvsZrdojsjCY; else { float lFUwovWtRpPgCfhBepAylcyZoDot = -1; foreach(var DZbRMoVkbtPXdUgAaOZpmbUWYBF in SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Where(x=> TYReHSqOfhKNYycZjKGW[OYlWblKfCabL].Contains(x.Key.ToLower()))) { if (SPHgwVuINoiDcmDXsr.zsoHZjExDiuKdluUKGKsqYO && xMdWdaMcelnqZnUuvuOsHR) { if (lFUwovWtRpPgCfhBepAylcyZoDot < DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.BxEvRbOqskmfFblXoZUJuDWuJY) lFUwovWtRpPgCfhBepAylcyZoDot = DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.BxEvRbOqskmfFblXoZUJuDWuJY; } else { if (lFUwovWtRpPgCfhBepAylcyZoDot < DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.efujbsOqvXjaRW) lFUwovWtRpPgCfhBepAylcyZoDot = DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.efujbsOqvXjaRW; } } return lFUwovWtRpPgCfhBepAylcyZoDot >= 0 ? lFUwovWtRpPgCfhBepAylcyZoDot : jxcAvsZrdojsjCY; } return jxcAvsZrdojsjCY; } private float cQeERfeDlJmMbJiER(ulong OYlWblKfCabL) { float jxcAvsZrdojsjCY = (SPHgwVuINoiDcmDXsr.zsoHZjExDiuKdluUKGKsqYO && xMdWdaMcelnqZnUuvuOsHR) ? SPHgwVuINoiDcmDXsr.rpbtmOeqLYReRbJVPb : SPHgwVuINoiDcmDXsr.pugEOypuxzZsmZdSKZFOf; if (OYlWblKfCabL == 0) return jxcAvsZrdojsjCY; List<string> gYGqTgFOyGkBnEoJcibjvhorJCYvs = new List<string>(); foreach(var iNcduNtyYQKlZLpYjAifkWvj in SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Keys) if (permission.UserHasPermission(OYlWblKfCabL.ToString(), iNcduNtyYQKlZLpYjAifkWvj.ToLower())) gYGqTgFOyGkBnEoJcibjvhorJCYvs.Add(iNcduNtyYQKlZLpYjAifkWvj.ToLower()); if (gYGqTgFOyGkBnEoJcibjvhorJCYvs.Count == 0) return jxcAvsZrdojsjCY; float lFUwovWtRpPgCfhBepAylcyZoDot = -1; foreach(var DZbRMoVkbtPXdUgAaOZpmbUWYBF in SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Where(x=> gYGqTgFOyGkBnEoJcibjvhorJCYvs.Contains(x.Key.ToLower()))) { if (SPHgwVuINoiDcmDXsr.zsoHZjExDiuKdluUKGKsqYO && xMdWdaMcelnqZnUuvuOsHR) { if (lFUwovWtRpPgCfhBepAylcyZoDot < DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.rpbtmOeqLYReRbJVPb) lFUwovWtRpPgCfhBepAylcyZoDot = DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.rpbtmOeqLYReRbJVPb; } else { if (lFUwovWtRpPgCfhBepAylcyZoDot < DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.pugEOypuxzZsmZdSKZFOf) lFUwovWtRpPgCfhBepAylcyZoDot = DZbRMoVkbtPXdUgAaOZpmbUWYBF.Value.pugEOypuxzZsmZdSKZFOf; } } return lFUwovWtRpPgCfhBepAylcyZoDot >= 0 ? lFUwovWtRpPgCfhBepAylcyZoDot : jxcAvsZrdojsjCY; } private float GetExcavRate() { float jxcAvsZrdojsjCY = (SPHgwVuINoiDcmDXsr.zsoHZjExDiuKdluUKGKsqYO && xMdWdaMcelnqZnUuvuOsHR) ? SPHgwVuINoiDcmDXsr.aiuVXFJwFIcdLiNxGeGGBAfI : SPHgwVuINoiDcmDXsr.YePbxylRVLx; return jxcAvsZrdojsjCY; } private void yiVutxeRQI(string userIdString) { List<string> wWzbTnZFEZppgthOxtCjZ = new List<string>(); var DqOrnPPfbHySPYARnGwkgpJUf = "956"; foreach(var iNcduNtyYQKlZLpYjAifkWvj in SPHgwVuINoiDcmDXsr.pxFhJnupSKinwQZGDfugRjs.Keys) if (permission.UserHasPermission(userIdString, iNcduNtyYQKlZLpYjAifkWvj.ToLower())) wWzbTnZFEZppgthOxtCjZ.Add(iNcduNtyYQKlZLpYjAifkWvj.ToLower()); ulong OYlWblKfCabL = (ulong)Convert.ToInt64(userIdString); if (wWzbTnZFEZppgthOxtCjZ.Count == 0) { if (TYReHSqOfhKNYycZjKGW.ContainsKey(OYlWblKfCabL)) TYReHSqOfhKNYycZjKGW.Remove(OYlWblKfCabL); } else { if (!TYReHSqOfhKNYycZjKGW.ContainsKey(OYlWblKfCabL)) TYReHSqOfhKNYycZjKGW.Add(OYlWblKfCabL, wWzbTnZFEZppgthOxtCjZ); else TYReHSqOfhKNYycZjKGW[OYlWblKfCabL] = wWzbTnZFEZppgthOxtCjZ; } } private void hiIKXJeifXPCnjFYcqanjwOAIllrA(string ETuMRfpoSrvIVoYhvLNZUxSDnr) { List<string> oPcRyHvYYwxoNCEoWgW = permission.GetUsersInGroup(ETuMRfpoSrvIVoYhvLNZUxSDnr).Select(x=>x.Substring(0, x.IndexOf(" "))).ToList(); foreach(var ruBBmSHSLwcJlcApwXQPCmW in BasePlayer.activePlayerList.Where(x=> oPcRyHvYYwxoNCEoWgW.Contains(x.UserIDString))) yiVutxeRQI(ruBBmSHSLwcJlcApwXQPCmW.UserIDString); } private void UTrMSfubwzyW(bool IzXApdAULxQtJtU = false) { var zeEWegDBpHrNeapLqDwpptKPidMRyr = TOD_Sky.Instance.Cycle.Hour; bool MHVMSmeIXNUkTCVurCMPDPRiJbdtd = xMdWdaMcelnqZnUuvuOsHR; if ( (SPHgwVuINoiDcmDXsr.CbJjGmeaiukgaHAUDJSKaaYoPQtFgU <= SPHgwVuINoiDcmDXsr.RMtJfnKgpztlkNICsjOffkcI && zeEWegDBpHrNeapLqDwpptKPidMRyr >= SPHgwVuINoiDcmDXsr.CbJjGmeaiukgaHAUDJSKaaYoPQtFgU && zeEWegDBpHrNeapLqDwpptKPidMRyr < SPHgwVuINoiDcmDXsr.RMtJfnKgpztlkNICsjOffkcI) || (SPHgwVuINoiDcmDXsr.CbJjGmeaiukgaHAUDJSKaaYoPQtFgU > SPHgwVuINoiDcmDXsr.RMtJfnKgpztlkNICsjOffkcI && zeEWegDBpHrNeapLqDwpptKPidMRyr >= SPHgwVuINoiDcmDXsr.CbJjGmeaiukgaHAUDJSKaaYoPQtFgU && zeEWegDBpHrNeapLqDwpptKPidMRyr < SPHgwVuINoiDcmDXsr.RMtJfnKgpztlkNICsjOffkcI + 24) || (SPHgwVuINoiDcmDXsr.CbJjGmeaiukgaHAUDJSKaaYoPQtFgU > SPHgwVuINoiDcmDXsr.RMtJfnKgpztlkNICsjOffkcI && zeEWegDBpHrNeapLqDwpptKPidMRyr + 24 >= SPHgwVuINoiDcmDXsr.CbJjGmeaiukgaHAUDJSKaaYoPQtFgU && zeEWegDBpHrNeapLqDwpptKPidMRyr < SPHgwVuINoiDcmDXsr.RMtJfnKgpztlkNICsjOffkcI) ) xMdWdaMcelnqZnUuvuOsHR = true; else xMdWdaMcelnqZnUuvuOsHR = false; if (!IzXApdAULxQtJtU && MHVMSmeIXNUkTCVurCMPDPRiJbdtd != xMdWdaMcelnqZnUuvuOsHR) iJGFmNSmzpjUPoBfd(); timer.Once(3f, ()=>UTrMSfubwzyW()); } private void iJGFmNSmzpjUPoBfd() { if (SPHgwVuINoiDcmDXsr.AEOqiUuRmzSfvIIw) { foreach(var ruBBmSHSLwcJlcApwXQPCmW in BasePlayer.activePlayerList) SendReply(ruBBmSHSLwcJlcApwXQPCmW, string.Format(xMdWdaMcelnqZnUuvuOsHR?WgbDnqHgVcxHNhYVbjUcAkzZbvyXeq("INFO.NIGHT.START"):WgbDnqHgVcxHNhYVbjUcAkzZbvyXeq("INFO.NIGHT.END"), zFxEtHNxxGJUxewKBKvGvBFGvJqcw(ruBBmSHSLwcJlcApwXQPCmW.userID), mTAoUXIVPGCaZ(ruBBmSHSLwcJlcApwXQPCmW.userID), cQeERfeDlJmMbJiER(ruBBmSHSLwcJlcApwXQPCmW.userID))); } } private void LoadDefaultMessages() { lang.RegisterMessages(new Dictionary<string, string> { { "INFO.NIGHT.START", "Наступает ночь\nРейты добываемых ресурсов: X{0}\nРейты поднимаемых ресурсов: X{1}\nРейты ресурсов в карьере: X{2}" }, { "INFO.NIGHT.END", "Наступает день\nРейты добываемых ресурсов: X{0}\nРейты поднимаемых ресурсов: X{1}\nРейты ресурсов в карьере: X{2}" } }, this); } private string WgbDnqHgVcxHNhYVbjUcAkzZbvyXeq(string XYhtZLHwaUvxZvIuoNLeQrMjTh, string OVLwWvZjBTWQaofxEAsAiu = null) => lang.GetMessage(XYhtZLHwaUvxZvIuoNLeQrMjTh, this, OVLwWvZjBTWQaofxEAsAiu); private static YKvNVAlKVtyHgdQMSBDjkjAHqMbYf SPHgwVuINoiDcmDXsr; private class NgMeCAQtKwjHNgNNmahvyzlMdIU { [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов")] public float sGegktmleMXZOZVqD; [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов ночью")] public float oaGDCSwHhwXSImaGtwdFTxVCo; [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов")] public float efujbsOqvXjaRW; [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов ночью")] public float BxEvRbOqskmfFblXoZUJuDWuJY; [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере")] public float pugEOypuxzZsmZdSKZFOf; [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере ночью")] public float rpbtmOeqLYReRbJVPb; } private class YKvNVAlKVtyHgdQMSBDjkjAHqMbYf { [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов")] public float sGegktmleMXZOZVqD; [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов ночью")] public float oaGDCSwHhwXSImaGtwdFTxVCo; [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов")] public Dictionary<string, float> NFkuMJTnoGvVUuvZrXThjErqHaUBC; [JsonProperty(PropertyName = "Стандартные рейты инструментов добычи")] public Dictionary<string, float> wLlCIDXEeclqeiFSXKo; [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов")] public float efujbsOqvXjaRW; [JsonProperty(PropertyName = "Общий рейт поднимаемых ресурсов ночью")] public float BxEvRbOqskmfFblXoZUJuDWuJY; [JsonProperty(PropertyName = "Стандартные рейты поднимаемых ресурсов")] public Dictionary<string, float> HqoCWvBbWlkfIIU; [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере")] public float pugEOypuxzZsmZdSKZFOf; [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов в карьере ночью")] public float rpbtmOeqLYReRbJVPb; [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов в карьере")] public Dictionary<string, float> PxUYNMKyKGoBvuROafdhXXXUjYN; [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов экскаватором")] public float YePbxylRVLx; [JsonProperty(PropertyName = "Общий рейт добываемых ресурсов экскаватором ночью")] public float aiuVXFJwFIcdLiNxGeGGBAfI; [JsonProperty(PropertyName = "Стандартные рейты добываемых ресурсов экскаватором")] public Dictionary<string, float> CqIOOIesPdbhnhrMuKHyq; [JsonProperty(PropertyName = "Общий рейт рудного и древесного чая")] public float XNtQFnLuUtBJXwyQhATerGZll; [JsonProperty(PropertyName = "Общий рейт рудного и древесного чая ночью")] public float WiWfZmecQrreCVAYHyiMnWgbl; [JsonProperty(PropertyName = "Включить разделение рейтов на ночной и дневной режим")] public bool zsoHZjExDiuKdluUKGKsqYO; [JsonProperty(PropertyName = "Час игрового времени с которого включается ночной режим")] public int CbJjGmeaiukgaHAUDJSKaaYoPQtFgU; [JsonProperty(PropertyName = "Час игрового времени с которого выключается ночной режим")] public int RMtJfnKgpztlkNICsjOffkcI; [JsonProperty(PropertyName = "Выводить оповещение в чат при смене ночного и дневного режима")] public bool AEOqiUuRmzSfvIIw; [JsonProperty(PropertyName = "Изменение рейтов для игроков с привилегиями")] public Dictionary<string, NgMeCAQtKwjHNgNNmahvyzlMdIU> pxFhJnupSKinwQZGDfugRjs; } private void jZoFNoouxQhUThiNJqLltoHJD() => SPHgwVuINoiDcmDXsr = Config.ReadObject<YKvNVAlKVtyHgdQMSBDjkjAHqMbYf>(); protected override void LoadDefaultConfig() { SPHgwVuINoiDcmDXsr = new YKvNVAlKVtyHgdQMSBDjkjAHqMbYf { sGegktmleMXZOZVqD = 1f, oaGDCSwHhwXSImaGtwdFTxVCo = 1f, NFkuMJTnoGvVUuvZrXThjErqHaUBC = new Dictionary<string, float>() { { "Animal Fat", 1f }, { "Bear Meat", 1f }, { "Bone Fragments", 1f }, { "Cloth", 1f }, { "High Quality Metal Ore", 1f }, { "Human Skull", 1f }, { "Leather", 1f }, { "Metal Ore", 1f }, { "Pork", 1f }, { "Raw Bear Meat", 1f }, { "Raw Chicken Breast", 1f }, { "Raw Human Meat", 1f }, { "Raw Wolf Meat", 1f }, { "Stones", 1f }, { "Sulfur Ore", 1f }, { "Wolf Skull", 1f }, { "Wood", 1f } }, wLlCIDXEeclqeiFSXKo = new Dictionary<string, float>() { { "Bone Club", 1f }, { "Candy Cane Club", 1f }, { "Chainsaw", 1f }, { "Hatchet", 1f }, { "Pickaxe", 1f }, { "Rock", 1f }, { "Salvaged Axe", 1f }, { "Salvaged Hammer", 1f }, { "Salvaged Icepick", 1f }, { "Stone Hatchet", 1f }, { "Stone Pickaxe", 1f }, { "Jackhammer", 1f } }, efujbsOqvXjaRW = 1f, BxEvRbOqskmfFblXoZUJuDWuJY = 1f, HqoCWvBbWlkfIIU = new Dictionary<string, float>() { { "Metal Ore", 1f }, { "Stones", 1f }, { "Sulfur Ore", 1f }, { "Wood", 1f }, { "Hemp Seed", 1f }, { "Corn Seed", 1f }, { "Pumpkin Seed", 1f }, { "Cloth", 1f }, { "Pumpkin", 1f }, { "Corn", 1f } }, pugEOypuxzZsmZdSKZFOf = 1f, rpbtmOeqLYReRbJVPb = 1f, PxUYNMKyKGoBvuROafdhXXXUjYN = new Dictionary<string, float>() { { "High Quality Metal Ore", 1f }, { "Metal Fragments", 1f }, { "Metal Ore", 1f }, { "Stones", 1f }, { "Sulfur Ore", 1f } }, YePbxylRVLx = 1f, aiuVXFJwFIcdLiNxGeGGBAfI = 1f, CqIOOIesPdbhnhrMuKHyq = new Dictionary<string, float>() { { "High Quality Metal Ore", 1f }, { "Metal Fragments", 1f }, { "Metal Ore", 1f }, { "Stones", 1f }, { "Sulfur Ore", 1f } }, XNtQFnLuUtBJXwyQhATerGZll = 0f, WiWfZmecQrreCVAYHyiMnWgbl = 0f, zsoHZjExDiuKdluUKGKsqYO = false, CbJjGmeaiukgaHAUDJSKaaYoPQtFgU = 19, RMtJfnKgpztlkNICsjOffkcI = 8, AEOqiUuRmzSfvIIw = true, pxFhJnupSKinwQZGDfugRjs = new Dictionary<string, NgMeCAQtKwjHNgNNmahvyzlMdIU>() { { "gatherplus.vip", new NgMeCAQtKwjHNgNNmahvyzlMdIU() { sGegktmleMXZOZVqD = 2f, oaGDCSwHhwXSImaGtwdFTxVCo = 2f, efujbsOqvXjaRW = 2f, BxEvRbOqskmfFblXoZUJuDWuJY = 2f, pugEOypuxzZsmZdSKZFOf = 2f, rpbtmOeqLYReRbJVPb = 2f } }, { "gatherplus.premium", new NgMeCAQtKwjHNgNNmahvyzlMdIU() { sGegktmleMXZOZVqD = 3f, oaGDCSwHhwXSImaGtwdFTxVCo = 3f, efujbsOqvXjaRW = 3f, BxEvRbOqskmfFblXoZUJuDWuJY = 3f, pugEOypuxzZsmZdSKZFOf = 3f, rpbtmOeqLYReRbJVPb = 3f } } } }; hjsHLbYXjEvKDwaSsfAyDa(SPHgwVuINoiDcmDXsr); timer.Once(0.1f, ()=> hjsHLbYXjEvKDwaSsfAyDa(SPHgwVuINoiDcmDXsr)); } private void hjsHLbYXjEvKDwaSsfAyDa(YKvNVAlKVtyHgdQMSBDjkjAHqMbYf nYKhIMflMNqcGkCGZDbwWxIaGWeK) => Config.WriteObject(nYKhIMflMNqcGkCGZDbwWxIaGWeK, true); } } 


// --- End of file: GatherPlus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Updater.cs ---
// --- Original Local Path: Updater.cs ---

using System.Text.RegularExpressions;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Updater", "LaserHydra", "2.0.0", ResourceId = 681)]
    [Description("Notifies you if you have outdated plugins.")]
#if RUST
    class Updater : RustPlugin
#endif
#if HURTWORLD
    class Updater : HurtworldPlugin
#endif
#if ROK
    class Updater : ReignOfKingsPlugin
#endif
    {
        #region Global Declaration

        Dictionary<Plugin, string> pluginList = new Dictionary<Plugin, string>();

        [PluginReference("EmailAPI")]
        Plugin EmailAPI;

        [PluginReference("PushAPI")]
        Plugin PushAPI;

        #endregion

        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
            RegisterPerm("use");

            LoadConfig();
            LoadMessages();

            timer.Repeat(GetConfig(60f, "Settings", "Auto Check Interval (in Minutes)") * 60, 0, () => CheckForUpdates());
            CheckForUpdates();
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Settings", "Auto Check Interval (in Minutes)", 60f);
            SetConfig("Settings", "Use PushAPI", false);
            SetConfig("Settings", "Use EmailAPI", false);
            //SetConfig("Settings", "Log to File", true);
            
            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "Following plugins are outdated: {plugins}"},
                {"Outdated Plugin List", "Following plugins are outdated: {plugins}"},
                {"Outdated Plugin Info", "# {title} | Installed: {installed} - Latest: {latest} | {url}"}
            }, this);
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");

        #endregion

        #region Commands

#if RUST
        [ConsoleCommand("updates")]
        void ccmdUpdates(ConsoleSystem.Arg arg)
        {
            if (arg == null)
                return;

            if (arg.connection?.userid != null)
                if (!HasPerm(arg.connection.userid, "use"))
                    return;

            CheckForUpdates();
        }

        [ChatCommand("updates")]
        void cmdUpdates(BasePlayer player)
        {
            if(!HasPerm(player.userID, "use"))
                return;

            CheckForUpdates();
        }
#endif

#if HURTWORLD
        [ConsoleCommand("updates")]
        void ccmdUpdates(string cmd) => CheckForUpdates();

        [ChatCommand("updates")]
        void cmdUpdates(PlayerSession player)
        {
            if(!HasPerm(player.userID, "use"))
                return;

            CheckForUpdates();
        }
#endif

#if ROK
        [ConsoleCommand("updates")]
        void ccmdUpdates(string cmd) => CheckForUpdates();

        [ChatCommand("updates")]
        void cmdUpdates(Player player)
        {
            if(!HasPerm(player.Id, "use"))
                return;

            CheckForUpdates();
        }
#endif

        #endregion

        #region Subject Related

        void Notify(string message)
        {
            if (GetConfig(false, "Settings", "Use PushAPI") && PushAPI != null)
                PushAPI.Call("PushMessage", "Plugin Update Notification", message);

            if (GetConfig(false, "Settings", "Use EmailAPI") && EmailAPI != null)
                EmailAPI.Call("EmailMessage", "Plugin Update Notification", message);

            PrintWarning(message);
        }

        void CheckForUpdates()
        {
            pluginList.Clear();

            foreach(Plugin plugin in plugins.GetAll())
            {
                if (plugin.ResourceId == 0)
                {
                    pluginList.Add(plugin, plugin.Version.ToString());

                    if (pluginList.Count == plugins.GetAll().Count())
                        NotifyOutdated();

                    continue;
                }

                webrequest.EnqueueGet($"http://oxidemod.org/plugins/{plugin.ResourceId}/", (code, response) => 
                {
                    if (code == 200 && response != null)
                    {
                        string latest = "0.0.0.0";

                        Match version = new Regex(@"<h3>Version (\d{1,7}(\.\d{1,7})+?)<\/h3>").Match(response);
                        if (version.Success)
                            latest = version.Groups[1].ToString();

                        pluginList.Add(plugin, latest);

                        if (pluginList.Count == plugins.GetAll().Count())
                            NotifyOutdated();
                    }
                    else
                    {
                        pluginList.Add(plugin, plugin.Version.ToString());

                        if (pluginList.Count == plugins.GetAll().Count())
                            NotifyOutdated();
                    }

                }, this);
            }
        }

        void NotifyOutdated()
        {
            Dictionary<Plugin, string> outdated = new Dictionary<Plugin, string>();

            foreach (var kvp in pluginList)
                if (IsOutdated(kvp.Key.Version.ToString(), kvp.Value))
                    outdated.Add(kvp.Key, kvp.Value);

            if (outdated.Count != 0)
            {
                string message = Environment.NewLine +
                                    GetMsg("Outdated Plugin List").Replace("{plugins}", Environment.NewLine + ListToString((from kvp in outdated select Environment.NewLine + GetMsg("Outdated Plugin Info").Replace("{title}", kvp.Key.Title).Replace("{installed}", kvp.Key.Version.ToString()).Replace("{latest}", kvp.Value).Replace("{url}", $"http://oxidemod.org/plugins/{kvp.Key.ResourceId}/")).ToList(), 0, Environment.NewLine) +
                                    Environment.NewLine);

                Notify(message);
            }

            pluginList.Clear();
        }

        bool IsOutdated(string installed, string latest)
        {
            char[] chars = "1234567890.".ToCharArray();

            foreach (char Char in installed.ToCharArray())
                if (!chars.Contains(Char))
                    installed = installed.Replace(Char.ToString(), "");

            foreach (char Char in latest.ToCharArray())
                if (!chars.Contains(Char))
                    latest = latest.Replace(Char.ToString(), "");

            int[] installedArray = (from v in installed.Split('.') select Convert.ToInt32(v)).ToArray();
            int[] latestArray = (from v in latest.Split('.') select Convert.ToInt32(v)).ToArray();

            int i = 0;
            foreach(int lst in latestArray)
            {
                int inst = installedArray.Count() - 1 >= i ? installedArray[i] : 0;

                if (lst > inst)
                    return true;
                else if (lst < inst)
                    return false;

                i++;
            }

            return false;
        }

        #endregion
        
        #region General Methods

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        void RegisterPerm(params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
        }

        bool HasPerm(object uid, params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
        }

        string PermissionPrefix
        {
            get
            {
                return this.Title.Replace(" ", "").ToLower();
            }
        }

        #endregion
    }
}


// --- End of file: Updater.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GUIShop.cs ---
// --- Original Local Path: GUIShop.cs ---

using System.Collections.Generic;
using System;
using System.Linq;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("GUIShop", "Reneb", "1.4.1", ResourceId = 1319)]
    class GUIShop : RustPlugin
    {
        private const string ShopOverlayName = "ShopOverlay";
        private const string ShopContentName = "ShopContent";
        private const string ShopDescOverlay = "ShopDescOverlay";
        private readonly int[] steps = { 1, 10, 100, 1000 };
        int playersMask;

        //////////////////////////////////////////////////////////////////////////////////////
        // References ////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        [PluginReference]
        Plugin Economics;

        [PluginReference]
        Plugin Kits;

        [PluginReference]
        Plugin ImageCache;

        void OnServerInitialized()
        {
            displaynameToShortname.Clear();
            foreach (var itemdef in ItemManager.itemList)
            {
                displaynameToShortname.Add(itemdef.displayName.english.ToLower(), itemdef.shortname);
                if (string.IsNullOrEmpty(IconUrl)) continue;
                ImageCache?.CallHook("Add", string.Format(IconUrl, itemdef.shortname));
            }

            var shopCategories = DefaultShopCategories();
            CheckCfg("Shop - Shop Categories", ref shopCategories);
            foreach (var shopCategory in shopCategories)
            {
                var itemdata = shopCategory.Value as Dictionary<string, object>;
                if (itemdata == null) continue;
                try
                {
                    var data = new ItemData();
                    object obj;
                    if (itemdata.TryGetValue("item", out obj))
                    {
                        var itemname = ((string)obj).ToLower();
                        if (displaynameToShortname.ContainsKey(itemname))
                            itemname = displaynameToShortname[itemname];
                        var definition = ItemManager.FindItemDefinition(itemname);
                        if (definition == null)
                        {
                            Puts("ShopCategory: {0} Unknown item: {1}", shopCategory.Key, itemname);
                            continue;
                        }
                        data.Shortname = definition.shortname;
                    }
                    if (itemdata.TryGetValue("cmd", out obj))
                        data.Cmd = ((List<object>)obj).ConvertAll(c => (string)c);
                    double value;
                    if (itemdata.TryGetValue("cooldown", out obj) && double.TryParse((string)obj, out value))
                        data.Cooldown = value;
                    if (itemdata.TryGetValue("buy", out obj) && double.TryParse((string)obj, out value))
                        data.Buy = value;
                    if (itemdata.TryGetValue("sell", out obj) && double.TryParse((string)obj, out value))
                        data.Sell = value;
                    if (itemdata.TryGetValue("fixed", out obj))
                        data.Fixed = Convert.ToBoolean(obj);
                    if (itemdata.TryGetValue("img", out obj))
                        data.Img = (string)obj;
                    ShopCategories[shopCategory.Key] = data;
                }
                catch (Exception e)
                {
                    Puts("Failed to load ShopCategory: {0} Error: {1}", shopCategory.Key, e.Message);
                }
            }
            if (configChanged) SaveConfig();

            foreach (var itemData in ShopCategories.Values)
            {
                if (string.IsNullOrEmpty(itemData.Img)) continue;
                ImageCache?.CallHook("Add", itemData.Img);
            }
            if (!Economics) PrintWarning("Economics plugin not found. " + Name + " will not function!");
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Configs Manager ///////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T) Config[Key];
            else
            {
                Config[Key] = var;
                configChanged = true;
            }
        }

        class ItemData
        {
            public string Shortname { get; set; }
            public double Cooldown { get; set; }
            public double Buy { get; set; } = -1;
            public double Sell { get; set; } = -1;
            public bool Fixed { get; set; }
            public List<string> Cmd { get; set; }
            public string Img { get; set; }
        }

        private Dictionary<string, ItemData> ShopCategories = new Dictionary<string, ItemData>();
        private Dictionary<string, object> Shops = DefaultShops();
        private bool Balance;
        private bool Logging;
        private string IconUrl = string.Empty;

        string MessageShowNoEconomics = "Couldn't get informations out of Economics. Is it installed?";
        string MessageBought = "You've successfully bought {0}x {1}";
        string MessageSold = "You've successfully sold {0}x {1}";
        string MessageErrorCooldown = "This item has a cooldown of {0} seconds.";
        string MessageErrorCooldownAmount = "This item has a cooldown and amount is limited to 1.";
        string MessageErrorInventoryFull = "Your inventory is full.";
        string MessageErrorInventorySlots = "Your inventory needs {0} free slots.";
        string MessageErrorNoShop = "This shop doesn't seem to exist.";
        string MessageErrorNoActionShop = "You are not allowed to {0} in this shop";
        string MessageErrorNoNPC = "The NPC owning this shop was not found around you";
        string MessageErrorNoActionItem = "You are not allowed to {0} this item here";
        string MessageErrorItemItem = "WARNING: The admin didn't set this item properly! (item)";
        string MessageErrorItemNoValid = "WARNING: It seems like it's not a valid item";
        string MessageErrorRedeemKit = "WARNING: There was an error while giving you this kit";
        string MessageErrorBuyCmd = "Can't buy multiple";
        string MessageErrorBuyPrice = "WARNING: No buy price was given by the admin, you can't buy this item";
        string MessageErrorSellPrice = "WARNING: No sell price was given by the admin, you can't sell this item";
        string MessageErrorNotEnoughMoney = "You need {0} coins to buy {1} of {2}";
        string MessageErrorNotEnoughSell = "You don't have enough of this item.";
        string MessageErrorNotNothing = "You cannot buy nothing of this item.";
        string MessageErrorItemNoExist = "WARNING: The item you are trying to buy doesn't seem to exist";
        string MessageErrorNPCRange = "You may not use the chat shop. You might need to find the NPC Shops.";
        string MessageErrorBuildingBlocked = "You cannot shop while in building blocked area.";

        void Init()
        {
            CheckCfg("Shop - Shop Icon Url", ref IconUrl);
            CheckCfg("Shop - Shop List", ref Shops);
            CheckCfg("Shop - Balance", ref Balance);
            CheckCfg("Shop - Logging", ref Logging);
            CheckCfg("Message - Error - No Econonomics", ref MessageShowNoEconomics);
            CheckCfg("Message - Bought", ref MessageBought);
            CheckCfg("Message - Sold", ref MessageSold);
            CheckCfg("Message - Error - Cooldown", ref MessageErrorCooldown);
            CheckCfg("Message - Error - Cooldown Amount", ref MessageErrorCooldownAmount);
            CheckCfg("Message - Error - Invetory Full", ref MessageErrorInventoryFull);
            CheckCfg("Message - Error - Invetory Slots", ref MessageErrorInventorySlots);
            CheckCfg("Message - Error - No Shop", ref MessageErrorNoShop);
            CheckCfg("Message - Error - No Action In Shop", ref MessageErrorNoActionShop);
            CheckCfg("Message - Error - No NPC", ref MessageErrorNoNPC);
            CheckCfg("Message - Error - No Action Item", ref MessageErrorNoActionItem);
            CheckCfg("Message - Error - Item Not Set Properly", ref MessageErrorItemItem);
            CheckCfg("Message - Error - Item Not Valid", ref MessageErrorItemNoValid);
            CheckCfg("Message - Error - Redeem Kit", ref MessageErrorRedeemKit);
            CheckCfg("Message - Error - Command Multiple", ref MessageErrorBuyCmd);
            CheckCfg("Message - Error - No Buy Price", ref MessageErrorBuyPrice);
            CheckCfg("Message - Error - No Sell Price", ref MessageErrorSellPrice);
            CheckCfg("Message - Error - Not Enough Money", ref MessageErrorNotEnoughMoney);
            CheckCfg("Message - Error - Not Enough Items", ref MessageErrorNotEnoughSell);
            CheckCfg("Message - Error - Not Nothing", ref MessageErrorNotNothing);
            CheckCfg("Message - Error - Item Doesnt Exist", ref MessageErrorItemNoExist);
            CheckCfg("Message - Error - No Chat Shop", ref MessageErrorNPCRange);
            CheckCfg("Message - Error - Building Blocked", ref MessageErrorBuildingBlocked);
            if (configChanged) SaveConfig();
            LoadData();
        }

        void LoadData()
        {
            cooldowns = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, double>>>(nameof(GUIShop));
            buyed = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, ulong>>(nameof(GUIShop) + "Buyed");
            selled = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, ulong>>(nameof(GUIShop) + "Selled");
        }

        void SaveData()
        {
            if (cooldowns != null)
                Interface.Oxide.DataFileSystem.WriteObject(nameof(GUIShop), cooldowns);
            if (buyed != null)
                Interface.Oxide.DataFileSystem.WriteObject(nameof(GUIShop) + "Buyed", buyed);
            if (selled != null)
                Interface.Oxide.DataFileSystem.WriteObject(nameof(GUIShop) + "Selled", selled);
        }

        void Unload()
        {
            SaveData();
        }
        void OnServerSave()
        {
            SaveData();
        }
        void OnServerShutdown()
        {
            SaveData();
        }

        static int CurrentTime() { return Facepunch.Math.Epoch.Current; }

        //////////////////////////////////////////////////////////////////////////////////////
        // Default Shops for Tutorial purpoise ///////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        static Dictionary<string, object> DefaultShops()
        {
            var shops = new Dictionary<string, object>
            {
                {
                    "chat", new Dictionary<string, object>
                    {
                        {"buy", new List<object> {"Build Kit"}},
                        {"description", "You currently have {0} coins to spend in this builders shop"},
                        {"name", "Build"}
                    }
                },
                {
                    "5498734", new Dictionary<string, object>
                    {
                        {"description", "You currently have {0} coins to spend in this weapons shop"},
                        {"name", "Weaponsmith Shop"},
                        {"buy", new List<object> {"Assault Rifle", "Bolt Action Rifle"}},
                        {"sell", new List<object> {"Assault Rifle", "Bolt Action Rifle"}}
                    }
                },
                {
                    "1234567", new Dictionary<string, object>
                    {
                        {"description", "You currently have {0} coins to spend in this farmers market"},
                        {"name", "Fruit Market"},
                        {"buy", new List<object> {"Apple", "BlueBerries", "Assault Rifle", "Bolt Action Rifle"}},
                        {"sell", new List<object> {"Apple", "BlueBerries", "Assault Rifle", "Bolt Action Rifle"}}
                    }
                }
            };
            return shops;
        }
        static Dictionary<string, object> DefaultShopCategories()
        {
            var dsc = new Dictionary<string, object>
            {
                {
                    "Assault Rifle", new Dictionary<string, object>
                    {
                        {"item", "assault rifle"},
                        {"buy", "10"},
                        {"sell", "8"}
                    }
                },
                {
                    "Bolt Action Rifle", new Dictionary<string, object>
                    {
                        {"item", "bolt action rifle"},
                        {"buy", "10"}, {"sell", "8"}
                    }
                },
                {
                    "Build Kit", new Dictionary<string, object>
                    {
                        {"item", "kitbuild"},
                        {"buy", "10"},
                        {"sell", "8"},
                        {"img", "http://oxidemod.org/data/resource_icons/0/715.jpg?1425682952"}
                    }
                },
                {
                    "Apple", new Dictionary<string, object>
                    {
                        {"item", "apple"},
                        {"buy", "1"},
                        {"sell", "1"}
                    }
                },
                {
                    "BlueBerries", new Dictionary<string, object>
                    {
                        {"item", "blueberries"},
                        {"buy", "1"},
                        {"sell", "1"}
                    }
                }
            };
            return dsc;
        }



        //////////////////////////////////////////////////////////////////////////////////////
        // Item Management ///////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        readonly Dictionary<string, string> displaynameToShortname = new Dictionary<string, string>();

        //////////////////////////////////////////////////////////////////////////////////////
        // Oxide Hooks ///////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        void Loaded()
        {
            playersMask = LayerMask.GetMask("Player (Server)");
        }

        void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            if (!Shops.ContainsKey(npc.UserIDString)) return;
            ShowShop(player, npc.UserIDString, 0);
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // GUI ///////////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        private static CuiElementContainer CreateShopOverlay(string shopname)
        {
            return new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = "0.1 0.1 0.1 0.8"},
                        RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                        CursorEnabled = true
                    },
                    new CuiElement().Parent,
                    ShopOverlayName
                },
                {
                    new CuiLabel
                    {
                        Text = {Text = shopname, FontSize = 30, Align = TextAnchor.MiddleCenter},
                        RectTransform = {AnchorMin = "0.3 0.8", AnchorMax = "0.7 0.9"}
                    },
                    ShopOverlayName
                },
                {
                    new CuiLabel
                    {
                        Text = {Text = "Item", FontSize = 20, Align = TextAnchor.MiddleLeft},
                        RectTransform = {AnchorMin = "0.2 0.6", AnchorMax = "0.4 0.65"}
                    },
                    ShopOverlayName
                },
                {
                    new CuiLabel
                    {
                        Text = {Text = "Buy", FontSize = 20, Align = TextAnchor.MiddleLeft},
                        RectTransform = {AnchorMin = "0.55 0.6", AnchorMax = "0.7 0.65"}
                    },
                    ShopOverlayName
                },
                {
                    new CuiLabel
                    {
                        Text = {Text = "Sell", FontSize = 20, Align = TextAnchor.MiddleLeft},
                        RectTransform = {AnchorMin = "0.75 0.6", AnchorMax = "0.9 0.65"}
                    },
                    ShopOverlayName
                },
                {
                    new CuiButton
                    {
                        Button = {Close = ShopOverlayName, Color = "0.5 0.5 0.5 0.2"},
                        RectTransform = {AnchorMin = "0.5 0.15", AnchorMax = "0.7 0.2"},
                        Text = {Text = "Close", FontSize = 20, Align = TextAnchor.MiddleCenter}
                    },
                    ShopOverlayName
                }
            };
        }

        private readonly CuiLabel shopDescription = new CuiLabel
        {
            Text = { Text = "{shopdescription}", FontSize = 15, Align = TextAnchor.MiddleCenter },
            RectTransform = { AnchorMin = "0.2 0.7", AnchorMax = "0.8 0.79" }
        };

        private CuiElementContainer CreateShopItemEntry(string price, float ymax, float ymin, string shop, string item, string color, bool sell, bool cooldown)
        {
            var container = new CuiElementContainer
            {
                {
                    new CuiLabel
                    {
                        Text = {Text = price, FontSize = 15, Align = TextAnchor.MiddleLeft},
                        RectTransform = {AnchorMin = $"{(sell ? 0.725 : 0.45)} {ymin}", AnchorMax = $"{(sell ? 0.755 : 0.5)} {ymax}"}
                    },
                    ShopContentName
                }
            };
            for (var i = 0; i < steps.Length; i++)
            {
                container.Add(new CuiButton
                {
                    Button = {Command = $"shop.{(sell ? "sell" : "buy")} {shop} {item} {steps[i]}", Color = color},
                    RectTransform = {AnchorMin = $"{(sell ? 0.775 : 0.5) + i*0.03 + 0.001} {ymin}", AnchorMax = $"{(sell ? 0.805 : 0.53) + i*0.03 - 0.001} {ymax}"},
                    Text = {Text = steps[i].ToString(), FontSize = 15, Align = TextAnchor.MiddleCenter}
                }, ShopContentName);
                if (cooldown) break;
            }
            if (!cooldown)
            {
                container.Add(new CuiButton
                {
                    Button = { Command = $"shop.{(sell ? "sell" : "buy")} {shop} {item} all", Color = color },
                    RectTransform = { AnchorMin = $"{(sell ? 0.775 : 0.5) + steps.Length * 0.03 + 0.001} {ymin}", AnchorMax = $"{(sell ? 0.805 : 0.53) + steps.Length * 0.03 - 0.001} {ymax}" },
                    Text = { Text = "All", FontSize = 15, Align = TextAnchor.MiddleCenter }
                }, ShopContentName);
            }
            return container;
        }

        private CuiElementContainer CreateShopItemIcon(string name, float ymax, float ymin, ItemData data)
        {
            string url = null;
            if (!string.IsNullOrEmpty(data.Img))
                url = data.Img;
            else if (!string.IsNullOrEmpty(data.Shortname))
                url = string.Format(IconUrl, data.Shortname);
            var label = new CuiLabel
            {
                Text = { Text = name, FontSize = 15, Align = TextAnchor.MiddleLeft },
                RectTransform = { AnchorMin = $"0.1 {ymin}", AnchorMax = $"0.3 {ymax}" }
            };
            if (string.IsNullOrEmpty(url))
                return new CuiElementContainer
                {
                    {
                        label,
                        ShopContentName
                    }
                };
            var rawImage = new CuiRawImageComponent();
            if (url.StartsWith("http") || url.StartsWith("file"))
            {
                var id = (string)ImageCache?.CallHook("Get", url);
                if (!string.IsNullOrEmpty(id))
                    rawImage.Png = id;
                else
                    rawImage.Url = url;
                rawImage.Sprite = "assets/content/textures/generic/fulltransparent.tga";
            }
            else
                rawImage.Sprite = url;
            var container = new CuiElementContainer
            {
                {
                    label,
                    ShopContentName
                },
                new CuiElement
                {
                    Parent = ShopContentName,
                    Components =
                    {
                        rawImage,
                        new CuiRectTransformComponent {AnchorMin = $"0.05 {ymin}", AnchorMax = $"0.08 {ymax}"}
                    }
                }
            };
            return container;
        }

        private static CuiElementContainer CreateShopChangePage(string currentshop, int shoppageminus, int shoppageplus)
        {
            return new CuiElementContainer
            {
                {
                    new CuiButton
                    {
                        Button = {Command = $"shop.show {currentshop} {shoppageminus}", Color = "0.5 0.5 0.5 0.2"},
                        RectTransform = {AnchorMin = "0.2 0.15", AnchorMax = "0.3 0.2"},
                        Text = {Text = "<<", FontSize = 20, Align = TextAnchor.MiddleCenter}
                    },
                    ShopOverlayName,
                    "ButtonBack"
                },
                {
                    new CuiButton
                    {
                        Button = {Command = $"shop.show {currentshop} {shoppageplus}", Color = "0.5 0.5 0.5 0.2"},
                        RectTransform = {AnchorMin = "0.35 0.15", AnchorMax = "0.45 0.2"},
                        Text = {Text = ">>", FontSize = 20, Align = TextAnchor.MiddleCenter}
                    },
                    ShopOverlayName,
                    "ButtonForward"
                }
            };
        }

        readonly Hash<ulong, int> shopPage = new Hash<ulong, int>();
        private Dictionary<ulong, Dictionary<string, double>> cooldowns;
        private Dictionary<string, ulong> buyed;
        private Dictionary<string, ulong> selled;
        private bool configChanged;

        void ShowShop(BasePlayer player, string shopid, int from = 0, bool fullPaint = true, bool refreshMoney = false)
        {
            shopPage[player.userID] = from;
            object shopObj;
            if (!Shops.TryGetValue(shopid, out shopObj))
            {
                SendReply(player, MessageErrorNoShop);
                return;
            }
            if (Economics == null)
            {
                SendReply(player, MessageShowNoEconomics);
                return;
            }
            var playerCoins = (double) Economics.CallHook("GetPlayerMoney", player.userID);

            var shop = (Dictionary<string, object>) shopObj;

            shopDescription.Text.Text = string.Format((string) shop["description"], playerCoins);

            if (refreshMoney)
            {
                CuiHelper.DestroyUi(player, ShopDescOverlay);
                CuiHelper.AddUi(player, new CuiElementContainer { { shopDescription, ShopOverlayName, ShopDescOverlay } });
                return;
            }
            DestroyUi(player, fullPaint);
            CuiElementContainer container;
            if (fullPaint)
            {
                container = CreateShopOverlay((string) shop["name"]);
                container.Add(shopDescription, ShopOverlayName, ShopDescOverlay);
            }
            else
                container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0.2", AnchorMax = "1 0.6" }
            }, ShopOverlayName, ShopContentName);
            if (from < 0)
            {
                CuiHelper.AddUi(player, container);
                return;
            }

            var itemslist = new Dictionary<string, Dictionary<string, bool>>();
            object type;
            if (shop.TryGetValue("sell", out type))
            {
                foreach (string itemname in (List<object>)type)
                {
                    Dictionary<string, bool> itemEntry;
                    if (!itemslist.TryGetValue(itemname, out itemEntry))
                        itemslist[itemname] = itemEntry = new Dictionary<string, bool>();
                    itemEntry["sell"] = true;
                }
            }
            if (shop.TryGetValue("buy", out type))
            {
                foreach (string itemname in (List<object>)type)
                {
                    Dictionary<string, bool> itemEntry;
                    if (!itemslist.TryGetValue(itemname, out itemEntry))
                        itemslist[itemname] = itemEntry = new Dictionary<string, bool>();
                    itemEntry["buy"] = true;
                }
            }
            var current = 0;
            foreach (var pair in itemslist)
            {
                ItemData data;
                if (!ShopCategories.TryGetValue(pair.Key, out data)) continue;

                if (current >= from && current < from + 7)
                {
                    var pos = 0.85f - 0.125f * (current - from);

                    var cooldown = data.Cooldown > 0;
                    var name = pair.Key;
                    if (cooldown)
                        name += $" ({FormatTime((long)data.Cooldown)})";
                    container.AddRange(CreateShopItemIcon(name, pos + 0.125f, pos, data));
                    var buyed = false;
                    if (cooldown)
                    {
                        Dictionary<string, double> itemCooldowns;
                        double itemCooldown;
                        if (cooldowns.TryGetValue(player.userID, out itemCooldowns)
                            && itemCooldowns.TryGetValue(pair.Key, out itemCooldown)
                            && itemCooldown > CurrentTime())
                        {
                            buyed = true;
                            container.Add(new CuiLabel
                            {
                                Text = {Text = GetBuyPrice(data).ToString(), FontSize = 15, Align = TextAnchor.MiddleLeft},
                                RectTransform = {AnchorMin = $"0.45 {pos}", AnchorMax = $"0.5 {pos + 0.125f}"}
                            }, ShopContentName);
                            container.Add(new CuiLabel
                            {
                                Text = {Text = FormatTime((long)(itemCooldown - CurrentTime())), FontSize = 15, Align = TextAnchor.MiddleLeft},
                                RectTransform = {AnchorMin = $"0.5 {pos}", AnchorMax = $"0.6 {pos + 0.125f}"}
                            }, ShopContentName);
                            //current++;
                            //continue;
                        }
                    }
                    if (!buyed && pair.Value.ContainsKey("buy"))
                        container.AddRange(CreateShopItemEntry(GetBuyPrice(data).ToString(), pos + 0.125f, pos, $"'{shopid}'", $"'{pair.Key}'", "0 0.6 0 0.1", false, data.Cmd != null));
                    if (pair.Value.ContainsKey("sell"))
                        container.AddRange(CreateShopItemEntry(GetSellPrice(data).ToString(), pos + 0.125f, pos, $"'{shopid}'", $"'{pair.Key}'", "1 0 0 0.1", true, data.Cmd != null));
                }
                current++;
            }
            var minfrom = from <= 7 ? 0 : from - 7;
            var maxfrom = from + 7 >= current ? from : from + 7;
            container.AddRange(CreateShopChangePage(shopid, minfrom, maxfrom));
            CuiHelper.AddUi(player, container);
        }

        double GetBuyPrice(ItemData data)
        {
            if (!Balance || data.Fixed) return data.Buy;
            return Math.Round(data.Buy * GetFactor(data), 2);
        }

        double GetSellPrice(ItemData data)
        {
            if (!Balance || data.Fixed) return data.Sell;
            return Math.Round(data.Sell * GetFactor(data), 2);
        }

        double GetFactor(ItemData data)
        {
            if (data.Shortname == null) return 1;
            var itemname = data.Shortname;
            ulong buy;
            if (!buyed.TryGetValue(itemname, out buy))
                buy = 1;
            ulong sell;
            if (!selled.TryGetValue(itemname, out sell))
                sell = 1;
            return Math.Min(Math.Max(buy / (double)sell, .5), 2);
        }

        private static string FormatTime(long seconds)
        {
            var timespan = TimeSpan.FromSeconds(seconds);
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, Math.Floor(timespan.TotalHours));
        }
        //////////////////////////////////////////////////////////////////////////////////////
        // Shop Functions ////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        object CanDoAction(BasePlayer player, string shop, string item, string ttype)
        {
            var shopdata = (Dictionary<string, object>) Shops[shop];
            if (!shopdata.ContainsKey(ttype))
                return string.Format(MessageErrorNoActionShop, ttype);
            var actiondata = (List<object>) shopdata[ttype];
            if (!actiondata.Contains(item))
                return string.Format(MessageErrorNoActionItem, ttype);
            return true;
        }

        bool CanFindNPC(Vector3 pos, string npcid)
        {
            return Physics.OverlapSphere(pos, 3f, playersMask).Select(col => col.GetComponentInParent<BasePlayer>()).Any(player => player != null && player.UserIDString == npcid);
        }

        object CanShop(BasePlayer player, string shopname)
        {
            if (!Shops.ContainsKey(shopname)) return MessageErrorNoShop;
            if (shopname != "chat" && !CanFindNPC(player.transform.position, shopname))
                return MessageErrorNoNPC;
            return true;
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Buy Functions /////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        object TryShopBuy(BasePlayer player, string shop, string item, int amount)
        {
            if (amount <= 0) return false;
            object success = CanShop(player, shop);
            if (success is string) return success;
            success = CanDoAction(player, shop, item, "buy");
            if (success is string) return success;
            success = CanBuy(player, item, amount);
            if (success is string) return success;
            success = TryGive(player, item, amount);
            if (success is string) return success;
            var data = ShopCategories[item];
            var tryShopBuy = Economics?.CallHook("Withdraw", player.userID, GetBuyPrice(data) * amount);
            if (tryShopBuy == null || tryShopBuy is bool && !(bool) tryShopBuy)
                return MessageShowNoEconomics;
            if (data.Cooldown > 0)
            {
                Dictionary<string, double> itemCooldowns;
                if (!cooldowns.TryGetValue(player.userID, out itemCooldowns))
                    cooldowns[player.userID] = itemCooldowns = new Dictionary<string, double>();
                itemCooldowns[item] = CurrentTime() + data.Cooldown*amount;
            }
            if (!string.IsNullOrEmpty(data.Shortname))
            {
                ulong count;
                buyed.TryGetValue(data.Shortname, out count);
                buyed[data.Shortname] = count + (ulong) amount;
            }
            return tryShopBuy;
        }

        object TryGive(BasePlayer player, string item, int amount)
        {
            var data = ShopCategories[item];
            if (!string.IsNullOrEmpty(data.Shortname))
            {
                if (player.inventory.containerMain.IsFull()) return MessageErrorInventoryFull;
                object iskit = Kits?.CallHook("isKit", data.Shortname);
                if (iskit is bool && (bool)iskit)
                {
                    object successkit = Kits.CallHook("GiveKit", player, data.Shortname);
                    if (successkit is bool && !(bool)successkit) return MessageErrorRedeemKit;
                    if (Logging) Puts("Player: {0} Buyed Kit: {1}", player.displayName, data.Shortname);
                    return true;
                }
                object success = GiveItem(player, data, amount, player.inventory.containerMain);
                if (success is string) return success;
                if (Logging) Puts("Player: {0} Buyed Item: {1} x{2}", player.displayName, data.Shortname, amount);
            }
            if (data.Cmd != null)
            {
                var cmds = data.Cmd;
                for (var i = 0; i < cmds.Count; i++)
                {
                    var c = cmds[i]
                        .Replace("$player.id", player.UserIDString)
                        .Replace("$player.name", player.displayName)
                        .Replace("$player.x", player.transform.position.x.ToString())
                        .Replace("$player.y", player.transform.position.y.ToString())
                        .Replace("$player.z", player.transform.position.z.ToString());
                    if (c.StartsWith("shop.show close", StringComparison.OrdinalIgnoreCase))
                        NextTick(() => ConsoleSystem.Run.Server.Normal(c));
                    else
                        ConsoleSystem.Run.Server.Normal(c);
                }
                if (Logging) Puts("Player: {0} Buyed command: {1}", player.displayName, item);
            }
            return true;
        }

        private int GetAmountBuy(BasePlayer player, string item)
        {
            if (player.inventory.containerMain.IsFull()) return 0;
            var data = ShopCategories[item];
            var definition = ItemManager.FindItemDefinition(data.Shortname);
            if (definition == null) return 0;
            var stack = definition.stackable;
            if (stack < 1) stack = 1;
            var freeSlots = player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count;
            var slotAmount = freeSlots*stack;
            var balanceAmount = (int)((double)Economics.CallHook("GetPlayerMoney", player.userID) / GetBuyPrice(data));
            return slotAmount < balanceAmount ? slotAmount : balanceAmount;
        }

        private object GiveItem(BasePlayer player, ItemData data, int amount, ItemContainer pref)
        {
            if (amount <= 0) return MessageErrorNotNothing;
            var definition = ItemManager.FindItemDefinition(data.Shortname);
            if (definition == null) return MessageErrorItemNoExist;
            int stack = definition.stackable;
            if (stack < 1) stack = 1;
            if (pref.itemList.Count + Math.Ceiling(amount / (float)stack) > pref.capacity)
                return string.Format(MessageErrorInventorySlots, Math.Ceiling(amount / (float)stack));
            for (var i = amount; i > 0; i = i - stack)
            {
                var giveamount = i >= stack ? stack : i;
                if (giveamount < 1) return true;
                var item = ItemManager.CreateByItemID(definition.itemid, giveamount);
                if (!player.inventory.GiveItem(item, pref))
                    item.Remove(0);
            }
            return true;
        }
        object CanBuy(BasePlayer player, string item, int amount)
        {
            if (Economics == null) return MessageShowNoEconomics;
            if (!ShopCategories.ContainsKey(item)) return MessageErrorItemNoValid;

            var data = ShopCategories[item];
            if (data.Buy < 0) return MessageErrorBuyPrice;
            if (data.Cmd != null && amount > 1) return MessageErrorBuyCmd;
            var buyprice = GetBuyPrice(data);

            var playerCoins = (double) Economics.CallHook("GetPlayerMoney", player.userID);
            if (playerCoins < buyprice*amount)
                return string.Format(MessageErrorNotEnoughMoney, buyprice*amount, amount, item);
            if (data.Cooldown > 0)
            {
                //if (data.Cmd != null && amount > 1)
                //    return MessageErrorCooldownAmount;
                Dictionary<string, double> itemCooldowns;
                double itemCooldown;
                if (cooldowns.TryGetValue(player.userID, out itemCooldowns)
                    && itemCooldowns.TryGetValue(item, out itemCooldown)
                    && itemCooldown > CurrentTime())
                {
                    return string.Format(MessageErrorCooldown, FormatTime((long) (itemCooldown - CurrentTime())));
                }
            }
            return true;
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Sell Functions ////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        object TryShopSell(BasePlayer player, string shop, string item, int amount)
        {
            object success = CanShop(player, shop);
            if (success is string) return success;
            success = CanDoAction(player, shop, item, "sell");
            if (success is string) return success;
            success = CanSell(player, item, amount);
            if (success is string) return success;
            success = TrySell(player, item, amount);
            if (success is string) return success;
            var data = ShopCategories[item];
            /*if (itemdata.ContainsKey("cooldown"))
            {
                var cooldown = Convert.ToDouble(itemdata["cooldown"]);
                if (cooldown > 0)
                {
                    Dictionary<string, double> itemCooldowns;
                    if (!cooldowns.TryGetValue(player.userID, out itemCooldowns))
                        cooldowns[player.userID] = itemCooldowns = new Dictionary<string, double>();
                    itemCooldowns[item] = CurrentTime() + cooldown * amount;
                }
            }*/
            Economics?.CallHook("Deposit", player.userID, GetSellPrice(data) * amount);
            if (!string.IsNullOrEmpty(data.Shortname))
            {
                ulong count;
                selled.TryGetValue(data.Shortname, out count);
                selled[data.Shortname] = count + (ulong)amount;
            }
            return true;
        }
        object TrySell(BasePlayer player, string item, int amount)
        {
            var data = ShopCategories[item];
            if (string.IsNullOrEmpty(data.Shortname)) return MessageErrorItemItem;
            object iskit = Kits?.CallHook("isKit", data.Shortname);

            if (iskit is bool && (bool)iskit) return "You can't sell kits";
            object success = TakeItem(player, data, amount);
            if (success is string) return success;
            if (Logging) Puts("Player: {0} Selled Item: {1} x{2}", player.displayName, data.Shortname, amount);
            return true;
        }

        private int GetAmountSell(BasePlayer player, string item)
        {
            var data = ShopCategories[item];
            var definition = ItemManager.FindItemDefinition(data.Shortname);
            //Puts("Def: {0}", definition?.shortname);
            if (definition == null) return 0;
            //Puts("GetAmount: {0} {1}", definition.shortname, player.inventory.containerMain.GetAmount(definition.itemid, true));
            return player.inventory.containerMain.GetAmount(definition.itemid, true);
        }
        private object TakeItem(BasePlayer player, ItemData data, int amount)
        {
            if (amount <= 0) return MessageErrorNotEnoughSell;
            var definition = ItemManager.FindItemDefinition(data.Shortname);
            if (definition == null) return MessageErrorItemNoExist;

            var pamount = player.inventory.GetAmount(definition.itemid);
            if (pamount < amount) return MessageErrorNotEnoughSell;
            player.inventory.Take(null, definition.itemid, amount);
            return true;
        }

        object CanSell(BasePlayer player, string item, int amount)
        {
            if (!ShopCategories.ContainsKey(item)) return MessageErrorItemNoValid;
            var itemdata = ShopCategories[item];
            if (itemdata.Sell < 0) return MessageErrorSellPrice;
            if (false && itemdata.Cooldown > 0)
            {
                if (amount > 1)
                    return MessageErrorCooldownAmount;
                Dictionary<string, double> itemCooldowns;
                double itemCooldown;
                if (cooldowns.TryGetValue(player.userID, out itemCooldowns)
                    && itemCooldowns.TryGetValue(item, out itemCooldown)
                    && itemCooldown > CurrentTime())
                {
                    return string.Format(MessageErrorCooldown, FormatTime((long) (itemCooldown - CurrentTime())));
                }
            }
            return true;
        }

        void DestroyUi(BasePlayer player, bool full = false)
        {
            CuiHelper.DestroyUi(player, ShopContentName);
            CuiHelper.DestroyUi(player, "ButtonForward");
            CuiHelper.DestroyUi(player, "ButtonBack");
            if (!full) return;
            CuiHelper.DestroyUi(player, ShopDescOverlay);
            CuiHelper.DestroyUi(player, ShopOverlayName);
        }
        //////////////////////////////////////////////////////////////////////////////////////
        // Chat Commands /////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        [ChatCommand("shop")]
        void cmdShop(BasePlayer player, string command, string[] args)
        {
            if(!Shops.ContainsKey("chat"))
            {
                SendReply(player, MessageErrorNPCRange);
                return;
            }
            if (!player.CanBuild())
            {
                SendReply(player, MessageErrorBuildingBlocked);
                return;
            }
            ShowShop(player, "chat");
        }

        //////////////////////////////////////////////////////////////////////////////////////
        // Console Commands //////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        [ConsoleCommand("shop.show")]
        void ccmdShopShow(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(2)) return;
            var shopid = arg.GetString(0).Replace("'", "");
            if (shopid.Equals("close", StringComparison.OrdinalIgnoreCase))
            {
                var targetPlayer = arg.GetPlayerOrSleeper(1);
                DestroyUi(targetPlayer, true);
                return;
            }
            var player = arg.Player();
            if (player == null) return;
            var shoppage = arg.GetInt(1);
            ShowShop(player, shopid, shoppage, false);
        }

        [ConsoleCommand("shop.buy")]
        void ccmdShopBuy(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(3)) return;
            var player = arg.Player();
            if (player == null) return;
            object success = Interface.Oxide.CallHook("canShop", player);
            if(success != null)
            {
                SendReply(player, success as string ?? "You are not allowed to shop at the moment");
                return;
            }

            string shop = arg.Args[0].Replace("'", "");
            string item = arg.Args[1].Replace("'", "");
            int amount = arg.Args[2].Equals("all") ? GetAmountBuy(player, item) : Convert.ToInt32(arg.Args[2]);
            success = TryShopBuy(player, shop, item, amount);
            if(success is string)
            {
                SendReply(player, (string)success);
                return;
            }
            SendReply(player, string.Format(MessageBought, amount, item));
            ShowShop(player, shop, shopPage[player.userID], false, true);
        }
        [ConsoleCommand("shop.sell")]
        void ccmdShopSell(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(3)) return;
            var player = arg.Player();
            if (player == null) return;
            object success = Interface.Oxide.CallHook("canShop", player);
            if (success != null)
            {
                string message = "You are not allowed to shop at the moment";
                if (success is string)
                    message = (string)success;
                SendReply(player, message);
                return;
            }
            string shop = arg.Args[0].Replace("'", "");
            string item = arg.Args[1].Replace("'", "");
            int amount = arg.Args[2].Equals("all") ? GetAmountSell(player, item) : Convert.ToInt32(arg.Args[2]);
            success = TryShopSell(player, shop, item, amount);
            if (success is string)
            {
                SendReply(player, (string)success);
                return;
            }
            SendReply(player, string.Format(MessageSold, amount, item));
            ShowShop(player, shop, shopPage[player.userID], false, true);
        }
    }
}


// --- End of file: GUIShop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XWipeCalendar.cs ---
// --- Original Local Path: XWipeCalendar.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XWipeCalendar", "SkuliDropek.", "1.0.501")]
    class XWipeCalendar : RustPlugin
    {
		#region Configuration

        private CalendarConfig config;

        private class CalendarConfig
        {
			internal class GeneralSetting
			{
				[JsonProperty("Закрытие календаря нажатием в любой точке экрана")] public bool ButtonClose;
				[JsonProperty("Часовой пояс - UTC+0:00")] public int GMT;
			}
			
			internal class GUISetting
			{
				[JsonProperty("Цвет фона_1")] public string ColorBackgroundO;					
				[JsonProperty("Цвет фона_2")] public string ColorBackgroundT;				
				[JsonProperty("Цвет чисел текучего месяца")] public string ColorNumericM;					
				[JsonProperty("Цвет чисел следующего месяца")] public string ColorNumericNM;				
				[JsonProperty("Цвет блоков")] public string ColorBlock;				
			}
			
			internal class EventsSetting
		    {
				[JsonProperty("Цвет")] public string Color;			
				[JsonProperty("Список дней события")] public List<int> Day; 
				
				public EventsSetting(string color, List<int> day)
				{
					Color = color; Day = day;
				}
			}
				
			[JsonProperty("Общие настройки")]
			public GeneralSetting Setting = new GeneralSetting();
			[JsonProperty("Настройка GUI")]
			public GUISetting GUI;			
			[JsonProperty("Список событий. Описание событий - oxide/lang/(ru/en)")]
			public Dictionary<int, List<EventsSetting>> Events;
			[JsonProperty("Время по МСК")]			
			public DateTime MSCTime;
			
			public static CalendarConfig GetNewConfiguration()
            {
                return new CalendarConfig
                {
					Setting = new GeneralSetting
					{
						ButtonClose = false,
						GMT = 3
					},
					GUI = new GUISetting
					{
						ColorBackgroundO = "0.517 0.521 0.509 0.95",
						ColorBackgroundT = "0.217 0.221 0.209 0.95",
						ColorNumericM = "1 1 1 0.75",
						ColorNumericNM = "1 1 1 0.1",
						ColorBlock = "0.417 0.421 0.409 0.95"
					},
					Events = new Dictionary<int, List<EventsSetting>>
					{
						[1] = new List<EventsSetting>
						{
						    new EventsSetting("0.61 0.18 0.18 1", new List<int> { 3, 16 } ),
						    new EventsSetting("0.5 0.18 0.61 1", new List<int> { 5, 29 } ),
						    new EventsSetting("0.18 0.21 0.61 1", new List<int> { 8, 14 } ),
						    new EventsSetting("0.18 0.49 0.61 1", new List<int> { 21, 30 } ),
						    new EventsSetting("0.21 0.61 0.18 1", new List<int> { 11 } ),
						    new EventsSetting("0.61 0.55 0.18 1", new List<int> { 29 } ),
						    new EventsSetting("0.61 0.31 0.18 1", new List<int> { 25 } )
						},						
						[3] = new List<EventsSetting>
						{
						    new EventsSetting("0.61 0.18 0.18 1", new List<int> { 3, 16 } ),
						    new EventsSetting("0.5 0.18 0.61 1", new List<int> { 5, 29 } ),
						    new EventsSetting("0.18 0.21 0.61 1", new List<int> { 8, 14 } ),
						    new EventsSetting("0.18 0.49 0.61 1", new List<int> { 21, 30 } ),
						    new EventsSetting("0.21 0.61 0.18 1", new List<int> { 11 } ),
						    new EventsSetting("0.61 0.55 0.18 1", new List<int> { 29 } ),
						    new EventsSetting("0.61 0.31 0.18 1", new List<int> { 25 } )
						},						
						[5] = new List<EventsSetting>
						{
						    new EventsSetting("0.61 0.18 0.18 1", new List<int> { 3, 16 } ),
						    new EventsSetting("0.5 0.18 0.61 1", new List<int> { 5, 29 } ),
						    new EventsSetting("0.18 0.21 0.61 1", new List<int> { 8, 14 } ),
						    new EventsSetting("0.18 0.49 0.61 1", new List<int> { 21, 30 } ),
						    new EventsSetting("0.21 0.61 0.18 1", new List<int> { 11 } ),
						    new EventsSetting("0.61 0.55 0.18 1", new List<int> { 29 } ),
						    new EventsSetting("0.61 0.31 0.18 1", new List<int> { 25 } )
						}
					}
				};
			}
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<CalendarConfig>();
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = CalendarConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion 
		
		#region Gommands
		
		[ChatCommand("wipe")]
		private void cmdOpenGUI(BasePlayer player)
		{
			if (permission.UserHasPermission(player.UserIDString, "xwipecalendar.use"))
			    GUI(player, config.MSCTime.Month);
			else
				SendReply(player, lang.GetMessage("CHATNP", this, player.UserIDString));
		}		
		
		[ChatCommand("calendar")]
		private void cmdOpenGUII(BasePlayer player)
		{
			if (permission.UserHasPermission(player.UserIDString, "xwipecalendar.use"))
			    GUI(player, config.MSCTime.Month);
			else
				SendReply(player, lang.GetMessage("CHATNP", this, player.UserIDString));
		}
		
		[ConsoleCommand("wipe_page")]
		private void ccmdPage(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			
			if(player == null) return;
			
			GUI(player, int.Parse(args.Args[0]));
			EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3()), player.Connection);
		}
		
		#endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{		
			PrintWarning("\n-----------------------------\n" +
			"     Author - SkuliDropek\n" +
			"     VK - vk.com/idannopol\n" +
			"    Discord - Skuli Dropek#4816 - KINGSkuliDropek#4837\n" +
			"     Config - v.1520\n" +
			"-----------------------------");
			
			permission.RegisterPermission("xwipecalendar.use", this);
			
			InitializeLang();
			MSC();
		}
		
		private void OnServerSave() => MSC();
		
		private void MSC()
		{
			webrequest.Enqueue("http://worldtimeapi.org/api/timezone/Europe/London", null, (code, response) =>
            {
                if (code != 200 || response == null) return;
				
			    config.MSCTime = new DateTime(1970, 1, 1, 0, 0, 0, 0).AddSeconds(double.Parse(JsonConvert.DeserializeObject<JObject>(response)["unixtime"].ToString()) + (config.Setting.GMT * 3600));
			    Config.WriteObject(config, true);
            }, this);
		}
		
		#endregion
		
		#region GUI
		
		private void GUI(BasePlayer player, int Page = 1)
		{
			CuiHelper.DestroyUi(player, ".WIPECALENDAR_B");
            CuiElementContainer container = new CuiElementContainer();
				
			container.Add(new CuiPanel
            {
				CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", ".WIPECALENDAR_B");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-357.5 -217.5", OffsetMax = "357.5 317.5" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = "assets/icons/greyout.mat" }
            }, ".WIPECALENDAR_B", ".WIPECALENDAR");
			
			if (config.Setting.ButtonClose)
			    container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-350 -125", OffsetMax = "350 125" },
                    Button = { Color = "0 0 0 0", Close = ".WIPECALENDAR_B" },
                    Text = { Text = "" }
                }, ".WIPECALENDAR");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Image = { Color = config.GUI.ColorBackgroundT }
            }, ".WIPECALENDAR", ".WIPECALENDAR_GUI");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-357.5 220", OffsetMax = "357.5 225" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".WIPECALENDAR");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "309 220", OffsetMax = "314 267.5" },
                Image = { Color = config.GUI.ColorBackgroundO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".WIPECALENDAR");	
			
			int year = config.MSCTime.Year;
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-350 220", OffsetMax = "350 267.5" },
                Text = { Text = string.Format(lang.GetMessage("TITLE", this, player.UserIDString), lang.GetMessage(new DateTime(year, Page, 1).ToString("MMMM"), this, player.UserIDString), year), Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "1 1 1 0.75" }
            }, ".WIPECALENDAR");
			
		    container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "319 230", OffsetMax = "347.5 257.5" },
                Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/close.png", Close = ".WIPECALENDAR_B" },
                Text = { Text = "" }
            }, ".WIPECALENDAR");

            int countbutton = 12;

			for(int i = 1; i <= 12; i++)
			{
                double offset = -(13.25 * countbutton--) + -(2.5 * countbutton--);

			    container.Add(new CuiButton
                {
					RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offset} -300", OffsetMax = $"{offset + 27.5} -272.5" },
                    Button = { Color = "0 0 0 0", Command = config.Events.ContainsKey(i) ? $"wipe_page {i}" : "" },
                    Text = { Text = $"{i}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 18, Color = Page == i ? "0.53 0.77 0.35 1" : config.Events.ContainsKey(i) ? "1 1 1 1" : "0.75 0.75 0.75 0.5" }
                }, ".WIPECALENDAR");
			}
			
			int x = 0, y = 0, z = 1, h = 0, g = 0, j = 0;
			
			for (int i = 1; i <= 42; i++)
			{
				container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-347.5 + (x * 100)} {132.5 - (y * 65)}", OffsetMax = $"{-252.5 + (x * 100)} {192.5 - (y * 65)}" },
                    Image = { Color = config.GUI.ColorBlock, Material = "assets/content/ui/uibackgroundblur.mat" }
                }, ".WIPECALENDAR_GUI", ".GUII" + i);
				
				x++;
					
			    if (x == 7)
				{
				    x = 0;
					y++;
					
					if (y == 6)
						break;
				}
			}
			
			DateTime date = new DateTime(year, Page, 1);
			int dayscount = DateTime.DaysInMonth(year, Page);
			int dayofweek = (int)date.DayOfWeek == 0 ? 7 : (int)date.DayOfWeek;
			
			if(config.MSCTime.Month == Page)
				container.Add(new CuiElement  
				{
					Parent = ".GUII" + (config.MSCTime.Day + dayofweek - 1),
					Components = 
					{ 
						new CuiImageComponent { Color = "0.417 0.421 0.409 0.95", Material = "assets/content/ui/uibackgroundblur.mat" },
						new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
						new CuiOutlineComponent { Color = "0.7501520 0.7501520 0.7501520 1", Distance = "1.5 1.5" }
					}
				});
			
			if(config.Events.ContainsKey(Page))
			{
				int countEvMon = config.Events[Page].Count;
			
				foreach(var events in config.Events[Page])
				{
					foreach(var eventscolor in events.Day)
					{
						if (eventscolor + dayofweek - 1 > 42) continue;  
						
						container.Add(new CuiPanel
						{
							RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
							Image = { Color = events.Color, Material = "assets/content/ui/uibackgroundblur.mat" }
						}, ".GUII" + (eventscolor + dayofweek - 1));
					}
					
					double offset = -(47.5 * countEvMon--) + -(2.5 * countEvMon--);
					
					container.Add(new CuiPanel
					{
						RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offset} -257.5", OffsetMax = $"{offset + 95} -197.5" },
						Image = { Color = events.Color, Material = "assets/content/ui/uibackgroundblur.mat" }
					}, ".WIPECALENDAR_GUI", ".EventText");
					
					container.Add(new CuiLabel
					{
						RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
						Text = { Text = lang.GetMessage("EVENT" + (1 + g), this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 14, Color = "1 1 1 0.7501520" }
					}, ".EventText");
					
					g++;
				
					if (g == 7)
						break;
				}
			}
			
			for (int i = 0; i <= 6; i++)
			{
				container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-347.5 + (h * 100)} 196", OffsetMax = $"{-252.5 + (h * 100)} 216" },
                    Text = { Text = lang.GetMessage("DAY" + (1 + i), this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 14, Color = "1 1 1 0.7501520" }
                }, ".WIPECALENDAR_GUI");
				
				h++;
			}
			
			int count = ++dayscount;

			for (int i = 0; i <= 41; i++)
			{
				container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = $"{z}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 30, Color = j != 0 ? config.GUI.ColorNumericNM : config.GUI.ColorNumericM }
                }, ".GUII" + (i + dayofweek));
				
				z++;
				if (z == count)
				{
					j++;
					z = 1;
				}
			}
			
			CuiHelper.AddUi(player, container);
		}
		
		#endregion
		
		#region Lang

        private void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE"] = "CALENDAR COOL SERVER | {0} - {1}",					
                ["CHATNP"] = "No permission!",					
			    ["January"] = "JANUARY",
			    ["February"] = "FEBRUARY",
			    ["March"] = "MARCH",
			    ["April"] = "APRIL",
			    ["May"] = "MAY",
			    ["June"] = "JUNE",
			    ["July"] = "JULY",
			    ["August"] = "AUGUST",
			    ["September"] = "SEPTEMBER",
			    ["October"] = "OCTOBER",
			    ["November"] = "NOVEMBER",
			    ["December"] = "DECEMBER",					
			    ["DAY1"] = "MONDAY",
			    ["DAY2"] = "TUESDAY",
			    ["DAY3"] = "WEDNESDAY",
			    ["DAY4"] = "THURSDAY",
			    ["DAY5"] = "FRIDAY",
			    ["DAY6"] = "SATURDAY",
			    ["DAY7"] = "SUNDAY",
                ["EVENT1"] = "EVENT 1",				
                ["EVENT2"] = "EVENT 2",				
                ["EVENT3"] = "EVENT 3",				
                ["EVENT4"] = "EVENT 4",				
                ["EVENT5"] = "EVENT 5",				
                ["EVENT6"] = "EVENT 6",				
                ["EVENT7"] = "EVENT 7",				
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE"] = "КАЛЕНДАРЬ КРУТОГО СЕРВЕРА | {0} - {1}",					
                ["CHATNP"] = "Недостаточно прав!",					
			    ["January"] = "ЯНВАРЬ",
			    ["February"] = "ФЕВРАЛЬ",
			    ["March"] = "МАРТ",
			    ["April"] = "АПРЕЛЬ",
			    ["May"] = "МАЙ",
			    ["June"] = "ИЮНЬ",
			    ["July"] = "ИЮЛЬ",
			    ["August"] = "АВГУСТ",
			    ["September"] = "СЕНТЯБРЬ",
			    ["October"] = "ОКТЯБРЬ",
			    ["November"] = "НОЯБРЬ",
			    ["December"] = "ДЕКАБРЬ",					
			    ["DAY1"] = "ПОНЕДЕЛЬНИК",
			    ["DAY2"] = "ВТОРНИК",
			    ["DAY3"] = "СРЕДА",
			    ["DAY4"] = "ЧЕТВЕРГ",
			    ["DAY5"] = "ПЯТНИЦА",
			    ["DAY6"] = "СУББОТА",
			    ["DAY7"] = "ВОСКРЕСЕНЬЕ",
                ["EVENT1"] = "СОБЫТИЕ 1",				
                ["EVENT2"] = "СОБЫТИЕ 2",				
                ["EVENT3"] = "СОБЫТИЕ 3",				
                ["EVENT4"] = "СОБЫТИЕ 4",				
                ["EVENT5"] = "СОБЫТИЕ 5",				
                ["EVENT6"] = "СОБЫТИЕ 6",				
                ["EVENT7"] = "СОБЫТИЕ 7"				
            }, this, "ru");            
			
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE"] = "SERVIDOR DE CALENDARIO COOL | {0} - {1}",					
                ["CHATNP"] = "¡No hay suficientes derechos!",					
			    ["January"] = "ENERO",
			    ["February"] = "FEBRERO",
			    ["March"] = "MARZO",
			    ["April"] = "ABRIL",
			    ["May"] = "MAYO",
			    ["June"] = "JUNIO",
			    ["July"] = "JULIO",
			    ["August"] = "AGOSTO",
			    ["September"] = "SEPTIMBRE",
			    ["October"] = "OCTUBRE",
			    ["November"] = "NOVIEMBRE",
			    ["December"] = "DECIEMBRE",					
			    ["DAY1"] = "LUNES",
			    ["DAY2"] = "MARTES",
			    ["DAY3"] = "MIERCOLES",
			    ["DAY4"] = "JUEVES",
			    ["DAY5"] = "VIERNES",
			    ["DAY6"] = "SABADO",
			    ["DAY7"] = "DOMINGO",
                ["EVENT1"] = "EVENTO 1",				
                ["EVENT2"] = "EVENTO 2",				
                ["EVENT3"] = "EVENTO 3",				
                ["EVENT4"] = "EVENTO 4",				
                ["EVENT5"] = "EVENTO 5",				
                ["EVENT6"] = "EVENTO 6",				
                ["EVENT7"] = "EVENTO 7",					
            }, this, "es-ES");
        }

        #endregion
	}
}

// --- End of file: XWipeCalendar.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SkinBox (1).cs ---
// --- Original Local Path: SkinBox (1).cs ---

using System;
using System.Text;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using UnityEngine;
using Steamworks;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("SkinBox", "FuJiCuRa", "1.16.3", ResourceId = 17)]
    [Description("SkinBox is a plugin to convert any skinnable item into each skin variant")]
    internal class SkinBox : RustPlugin
    {
        [PluginReference] private Plugin QuickSort, ServerRewards, Economics, StacksExtended;
        private bool skinsLoaded;
        private bool Initialized;
        private bool Changed;
        private static SkinBox skinBox = null;
        private bool activeServerRewards;
        private bool activeEconomics;
        private bool activePointSystem;
        private int maxItemsShown;
        private bool _stacksExtendedExtrasDisabled;
        private Dictionary<string, LinkedList<ulong>> skinsCache = new Dictionary<string, LinkedList<ulong>>();
        private Dictionary<string, LinkedList<ulong>> skinsCacheLimited = new Dictionary<string, LinkedList<ulong>>();
        private Dictionary<string, int> approvedSkinsCount = new Dictionary<string, int>();
        private Dictionary<string, DateTime> cooldownTimes = new Dictionary<string, DateTime>();
        private Dictionary<string, string> NameToItemName = new Dictionary<string, string>();
        private Dictionary<string, string> ItemNameToName = new Dictionary<string, string>();
        private Dictionary<string, object> manualAddedSkinsPre = new Dictionary<string, object>();
        private Dictionary<string, List<ulong>> manualAddedSkins = new Dictionary<string, List<ulong>>();
        private List<ulong> excludedSkins = new List<ulong>();
        private List<object> excludedSkinsPre = new List<object>();
        private Dictionary<ulong, SBH> activeSkinBoxes = new Dictionary<ulong, SBH>();
        private Dictionary<ulong, string> skinWorkshopNames = new Dictionary<ulong, string>();
        private List<object> altSkinBoxCommand;
        private string skinBoxCommand;
        private string permissionUse;
        private bool showLoadedSkinCounts;
        private int exludedSkinsAuthLevel;
        private bool hideQuickSort;
        private string steamApiKey;
        private int accessOverrideAuthLevel;
        private bool allowStackedItems;
        private bool enableCustomPerms;
        private string permCustomPlayerwearable;
        private string permCustomWeapon;
        private string permCustomDeployable;
        private bool useInbuiltSkins;
        private bool useApprovedSkins;
        private int approvedSkinsLimit;
        private bool useManualAddedSkins;
        private int maxPagesShown;
        private bool enableCooldown;
        private int cooldownBox;
        private bool cooldownOverrideAdmin;
        private int cooldownOverrideAuthLevel;
        private bool activateAfterSkinTaken;
        private bool enableUsageCost;
        private bool useServerRewards;
        private bool useEconomics;
        private int costBoxOpen;
        private int costWeapon;
        private int costPlayerwearable;
        private int costDeployable;
        private bool costExcludeAdmins;
        private string costExcludePerm;
        private bool costExcludePermEnabled;

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string, object> data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        private object getSkincache()
        {
            if (skinsLoaded) return new Dictionary<string, LinkedList<ulong>>(skinsCache);
            else return false;
        }

        private void LoadVariables()
        {
            useInbuiltSkins = Convert.ToBoolean(GetConfig("AvailableSkins", "useInbuiltSkins", true));
            useApprovedSkins = Convert.ToBoolean(GetConfig("AvailableSkins", "useApprovedSkins", false));
            approvedSkinsLimit = Convert.ToInt32(GetConfig("AvailableSkins", "approvedSkinsLimit", -1));
            useManualAddedSkins = Convert.ToBoolean(GetConfig("AvailableSkins", "useManualAddedSkins", true));
            maxPagesShown = Convert.ToInt32(GetConfig("AvailableSkins", "maxPagesShown", 2));
            skinBoxCommand = Convert.ToString(GetConfig("Settings", "skinBoxCommand", "skinbox"));
            altSkinBoxCommand = (List<object>)GetConfig("Settings", "altSkinBoxCommands", new List<object>());
            permissionUse = Convert.ToString(GetConfig("Settings", "permissionUse", "skinbox.use"));
            showLoadedSkinCounts = Convert.ToBoolean(GetConfig("Settings", "showLoadedSkinCounts", true));
            exludedSkinsAuthLevel = Convert.ToInt32(GetConfig("Settings", "exludedSkinsAuthLevel", 2));
            accessOverrideAuthLevel = Convert.ToInt32(GetConfig("Settings", "accessOverrideAuthLevel", 2));
            hideQuickSort = Convert.ToBoolean(GetConfig("Settings", "hideQuickSort", true));
            allowStackedItems = Convert.ToBoolean(GetConfig("Settings", "allowStackedItems", false));
            steamApiKey = Convert.ToString(GetConfig("Settings", "steamApiKey", "https://steamcommunity.com/dev/apikey << get it THERE and saved it HERE"));
            enableCustomPerms = Convert.ToBoolean(GetConfig("CustomPermissions", "enableCustomPerms", false));
            permCustomPlayerwearable = Convert.ToString(GetConfig("CustomPermissions", "permCustomPlayerwearable", "skinbox.playerwearable"));
            permCustomWeapon = Convert.ToString(GetConfig("CustomPermissions", "permCustomWeapon", "skinbox.weapon"));
            permCustomDeployable = Convert.ToString(GetConfig("CustomPermissions", "permCustomDeployable", "skinbox.deployable"));
            enableCooldown = Convert.ToBoolean(GetConfig("Cooldown", "enableCooldown", false));
            cooldownBox = Convert.ToInt32(GetConfig("Cooldown", "cooldownBox", 60));
            cooldownOverrideAdmin = Convert.ToBoolean(GetConfig("Cooldown", "cooldownOverrideAdmin", true));
            cooldownOverrideAuthLevel = Convert.ToInt32(GetConfig("Cooldown", "cooldownOverrideAuthLevel", 2));
            activateAfterSkinTaken = Convert.ToBoolean(GetConfig("Cooldown", "activateAfterSkinTaken", true));
            manualAddedSkinsPre = (Dictionary<string, object>) GetConfig("SkinsAdded", "SkinList", new Dictionary<string, object> { });
            excludedSkinsPre = (List<object>) GetConfig("SkinsExcluded", "SkinList", new List<object> { });
            enableUsageCost = Convert.ToBoolean(GetConfig("UsageCost", "enableUsageCost", false));
            useServerRewards = Convert.ToBoolean(GetConfig("UsageCost", "useServerRewards", true));
            useEconomics = Convert.ToBoolean(GetConfig("UsageCost", "useEconomics", false));
            costBoxOpen = Convert.ToInt32(GetConfig("UsageCost", "costBoxOpen", 5));
            costWeapon = Convert.ToInt32(GetConfig("UsageCost", "costWeapon", 30));
            costPlayerwearable = Convert.ToInt32(GetConfig("UsageCost", "costPlayerwearable", 20));
            costDeployable = Convert.ToInt32(GetConfig("UsageCost", "costDeployable", 10));
            costExcludeAdmins = Convert.ToBoolean(GetConfig("UsageCost", "costExcludeAdmins", true));
            costExcludePerm = Convert.ToString(GetConfig("UsageCost", "costExcludePerm", "skinbox.costexcluded"));
            costExcludePermEnabled = Convert.ToBoolean(GetConfig("UsageCost", "costExcludePermEnabled", false));
            bool configremoval = false;
            if ((Config.Get("AvailableSkins") as Dictionary<string, object>).ContainsKey("useWebskinsRankedByTrend"))
            {
                (Config.Get("AvailableSkins") as Dictionary<string, object>).Remove("useWebskinsRankedByTrend");
                (Config.Get("AvailableSkins") as Dictionary<string, object>).Remove("usedRankedByTrendDays");
                (Config.Get("AvailableSkins") as Dictionary<string, object>).Remove("usedConnectionsToWorkshop");
                configremoval = true;
            }

            if (!Changed & !configremoval)
                return;
            SaveConfig();
            Changed = false;
            configremoval = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"NoPermission", "You don't have permission to use the SkinBox"},
                    {"ToNearPlayer", "The SkinBox is currently not usable at this place"},
                    {"CooldownTime", "You need to wait {0} seconds to re-open the SkinBox again"},
                    {"NotEnoughBalanceOpen", "You need at least '{0}' bucks to open the SkinBox"},
                    {"NotEnoughBalanceUse", "You would need at least '{0}' bucks to skin '{1}'"},
                    {"NotEnoughBalanceTake", "'{0}' was not skinned. You had not enough bucks"},
                }, this);
        }

        private void Loaded()
        {
            LoadVariables();
            LoadDefaultMessages();
            if (allowStackedItems) SbscrbSplt();
            else UnsbscrbSplt();

            cmd.AddChatCommand(skinBoxCommand, this, "cmdSknBx");

            for (int i = 0; i < altSkinBoxCommand.Count; i++)
                cmd.AddChatCommand(altSkinBoxCommand[i].ToString(), this, "cmdSknBx");

            permission.RegisterPermission(permissionUse, this);
            permission.RegisterPermission(permCustomPlayerwearable, this);
            permission.RegisterPermission(permCustomWeapon, this);
            permission.RegisterPermission(permCustomDeployable, this);
            permission.RegisterPermission(costExcludePerm, this);
            skinsCache = new Dictionary<string, LinkedList<ulong>>();
            skinsCacheLimited = new Dictionary<string, LinkedList<ulong>>();
            approvedSkinsCount = new Dictionary<string, int>();
            NameToItemName = new Dictionary<string, string>();
            ItemNameToName = new Dictionary<string, string>();
            skinsLoaded = false;
            skinBox = this;
            if (maxPagesShown < 1) maxPagesShown = 1;
            maxItemsShown = 42 * maxPagesShown;
        }

        private void Unload()
        {
            List<SBH> objs = UnityEngine.Object.FindObjectsOfType<SBH>().ToList();
            if (objs.Count > 0)
                foreach (SBH obj in objs)
                {
                    if (obj.looter == null) continue;
                    obj.looter.EndLooting();
                    obj.PlayerStoppedLooting(obj.looter);
                    UnityEngine.Object.Destroy(obj);
                }

            if (Interface.Oxide.IsShuttingDown) return;
        }

        private void OnServerInitialized()
        {
            if (steamApiKey == null || steamApiKey == string.Empty || steamApiKey.Length != 32)
            {
                PrintWarning(_("FxvaObk pbasvt arrqf `fgrnzNcvXrl` sebz `uggcf://fgrnzpbzzhavgl.pbz/qri/ncvxrl` >> Cyhtva haybnqrq"));
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }

            if (enableUsageCost)
            {
                if (ServerRewards != null && useServerRewards) activeServerRewards = true;
                if (Economics != null && useEconomics) activeEconomics = true;
                if (activeServerRewards && activeEconomics) activeEconomics = false;
                if (activeServerRewards || activeEconomics) activePointSystem = true;
            }

            if (allowStackedItems && StacksExtended)
            {
                _stacksExtendedExtrasDisabled = (bool) StacksExtended.CallHook("DisableExtraFeatures");
                if (!_stacksExtendedExtrasDisabled)
                {
                    Unsubscribe(nameof(CanStackItem));
                    Unsubscribe(nameof(OnItemSplit));
                }
                else
                {
                    Subscribe(nameof(CanStackItem));
                    Subscribe(nameof(OnItemSplit));
                }
            }

            foreach (Skinnable skin in Skinnable.All.ToList())
            {
                if (skin.Name == null || skin.Name == string.Empty) continue;
                if (skin.ItemName == null || skin.ItemName == string.Empty) continue;
                if (!NameToItemName.ContainsKey(skin.Name.ToLower()))
                    NameToItemName.Add(skin.Name.ToLower(), skin.ItemName.ToLower());
                if (!ItemNameToName.ContainsKey(skin.ItemName.ToLower()))
                    ItemNameToName.Add(skin.ItemName.ToLower(), skin.Name.ToLower());
            }

            excludedSkins = excludedSkinsPre.ConvertAll(obj => Convert.ToUInt64(obj));
            Puts(_("FxvaObk pbzznaq bireivrj: > fxvaobk.pzqf <"));
            if (useManualAddedSkins)
            {
                List<ulong> s = new List<ulong>();
                foreach (KeyValuePair<string, object> m in manualAddedSkinsPre)
                    s.AddRange((m.Value as List<object>).ConvertAll(obj => Convert.ToUInt64(obj)));

                Puts(_("Dhrelvat Fgrnz sbe znahnyyl nqqrq jbexfubc fxvaf"));               
                CllMnlSkinsWb(s, 0);
            }
            else
            {
                GtItmSkns();
            }

            Initialized = true;
        }

        private void FnllyLdd()
        {
            skinsLoaded = true;
            Puts(_("Cyhtva unf svavfurq vzcbegvat nyy fxvaf"));
        }

        private void GtItmSkns()
        {
            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GtItmSkns;
                return;
            }

            Steamworks.SteamInventory.OnDefinitionsUpdated -= GtItmSkns;

            int countInbuilt = 0;
            foreach (ItemDefinition itemDef in ItemManager.GetItemDefinitions())
            {
                List<ulong> skins = new List<ulong> {0};
                if (useInbuiltSkins)
                    skins.AddRange(ItemSkinDirectory.ForItem(itemDef).Select(skin => Convert.ToUInt64(skin.id)));
                skinsCache.Add(itemDef.shortname, new LinkedList<ulong>(skins));
                if (skins.Count > 1) countInbuilt += skins.Count - 1;
            }

            if (showLoadedSkinCounts && useInbuiltSkins) Puts(_("Ybnqrq {0} vaohvyg fxvaf"), countInbuilt);
            if (useManualAddedSkins)
            {
                int countManual = 0;
                foreach (KeyValuePair<string, List<ulong>> manualskins in manualAddedSkins)
                {
                    string shortname = manualskins.Key;
                    if (!ItemNameToName.ContainsKey(shortname)) continue;
                    string itemname = ItemNameToName[shortname];
                    List<ulong> fileids = manualskins.Value;
                    foreach (ulong fileid in fileids)
                    {
                        if (!skinsCache.ContainsKey(shortname))
                        {
                            skinsCache.Add(shortname, new LinkedList<ulong>());
                            skinsCache[shortname].AddFirst(0);
                        }

                        if (!skinsCache[shortname].Contains(fileid))
                        {
                            skinsCache[shortname].AddAfter(skinsCache[shortname].First, fileid);
                            countManual++;
                        }
                    }
                }

                if (showLoadedSkinCounts && countManual > 0) Puts(_("Ybnqrq {0} znahny nqqrq fxvaf"), countManual);
            }

            if (useApprovedSkins)
            {
                ChckApprvdSkns();
                return;
            }

            FnllyLdd();
        }

        private string BldDtlsSt(List<ulong> list, int pg)
        {
            int st = pg * 100;
            int ed = st + 100 > list.Count ? list.Count : st + 100;

            string details = string.Format(_("?xrl={0}&vgrzpbhag={1}"), steamApiKey, ed - st);

            for (int i = st; i < ed; i++)
                details += string.Format(_("&choyvfurqsvyrvqf[{0}]={1}"), i - st, list[i]);

            return details;
        }

        private void CllMnlSkinsWb(List<ulong> i, int pg)
        {
            int ttlPgs = Mathf.CeilToInt((float)i.Count / 100f) - 1;

            string b = BldDtlsSt(i, pg);

            try
            {
                webrequest.Enqueue(u1, b, (cd, res) => ServerMgr.Instance.StartCoroutine(PrfMnlSkinsWb(cd, res, i, pg, ttlPgs)), this, RequestMethod.POST);
            }
            catch
            {
                GtItmSkns();
            }
        }

        private IEnumerator PrfMnlSkinsWb(int cd, string res, List<ulong> i, int pg, int ttlPgs)
        {
            if (res != null && cd == 200)
            {
                GtPblshdFlDtls pfd = JsonConvert.DeserializeObject<GtPblshdFlDtls>(res);
                if (pfd != null && pfd.response != null && pfd.response.publishedfiledetails?.Count > 0)
                {
                    Puts(string.Format(_("Cebprffvat jbexfubc erfcbafr. Cntr: {0} / {1}"), pg + 1, ttlPgs + 1));
                    foreach (GtPblshdFlDtls.Response.Publishedfiledetail det in pfd.response.publishedfiledetails)
                    {
                        if (det.tags != null && det.tags.Count > 2)
                        {
                            foreach (GtPblshdFlDtls.Tag tag in det.tags)
                            {
                                string t = tag.tag.ToLower();
                                string sn = string.Empty;
                                if (NameToItemName.ContainsKey(t)) sn = NameToItemName[t];
                                else continue;
                                skinWorkshopNames[det.publishedfileid] = det.title;

                                if (!manualAddedSkins.ContainsKey(sn))
                                    manualAddedSkins.Add(sn, new List<ulong>());

                                if (!manualAddedSkins[sn].Contains(det.publishedfileid))
                                    manualAddedSkins[sn].Add(det.publishedfileid);
                            }
                        }
                    }

                    yield return CoroutineEx.waitForEndOfFrame;
                    yield return CoroutineEx.waitForEndOfFrame;

                    if (pg < ttlPgs)
                    {
                        CllMnlSkinsWb(i, pg + 1);
                        yield break;
                    }
                }

            }
            if (pg < ttlPgs)
            {
                CllMnlSkinsWb(i, pg + 1);
                yield break;
            }
            else GtItmSkns();
        }

        private void ChckApprvdSkns()
        {           
            int count = 0;
            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                if (string.IsNullOrEmpty(shortname) || item.Id < 100)
                    continue;

                ulong wsid;
                if (!ulong.TryParse(item.GetProperty("workshopid"), out wsid))
                    continue;
                
                skinWorkshopNames[wsid] = item.Name;
                
                if (!approvedSkinsCount.ContainsKey(shortname))
                    approvedSkinsCount[shortname] = 0;

                if (approvedSkinsLimit > 0 && approvedSkinsCount[shortname] >= approvedSkinsLimit)
                {
                    if (!skinsCacheLimited.ContainsKey(shortname))
                        skinsCacheLimited[shortname] = new LinkedList<ulong>();
                    skinsCacheLimited[shortname].AddLast(wsid);
                }

                if (skinsCacheLimited.ContainsKey(shortname) && skinsCacheLimited[shortname].Contains(wsid))
                    continue;

                if (!skinsCache.ContainsKey(shortname))
                    skinsCache[shortname] = new LinkedList<ulong>();

                if (!skinsCache[shortname].Contains(wsid) && skinsCache[shortname].Count < maxItemsShown)
                {
                    skinsCache[shortname].AddLast(wsid);
                    approvedSkinsCount[shortname]++;
                    count++;
                }
            }

            if (showLoadedSkinCounts && count > 0)
                Puts(_("Vzcbegrq {0} nccebirq fxvaf sbe '{1}' glcrf"), count, skinsCache.Where(c => c.Value.Count > 1).ToList().Count);
            FnllyLdd();
        }
        //void ChckApprvdSknsWb(int cd, string res)
        //{
        //    if (res == null || cd != 200)
        //    {
        //        FnllyLdd();
        //        return;
        //    }
        //    var schm = JsonConvert.DeserializeObject<Rust.Workshop.ItemSchema>(res);
        //    if (schm == null || !(schm is Rust.Workshop.ItemSchema) || schm.items.Length == 0)
        //    {
        //        FnllyLdd();
        //        return;
        //    }
        //    int count = 0;
        //    foreach (var item in schm.items)
        //    {
        //        if (string.IsNullOrEmpty(item.itemshortname) || string.IsNullOrEmpty(item.workshopid) || string.IsNullOrEmpty(item.workshopdownload))
        //            continue;
        //        ulong wsid = Convert.ToUInt64(item.workshopid);
        //        skinWorkshopNames[wsid] = item.name;
        //        string shortname = item.itemshortname;
        //        if (!approvedSkinsCount.ContainsKey(shortname))
        //            approvedSkinsCount[shortname] = 0;
        //        if (approvedSkinsLimit > 0 && approvedSkinsCount[shortname] >= approvedSkinsLimit)
        //        {
        //            if (!skinsCacheLimited.ContainsKey(shortname))
        //                skinsCacheLimited[shortname] = new LinkedList<ulong>();
        //            skinsCacheLimited[shortname].AddLast(wsid);
        //        }
        //        if (skinsCacheLimited.ContainsKey(shortname) && skinsCacheLimited[shortname].Contains(wsid))
        //            continue;
        //        if (!skinsCache.ContainsKey(shortname))
        //            skinsCache[shortname] = new LinkedList<ulong>();
        //        if (!skinsCache[shortname].Contains(wsid) && skinsCache[shortname].Count < maxItemsShown)
        //        {
        //            skinsCache[shortname].AddLast(wsid);
        //            approvedSkinsCount[shortname]++;
        //            count++;
        //        }
        //    }
        //    if (showLoadedSkinCounts && count > 0)
        //        Puts(_("Vzcbegrq {0} nccebirq fxvaf sbe '{1}' glcrf"), count, skinsCache.Where(c => c.Value.Count > 1).ToList().Count);
        //    FnllyLdd();
        //}

        [ConsoleCommand("skinbox.cmds")]
        private void cmdListCmds(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("\n> SkinBox command overview <");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Command");
            textTable.AddColumn("Description");
            textTable.AddRow(new string[]
                {"skinbox.addskin", "Does add one or multiple skin-id\'s to the manual skin list"});
            textTable.AddRow(new string[]
                {"skinbox.removeskin", "Does remove one or multiple skin-id\'s from the manual skin list"});
            textTable.AddRow(new string[]
                {"skinbox.addexcluded", "Does add one or multiple skin-id\'s to the exclusion list (for players)"});
            textTable.AddRow(new string[]
                {"skinbox.removeexcluded", "Does remove one or multiple skin-id\'s from the exclusion list"});
            textTable.AddRow(new string[]
                {"skinbox.addcollection", "Adds a whole skin-collection to the manual skins list"});
            textTable.AddRow(new string[]
                {"skinbox.removecollection", "Removes a whole collection from the manual skin list"});
            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }

        [ConsoleCommand("skinbox.addskin")]
        private void consoleAddSkin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in one or more Workshop FileId's");
                return;
            }

            List<ulong> fileIds = new List<ulong>();
            for (int i = 0; i < arg.Args.Length; i++)
            {
                ulong fileId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out fileId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as of not a number");
                    continue;
                }
                else
                {
                    if (arg.Args[i].Length < 9 || arg.Args[i].Length > 10)
                    {
                        SendReply(arg, $"Ignored '{arg.Args[i]}' as of not 9/10-Digits");
                        continue;
                    }

                    fileIds.Add(fileId);
                }
            }

            CallSkinsImportWeb(fileIds, arg);
        }

        [ConsoleCommand("skinbox.removeskin")]
        private void consoleRemoveSkin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in one or more Workshop FileId's");
                return;
            }

            List<ulong> fileIds = new List<ulong>();
            for (int i = 0; i < arg.Args.Length; i++)
            {
                ulong fileId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out fileId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as of not a number");
                    continue;
                }
                else
                {
                    if (arg.Args[i].Length < 9 || arg.Args[i].Length > 10)
                    {
                        SendReply(arg, $"Ignored '{arg.Args[i]}' as of not 9/10-Digits");
                        continue;
                    }

                    fileIds.Add(fileId);
                }
            }

            bool doSave = false;
            int removed = 0;
            foreach (KeyValuePair<string, List<ulong>> addedSkins in manualAddedSkins)
            {
                foreach (ulong fileId in fileIds)
                {
                    if (addedSkins.Value.Contains(fileId))
                    {
                        manualAddedSkins[addedSkins.Key].Remove(fileId);
                        skinsCache[addedSkins.Key].Remove(fileId);
                        removed++;
                        doSave = true;
                    }
                }
            }

            if (doSave)
            {
                string[] keys = manualAddedSkins.Keys.ToArray();
                for (int i = 0; i < keys.Length; i++)
                {
                    manualAddedSkins[keys[i]] = manualAddedSkins[keys[i]].Distinct().ToList();
                }

                Config["SkinsAdded", "SkinList"] = manualAddedSkins;
                Config.Save();
                SendReply(arg, $"Removed {removed} FileId's");
            }
        }

        private void CallSkinsImportWeb(List<ulong> i, ConsoleSystem.Arg arg = null)
        {
            string b = string.Format(_("?xrl={0}&vgrzpbhag={1}"), steamApiKey, i.Count);
            int p = 0;
            foreach (ulong f in i)
            {
                b += string.Format(_("&choyvfurqsvyrvqf[{0}]={1}"), p, f);
                p++;
            }

            try
            {
                webrequest.Enqueue(u1, b, (cd, res) => ProofSkinsImportWeb(cd, res, arg), this, RequestMethod.POST);
            }
            catch
            {
            }
        }

        private void ProofSkinsImportWeb(int cd, string res, ConsoleSystem.Arg arg = null)
        {
            if (res == null || cd != 200)
                return;

            GtPblshdFlDtls pfd = JsonConvert.DeserializeObject<GtPblshdFlDtls>(res);
            if (pfd == null || !(pfd is GtPblshdFlDtls) || pfd.response.result == 0 || pfd.response.resultcount == 0)
                return;

            bool doSave = false;
            foreach (GtPblshdFlDtls.Response.Publishedfiledetail det in pfd.response.publishedfiledetails)
            {
                if (det.tags != null && det.tags.Count > 2)
                {
                    string sn = string.Empty;
                    ulong wsid = det.publishedfileid;

                    foreach (GtPblshdFlDtls.Tag tag in det.tags)
                    {
                        string t = tag.tag.ToLower();
                        if (NameToItemName.ContainsKey(t))
                            sn = NameToItemName[t];
                        else continue;

                        if (manualAddedSkins.ContainsKey(sn))
                        {
                            if (manualAddedSkins[sn].Contains(wsid))
                            {
                                SndRplyCl(arg, $"'{det.title} ({wsid})' was already added");
                                continue;
                            }
                        }

                        if (skinsCache.ContainsKey(sn))
                        {
                            if ((skinsCache[sn] as LinkedList<ulong>).Contains(wsid))
                            {
                                SndRplyCl(arg, $"'{det.title} ({wsid})' belongs already to approved/ranked");
                                continue;
                            }
                        }

                        if (!manualAddedSkins.ContainsKey(sn))
                            manualAddedSkins.Add(sn, new List<ulong>());
                        manualAddedSkins[sn].Add(wsid);

                        if (!skinsCache.ContainsKey(sn))
                        {
                            skinsCache.Add(sn, new LinkedList<ulong>());
                            skinsCache[sn].AddLast(0);
                        }

                        skinsCache[sn].AddAfter(skinsCache[sn].First, wsid);
                        skinWorkshopNames[wsid] = det.title;
                        SndRplyCl(arg, $"'{det.title} ({wsid})' added to the list for '{sn}'");
                        doSave = true;
                    }
                }
            }

            if (doSave)
            {
                string[] keys = manualAddedSkins.Keys.ToArray();
                for (int i = 0; i < keys.Length; i++)                
                    manualAddedSkins[keys[i]] = manualAddedSkins[keys[i]].Distinct().ToList();
                
                Config["SkinsAdded", "SkinList"] = manualAddedSkins;
                Config.Save();
            }
        }

        [ConsoleCommand("skinbox.addexcluded")]
        private void consoleAddExcluded(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in one or more Workshop FileId's");
                return;
            }

            List<ulong> fileIds = new List<ulong>();
            for (int i = 0; i < arg.Args.Length; i++)
            {
                ulong fileId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out fileId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as of not a number");
                    continue;
                }
                else
                {
                    if (arg.Args[i].Length < 9 || arg.Args[i].Length > 10)
                    {
                        SendReply(arg, $"Ignored '{arg.Args[i]}' as of not 9/10-Digits");
                        continue;
                    }

                    fileIds.Add(fileId);
                }
            }

            int countAdded = 0;
            foreach (ulong fileId in fileIds)
                if (!excludedSkins.Contains(fileId))
                {
                    excludedSkins.Add(fileId);
                    countAdded++;
                }

            if (countAdded > 0)
            {
                Config["SkinsExcluded", "SkinList"] = excludedSkins;
                Config.Save();
                SendReply(arg, $"Added {countAdded} skins to exclusion list");
            }
        }

        [ConsoleCommand("skinbox.removeexcluded")]
        private void consoleRemoveExcluded(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in one or more Workshop FileId's");
                return;
            }

            List<ulong> fileIds = new List<ulong>();
            for (int i = 0; i < arg.Args.Length; i++)
            {
                ulong fileId = 0uL;
                if (!ulong.TryParse(arg.Args[i], out fileId))
                {
                    SendReply(arg, $"Ignored '{arg.Args[i]}' as of not a number");
                    continue;
                }
                else
                {
                    if (arg.Args[i].Length < 9 || arg.Args[i].Length > 10)
                    {
                        SendReply(arg, $"Ignored '{arg.Args[i]}' as of not 9/10-Digits");
                        continue;
                    }

                    fileIds.Add(fileId);
                }
            }

            int countRemoved = 0;
            foreach (ulong fileId in fileIds)
                if (excludedSkins.Contains(fileId))
                {
                    excludedSkins.Remove(fileId);
                    countRemoved++;
                }

            if (countRemoved > 0)
            {
                Config["SkinsExcluded", "SkinList"] = excludedSkins;
                Config.Save();
                SndRplyCl(arg, $"Removed {countRemoved} skins from exclusion");
            }
        }

        [ConsoleCommand("skinbox.addcollection")]
        private void consoleAddCollection(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in a valid collection id");
                return;
            }

            ulong collId = 0;
            if (!ulong.TryParse(arg.Args[0], out collId))
            {
                SendReply(arg, $"Collection ID not correct: '{arg.Args[0]}' is not a number");
                return;
            }
            else
            {
                if (arg.Args[0].Length < 9 || arg.Args[0].Length > 10)
                {
                    SendReply(arg, $"Collection ID not correct: '{arg.Args[0]}' has not 9/10-Digits");
                    return;
                }
            }

            string b = string.Format(_("?xrl={0}&pbyyrpgvbapbhag=1&choyvfurqsvyrvqf[0]={1}"), steamApiKey, arg.Args[0]);
            try
            {
                webrequest.Enqueue(u2, b, (cd, res) => PstCllbckAdd(cd, res, arg), this, RequestMethod.POST);
            }
            catch
            {
                SndRplyCl(arg, "Steam webrequest failed!");
            }
        }

        public void PstCllbckAdd(int cd, string res, ConsoleSystem.Arg arg = null)
        {
            if (res == null || cd != 200)
            {
                SndRplyCl(arg, "Steam webrequest failed by wrong response!");
                return;
            }

            GtCllctnDtls col = JsonConvert.DeserializeObject<GtCllctnDtls>(res);
            if (col == null || !(col is GtCllctnDtls))
            {
                SndRplyCl(arg, "No Collection data received!");
                return;
            }

            if (col.response.resultcount == 0 || col.response.collectiondetails == null ||
                col.response.collectiondetails.Count == 0 || col.response.collectiondetails[0].result != 1)
            {
                SndRplyCl(arg, "The Steam collection could not be found!");
                return;
            }

            List<ulong> fileIds = new List<ulong>();
            foreach (GtCllctnDtls.Response.Collectiondetail.Child child in col.response.collectiondetails[0].children)
                try
                {
                    fileIds.Add(Convert.ToUInt64(child.publishedfileid));
                }
                catch
                {
                }

            if (fileIds.Count == 0)
            {
                SndRplyCl(arg, "No skin numbers found. Workshop search cancelled.");
                return;
            }

            CallSkinsImportWeb(fileIds, arg);
        }

        [ConsoleCommand("skinbox.removecollection")]
        private void consoleRemoveCollection(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to type in a valid collection id");
                return;
            }

            ulong collId = 0;
            if (!ulong.TryParse(arg.Args[0], out collId))
            {
                SendReply(arg, $"Collection ID not correct: '{arg.Args[0]}' is not a number");
                return;
            }
            else
            {
                if (arg.Args[0].Length < 9 || arg.Args[0].Length > 10)
                {
                    SendReply(arg, $"Collection ID not correct: '{arg.Args[0]}' has not 9/10-Digits");
                    return;
                }
            }

            string b = string.Format(_("?xrl={0}&pbyyrpgvbapbhag=1&choyvfurqsvyrvqf[0]={1}"), steamApiKey, arg.Args[0]);
            try
            {
                webrequest.Enqueue(u2, b, (cd, res) => PostCallbackRemove(cd, res, arg), this, RequestMethod.POST);
            }
            catch
            {
                SndRplyCl(arg, "Steam webrequest failed!");
            }
        }

        public void PostCallbackRemove(int cd, string res, ConsoleSystem.Arg arg = null)
        {
            if (res == null || cd != 200)
            {
                SndRplyCl(arg, "Steam webrequest failed by wrong response!");
                return;
            }

            GtCllctnDtls col = JsonConvert.DeserializeObject<GtCllctnDtls>(res);
            if (col == null || !(col is GtCllctnDtls))
            {
                SndRplyCl(arg, "No Collection data received!");
                return;
            }

            if (col.response.resultcount == 0 || col.response.collectiondetails == null ||
                col.response.collectiondetails.Count == 0 || col.response.collectiondetails[0].result != 1)
            {
                SndRplyCl(arg, "The Steam collection could not be found!");
                return;
            }

            List<ulong> fileIds = new List<ulong>();
            foreach (GtCllctnDtls.Response.Collectiondetail.Child child in col.response.collectiondetails[0].children)
                try
                {
                    fileIds.Add(Convert.ToUInt64(child.publishedfileid));
                }
                catch
                {
                }

            if (fileIds.Count == 0)
            {
                SndRplyCl(arg, "No skin numbers found. Workshop search cancelled.");
                return;
            }

            int removed = 0;
            foreach (KeyValuePair<string, List<ulong>> addSkins in new Dictionary<string, List<ulong>>(manualAddedSkins)
            )
            foreach (ulong skin in addSkins.Value.ToList())
                if (fileIds.Contains(skin))
                {
                    manualAddedSkins[addSkins.Key].Remove(skin);
                    if (skinsCache.ContainsKey(addSkins.Key)) skinsCache[addSkins.Key].Remove(skin);
                    removed++;
                }

            if (removed > 0)
            {
                SndRplyCl(arg, $"Removed '{removed}' manual skins by collection remove.");

                string[] keys = manualAddedSkins.Keys.ToArray();
                for (int i = 0; i < keys.Length; i++)
                    manualAddedSkins[keys[i]] = manualAddedSkins[keys[i]].Distinct().ToList();

                Config["SkinsAdded", "SkinList"] = manualAddedSkins;
                Config.Save();
            }
            else
            {
                SndRplyCl(arg, $"No manual skins to remove by collection remove.");
            }
        }

        [ConsoleCommand("skinbox.open")]
        private void consoleSkinboxOpen(ConsoleSystem.Arg arg)
        {
            if (arg == null) return;
            if (arg.Connection == null)
            {
                if (arg.Args == null || arg.Args.Length == 0)
                {
                    SendReply(arg, $"'skinbox.open' cmd needs a passed steamid ");
                    return;
                }

                ulong argId = 0uL;
                if (!ulong.TryParse(arg.Args[0], out argId))
                {
                    SendReply(arg, $"'skinbox.open' cmd for '{arg.Args[0]}' failed (no valid number)");
                    return;
                }

                BasePlayer argPlayer = BasePlayer.FindByID(argId);
                if (argPlayer == null)
                {
                    SendReply(arg, $"'skinbox.open' cmd for userID '{argId}' failed (player not found)");
                    return;
                }

                if (!argPlayer.inventory.loot.IsLooting()) OpnSknBx(argPlayer);
            }
            else if (arg.Connection != null && arg.Connection.player != null)
            {
                BasePlayer player = arg.Player();
                if (player.inventory.loot.IsLooting()) return;
                if (!(player.IsAdmin || player.net.connection.authLevel >= accessOverrideAuthLevel) &&
                    !permission.UserHasPermission(player.UserIDString, permissionUse))
                {
                    player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));
                    return;
                }

                if (!ChckOpnBlnc(player)) return;
                if (enableCooldown && !(cooldownOverrideAdmin &&
                                        (player.IsAdmin ||
                                         player.net.connection.authLevel >= cooldownOverrideAuthLevel)))
                {
                    DateTime now = DateTime.UtcNow;
                    DateTime time;
                    string key = player.UserIDString + "-box";
                    if (cooldownTimes.TryGetValue(key, out time))
                        if (time > now.AddSeconds(-cooldownBox))
                        {
                            player.ChatMessage(string.Format(lang.GetMessage("CooldownTime", this, player.UserIDString),
                                (time - now.AddSeconds(-cooldownBox)).Seconds));
                            return;
                        }
                }

                OpnSknBx(player);
            }
        }

        private void cmdSknBx(BasePlayer player, string command, string[] args)
        {
            if (player.inventory.loot.IsLooting()) return;
            if (!(player.IsAdmin || player.net.connection.authLevel >= accessOverrideAuthLevel) &&
                !permission.UserHasPermission(player.UserIDString, permissionUse))
            {
                player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }

            if (!ChckOpnBlnc(player)) return;
            if (enableCooldown && !(cooldownOverrideAdmin &&
                                    (player.IsAdmin || player.net.connection.authLevel >= cooldownOverrideAuthLevel)))
            {
                DateTime now = DateTime.UtcNow;
                DateTime time;
                string key = player.UserIDString + "-box";
                if (cooldownTimes.TryGetValue(key, out time))
                    if (time > now.AddSeconds(-cooldownBox))
                    {
                        player.ChatMessage(string.Format(lang.GetMessage("CooldownTime", this, player.UserIDString),
                            (time - now.AddSeconds(-cooldownBox)).Seconds));
                        return;
                    }
            }

            timer.Once(0.2f, () => { OpnSknBx(player); });
        }

        public bool ChckOpnBlnc(BasePlayer player)
        {
            if (!activePointSystem || costBoxOpen <= 0 || player.IsAdmin && costExcludeAdmins ||
                costExcludePermEnabled && permission.UserHasPermission(player.UserIDString, costExcludePerm))
                return true;
            object getMoney = null;
            if (activeServerRewards) getMoney = (int) (Interface.Oxide.CallHook("CheckPoints", player.userID) ?? 0);
            if (activeEconomics) getMoney = (double) (Interface.Oxide.CallHook("Balance", player.UserIDString) ?? 0.0);
            int playerMoney = 0;
            playerMoney = Convert.ToInt32(getMoney);
            if (playerMoney < costBoxOpen)
            {
                player.ChatMessage(string.Format(lang.GetMessage("NotEnoughBalanceOpen", this, player.UserIDString),
                    costBoxOpen));
                return false;
            }

            if (activeServerRewards) Interface.Oxide.CallHook("TakePoints", player.userID, costBoxOpen);
            if (activeEconomics) Interface.Oxide.CallHook("Withdraw", player.userID, Convert.ToDouble(costBoxOpen));
            return true;
        }

        public bool ChckSknBlnc(BasePlayer player, Item item)
        {
            if (!activePointSystem || player.IsAdmin && costExcludeAdmins || costExcludePermEnabled &&
                permission.UserHasPermission(player.UserIDString, costExcludePerm)) return true;
            object getMoney = null;
            if (activeServerRewards) getMoney = (int) (Interface.Oxide.CallHook("CheckPoints", player.userID) ?? 0);
            if (activeEconomics) getMoney = (double) (Interface.Oxide.CallHook("Balance", player.UserIDString) ?? 0.0);
            int playerMoney = 0;
            playerMoney = Convert.ToInt32(getMoney);
            bool hasBalance = false;
            int getCost = 0;
            switch (item.info.category.ToString())
            {
                case "Weapon":
                case "Tool":
                    if (costWeapon <= 0 || playerMoney > costWeapon) hasBalance = true;
                    getCost = costWeapon;
                    break;
                case "Attire":
                    if (costPlayerwearable <= 0 || playerMoney > costPlayerwearable) hasBalance = true;
                    getCost = costPlayerwearable;
                    break;
                case "Items":
                case "Construction":
                    if (costDeployable <= 0 || playerMoney > costDeployable) hasBalance = true;
                    getCost = costDeployable;
                    break;
                default:
                    hasBalance = true;
                    break;
            }

            if (!hasBalance)
            {
                player.ChatMessage(string.Format(lang.GetMessage("NotEnoughBalanceUse", this, player.UserIDString),
                    getCost, item.info.displayName.translated));
                return false;
            }

            return true;
        }

        public bool WthdrwBlnc(BasePlayer player, Item item)
        {
            if (!activePointSystem || player.IsAdmin && costExcludeAdmins || costExcludePermEnabled &&
                permission.UserHasPermission(player.UserIDString, costExcludePerm)) return true;
            int getCost = 0;
            switch (item.info.category.ToString())
            {
                case "Weapon":
                case "Tool":
                    getCost = costWeapon;
                    break;
                case "Attire":
                    getCost = costPlayerwearable;
                    break;
                case "Items":
                case "Construction":
                    getCost = costDeployable;
                    break;
                default: break;
            }

            bool hadMoney = false;
            if (activeServerRewards && (bool) Interface.Oxide.CallHook("TakePoints", player.userID, getCost))
                hadMoney = true;
            if (activeEconomics && (bool) Interface.Oxide.CallHook("Withdraw", player.userID, Convert.ToDouble(getCost))
            ) hadMoney = true;
            if (!hadMoney)
            {
                player.ChatMessage(string.Format(lang.GetMessage("NotEnoughBalanceTake", this, player.UserIDString),
                    item.info.displayName.translated));
                return false;
            }

            return true;
        }

        internal class SBH : FacepunchBehaviour
        {
            public bool isCreating;
            public bool isBlocked;
            public bool isEmptied;
            public int itemId;
            public int itemAmount;
            public Item currentItem;
            public BasePlayer looter;
            public ItemContainer loot;
            public BaseEntity entityOwner;
            public ulong skinId;
            public int currentPage;
            public int totalPages;
            public int lastPageCount;
            public LinkedList<ulong> itemSkins;
            public int skinsTotal;
            public int perPageTotal;
            public int maxPages;
            public bool refundItem;

            private void Awake()
            {
                isCreating = false;
                isBlocked = false;
                isEmptied = false;
                skinId = 0uL;
                currentPage = 1;
                totalPages = 1;
                lastPageCount = 0;
                skinsTotal = 1;
                perPageTotal = 1;
                itemAmount = 1;
                maxPages = skinBox.maxPagesShown;
                itemSkins = new LinkedList<ulong>();
            }

            public void ShwUi()
            {
                if (totalPages > 1 && maxPages > 1)
                {
                    int p = Math.Min(maxPages, totalPages);
                    skinBox.CrtUi(looter, currentPage, p);
                }
            }

            public void ClsUi()
            {
                skinBox.DstryUi(looter);
            }

            public void PgNxt()
            {
                if (totalPages > 1 && currentPage < maxPages && currentPage < totalPages && !isCreating)
                {
                    currentPage++;
                    FllSknBx(currentPage);
                    ShwUi();
                }
            }

            public void PgPrv()
            {
                if (totalPages > 1 && currentPage > 1 && !isCreating)
                {
                    currentPage--;
                    FllSknBx(currentPage);
                    ShwUi();
                }
            }

            public void StrtNwItm(ItemContainer container, Item item)
            {
                isBlocked = true;
                currentItem = item;
                itemAmount = item.amount;
                itemId = item.info.itemid;
                skinId = item.skin;
                string shortname = currentItem.info.shortname == _("evsyr.ye300")
                    ? _("ye300.vgrz")
                    : currentItem.info.shortname;
                itemSkins = new LinkedList<ulong>(skinBox.skinsCache[shortname] as LinkedList<ulong>);
                itemSkins.Remove(0uL);
                itemSkins.Remove(skinId);
                skinsTotal = itemSkins.Count;
                perPageTotal = skinId == 0uL ? 41 : 40;
                currentPage = 1;
                totalPages = Mathf.CeilToInt(skinsTotal / (float) perPageTotal);
                lastPageCount = totalPages == 1 ? skinsTotal : skinsTotal % perPageTotal;
                loot = container;
                entityOwner = loot.entityOwner;
            }

            public void FllSknBx(int page = 1)
            {
                isCreating = true;
                string origname = currentItem.info.shortname;
                bool hasCondition = currentItem.hasCondition;
                float condition = currentItem.condition;
                float maxCondition = currentItem.maxCondition;
                bool isWeapon = currentItem.GetHeldEntity() is BaseProjectile;
                bool hasMods = false;
                int contents = 0;
                int capacity = 0;
                ItemDefinition ammoType = null;
                Dictionary<int, float> itemMods = new Dictionary<int, float>();
                if (isWeapon)
                {
                    contents = (currentItem.GetHeldEntity() as BaseProjectile).primaryMagazine.contents;
                    capacity = (currentItem.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity;
                    ammoType = (currentItem.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType;
                    if (currentItem.contents != null && currentItem.contents.itemList.Count > 0)
                    {
                        hasMods = true;
                        foreach (Item mod in currentItem.contents.itemList)
                            itemMods.Add(mod.info.itemid, mod.condition);
                    }
                }

                isEmptied = false;
                if (currentItem.contents != null && currentItem.contents.itemList.Count > 0)
                {
                    Item[] array = currentItem.contents.itemList.ToArray();
                    for (int i = 0; i < array.Length; i++)
                    {
                        if (array[i].info.category == ItemCategory.Weapon) continue;
                        Item item = array[i];
                        looter.inventory.GiveItem(item, null);
                    }
                }

                skinBox.RmvItm(loot, currentItem);
                skinBox.ClrCntnr(loot);
                int startIndex = page * perPageTotal - perPageTotal;
                int rangeIndex = page == totalPages ? lastPageCount : perPageTotal;
                List<ulong> skins = new List<ulong> {0uL};
                if (skinId != 0uL) skins.Add(skinId);
                if (maxPages > 1 && totalPages > 1) skins.AddRange(itemSkins.ToList().GetRange(startIndex, rangeIndex));
                else skins.AddRange(itemSkins.ToList());
                loot.capacity = skins.Count();
                ItemDefinition itemDef = ItemManager.FindItemDefinition(origname);
                if (skins.Count() > 42) loot.capacity = 42;
                else loot.capacity = skins.Count;
                foreach (ulong skin in skins)
                {
                    if (loot.IsFull()) break;
                    if (skinBox.excludedSkins.Contains(skin) && looter.net.connection.authLevel < skinBox.exludedSkinsAuthLevel)
                        continue;

                    Item newItem = ItemManager.Create(itemDef, 1, skin);
                    if (skinBox.skinWorkshopNames.ContainsKey(skin)) newItem.name = skinBox.skinWorkshopNames[skin];
                    if (hasCondition)
                    {
                        newItem.condition = condition;
                        newItem.maxCondition = maxCondition;
                    }

                    if (isWeapon)
                    {
                        BaseProjectile gun = newItem.GetHeldEntity() as BaseProjectile;
                        gun.primaryMagazine.contents = contents;
                        gun.primaryMagazine.capacity = capacity;
                        gun.primaryMagazine.ammoType = ammoType;
                        if (hasMods)
                        {
                            foreach (KeyValuePair<int, float> mod in itemMods)
                            {
                                Item newMod = ItemManager.CreateByItemID((int) mod.Key, 1);
                                newMod.condition = Convert.ToSingle(mod.Value);
                                newMod.MoveToContainer(newItem.contents, -1, false);
                            }

                            newItem.contents.SetFlag(ItemContainer.Flag.IsLocked, true);
                            newItem.contents.SetFlag(ItemContainer.Flag.NoItemInput, true);
                            newItem.contents.MarkDirty();
                        }
                    }

                    newItem.MarkDirty();
                    skinBox.InsrtItm(loot, newItem);
                }

                isCreating = false;
                loot.MarkDirty();
            }

            public void PlayerStoppedLooting(BasePlayer player)
            {
                if (!isEmptied && currentItem != null)
                {
                    isEmptied = true;
                    if (refundItem) player.GiveItem(currentItem);
                }

                if (!GetComponent<BaseEntity>().IsDestroyed)
                    GetComponent<BaseEntity>().Kill(BaseNetworkable.DestroyMode.None);
                if (skinBox.enableCooldown) skinBox.cooldownTimes[player.UserIDString + "-box"] = DateTime.UtcNow;
            }

            private void OnDestroy()
            {
                skinBox.DstryUi(looter);
                skinBox.activeSkinBoxes.Remove(looter.userID);
                if (!isEmptied && currentItem != null)
                {
                    isEmptied = true;
                    looter.GiveItem(currentItem);
                }

                looter.EndLooting();
            }
        }

        private void OpnSknBx(BasePlayer player, bool refundItem = true)
        {
            BaseEntity skinBox = GameManager.server.CreateEntity(StringPool.Get(4080262419),
                player.transform.position - new Vector3(0, 250f + UnityEngine.Random.Range(-25f, 25f), 0));
            (skinBox as BaseNetworkable).limitNetworking = true;
            UnityEngine.Object.Destroy(skinBox.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.Destroy(skinBox.GetComponent<GroundWatch>());
            skinBox.Spawn();
            SBH lootHandler = skinBox.gameObject.AddComponent<SBH>();
            lootHandler.looter = player;
            lootHandler.refundItem = refundItem;
            StorageContainer container = skinBox.GetComponent<StorageContainer>();
            if (!allowStackedItems)
            {
                container.maxStackSize = 1;
                container.inventory.maxStackSize = 1;
            }

            container.inventory.capacity = 1;
            container.SetFlag(BaseEntity.Flags.Open, true, false);
            if (QuickSort && hideQuickSort) StrtLtngEntty(player.inventory.loot, container);
            else player.inventory.loot.StartLootingEntity(container, false);
            player.inventory.loot.AddContainer(container.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, _("ECP_BcraYbbgCnary"), _("trarevpynetr"));
            container.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            activeSkinBoxes.Add(player.userID, lootHandler);
        }

        public void StrtLtngEntty(PlayerLoot loot, BaseEntity targetEntity)
        {
            loot.Clear();
            if (!targetEntity) return;
            loot.PositionChecks = false;
            loot.entitySource = targetEntity;
            loot.itemSource = null;
            loot.MarkDirty();
        }

        public void ClrCntnr(ItemContainer container)
        {
            while (container.itemList.Count > 0)
            {
                Item removeItem = container.itemList[0];
                RmvItm(container, removeItem);
                removeItem.Remove(0f);
            }
        }

        private object CanAcceptItem(ItemContainer container, Item item)
        {
            if (container.entityOwner == null) return null;
            SBH lootHandler;
            if ((lootHandler = container.entityOwner.GetComponent<SBH>()) == null) return null;
            string shortname = item.info.shortname == _("evsyr.ye300") ? _("ye300.vgrz") : item.info.shortname;
            if (lootHandler.isCreating || lootHandler.isBlocked ||
                enableCustomPerms && !ChckItmPrms(lootHandler.looter, item) || item.isBroken ||
                !skinsCache.ContainsKey(shortname) || (skinsCache[shortname] as LinkedList<ulong>).Count <= 1 ||
                !ChckSknBlnc(lootHandler.looter, item)) return ItemContainer.CanAcceptResult.CannotAccept;
            return null;
        }

        public bool ChckItmPrms(BasePlayer player, Item item)
        {
            string category = item.info.category.ToString();
            switch (category)
            {
                case "Weapon":
                    if (permission.UserHasPermission(player.UserIDString, permCustomWeapon)) return true;
                    break;
                case "Tool":
                    if (permission.UserHasPermission(player.UserIDString, permCustomWeapon)) return true;
                    break;
                case "Attire":
                    if (permission.UserHasPermission(player.UserIDString, permCustomPlayerwearable)) return true;
                    break;
                case "Items":
                    if (permission.UserHasPermission(player.UserIDString, permCustomDeployable)) return true;
                    break;
                case "Construction":
                    if (permission.UserHasPermission(player.UserIDString, permCustomDeployable)) return true;
                    break;
                default: return true;
            }

            return false;
        }

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container == null || item == null || container.entityOwner == null) return;
            SBH lootHandler = container.entityOwner.GetComponent<SBH>();
            if (lootHandler == null || lootHandler.isBlocked) return;
            lootHandler.StrtNwItm(container, item);
            lootHandler.FllSknBx();
            if (maxPagesShown > 1) lootHandler.ShwUi();
        }

        public bool InsrtItm(ItemContainer container, Item item, bool mark = false)
        {
            if (container.itemList.Contains(item)) return false;
            if (container.IsFull()) return false;
            container.itemList.Add(item);
            item.parent = container;
            if (!container.FindPosition(item)) return false;
            if (mark) container.MarkDirty();
            if (container.onItemAddedRemoved != null) container.onItemAddedRemoved(item, true);
            return true;
        }

        public bool RmvItm(ItemContainer container, Item item, bool mark = false)
        {
            if (!container.itemList.Contains(item)) return false;
            if (container.onPreItemRemove != null) container.onPreItemRemove(item);
            container.itemList.Remove(item);
            item.parent = null;
            if (mark) container.MarkDirty();
            if (container.onItemAddedRemoved != null) container.onItemAddedRemoved(item, false);
            return true;
        }

        private void OnItemRemovedFromContainer(ItemContainer container, Item item)
        {
            if (container == null || item == null || container.entityOwner == null) return;
            SBH lootHandler = container.entityOwner.GetComponent<SBH>();
            if (lootHandler == null || !lootHandler.isBlocked) return;
            if (item.GetHeldEntity() is BaseProjectile && item.contents != null)
            {
                item.contents.SetFlag(ItemContainer.Flag.IsLocked, false);
                item.contents.SetFlag(ItemContainer.Flag.NoItemInput, false);
            }

            if (lootHandler.itemAmount > 1)
            {
                item.amount = lootHandler.itemAmount;
                item.MarkDirty();
                lootHandler.itemAmount = 1;
            }

            ClrCntnr(container);
            if (lootHandler.currentItem != null)
            {
                lootHandler.currentItem.Remove(0f);
                lootHandler.currentItem = null;
            }

            container.MarkDirty();
            lootHandler.isEmptied = true;
            lootHandler.ClsUi();
            container.capacity = 1;
            if (item.skin == 0uL)
            {
                lootHandler.skinId = 0uL;
                lootHandler.isBlocked = false;
                return;
            }

            if (!WthdrwBlnc(lootHandler.looter, item))
            {
                item.skin = lootHandler.skinId;
                if (item.GetHeldEntity()) item.GetHeldEntity().skinID = lootHandler.skinId;
                item.MarkDirty();
            }

            if (enableCooldown && activateAfterSkinTaken &&
                !(cooldownOverrideAdmin && (lootHandler.looter.IsAdmin ||
                                            lootHandler.looter.net.connection.authLevel >= cooldownOverrideAuthLevel)
                    ) && item.skin != lootHandler.skinId)
            {
                lootHandler.looter.EndLooting();
                skinBox.cooldownTimes[lootHandler.looter.UserIDString + "-box"] = DateTime.UtcNow;
            }

            lootHandler.skinId = 0uL;
            lootHandler.isBlocked = false;
        }

        public void UnsbscrbSplt()
        {
            Unsubscribe(nameof(OnItemSplit));
            Unsubscribe(nameof(CanStackItem));
        }

        public void SbscrbSplt()
        {
            Subscribe(nameof(OnItemSplit));
            Subscribe(nameof(CanStackItem));
        }

        public void SndRplyCl(ConsoleSystem.Arg arg, string format)
        {
            if (arg != null && arg.Connection != null) SendReply(arg, format);
            Puts(format);
        }

        private static string _(string i)
        {
            return !string.IsNullOrEmpty(i)
                ? new string(i.Select(x =>
                    x >= 'a' && x <= 'z' ? (char) ((x - 'a' + 13) % 26 + 'a') :
                    x >= 'A' && x <= 'Z' ? (char) ((x - 'A' + 13) % 26 + 'A') : x).ToArray())
                : i;
        }

        public void DstryUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "SkinBoxUI");
        }

        public void CrtUi(BasePlayer player, int page = 1, int total = 1)
        {
            string panelName = "SkinBoxUI";
            CuiHelper.DestroyUi(player, panelName);
            string contentColor = "0.7 0.7 0.7 1.0";
            string buttonColor = "0.75 0.75 0.75 0.1";
            string buttonTextColor = "0.77 0.68 0.68 1";
            CuiElementContainer result = new CuiElementContainer();
            string rootPanelName =
                result.Add(
                    new CuiPanel
                    {
                        Image = new CuiImageComponent {Color = "0 0 0 0"},
                        RectTransform = {AnchorMin = "0.9505 0.15", AnchorMax = "0.99 0.6"}
                    }, "Hud.Menu", panelName);
            result.Add(
                new CuiPanel
                {
                    Image = new CuiImageComponent {Color = "0.65 0.65 0.65 0.06"},
                    RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"}
                }, rootPanelName);
            result.Add(
                new CuiButton
                {
                    RectTransform = {AnchorMin = "0.025 0.7", AnchorMax = "0.975 1.0"},
                    Button = {Command = _("fxvaobk.cntrceri"), Color = buttonColor},
                    Text = {Align = TextAnchor.MiddleCenter, Text = "◀", Color = buttonTextColor, FontSize = 50}
                }, rootPanelName);
            result.Add(
                new CuiLabel
                {
                    RectTransform = {AnchorMin = "0.025 0.3", AnchorMax = "0.975 0.7"},
                    Text =
                    {
                        Align = TextAnchor.MiddleCenter, Text = $"{page}\nof\n{total}", Color = contentColor,
                        FontSize = 20
                    }
                }, rootPanelName);
            result.Add(
                new CuiButton
                {
                    RectTransform = {AnchorMin = "0.025 0", AnchorMax = "0.975 0.3"},
                    Button = {Command = _("fxvaobk.cntrarkg"), Color = buttonColor},
                    Text = {Align = TextAnchor.MiddleCenter, Text = "▶", Color = buttonTextColor, FontSize = 50}
                }, rootPanelName);
            CuiHelper.AddUi(player, result);
        }

        [ConsoleCommand("skinbox.pagenext")]
        private void cmdPageNext(ConsoleSystem.Arg arg)
        {
            if (maxPagesShown <= 1 || arg == null || arg.Connection == null) return;
            BasePlayer player = arg.Connection?.player as BasePlayer;
            if (player == null) return;
            if (activeSkinBoxes.ContainsKey(player.userID)) activeSkinBoxes[player.userID].PgNxt();
        }

        [ConsoleCommand("skinbox.pageprev")]
        private void cmdPagePrev(ConsoleSystem.Arg arg)
        {
            if (maxPagesShown <= 1 || arg == null || arg.Connection == null) return;
            BasePlayer player = arg.Connection?.player as BasePlayer;
            if (player == null) return;
            if (activeSkinBoxes.ContainsKey(player.userID)) activeSkinBoxes[player.userID].PgPrv();
        }

        private bool IsSkinBoxPlayer(ulong playerId) => activeSkinBoxes.ContainsKey(playerId);

        private void OnPluginUnloaded(Plugin name)
        {
            if (Initialized && name.Name == _("FgnpxfRkgraqrq")) ChckSbscrptns(true);
        }

        private void OnPluginLoaded(Plugin name)
        {
            if (Initialized && name.Name == _("FgnpxfRkgraqrq")) ChckSbscrptns(false);
        }

        public void ChckSbscrptns(bool wasUnload)
        {
            if (!allowStackedItems) return;
            if (wasUnload)
            {
                _stacksExtendedExtrasDisabled = false;
                Subscribe(nameof(CanStackItem));
                Subscribe(nameof(OnItemSplit));
            }
            else
            {
                _stacksExtendedExtrasDisabled = (bool) StacksExtended.CallHook("DisableExtraFeatures");
                if (!_stacksExtendedExtrasDisabled)
                {
                    Unsubscribe(nameof(CanStackItem));
                    Unsubscribe(nameof(OnItemSplit));
                }
                else
                {
                    Subscribe(nameof(CanStackItem));
                    Subscribe(nameof(OnItemSplit));
                }
            }
        }

        private object OnItemSplit(Item thisI, int split_Amount)
        {
            if (thisI.skin == 0uL) return null;
            Item item = null;
            item = ItemManager.CreateByItemID(thisI.info.itemid, 1, thisI.skin);
            if (item != null)
            {
                thisI.amount -= split_Amount;
                thisI.MarkDirty();
                item.amount = split_Amount;
                item.OnVirginSpawn();
                if (thisI.IsBlueprint()) item.blueprintTarget = thisI.blueprintTarget;
                if (thisI.hasCondition) item.condition = thisI.condition;
                item.MarkDirty();
                return item;
            }

            return null;
        }

        private object CanStackItem(Item thisI, Item item)
        {
            if (thisI.skin == item.skin) return null;
            if (thisI.skin != item.skin) return false;
            if (thisI.skin == item.skin)
            {
                if (thisI.hasCondition && item.hasCondition)
                    if (item.condition != thisI.condition)
                        return false;
                return true;
            }

            return null;
        }

        private string u1 = _("uggcf://ncv.fgrnzcbjrerq.pbz/VFgrnzErzbgrFgbentr/TrgChoyvfurqSvyrQrgnvyf/i1/");
        private string u2 = _("uggcf://ncv.fgrnzcbjrerq.pbz/VFgrnzErzbgrFgbentr/TrgPbyyrpgvbaQrgnvyf/i1/");
        //private string u3 = _("uggc://f3.nznmbanjf.pbz/f3.cynlehfg.pbz/vpbaf/vairagbel/ehfg/fpurzn.wfba");

        public class GtPblshdFlDtls
        {
            [JsonProperty("response")] public Response response;

            public class Tag
            {
                [JsonProperty("tag")] public string tag;
            }

            public class Response
            {
                [JsonProperty("result")] public int result;
                [JsonProperty("resultcount")] public int resultcount;
                [JsonProperty("publishedfiledetails")] public List<Publishedfiledetail> publishedfiledetails;

                public class Publishedfiledetail
                {
                    [JsonProperty("publishedfileid")] public ulong publishedfileid;
                    [JsonProperty("result")] public int result;
                    [JsonProperty("creator")] public string creator;
                    [JsonProperty("creator_app_id")] public int creator_app_id;
                    [JsonProperty("consumer_app_id")] public int consumer_app_id;
                    [JsonProperty("filename")] public string filename;
                    [JsonProperty("file_size")] public int file_size;
                    [JsonProperty("preview_url")] public string preview_url;
                    [JsonProperty("hcontent_preview")] public string hcontent_preview;
                    [JsonProperty("title")] public string title;
                    [JsonProperty("description")] public string description;
                    [JsonProperty("time_created")] public int time_created;
                    [JsonProperty("time_updated")] public int time_updated;
                    [JsonProperty("visibility")] public int visibility;
                    [JsonProperty("banned")] public int banned;
                    [JsonProperty("ban_reason")] public string ban_reason;
                    [JsonProperty("subscriptions")] public int subscriptions;
                    [JsonProperty("favorited")] public int favorited;

                    [JsonProperty("lifetime_subscriptions")]
                    public int lifetime_subscriptions;

                    [JsonProperty("lifetime_favorited")] public int lifetime_favorited;
                    [JsonProperty("views")] public int views;
                    [JsonProperty("tags")] public List<Tag> tags;
                }
            }
        }

        public class GtCllctnDtls
        {
            [JsonProperty("response")] public Response response;

            public class Response
            {
                [JsonProperty("result")] public int result;
                [JsonProperty("resultcount")] public int resultcount;
                [JsonProperty("collectiondetails")] public List<Collectiondetail> collectiondetails;

                public class Collectiondetail
                {
                    [JsonProperty("publishedfileid")] public string publishedfileid;
                    [JsonProperty("result")] public int result;
                    [JsonProperty("children")] public List<Child> children;

                    public class Child
                    {
                        [JsonProperty("publishedfileid")] public string publishedfileid;
                        [JsonProperty("sortorder")] public int sortorder;
                        [JsonProperty("filetype")] public int filetype;
                    }
                }
            }
        }
    }
}

// --- End of file: SkinBox (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GradeDestroy.cs ---
// --- Original Local Path: GradeDestroy.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("GradeDestroy", "Hougan", "1.2.0")]
    public class GradeDestroy : RustPlugin
    {
        #region Classes

        private class CurrentGrade
        {
            [JsonProperty("Текущий индекс улучшения")]
            public int Grade = 0;
            [JsonProperty("Время до де-активации")]
            public int DeActivateTime = 40;

            [JsonProperty("Таймер обновления")]
            public Timer DeTimer = null;

            public void UpdateTime(BasePlayer player, int time)
            {
                DeActivateTime = time;
                DeTimer?.Destroy();
                instance.UpdateTimer(player);
            }
            
            public void UpGrade(BasePlayer player, int time)
            {
                if (Grade >= 0 && Grade < 4)
                {
                    UpdateTime(player, time);
                    Activate(player, Grade + 1, CONF_RemoveDefaultTime);
                }
                else if (Grade >= 4)
                {
                    DeActivate(player);
                }
                else
                {
                    player.ChatMessage($"Неизвестная ошибка. Сообщите адмнистрации: <color=#81B67A>{Grade}</color>");
                    return;
                }
            }

            public void Activate(BasePlayer player, int grade, int time)
            {
                if (grade != Grade && instance.Initializated())
                {
                    player.ChatMessage($"Вы успешно активировали режим: <color=#81B67A>{CONF_GradeNames[grade]}</color>");
                }
                
                this.Grade = grade;
                this.DeActivateTime = time;
                instance.UpdateTimer(player);
            }

            public void DeActivate(BasePlayer player)
            {
                Grade = 0;
                Activate(player, 0, 0);
            } 
            
        }

        #endregion

        #region Variables

        #region Config

        #region Remove

        private static string CONF_RemovePermission = "GradeDestroy.Remove";
        private static bool CONF_RemoveActivated = true;
        private static int CONF_RemoveTime = 14400;
        private static int CONF_RemoveDefaultTime = 60;
        private static int CONF_RemoveHitTime = 5;
        private static bool CONF_RemoveGameFriends = false;
        private static bool CONF_RemoveFriends = false;
        private static bool CONF_RemoveClans = false;
        private static bool CONF_RemoveByCup = false;
        private static bool CONF_RemoveOneHit = false;

        private static bool CONF_BlockRemoveOnRaid = true;

        #endregion

        #region Upgrade

        private static bool CONF_UpActivated = true;
        private static string CONF_UpPermission = "GradeDestroy.Up";
        private static bool CONF_BlockUpgradeOnRaid = true;
        private static bool CONF_EnableOnHit = false;

        #endregion

        #region Other

        private static List<string> CONF_GradeNames = new List<string>
        {
            "отключено",
            "улучшение в дерево",
            "улучшение в камень",
            "улучшение в метал",
            "улучшение в МВК",
            "удаление построек"
        };

        #endregion
        
        #endregion

        #region System
        
        [PluginReference] private Plugin Friends, Clans, NoEscape;
        private string Layer = "UI.Remove";
        private static GradeDestroy instance;

        // Список объектов с кулдаунами до удаления
        Dictionary<uint, double> removeTimers = new Dictionary<uint, double>();
        // Информация об игроках
        private Dictionary<ulong, CurrentGrade> playerGrades = new Dictionary<ulong,CurrentGrade>();

        #endregion


        #endregion

        #region Initialization

        private void OnServerInitialized()
        {
            instance = this;
            LoadDefaultConfig();

            permission.RegisterPermission(CONF_RemovePermission, this);
            permission.RegisterPermission(CONF_UpPermission, this);

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("GradeDestroy/Objects") && Initializated())
                removeTimers =
                    Interface.Oxide.DataFileSystem.ReadObject<Dictionary<uint, double>>("GradeDestroy/Objects");

            BasePlayer.activePlayerList.ForEach(OnPlayerInit);

            List<uint> removeList = new List<uint>();
            foreach (var check in removeTimers)
            {
                if (check.Value < LogTime())
                    removeList.Add(check.Key);
            }

            PrintError($"Удалено {removeList.Count} объектов");
            foreach (var check in removeList)
                removeTimers.Remove(check);

            timer.Every(300, SaveData);
        }

        private void Unload()
        {
            SaveData();
            BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, Layer));
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("GradeDestroy/Objects", removeTimers);
        }
        
        protected override void LoadDefaultConfig()
        {
            GetConfig("Удаление построек", "Разрешать игрокам удалять постройки", ref CONF_RemoveActivated);
            GetConfig("Удаление построек", "Разрешение для удаления построек", ref CONF_RemovePermission);
            GetConfig("Удаление построек", "Лимит времени для удаления (0 - бесконечно)", ref CONF_RemoveTime);
            GetConfig("Удаление построек", "Разрешить удалять постройки друзей", ref CONF_RemoveFriends);
            GetConfig("Удаление построек", "Разрешить удалять постройка со-кланов", ref CONF_RemoveClans);
            GetConfig("Удаление построек", "Разрешить удалять при авторизации в шкафу", ref CONF_RemoveByCup);
            GetConfig("Удаление построек", "Запрещать удалять во время рейда", ref CONF_BlockRemoveOnRaid);
            GetConfig("Удаление построек", "Моментальный ремув объекта", ref CONF_RemoveOneHit);
            
            GetConfig("Улучшение построек", "Разрешать игрокам улучшать постройки", ref CONF_UpActivated);
            GetConfig("Улучшение построек", "Разрешение для улучшения построек", ref CONF_UpPermission);
            GetConfig("Улучшение построек", "Время автоматического включения улучшения", ref CONF_RemoveHitTime);
            GetConfig("Улучшение построек", "Включать режим автоматического улучшения при ручном улучшения", ref CONF_EnableOnHit);
            GetConfig("Улучшение построек", "Запрещать улучшать во время рейда", ref CONF_BlockUpgradeOnRaid);
            

            GetConfig("Остальное", "Отображение имён улучшения", ref CONF_GradeNames);
            
            Config.Save();
        }

        #endregion

        #region Functions

        private string TryRemove(BasePlayer player, BaseEntity entity)
        {
            if (!player.CanBuild() || !Initializated())
            {
                return "Вы не можете удалять постройки на <color=#81B67A>чужой территории</color>!";
            }

            if (entity is DecayEntity && !(entity is BuildingBlock))
            {
                return "Вы можете удалять <color=#81B67a>только конструкции</color>";
            }
            
            if (CONF_RemoveTime != 0 && removeTimers.ContainsKey(entity.net.ID))
            {
                
                if (removeTimers[entity.net.ID] <= LogTime())
                {
                    removeTimers.Remove(entity.net.ID);
                    return "Вышло время удаления данного объекта!";
                }
            }
            else if (CONF_RemoveTime != 0 && !removeTimers.ContainsKey(entity.net.ID))
            {
                return "Вышло время удаления данного объекта!";
            }
            
            if (CONF_BlockRemoveOnRaid && NoEscape)
            {
                var blockTime = (bool) (NoEscape?.Call("IsRaidBlocked", player) ?? false);
                if (blockTime)
                {
                    return "Вы не можете удалять постройки <color=#81B67A>во время рейда</color>!";
                }
            }

            bool isOwner = entity.OwnerID == player.userID;
            bool areFriends = (bool) ((Friends?.Call("AreFriends", player.userID, entity.OwnerID) ?? false));
            List<string> areClanMates = (List<string>) (Clans?.Call("GetClanMembers", player.userID) ?? new List<string>());
            
            if (CONF_RemoveByCup == true || (CONF_RemoveFriends && areFriends) || (CONF_RemoveClans && areClanMates.Contains(entity.OwnerID.ToString())) || isOwner)
            {
                return "";
            }
            else
            {
                return "Вы можете удалять свои постройки, а также постройки друзей!";
            }

            return "";
        }

        private string TryUpgrade(BasePlayer player, BuildingBlock block, CurrentGrade currentGrade)
        {
            if (currentGrade.Grade <= (int) block.lastGrade || !Initializated())
                return "";

            if (CONF_BlockUpgradeOnRaid && NoEscape)
            {
                var blockTime = (bool) (NoEscape?.Call("IsRaidBlocked", player) ?? false);
                if (blockTime)
                {
                    currentGrade.DeActivate(player);
                    return "Вы не можете авто-улучшать постройки <color=#81B67A>во время рейда</color>!";
                }
            }
            
            if (!player.CanBuild())
            {
                currentGrade.DeActivate(player);
                return "Вы находитесь на чужой территории, автоматическое улучшение <color=#81B67A>отключено</color>!";
            }
            
            if (block.SecondsSinceAttacked < 30)
            {
                return $"Это объект можно будет улучшить через <color=#81B67A>{FormatTime(TimeSpan.FromSeconds(30 - (int) block.SecondsSinceAttacked), maxSubstr:2)}</color>";
            }
            
            foreach (var check in block.blockDefinition.grades[currentGrade.Grade].costToBuild)
            {
                if (player.inventory.GetAmount(check.itemid) < check.amount)
                {
                    CuiHelper.DestroyUi(player, Layer);
                    currentGrade.DeActivate(player);
                    return "У вас не хватает ресурсов для автоматического улучшения!";
                }
            }
            foreach (var check in block.blockDefinition.grades[currentGrade.Grade].costToBuild)
            {
                player.inventory.Take(null, check.itemid, (int) check.amount);
                player.Command("note.inv", check.itemid, check.amount * -1f);
            }
            block.SetGrade((BuildingGrade.Enum) currentGrade.Grade);
            block.UpdateSkin();
            block.SetHealthToMax();
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            currentGrade.UpdateTime(player, CONF_RemoveDefaultTime);
            
            return "";
        }

        private void UpdateTimer(BasePlayer player)
        {
            if (!playerGrades.ContainsKey(player.userID) || !Initializated())
                playerGrades.Add(player.userID, new CurrentGrade());

            CurrentGrade currentGrade = playerGrades[player.userID];
            if (currentGrade.Grade == 0)
            {
                CuiHelper.DestroyUi(player, Layer);
                return;
            }
            
            CuiHelper.DestroyUi(player, Layer);
            
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.4359375 0.1148148", AnchorMax = "0.55 0.1379629", OffsetMax = "0 0 " },
                Image = { Color = HexToRustFormat("#81B67B3C"), Sprite = "assets/content/ui/ui.background.tile.psd"},
            }, "Hud", Layer);
            container.Add(new CuiLabel
            {
                Text = { Text = $"{CONF_GradeNames[currentGrade.Grade].ToUpper()}: {currentGrade.DeActivateTime} СЕК.", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, Layer);

            CuiHelper.AddUi(player, container);
            
            currentGrade.DeActivateTime--;
            if (currentGrade.DeActivateTime < 0)
            {
                currentGrade.DeActivate(player);
                CuiHelper.DestroyUi(player, Layer);
                return;
            }
            
            currentGrade.DeTimer?.Destroy();
            currentGrade.DeTimer = timer.Once(1, () => UpdateTimer(player));
        }

        #endregion

        #region Commands

        [ChatCommand("remove")]
        private void cmdChatRemove(BasePlayer player, string command, string[] args)
        {
            if (!CONF_RemoveActivated)
                return;
            
            if (!permission.UserHasPermission(player.UserIDString, CONF_RemovePermission))
            {
                SendReply(player, "У вас <color=#81B67a>недостаточно</color> прав для использования этой команды!");
                return;
            }
            
            OnPlayerInit(player);
            CurrentGrade currentGrade = playerGrades[player.userID];

            if (currentGrade.Grade == 5)
            {
                currentGrade.DeActivate(player);
                return;
            }
            else
            {
                currentGrade.Activate(player, 5, CONF_RemoveDefaultTime);
            }
        }

        [ChatCommand("up")]
        private void cmdChatUpgrade(BasePlayer player, string command, string[] args)
        {
            if (!CONF_UpActivated)
                return;
            
            if (!permission.UserHasPermission(player.UserIDString, CONF_UpPermission))
            {
                SendReply(player, "У вас <color=#81B67a>недостаточно</color> прав для использования этой команды!");
                return;
            }
            
            OnPlayerInit(player);
            CurrentGrade currentGrade = playerGrades[player.userID];

            switch (args.Length)
            {
                case 0:
                {
                    currentGrade.UpGrade(player, CONF_RemoveDefaultTime);
                    break;
                }
                case 1:
                {
                    int newGrade;
                    if (!int.TryParse(args[0], out newGrade) || newGrade < 0 || newGrade > 4)
                    {
                        SendReply(player, $"Мы <color=#81B67A>не смогли</color> распознать введеный уровень улучшения!\n" +
                                                $"Возможные варианты:\n" +
                                                $"\n" +
                                                $"[<color=#81B67A>0</color>] -> Отключить\n" +
                                                $"[<color=#81B67A>1</color>] -> В дерево\n" +
                                                $"[<color=#81B67A>2</color>] -> В камень\n" +
                                                $"[<color=#81B67A>3</color>] -> В метал\n" +
                                                $"[<color=#81B67A>4</color>] -> В МВК");
                        return;
                    }
                    currentGrade.Activate(player, newGrade, CONF_RemoveDefaultTime);
                    break;
                }
                default:
                {
                    cmdChatUpgrade(player, command, new string[] { });
                    return;
                }
            }
        }

        #endregion

        #region Hooks

        
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan?.GetOwnerPlayer();
            if (player == null)
                return;
            
            if (!playerGrades.ContainsKey(player.userID))
                playerGrades.Add(player.userID, new CurrentGrade());
            
            CurrentGrade currentGrade = playerGrades[player.userID];
            
            
            BuildingBlock block = go.ToBaseEntity().GetComponent<BuildingBlock>();
            if (block == null)
                return;
            
            if (CONF_RemoveTime != 0)
                removeTimers.Add(block.net.ID, LogTime() + CONF_RemoveTime);
            
            if (currentGrade.Grade <= 0 || currentGrade.Grade > 4)
                return;

            var result = TryUpgrade(player, block, currentGrade);
            if (result != "")
            {
                player.ChatMessage(result);
                return;
            }
        }
        
        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (info == null)
                return;
            
            if (!playerGrades.ContainsKey(player.userID))
                playerGrades.Add(player.userID, new CurrentGrade());
            
            CurrentGrade currentGrade = playerGrades[player.userID];

            if (currentGrade.Grade == 5)
            {
                if (info.HitEntity is DecayEntity || info.HitEntity is BaseOven || info.HitEntity is BuildingBlock || info.HitEntity is SimpleBuildingBlock)
                {
                    var tryRemoveResult = TryRemove(player, info.HitEntity);
                    if (tryRemoveResult != "")
                        SendReply(player, tryRemoveResult);
                    else
                    {
                        NextTick(() =>
                        {
                            if (info.HitEntity.GetComponent<StorageContainer>() != null)
                            {
                                info.HitEntity.GetComponent<StorageContainer>().DropItems();
                            }
                            if (CONF_RemoveOneHit)
                                info.HitEntity.GetComponent<BaseCombatEntity>().Kill();
                            else
                                info.HitEntity.GetComponent<BaseCombatEntity>().Hurt(2500);
                        });
                    }
                }
            }
            else if (currentGrade.Grade != 0)
            {
                if (info.HitEntity is BuildingBlock)
                {
                    BuildingBlock block = info.HitEntity as BuildingBlock;
                    
                    var tryUpgradeRsult = TryUpgrade(player, block, currentGrade);
                    if (tryUpgradeRsult != "")
                        SendReply(player, tryUpgradeRsult);
                }
            }
            else
            {
                if (TryRemove(player, info.HitEntity) == "")
                {
                    if (info.HitEntity is BuildingBlock)
                    {
                        BuildingBlock block = info.HitEntity as BuildingBlock;
                        if (removeTimers.ContainsKey(block.net.ID) && player.SecondsSinceAttacked > 10)
                        {
                            double leftRemove = removeTimers[block.net.ID] - LogTime();
                            if (leftRemove < 0)
                            {
                                SendReply(player, "Время удаления данного объекта <color=#81B67a>закончилось</color>!");
                            }
                            else
                            {
                                SendReply(player, $"Через <color=#81B67A>{FormatTime(TimeSpan.FromSeconds(leftRemove), maxSubstr:2)}</color> вы не сможете удалить этот объект!");
                            }
                            player.Hurt(0);
                            return;
                        }
                    }
                }
                return;
            }
        }
        
        object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (!playerGrades.ContainsKey(player.userID))
                playerGrades.Add(player.userID, new CurrentGrade());

            CurrentGrade currentGrade = playerGrades[player.userID];

            if (CONF_EnableOnHit && permission.UserHasPermission(player.UserIDString, CONF_UpPermission))
            {
                currentGrade.Activate(player, (int) grade, CONF_RemoveHitTime);
            }

            if (player.SecondsSinceAttacked > 10)
            {
                SendReply(player, $"Вы можете удалить построенный объект в течении <color=#81B67A>{FormatTime(TimeSpan.FromSeconds(CONF_RemoveTime), maxSubstr:2)}</color>");
                player.Hurt(0);
            }
            return null;
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (!playerGrades.ContainsKey(player.userID))
                playerGrades.Add(player.userID, new CurrentGrade());
        }

        #endregion

        #region Utils

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        
        public static string FormatTime(TimeSpan time, int maxSubstr = 5, string language = "ru")
        {
            string result = string.Empty;
            switch (language)
            {
                case "ru":
                    int i = 0;
                    if (time.Days != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";
                        
                        result += $"{Format(time.Days, "дней", "дня", "день")}";
                        i++;
                    }

                    if (time.Hours != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Hours, "часов", "часа", "час")}";
                        i++;
                    }

                    if (time.Minutes != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Minutes, "минут", "минуты", "минута")}";
                        i++;
                    }

                    if (time.Seconds != 0 && i < maxSubstr)
                    {
                        if (!string.IsNullOrEmpty(result))
                            result += " ";

                        result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")}";
                        i++;
                    }

                        break;
                case "en":
                    result = string.Format( "{0}{1}{2}{3}",
                        time.Duration().Days > 0 ? $"{time.Days:0} day{( time.Days == 1 ? String.Empty : "s" )}, " : string.Empty,
                        time.Duration().Hours > 0 ? $"{time.Hours:0} hour{( time.Hours == 1 ? String.Empty : "s" )}, " : string.Empty,
                        time.Duration().Minutes > 0 ? $"{time.Minutes:0} minute{( time.Minutes == 1 ? String.Empty : "s" )}, " : string.Empty,
                        time.Duration().Seconds > 0 ? $"{time.Seconds:0} second{( time.Seconds == 1 ? String.Empty : "s" )}" : string.Empty );

                    if (result.EndsWith( ", " )) result = result.Substring( 0, result.Length - 2 );

                    if (string.IsNullOrEmpty( result )) result = "0 seconds";
                    break;
            }
            return result;
        }
        
        public bool Initializated()
        {
            int result = 0;
            foreach (var check in Author.ToCharArray())
                result += (int) check;
            return result == 610 ? true : false;
        }
      
        private static string Format(int units, string form1, string form2, string form3 )
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        
        private bool GetConfig<T>(string mainMenu, string key, ref T var)
        {
            if (Config[mainMenu, key] != null)
            {
                var = Config.ConvertValue<T>(Config[mainMenu, key]);
                return false;
            }

            Config[mainMenu, key] = var;
            return true;
        }
        
        private static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private static double LogTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion
    }
}

// --- End of file: GradeDestroy.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RGive.cs ---
// --- Original Local Path: RGive.cs ---

using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("RGive", "LaserHydra", "2.0.2", ResourceId = 929)]
    [Description("Random item giving")]

    class RGive : RustPlugin
    {
        #region Class

        class Category : Dictionary<string, object>
        {
            public Category(int MinimalAmount, int MaximalAmount, bool Enabled)
            {
                this.Add("Minimal Amount", MinimalAmount);
                this.Add("Maximal Amount", MaximalAmount);
                this.Add("Enabled", Enabled);
            }
        }

        #endregion

        #region Plugin General
        ////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////

        void Loaded()
        {
            permission.RegisterPermission("rgive.use", this);

            LoadConfig();
        }

        ////////////////////////////////////////
        ///     Config Handling
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Categories", "Weapon", new Category(1, 2, true));
            SetConfig("Categories", "Construction", new Category(1, 5, true));
            SetConfig("Categories", "Items", new Category(1, 5, true));
            SetConfig("Categories", "Resources", new Category(500, 10000, false));
            SetConfig("Categories", "Attire", new Category(1, 2, true));
            SetConfig("Categories", "Tool", new Category(1, 2, true));
            SetConfig("Categories", "Medical", new Category(1, 5, true));
            SetConfig("Categories", "Food", new Category(5, 10, false));
            SetConfig("Categories", "Ammunition", new Category(5, 64, true));
            SetConfig("Categories", "Traps", new Category(1, 3, true));
            SetConfig("Categories", "Misc", new Category(1, 5, false));

            SetConfig("Settings", "Item Blacklist", new List<object> { "autoturret", "mining.quarry", "mining.pumpjack", "cctv.camera", "targeting.computer" });

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");

#endregion

        #region Subject Related

        object GetRandomAmount(string category)
        {
            if (Config["Categories", category] == null)
                return null;

            Dictionary<string, object> settings = Config["Categories", category] as Dictionary<string, object>;

            if (settings == null)
                return null;

            int minAmount = Convert.ToInt32(settings["Minimal Amount"]);
            int maxAmount = Convert.ToInt32(settings["Maximal Amount"]) + 1;

            return UnityEngine.Random.Range(minAmount, maxAmount);
        }

        BasePlayer GetRandomPlayer() => BasePlayer.activePlayerList[UnityEngine.Random.Range(0, BasePlayer.activePlayerList.Count - 1)];

        void GiveRandomItem(BasePlayer player)
        {
            if (player == null)
                return;

            ItemDefinition info = ItemManager.itemList[UnityEngine.Random.Range(0, ItemManager.itemList.Count - 1)];

            List<object> blacklist = GetConfig(new List<object> { "autoturret", "mining.quarry", "mining.pumpjack", "cctv.camera", "targeting.computer" }, "Settings", "Item Blacklist");

            if (!GetConfig(false, "Categories", info.category, "Enabled") || blacklist.Contains(info.shortname))
            {
                GiveRandomItem(player);
                return;
            }

            int amount = (int)GetRandomAmount(info.category.ToString());

            GiveItem(ItemManager.CreateByItemID(info.itemid), amount, player);

            string message = $"You have recieved random items: {amount}x {info.displayName.english}s";

            if (amount == 1 || info.displayName.english.EndsWith("s"))
                message = $"You have recieved a random item: {amount}x {info.displayName.english}";

            SendChatMessage(player, "RGive", message);
        }

        void GiveItem(Item item, int amount, BasePlayer player)
        {
            if (item == null)
                return;

            player.inventory.GiveItem(ItemManager.CreateByItemID(item.info.itemid, amount));
        }

#endregion

        #region Commands

        [ChatCommand("rgive")]
        void cmdRGive(BasePlayer player, string cmd, string[] args)
        {
            if (player != null)
            {
                if (!HasPerm(player.userID, "use"))
                {
                    SendChatMessage(player, "RGive", "You don't have permission to use this command!");
                    return;
                }
            }

            //	Give Random item to all
            if (args.Length == 1 && args[0].ToLower() == "all")
            {
                foreach (BasePlayer current in BasePlayer.activePlayerList)
                    GiveRandomItem(current);

                BroadcastChat("RGive", "Random items have been given to all online players!");

                return;
            }

            //	Show Syntax
            if (args.Length < 2)
            {
                SendChatMessage(player, "<size=20>RGive</size>", "\n" +
                            "<color=#00FF8D>/rgive player <playername></color> give random item to specific player\n" +
                            "<color=#00FF8D>/rgive item <itemname></color> give specific item to random player\n" +
                            "<color=#00FF8D>/rgive all</color> give random item to all players\n");

                return;
            }

            if (args.Length >= 2)
            {
                switch (args[0].ToLower())
                {
                    //	Give random item to specific player
                    case "player":
                        BasePlayer specificTarget = GetPlayer(args[1], player);
                        if (specificTarget == null) return;

                        GiveRandomItem(specificTarget);
                        SendChatMessage(player, "RGive", "Random items given to " + specificTarget.displayName);

                        break;

                    //	Give specific item to random player
                    case "item":
                        BasePlayer randomTarget = GetRandomPlayer();
                        Item item = GetItem(args[1], player);
                        if (item == null)
                            return;

                        int amount = (int)GetRandomAmount(item.info.category.ToString());

                        GiveItem(item, amount, randomTarget);

                        //	Send message to the sender

                        if (amount == 1 || item.info.displayName.english.EndsWith("s"))
                            SendChatMessage(player, "RGive", $"{amount} {item.info.displayName.english} given to {randomTarget.displayName}");
                        else
                            SendChatMessage(player, "RGive", $"{amount} {item.info.displayName.english}s given to {randomTarget.displayName}");

                        //	Send message to the lucky reciever

                        if (amount == 1 || item.info.displayName.english.EndsWith("s"))
                            SendChatMessage(randomTarget, "RGive", $"You have been randomly chosen to recieve {amount} {item.info.displayName.english}");
                        else
                            SendChatMessage(randomTarget, "RGive", "You have been randomly chosen to recieve {amount} {item.info.displayName.english}s");

                        break;

                    //	Wrong args, show Syntax
                    default:
                        SendChatMessage(player, "<size=20>RGive</size>", "\n" +
                            "<color=#00FF8D>/rgive player <playername></color> give random item to specific player\n" +
                            "<color=#00FF8D>/rgive item <itemname></color> give specific item to random player\n" +
                            "<color=#00FF8D>/rgive all</color> give random item to all players\n");
                        break;
                }
            }
        }

        [ConsoleCommand("rgive")]
        void ccmdRGive(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg?.connection?.player == null ? null : (BasePlayer) arg.connection.player;

            string[] args = arg.HasArgs() ? arg.Args : new string[0];

            cmdRGive(player, arg.cmd.name, args);
        }

        #endregion

        #region General Methods

        ////////////////////////////////////////
        ///     Player & Item Finding
        ////////////////////////////////////////

        Item GetItem(string searchedItem, BasePlayer player)
        {
            if (ItemManager.CreateByName(searchedItem.ToLower()) != null)
                return ItemManager.CreateByName(searchedItem.ToLower());

            List<string> foundItemNames =
                (from info in ItemManager.itemList
                 where info.shortname.ToLower().Contains(searchedItem.ToLower())
                 select info.shortname).ToList();

            switch (foundItemNames.Count)
            {
                case 0:
                    SendChatMessage(player, "The item can not be found.");

                    break;

                case 1:
                    return ItemManager.CreateByName(foundItemNames[0]);

                default:
                    string players = ListToString(foundItemNames, 0, ", ");
                    SendChatMessage(player, "Multiple matching items found: \n" + players);

                    break;
            }

            return null;
        }

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer player)
        {
            foreach (BasePlayer current in BasePlayer.activePlayerList)
                if (current.displayName.ToLower() == searchedPlayer.ToLower())
                    return current;

            List<BasePlayer> foundPlayers =
                (from current in BasePlayer.activePlayerList
                 where current.displayName.ToLower().Contains(searchedPlayer.ToLower())
                 select current).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(player, "The player can not be found.");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    List<string> playerNames = (from current in foundPlayers select current.displayName).ToList();
                    string players = ListToString(playerNames, 0, ", ");
                    SendChatMessage(player, "Multiple matching players found: \n" + players);
                    break;
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Data Related
        ////////////////////////////////////////

        void LoadData<T>(ref T data, string filename = "?") => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename == "?" ? this.Title : filename);

        void SaveData<T>(ref T data, string filename = "?") => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == "?" ? this.Title : filename, data);

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        void RegisterPerm(params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
        }

        bool HasPerm(object uid, params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
        }

        string PermissionPrefix
        {
            get
            {
                return this.Title.Replace(" ", "").ToLower();
            }
        }

        ////////////////////////////////////////
        ///     Chat Related
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null)
        {
            if (player == null)
                Puts(msg == null ? StripTags(prefix) : StripTags(msg));
            else
                rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);
        }

        string StripTags(string original)
        {
            List<string> regexTags = new List<string>
            {
                @"<color=.+?>",
                @"<size=.+?>"
            };

            List<string> tags = new List<string>
            {
                "</color>",
                "</size>",
                "<i>",
                "</i>",
                "<b>",
                "</b>"
            };

            foreach (string tag in tags)
                original = original.Replace(tag, "");

            foreach (string regexTag in regexTags)
                original = new Regex(regexTag).Replace(original, "");

            return original;
        }

        #endregion
    }
}


// --- End of file: RGive.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoBugs.cs ---
// --- Original Local Path: NoBugs.cs ---

using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
    [Info("NoBugs", "azalea`", "1.3", ResourceId = 1778)]
    class NoBugs : RustPlugin
    {
        void OnServerInitialized()
        {
            foreach (var stash in UnityEngine.Object.FindObjectsOfType<StashContainer>())
            {
                SetupObject(stash.gameObject);
            }

            foreach (var stocking in UnityEngine.Object.FindObjectsOfType<Stocking>())
            {
                SetupObject(stocking.gameObject);
            }
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (player.IsDead())
                player.RemoveFromTriggers();
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (player.IsAlive() && !player.IsOnGround() && !player.IsAdmin())
                player.Die();
        }

        void OnEntityBuilt(Planner plan, GameObject obj)
        {
            if (obj.GetComponent<StashContainer>() != null || obj.GetComponent<Stocking>() != null)
            {
                SetupObject(obj);

                return;
            }

            if (obj.GetComponentInParent<BuildingBlock>() != null)
            {
                BuildingBlock Block = obj.GetComponentInParent<BuildingBlock>();
                
                if (!Block.blockDefinition.hierachyName.StartsWith("foundation")) return;

                RaycastHit hitInfo;

                if (Physics.Raycast(new Ray(obj.transform.position, Vector3.down), out hitInfo, float.PositiveInfinity))
                {
                    if (System.Math.Round(hitInfo.distance, 2) == 0.00d)
                        Block.KillMessage();
                }
                else    Block.KillMessage();
            }
        }

        void SetupObject(GameObject Object)
        {
            Object.layer = (int)Layer.Prevent_Building;
            //Object.transform.localScale = new Vector3(1f, 3f, 1f);
        }
    }
}

// --- End of file: NoBugs.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EnemyBar.cs ---
// --- Original Local Path: EnemyBar.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("EnemyBar", "TopPlugin.ru", "1.0.2")]
// 332 строка добавлено                 if (targetPlayer == null) return;
    public class EnemyBar : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

        private const string elemMain = "healthbar.main";
        private const string elemPanel = "healthbar.panel";
        private static EnemyBar plugin;

     #region ConfigData

        private static ConfigData configData;
        public class ConfigData
        {
            [JsonProperty("ОСНОВНЫЕ НАСТРОЙКИ")]
            public SettingBasic OptionsBasic;
            [JsonProperty("НАСТРОЙКИ ГРАФИЧЕСКОГО ИНТЕРФЕЙСА")]
            public SettingGUI OptionsGUI;

            public class SettingBasic
            {
                [JsonProperty("Разрешение для отображения интерфейса")]
                public string permUse;
                [JsonProperty("Текст в графическом интерфейсе")]
                public string woundedText;
                [JsonProperty("Интервал проверки здоровья")]
                public float healthCheckInterval;
            }

            public class SettingGUI
            {
                [JsonProperty("Позиция графического интерфейса")]
                public string position;
                [JsonProperty("Цвет фона графического интерфейса")]
                public string colorBackground;
                [JsonProperty("Цвет шкалы здоровья графического интерфейса")]
                public string colorLine;
                [JsonProperty("Размер текста в графическом интерфейсе")]
                public int textSize;
                [JsonProperty("Цвет текста в графическом интерфейсе")]
                public string textColor;
                [JsonProperty("Ссылка на изображение")]
                public string iconUrl;
                [JsonProperty("Время отображения шкалы здоровья |секунд|")]
                public int duration;
                [JsonProperty("Время принудительного удаления шкалы здоровья |секунд|")]
                public int forceDuration;
            }
        }

        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData
            {
                OptionsBasic = new ConfigData.SettingBasic
                {
                    healthCheckInterval = 0.2f,
                    woundedText = "<color=#FF0000>ранен</color>",
                    permUse = "enemybar.use"
                },
                OptionsGUI = new ConfigData.SettingGUI
                {
                    position = "0.5 0.15",
                    colorBackground = "0.8 0.8 0.8 0.3",
                    colorLine = "0.55 0.78 0.24 1",
                    textSize = 14,
                    textColor = "1 1 1 0.8",
                    iconUrl = "https://i.imgur.com/OIeOcBr.png",
                    duration = 5,
                    forceDuration = 15
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();
        }
        protected override void SaveConfig() => Config.WriteObject(configData);

     #endregion

        private void Init()
        {
            permission.RegisterPermission(configData.OptionsBasic.permUse, this);
            plugin = this;
            timer.Every(Core.Random.Range(500, 700), CheckPlayers);
        }

        private void OnServerInitialized()
        {
            
            AddImage(elemMain, configData.OptionsGUI.iconUrl);
            CheckPlayers();
        }

        private void Unload()
        {
            DestroyScripts();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, configData.OptionsBasic.permUse) == false)
            {
                return;
            }
            player.gameObject.GetOrAddComponent<HealthBar>();
        }

        private void OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            var script = player.GetComponent<HealthBar>();
            if (script != null)
            {
                script.OnAttacked(info?.HitEntity);
            }
        }

        private void CheckPlayers()
        {
            timer.Once(1f, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    OnPlayerConnected(player);
                }
            });
        }

        private void DestroyScripts()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var script = player.GetComponent<HealthBar>();
                UnityEngine.Object.Destroy(script);
            }
        }

        private void CreateGUI(BasePlayer player, float fraction, string value)
        {
            var container = new CuiElementContainer();
            var cfg = configData.OptionsGUI;
            var sizeX = 0.98 * fraction;

            container.Add(new CuiElement
            {
                Name = elemMain,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = cfg.position,
                        AnchorMax = cfg.position
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = elemPanel,
                Parent = elemMain,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = cfg.colorBackground,
                        Material = "assets/content/ui/namefontmaterial.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        OffsetMin = "-95.5 0",
                        OffsetMax = "95.5 25"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = elemPanel,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = cfg.colorLine,
                        Material = "assets/content/ui/namefontmaterial.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.133 0.13",
                        AnchorMax = $"{sizeX} 0.87"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = elemPanel,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = value,
                        Align = TextAnchor.MiddleLeft,
                        FontSize = cfg.textSize,
                        Color = cfg.textColor
                    },
                    new CuiRectTransformComponent
                    {
                        OffsetMin = "32 0",
                        OffsetMax = "32 0",
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = elemPanel,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = GetImage(elemMain),
                        Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax="0 0",
                        OffsetMin = "0 0", OffsetMax="25 25"
                    }
                }
            });
            CuiHelper.DestroyUi(player, elemMain);
            CuiHelper.AddUi(player, container);
        }

        private static void DestroyGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, elemMain);
        }

        private void AddImage(string name, string url)
        {
            if (ImageLibrary == null || ImageLibrary?.IsLoaded == false)
            {
                timer.Once(3f, () =>
                {
                    AddImage(name, url);
                });
                return;
            }

            if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(url))
            {
                return;
            }
            ImageLibrary.CallHook("AddImage", url, name, (ulong) 0);
        }

        private string GetImage(string name)
        {
            return ImageLibrary?.Call<string>("GetImage", name);
        }

        private class HealthBar : MonoBehaviour
        {
            private BasePlayer player;
            private BaseCombatEntity target;
            private BasePlayer targetPlayer;
            private float lastHealth;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }

            public void OnAttacked(BaseEntity entity)
            {
                if (entity == null || target == entity)
                {
                    return;
                }
                target = entity.GetComponent<BaseCombatEntity>();
                targetPlayer = entity.GetComponent<BasePlayer>();

                if (IsInvoking(nameof(CheckHealth)) == false)
                {
                    InvokeRepeating(nameof(CheckHealth), configData.OptionsBasic.healthCheckInterval, configData.OptionsBasic.healthCheckInterval);
                }

                if (configData.OptionsGUI.forceDuration != 0)
                {
                    if (IsInvoking(nameof(ForceDestroy)) == false)
                    {
                        Invoke(nameof(ForceDestroy), configData.OptionsGUI.forceDuration);
                    }
                }
            }

            private void CheckHealth()
            {
                if (target == null)
                {
                    CancelInvoke(nameof(CheckHealth));
                    DestroyGUI(player);
                    return;
                }

                

                if (Math.Abs(target.Health() - lastHealth) > 0.2f)
                {
                    OnDamaged();
                }
            }

            private void OnDamaged()
            {
                if (targetPlayer == null) return;
                lastHealth = target.Health();
                var value = Convert.ToInt32(target.Health()).ToString();
                var fraction = target.Health() / target.MaxHealth();

                if (lastHealth < 10)
                {
                    if (targetPlayer?.IsWounded() ?? false)
                    {
                        value = configData.OptionsBasic.woundedText;
                        fraction = 0.15f;
                    }
                }

                plugin.CreateGUI(player, fraction, value);
                CancelInvoke(nameof(TimedDestroy));
                Invoke(nameof(TimedDestroy), configData.OptionsGUI.duration);
            }

            private void ForceDestroy()
            {
                target = null;
                CancelInvoke(nameof(CheckHealth));
                DestroyGUI(player);
            }

            private void TimedDestroy()
            {
                DestroyGUI(player);
            }
        }
    }
}


// --- End of file: EnemyBar.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DiscordMessages.cs ---
// --- Original Local Path: DiscordMessages.cs ---

﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info( "DiscordMessages", "Slut", "2.1.8" )]
    [SuppressMessage( "ReSharper", "UnusedMember.Local" )]
    internal class DiscordMessages : CovalencePlugin
    {
        #region PlayerChat

#if RUST
        private void OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel)
        {
            if (channel == ConVar.Chat.ChatChannel.Team)
            {
                return;
            }

            var player = basePlayer.IPlayer;
            if (player == null)
            {
                return;
            }
            if (BetterChatMute?.Call<bool>("API_IsMuted", player) ?? false)
            {
                return;
            }
            if (AdminChat?.Call<bool>("HasAdminChatEnabled", player) ?? false)
            {
                return;
            }
            
            if (!player.HasPermission(AdminPermission)) message = message.Replace("@everyone", "@ everyone").Replace("@here", "@ here");
            var chatConfig = GetFeatureConfig<Configuration.Chat>(FeatureType.PlayerChat);
            string discordMessage = GetLang( "PlayerChatFormatNew", null, player.Name, message, DateTime.Now.ToShortTimeString() );
            Request.Send(chatConfig.WebhookUrl, new FancyMessage().WithContent(discordMessage).AsTTS(chatConfig.TextToSpeech), this);   
        }

#else
        private void OnUserChat( IPlayer player, string message )
        {
            if ( !GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat ).Enabled )
            {
                return;
            }

            if ( BetterChatMute?.Call<bool>( "API_IsMuted", player ) ?? false )
            {
                return;
            }

            if ( AdminChat?.Call<bool>( "HasAdminChatEnabled", player ) ?? false )
            {
                return;
            }

            if ( !player.HasPermission( AdminPermission ) )
            {
                message = message.Replace( "@everyone", "@ everyone" ).Replace( "@here", "@ here" );
            }

            var chatConfig = GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat );
            string discordMessage = GetLang( "PlayerChatFormatNew", null, player.Name, message, DateTime.Now.ToShortTimeString() );
            Request.Send( chatConfig.WebhookUrl, new FancyMessage().WithContent( discordMessage ).AsTTS( chatConfig.TextToSpeech ), this );
        }
#endif

        #endregion

        #region Message

        private void MessageCommand( IPlayer player, string command, string[] args )
        {
            if ( args.Length < 1 )
            {
                SendMessage( player, GetLang( "MessageSyntax", player.Id ) );
                return;
            }

            var messageConfig = GetFeatureConfig<Configuration.Message>( FeatureType.Message );

            int secondsRemaining;
            if ( OnCooldown( player, CooldownType.MessageCooldown, out secondsRemaining ) )
            {
                SendMessage( player, GetLang( "Cooldown", player.Id, secondsRemaining.ToString() ));

                return;
            }

            string message = string.Join( " ", args.ToArray() );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_MessageTitle" ) ).AddInlineField( GetLang( "Embed_MessagePlayer" ), $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" ).AddField( GetLang( "Embed_MessageMessage" ), message ).SetColor( messageConfig.Color );
            FancyMessage payload = new FancyMessage().WithContent( messageConfig.Alert ).SetEmbed( builder );
            Request.Send( messageConfig.WebhookUrl, payload, response =>
            {
                if ( response.IsOk )
                {
                    SendMessage( player, GetLang( "MessageSent", player.Id ) );

                    PlayerData data;
                    if ( !_data.Players.TryGetValue( player.Id, out data ) )
                    {
                        _data.Players.Add( player.Id, data = new PlayerData() );
                    }

                    data.MessageCooldown = DateTime.UtcNow;

                    if ( messageConfig.LogToConsole )
                    {
                        Puts( $"MESSAGE ({player.Name}/{player.Id}) : {message}" );
                    }
                }
                else if ( response.IsBad )
                {
                    SendMessage( player, GetLang( "MessageNotSent", player.Id ) );
                }
            }, this );
        }

        #endregion

        #region Classes

        private class Data
        {
            public readonly Dictionary<string, PlayerData> Players = new Dictionary<string, PlayerData>();
        }

        private class PlayerData
        {
            public int Reports { get; set; }
            public DateTime? ReportCooldown { get; set; }
            public DateTime? MessageCooldown { get; set; }
            public bool ReportDisabled { get; set; }
        }

        public class FancyMessage
        {
            [JsonProperty( "content" )] private string Content { get; set; }

            [JsonProperty( "tts" )] private bool TextToSpeech { get; set; }

            [JsonProperty( "embeds" )] private EmbedBuilder[] Embeds { get; set; }

            public FancyMessage WithContent( string value )
            {
                Content = value;
                return this;
            }

            public FancyMessage AsTTS( bool value )
            {
                TextToSpeech = value;
                return this;
            }

            public FancyMessage SetEmbed( EmbedBuilder value )
            {
                Embeds = new[]
                {
                    value
                };
                return this;
            }

            public string GetContent()
            {
                return Content;
            }

            public bool IsTTS()
            {
                return TextToSpeech;
            }

            public EmbedBuilder GetEmbed()
            {
                return Embeds[0];
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject( this, _instance._jsonSettings );
            }
        }

        public class EmbedBuilder
        {
            public EmbedBuilder()
            {
                Fields = new List<Field>();
            }

            [JsonProperty( "title" )] private string Title { get; set; }

            [JsonProperty( "color" )] private int Color { get; set; }

            [JsonProperty( "fields" )] private List<Field> Fields { get; }

            [JsonProperty( "description" )] private string Description { get; set; }

            public EmbedBuilder WithTitle( string title )
            {
                Title = title;
                return this;
            }

            public EmbedBuilder WithDescription( string description )
            {
                Description = description;
                return this;
            }

            public EmbedBuilder SetColor( int color )
            {
                Color = color;
                return this;
            }

            public EmbedBuilder SetColor( string color )
            {
                Color = ParseColor( color );
                return this;
            }

            public EmbedBuilder AddInlineField( string name, object value )
            {
                Fields.Add( new Field( name, value, true ) );
                return this;
            }

            public EmbedBuilder AddField( string name, object value )
            {
                Fields.Add( new Field( name, value, false ) );
                return this;
            }

            public EmbedBuilder AddField( Field field )
            {
                Fields.Add( field );
                return this;
            }

            public EmbedBuilder AddFields( Field[] fields )
            {
                for ( var i = 0; i < fields.Length; i++ )
                {
                    Fields.Add( fields[i] );
                }

                return this;
            }

            public int GetColor()
            {
                return Color;
            }

            public string GetTitle()
            {
                return Title;
            }

            public Field[] GetFields()
            {
                return Fields.ToArray();
            }

            private int ParseColor( string input )
            {
                int color;
                if ( !int.TryParse( input, out color ) )
                {
                    color = 3329330;
                }

                return color;
            }

            public class Field
            {
                [JsonProperty( "inline" )]
                public bool Inline;

                [JsonProperty( "name" )]
                public string Name;

                [JsonProperty( "value" )]
                public object Value;

                public Field( string name, object value, bool inline )
                {
                    Name = name;
                    Value = value;
                    Inline = inline;
                }

                public Field() { }
            }
        }

        private abstract class Response
        {
            public int Code { get; set; }
            public string Message { get; set; }
        }

        private class BaseResponse : Response
        {
            public bool IsRatelimit => Code == 429;
            public bool IsOk => ( Code == 200 ) | ( Code == 204 );
            public bool IsBad => !IsRatelimit && !IsOk;

            public RateLimitResponse GetRateLimit()
            {
                return Message.Length == 0 ? null : JsonConvert.DeserializeObject<RateLimitResponse>( Message );
            }
        }

        private class Request
        {
            private static bool _rateLimited;
            private static bool _busy;
            private static Queue<Request> _requestQueue;
            private readonly string _payload;
            private readonly Plugin _plugin;
            private readonly Action<BaseResponse> _response;
            private readonly string _url;

            public static void Init()
            {
                _requestQueue = new Queue<Request>();
            }

            private Request( string url, FancyMessage message, Action<BaseResponse> response = null, Plugin plugin = null )
            {
                _url = url;
                _payload = message.ToJson();
                _response = response;
                _plugin = plugin;
            }

            private Request( string url, FancyMessage message, Plugin plugin = null )
            {
                _url = url;
                _payload = message.ToJson();
                _plugin = plugin;
            }

            private static void SendNextRequest()
            {
                if ( _requestQueue.Count == 0 )
                {
                    return;
                }

                Request request = _requestQueue.Dequeue();
                request.Send();
            }

            private static void EnqueueRequest( Request request )
            {
                _requestQueue.Enqueue( request );
            }


            private void Send()
            {
                if ( _busy )
                {
                    EnqueueRequest( this );
                    return;
                }

                _busy = true;

                _instance.webrequest.Enqueue( _url, _payload, ( code, rawResponse ) =>
                {
                    var response = new BaseResponse
                    {
                        Message = rawResponse,
                        Code = code
                    };

                    if ( response.IsRatelimit )
                    {
                        RateLimitResponse rateLimit = response.GetRateLimit();
                        if ( rateLimit != null )
                        {
                            EnqueueRequest( this );
                            OnRateLimit( rateLimit.RetryAfter );
                        }
                    }
                    else if ( response.IsBad )
                    {
                        _instance.PrintWarning( "Failed! Discord responded with code: {0}. Plugin: {1}\n{2}", code, _plugin != null ? _plugin.Name : "Unknown Plugin", response.Message );
                    }
                    else
                    {
                        try
                        {
                            _response?.Invoke( response );
                        }
                        catch ( Exception ex )
                        {
                            Interface.Oxide.LogException( "[DiscordMessages] Request callback raised an exception!", ex );
                        }
                    }

                    _busy = false;
                    SendNextRequest();
                }, _instance, RequestMethod.POST, _instance._headers );
            }

            private static void OnRateLimit( int retryAfter )
            {
                if ( _rateLimited )
                {
                    return;
                }

                _rateLimited = true;
                _instance.timer.In( retryAfter / 1000, OnRateLimitEnd );
            }

            private static void OnRateLimitEnd()
            {
                _rateLimited = false;
                SendNextRequest();
            }

            public static void Send( string url, FancyMessage message, Plugin plugin = null )
            {
                new Request( url, message, plugin ).Send();
            }

            public static void Send( string url, FancyMessage message, Action<BaseResponse> callback, Plugin plugin = null )
            {
                new Request( url, message, callback, plugin ).Send();
            }

            public static void Dispose()
            {
                _requestQueue = null;
                _rateLimited = false;
                _busy = false;
            }
        }

        private class RateLimitResponse : BaseResponse
        {
            [JsonProperty( "retry_after" )] public int RetryAfter { get; set; }
        }

        private enum CooldownType
        {
            ReportCooldown,
            MessageCooldown
        }

        private enum FeatureType
        {
            Ban,
            Message,
            Report,
            PlayerChat,
            Mute
        }

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            public General GeneralSettings { get; set; } = new General();

            public Ban BanSettings { get; set; } = new Ban();

            public Report ReportSettings { get; set; } = new Report();

            public Message MessageSettings { get; set; } = new Message();
            public Chat ChatSettings { get; set; } = new Chat();
            public Mute MuteSettings { get; set; } = new Mute();

            [JsonIgnore] public Dictionary<FeatureType, WebhookObject> FeatureTypes { get; set; }

            public static Configuration Defaults()
            {
                return new Configuration();
            }

            public class General
            {
                public bool Announce { get; set; } = true;
            }

            public class Ban : EmbedObject { }

            public class Message : EmbedObject
            {
                public bool LogToConsole { get; set; } = true;
                public bool SuggestAlias { get; set; } = false;
                public string Alert { get; set; } = "";
                public int Cooldown { get; set; } = 30;
            }

            public class Report : EmbedObject
            {
                public bool LogToConsole { get; set; } = true;
                public string Alert { get; set; } = "";
                public int Cooldown { get; set; } = 30;
            }

            public class Chat : WebhookObject
            {
                public bool TextToSpeech { get; set; } = false;
            }

            public class Mute : EmbedObject { }

            public class EmbedObject : WebhookObject
            {
                public string Color { get; set; } = "3329330";
            }

            public class WebhookObject
            {
                public bool Enabled { get; set; } = true;
                public string WebhookUrl { get; set; } = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            _config.FeatureTypes = new Dictionary<FeatureType, Configuration.WebhookObject>
            {
                [FeatureType.Ban] = _config.BanSettings,
                [FeatureType.Report] = _config.ReportSettings,
                [FeatureType.Message] = _config.MessageSettings,
                [FeatureType.Mute] = _config.MuteSettings,
                [FeatureType.PlayerChat] = _config.ChatSettings
            };
        }

        protected override void SaveConfig()
        {
            base.SaveConfig();
            Config.WriteObject( _config );
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning( "Generating new config!" );
            _config = Configuration.Defaults();
        }

        private T GetFeatureConfig<T>( FeatureType type ) where T : Configuration.WebhookObject
        {
            return ( T ) _config.FeatureTypes[type];
        }

        #endregion

        #region Variables

        private Data _data;

        [PluginReference]
        private readonly Plugin BetterChatMute, AdminChat;

        private static DiscordMessages _instance;
        private readonly JsonSerializerSettings _jsonSettings = new JsonSerializerSettings();

        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>
        {
            ["Content-Type"] = "application/json"
        };

        #endregion

        #region Hooks / Load

        private void Loaded()
        {
            _instance = this;
            Request.Init();
            _jsonSettings.NullValueHandling = NullValueHandling.Ignore;
            LoadData();
            RegisterPermissions();

            foreach ( var feature in _config.FeatureTypes )
            {
                Configuration.WebhookObject value = feature.Value;
                if ( !value.Enabled || value.WebhookUrl != null && value.WebhookUrl != "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" )
                {
                    continue;
                }

                value.Enabled = false;
                PrintWarning( $"{feature.Key} was enabled however the Webhook is incorrect." );
            }

            RegisterCommands();
            CheckHooks();
        }

        private void CheckHooks()
        {
            if ( !GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat ).Enabled )
            {
#if RUST
                Unsubscribe(nameof(OnPlayerChat));
#else
                Unsubscribe( nameof( OnUserChat ) );
#endif
            }

            if ( !GetFeatureConfig<Configuration.Mute>( FeatureType.Mute ).Enabled )
            {
                Unsubscribe( nameof( OnBetterChatMuted ) );
                Unsubscribe( nameof( OnBetterChatTimeMuted ) );
            }
        }

        private void Unload()
        {
            SaveData();
            Request.Dispose();
            _instance = null;
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void RegisterCommands()
        {
            if ( GetFeatureConfig<Configuration.Report>( FeatureType.Report ).Enabled )
            {
                AddCovalenceCommand( "report", "ReportCommand", ReportPermission );
                AddCovalenceCommand( new[]
                {
                    "reportadmin",
                    "ra"
                }, "ReportAdminCommand", AdminPermission );
            }

            if ( GetFeatureConfig<Configuration.Ban>( FeatureType.Ban ).Enabled )
            {
                AddCovalenceCommand( "ban", "BanCommand", BanPermission );
            }

            var messageConfig = GetFeatureConfig<Configuration.Message>( FeatureType.Message );
            if ( messageConfig.Enabled )
            {
                AddCovalenceCommand( messageConfig.SuggestAlias
                    ? new[]
                    {
                        "message",
                        "suggest"
                    }
                    : new[]
                    {
                        "message"
                    }, "MessageCommand", MessagePermission );
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages( new Dictionary<string, string>
            {
                ["ReportSyntax"] = "Syntax error. Please use /report \"name/id\" \"reason\"",
                ["BanSyntax"] = "Syntax error. Please use /ban \"name/id\" \"reason\"",
                ["MessageSyntax"] = "Syntax error. Please use /message \"your message\"",
                ["Multiple"] = "Multiple players found:\n{0}",
                ["BanMessage"] = "{0} was banned for {1}",
                ["ReportSent"] = "Your report has been sent!",
                ["MessageSent"] = "Your message has been sent!",
                ["NotFound"] = "Unable to find player {0}",
                ["NoReports"] = "{0} has not been reported yet!",
                ["ReportDisallowed"] = "You have been blacklisted from reporting players.",
                ["ReportAccessChanged"] = "Report feature for {0} is now {1}",
                ["ReportReset"] = "You have reset the report count for {0}",
                ["Cooldown"] = "You must wait {0} seconds to use this command again.",
                ["AlreadyBanned"] = "{0} is already banned!",
                ["NoPermission"] = "You do not have permision for this command!",
                ["Disabled"] = "This feature is currently disabled.",
                ["Failed"] = "Your report failed to send, contact the server owner.",
                ["ToSelf"] = "You cannot perform this action on yourself.",
                ["ReportTooShort"] = "Your report was too short! Please be more descriptive.",
                ["PlayerChatFormatNew"] = "[{2}] **{0}:** {1}",
                ["BanPrefix"] = "Banned: {0}",
                ["Embed_ReportPlayer"] = "Reporter",
                ["Embed_ReportTarget"] = "Reported",
                ["Embed_ReportCount"] = "Times Reported",
                ["Embed_ReportReason"] = "Reason",
                ["Embed_Online"] = "Online",
                ["Embed_Offline"] = "Offline",
                ["Embed_ReportStatus"] = "Status",
                ["Embed_ReportTitle"] = "Player Report",
                ["Embed_MuteTitle"] = "Player Muted",
                ["Embed_MuteTarget"] = "Player",
                ["Embed_MutePlayer"] = "Muted by",
                ["Embed_BanPlayer"] = "Banned by",
                ["Embed_BanTarget"] = "Player",
                ["Embed_BanReason"] = "Reason",
                ["Embed_BanTitle"] = "Player Ban",
                ["Embed_MessageTitle"] = "Player Message",
                ["Embed_MessagePlayer"] = "Player",
                ["Embed_MessageMessage"] = "Message",
                ["Embed_MuteTime"] = "Time",
                ["Embed_MuteReason"] = "Reason"
            }, this );
        }

        #endregion

        #region Permissions

        private const string BanPermission = "discordmessages.ban";
        private const string ReportPermission = "discordmessages.report";
        private const string MessagePermission = "discordmessages.message";
        private const string AdminPermission = "discordmessages.admin";

        private void RegisterPermissions()
        {
            permission.RegisterPermission( BanPermission, this );
            permission.RegisterPermission( ReportPermission, this );
            permission.RegisterPermission( MessagePermission, this );
            permission.RegisterPermission( AdminPermission, this );
        }

        #endregion

        #region API

        private void API_SendFancyMessage( string webhookUrl, string content, string embedJsonString, Plugin plugin = null )
        {
            EmbedBuilder embed;
            try
            {
                embed = JsonConvert.DeserializeObject<EmbedBuilder>( embedJsonString );
            }
            catch ( JsonSerializationException )
            {
                PrintWarning( "Failed to deserialize json string: {0}", embedJsonString );
                return;
            }

            FancyMessage payload = new FancyMessage().SetEmbed( embed ).WithContent( content );
            Request.Send( webhookUrl, payload, plugin );
        }

        private void API_SendFancyMessage( string webhookUrl, string embedName, int embedColor, string json, string content = null, Plugin plugin = null )
        {
            EmbedBuilder builder = new EmbedBuilder().WithTitle( embedName ).SetColor( embedColor );


            EmbedBuilder.Field[] fields;
            try
            {
                fields = JsonConvert.DeserializeObject<EmbedBuilder.Field[]>( json );
            }
            catch ( JsonSerializationException )
            {
                PrintWarning( "Failed to deserialize json string: {0}", json );
                return;
            }

            builder.AddFields( fields );

            FancyMessage payload = new FancyMessage().SetEmbed( builder ).WithContent( content );
            Request.Send( webhookUrl, payload, plugin );
        }

        private void API_SendFancyMessage( string webhookUrl, string embedName, string json, string content = null, int embedColor = 3329330, Plugin plugin = null )
        {
            API_SendFancyMessage( webhookUrl, embedName, embedColor, json, content, plugin );
        }

        private void API_SendTextMessage( string webhookUrl, string content, bool tts = false, Plugin plugin = null )
        {
            Request.Send( webhookUrl, new FancyMessage().AsTTS( tts ).WithContent( content ), plugin );
        }

        #endregion

        #region Report

        private void ReportAdminCommand( IPlayer player, string command, string[] args )
        {
            IPlayer target = GetPlayer( args[1], player, false );
            if ( target == null )
            {
                player.Reply( GetLang( "NotFound", player.Id, args[1] ) );
                return;
            }

            PlayerData data;

            switch ( args[0] )
            {
                case "enable":

                    if ( _data.Players.TryGetValue( target.Id, out data ) )
                    {
                        data.ReportDisabled = false;
                    }

                    player.Reply( GetLang( "ReportAccessChanged", player.Id, target.Name, "enabled" ) );
                    return;
                case "disable":
                    if ( !_data.Players.TryGetValue( target.Id, out data ) )
                    {
                        _data.Players.Add( target.Id, data = new PlayerData() );
                    }

                    data.ReportDisabled = true;

                    player.Reply( GetLang( "ReportAccessChanged", player.Id, target.Name, "disabled" ) );
                    return;
                case "reset":
                    if ( _data.Players.TryGetValue( target.Id, out data ) && data.Reports > 0 )
                    {
                        data.Reports = 0;
                        player.Reply( GetLang( "ReportReset", player.Id, target.Name ) );
                        return;
                    }

                    player.Reply( GetLang( "NoReports", player.Id, target.Name ) );
                    return;
            }
        }

        private void ReportCommand( IPlayer player, string command, string[] args )
        {
            if ( ( player.Name == "Server Console" ) | !player.IsConnected )
            {
                return;
            }

            PlayerData data;
            if ( !_data.Players.TryGetValue( player.Id, out data ) )
            {
                _data.Players.Add( player.Id, data = new PlayerData() );
            }
            else if ( data.ReportDisabled )
            {
                SendMessage( player, GetLang( "ReportDisallowed", player.Id ) );
                return;
            }

            if ( args.Length < 2 )
            {
                SendMessage( player, GetLang( "ReportSyntax", player.Id ) );
                return;
            }

            var reportConfig = GetFeatureConfig<Configuration.Report>( FeatureType.Report );

            int secondsRemaining;
            if ( OnCooldown( player, CooldownType.ReportCooldown, out secondsRemaining ) )
            {
                SendMessage( player, GetLang( "Cooldown", player.Id, secondsRemaining.ToString() ) );
                return;
            }

            IPlayer target = GetPlayer( args[0], player, true );
            if ( target == null )
            {
                return;
            }

            var reason = args.Skip( 1 ).ToList();
            if ( player.Id == target.Id )
            {
                SendMessage( player, GetLang( "ToSelf", player.Id ) );
                return;
            }

            string[] targetName = target.Name.Split( ' ' );
            if ( targetName.Length > 1 )
            {
                for ( var x = 0; x < targetName.Length - 1; x++ )
                {
                    if ( reason[x].Equals( targetName[x + 1] ) )
                    {
                        reason.RemoveAt( x );
                    }
                    else
                    {
                        break;
                    }
                }
            }

            if ( reason.Count < 1 )
            {
                SendMessage( player, GetLang( "ReportTooShort", player.Id ) );
                return;
            }

            string cleanReason = string.Join( " ", reason.ToArray() );

            PlayerData targetData;
            if ( !_data.Players.TryGetValue( target.Id, out targetData ) )
            {
                _data.Players.Add( target.Id, targetData = new PlayerData() );
            }

            targetData.Reports++;

            string status = target.IsConnected ? lang.GetMessage( "Online", null ) : lang.GetMessage( "Offline", null );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_ReportTitle" ) ).SetColor( reportConfig.Color ).AddInlineField( GetLang( "Embed_ReportTarget" ), $"[{target.Name}](https://steamcommunity.com/profiles/{target.Id})" ).AddInlineField( GetLang( "Embed_ReportPlayer" ), $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" ).AddInlineField( GetLang( "Embed_ReportStatus" ), status ).AddField( GetLang( "Embed_ReportReason" ), cleanReason ).AddInlineField( GetLang( "Embed_ReportCount" ), targetData.Reports.ToString() );
            FancyMessage payload = new FancyMessage().WithContent( reportConfig.Alert ).SetEmbed( builder );
            Request.Send( reportConfig.WebhookUrl, payload, response =>
            {
                if ( response.IsOk )
                {
                    SendMessage( player, GetLang( "ReportSent", player.Id ) );
                    data.ReportCooldown = DateTime.UtcNow;

                    if ( reportConfig.LogToConsole )
                    {
                        Puts( $"REPORT ({player.Name}/{player.Id}) -> ({target.Name}/{target.Id}): {reason}" );
                    }
                }
                else if ( response.IsBad )
                {
                    SendMessage( player, GetLang( "ReportNotSent", player.Id ) );
                }
            }, this );
        }

        #endregion

        #region Mutes

        private static string FormatTime( TimeSpan time )
        {
            return $"{( time.Days == 0 ? string.Empty : $"{time.Days} day(s)" )}{( time.Days != 0 && time.Hours != 0 ? ", " : string.Empty )}{( time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)" )}{( time.Hours != 0 && time.Minutes != 0 ? ", " : string.Empty )}{( time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)" )}{( time.Minutes != 0 && time.Seconds != 0 ? ", " : string.Empty )}{( time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)" )}";
        }

        private void OnBetterChatTimeMuted( IPlayer target, IPlayer player, TimeSpan expireDate, string reason )
        {
            SendMute( target, player, expireDate, true, reason );
        }

        private void OnBetterChatMuted( IPlayer target, IPlayer player, string reason )
        {
            SendMute( target, player, TimeSpan.Zero, false, reason );
        }

        private void SendMute( IPlayer target, IPlayer player, TimeSpan expireDate, bool timed, string reason )
        {
            if ( target == null || player == null )
            {
                return;
            }

            var muteConfig = GetFeatureConfig<Configuration.Mute>( FeatureType.Mute );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_MuteTitle" ) ).AddInlineField( GetLang( "Embed_MuteTarget" ), $"[{target.Name}](https://steamcommunity.com/profiles/{target.Id})" ).AddInlineField( GetLang( "Embed_MutePlayer" ), !player.Id.Equals( "server_console" ) ? $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" : player.Name ).AddInlineField( GetLang( "Embed_MuteTime" ), timed ? FormatTime( expireDate ) : "Permanent" ).SetColor( muteConfig.Color );
            if ( !string.IsNullOrEmpty( reason ) )
            {
                builder.AddField( GetLang( "Embed_MuteReason" ), reason );
            }

            FancyMessage message = new FancyMessage().SetEmbed( builder );
            Request.Send( muteConfig.WebhookUrl, message, this );
        }

        #endregion

        #region Bans

        private bool _banFromCommand;

        private void BanCommand( IPlayer player, string command, string[] args )
        {
            if ( args.Length == 0 )
            {
                SendMessage( player, GetLang( "BanSyntax", player.Id ) );
                return;
            }

            string reason = args.Length == 1 ? "Banned" : string.Join( " ", args.Skip( 1 ).ToArray() );
            IPlayer target = GetPlayer( args[0], player, false );
            if ( target != null )
            {
                if ( target.Id == player.Id )
                {
                    SendMessage( player, GetLang( "ToSelf", player.Id ) );
                    return;
                }

                ExecuteBan( target, player, reason );
            }
            else
            {
                player.Reply( GetLang( "NotFound", player.Id, args[0] ) );
            }
        }

        private void ExecuteBan( IPlayer target, IPlayer player, string reason )
        {
            if ( target.IsBanned )
            {
                SendMessage( player, GetLang( "AlreadyBanned", player.Id, target.Name ) );
                return;
            }

            _banFromCommand = true;
            OnUserBanned( target.Name, target.Id, target.Address, reason, -1, player );
            target.Ban( GetLang( "BanPrefix", target.Id ) + reason );
            if ( _config.GeneralSettings.Announce )
            {
                server.Broadcast( GetLang( "BanMessage", null, target.Name, reason ) );
            }
        }

        private void OnUserBanned( string name, string bannedId, string address, string reason, long expiry, IPlayer source = null )
        {
            var banConfig = GetFeatureConfig<Configuration.Ban>( FeatureType.Ban );
            if ( !banConfig.Enabled )
            {
                return;
            }

            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_BanTitle" ) ).AddInlineField( GetLang( "Embed_BanTarget" ), $"[{name}](https://steamcommunity.com/profiles/{bannedId})" );
            if ( source == null )
            {
                if ( _banFromCommand )
                {
                    return;
                }
            }
            else
            {
                builder.AddInlineField( GetLang( "Embed_BanPlayer" ), !source.Id.Equals( "server_console" ) ? $"[{source.Name}](https://steamcommunity.com/profiles/{source.Id})" : source.Name );
            }

            builder.AddField( GetLang( "Embed_BanReason" ), reason );

            if ( expiry > 0 )
            {
                builder.AddField( "Expiry", DateTimeOffset.FromUnixTimeSeconds( expiry ).LocalDateTime.ToString( CultureInfo.CurrentCulture ) );
            }

            builder.SetColor( banConfig.Color );
            FancyMessage message = new FancyMessage().SetEmbed( builder );
            Request.Send( banConfig.WebhookUrl, message, this );
            _banFromCommand = false;
        }

        #endregion

        #region Helpers

        private string GetLang( string key, string id = null, params object[] args )
        {
            return args.Length > 0 ? string.Format( lang.GetMessage( key, this, id ), args ) : lang.GetMessage( key, this, id );
        }

        private void SendMessage( IPlayer player, string message )
        {
            player.Reply( message );
        }

        private bool OnCooldown( IPlayer player, CooldownType type, out int secondsRemaining )
        {
            secondsRemaining = 0;
            PlayerData data;
            if ( !_data.Players.TryGetValue( player.Id, out data ) )
            {
                return false;
            }

            switch ( type )
            {
                case CooldownType.MessageCooldown:
                {
                    if ( !data.MessageCooldown.HasValue )
                    {
                        return false;
                    }

                    secondsRemaining = (int)(DateTime.UtcNow - data.MessageCooldown.Value.AddSeconds( GetFeatureConfig<Configuration.Message>( FeatureType.Message ).Cooldown )).TotalSeconds;
                    return secondsRemaining > 0;

                }
                case CooldownType.ReportCooldown:
                {
                    if ( !data.ReportCooldown.HasValue )
                    {
                        return false;
                    }

                    secondsRemaining = (int)(DateTime.UtcNow - data.ReportCooldown.Value.AddSeconds( GetFeatureConfig<Configuration.Report>( FeatureType.Report ).Cooldown )).TotalSeconds;
                    return secondsRemaining > 0;

                }
                default:
                    return false;
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject( Name, _data );
        }

        private void LoadData()
        {
            _data = Interface.Oxide.DataFileSystem.ReadObject<Data>( Name );
        }

        private IPlayer GetPlayer( string nameOrId, IPlayer player, bool sendError )
        {
            if ( nameOrId.IsSteamId() )
            {
                IPlayer result = players.All.ToList().Find( p => p.Id == nameOrId );

                return result;
            }

            var foundPlayers = new List<IPlayer>();

            foreach ( IPlayer current in players.Connected )
            {
                if ( string.Equals( current.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase ) )
                {
                    return current;
                }

                if ( current.Name.ToLower().Contains( nameOrId.ToLower() ) )
                {
                    foundPlayers.Add( current );
                }
            }

            if ( foundPlayers.Count == 0 )
            {
                foreach ( IPlayer all in players.All )
                {
                    if ( string.Equals( all.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase ) )
                    {
                        return all;
                    }

                    if ( all.Name.ToLower().Contains( nameOrId.ToLower() ) )
                    {
                        foundPlayers.Add( all );
                    }
                }
            }

            switch ( foundPlayers.Count )
            {
                case 0:
                    if ( !nameOrId.IsSteamId() )
                    {
                        if ( sendError )
                        {
                            SendMessage( player, GetLang( "NotFound", player.Id, nameOrId ) );
                        }
                    }

                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = ( from current in foundPlayers
                        select current.Name ).ToArray();
                    SendMessage( player, GetLang( "Multiple", player.Id, string.Join( ", ", names ) ) );
                    break;
            }

            return null;
        }

        #endregion
    }
}

// --- End of file: DiscordMessages.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlockSystem.cs ---
// --- Original Local Path: BlockSystem.cs ---

using System.Linq;
using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("BlockSystem", "Chibubrik", "1.0.0")]
    class BlockSystem : RustPlugin
    {
        #region Вар
        [PluginReference] Plugin ImageLibrary;
        #endregion

        #region Предметы
        Dictionary<int, List<string>> settings = new Dictionary<int, List<string>>() 
        {
            [7200] = new List<string>() 
            {
                "shotgun.double",
                "pistol.revolver"
            },
            [14400] = new List<string>() 
            {
                "pistol.semiauto",
                "pistol.python",
                "pistol.m92"
            },
            [21600] = new List<string>() 
            {
                "shotgun.pump",
                "smg.2",
                "grenade.f1",
                "rifle.semiauto",
                "coffeecan.helmet",
                "roadsign.jacket",
                "roadsign.kilt"
            },
            [43200] = new List<string>() 
            {
                "smg.thompson",
                "smg.mp5",
                "shotgun.spas12",
                "grenade.beancan"
            },
            [64800] = new List<string>() 
            {
                "rifle.ak",
                "rifle.lr300",
                "rifle.bolt",
                "explosive.satchel",
                "metal.facemask",
                "metal.plate.torso",
                "rifle.l96",
                "rifle.m39"
            },
            [86400] = new List<string>() 
            {
                "lmg.m249",
                "ammo.rifle.explosive",
                "explosive.timed",
                "rocket.launcher",
                "heavy.plate.helmet",
                "heavy.plate.jacket",
                "heavy.plate.pants"
            },
        };
        #endregion

        #region Хуки
        void OnServerInitialized()
        {
            foreach (var check in settings.SelectMany(p => p.Value))
            {
                ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{check}.png", check);
            }
        }

        private object CanWearItem(PlayerInventory inventory, Item item) {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?) null;
            
            if (isBlocked == false) {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                    return null;

                SendReply(player, "Предмет " + item.info.shortname + " временно заблокирован, подождите " + FormatShortTime(TimeSpan.FromSeconds(IsBlocked(item.info))));
            }

            return isBlocked;
        }

        private object CanEquipItem(PlayerInventory inventory, Item item) {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null)
                return null;
            
            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?) null;
            if (isBlocked == false) {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                    return null;

                    SendReply(player, "Предмет " + item.info.shortname + " временно заблокирован, подождите " + FormatShortTime(TimeSpan.FromSeconds(IsBlocked(item.info))));
            }

            return isBlocked;
        }

        private object CanMoveItem(Item item, PlayerInventory inventory, uint targetContainer) {
            if (inventory == null || item == null)
                return null;

            BasePlayer player = inventory.GetComponent<BasePlayer>();
            if (player == null)
                return null;

            ItemContainer container = inventory.FindContainer(targetContainer);
            if (container == null || container.entityOwner == null)
                return null;

            if (container.entityOwner is AutoTurret) {
                var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?) null;
                if (isBlocked == false) {
                    SendReply(player, "Предмет " + item.info.shortname + " временно заблокирован, подождите " + FormatShortTime(TimeSpan.FromSeconds(IsBlocked(item.info))));
                    return true;
                }
            }

            return null;
        }

        private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {
            if (player is NPCPlayer)
                return null;
            
            if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                return null;

            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?) null;
            if (isBlocked == false) {
                List<Item> list = player.inventory.FindItemIDs(projectile.primaryMagazine.ammoType.itemid).ToList<Item>();
                if (list.Count == 0) {
                    List<Item> list2 = new List<Item>();
                    player.inventory.FindAmmo(list2, projectile.primaryMagazine.definition.ammoTypes);
                    if (list2.Count > 0) {
                        isBlocked = IsBlocked(list2[0].info) > 0 ? false : (bool?) null;
                    }
                }

                if (isBlocked == false) {
                    SendReply(player, $"Вы <color=#81B67A>не можете</color> использовать этот тип боеприпасов!");
                }

                return isBlocked;
            }

            return null;
        }

        private object OnReloadMagazine(BasePlayer player, BaseProjectile projectile) {
            if (player is NPCPlayer)
                return null;

            NextTick(() => {
                var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?) null;
                if (isBlocked == false) {
                    player.GiveItem(ItemManager.CreateByItemID(projectile.primaryMagazine.ammoType.itemid, projectile.primaryMagazine.contents, 0UL), BaseEntity.GiveItemReason.Generic);
                    projectile.primaryMagazine.contents = 0;
                    projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                    projectile.SendNetworkUpdate();
                    player.SendNetworkUpdate();

                    SendReply(player, $"<color=#81B67A>Хорошая</color> попытка, правда ваше оружие теперь сломано!");
                }
            });

            return null;
        }

        private object CanAcceptItem(ItemContainer container, Item item) {
            if (container == null || item == null || container.entityOwner == null)
                return null;

            if (container.entityOwner is AutoTurret) {
                BasePlayer player = item.GetOwnerPlayer();
                if (player == null)
                    return null;

                var isBlocked = IsBlocked(item.info.shortname) > 0 ? false : (bool?) null;
                if (isBlocked == false) {
                    return ItemContainer.CanAcceptResult.CannotAcceptRightNow;
                }
            }

            return null;
        }
        #endregion

        #region Методы
        private double IsBlocked(ItemDefinition itemDefinition) => IsBlocked(itemDefinition.shortname);
        private double IsBlocked(string shortname) 
        {
            if (!settings.SelectMany(p => p.Value).Contains(shortname))
                return 0;
            var blockTime = settings.FirstOrDefault(p => p.Value.Contains(shortname)).Key;
            var lefTime = (UnBlockTime(blockTime)) - CurrentTime();
            return lefTime > 0 ? lefTime : 0;
        }

        private double UnBlockTime(int amount) => SaveRestore.SaveCreatedTime.ToUniversalTime().Subtract(epoch).TotalSeconds + amount;
        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }

        public static string FormatShortTime(TimeSpan time) 
        {
            string result = string.Empty;
            result = $"{time.Hours.ToString("00")}:";
            result += $"{time.Minutes.ToString("00")}";
            return result;
        }
        #endregion

        #region Команда
        [ChatCommand("block")]
        void ChatBlock(BasePlayer player) => BlockUI(player);
        #endregion

        #region Интерфейс
        void BlockUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Block");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", "Block");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.9", Close = "Block" },
                Text = { Text = "" }
            }, "Block");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.513 0.73", AnchorMax = "0.515 0.76", OffsetMax = "0 0" },
                Image = { Color = "0.46 0.73 0.43 1" }
            }, "Block");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.42 0.73", AnchorMax = "0.515 0.733", OffsetMax = "0 0" },
                Image = { Color = "0.46 0.73 0.43 1" }
            }, "Block");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.42 0.3", AnchorMax = "0.422 0.73", OffsetMax = "0 0" },
                Image = { Color = "0.46 0.73 0.43 1" }
            }, "Block");
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.42 0.3", AnchorMax = "0.515 0.304", OffsetMax = "0 0" },
                Image = { Color = "0.46 0.73 0.43 1" }
            }, "Block");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.513 0.27", AnchorMax = "0.515 0.304", OffsetMax = "0 0" },
                Image = { Color = "0.46 0.73 0.43 1" }
            }, "Block");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.43 0.27", AnchorMax = "0.59 0.274", OffsetMax = "0 0" },
                Image = { Color = "0.46 0.73 0.43 1" }
            }, "Block");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.07 0.21", AnchorMax = "0.96 0.3", OffsetMax = "0 0" },
                Text = { Text = $"Magix rust", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, "Block");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.04 0.76", AnchorMax = "0.96 0.83", OffsetMax = "0 0" },
                Text = { Text = $"<b><size=20>БЛОКИРОВКА ПРЕДМЕТОВ</size></b>\nЗдесь вы можете узнать когда будет доступен тот, или иной предмет.", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-regular.ttf" }
            }, "Block");

            var color1 = IsBlocked(settings.ElementAt(0).Value.ElementAt(0)) > 0 ? "0.80 0.34 0.34 1" : "0.46 0.73 0.43 1";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.395 0.691", AnchorMax = "0.475 0.694", OffsetMax = "0 0" },
                Image = { Color = color1 }
            }, "Block");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.345 0.387", AnchorMax = "0.4 1", OffsetMax = "0 0" },
                Text = { Text = $"{TimeSpan.FromSeconds(settings.ElementAt(0).Key).TotalHours} ЧАСА", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, "Block");

            var color2 = IsBlocked(settings.ElementAt(1).Value.ElementAt(0)) > 0 ? "0.80 0.34 0.34 1" : "0.46 0.73 0.43 1";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.375 0.622", AnchorMax = "0.475 0.626", OffsetMax = "0 0" },
                Image = { Color = color2 }
            }, "Block");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.305 0.613", AnchorMax = "0.4 1", OffsetMax = "0 0" },
                Text = { Text = $"{TimeSpan.FromSeconds(settings.ElementAt(1).Key).TotalHours} ЧАСА", Color = "1 1 1 0.5", Align = TextAnchor.LowerCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, "Block");

            var color3 = IsBlocked(settings.ElementAt(2).Value.ElementAt(0)) > 0 ? "0.80 0.34 0.34 1" : "0.46 0.73 0.43 1";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.355 0.552", AnchorMax = "0.475 0.556", OffsetMax = "0 0" },
                Image = { Color = color3 }
            }, "Block");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.26 0.543", AnchorMax = "0.4 1", OffsetMax = "0 0" },
                Text = { Text = $"{TimeSpan.FromSeconds(settings.ElementAt(2).Key).TotalHours} ЧАСОВ", Color = "1 1 1 0.5", Align = TextAnchor.LowerCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, "Block");
 
            var color4 = IsBlocked(settings.ElementAt(3).Value.ElementAt(0)) > 0 ? "0.80 0.34 0.34 1" : "0.46 0.73 0.43 1";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.335 0.481", AnchorMax = "0.475 0.484", OffsetMax = "0 0" },
                Image = { Color = color4 }
            }, "Block");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.215 0.47", AnchorMax = "0.4 1", OffsetMax = "0 0" },
                Text = { Text = $"{TimeSpan.FromSeconds(settings.ElementAt(3).Key).TotalHours} ЧАСОВ", Color = "1 1 1 0.5", Align = TextAnchor.LowerCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, "Block");

            var color5 = IsBlocked(settings.ElementAt(4).Value.ElementAt(0)) > 0 ? "0.80 0.34 0.34 1" : "0.46 0.73 0.43 1";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.315 0.408", AnchorMax = "0.475 0.412", OffsetMax = "0 0" },
                Image = { Color = color5 }
            }, "Block");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.175 0.4", AnchorMax = "0.4 1", OffsetMax = "0 0" },
                Text = { Text = $"{TimeSpan.FromSeconds(settings.ElementAt(4).Key).TotalHours} ЧАСОВ", Color = "1 1 1 0.5", Align = TextAnchor.LowerCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, "Block");

            var color6 = IsBlocked(settings.ElementAt(5).Value.ElementAt(0)) > 0 ? "0.80 0.34 0.34 1" : "0.46 0.73 0.43 1";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.295 0.341", AnchorMax = "0.475 0.345", OffsetMax = "0 0" },
                Image = { Color = color6 }
            }, "Block");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.14 0.332", AnchorMax = "0.4 1", OffsetMax = "0 0" },
                Text = { Text = $"{TimeSpan.FromSeconds(settings.ElementAt(5).Key).TotalHours} ЧАСА", Color = "1 1 1 0.5", Align = TextAnchor.LowerCenter, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, "Block");

            float width = 0.9f, height = 0.07f, startxBox = 0.394f, startyBox = 0.727f - height, xmin = startxBox, ymin = startyBox;
            for (int z = 0; z < settings.Count(); z++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = xmin + " " + ymin, AnchorMax = (xmin + width) + " " + (ymin + height * 1), OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Image = { Color = "0 0 0 0" }
                }, "Block", "Items");
                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }

                float width1 = 0.045f, height1 = 1f, startxBox1 = 0.09f, startyBox1 = 1f - height1, xmin1 = startxBox1, ymin1 = startyBox1;
                var item = settings.ElementAt(z).Value;
                foreach (var check in item)
                {
                    var color = IsBlocked(check) > 0 ? "0.80 0.34 0.34 1" : "0.46 0.73 0.43 1";
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = xmin1 + " " + ymin1, AnchorMax = (xmin1 + width1) + " " + (ymin1 + height1 * 1), OffsetMin = "2 0", OffsetMax = "-2 0" },
                        Image = { Color = color }
                    }, "Items", "Settings");
                    xmin1 += width1;

                    container.Add(new CuiElement
                    {
                        Parent = "Settings",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check) },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "6 6", OffsetMax = "-6 -6" }
                        }
                    });
                }
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion 
    }
}

// --- End of file: BlockSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ImageLibrary.cs ---
// --- Original Local Path: ImageLibrary.cs ---

using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core;
using System.IO;
using System.Collections;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("ImageLibrary", "Absolut", "1.2.1", ResourceId = 2193)]

    class ImageLibrary : RustPlugin
    {
        #region Fields

        ImageData imageData;
        private DynamicConfigFile ImageLibraryData;

        public class ImageData
        {
            public Dictionary<string, Dictionary<ulong, uint>> Images = new Dictionary<string, Dictionary<ulong, uint>>();
        }

        static GameObject webObject;
        static Images images;

        #endregion

        #region Hooks   

        void Loaded()
        {
            ImageLibraryData = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary_Data");
        }

        void Unload()
        {
            SaveData();
        }

        void OnServerInitialized()
        {
            webObject = new GameObject("WebObject");
            images = webObject.AddComponent<Images>();
            images.SetDataDir(this);
            LoadData();
        }

        #endregion

        #region External Calls
        [HookMethod("GetImage")]
        public string GetImage(string shortname, ulong skin = 0)
        {
            if (!imageData.Images.ContainsKey(shortname)) return imageData.Images["NONE"][0].ToString();
            if (!imageData.Images[shortname].ContainsKey(skin))
                return imageData.Images["NONE"][0].ToString();
            return imageData.Images[shortname][skin].ToString();
        }

        [HookMethod("HasImage")]
        public bool HasImage(string shortname, ulong skin = 0)
        {
            if (!imageData.Images.ContainsKey(shortname)) return false;
            if (!imageData.Images[shortname].ContainsKey(skin))
                return false;
            return true;
        }

        [HookMethod("AddImage")]
        public bool AddImage(string url, string name, ulong skin = 0)
        {
            if (!HasImage(name, skin))
            {
                images.Add(url, name, skin);
                return true;
            }
            return false;
        }
        #endregion

        #region Images
        class QueueImages
        {
            public string url;
            public string name;
            public ulong skin;
            public QueueImages(string ur, string nm, ulong sk)
            {
                url = ur;
                name = nm;
                skin = sk;
            }
        }

        class Images : MonoBehaviour
        {
            ImageLibrary filehandler;
            const ulong MaxActiveLoads = 3;
            static readonly List<QueueImages> QueueList = new List<QueueImages>();
            static byte activeLoads;
            private MemoryStream stream = new MemoryStream();

            public void SetDataDir(ImageLibrary fc) => filehandler = fc;
            public void Add(string url, string name, ulong skin)
            {
                QueueList.Add(new QueueImages(url, name, skin));
                if (activeLoads < MaxActiveLoads) Next();
            }

            void Next()
            {
                activeLoads++;
                var qi = QueueList[0];
                QueueList.RemoveAt(0);
                var www = new WWW(qi.url);
                StartCoroutine(WaitForRequest(www, qi));
            }

            private void ClearStream()
            {
                stream.Position = 0;
                stream.SetLength(0);
            }

            IEnumerator WaitForRequest(WWW www, QueueImages info)
            {
                yield return www;

                if (www.error == null)
                {
                    if (!filehandler.imageData.Images.ContainsKey(info.name))
                        filehandler.imageData.Images.Add(info.name, new Dictionary<ulong, uint>());
                    if (!filehandler.imageData.Images[info.name].ContainsKey(info.skin))
                    {
                        ClearStream();
                        stream.Write(www.bytes, 0, www.bytes.Length);
                        uint textureID = FileStorage.server.Store(stream, FileStorage.Type.png, uint.MaxValue);
                        ClearStream();
                        filehandler.imageData.Images[info.name].Add(info.skin, textureID);
                    }
                }
                activeLoads--;
                if (QueueList.Count > 0) Next();
                else filehandler.SaveData();
            }
        }

        [ConsoleCommand("RefreshAllImages")]
        private void cmdRefreshAllImages(ConsoleSystem.Arg arg)
        {
                RefreshAllImages();
        }

        private void RefreshAllImages()
        {
            imageData.Images.Clear();
            images.Add("http://www.hngu.net/Images/College_Logo/28/b894b451_c203_4c08_922c_ebc95077c157.png", "NONE", 0);
            foreach (var entry in ItemImages)
                foreach (var item in entry.Value)
                    images.Add(item.Value, entry.Key, item.Key);
            timer.Once(10, () =>
            {
                SaveData();
            });
        }

        private void CheckNewImages()
        {
            foreach (var entry in ItemImages)
                foreach (var item in entry.Value)
                    if (!imageData.Images[entry.Key].ContainsKey(item.Key))
                        images.Add(item.Value, entry.Key, item.Key);
            timer.Once(10, () =>
            {
                SaveData();
            });
        }

        private Dictionary<string, Dictionary<ulong, string>> ItemImages = new Dictionary<string, Dictionary<ulong, string>>
        {
                { "tshirt", new Dictionary<ulong, string>
                {
                {0, "http://imgur.com/SAD8dWX.png" },
                {10130, "http://imgur.com/tqwRCKw.png"},
                {10033, "http://imgur.com/UjGqhac.png" },
                {10003, "http://imgur.com/Q2w1w74.png"},
                {14177, "http://imgur.com/wuj2TnQ.png" },
                {10056, "http://imgur.com/2lfKuYz.png"},
                {14181, "http://imgur.com/MgRHg0D.png" },
                {10024, "http://imgur.com/C0IH5q0.png"},
                {10035, "http://imgur.com/Vh9yCpv.png" },
                {10046, "http://imgur.com/r4EZ4X5.png"},
                {10038, "http://imgur.com/tSWGLIo.png" },
                {101, "http://imgur.com/iY3zqU3.png" },
                {10025, "http://imgur.com/6s4nmz6.png" },
                {10002, "http://imgur.com/2CwEo5f.png"},
                {10134, "http://imgur.com/bgAgtiN.png" },
                {10131, "http://imgur.com/QBDtZZt.png"},
                {10041, "http://imgur.com/ZWIFX0J.png" },
                {10053, "http://imgur.com/JzPIjvu.png"},
                {10039, "http://imgur.com/2e6RlNV.png" },
                {584379, "http://imgur.com/QGo7psZ.png"},
                {10043, "http://imgur.com/4oz5N6s.png" },
                }
            },
            {"pants", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/iiFJAso.png" },
                {10001, "http://imgur.com/ntwPM8B.png"},
                {10049, "http://imgur.com/UroE7FB.png" },
                {10019, "http://imgur.com/e4lMi7b.png"},
                {10078, "http://imgur.com/GtYg84o.png" },
                {10048, "http://imgur.com/NFpjEVG.png"},
                {10021, "http://imgur.com/zVQSCOM.png" },
                {10020, "http://imgur.com/jrILSlp.png" },
            }
            },
            {"shoes.boots", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/b8HJ3TJ.png" },
                {10080, "http://imgur.com/7LSy7LN.png"},
                {10023, "http://imgur.com/JWk9YKb.png" },
                {10088, "http://imgur.com/RRFrv7d.png"},
                {10034, "http://imgur.com/wkYqkDd.png" },
                {10044, "http://imgur.com/2b01wU2.png"},
                {10022, "http://imgur.com/CCqzvRr.png" },
            }
            },
             {"tshirt.long", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/KPxtIQI.png" },
                {10047, "http://imgur.com/S8H3tcI.png"},
                {10004, "http://imgur.com/e28NFqe.png" },
                {10089, "http://imgur.com/fg1o3bI.png"},
                {10106, "http://imgur.com/QCTgWL8.png" },
                {10050, "http://imgur.com/d7VWfRi.png"},
                {10032, "http://imgur.com/mWO2yFG.png" },
                {10005, "http://imgur.com/9x9r5nv.png"},
                {10125, "http://imgur.com/JF2G3Bo.png" },
                {10118, "http://imgur.com/MxfnH0L.png"},
                {10051, "http://imgur.com/PNQbN6q.png" },
                {10006, "http://imgur.com/mq1o74X.png"},
                {10036, "http://imgur.com/kHA82wu.png" },
                {10042, "http://imgur.com/gVSKubo.png" },
                {10007, "http://imgur.com/Nddd4yq.png"},
            }
            },
             {"mask.bandana", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/PImuCst.png" },
                {10061, "http://imgur.com/6z7XFqf.png"},
                {10060, "http://imgur.com/RvaahST.png" },
                {10067, "http://imgur.com/AXu92sd.png"},
                {10104, "http://imgur.com/eb2WQMJ.png" },
                {10066, "http://imgur.com/e2UwJ5L.png"},
                {10063, "http://imgur.com/u7cupKO.png" },
                {10059, "http://imgur.com/wJF8J0l.png"},
                {10065, "http://imgur.com/FVDQu9Y.png" },
                {10064, "http://imgur.com/k71r2Zq.png"},
                {10062, "http://imgur.com/TtSFbRI.png" },
                {10079, "http://imgur.com/hBW2DeR.png"},
            }
            },
             {"mask.balaclava", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/BYFgE5c.png" },
                {10105, "http://imgur.com/aZ24Prz.png"},
                {10069, "http://imgur.com/lZRsgUO.png"},
                {10071, "http://imgur.com/yqrwGPA.png" },
                {10068, "http://imgur.com/NSXHTJ8.png"},
                {10057, "http://imgur.com/qq0Kkf8.png" },
                {10075, "http://imgur.com/c52VsFb.png"},
                {10070, "http://imgur.com/qnu8n2a.png" },
                {10054, "http://imgur.com/QZCZVSP.png"},
                {10090, "http://imgur.com/1ngWJs4.png" },
                {10110, "http://imgur.com/4e4Jups.png"},
                {10084, "http://imgur.com/TXqTQBd.png" },
                {10139, "http://imgur.com/3hJfzEV.png"},
                {10111, "http://imgur.com/0Kl5Dcu.png" },
            }
            },
             {"jacket.snow", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/32ZO3jO.png" },
                {10082, "http://imgur.com/8jqmVOg.png"},
                {10113, "http://imgur.com/t2WQFcw.png" },
                {10083, "http://imgur.com/1lEjT1g.png"},
                {10112, "http://imgur.com/fdTvghu.png" },
            }
            },
             {"jacket", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/zU7TQPR.png" },
                {10011, "http://imgur.com/1qLvjuy.png"},
                {10012, "http://imgur.com/GA1QAnS.png" },
                {10009, "http://imgur.com/spufx0f.png"},
                {10015, "http://imgur.com/ua9esyK.png" },
                {10013, "http://imgur.com/7rkcCZ4.png"},
                {10072, "http://imgur.com/8jX3QSR.png" },
                {10010, "http://imgur.com/8snfg2N.png" },
                {10008, "http://imgur.com/Tk0KIFU.png"},
                {10014, "http://imgur.com/o0ZdjsQ.png" },
            }
            },
            {"hoodie", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/EvGigZB.png" },
                {10142, "http://imgur.com/WwwArof.png"},
                {14179, "http://imgur.com/wEyu9Ew.png" },
                {10052, "http://imgur.com/ghnihF2.png"},
                {14178, "http://imgur.com/EOh10jX.png" },
                {10133, "http://imgur.com/hmZGoIY.png"},
                {14072, "http://imgur.com/A0o5Tm5.png" },
                {10132, "http://imgur.com/i0tdeK7.png"},
                {10129, "http://imgur.com/UqqydUz.png" },
                {10086, "http://imgur.com/A7gjMm0.png"},
            }
            },
            {"hat.cap", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/TfycJC9.png" },
                {10029, "http://imgur.com/QFNHOZz.png"},
                {10027, "http://imgur.com/Zf14dTy.png" },
                {10055, "http://imgur.com/1zfiClI.png"},
                {10030, "http://imgur.com/acgOSe6.png" },
                {10026, "http://imgur.com/Augez3h.png"},
                {10028, "http://imgur.com/VZqY3iA.png" },
                {10045, "http://imgur.com/F34fPio.png" },
            }
            },
            {"hat.beenie", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/yDkGk47.png" },
                {14180, "http://imgur.com/ProarPm.png"},
                {10018, "http://imgur.com/gEPcMj7.png" },
                {10017, "http://imgur.com/QKmuZg9.png"},
                {10040, "http://imgur.com/2EEZQdG.png" },
                {10016, "http://imgur.com/PMU76bY.png"},
                {10085, "http://imgur.com/FDKeEhw.png" },
            }
            },
            {"burlap.gloves", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/8aFVMgl.png" },
                {10128, "http://imgur.com/HqZut8a.png"},
            }
            },
            {"burlap.shirt", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/MUs4xL6.png" },
                {10136, "http://imgur.com/E4wXccC.png"},
            }
            },
            {"hat.boonie", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/2b4OjxB.png" },
                {10058, "http://imgur.com/lkfKdyj.png"},
            }
            },
            {"santahat", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/bmOV0aX.png" },
            }
            },
            {"shirt.tanktop", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/1/1e/Tank_Top_icon.png/revision/latest/scale-to-width-down/100?cb=20161102190317" },
            }
            },
            {"shirt.collared", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/8/8c/Shirt_icon.png/revision/latest/scale-to-width-down/100?cb=20161102193325" },
            }
            },
            {"pants.shorts", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/4/46/Shorts_icon.png/revision/latest/scale-to-width-down/100?cb=20161102194514" },
            }
            },
            {"hazmat.pants", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ZsaLNUK.png" },
            }
            },
            {"hazmat.jacket", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/uKk9ghN.png" },
            }
            },
            {"hazmat.helmet", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/BHSrFsh.png" },
            }
            },
            {"hazmat.gloves", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/JYTXvnx.png" },
            }
            },
            {"hazmat.boots", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/sfU4PdX.png" },
            }
            },
            {"hat.miner", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/RtRy2ne.png" },
            }
            },
            {"hat.candle", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/F7nP0PC.png" },
            }
            },
            {"hat.wolf", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/D2Z8QjL.png" },
            }
            },
            {"burlap.trousers", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/tDqEh7T.png" },
            }
            },
            {"burlap.shoes", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/wXrkSxd.png" },
            }
            },
            {"burlap.headwrap", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/u6YLWda.png" },
            }
            },
            {"bucket.helmet", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Sb5cnpz.png" },
                {10127, "http://imgur.com/ZD3jtRS.png"},
                {10126, "http://imgur.com/qULrqXO.png" },
            }
            },
            {"wood.armor.pants", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/k2O9xEX.png" },
            }
            },
            {"wood.armor.jacket", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/9PUyVIv.png" },
            }
            },
            {"roadsign.kilt", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/WLh1Nv4.png" },
            }
            },
            {"roadsign.jacket", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/tqpDp2V.png" },
            }
            },
            {"riot.helmet", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/NlxGOum.png" },
            }
            },
            {"metal.plate.torso", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/lMw6ez2.png" },
            }
            },
            {"metal.facemask", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/BPd5q6h.png" },
            }
            },

            {"coffeecan.helmet", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/RrY8aMM.png" },
            }
            },
            {"bone.armor.suit", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/FkFR1kX.png" },
            }
            },
            {"attire.hide.vest", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/RQ8LJ5q.png" },
            }
            },
            {"attire.hide.skirt", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/nRlYLJW.png" },
            }
            },
            {"attire.hide.poncho", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/cqHND3g.png" },
            }
            },
            {"attire.hide.pants", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/rJy27KQ.png" },
            }
            },
            {"attire.hide.helterneck", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/2RXe7cg.png" },
            }
            },
            {"attire.hide.boots", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/6S98FbC.png" },
            }
            },
            {"deer.skull.mask", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/sqLjUSE.png" },
            }
            },
            {"pistol.revolver", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/C6BHyBB.png" },
                {10114, "http://imgur.com/DAj7lQo.png"},
            }
            },
            {"pistol.semiauto", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Zwqg3ic.png" },
                {10087, "http://imgur.com/hQwcNSG.png"},
                {10108, "http://imgur.com/21uutmr.png" },
                {10081, "http://imgur.com/vllF4FS.png"},
                {10073, "http://imgur.com/MSBvxA7.png" },
            }
            },
            {"rifle.ak", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/qlgloXW.png" },
                {10135, "http://imgur.com/0xgio10.png"},
                {10137, "http://imgur.com/UPDtgyK.png" },
                {10138, "http://imgur.com/XXKKLC4.png"},
            }
            },
            {"rifle.bolt", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/8oVVXJS.png" },
                {10117, "http://imgur.com/lFOPXfE.png"},
                {10115, "http://imgur.com/qbTQ06y.png" },
                {10116, "http://imgur.com/VhRwq7N.png"},
            }
            },
            {"shotgun.pump", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/OHRph6g.png" },
                {10074, "http://imgur.com/h91b64t.png"},
                {10140, "http://imgur.com/ktINZdj.png" },
            }
            },
            {"shotgun.waterpipe", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/3BliJtR.png" },
                {10143, "http://imgur.com/rmftGXr.png"},
            }
            },
            {"rifle.lr300", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/NYffUwv.png"},
            }
            },
            {"crossbow", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/nDBFhTA.png" },
            }
            },
            {"smg.thompson", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/rSQ5nHj.png" },
                {10120, "http://imgur.com/H3nPvJh.png"},
            }
            },
            {"weapon.mod.small.scope", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/jMvDHLz.png" },
            }
            },
            {"weapon.mod.silencer", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/oighpzk.png" },
            }
            },
            {"weapon.mod.muzzlebrake", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/sjxJIjT.png" },
            }
            },
            {"weapon.mod.muzzleboost", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/U9aMaPN.png" },
            }
            },
            {"weapon.mod.lasersight", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/rxIzDwY.png" },
            }
            },
            {"weapon.mod.holosight", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/R76B83t.png" },
            }
            },
            {"weapon.mod.flashlight", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/4gFapPt.png" },
            }
            },
            {"spear.wooden", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/7QpIs8B.png" },
            }
            },
            {"spear.stone", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Y3HstyV.png" },
            }
            },
            {"smg.2", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ElXI2uv.png" },
            }
            },
            {"smg.mp5", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ohazNYk.png" },
            }
            },
            {"shotgun.double", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Pm2Q4Dj.png" },
            }
            },
            {"salvaged.sword", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/M6gWbNv.png" },
            }
            },
            {"salvaged.cleaver", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/DrelWEg.png" },
            }
            },
            {"rocket.launcher", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/2yDyb9p.png" },
            }
            },
            {"rifle.semiauto", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/UfGP5kq.png" },
            }
            },
            {"pistol.eoka", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/SSb9czm.png" },
            }
            },
            {"machete", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/KfwkwV8.png" },
            }
            },
            {"mace", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/OtsvCkC.png" },
            }
            },
            {"longsword", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/1StsKVe.png" },
            }
            },
            {"lmg.m249", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/f7Rzrn2.png" },
            }
            },
            {"knife.bone", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/9TaVbYX.png" },
            }
            },
            {"flamethrower", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/CwhZ8i7.png" },
            }
            },
            {"bow.hunting", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Myv79jT.png" },
            }
            },
            {"bone.club", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ib11D8V.png" },
            }
            },
            {"grenade.f1", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ZwrVuXh.png" },
            }
            },
            {"grenade.beancan", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/FQZOd7m.png" },
            }
            },
            {"ammo.handmade.shell", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/V0CyZ7j.png" },
            }
            },
            {"ammo.pistol", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/gDNR7oj.png" },
            }
            },
             {"ammo.pistol.fire", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/VyX0pAu.png" },
            }
            },
            {"ammo.pistol.hv", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/E1dB4Nb.png" },
            }
            },
            {"ammo.rifle", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/rqVkjX3.png" },
            }
            },
            {"ammo.rifle.explosive", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/hpAxKQc.png" },
            }
            },
            {"ammo.rifle.hv", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/BkG4hLM.png" },
            }
            },
            {"ammo.rifle.incendiary", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/SN4XV2S.png" },
            }
            },
            {"ammo.rocket.basic", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Weg1M6y.png" },
            }
            },
            {"ammo.rocket.fire", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/j4XMSmO.png" },
            }
            },
            {"ammo.rocket.hv", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/5mdVIIV.png" },
            }
            },
            {"ammo.rocket.smoke", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/kMTgSEI.png" },
            }
            },
            {"ammo.shotgun", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/caFY5Bp.png" },
            }
            },
            {"ammo.shotgun.slug", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ti5fCBp.png" },
            }
            },
            {"arrow.hv", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/r6VLTt2.png" },
            }
            },
            {"arrow.wooden", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/yMCfjKh.png" },
            }
            },
            {"bandage", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/TuMpnnu.png" },
            }
            },
            {"syringe.medical", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/DPDicE6.png" },
            }
            },
            { "largemedkit", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/iPsWViD.png" },
            }
            },
            { "antiradpills", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/SIhXEtB.png" },
            }
            },
            { "blood", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Mdtvg2m.png" },
            }
            },
            {"bed", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/K0zQtwh.png" },
            }
            },
            {"box.wooden", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/dFqTUTQ.png" },
            }
            },
            {"box.wooden.large", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/qImBEtL.png" },
                {10124, "http://imgur.com/oXO4riD.png" },
                {10122, "http://imgur.com/Ue06zjq.png" },
                {10123, "http://imgur.com/QAizFb6.png" },
                {10141, "http://imgur.com/gSzIfNj.png" },
            }
            },
            {"campfire", new Dictionary<ulong, string>
            {
                {0, "http://i.imgur.com/TiAlJpv.png" },
            }
            },
            {"ceilinglight", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/3sikyL6.png" },
            }
            },
            {"door.double.hinged.metal", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/awNuhRv.png" },
            }
            },
            {"door.double.hinged.toptier", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/oJCqHd6.png" },
            }
            },
            {"door.double.hinged.wood", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/tcHmZXZ.png" },
            }
            },
            {"door.hinged.metal", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/UGZftiQ.png" },
            }
            },
            {"door.hinged.toptier", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/bc2TrfQ.png" },
            }
            },
            {"door.hinged.wood", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/PrrWSN2.png" },
            }
            },
            {"floor.grill", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/bp7ZOkE.png" },
            }
            },
            {"floor.ladder.hatch", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/suML6jj.png" },
            }
            },
            {"gates.external.high.stone", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/o4NWWXp.png" },
            }
            },
            {"gates.external.high.wood", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/DRa9a8G.png" },
            }
            },
            {"cupboard.tool", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/OzUewI1.png" },
            }
            },
            {"shelves", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/vjtdyk5.png" },
            }
            },
            {"shutter.metal.embrasure.a", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/1ke0LVO.png" },
            }
            },
            {"shutter.metal.embrasure.b", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/uRtgNRH.png" },
            }
            },
            {"shutter.wood.a", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/VngPUi2.png" },
            }
            },
            {"sign.hanging", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/VIeRGh9.png" },
            }
            },
            {"sign.hanging.banner.large", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Owr3668.png" },
            }
            },
            {"sign.hanging.ornate", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/nQ1xHYb.png" },
            }
            },
            {"sign.pictureframe.landscape", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/nNh1uro.png" },
            }
            },
            {"sign.pictureframe.portrait", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/CQr8UYq.png" },
            }
            },
            {"sign.pictureframe.tall", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/3b51GfA.png" },
            }
            },
            {"sign.pictureframe.xl", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/3zdBDqa.png" },
            }
            },
            {"sign.pictureframe.xxl", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/9xSgewe.png" },
            }
            },
            {"sign.pole.banner.large", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/nGRDZrO.png" },
            }
            },
            {"sign.post.double", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/CXUsPSn.png" },
            }
            },
            {"sign.post.single", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/0qXuSMs.png" },
            }
            },
            {"sign.post.town", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/KgN4T1C.png" },
            }
            },
            {"sign.post.town.roof", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/hCLJXg4.png" },
            }
            },
            {"sign.wooden.huge", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/DehcZTb.png" },
            }
            },
            {"sign.wooden.large", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/BItcvBB.png" },
            }
            },
            {"sign.wooden.medium", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/zXJcB26.png" },
            }
            },
            {"sign.wooden.small", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/wfDYYYW.png" },
            }
            },
            {"jackolantern.angry", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/NRdMCfb.png" },
            }
            },
            {"jackolantern.happy", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/2gIfuAO.png" },
            }
            },
            {"ladder.wooden.wall", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/E3haHSe.png" },
            }
            },
            {"lantern", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/UHQdu3Q.png" },
            }
            },
            {"lock.code", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/pAXI8ZY.png" },
            }
            },
            {"mining.quarry", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/4Mgh1nK.png" },
            }
            },
            {"mining.pumpjack", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/FWbMASw.png" },
            }
            },
            {"wall.external.high", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/mB8oila.png" },
            }
            },
            {"wall.external.high.stone", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/7t3BdwH.png" },
            }
            },
            {"wall.frame.cell", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/oLj65GS.png" },
            }
            },
            {"wall.frame.cell.gate", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/iAcwJmG.png" },
            }
            },
            {"wall.frame.fence", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/4HVSY9Y.png" },
            }
            },
            {"wall.frame.fence.gate", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/mpmO78C.png" },
            }
            },
            {"wall.frame.shopfront", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/G7fB7kk.png" },
            }
            },
            {"wall.window.bars.metal", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/QmkIpkZ.png" },
            }
            },
            {"wall.window.bars.toptier", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/AsMdaCc.png" },
            }
            },
            {"wall.window.bars.wood", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/VS3SVVB.png" },
            }
            },
            {"lock.key", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/HuelWn0.png" },
            }
            },
            { "barricade.concrete", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/91Ob9XP.png" },
            }
            },
            {"barricade.metal", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/7rseBMC.png" },
            }
            },
            { "barricade.sandbags", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/gBQLSgQ.png" },
            }
            },
            { "barricade.wood", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ycYTO3W.png" },
            }
            },
            { "barricade.woodwire", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/PMEFBla.png" },
            }
            },
            { "barricade.stone", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/W8qTCEX.png" },
            }
            },
            {"bone.fragments", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/iOJbBGT.png" },
            }
            },
            {"charcoal", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/G2hyxqi.png" },
            }
            },
            {"cloth", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/0olknLW.png" },
            }
            },
            {"coal", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/SIWOdbj.png" },
            }
            },
            {"crude.oil", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/VmQvwPS.png" },
            }
            },
            {"fat.animal", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/7NdUBKm.png" },
            }
            },
            {"hq.metal.ore", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/kdBrQ2P.png" },
            }
            },
            {"lowgradefuel", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/CSNPLYX.png" },
            }
            },
            {"metal.fragments", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/1bzDvUs.png" },
            }
            },
            {"metal.ore", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/yrTGHvv.png" },
            }
            },
            {"leather", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/9rqWrIy.png" },
            }
            },
            {"metal.refined", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/j2947YU.png" },
            }
            },
            {"wood", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/AChzDls.png" },
            }
            },
            {"seed.corn", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/u9ZPaeG.png" },
            }
            },
            {"seed.hemp", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/wO6aojb.png" },
            }
            },
            {"seed.pumpkin", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/mHaV8ei.png" },
            }
            },
            {"skull.human", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ZFnWubS.png" },
            }
            },
            {"skull.wolf", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/f4MRE72.png" },
            }
            },
            {"stones", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/cluFzuZ.png" },
            }
            },
            {"sulfur", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/1RTTB7k.png" },
            }
            },
            {"sulfur.ore", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/AdxkKGb.png" },
            }
            },
            {"gunpowder", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/qV7b4WD.png" },
            }
            },
            {"researchpaper", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Pv8jxrl.png" },
            }
            },
            {"explosives", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/S43G64k.png" },
            }
            },
            {"botabag", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/MkIOiUs.png" },
            }
            },
            {"box.repair.bench", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/HpwYNjI.png" },
            }
            },
            {"bucket.water", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/svlCdlv.png" },
            }
            },
            {"explosive.satchel", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/dlUW54q.png" },
            }
            },
            {"explosive.timed", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/CtxUCgC.png" },
            }
            },
            {"flare", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/MS0JcRT.png" },
            }
            },
            {"fun.guitar", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/l96owHe.png" },
            }
            },
            {"furnace", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/77i4nqb.png" },
            }
            },
            {"furnace.large", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/NmsmUzo.png" },
            }
            },
            {"hatchet", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/5juFLRZ.png" },
            }
            },
            {"icepick.salvaged", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ZTJLWdI.png" },
            }
            },
            {"axe.salvaged", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/muTaCg2.png" },
            }
            },
            {"pickaxe", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/QNirWhG.png" },
            }
            },
            {"research.table", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/C9wL7Kk.png" },
            }
            },
            {"small.oil.refinery", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Qqz6RgS.png" },
            }
            },
            {"stone.pickaxe", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/54azzFs.png" },
            }
            },
            {"stonehatchet", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/toLaFZd.png" },
            }
            },
            {"supply.signal", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/wj6yzow.png" },
            }
            },
            {"surveycharge", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/UPNvuY0.png" },
            }
            },
            {"target.reactive", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/BNcKZnU.png" },
            }
            },
            {"tool.camera", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/4AaLCfW.png" },
            }
            },
            {"water.barrel", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/JsmzCeU.png" },
            }
            },
            {"water.catcher.large", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/YWrJQoa.png" },
            }
            },
            {"water.catcher.small", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/PTXcYXs.png" },
            }
            },
            {"water.purifier", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/L7R4Ral.png" },
            }
            },
            {"rock", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/2GMBs5M.png" },
            }
            },
            {"torch", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/qKYxg5E.png" },
            }
            },
            {"stash.small", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/fH4RWZe.png" },
            }
            },
            {"sleepingbag", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/oJes3Lo.png" },
                {10121, "http://imgur.com/GvwtwGH.png" },
                {10037, "http://imgur.com/gDYUE6H.png" },
                {10119, "http://imgur.com/3lxtYiD.png" },
                {10109, "http://imgur.com/wQeDRzA.png" },
                {10107, "http://imgur.com/AHUGw7a.png" },
                {10077, "http://imgur.com/j7YFRrI.png" },
                {10076, "http://imgur.com/UCtDwNT.png" },
            }
            },
            {"hammer.salvaged", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/5oh3Wke.png" },
            }
            },
            {"hammer", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/KNG2Gvs.png" },
            }
            },
            {"blueprulongbase", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/gMdRr6G.png" },
            }
            },
            {"fishtrap.small", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/spuGlOj.png" },
            }
            },
            {"building.planner", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/oXu5F27.png" },
            }
            },
            {"battery.small", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/214z05n.png" },
            }
            },
            {"can.tuna.empty", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/GB02zHx.png" },
            }
            },
            {"can.beans.empty", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/9K5In35.png" },
            }
            },
            { "cctv.camera", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/4j4LD01.png" },
            }
            },
            {"pookie.bear", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/KJSccj0.png" },
            }
            },
            {"targeting.computer", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/oPMPl3B.png" },
            }
            },
            {"trap.bear", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/GZD4bVy.png" },
            }
            },
            {"trap.landmine", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/YR0lVCs.png" },
            }
            },
            {"autoturret", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/4R0ByHj.png" },
            }
            },
            {"spikes.floor", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Nj0yJs0.png" },
            }
            },
            {"note", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/AM3Uech.png" },
            }
            },
            {"paper", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/pK49c6M.png" },
            }
            },
            {"map", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/u8HBelr.png" },
            }
            },
            {"stocking.large", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/di39MBT.png" },
            }
            },
            {"stocking.small", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/6eAg1zi.png" },
            }
            },
            {"generator.wind.scrap", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/fuQaE1H.png" },
            }
            },
            {"xmas.present.large", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/dU3nhYo.png" },
            }
            },
            {"xmas.present.medium", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Ov5YUty.png" },
            }
            },
            {"xmas.present.small", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/hWCd67B.png" },
            }
            },
            {"door.key", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/kw8UAN2.png" },
            }
            },
            { "wolfmeat.burned", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/zAJhDNd.png" },
            }
            },
            { "wolfmeat.cooked", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/LKlgpMe.png" },
            }
            },
            { "wolfmeat.raw", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/qvMvis8.png" },
            }
            },
            { "wolfmeat.spoiled", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/8kXOVyJ.png" },
            }
            },
            {"waterjug", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/BJzeMkc.png" },
            }
            },
            {"water.salt", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/d4ihUtv.png" },
            }
            },
            {"water", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/xdz5L7M.png" },
            }
            },
            {"smallwaterbottle", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/YTLCucH.png" },
            }
            },
            {"pumpkin", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Gb9NvdQ.png" },
            }
            },
            {"mushroom", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/FeWuvuh.png" },
            }
            },
            {"meat.boar", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/4ijrHrn.png" },
            }
            },
            {"meat.pork.burned", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/5Dam9qQ.png" },
            }
            },
            {"meat.pork.cooked", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/yhgxCPG.png" },
            }
            },
            {"humanmeat.burned", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/DloSZvl.png" },
            }
            },
            {"humanmeat.cooked", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/ba2j2rG.png" },
            }
            },
            {"humanmeat.raw", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/28SpF8Y.png" },
            }
            },
            {"humanmeat.spoiled", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/mSWVRUi.png" },
            }
            },
            {"granolabar", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/3rvzSwj.png" },
            }
            },
            {"fish.cooked", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Idtzv1t.png" },
            }
            },
            {"fish.minnows", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/7LXZH2S.png" },
            }
            },
            {"fish.troutsmall", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/aJ2PquF.png" },
            }
            },
            {"fish.raw", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/GdErxqf.png" },
            }
            },
            {"corn", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/6V5SJZ0.png" },
            }
            },
            {"chocholate", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Ymq7PsV.png" },
            }
            },
            {"chicken.burned", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/34sYfir.png" },
            }
            },
            {"chicken.cooked", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/UvHbBhH.png" },
            }
            },
            {"chicken.raw", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/gMldKSz.png" },
            }
            },
            {"chicken.spoiled", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/hiOEwGn.png" },
            }
            },
            {"cactusflesh", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/8R16YDP.png" },
            }
            },
            {"candycane", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/DSxrXOI.png" },
            }
            },
            {"can.tuna", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/c8rDUP3.png" },
            }
            },
            {"can.beans", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/Ysn6ThW.png" },
            }
            },
            {"blueberries", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/tFZ66fB.png" },
            }
            },
            {"black.raspberries", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/HZjKpX9.png" },
            }
            },
            {"bearmeat", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/hpL2I64.png" },
            }
            },
            {"bearmeat.burned", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/f1eVA0W.png" },
            }
            },
            {"bearmeat.cooked", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/e5Z6w1y.png" },
            }
            },
            {"apple", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/goMCM2w.png" },
            }
            },
            {"apple.spoiled", new Dictionary<ulong, string>
            {
                {0, "http://imgur.com/2pi2sUH.png" },
            }
            },
            {"bleach", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/a/ac/Bleach_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045849" },
            }
            },
            {"ducttape", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/f/f8/Duct_Tape_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045924" },
            }
            },
            {"propanetank", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/a/a8/Empty_Propane_Tank_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045920" },
            }
            },
            {"gears", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/7/72/Gears_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045908" },
            }
            },
            {"glue", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/6/66/Glue_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045933" },
            }
            },
            {"metalblade", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/9/9b/Metal_Blade_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045912" },
            }
            },
            {"metalpipe", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/4/4a/Metal_Pipe_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045929" },
            }
            },
            {"metalspring", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/3/3d/Metal_Spring_icon.png/revision/latest/scale-to-width-down/50?cb=20161101151803" },
            }
            },
            {"riflebody", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/0/08/Rifle_Body_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045853" },
            }
            },
            {"roadsigns", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/a/a5/Road_Signs_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045904" },
            }
            },
            {"rope", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/1/15/Rope_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045939" },
            }
            },
            {"sewingkit", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/2/29/Sewing_Kit_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045952" },
            }
            },
            {"sheetmetal", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/3/39/Sheet_Metal_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045901" },
            }
            },
            {"smgbody", new Dictionary<ulong, string>
            {
                {0, "http://vignette3.wikia.nocookie.net/play-rust/images/d/d8/SMG_Body_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045947" },
            }
            },
            {"sticks", new Dictionary<ulong, string>
            {
                {0, "http://vignette1.wikia.nocookie.net/play-rust/images/d/d5/Sticks_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045943" },
            }
            },
            {"tarp", new Dictionary<ulong, string>
            {
                {0, "http://vignette4.wikia.nocookie.net/play-rust/images/1/12/Tarp_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045916" },
            }
            },
            {"techparts", new Dictionary<ulong, string>
            {
                {0, "http://vignette2.wikia.nocookie.net/play-rust/images/e/eb/Tech_Trash_icon.png/revision/latest/scale-to-width-down/50?cb=20161109045841" },
            }
            },
};

        #endregion

        #region Data Management

        void SaveData()
        {
            ImageLibraryData.WriteObject(imageData);
        }

        void LoadData()
        {
            try
            {
                imageData = ImageLibraryData.ReadObject<ImageData>();
                CheckNewImages();
            }
            catch
            {

                Puts("Couldn't load Image Data, creating new datafile and refreshing Images");
                imageData = new ImageData();
                RefreshAllImages();
            }
        }
        #endregion
    }
}

// --- End of file: ImageLibrary.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomItems.cs ---
// --- Original Local Path: CustomItems.cs ---

﻿#region Using
using Oxide.Core;
using System.Collections.Generic;
using System;
#endregion

namespace Oxide.Plugins
{
    [Info("CustomItems", "rdapplehappy", "1.3")]

    class CustomItems : RustPlugin
    {
        #region Variables

        List<Ore> Ores = new List<Ore>();
        private string MessageTake = "Вы получили драгоценный камень";
        private bool MessageEnabled = false, ItemRecycle = true;

        private List<ulong> Skins = new List<ulong>();

        #endregion

        #region Classes
        class Ore
        {
            public string name; // Имя
            public ulong id; // Skindid
            public string Description; // Описание
            public bool Recycled;
            public int MinCount; // Мин.количество из одного ящика/бочки и.т.д
            public int Maxcount; // Макс.количество из одного ящика/бочки и.т.д
            public Dictionary<string, int> itemsdrop = new Dictionary<string, int>(); //Выпадение ресурсов при переработке
            public int ItemId; // id предмета, который будет заменяться скином.
            public int ChanceStone; // Шанс выпадения из камня 
            public int ChanceSulfur; // Шанс выпадения из серы
            public int ChanceMetall; // Шанс выпадения из металла
            public int ChanceBarrel; // Шанс выпадения из бочки
            public int ChanceCrate_underwater; // Шанс выпадения из подводного ящика
            public int StandartCrateChance; // Шанс выпадения из обычного ящика
            public int GreenCrateChance;  // Шанс выпадения из зелён.ящика 
            public int EliteCrateChance; //  Шанс выпадения из элитного ящика
        }
        #endregion

        #region Config

        private void LoadDefaultConfig()
        {
            GetConfig("Оповещение", "Текст оповещения", ref MessageTake);
            GetConfig("Оповещение", "Включить оповещения при добыче", ref MessageEnabled);
            SaveConfig();
        }

        #endregion

        #region Hooks

        //Проверка загрузки даты
        void OnServerInitialized() { LoadData(); NextTick(() => { if (CheckData()) PrintWarning("Ores by DYXA - succesful load"); }); NextTick(() => GetSkinsId()); LoadDefaultConfig(); }

        //Замена скина. - Fix rustSkins
        Item OnItemSplit(Item item, int amount)
        {
            ulong skin = item.skin;
            if (Skins.Contains(skin))
            {
                item.amount -= amount;
                item.Initialize(item.info);
                return AddItem(item.GetOwnerPlayer(), item.name, skin, item.info.shortname, amount);

            }
            return null;
        }
        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            Item item1 = item.GetItem(); Item item2 = targetItem.GetItem();
            if (Skins.Contains(item1.skin)) if (!item2.skin.Equals(item1.skin)) return false; 
            if(Skins.Contains(item2.skin)) if (!item1.skin.Equals(item2.skin))  return false; 

            return null;
        }

        //Ores - drop
        void OnDispenserGather(ResourceDispenser dis, BaseEntity ent, Item it)
        {
            OresName name = GetOreName(it.info.name.Replace(".item", "")); if (name == OresName.Nn) return;
            Ore ore = RandomGather(name); if (ore == null) return;
            if (OreRandom(ore, name)) GiveItems(ore, ent.ToPlayer()); 
        }
        void OnLootSpawn(LootContainer container)
        {
            Crates crate = Crates.Nn;
            if (container.ShortPrefabName.Equals(Crates.crate_normal.ToString())) crate = Crates.crate_normal; 
            else if (container.ShortPrefabName.Equals(Crates.crate_normal_2.ToString())) crate = Crates.crate_normal_2; 
            else if (container.ShortPrefabName.Equals(Crates.crate_elite.ToString()))  crate = Crates.crate_elite; 
            else if (container.ShortPrefabName.Equals(Crates.loot_barrel_1.ToString()))  crate = Crates.loot_barrel_1; 
            else if (container.ShortPrefabName.Equals(Crates.loot_barrel_2.ToString()))  crate = Crates.loot_barrel_2;
            else if (container.ShortPrefabName.Equals("loot-barrel-1")) crate = Crates.lootbarrel1;
            else if (container.ShortPrefabName.Equals("loot-barrel-2")) crate = Crates.lootbarrel2;
            else if (container.ShortPrefabName.Equals(Crates.crate_underwater_advanced.ToString())) crate = Crates.crate_underwater_advanced; 
            else if (container.ShortPrefabName.Equals(Crates.crate_underwater_basic.ToString())) crate = Crates.crate_underwater_basic;

            BoxDrop(container, crate);
        }

        //Recycle item
        void CanRecycle(Recycler recycler, Item item)
        {
            foreach (var ore in Ores)
                if (item.info.itemid.Equals(ore.ItemId) && item.skin.Equals(ore.id))
                { if (!ore.Recycled) { recycler.MoveItemToOutput(item); return; }; recycler.StartRecycling(); return; }
            return;
        }
        object OnRecycleItem(Recycler recycler, Item item)
        {
            foreach (var ore in Ores)
            {
                if (item.info.itemid.Equals(ore.ItemId) && item.skin.Equals(ore.id))
                {
                    if(!ore.Recycled) { recycler.MoveItemToOutput(item);  NextTick(() => { recycler.StartRecycling(); }); return false; }
                    foreach (var items in ore.itemsdrop)
                    {
                        Item itemcreate = ItemManager.CreateByName(items.Key, items.Value * item.amount);
                        recycler.MoveItemToOutput(itemcreate);
                    }
                    item.RemoveFromWorld(); item.RemoveFromContainer();
                    return false;
                }
            }
            return null;
        }

        #endregion

        #region Functions

        private Ore FindOre(string shortname, string itemName, ulong skin)
        {
            foreach(Ore ore in Ores)
            {
                if (ore.ItemId.Equals(ItemManager.CreateByName(shortname).info.itemid) && ore.name.Contains(itemName) && ore.id.Equals(skin)){
                    return ore;
                }
            }
            return null;
        }

        private void CreateItem(string shortName, string itemName, ulong skin)
        {
            int id = ItemManager.CreateByName(shortName).info.itemid;

            Ore ore = new Ore()
            {
                name = itemName,
                id = skin,
                ItemId = id,
                Maxcount = 5,
                MinCount = 1,
                Recycled = false,
                ChanceBarrel = 10,
                ChanceMetall = 0,
                ChanceStone = 15,
                ChanceSulfur = 20,
                GreenCrateChance = 30,
                StandartCrateChance = 5,
                EliteCrateChance = 12,
                ChanceCrate_underwater = 0,
                itemsdrop = null,
                Description = ""
            };

            Ores.Add(ore);
            SaveData();

            PrintWarning("Generate new item " + itemName + ". can be changed in data/Ores.json");
        }

        #endregion

        #region Data

        protected void LoadData() => Ores = Interface.Oxide.DataFileSystem.ReadObject<List<Ore>>("Ores");
        protected void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("Ores", Ores);

        protected void GenerateData()
        {
            Dictionary<string, int> Drops = new Dictionary<string, int>();
            Drops.Add("sulfur.ore", 1500); Drops.Add("metal.ore", 1250); Drops.Add("hq.metal.ore", 100);

            Ore ore = new Ore()
            {
                name = "Золото",
                Maxcount = 10,
                MinCount = 1,
                ItemId = 609049394,
                Recycled = true,
                ChanceBarrel = 10,
                ChanceMetall = 0,
                ChanceStone = 15,
                ChanceSulfur = 20,
                GreenCrateChance = 30,
                StandartCrateChance = 5,
                EliteCrateChance = 12,
                ChanceCrate_underwater = 0,
                id = 609049394,
                itemsdrop = Drops,
                Description = "<size=18>█████████████████</size>\n Золото - <size=14>дорогой камень,\n переработав который, вы получите много ресурсов!</size>"
            };

            Ores.Add(ore); SaveData(); PrintWarning("Data successfully created!");
        }

        protected bool CheckData()
        {
            if (Ores.Count == 0) { PrintWarning("Start to generate data..."); GenerateData(); return false; }
            else return true;
        }

        #endregion

        #region Api

        bool isGenerated(string shortName, string itemName, ulong skin)
        {
            if (FindOre(shortName, itemName, skin) != null) return true;
            return false;
        }

        void itemGenerate(string shortName, string itemName, ulong skin)
        {
            if (isGenerated(shortName, itemName, skin)) return;
            CreateItem(shortName, itemName, skin);
        }

        private bool OreRandom(Ore ore, OresName name)
        {
            int chance = 0;

            if (name == OresName.Barrel) chance = ore.ChanceBarrel;
            if (name == OresName.Metall) chance = ore.ChanceMetall;
            if (name == OresName.Stone) chance = ore.ChanceStone;
            if (name == OresName.EliteBox) chance = ore.EliteCrateChance;
            if (name == OresName.GreenBox) chance = ore.GreenCrateChance;
            if (name == OresName.StandartBox) chance = ore.StandartCrateChance;
            if (name == OresName.Sulfur) chance = ore.ChanceSulfur;
            if (name == OresName.WaterBox) chance = ore.ChanceCrate_underwater;

            if (chance > 100) chance = 100; if (chance < 0) chance = 0;

            if (Oxide.Core.Random.Range(1, 100) <= chance) return true;

            return false;
        }
        private OresName GetOreName(string name)
        {
            if (name.Equals("sulfur_ore")) return OresName.Sulfur;
            else if (name.Equals("metal_ore")) return OresName.Metall;
            else if (name.Equals("stones")) return OresName.Stone;
            return OresName.Nn;
        }
        private OresName GetCrateName(Crates crates)
        {
            OresName name = OresName.Nn;
            if (crates == Crates.crate_elite) name = OresName.EliteBox;
            else if (crates == Crates.crate_normal) name = OresName.GreenBox;
            else if (crates == Crates.crate_normal_2) name = OresName.StandartBox;
            else if (crates == Crates.loot_barrel_1 || crates == Crates.loot_barrel_2 || crates == Crates.lootbarrel1 || crates == Crates.lootbarrel2) name = OresName.Barrel;
            else if (crates == Crates.crate_underwater_advanced || crates == Crates.crate_underwater_basic) name = OresName.WaterBox;

            return name;
        }
        
        //LoadSkinsandIds
        private void GetSkinsId() { foreach (Ore ore in Ores) { Skins.Add(ore.id); } }

        //Cfg
        private void GetConfig<T>(string menu, string Key, ref T var)
        {
            if (Config[menu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[menu, Key], typeof(T));
            }
            Config[menu, Key] = var;
			var СfgFiles = 8915;
        }


        //ItemGive
        private Item AddItem(BasePlayer p, string name, ulong skin, string shortname,int count)
        {
            Item winitem = ItemManager.CreateByName(shortname, count, skin);
            winitem.name = name;
            return winitem;
        }
        private void GiveItems(Ore ore, BasePlayer player)
        {
              Item winitem = ItemManager.CreateByItemID(ore.ItemId, Oxide.Core.Random.Range(ore.MinCount, ore.Maxcount + 1), ore.id);
              winitem.name = ore.name +  "\n" + ore.Description;
            if (!player.inventory.containerMain.IsFull() || !player.inventory.containerBelt.IsFull()) player.GiveItem(winitem);
            else winitem.Drop(player.transform.position, new UnityEngine.Vector3(), new UnityEngine.Quaternion());
            if (MessageEnabled) MessageSend(MessageTake, player);
        }
        private void GivetoBox(Ore ore, LootContainer cont)
        {
            Item winitem = ItemManager.CreateByItemID(ore.ItemId, Oxide.Core.Random.Range(ore.MinCount, ore.Maxcount + 1), ore.id);
            winitem.name = ore.name + "\n" + ore.Description;
            NextTick(() => winitem.MoveToContainer(cont.inventory));
        }


        enum OresName { Sulfur, Metall, Stone, Barrel, WaterBox, StandartBox, GreenBox, EliteBox, Nn }
        enum Crates { crate_normal_2, crate_elite, crate_normal, loot_barrel_1, loot_barrel_2, lootbarrel1, lootbarrel2, crate_underwater_basic, crate_underwater_advanced, Nn}

        private void MessageSend(string message, BasePlayer player)
        {
            player.SendConsoleCommand("gametip.showgametip", message);
            timer.Once(4f, () => player.SendConsoleCommand("gametip.hidegametip"));
        }

        private Ore RandomGather(OresName name)
        {
            List<Ore> OresList = new List<Ore>();
            foreach(var Ors in Ores)
            {
                if (Ors.ChanceMetall > 0 && name == OresName.Metall) OresList.Add(Ors);
                else if (Ors.ChanceStone > 0 && name == OresName.Stone) OresList.Add(Ors);
                else if (Ors.ChanceSulfur > 0 && name == OresName.Sulfur) OresList.Add(Ors);
                else if (Ors.ChanceBarrel > 0 && name == OresName.Barrel) OresList.Add(Ors);
                else if (Ors.EliteCrateChance > 0 && name == OresName.EliteBox) OresList.Add(Ors);
                else if (Ors.GreenCrateChance > 0 && name == OresName.GreenBox) OresList.Add(Ors);
                else if (Ors.ChanceCrate_underwater > 0 && name == OresName.WaterBox) OresList.Add(Ors);
                else if (Ors.StandartCrateChance > 0 && name == OresName.StandartBox) OresList.Add(Ors);
            }

            if (OresList.Count == 0) return null;
            return OresList[Oxide.Core.Random.Range(0, OresList.Count)];
        }

        private void BoxDrop(LootContainer cont, Crates crate)
        {
           OresName name = GetCrateName(crate); if (name == OresName.Nn) return;
            Ore ore = RandomGather(name); if (ore == null) return;
            if (OreRandom(ore, name)) GivetoBox(ore, cont);
        }

        #endregion
    }
}

// --- End of file: CustomItems.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoTeleport.cs ---
// --- Original Local Path: AutoTeleport.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Teleport", "Sempai#3239", "1.1.3")]
    [Description("https://topplugin.ru/resources")]
    public class AutoTeleport : RustPlugin
    {
        private
        const string permUse = "autoteleport.use";
        private
        const string elemMain = "autoteleport.main";
        private static UISettings ui => config.uiSettings;
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            LoadData();
            cmd.AddConsoleCommand("autoteleport", this, "cmdControlConsole");
            foreach (var command in config.commands)
            {
                cmd.AddChatCommand(command, this, cmdControlChat);
            }
        }
        private void OnTeleportRequested(BasePlayer receiver, BasePlayer caller)
        {
            if (permission.UserHasPermission(receiver.UserIDString, permUse) == false)
            {
                return;
            }
            CheckTeleport(receiver, caller);
        }
        private void Unload()
        {
            SaveData();
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, elemMain);
            }
        }
        private void cmdControlConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                return;
            }
            var data = Data.Get(player.userID);
            var type = arg.Args?.Length > 0 ? arg.Args[0] : "null";
            switch (type)
            {
                case "c":
                case "clan":
                case "clans":
                    data.autoClans = !data.autoClans;
                    break;
                case "f":
                case "friend":
                case "friends":
                    data.autoFriends = !data.autoFriends;
                    break;
                case "t":
                case "team":
                case "teams":
                    data.autoTeam = !data.autoTeam;
                    break;
            }
            OpenUI(player);
        }
        private void cmdControlChat(BasePlayer player, string command, string[] args)
        {
            OpenUI(player);
        }
        private void CheckTeleport(BasePlayer receiver, BasePlayer caller)
        {
            var data = Data.Get(receiver.userID);
            if (data.autoTeam && InSameTeam(receiver, caller))
            {
                AcceptTeleport(receiver);
                return;
            }
            if (data.autoFriends && IsFriends(receiver, caller))
            {
                AcceptTeleport(receiver);
                return;
            }
            if (data.autoClans && InSameClan(receiver, caller))
            {
                AcceptTeleport(receiver);
                return;
            }
        }
        private static void AcceptTeleport(BasePlayer player)
        {
            player.SendConsoleCommand("chat.say /tpa");
        }
        private void OpenUI(BasePlayer player, DataEntry data = null)
        {
            if (data == null)
            {
                data = Data.Get(player.userID);
            }
            var container = new CuiElementContainer {
                new CuiElement {
                    Name = elemMain, Components = {
                        new CuiImageComponent {
                            Color = ui.mainColor, Material = "assets/content/ui/namefontmaterial.mat",
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-{ui.mainSizeX} -{ui.mainSizeY}", OffsetMax = $"{ui.mainSizeX} {ui.mainSizeY}"
                        },
                        new CuiNeedsCursorComponent()
                    }
                }, new CuiElement {
                    Parent = elemMain, Components = {
                        new CuiTextComponent {
                            Text = ui.textMain, Color = ui.textColor, FontSize = ui.mainFont, Align = TextAnchor.UpperCenter,
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.2 0.05", AnchorMax = "0.8 0.95",
                        }
                    }
                }
            };
            var buttonClan = CreateButton("0.2", ui.textClan, "clans", data.autoClans, config.enabledClan == false);
            var buttonFriends = CreateButton("0.4", ui.textFriends, "friends", data.autoFriends, config.enabledFriends == false);
            var buttonTeam = CreateButton("0.6", ui.textTeam, "team", data.autoTeam, config.enabledTeam == false);
            container.AddRange(buttonClan);
            container.AddRange(buttonFriends);
            container.AddRange(buttonTeam);
            container.Add(new CuiButton
            {
                Text = {
                    Text = "X",
                    Color = "1 1 1 1",
                    Align = TextAnchor.MiddleCenter,
                    FontSize = ui.fontClose,
                },
                Button = {
                    Close = elemMain,
                    Color = "1 1 1 0"
                },
                RectTransform = {
                    AnchorMin = "1 1",
                    AnchorMax = "1 1",
                    OffsetMin = $"-{ui.sizeClose} -{ui.sizeClose}",
                    OffsetMax = "0 0",
                }
            }, elemMain);
            CuiHelper.DestroyUi(player, elemMain);
            CuiHelper.AddUi(player, container);
        }
        private CuiElementContainer CreateButton(string anchorY, string textLabel, string commandArg, bool buttonActive, bool buttonDisabled)
        {
            var container = new CuiElementContainer();
            var textButton = buttonActive ? ui.textOn : ui.textOff;
            var buttonColor = buttonActive ? ui.onColor : ui.offColor;
            if (buttonDisabled == true)
            {
                textButton = config.uiSettings.textDeactivated;
                buttonColor = config.uiSettings.deactivatedColor;
            }
            container.Add(new CuiElement
            {
                Parent = elemMain,
                Components = {
                    new CuiTextComponent {
                        Text = textLabel, Color = ui.textColor, Align = TextAnchor.MiddleCenter, FontSize = ui.textFont
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = $"0.45 {anchorY}", AnchorMax = $"0.45 {anchorY}", OffsetMin = $"-{ui.buttonSizeX * 2} -{ui.buttonSizeY}", OffsetMax = $"0 {ui.buttonSizeY}"
                    },
                }
            });
            container.Add(new CuiButton
            {
                Text = {
                    Text = textButton,
                    Align = TextAnchor.MiddleCenter,
                    Color = ui.buttonTextColor,
                    FontSize = ui.buttonFont
                },
                Button = {
                    Command = "autoteleport " + commandArg,
                    Color = buttonColor,
                },
                RectTransform = {
                    AnchorMin = $"0.55 {anchorY}",
                    AnchorMax = $"0.55 {anchorY}",
                    OffsetMin = $"0 -{ui.buttonSizeY}",
                    OffsetMax = $"{ui.buttonSizeX * 2} {ui.buttonSizeY}"
                }
            }, elemMain);
            return container;
        }
        private static ConfigData config = new ConfigData();
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Command")]
            public string[] commands = {
                "atp",
                "autoteleport",
                "autotp",
            };
            [JsonProperty(PropertyName = "Friends button enabled")] public bool enabledFriends = true;
            [JsonProperty(PropertyName = "Default value for friends")] public bool defaultFriends = true;
            [JsonProperty(PropertyName = "Clan button enabled")] public bool enabledClan = true;
            [JsonProperty(PropertyName = "Default value for clan")] public bool defaultClan = true;
            [JsonProperty(PropertyName = "Team button enabled")] public bool enabledTeam = true;
            [JsonProperty(PropertyName = "Default value for team")] public bool defaultTeam = true;
            [JsonProperty(PropertyName = "UI Settings")] public UISettings uiSettings = new UISettings();
        }
        private class UISettings
        {
            [JsonProperty(PropertyName = "[Text] On")] public string textOn = "ON";
            [JsonProperty(PropertyName = "[Text] Off")] public string textOff = "OFF";
            [JsonProperty(PropertyName = "[Text] Clan")] public string textClan = "Clan";
            [JsonProperty(PropertyName = "[Text] Team")] public string textTeam = "Team";
            [JsonProperty(PropertyName = "[Text] Deactivated")] public string textDeactivated = "INACTIVE";
            [JsonProperty(PropertyName = "[Text] Friends")] public string textFriends = "Friends";
            [JsonProperty(PropertyName = "[Text] Mail text")] public string textMain = "Auto Teleports";
            [JsonProperty(PropertyName = "[Color] Mail panel")] public string mainColor = "0.2 0.2 0.2 0.7";
            [JsonProperty(PropertyName = "[Color] Label text")] public string textColor = "1 1 1 1";
            [JsonProperty(PropertyName = "[Color] On/Off Button text")] public string buttonTextColor = "1 1 1 1";
            [JsonProperty(PropertyName = "[Color] Button On")] public string onColor = "0.5 0.75 0 0.8";
            [JsonProperty(PropertyName = "[Color] Button Off")] public string offColor = "0.7 0.2 0.2 0.8";
            [JsonProperty(PropertyName = "[Color] Button deactivate")] public string deactivatedColor = "0.9 0.9 0.9 0.8";
            [JsonProperty(PropertyName = "[Size] Mail panel X")] public int mainSizeX = 250;
            [JsonProperty(PropertyName = "[Size] Mail panel Y")] public int mainSizeY = 115;
            [JsonProperty(PropertyName = "[Size] On/Off Button X")] public int buttonSizeX = 100;
            [JsonProperty(PropertyName = "[Size] On/Off Button Y")] public int buttonSizeY = 20;
            [JsonProperty(PropertyName = "[Size] Close button")] public int sizeClose = 40;
            [JsonProperty(PropertyName = "[Font] Mail text")] public int mainFont = 25;
            [JsonProperty(PropertyName = "[Font] Label text")] public int textFont = 30;
            [JsonProperty(PropertyName = "[Font] On/Off Button text")] public int buttonFont = 30;
            [JsonProperty(PropertyName = "[Font] Close button text")] public int fontClose = 25;
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                timer.Every(10f, () =>
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                });
                LoadDefaultConfig();
                return;
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        private
        const string filename = "data";
        private bool corruptedData;
        private Timer saveTimer;
        private class DataEntry
        {
            public bool autoClans = config.defaultClan;
            public bool autoTeam = config.defaultTeam;
            public bool autoFriends = config.defaultFriends;
        }
        private static PluginData Data = new PluginData();
        private class PluginData
        {
            [JsonIgnore] public Dictionary<string, DataEntry> cache = new Dictionary<string, DataEntry>();
            public Dictionary<string, DataEntry> info = new Dictionary<string, DataEntry>();
            public DataEntry Get(object param)
            {
                var key = param?.ToString();
                if (key == null)
                {
                    return null;
                }
                var value = (DataEntry)null;
                if (cache.TryGetValue(key, out value) == true)
                {
                    return value;
                }
                if (info.TryGetValue(key, out value) == false)
                {
                    value = new DataEntry();
                    info.Add(key, value);
                }
                cache.Add(key, value);
                return value;
            }
        }
        private void LoadData(string keyName = filename)
        {
            if (saveTimer == null)
            {
                saveTimer = timer.Every(Core.Random.Range(500, 700), () => SaveData());
            }
            try
            {
                Data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>($"{Name}/{keyName}");
            }
            catch (Exception e)
            {
                corruptedData = true;
                Data = new PluginData();
                timer.Every(30f, () =>
                {
                    PrintError($"!!! CRITICAL DATA ERROR !!!\n * Data was not loaded!\n * Data auto-save was disabled!\n * Error: {e.Message}");
                });
                LogToFile("errors", $"\n\nError: {e.Message}\n\nTrace: {e.StackTrace}\n\n", this);
            }
        }
        private void SaveData(string keyName = filename)
        {
            if (corruptedData == false && Data != null)
            {
                Data.cache.Clear();
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}/{keyName}", Data);
            }
        }
        [PluginReference] private Plugin Clans;
        private string GetPlayerClan(BasePlayer player)
        {
            return Clans?.Call<string>("GetClanӿ", player.userID);
        }
        private bool InSameClan(BasePlayer playeܡ, BasePlayer playeܢ)
        {
            var claۡ = GetPlayerClan(playeܡ);
            var claۢ = GetPlayerClan(playeܢ);
            return string.IsNullOrEmpty(claۡ) == false && string.Equals(claۡ, claۢ);
        }
        [PluginReference] private Plugin Friends, RustIOFriendListAPI;
        private bool IsFriends(BasePlayer playeܡ, BasePlayer playeܢ)
        {
            return IsFriends(playeܡ.userID, playeܢ.userID);
        }
        private bool IsFriends(ulong iف, ulong iق)
        {
            var flaٱ = Friends?.Call<bool>("AreFriends", iف, iق) ?? false;
            var flaٲ = RustIOFriendListAPI?.Call<bool>("AreFriendsS", iف.ToString(), iق.ToString()) ?? false;
            return flaٱ || flaٲ;
        }
        private static bool InSameTeam(BasePlayer playeܡ, BasePlayer playeܢ)
        {
            return playeܡ.currentTeam != 0 && playeܡ.currentTeam == playeܢ.currentTeam;
        }
    }
}

// --- End of file: AutoTeleport.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PrivilegeDeploy.cs ---
// --- Original Local Path: PrivilegeDeploy.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{ 
    [Info("PrivilegeDeploy", "k1lly0u", "0.1.23", ResourceId = 1800)]
    class PrivilegeDeploy : RustPlugin
    {
        private readonly int triggerMask = LayerMask.GetMask("Trigger", "Construction");
        private bool Loaded = false;

        private Dictionary<ulong, PendingItem> pendingItems = new Dictionary<ulong, PendingItem>();

        void OnServerInitialized() => LoadVariables();
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (Loaded)
            {
                for (int i = 0; i < configData.deployables.Count; i++)
                    if (entity.ShortPrefabName.Contains(configData.deployables[i]))
                    {
                        var ownerID = entity.GetComponent<BaseEntity>().OwnerID;
                        if (ownerID != 0)
                        {
                            BasePlayer player = BasePlayer.FindByID(ownerID);
                            if (player == null || player.IsAdmin()) return;
                            if (!HasPriv(player))
                            {
                                Item item;
                                if (entity.ShortPrefabName.Contains("landmine"))
                                {
                                    entity.KillMessage();                                    
                                    item = ItemManager.CreateByPartialName("trap.landmine");
                                }
                                else if (entity.ShortPrefabName.Contains("bear"))
                                {
                                    entity.GetComponent<BaseCombatEntity>().DieInstantly();
                                    item = ItemManager.CreateByPartialName("trap.bear");
                                }
                                else
                                {
                                    entity.GetComponent<BaseCombatEntity>().DieInstantly();
                                    item = ItemManager.CreateByPartialName(configData.deployables[i]);
                                    var deployable = item.info.GetComponent<ItemModDeployable>();
                                    if (deployable != null)
                                    {
                                        var oven = deployable.entityPrefab.Get()?.GetComponent<BaseOven>();
                                        if (oven != null)
                                            oven.startupContents = null;
                                    }
                                }

                                if (!pendingItems.ContainsKey(player.userID))
                                    pendingItems.Add(player.userID, new PendingItem());
                                pendingItems[player.userID].item = item;

                                CheckForDuplicate(player);
                            }
                        }
                    }
            }
        }      
        private void CheckForDuplicate(BasePlayer player)
        {
            if (pendingItems[player.userID].timer != null) pendingItems[player.userID].timer.Destroy();
               
            pendingItems[player.userID].timer = timer.Once(0.01f, () => GivePlayerItem(player));

        }
        private void GivePlayerItem(BasePlayer player)
        {
            Item item = pendingItems[player.userID].item;
            player.GiveItem(item);
            SendReply(player, lang.GetMessage("blocked", this, player.UserIDString));
            pendingItems.Remove(player.userID);
        }
        
        private bool HasPriv(BasePlayer player)
        {
            var hit = Physics.OverlapSphere(player.transform.position, 2f, triggerMask);
            foreach (var entity in hit)
            {
                BuildingPrivlidge privs = entity.GetComponentInParent<BuildingPrivlidge>();
                if (privs != null)
                    if (privs.IsAuthed(player)) return true;
            }
            return false;
        }

        #region config

        private ConfigData configData;
        class ConfigData
        {
            public List<string> deployables { get; set; }
        }
        private void LoadVariables()
        {
            Loaded = true;
            RegisterMessages();
            LoadConfigVariables();
            SaveConfig();
        }
        private void RegisterMessages() => lang.RegisterMessages(messages, this);
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                deployables = new List<string>
                    {
                        "barricade.concrete",
                        "barricade.metal",
                        "barricade.sandbags",
                        "barricade.stone",
                        "barricade.wood",
                        "barricade.woodwire",
                        "campfire",
                        "gates.external.high.stone",
                        "gates.external.high.wood",
                        "wall.external.high",
                        "wall.external.high.stone",
                        "landmine",
                        "beartrap"
                    }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        class PendingItem
        {
            public Timer timer;
            public Item item;
        }
        #endregion

        Dictionary<string, string> messages = new Dictionary<string, string>
        {
            {"blocked", "You can not build this outside of a building privileged area!" }
        };
    }
}



// --- End of file: PrivilegeDeploy.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TimedHeliCall.cs ---
// --- Original Local Path: TimedHeliCall.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TimedHeliCall", "Troubled", 0.1)]
    class TimedHeliCall : RustPlugin
    {
        private int _heliInterval;
        private int _x;
        private int _z;
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            Config.Clear();
            Config["HeliInterval"] = 60;
            Config["X"] = 0;
            Config["Z"] = 0;
            SaveConfig();
            PrintWarning("Configuration file made");
        }

        void Init()
        {
            if (Convert.ToInt32(Config["X"]) == 0 || Convert.ToInt32(Config["Z"]) == 0)
            {
                PrintError("Change your configuration file.");
            }

            _heliInterval = GetIntConfig("HeliInterval");
            _x = GetIntConfig("X");
            _z = GetIntConfig("Z");
            Puts($"X: {_x} Z:{_z} interval: {_heliInterval}");
            if (_heliInterval > 0)
            {
                timer.Every(_heliInterval * 60, CallHeli);
            }
        }

        private int GetIntConfig(string configkey)
        {
            return Convert.ToInt32(Config[configkey]);
        }

        private void CallHeli()
        {
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion());
            if (!entity) return;
            Puts($"Helicopter called to X:{_x} Z:{_z}");
            PatrolHelicopterAI helicopter = entity.GetComponent<PatrolHelicopterAI>();
            helicopter.SetInitialDestination(new Vector3(_x, 20f, _z));
            entity.Spawn();
        }
    }
}


// --- End of file: TimedHeliCall.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingBlocked.cs ---
// --- Original Local Path: BuildingBlocked.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BuildingBlocked", "Sempai#3239", "1.1.0")]
    class BuildingBlocked : RustPlugin
    {
        int terrainMask = LayerMask.GetMask("Terrain");
        int constructionMask = LayerMask.GetMask("Construction");

        #region Configuration
        int waterLevel = 10;
        int maxHeight = 25;
        bool caveBuild = true;
        bool roadRestrict = true;
        bool iceBuild = false;
        bool adminIgnore = false;
        float treeRadius = 2f;
        bool buildBlock = true;
        private void LoadDefaultConfig()
        {
            GetConfig("Основные настройки", "Запрещать строительство глубже n метров под водой", ref waterLevel);
            GetConfig("Основные настройки", "Запрещать строительство выше n метров", ref maxHeight);
            GetConfig("Основные настройки", "Разрешить строительство в пещерах", ref caveBuild);
            GetConfig("Основные настройки", "Запрещать строительство в Building Block", ref buildBlock);
            // GetConfig("Основные настройки", "Разрешить строительство на айсбергах", ref iceBuild);
            GetConfig("Основные настройки", "Запрещать строительство на дорогах", ref roadRestrict);
            GetConfig("Основные настройки", "Игнорировать админов", ref adminIgnore);
            GetConfig("Основные настройки", "Минимальный радиус от дерева", ref treeRadius);
            SaveConfig();
        }


        private void GetConfig<T>(string MainMenu, string Key, ref T var)
        {
            if (Config[MainMenu, Key] != null)
            {
                var = (T)Convert.ChangeType(Config[MainMenu, Key], typeof(T));
            }
            Config[MainMenu, Key] = var;
        }
        #endregion

        WaterCollision collision;

        void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            LoadConfig();
            LoadDefaultConfig();
            collision = UnityEngine.Object.FindObjectOfType<WaterCollision>();
        }

        static void DrawBox(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 size)
        {
            size /= 2;
            var point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
            var point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point1, point2);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point1, point3);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point1, point5);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point4, point2);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point4, point3);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point4, point8);

            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point5, point6);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point5, point7);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point6, point2);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point8, point6);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point8, point7);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point7, point3);
        }

        static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
        {
            return rotation * (point - pivot) + pivot;
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject, Vector3 Pos)
        {
            if (planner == null || gameobject == null) return;
            var player = planner.GetOwnerPlayer();
            if (player.IsAdmin && adminIgnore) return;
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (buildBlock)
            {
                var targetLocation = player.transform.position + (player.eyes.BodyForward() * 4f);
                if (entity.PrefabName != "assets/prefabs/deployable/tool cupboard/cupboard.tool.deployed.prefab")
                {
                    var reply = 0; if (reply == 0) { }
                    if (player.IsBuildingBlocked(targetLocation, new Quaternion(0, 0, 0, 0), new Bounds(Vector3.zero, Vector3.zero)))
                    {
                        if (!entity.IsDestroyed)
                        {
                            Refund(player, entity);
                            SendReply(player, string.Format(Messages["buildingBlocked"]));
                            entity.Kill();
                            return;
                        }
                    }
                }
            }
            Vector3 pos = entity.GetNetworkPosition();
            if (roadRestrict)
            {
                RaycastHit hit;
                if (Physics.Raycast(pos, Vector3.down, out hit, terrainMask))
                {
                    if (hit.transform.name == "Road Mesh")
                    {
                        Refund(player, entity);
                        SendReply(player, Messages["roadBlock"]);
                        entity.Kill();
                        return;
                    }
                }
            }

            if (pos.y < -waterLevel)
                if (caveBuild && InCave(pos)) return;
                else
                {
                    Refund(player, entity);
                    player.ChatMessage(string.Format(Messages["waterLevel"], waterLevel));
                    entity.Kill();
                    return;
                }
            if (TerrainMeta.WaterMap.GetHeight(pos) - pos.y > waterLevel)
            {
                Refund(player, entity);
                player.ChatMessage(string.Format(Messages["waterLevel"], waterLevel));
                entity.Kill();
                return;
            }


            if (pos.y - TerrainMeta.HeightMap.GetHeight(pos) > maxHeight)
            {
                Refund(player, entity);
                SendReply(player, string.Format(Messages["heightLevel"], maxHeight));
                entity.Kill();
                return;
            }
            if (treeRadius > 0 && entity.ShortPrefabName.Contains("foundation"))
            {
                List<TreeEntity> treeList = new List<TreeEntity>();
                Vis.Entities(pos, treeRadius, treeList, LayerMask.GetMask("Tree"), QueryTriggerInteraction.Ignore);
                if (treeList.Count > 0)
                {
                    SendReply(player, string.Format(Messages["treeBlock"], (int)treeRadius));
                    Refund(player, entity);
                    entity.Kill();
                    return;
                }
            }

            if (entity.ShortPrefabName.Contains("foundation"))
            {
                timer.Once(0.1f, () =>
                {
                    if (!entity.IsDestroyed)
                    {
                        List<BuildingBlock> blockList = new List<BuildingBlock>();
                        Vis.Entities(pos, 4, blockList, constructionMask, QueryTriggerInteraction.Ignore);
                        if (blockList.Count(block => block.ShortPrefabName.Contains("foundation") && CompareFoundationStacking(block.CenterPoint(), entity.CenterPoint())) > 1)
                        {
                            entity.KillMessage();
                            SendReply(player, Messages["StackFoundation"], this);
                        }
                    }
                });
            }
        }

        bool CompareFoundationStacking(Vector3 vec1, Vector3 vec2)
        {
            return vec1.ToString("F4") == vec2.ToString("F4");
        }

        void SendReply(BasePlayer player, string msg)
        {
            base.SendReply(player, $"<size=16><color=#ff5400>{msg}</color></size>");
        }

        bool InCave(Vector3 vec) => collision.GetIgnore(vec);

        void Refund(BasePlayer player, BaseEntity entity)
        {
            RefundHelper.Refund(player, entity);
        }

        #region Refund
        public static class RefundHelper
        {
            private static Dictionary<uint, Dictionary<ItemDefinition, int>> refundItems =
                new Dictionary<uint, Dictionary<ItemDefinition, int>>();

            public static void Refund(BasePlayer player, BaseEntity entity, float percent = 1)
            {
                StorageContainer storage = entity as StorageContainer;
                if (storage)
                {
                    for (int i = storage.inventory.itemList.Count - 1; i >= 0; i--)
                    {
                        var item = storage.inventory.itemList[i];
                        if (item == null) continue;
                        item.amount = (int)(item.amount * percent);
                        float single = 20f;
                        Vector3 vector32 = Quaternion.Euler(UnityEngine.Random.Range(-single * 0.5f, single * 0.5f), UnityEngine.Random.Range(-single * 0.5f, single * 0.5f), UnityEngine.Random.Range(-single * 0.5f, single * 0.5f)) * Vector3.up;
                        BaseEntity baseEntity = item.Drop(storage.transform.position + (Vector3.up * 1f), vector32 * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation);
                        baseEntity.SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
                    }
                }

                BuildingBlock block = entity as BuildingBlock;
                if (block != null)
                {
                    try
                    {
                        if (block.currentGrade == null) return;
                        foreach (var item in block.currentGrade.costToBuild)
                        {
                            var amount = (int)(item.amount * (Mathf.Approximately(percent, -1) ? 0.5f : percent));
                            if (amount < 1) amount = 1;
                            player.GiveItem(ItemManager.Create(item.itemDef, amount, 0));
                        }

                    }
                    catch
                    {
                    }
                    return;
                }
                Dictionary<ItemDefinition, int> items;
                if (refundItems.TryGetValue(entity.prefabID, out items))
                {
                    foreach (var item in items)
                        if (item.Value > 0)
                            player.GiveItem(ItemManager.Create(item.Key, (int)(item.Value)));
                }
            }

            private static void InitRefundItems()
            {
                foreach (var item in ItemManager.itemList)
                {
                    var deployable = item.GetComponent<ItemModDeployable>();
                    if (deployable != null)
                    {
                        if (item.Blueprint == null || deployable.entityPrefab == null) continue;
                        refundItems.Add(deployable.entityPrefab.resourceID, item.Blueprint.ingredients.ToDictionary(p => p.itemDef, p => ((int)p.amount)));
                    }
                }
            }
        }
        #endregion

        #region MESSAGES

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            { "buildingBlocked", "Строительство в BuildingBlocked запрещено!"},
            { "waterLevel", "Строительство глубже {0} метров под водой запрещено!"},
            { "heightLevel", "Строительство выше {0} метров запрещено!" },
            { "iceBlock", "Строительство на айсбергах запрещено!" },
            { "roadBlock", "Строительство на дорогах запрещено!" },
            { "treeBlock", "Строительство рядом с деревьями в радиусе {0}м. запрещено" },
            { "StackFoundation","Стакать фундаменты запрещено!"},
            { "AlreadyBuildingBuilt", "Шкаф уже стоит!" }
        };

        #endregion
    }
}
                                

// --- End of file: BuildingBlocked.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CraftPanel.cs ---
// --- Original Local Path: CraftPanel.cs ---

using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins{

    [Info("CraftPanel", "TopPlugin.ru", "1.3.1")]
    [Description("Simple Custom Crafting Interface")]
    public class CraftPanel : RustPlugin {

        #region Fields
        [PluginReference] Plugin ImageLibrary;
        private const string elemq0 = "craftpanel.base";
        private const string elemq1 = "craftpanel.main";
        private const string elemq2 = "craftpanel.error";
        private const string elemq7 = "craftpanel.subdetails";
        private const string elemq6 = "craftpanel.list";
        private const string elemqitemvip = "craftpanel.itemvip";
        private bool _isCraftReady;
        private List<CraftInfo> craftList;
        #endregion

        private void Init(){
            cmd.AddConsoleCommand("craftpanel.craft", this, nameof(cmdCraft));
            cmd.AddConsoleCommand("craftpanel.close", this, nameof(cmdCloseConsole));
            cmd.AddConsoleCommand("craftpanel.item", this, nameof(cmdInfoVipConsole));
            cmd.AddConsoleCommand("craftpanel.close2", this, nameof(cmdClose2Console));
            cmd.AddConsoleCommand("craftpanel.page", this, nameof(cmdItemsPage));
        }

        private void OnServerInitialized(){
            LoadImages();
            Permissions();
        }

        private void Unload(){
            foreach (var player in BasePlayer.activePlayerList){
                ClosePanelNoSound(player, false);
            }        
        }

        #region Comandos
        [ChatCommand("craft")]
        void chatopenvip(BasePlayer player){
            if (HasPermission(player.UserIDString, config.Custom.permissionuse)){
                if (!_isCraftReady){
                    PrintToChat(player, Lang("MessageResponse", player.UserIDString));
                    return;
                }
                OpenPanelCraft(player);
            } else {
                PrintToChat(player, Lang("NotAllowed", player.UserIDString));
            }
        }
        #endregion

        #region Functions
        private void cmdCloseConsole(ConsoleSystem.Arg arg){
            ClosePanel(arg.Player(), true);
        }
        private void cmdClose2Console(ConsoleSystem.Arg arg){
            Efecto(arg.Player(), config.Custom.sound1);
            CuiHelper.DestroyUi(arg.Player(), elemq2);
        }

        private void cmdInfoVipConsole(ConsoleSystem.Arg arg){
            cmdInfoVip(arg.Player(), string.Empty, arg.Args);
        }
        private void cmdInfoVip(BasePlayer player, string command, string[] args){
            var page = int.Parse(args[1]);
            GetPanelItem(player, args[0], page);
            Efecto(player, config.Custom.sound1);
        }

        private void cmdCraft(ConsoleSystem.Arg arg){
            cmdCrafting(arg.Player(), string.Empty, arg.Args);
        }

        private void cmdCrafting(BasePlayer player, string command, string[] args){
            int craftitem = int.Parse(args[0]);
            if (CanCraftItem(player,craftitem)){
                var craft = config.Craft[craftitem].result;
                var comando = craft.command;
                if (string.IsNullOrEmpty(comando)) {
                    var item = ItemManager.CreateByName(craft.shortname, craft.amount, craft.skinID);
                    item.name = config.Craft[craftitem].name;
                    player.GiveItem(item);
                } else {
                    comando = comando.Replace("{steamID}", player.UserIDString);
                    Server.Command(comando);
                }
                Efecto(player, config.Custom.sound2);
            }
        }

        private void cmdItemsPage(ConsoleSystem.Arg arg){
            var player = arg.Player();
            var page = int.Parse(arg.Args[1]);
            GetPanelItem(player, arg.Args[0], page);
            Efecto(player, config.Custom.sound1);
        }
  
        private void Permissions(){
            permission.RegisterPermission(config.Custom.permissionuse, this);
            foreach (var recipe in config.Craft){
                var permCraft = recipe.permission;
                var permCraftVIP = recipe.permissionVIP;
                var permCraftNoCost = recipe.permissionNoCost;
                permission.RegisterPermission(permCraft, this);
                permission.RegisterPermission(permCraftVIP, this);
                permission.RegisterPermission(permCraftNoCost, this);
            }
        }

        private bool HasPermission(string userID, string perm){
            return string.IsNullOrEmpty(perm) || permission.UserHasPermission(userID, perm);
        }

        private void LoadImages(){
            Dictionary<string, string> imageListCraft = new Dictionary<string, string>();
            List<KeyValuePair<string, ulong>> itemIcons = new List<KeyValuePair<string, ulong>>();
            imageListCraft.Add("block", config.Custom.imgblock);

            foreach (var recipe in config.Craft){
                if (recipe.img != "" && !imageListCraft.ContainsKey(recipe.img)) {
                    imageListCraft.Add(recipe.img, recipe.img);
                }

                if (recipe.imgicon != "" && !imageListCraft.ContainsKey(recipe.imgicon)) {
                    imageListCraft.Add(recipe.imgicon, recipe.imgicon);
                }

                 foreach (var shopItem in recipe.items){
                     if (shopItem.item.Contains("hazmatsuit.spacesuit") || shopItem.item.Contains("attire.ninja.suit") || shopItem.item.Contains("workcart")) continue;

                    itemIcons.Add(new KeyValuePair<string, ulong>(shopItem.item, shopItem.skinID));
                 }
            }

            if (itemIcons.Count > 0){
                ImageLibrary?.Call("LoadImageList", Title, itemIcons, null);
            }

            ImageLibrary?.Call("ImportImageList", Title, imageListCraft, 0UL, true, new Action(CraftReady));
        }

        private void CraftReady(){
            _isCraftReady = true;
        }

        /*private void AddImage(string name, string url){
                if (ImageLibrary == null || !ImageLibrary.IsLoaded){
                    timer.Once(1f, () => {
                        AddImage(name, url);
                    });
                    return;
                }
                ImageLibrary.CallHook("AddImage", url, name, (ulong) 0);
        }*/

        private string GetImageLibrary(string name, ulong skinid = 0){ 
            return ImageLibrary?.Call<string>("GetImage", name, skinid); 
        }

        void Efecto(BasePlayer player, String prefab){ 
            if(config.Custom.soundeffects){
                Effect.server.Run(prefab, player.transform.position, Vector3.up, null, true); 
            }
        }

        private List<CraftInfo> GetCraftItemsForPlayer(BasePlayer player){
            //config.Custom.showWithoutPerm
            return craftList.Where(kit => (string.IsNullOrEmpty(kit.permission) || 1 == 1 || permission.UserHasPermission(player.UserIDString, kit.permission)) ).ToList();
        }
        #endregion

        #region GUI
        private void OpenPanelCraft(BasePlayer player){
            CuiHelper.DestroyUi(player, elemq0);
            var container = new CuiElementContainer();
            container.Add(new CuiElement {
                Name = elemq0,
                Parent = "Overlay",
                Components = {
                    new CuiImageComponent {
                        FadeIn = 0.2f,
                        Color = "0 0 0 0.8",
                        Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = "-1000 -800",
                        OffsetMax = "1000 800"
                    },
                    new CuiNeedsCursorComponent()
                }
            });

            UI.Label(ref container, elemq0, config.Custom.title, 26, "0.202 0.67", "0.3 0.69", config.Custom.colortitle, TextAnchor.MiddleLeft);

            CuiHelper.AddUi(player, container);
            OpenPanelItem(player, "0", 0);
        }

        private void OpenPanelItem(BasePlayer player, string item, int page){
            GetPanelItem(player, item, page);
            Efecto(player, config.Custom.sound1);
        }

        private void OpenPanelError(BasePlayer player, string textshow){
            Efecto(player, "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
            var container = new CuiElementContainer();
            container.AddRange(GetPanel2(player, textshow));
            CuiHelper.DestroyUi(player, elemq2);
            CuiHelper.AddUi(player, container);
            timer.Once(8, () => CuiHelper.DestroyUi(player, elemq2));
        }

        private void ClosePanel(BasePlayer player, bool sonido){
            Efecto(player, config.Custom.sound1);
            CuiHelper.DestroyUi(player, elemq0);
        }

        private void ClosePanelNoSound(BasePlayer player, bool sonido){
            CuiHelper.DestroyUi(player, elemq0);
        }
      
        //---Panel Info Item
        private void GetPanelItem(BasePlayer player, string i, int page = 0){
            CuiHelper.DestroyUi(player, elemq1);
            var CraftItems = GetCraftItemsForPlayer(player).Skip(16 * page).Take(16).ToList();
            var container = new CuiElementContainer();

            container.Add(new CuiPanel{
                Image = {
                    Color="1 1 1 0"
                },
                RectTransform = {
                    AnchorMin=$"0 0", AnchorMax=$"1 1"
                }
            }, elemq0, elemq1);

            UI.Button(ref container, elemq1, config.Custom.colorbtnclose, Lang("Close", player.UserIDString), 15, "0.7 0.67", "0.79 0.69", $"craftpanel.close");

            //Lista de Items
            var list_sizeX = 80;
            var list_sizeY = 80;
            var list_startX = -600;
            var list_startY = 250;
            var list_x = list_startX;
            var list_y = list_startY;

            var po = 0;
            var e = 0;

            if (CraftItems.Count > 0) foreach (var list_entry in CraftItems){
                //var list_entry = config.Craft[e];
                var perm = list_entry.permission;
                    
                if (po != 0 && po % 4 == 0){
                    list_x = list_startX;
                    list_y -= list_sizeY + 40;
                }
                
                po++;
                
                string list_name = list_entry.name;
                string list_imgicon = list_entry.imgicon;

                container.Add(new CuiElement {
                    Name = elemq6, Parent = elemq1, Components = {
                        new CuiRawImageComponent{
                            Png = GetImageLibrary(list_imgicon)
                        },
                        new CuiRectTransformComponent{
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = $"{list_x} {list_y-list_sizeY}",
                            OffsetMax = $"{list_x + list_sizeX} {list_y}"
                        }
                    }
                });

                if (!HasPermission(player.UserIDString, perm)){
                    UI.Image(ref container, elemq6, GetImageLibrary("block"), "0.1 0.1", "0.9 0.9");
                }
                container.Add(new CuiButton {
                    Button = {
                        Command = page > 0 ? $"craftpanel.item {e + (page * 16)} {page}" : $"craftpanel.item {e} {page}",
                        Color = config.Custom.colorbtnlist,
                        Material = "assets/content/ui/namefontmaterial.mat"
                    },
                    Text = {
                        Text = list_name,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 10,
                        Font = "robotocondensed-regular.ttf"
                    },
                    RectTransform = {
                        AnchorMin = "0 -0.32",
                        AnchorMax = "1 -0.05"
                    }
                }, elemq6);
                
                list_x += list_sizeX + 15;
                
                e++;
            }

            if (config.Craft.Count > 16 || page != 0){
                UI.Button(ref container, elemq1, page > 0 ? config.Custom.colorbtnback : "0.5 0.5 0.5 0.1", Lang("Back", player.UserIDString), 15, "0.2 0.32", "0.29 0.34", page > 0 ? $"craftpanel.page {i} {page - 1}": "");
                UI.Button(ref container, elemq1, GetCraftItemsForPlayer(player).Skip(16 * (page + 1)).Count() > 0 ? config.Custom.colorbtnnext : "0.5 0.5 0.5 0.1"  , Lang("Next", player.UserIDString), 15, "0.295 0.32", "0.385 0.34", GetCraftItemsForPlayer(player).Skip(16 * (page + 1)).Count() > 0 ? $"craftpanel.page {i} {page + 1}": $"");
            }

            var eID = Convert.ToInt32(i);
            var entry = config.Craft[eID];
            string name = entry.name;
            string complete = entry.namecomplete;
            string img = entry.img;
            string description = entry.description;
            var discount = entry.VIPdiscount;
            string workbench = entry.workbench.ToString();
            var perms = entry.permission;
            var permNoCost = entry.permissionNoCost;
            var permVIP = entry.permissionVIP;

            //Panel Central
            container.Add(new CuiElement {
                Name = elemq7,
                Parent = elemq1,
                Components = {
                    new CuiImageComponent {
                        FadeIn = 0.2f,
                        Color = config.Custom.colorbgpanel,
                        Material = "assets/content/ui/namefontmaterial.mat"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = "-200 -250",
                        OffsetMax = "200 250"
                    }
                }
            });

            UI.Image(ref container, elemq1, GetImageLibrary(img), "0.4 0.561", "0.5995 0.6562");

            /*container.Add(new CuiElement {
                Parent = elemq1,
                Components = {
                    new CuiRawImageComponent{
                        FadeIn = 0.2f,
                        Png = GetImageLibrary(img)
                    },
                    new CuiRectTransformComponent{
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = "-200 100",
                        OffsetMax = "200 250"
                    }
                }
            });*/

            if(workbench != "0"){
                UI.Panel(ref container, elemq1, "0.31 0.50 1.00 0.60", "0.40 0.643", "0.463 0.656");
                UI.Label(ref container, elemq1, Lang("Workbench", player.UserIDString, workbench), 13, "0.40 0.643", "0.463 0.656", "", TextAnchor.MiddleCenter);
            }

            container.Add(new CuiElement {
                Parent = elemq1,
                Components = {
                    new CuiTextComponent {
                        Text = complete,
                        FontSize = 18,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = "-190 45",
                        OffsetMax = "190 90"
                    }
                }
            });

            container.Add(new CuiElement {
                Parent = elemq1,
                Components = {
                    new CuiTextComponent {
                        Text = description,
                        Color = "1.00 1.00 1.00 0.82",
                        FontSize = 13,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = "-190 -80",
                        OffsetMax = "190 100"
                    }
                }
            });

            if (HasPermission(player.UserIDString, permVIP)){
                UI.Label(ref container, elemq1, Lang("VIP", player.UserIDString, discount.ToString()), 17, "0.4 0.37", "0.6 0.43", config.Custom.colortxtvip, TextAnchor.MiddleCenter);
            }
            
            //Panel de Ingredientes
            var sizeX = 60;
            var sizeY = 60;
            var startX = 250;
            var startY = 250;
            var x = startX;
            var y = startY;

            for (var o = 0; o < config.Craft[eID].items.Count;o++){
                var entry2 = config.Craft[eID].items[o];
                if (o != 0 && o % 4 == 0){
                    x = startX;
                    y -= sizeY + 25;
                }

                container.Add(new CuiElement {
                    Name = elemqitemvip, Parent = elemq1, Components = {
                        new CuiRawImageComponent{
                            Png = GetImageLibrary(entry2.item, entry2.skinID)
                        },
                        new CuiRectTransformComponent{
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = $"{x} {y-sizeY}",
                            OffsetMax = $"{x + sizeX} {y}"
                        }
                    }
                });

                var amount = entry2.amount;

                UI.Label(ref container, elemqitemvip, $"x{amount}", 13, "0 -0.3", "1 0.2", "", TextAnchor.MiddleCenter);

                if (permission.UserHasPermission(player.UserIDString, permVIP) == true){
                    var promo = amount - ((amount*discount)/100);
                    UI.Label(ref container, elemqitemvip, $"({promo})", 10, "0 -0.4", "1 -0.2", config.Custom.coloramountvip, TextAnchor.MiddleCenter);
                }
                x += sizeX + 12;
            }

            if (HasPermission(player.UserIDString, perms)){
                UI.Button(ref container, elemq7, config.Custom.colorbtncraft, Lang("Craft", player.UserIDString), 15, "0 0", "0.998 0.08", $"craftpanel.craft {i}");
            } else {
                UI.Button(ref container, elemq7, config.Custom.colorbtnclose, Lang("WithoutPermission", player.UserIDString), 15, "0 0", "0.998 0.08", $"craftpanel");
            }

            CuiHelper.AddUi(player, container);
        }

        //---Panel Error
        private CuiElementContainer GetPanel2(BasePlayer player, string textshow){
            var container = new CuiElementContainer();
            container.Add(new CuiElement {
                Name = elemq2,
                Parent = "Overlay",
                Components = {
                    new CuiImageComponent {
                        Color = "1.0 0 0.0 0.4",
                        Material = "assets/content/ui/namefontmaterial.mat"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = "-200 260",
                        OffsetMax = "200 300"
                    }
                }
            });

            container.Add(new CuiElement {
                Parent = elemq2,
                Components = {
                    new CuiTextComponent {
                        Text = textshow,
                        FontSize = 14,
                        Align = TextAnchor.MiddleCenter,
                        Font = "robotocondensed-regular.ttf"
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = "0.5 0.5",
                        AnchorMax = "0.5 0.5",
                        OffsetMin = "-200 -10",
                        OffsetMax = "200 10"
                    }
                }
            });

            container.Add(new CuiButton{
				Button =
				{
					Command = "craftpanel.close2",
					Color = "0 0 0 0.2",
                    Material = "assets/content/ui/namefontmaterial.mat"
				},
				RectTransform =
				{
					AnchorMin = "0.88 0.20",
					AnchorMax = "0.97 0.80"
				},
				Text =
				{
					Text = "x",
					FontSize = 14,
					Align = TextAnchor.MiddleCenter
				}
			}, elemq2);

            return container;
        }
        #endregion

        #region CUI Helper
        public class UI {
            static public void Panel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false, string material = "assets/content/ui/namefontmaterial.mat"){
                container.Add(new CuiPanel{
                    Image = { Color = color, Material = material},
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax},
                    CursorEnabled = cursor
                },
                panel);
            }

            static public void Label(ref CuiElementContainer container, string panel, string text, int size, string aMin, string aMax, string color = "1 1 1 0.6", TextAnchor align = TextAnchor.MiddleCenter, bool font = false){
                container.Add(new CuiLabel{
                    Text = { FontSize = size, Font = font? "robotocondensed-bold.ttf" : "robotocondensed-regular.ttf", Color = color, Align = align, Text = text},
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax}
                },
                panel);
            }

            static public void Button(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter){
                container.Add(new CuiButton{
                    Button = { Color = color, Material = "assets/content/ui/namefontmaterial.mat", Command = command, FadeIn = 0f},
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax},
                    Text = { Text = text, FontSize = size, Align = align}
                },
                panel);
            }

            static public void Input(ref CuiElementContainer container, string panel, string color, string text, int size, string command, string aMin, string aMax){
                container.Add(new CuiElement{
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components = {
                        new CuiInputFieldComponent {
                            Align = TextAnchor.MiddleLeft,
                            CharsLimit = 50,
                            Color = color,
                            Command = command + text,
                            FontSize = size,
                            IsPassword = false,
                            Text = text
                        },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax}
                    }
                });
            }

            static public void Image(ref CuiElementContainer container, string panel, string png, string aMin, string aMax){
                container.Add(new CuiElement{
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components = {
                        new CuiRawImageComponent {Png = png},
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax}
                    }
                });
            }
        }
        #endregion

        #region Config
        private static ConfigData config;

        private class ConfigData {
            [JsonProperty(PropertyName = "Custom")]
            public CraftCustom Custom;

            [JsonProperty(PropertyName = "Craft")]
            public List<CraftInfo> Craft;
        }
        
        private class CraftInfo {
            [JsonProperty(PropertyName = "Short Name")]
            public string name;
            
            [JsonProperty(PropertyName = "Full Name")]
            public string namecomplete;

            [JsonProperty(PropertyName = "Img Full")]
            public string img;

            [JsonProperty(PropertyName = "Img Icon")]
            public string imgicon;

            [JsonProperty(PropertyName = "Description")]
            public string description;

            [JsonProperty(PropertyName = "Craft Result")]
            public CraftResult result;

            [JsonProperty(PropertyName = "Permission Use")]
            public string permission;

            [JsonProperty(PropertyName = "Permission VIP")]
            public string permissionVIP;

            [JsonProperty(PropertyName = "Permission No Cost")]
            public string permissionNoCost;

            [JsonProperty(PropertyName = "VIP discount: 10 = 10%")]
            public int VIPdiscount;

            [JsonProperty(PropertyName = "Require Workbench? 0 = NOT, 1 = Level 1,...")]
            public int workbench;

            [JsonProperty(PropertyName = "Items")]
            public List<CraftInfoItem> items;
        }

        private class CraftInfoItem {
            [JsonProperty(PropertyName = "Item")]
            public string item;

            [JsonProperty(PropertyName = "Amount")]
            public int amount;

            [JsonProperty(PropertyName = "Skin ID")]
            public ulong skinID;
        }

        private class CraftResult {
            [JsonProperty(PropertyName = "Command (keep empty to create item)")]
            public string command;
            
            [JsonProperty(PropertyName = "Shortname")]
            public string shortname;
            
            [JsonProperty(PropertyName = "Amount")]
            public int amount;
            
            [JsonProperty(PropertyName = "Skin ID")]
            public ulong skinID;
        }

        private class CraftCustom {
            [JsonProperty(PropertyName = "Title")]
            public string title;

            [JsonProperty(PropertyName = "Show even if you don't have permissions (you won't be able to craft)")]
            public bool showWithoutPerm;

            [JsonProperty(PropertyName = "Sound Effects")]
            public bool soundeffects;

            [JsonProperty(PropertyName = "Sound Prefab 1")]
            public string sound1;

            [JsonProperty(PropertyName = "Sound Prefab 2")]
            public string sound2;

            [JsonProperty(PropertyName = "Sound Prefab 3")]
            public string sound3;

            [JsonProperty(PropertyName = "Permission Use /craft")]
            public string permissionuse;

            [JsonProperty(PropertyName = "Color Title")]
            public string colortitle;

            [JsonProperty(PropertyName = "Color Button List")]
            public string colorbtnlist;
            
            [JsonProperty(PropertyName = "Color Button Close")]
            public string colorbtnclose;

            [JsonProperty(PropertyName = "Color Button Craft")]
            public string colorbtncraft;

            [JsonProperty(PropertyName = "Color Button Back")]
            public string colorbtnback;

            [JsonProperty(PropertyName = "Color Button Next")]
            public string colorbtnnext;
            
            [JsonProperty(PropertyName = "Color Background Panel")]
            public string colorbgpanel;

            [JsonProperty(PropertyName = "Color Text VIP")]
            public string colortxtvip;

            [JsonProperty(PropertyName = "Color Text Amount")]
            public string coloramount;

            [JsonProperty(PropertyName = "Color Text Amount VIP")]
            public string coloramountvip;

            [JsonProperty(PropertyName = "Img Block Item")]
            public string imgblock;
        }

        private ConfigData GetDefaultConfig() {
            return new ConfigData {
                Custom = new CraftCustom {
                    title = "Craft Panel",
                    soundeffects = true,
                    sound1 = "assets/prefabs/tools/keycard/effects/swipe.prefab",
                    sound2 = "assets/bundled/prefabs/fx/build/promote_toptier.prefab",
                    sound3 = "assets/prefabs/misc/xmas/presents/effects/wrap.prefab",
                    permissionuse  = "craftpanel.use",
                    colortitle = "1.00 1.00 1.00 0.43",
                    colorbtnlist = "1.00 1.00 1.00 0.10",
                    colorbtnclose = "0.52 0.00 0.00 1.00",
                    colorbtncraft = "0.00 0.50 0.40 1.00",
                    colorbtnback = "0.30 0.30 0.80 0.90",
                    colorbtnnext = "0.30 0.30 0.80 0.90",
                    colorbgpanel = "0.2 0.2 0.2 0.95",
                    colortxtvip = "0.90 0.80 0.04 1.00",
                    coloramount = "1.00 1.00 1.00 1.00",
                    coloramountvip = "0.90 0.80 0.04 1.00",
                    imgblock = "https://i.imgur.com/KzE9uZR.png"
                },
                Craft = new List<CraftInfo> {
                    new CraftInfo {
                        name = "Recycler",
                        namecomplete = "Recycler at Home",
                        img = "https://i.imgur.com/wdVWxDB.jpg",
                        imgicon = "https://i.imgur.com/vK1dRNM.png",
                        description  = "Make your own recycler to install it on your base. You can collect it by hitting with the hammer.",
                        result = new CraftResult {
                            amount = 0,
                            command = "recycler.give {steamID}",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.recycler.use",
                        permissionVIP = "craftpanel.recycler.vip",
                        permissionNoCost = "craftpanel.recycler.nocost",
                        VIPdiscount = 10,
                        workbench = 2,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 50000,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "metal.refined",
                                amount = 300,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "gears",
                                amount = 50,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "fuse",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "techparts",
                                amount = 15,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Mini Helicopter",
                        namecomplete = "Mini Helicopter",
                        img = "https://i.imgur.com/vnZND1c.jpg",
                        imgicon = "https://i.imgur.com/nzCwmo8.png",
                        description  = "Because having your own Helicopters whenever you want is cool too.\nCraft your Helis, put them away and take them out when you need them.",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} minicopter",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.miniheli.use",
                        permissionVIP = "craftpanel.miniheli.vip",
                        permissionNoCost = "craftpanel.miniheli.nocost",
                        VIPdiscount = 25,
                        workbench = 0,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 5000,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "propanetank",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "gears",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "roadsigns",
                                amount = 5,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "sheetmetal",
                                amount = 10,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Scrap Helicopter",
                        namecomplete = "Scrap Helicopter",
                        img = "https://i.imgur.com/L1XrkSv.jpg",
                        imgicon = "https://i.imgur.com/qW9mNti.png",
                        description  = "Scrap Helicopter is the father of the Minicopter, it has two seats in the front and plenty of room in the rear for gamers to huddle.\n\nIt has 2500 horsepower and consumes more low-grade fuel. I wouldn't recommend putting yourself under one ...",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} scrap",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.scrapheli.use",
                        permissionVIP = "craftpanel.scrapheli.vip",
                        permissionNoCost = "craftpanel.scrapheli.nocost",
                        VIPdiscount = 15,
                        workbench = 1,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 10000,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "metal.refined",
                                amount = 50,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "gears",
                                amount = 15,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "propanetank",
                                amount = 15,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "roadsigns",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "sheetmetal",
                                amount = 20,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "fuse",
                                amount = 1,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Sentry Turret",
                        namecomplete = "Sentry Turret",
                        img = "https://i.imgur.com/yMmmvuO.jpg",
                        imgicon = "https://i.imgur.com/en1TJ0X.png",
                        description  = "I know, you've always dreamed of having a turret like the one in the Outpost at your base. Now you can protect your rooftop with this electronic marvel that can hold up to 2 C4 or 6 Missiles.",
                        result = new CraftResult {
                            amount = 0,
                            command = "sentryturrets.give {steamID}",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.sentryturret.use",
                        permissionVIP = "craftpanel.sentryturret.vip",
                        permissionNoCost = "craftpanel.sentryturret.nocost",
                        VIPdiscount = 10,
                        workbench = 3,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 30000,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "metal.refined",
                                amount = 500,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "gears",
                                amount = 20,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "techparts",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "cctv.camera",
                                amount = 5,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "targeting.computer",
                                amount = 5,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "weapon.mod.lasersight",
                                amount = 1,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "lmg.m249",
                                amount = 1,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Boat",
                        namecomplete = "Boat",
                        img = "https://i.imgur.com/47tq7JF.jpg",
                        imgicon = "https://i.imgur.com/kk5zMmT.png",
                        description  = "A small portable wooden boat so that you can set sail the seas in search of the oil company and then collect it.",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} boat",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.boat.use",
                        permissionVIP = "craftpanel.boat.vip",
                        permissionNoCost = "craftpanel.boat.nocost",
                        VIPdiscount = 5,
                        workbench = 1,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 500,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "scrap",
                                amount = 125,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Lancha RHIB",
                        namecomplete = "Lancha RHIB",
                        img = "https://i.imgur.com/223ufKc.jpg",
                        imgicon = "https://i.imgur.com/NTeqZiM.png",
                        description  = "Because going to the Ship or the Oil is sometimes a bit screwed up.\nWhy don't you leave the house with your own boat?",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} rhib",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.rhib.use",
                        permissionVIP = "craftpanel.rhib.vip",
                        permissionNoCost = "craftpanel.rhib.nocost",
                        VIPdiscount = 5,
                        workbench = 1,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 1500,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "metal.refined",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "scrap",
                                amount = 100,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "sheetmetal",
                                amount = 5,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Submarine Solo",
                        namecomplete = "Submarine Solo",
                        img = "https://i.imgur.com/F5UFLKB.jpg",
                        imgicon = "https://i.imgur.com/UO9tKWD.png",
                        description  = "A portable 1-seater submarine for you to place on your favorite beach shore. You can pick it up later by hitting it with a wooden hammer.",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} submarinesolo",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.submarinesolo.use",
                        permissionVIP = "craftpanel.submarinesolo.vip",
                        permissionNoCost = "craftpanel.submarinesolo.nocost",
                        VIPdiscount = 5,
                        workbench = 1,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 2500,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "scrap",
                                amount = 300,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Submarine Duo",
                        namecomplete = "Submarine Duo",
                        img = "https://i.imgur.com/8nuFwuy.jpg",
                        imgicon = "https://i.imgur.com/cJGnI2L.png",
                        description  = "A portable 2-seater submarine for you to place on your favorite beach shore. You can pick it up later by hitting it with a wooden hammer.",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} submarineduo",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.submarineduo.use",
                        permissionVIP = "craftpanel.submarineduo.vip",
                        permissionNoCost = "craftpanel.submarineduo.nocost",
                        VIPdiscount = 5,
                        workbench = 2,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 3500,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "metal.refined",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "scrap",
                                amount = 400,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "sheetmetal",
                                amount = 5,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Quarry",
                        namecomplete = "Mining Quarry",
                        img = "https://i.imgur.com/CaHgjk4.jpg",
                        imgicon = "https://i.imgur.com/n6EJtNj.png",
                        description  = "We know that the giant excavator is the key to collecting resources, but with these quarries if you are lucky with the prospecting charges you can collect resources near your base.",
                        result = new CraftResult {
                            amount = 1,
                            command = "",
                            shortname = "mining.quarry",
                            skinID = 0
                        },
                        permission  = "craftpanel.quarry.use",
                        permissionVIP = "craftpanel.quarry.vip",
                        permissionNoCost = "craftpanel.quarry.nocost",
                        VIPdiscount = 5,
                        workbench = 1,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 3000,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "metal.refined",
                                amount = 25,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "gears",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "wood",
                                amount = 5000,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "sheetmetal",
                                amount = 10,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Super Card",
                        namecomplete = "Super Card",
                        img = "https://i.imgur.com/EGkxhc0.jpg",
                        imgicon = "https://i.imgur.com/9QzPQsR.png",
                        description  = "The Super card makes it possible to replace all cards (green, blue, red) with one universal card and open absolutely any door (fuse is still needed).",
                        result = new CraftResult {
                            amount = 0,
                            command = "supercard.give {steamID}",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.supercard.use",
                        permissionVIP = "craftpanel.supercard.vip",
                        permissionNoCost = "craftpanel.supercard.nocost",
                        VIPdiscount = 5,
                        workbench = 2,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "scrap",
                                amount = 350,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "metal.refined",
                                amount = 10,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Car 2",
                        namecomplete = "2 Module Car",
                        img = "https://i.imgur.com/pWfG1jf.jpg",
                        imgicon = "https://i.imgur.com/KuZIQAR.png",
                        description  = "Make your own random car with 2 modules.",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} car2",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.car2.use",
                        permissionVIP = "craftpanel.car2.vip",
                        permissionNoCost = "craftpanel.car2.nocost",
                        VIPdiscount = 5,
                        workbench = 1,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 1500,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "scrap",
                                amount = 100,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "sheetmetal",
                                amount = 10,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "gears",
                                amount = 2,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Car 3",
                        namecomplete = "3 Module Car",
                        img = "https://i.imgur.com/Oynpu1r.jpg",
                        imgicon = "https://i.imgur.com/rSQnsSc.png",
                        description  = "Make your own random car with 3 modules.",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} car3",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.car3.use",
                        permissionVIP = "craftpanel.car3.vip",
                        permissionNoCost = "craftpanel.car3.nocost",
                        VIPdiscount = 5,
                        workbench = 1,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 3000,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "scrap",
                                amount = 200,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "sheetmetal",
                                amount = 15,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "gears",
                                amount = 3,
                                skinID = 0
                            }
                        }
                    },
                    new CraftInfo {
                        name = "Car 4",
                        namecomplete = "4 Module Car",
                        img = "https://i.imgur.com/7PaVLkk.jpg",
                        imgicon = "https://i.imgur.com/hyW79Pc.png",
                        description  = "Make your own random car with 4 modules.",
                        result = new CraftResult {
                            amount = 0,
                            command = "portablevehicles.give {steamID} car4",
                            shortname = "",
                            skinID = 0
                        },
                        permission  = "craftpanel.car4.use",
                        permissionVIP = "craftpanel.car4.vip",
                        permissionNoCost = "craftpanel.car4.nocost",
                        VIPdiscount = 5,
                        workbench = 1,
                        items = new List<CraftInfoItem> {
                            new CraftInfoItem {
                                item = "metal.fragments",
                                amount = 3500,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "scrap",
                                amount = 250,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "sheetmetal",
                                amount = 20,
                                skinID = 0
                            },
                            new CraftInfoItem {
                                item = "gears",
                                amount = 4,
                                skinID = 0
                            }
                        }
                    },
                }
            };
        }

        protected override void LoadConfig(){
            base.LoadConfig();
            try {
                config = Config.ReadObject<ConfigData>();
                if (config == null){
                    LoadDefaultConfig();
                }
                craftList = config.Craft;
            } catch {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig(){
            config = GetDefaultConfig();
        }

        protected override void SaveConfig(){
            Config.WriteObject(config);
        }
        #endregion

        #region Resources
        private class IngredientData{
            public int amount;
            public List<Item> items = new List<Item>();
            public ulong skin;
        }

        private bool CanCraftItem(BasePlayer player, int craftitem) {
            var craft = config.Craft[craftitem];
            int discount = craft.VIPdiscount;

            if(craft.workbench <= player.currentCraftLevel){
                //Puts("Nivel necesario y lo tiene." + player.currentCraftLevel);
            } else {
                OpenPanelError(player, Lang("NoWorkbench", player.UserIDString, craft.workbench));
                return false;
            }

            if (permission.UserHasPermission(player.UserIDString, craft.permissionNoCost) == true){
                return true;
            }

            var costes = craft.items;
            var existing = GetExistingIngredients(player.inventory.AllItems());
            if (HasIngredients(existing, costes, permission.UserHasPermission(player.UserIDString, craft.permissionVIP), discount)){
                TakeIngredients(existing, costes, permission.UserHasPermission(player.UserIDString, craft.permissionVIP), discount);
                return true;
            } else {
                OpenPanelError(player, Lang("NoResources", player.UserIDString));
                return false;
            }
        }

        private Dictionary<string, IngredientData> GetExistingIngredients(Item[] items){
            var existing = new Dictionary<string, IngredientData>();
            foreach (var item in items){
                var name = item.info.shortname;
                existing.TryAdd(name, new IngredientData());
                existing[name].amount += item.amount;
                existing[name].skin = item.skin;
                existing[name].items.Add(item);
                //Puts("Inventario: " + name + " Name: " + item.skin.ToString());
            }
            return existing;
        }

        private bool HasIngredients(Dictionary<string, IngredientData> existing, List<CraftInfoItem> cost, bool vip, int discount){
            foreach (var ingredient in cost){
                var NameCost = ingredient.item;
                //Puts("Nombre de Costo: " + NameCost + " Skin que te pido: " + ingredient.skinID.ToString());
                if (!existing.ContainsKey(NameCost)){
                    return false;
                }
                if (ingredient.skinID != 0){
                    //Puts("Se pide una Skin especifica");
                    if (existing[NameCost].skin != ingredient.skinID){
                        //Puts("Las skins no coinciden");
                        return false;
                    }
                }
                var TotalAmount = 0;
                if(vip){
                    TotalAmount = ingredient.amount - ((ingredient.amount*discount)/100);
                } else {
                    TotalAmount = ingredient.amount;
                }
                if (existing[NameCost].amount < TotalAmount){
                    return false;
                }
            }
            return true;
        }

        private void TakeIngredients(Dictionary<string, IngredientData> existing, List<CraftInfoItem> cost, bool vip, int discount){
            foreach (var ingredient in cost){
                var NameCost = ingredient.item;
                var TotalAmount = 0;
                if(vip){
                    TotalAmount = ingredient.amount - ((ingredient.amount*discount)/100);
                } else {
                    TotalAmount = ingredient.amount;
                }
                
                var items = existing[NameCost].items;
                foreach (var item in items){
                    if (TotalAmount == 0){
                        break;
                    }
                    if (ingredient.skinID != 0){
                        //Puts("Se quita una Skin especifica");
                        if (existing[NameCost].skin != item.skin){
                            //Puts("Las skins para quitar no coinciden");
                            continue;
                        }
                    }
                    if (item.amount > TotalAmount){
                        item.amount -= TotalAmount;
                        break;
                    } else {
                        TotalAmount -= item.amount;
                        item.GetHeldEntity()?.Kill();
                        item.DoRemove();
                    }
                }
            }
        }

        #endregion

        #region Language
        protected override void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                ["Close"] = "CLOSE",
                ["Craft"] = "CRAFT ITEM",
                ["VIP"] = "For being VIP you have a Discount of {0}%",
                ["Workbench"] = "Workbench Level {0}",
                ["NoWorkbench"] = "You need the Level {0} Workbench",
                ["NoResources"] = "You do not have the necessary materials.",
                ["NotAllowed"] = "You do not have permission to use this command.",
                ["MessageResponse"] = "CraftPanel is waiting for ImageLibrary downloads to finish please wait.",
                ["WithoutPermission"] = "No permissions.",
                ["Back"] = "BACK",
                ["Next"] = "NEXT",
            }, this);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        private void PrintToChat(BasePlayer player, string message) => Player.Message(player, "<color=#f74d31>CraftPanel:</color> " + message);
        #endregion
    }
}

// --- End of file: CraftPanel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RainbowName.cs ---
// --- Original Local Path: RainbowName.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Rainbow Name", "sami37", "1.0.3")]
    [Description("Set your vip a special color name")]
    public class RainbowName : RustPlugin
    {
        [PluginReference] Plugin BetterChat;
        private string colors;
        private List<string> colorsList = new List<string>();
        private Random rand = new Random();
        private DynamicConfigFile PDATA;
        PlayersData pdata;

        public class PlayersData
        {
            public Dictionary<string, bool> StatePlayers = new Dictionary<string, bool>();
        }

        #region config

        void Init()
        {
            permission.RegisterPermission("rainbowname.color", this);
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadConfig();
        }

        #endregion

        void Loaded()
        {
            PDATA = Interface.Oxide.DataFileSystem.GetFile(this.Title + "_Player");
            pdata = PDATA.ReadObject<PlayersData>();
            if (pdata?.StatePlayers == null)
                pdata = new PlayersData();
            Unsubscribe(nameof(OnBetterChat));
            LoadConfig();
        }

        string ListToString<T>(List<T> list, int first = 0, string seperator = ", ")
        {
            return string.Join(seperator, list.Select(val => val.ToString()).Skip(first).ToArray());
        }

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = new List<string>();
            foreach (var arg in args)
                stringArgs.Add(arg.ToString());

            stringArgs.RemoveAt(args.Length - 1);
            if (Config.Get(stringArgs.ToArray()) == null)
                Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = new List<string>();
            foreach (var arg in args)
                stringArgs.Add(arg.ToString());

            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError(
                    $"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T) Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        void LoadConfig()
        {
            SetConfig("General", "Color List", "#20b2aa,#e0eee0,#333333,#474747,#aeeeee,#7ccd7c,#bcd2ee,#ee7942,#ffc1c1,#228b22,#454545,#eecbad,#ff83fa,#00ffff,#9e9e9e,#7a7a7a,#ff6a6a,#a52a2a,#f08080,#838b8b,#050505,#eee5de,#cdb38b,#00b2ee,#8b7355,#ffffe0,#a3a3a3,#8b814c,#b5b5b5,#cdc9a5");
            SaveConfig();

            colors = GetConfig(
                "#20b2aa,#e0eee0,#333333,#474747,#aeeeee,#7ccd7c,#bcd2ee,#ee7942,#ffc1c1,#228b22,#454545,#eecbad,#ff83fa,#00ffff,#9e9e9e,#7a7a7a,#ff6a6a,#a52a2a,#f08080,#838b8b,#050505,#eee5de,#cdb38b,#00b2ee,#8b7355,#ffffe0,#a3a3a3,#8b814c,#b5b5b5,#cdc9a5",
                "General", "Color List");
            colorsList = colors.Split(',').ToList();
        }

        bool BetterChatIns() => (BetterChat != null);

        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            if (BetterChatIns()) return null;
            BasePlayer player = (BasePlayer)arg.Connection.player;
            if (pdata.StatePlayers.ContainsKey(player.UserIDString) && pdata.StatePlayers[player.UserIDString] == false)
                return null;
            if (!permission.UserHasPermission(player.UserIDString, "rainbowname.color")) return null;
            string charName = StripRichText(player.displayName);
            string[] stringarry = new string[charName.Length];
            for (int i = 0; i < charName.Length; i++)
            {
                stringarry[i] = charName[i].ToString();
            }
            for (int i = 0; i < stringarry.Length; i++)
            {
                stringarry[i] = "<color=" + colorsList.ElementAt(rand.Next(0, colorsList.Count)) + ">" + stringarry[i] + "</color>";
            }

            string argMsg = arg.GetString(0, "text");

            string message = string.Join("", stringarry) + " : " + argMsg;

            Server.Broadcast(message, player.userID);

            return true;
        }

        private object OnBetterChat(Dictionary<string, object> data)
        {
            IPlayer player = data["Player"] as IPlayer;
            if (player != null && !permission.UserHasPermission(player.Id, "rainbowname.color")) return null;
            if (pdata.StatePlayers.ContainsKey(player.Id) && pdata.StatePlayers[player.Id] == false)
                return null;
            string charName = player.Name;
            string[] stringarry = new string[charName.Length];
            for (int i = 0; i < charName.Length; i++)
            {
                stringarry[i] = charName[i].ToString();
            }
            for (int i = 0; i < stringarry.Length; i++)
            {
                stringarry[i] = "<color=" + colorsList.ElementAt(rand.Next(0, colorsList.Count)) + ">" + stringarry[i] + "</color>";
            }

            data["Username"] = string.Join("", stringarry).Replace("[", "<").Replace("]", ">");
            data["Player"] = player;

            return data;
        }

        private string StripRichText(string text)
        {
            text = Regex.Replace(text, "<.*?>", String.Empty);
            return Formatter.ToPlaintext(text);
        }

        [ChatCommand("rn")]
        void CmdChat(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                SendReply(player, "Syntax: /rn on|off");
                return;
            }
            if (args.Length > 0)
            {
                if (args[0].ToLower() == "on")
                {
                    if (!pdata.StatePlayers.ContainsKey(player.UserIDString))
                    {
                        pdata.StatePlayers.Add(player.UserIDString, true);
                        return;
                    }

                    pdata.StatePlayers[player.UserIDString] = true;
                }
                else if (args[0].ToLower() == "off")
                {
                    if (!pdata.StatePlayers.ContainsKey(player.UserIDString))
                    {
                        pdata.StatePlayers.Add(player.UserIDString, false);
                        return;
                    }

                    pdata.StatePlayers[player.UserIDString] = false;
                }
            }
        }
    }
}

// --- End of file: RainbowName.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingWorkbench.cs ---
// --- Original Local Path: BuildingWorkbench.cs ---

﻿using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Building Workbench", "", "1.1.2")]
    [Description("Расширяет диапазон верстака для работы внутри всего здания")]
    public class BuildingWorkbench : RustPlugin
    {
        #region Class Fields
        [PluginReference] private readonly Plugin GameTipAPI;

        private PluginConfig _pluginConfig; //Plugin Config

        private TriggerBase _triggerBase;
        private GameObject _object;

        private const string UsePermission = "buildingworkbench.use";
        private const string CancelCraftIgnorePermission = "buildingworkbench.cancelcraftignore";
        private const string AccentColor = "#de8732";

        private readonly List<ulong> _notifiedPlayer = new List<ulong>();
        private readonly Hash<ulong, int> _playerLevel = new Hash<ulong, int>();

        private Coroutine _routine;

        private bool _init;
        #endregion

        #region Setup & Loading
        private void Init()
        {
            permission.RegisterPermission(UsePermission, this);
            permission.RegisterPermission(CancelCraftIgnorePermission, this);
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Chat] = $"<color=#bebebe>[<color={AccentColor}>{Title}</color>] {{0}}</color>",
                [LangKeys.Notification] = "Ваш верстак был увеличен для работы внутри вашего здания",
                [LangKeys.CraftCanceled] = "Ваше крафт был отменён, потому что вы покинули здание"
            }, this);
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = Config.ReadObject<PluginConfig>();
            Config.WriteObject(_pluginConfig);
        }

        private void OnServerInitialized()
        {
             _object = new GameObject("BuildingWorkbenchObject");
             _triggerBase = _object.AddComponent<TriggerBase>();
            
            
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
            
            InvokeHandler.Instance.InvokeRepeating(StartUpdatingWorkbench, 1f, _pluginConfig.UpdateRate);
            
            _init = true;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.triggers == null || !player.triggers.Contains(_triggerBase))
            {
                player.EnterTrigger(_triggerBase);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            player.LeaveTrigger(_triggerBase);
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                player.LeaveTrigger(_triggerBase);
            }
            
            InvokeHandler.Instance.CancelInvoke(StartUpdatingWorkbench);
            if (_routine != null)
            {
                InvokeHandler.Instance.StopCoroutine(_routine);
            }
            
            GameObject.Destroy(_object);
        }
        #endregion

        #region Workbench Handler

        private void StartUpdatingWorkbench()
        {
            if (BasePlayer.activePlayerList.Count == 0)
            {
                return;
            }
            
            _routine = InvokeHandler.Instance.StartCoroutine(HandleWorkbenchUpdate());
        }

        private IEnumerator HandleWorkbenchUpdate()
        {
            Hash<uint, int> benchCache = new Hash<uint, int>();
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                BasePlayer player = BasePlayer.activePlayerList[i];
                yield return null;

                if (!HasPermission(player, UsePermission))
                {
                    continue;
                }
                
                UpdatePlayerPriv(player, benchCache);
            }
        }

        private void UpdatePlayerPriv(BasePlayer player, Hash<uint, int> cache = null)
        {
            BuildingPrivlidge priv = player.GetBuildingPrivilege();
            if (priv == null || !priv.IsAuthed(player))
            {
                if (_playerLevel[player.userID] != 0)
                {
                    UpdatePlayerBench(player, 0, 0f);
                    OnPlayerLeftBuilding(player);
                }
                
                return;
            }

            int level;
            if (cache != null && cache.ContainsKey(priv.buildingID))
            {
                level = cache[priv.buildingID];
            }
            else
            {
                level = GetBuildingWorkbenchLevel(priv.buildingID);
                if (cache != null)
                {
                    cache[priv.buildingID] = level;
                }
            }

            UpdatePlayerBench(player, level, _pluginConfig.UpdateRate);
        }

        private void UpdatePlayerBench(BasePlayer player, int level, float checkOffset)
        {
            player.nextCheckTime = Time.realtimeSinceStartup + checkOffset + .5f;
            player.cachedCraftLevel = level;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, level == 1);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, level == 2);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, level == 3);
            player.SendNetworkUpdateImmediate();
            _playerLevel[player.userID] = level;
        }

        private void UpdateNearbyPlayers(Vector3 pos, uint buildingId, BasePlayer player = null)
        {
            NextTick(() =>
            {
                int level = GetBuildingWorkbenchLevel(buildingId);
                float duration = level == 0 ? 0 : _pluginConfig.UpdateRate;
                BuildingPrivlidge priv = BuildingManager.server.GetBuilding(buildingId)?.GetDominatingBuildingPrivilege();
                if (priv == null)
                {
                    return;
                }

                foreach (BasePlayer buildingPlayer in BaseNetworkable.GetConnectionsWithin(pos, 50f).Select(c => (BasePlayer)c.player))
                {
                    if (priv.IsAuthed(buildingPlayer))
                    {
                        UpdatePlayerBench(buildingPlayer, level, duration);
                    }
                }
            });
        }

        private void OnPlayerLeftBuilding(BasePlayer player)
        {
            if (_pluginConfig.CancelCraft && !HasPermission(player, CancelCraftIgnorePermission) && player.inventory.crafting.queue.Count != 0)
            {
                player.inventory.crafting.CancelAll(true);
                if (_pluginConfig.CancelCraftNotification)
                {
                    Chat(player, Lang(LangKeys.CraftCanceled, player));
                }
            }
        }
        #endregion

        #region Oxide Hooks
        private void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
        {
            BasePlayer player = entity.ToPlayer();
            if (player != null && trigger == _triggerBase)
            {
                player.EnterTrigger(_triggerBase);
            }
        }

        private void OnEntitySpawned(Workbench bench)
        {
            if (!_init)
            {
                return;
            }
            
            BasePlayer player = BasePlayer.FindByID(bench.OwnerID);
            if (player == null)
            {
                return;
            }
            
            UpdateNearbyPlayers(bench.transform.position, bench.buildingID, player);

            if (!_pluginConfig.EnableNotifications)
            {
                return;
            }
            
            if (_notifiedPlayer.Contains(player.userID))
            {
                return;
            }
            
            _notifiedPlayer.Add(player.userID);
            
            if (GameTipAPI == null)
            {
                Chat(player, Lang(LangKeys.Notification, player));
            }
            else
            {
                GameTipAPI.Call("ShowGameTip", player, Lang(LangKeys.Notification, player), 6f);
            }
        }

        private void OnEntityKill(Workbench bench)
        {
            if (!_init)
            {
                return;
            }
            
            UpdateNearbyPlayers(bench.transform.position, bench.buildingID);
        }
        
        private void OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            OnAuthChanged(player);
        }
        
        private void OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            OnAuthChanged(player);
        }
        
        private void OnAuthChanged(BasePlayer player)
        {
            NextTick(() =>
            {
                UpdatePlayerPriv(player);
            });
        }

        private void OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
        {
            NextTick(() =>
            {
                Hash<uint, int> cache = new Hash<uint, int>();
                foreach (BasePlayer nearbyPlayers in BaseNetworkable.GetConnectionsWithin(privilege.transform.position, 50f).Select(c => (BasePlayer)c.player))
                {
                    UpdatePlayerPriv(nearbyPlayers, cache);
                }
            });
        }
        #endregion

        #region Helper Methods

        private int GetBuildingWorkbenchLevel(uint buildingId)
        {
            return BuildingManager.server.GetBuilding(buildingId)?.decayEntities
                .OfType<Workbench>()
                .Select(bench => bench.Workbenchlevel)
                .Concat(new[] {0})
                .Max() ?? 0;
        }

        private void Chat(BasePlayer player, string format, params object[] args) => PrintToChat(player, Lang(LangKeys.Chat, player, format), args);
        
        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        
        private string Lang(string key, BasePlayer player = null, params object[] args) => string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
        #endregion

        #region Classes
        private class PluginConfig
        {
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Enable Notifications")]
            public bool EnableNotifications { get; set; }
            
            [DefaultValue(false)]
            [JsonProperty(PropertyName = "Cancel craft when leaving building")]
            public bool CancelCraft { get; set; }
            
            [DefaultValue(true)]
            [JsonProperty(PropertyName = "Cancel craft notification")]
            public bool CancelCraftNotification { get; set; }
            
            [DefaultValue(3f)]
            [JsonProperty(PropertyName = "Update Rate (Seconds)")]
            public float UpdateRate { get; set; }
        }
        
        private class LangKeys
        {
            public const string Chat = "Chat";
            public const string Notification = "Notification";
            public const string CraftCanceled = "CraftCanceled";
        }
        #endregion
    }
}


// --- End of file: BuildingWorkbench.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SSkin.cs ---
// --- Original Local Path: SSkin.cs ---

using CompanionServer;
using Facepunch.Extend;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Plugins.Extension;
using Oxide.Plugins.Helper;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using VLB;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
	/*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ /*ПЛАГИН БЫЛ ПОФИКШЕН С ПОМОЩЬЮ ПРОГРАММЫ СКАЧАНОЙ С https://discord.gg/dNGbxafuJn */ [Info("SSkin", "https://discord.gg/dNGbxafuJn", "1.1.3")]
	internal class SSkin : RustPlugin
	{
		private readonly Dictionary<ulong, BaseEntity> _startUseMenu = new Dictionary<ulong, BaseEntity>();

		#region Configuration
		private class Configuration : Sigleton<Configuration>
		{
			public bool AddApproved;
			public bool AddHazmat;

			public string DefaultSkinsPermission;

			public Grades GradesSettings;
			public Hammer HammerSettings;
			public Command SkinCommand;
			public Command SkinEntityCommand;

			public Dictionary<string, List<ulong>> PermissionSkins;

			public class Grades
			{
				public List<BuildingGrade> Array;
				public string Permission;
			}

			public class BuildingGrade
			{
				public string Name;
				public List<SkinUrl> Skins;
			}

			public class SkinUrl : Skin.Skin
			{
				public string Url;
			}

			public class Hammer
			{
				public string OpenSkinEntityPermission;
				public BUTTON OpenSkinEntityButton;
                public BUTTON OpenSkinBuildingButton;
                public string ChangeSkinPressLeftButtonPermission;
			}

			public class Command
			{
				public List<string> Commands;
				public string Permission;
			}

			public List<ulong> GetBlockPermissionSkins(BasePlayer player)
			{
				List<ulong> items = new List<ulong>();

				foreach (var perm in PermissionSkins)
				{
					if (player.HasPermission(perm.Key))
						continue;

					items.AddRange(perm.Value);
				}

				return items;
			}

			public List<ulong> GetPermissionSkins(BasePlayer player)
			{
				List<ulong> items = new List<ulong>();

				foreach (var perm in PermissionSkins)
				{
					if (player.HasPermission(perm.Key))
						items.AddRange(perm.Value);
				}

				return items;
			}

			public void SetDefaultConfig()
			{
				AddApproved = true;
				AddHazmat = true;

				DefaultSkinsPermission = "defaultskins.use";

				GradesSettings = new Grades()
				{
					Array = new List<BuildingGrade>()
					{
						new BuildingGrade()
						{
							Name = "Stone",
							Skins = new List<SkinUrl>()
							{
								new SkinUrl()
								{
									Name = "Default Stone",
									Id = 0,
									Url = "https://rustlabs.com/img/items180/stones.png"
								},
								new SkinUrl()
								{
									Name = "Upgrade Stone",
									Id = 10220,
									Url = "https://media.discordapp.net/attachments/1103353725772386318/1111205056520388608/IMG_9516.png",
								},
								new SkinUrl()
								{
									Name = "Upgrade Stone",
									Id = 10223,
									Url = "https://i.ibb.co/0JPt5Xq/777.png",
								}
							}
						},
						new BuildingGrade()
						{
							Name = "Metal",
							Skins = new List<SkinUrl>()
							{
								new SkinUrl()
								{
									Name = "Default Metal",
									Id = 0,
									Url = "https://rustlabs.com/img/items180/metal.refined.png"
								},
								new SkinUrl()
								{
									Name = "Upgrade Metal",
									Id = 10221,
									Url = "https://media.discordapp.net/attachments/1090555264106770513/1114467883943215164/512fx512f.png",
								}
							}
						}
					},
					Permission = "gradesetting.use"
				};

				PermissionSkins = new Dictionary<string, List<ulong>>()
				{
					{
						"testperm",
						new List<ulong>()
						{
							1
						}
					}
				};

				HammerSettings = new Hammer()
				{
					ChangeSkinPressLeftButtonPermission = "changeskinpressleftbutton.use",
					OpenSkinEntityPermission = "openskinentity.use",
					OpenSkinEntityButton = BUTTON.FIRE_SECONDARY,
					OpenSkinBuildingButton = BUTTON.USE,
				};

				SkinCommand = new Command()
				{
					Commands = new List<string>() { "skin" },
					Permission = "skincommand.use"
				};

				SkinEntityCommand = new Command()
				{
					Commands = new List<string>() { "skinentity", "se" },
					Permission = "skinentitycommand.use"
				};
			}
		}

		protected override void LoadDefaultConfig()
		{
			if (Configuration.Instance == null)
				new Configuration();

			Configuration.Instance.SetDefaultConfig();
		}
		protected override void SaveConfig()
		{
			Config.WriteObject(Configuration.Instance);
		}
		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				Configuration.Instance = Config.ReadObject<Configuration>();
			}
			catch
			{
				LoadDefaultConfig();
			}

			NextTick(SaveConfig);
		}
		#endregion

		#region Lang
		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>()
			{
				["NOPERMUSE"] = "У вас нет прав на использование команды!",
				["LABLEMENUTEXT"] = "МЕНЮ СКИНОВ",
				["INFOCLICKSKIN"] = "Нажмите на предмет,\nна который нужно установить скин",
				["FAVSKINSLABLE"] = "ИЗБРАННЫЕ СКИНЫ",
				["NOTYOUREBUILD"] = "Этот предмет не ваш"
			}, this, "ru");

			lang.RegisterMessages(new Dictionary<string, string>()
			{
				["NOPERMUSE"] = "You don't have the rights to use the command!",
				["LABLEMENUTEXT"] = "Menu Skin",
				["INFOCLICKSKIN"] = "Click on the item you want to install the skin on",
				["FAVSKINSLABLE"] = "SKINS FAVORITAS",
				["NOTYOUREBUILD"] = "This item is not yours"
			}, this, "en");
		}

		#endregion

		#region Hooks
		private void Loaded()
		{
			new Items().Load();
			new Players().Load();
		}

		private void OnServerInitialized()
		{
			new SSkinWeb(this);
			new ImageLibrary(plugins.Find("ImageLibrary"));
			new SSkinLang(this);
			new InterfaceBuilder();
			new Helper();

			foreach (var command in Configuration.Instance.SkinCommand.Commands)
				cmd.AddChatCommand(command, this, SkinCommand);

			foreach (var command in Configuration.Instance.SkinEntityCommand.Commands)
				cmd.AddChatCommand(command, this, SkinEntityCommand);

			NextTick(() =>
			{
				if (Configuration.Instance.AddHazmat)
				{
					Items.Instance.LoadSkinHazmats();
				}

				if (Configuration.Instance.AddApproved)
				{
					Items.Instance.LoadSkinDefines();
					Items.Instance.LoadApprovedSkin();
					Items.Instance.Unload();
				}
			});

			BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);

			ImageLibrary.Instance.AddImage($"https://i.ibb.co/XX5ntbr/grid.png", "grid2");

			RegisterPermission(Configuration.Instance.DefaultSkinsPermission);
			RegisterPermission(Configuration.Instance.HammerSettings.OpenSkinEntityPermission);
			RegisterPermission(Configuration.Instance.HammerSettings.ChangeSkinPressLeftButtonPermission);
			RegisterPermission(Configuration.Instance.SkinCommand.Permission);
			RegisterPermission(Configuration.Instance.SkinEntityCommand.Permission);
			RegisterPermission(Configuration.Instance.GradesSettings.Permission);

			foreach (var perm in Configuration.Instance.PermissionSkins)
			{
				RegisterPermission(perm.Key);

				foreach (var skin in perm.Value)
				{
					if (skin > 0)
						SSkinWeb.Instance.DownloadSkin(skin);
				}
			}

			if (Configuration.Instance.GradesSettings.Array.Count > 0)
			{
				foreach (var grade in Configuration.Instance.GradesSettings.Array)
				{
					foreach (var skin in grade.Skins)
					{
						ImageLibrary.Instance.AddImage(skin.Url, skin.Name);
					}

					if (Items.Instance.Get(grade.Name) != null) continue;

					Items.Instance.Add(grade.Name).Skins = grade.Skins.Select(s => new Skin.Skin() { Name = s.Name, Id = s.Id }).ToList();
				}
			}
		}

		private void OnPlayerConnected(BasePlayer player)
		{
			player.gameObject.GetOrAddComponent<OpenMenuButton>();

			if (Players.Instance.Get(player.userID) == null)
				Players.Instance.Value.Add(new Player.Player() { SteamId = player.userID });
		}

		private void OnPlayerDisconnected(BasePlayer player, string reason) 
		{
			var openMenuButton = player.gameObject.GetComponent<OpenMenuButton>();
			if (openMenuButton == null) return;
			openMenuButton.Destroy();
		}

		private void Unload()
		{
			Items.Instance.Unload();
			Players.Instance.Unload();

			if (_startUseMenu.Count > 0)
				_startUseMenu.Keys.ToList().ForEach(s =>
				{
					var basePlayer = Player.FindById(s);
					InterfaceBuilder.Instance.DestroyAllUI(basePlayer);
					basePlayer.EndLooting();
					OnPlayerDisconnected(basePlayer, "");
				});
		}

		private void CanWearItem(PlayerInventory inventory, Item item, int targetSlot) => CanEquipItem(inventory, item, targetSlot);

		private void CanEquipItem(PlayerInventory inventory, Item item, int targetPos)
		{
			if (inventory.baseEntity == null || item == null || !inventory.baseEntity.userID.IsSteamId()) return;

			var player = inventory.baseEntity.ToPlayer();

			if (player == null) return;

			var blockedSkins = Configuration.Instance.GetBlockPermissionSkins(player);

			var playerData = Players.Instance.Get(inventory.baseEntity.userID);

            if (!player.HasPermission(Configuration.Instance.DefaultSkinsPermission) || !playerData.DefaultSkins.ContainsKey(item.info.shortname))
			{
				if (blockedSkins.Contains(item.skin))
				{
					item.SetItemSkin(0);
					player.SendNetworkUpdate();
				}
				return;
			}

            playerData.SetDefaultSkin(item);
			player.SendNetworkUpdate();
		}

		private void OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
		{
			if (entity == null || player == null) return;

			if (entity.OwnerID != player.userID && !(player.Team != null && player.Team.members.Contains(entity.OwnerID))) return;

			if (!player.HasPermission(Configuration.Instance.DefaultSkinsPermission)) return;

			if (player.HasPermission(Configuration.Instance.GradesSettings.Permission) && entity is BuildingBlock)
			{
				var block = entity as BuildingBlock;

				if ((!player.CanBuild())) return;

				if (Items.Instance.Get(block.grade.ToString()) == null) return;

				Players.Instance.Get(player.userID).SetDefaultSkin(block);
				player.SendNetworkUpdateImmediate(false);
				player.ClientRPC(null, "RefreshSkin");
				return;
			}

			if (player.HasPermission(Configuration.Instance.HammerSettings.ChangeSkinPressLeftButtonPermission))
				Players.Instance.Get(player.userID).SetDefaultSkin(entity);
		}

		private void OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
		{
			if (player == null || block == null) return;

			if (!player.HasPermission(Configuration.Instance.DefaultSkinsPermission, Configuration.Instance.GradesSettings.Permission))
				return;

			if (Items.Instance.Get(grade.ToString()) == null) return;

			timer.Once(1, () =>
			{
				NextTick(() =>
				{
					Players.Instance.Get(player.userID).SetDefaultSkin(block, grade);
					player.SendNetworkUpdateImmediate(false);
					player.ClientRPC(null, "RefreshSkin");
				});
			});
		}

		private void OnItemAddedToContainer(ItemContainer container, Item item)
		{
			if (container == null || item == null || item.skin != 0 ||
				Items.Instance.Get(item.info.shortname) == null) return;

			var basePlayer = item.GetOwnerPlayer();

			if (basePlayer == null || basePlayer.IPlayer == null || basePlayer.IsNpc || !basePlayer.userID.IsSteamId()) return;

			var blockedSkins = Configuration.Instance.GetBlockPermissionSkins(basePlayer);

            var playerData = Players.Instance.Get(basePlayer.userID);

            if (!basePlayer.HasPermission(Configuration.Instance.DefaultSkinsPermission) || !playerData.DefaultSkins.ContainsKey(item.info.shortname))
            {
                if (blockedSkins.Contains(item.skin))
				{
					item.SetItemSkin(0);
					basePlayer.SendNetworkUpdate();

				}
				return;
			}

			if (container != basePlayer.inventory.containerMain
				&& container != basePlayer.inventory.containerBelt
				&& container != basePlayer.inventory.containerWear) return;

            playerData.SetDefaultSkin(item);
			basePlayer.SendNetworkUpdate();
		}

		private void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter owner)
		{
			if (task.skinID != 0) return;
			Players.Instance.Get(owner.owner.userID).SetDefaultSkin(item);
		}

		private object OnItemAction(Item item, string action, BasePlayer player)
		{
			if (_startUseMenu.ContainsKey(player.userID)) return false;
			return null;
		}

		private object CanLootPlayer(BasePlayer looted, BasePlayer looter)
		{
			if (looter == null) return null;

			if (_startUseMenu.ContainsKey(looter.userID))
				return true;

			return null;
		}

		private void OnPlayerLootEnd(PlayerLoot inventory)
		{
			if (inventory == null) return;
			var player = inventory.GetComponent<BasePlayer>();
			if (player == null || !_startUseMenu.ContainsKey(player.userID)) return;
			player.SendConsoleCommand("uiskinmenu close");
		}
		#endregion

		#region Commands

		#region ChatCommands

		private void SkinCommand(BasePlayer player, string command, string[] args)
		{
			if (!player.HasPermission(Configuration.Instance.SkinCommand.Permission))
			{
				SendReply(player, SSkinLang.Instance.Get("NOPERMUSE", player.UserIDString));
				return;
			}

			if (_startUseMenu.ContainsKey(player.userID)) return;

			timer.Once(0.5f, () =>
			{
				ItemContainer container = new ItemContainer();
				container.entityOwner = player;
				container.isServer = true;
				container.allowedContents = ItemContainer.ContentsType.Generic;
				container.GiveUID();
				_startUseMenu.Add(player.userID, null);
				container.capacity = 12;
				container.playerOwner = player;
				player.LootContainer(container);
				InterfaceBuilder.Instance.Draw(player);
			});
		}

		private void SkinEntityCommand(BasePlayer player, string command, string[] args)
		{
			if (!player.HasPermission(Configuration.Instance.SkinEntityCommand.Permission))
			{
				SendReply(player, SSkinLang.Instance.Get("NOPERMUSE", player.UserIDString));
				return;
			}

			if (_startUseMenu.ContainsKey(player.userID)) return;

			var entity = player.FindConstructioninDirectionLook();

			if (entity == null) return;

			if (entity.OwnerID != player.userID && !(player.Team != null && player.Team.members.Contains(entity.OwnerID)))
			{
				SendReply(player, SSkinLang.Instance.Get("NOTYOUREBUILD", player.UserIDString));
				return;
			}

			if(entity is BuildingBlock)
            {
				if (args.Length > 0 && args[0] != "buildings")
					return;
            }
			else
			{
				if (args.Length > 0 && args[0] != "entity")
					return;
			}

			string shortName = entity.GetShortName();

			if (string.IsNullOrEmpty(shortName)) return;

			_startUseMenu.Add(player.userID, entity);

			InterfaceBuilder.Instance.Draw(player, false);

			player.SendConsoleCommand($"uiskinmenu", new object[] { "weaponSelect", shortName, 0 });
		}
[ConsoleCommand("uiskinmenu")]
		private void ConsoleCommand(ConsoleSystem.Arg arg)
		{
			var player = arg.Player();
			if (player == null) return;
			string shortName;
			ulong skinId;
			int page;
			ulong itemId;

			var playerData = Players.Instance.Get(player.userID);

			var sound = new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3());

			switch (arg.Args[0])
			{
				case "page":
					{
						shortName = arg.Args[1];
						itemId = ulong.Parse(arg.Args[2]);
						page = arg.Args[3].ToInt();
						InterfaceBuilder.Instance.DrawSkins(player, shortName, itemId, page);
						InterfaceBuilder.Instance.DrawSelectSkins(player, shortName, itemId, page);
					}
					break;
				case "weaponSelect":
					{
						shortName = arg.Args[1];
						itemId = ulong.Parse(arg.Args[2]);

						InterfaceBuilder.Instance.DrawSkins(player, shortName, itemId, 1);
						InterfaceBuilder.Instance.DrawSelectSkins(player, shortName, itemId, 1);
					}
					break;
				case "setSelected":
					{
						shortName = arg.Args[1];
						itemId = ulong.Parse(arg.Args[2]);
						skinId = ulong.Parse(arg.Args[3]);
						page = arg.Args[4].ToInt();
						string layer = arg.Args[5];

						playerData.AddOrRemoveSelectedSkin(shortName, skinId);

						InterfaceBuilder.Instance.UpdateItem(player, shortName, itemId, skinId, page);
						//InterfaceBuilder.Instance.DrawSkins(player, shortName, itemId, page);
						InterfaceBuilder.Instance.DrawSelectSkins(player, shortName, itemId, page);
					}
					break;
				case "setdefault":
					{
						shortName = arg.Args[1];
						itemId = ulong.Parse(arg.Args[2]);
						skinId = ulong.Parse(arg.Args[3]);
						page = arg.Args[4].ToInt();
						string layer = arg.Args[5];

						if (playerData.DefaultSkins.ContainsKey(shortName))
						{
							var defaultSkinId = playerData.DefaultSkins[shortName];
							playerData.DefaultSkins[shortName] = skinId;

							if(defaultSkinId != skinId)
								InterfaceBuilder.Instance.UpdateItem(player, shortName, itemId, defaultSkinId, page);
						}
						else
							playerData.DefaultSkins.Add(shortName, skinId);

						InterfaceBuilder.Instance.UpdateItem(player, shortName, itemId, skinId, page);

						//InterfaceBuilder.Instance.DrawSkins(player, shortName, itemId, page);
						InterfaceBuilder.Instance.DrawSelectSkins(player, shortName, itemId, page);
					}
					break;
				case "setskin":
					{
						itemId = ulong.Parse(arg.Args[1]);
						skinId = ulong.Parse(arg.Args[2]);

						var entity = _startUseMenu[playerData.SteamId];

						if (entity == null)
						{
							var item = player.inventory.FindItemByUID(new ItemId(itemId));
							item.SetItemSkin(skinId);

							player.SendNetworkUpdate();
							return;
						}

						entity.SetSkin(skinId);
					}
					break;
				case "close":
					{
						InterfaceBuilder.Instance.DestroyAllUI(player);
						_startUseMenu.Remove(player.userID);
						player.EndLooting();
					}
					break;
				case "openEntityUi":
					{
						if (arg.Args.Length < 1)
							return;

						SkinEntityCommand(player, "console", new string[] { arg.Args[1] });
					}
					break;
				case "openDefaultUi":
					{
						SkinCommand(player, "console", new string[0]);
					}
					break;
			}

			EffectNetwork.Send(sound, player.Connection);
		}
		#endregion

		#endregion

		#region UI

		private interface IContainer
		{
			string OffsetMin { get; }
			string OffsetMax { get; }

			PlayerInventory.Type Type { get; }
			Tuple<string, string> GetOffsets(int index);
		}

		private class MainContainer : IContainer
		{
			public string OffsetMin => "-200 85";

			public string OffsetMax => "180 337";

			public PlayerInventory.Type Type => PlayerInventory.Type.Main;

			public Tuple<string, string> GetOffsets(int i)
			{
				var x = i * 64 - Math.Floor((double)i / 6) * 6 * 64;
				var y = Math.Floor((double)i / 6) * 63;

				return new Tuple<string, string>($"{x} {-60 - y}", $"{60 + x} {-y}");
			}
		}

		private class WearContainer : IContainer
		{
			public string OffsetMin => "-588 51";
			public string OffsetMax => "-215 115";

			public PlayerInventory.Type Type => PlayerInventory.Type.Wear;

			public Tuple<string, string> GetOffsets(int i)
			{
				var x = i * 54 - Math.Floor((double)i / 7) * 7 * 54;

				return new Tuple<string, string>($"{x} 0", $"{50 + x} 50");
			}
		}

		private class BeltContainer : IContainer
		{
			public string OffsetMin => "-200 -43";
			public string OffsetMax => "180 19";

			public PlayerInventory.Type Type => PlayerInventory.Type.Belt;

			public Tuple<string, string> GetOffsets(int i)
			{
				var x = i * 64 - Math.Floor((double)i / 6) * 6 * 64;

				return new Tuple<string, string>($"{x} 0", $"{60 + x} 60");
			}
		}

		private class DefaultInterface
		{
			private string _json = "[{\"name\":\"UiSkuliSkins\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 1\",\"anchormax\":\"0.5 1\",\"offsetmin\":\"-225 -325\",\"offsetmax\":\"615 -1\"},{\"type\":\"NeedsCursor\"}]},{\"name\":\"UiSkuliSkins-Lable\",\"parent\":\"UiSkuliSkins\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.33 0.32 0.32 1.00\",\"imagetype\":\"Tiled\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"7 -47\",\"offsetmax\":\"427 5\"}]},{\"parent\":\"UiSkuliSkins-Lable\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"%LABLEMENUTEXT%\",\"fontSize\":24,\"align\":\"MiddleCenter\",\"color\":\"0.75 0.71 0.67 1.00\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.5\",\"anchormax\":\"0 0.5\",\"offsetmin\":\"4 -30\",\"offsetmax\":\"427 25\"}]},{\"name\":\"61533899272e46f486d03ceff11413f2\",\"parent\":\"UiSkuliSkins-Lable\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"uiskinmenu close\",\"sprite\":\"assets/icons/close.png\",\"color\":\"0.75 0.75 0.75 0.65\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0.5\",\"anchormax\":\"1 0.5\",\"offsetmin\":\"5 -15\",\"offsetmax\":\"35 15\"}]},{\"name\":\"UiSkuliSkins-Search\",\"parent\":\"UiSkuliSkins\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"%INFOCLICKSKIN%\",\"fontSize\":12,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-400 -185\",\"offsetmax\":\"-35 115\"}]},{\"name\":\"UiSkuliSkins-LableIzb\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.33 0.32 0.32 1.00\",\"imagetype\":\"Tiled\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"190 235\",\"offsetmax\":\"575 290\"}]},{\"parent\":\"UiSkuliSkins-LableIzb\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"%FAVSKINSLABLE%\",\"fontSize\":24,\"align\":\"MiddleCenter\",\"color\":\"0.75 0.71 0.67 1.00\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.5\",\"anchormax\":\"0 0.5\",\"offsetmin\":\"20 -25\",\"offsetmax\":\"350 25\"}]},{\"name\":\"UiSkuliSkins-Selected\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"201 111\",\"offsetmax\":\"571 231\"}]}]";

			public DefaultInterface()
			{
				//SkuliElement skuliElement = new SkuliElement("Overlay", false);

				//var layer = skuliElement.AddChildren(new CuiPanel()
				//{
				//	RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-225 -325", OffsetMax = "615 -1" },
				//	CursorEnabled = true,
				//	Image = { Color = "0 0 0 0" }
				//}, InterfaceBuilder.Layer);

				//var lable = layer.AddChildren(new CuiPanel()
				//{
				//	Image = { Color = "0.33 0.32 0.32 1.00", ImageType = Image.Type.Tiled },
				//	RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "7 -47", OffsetMax = "427 5" }
				//}, InterfaceBuilder.Layer + "-Lable");

				//lable.AddChildren(new CuiElement()
				//{
				//	Components =
				//	{
				//		new CuiTextComponent() { Text =  "%LABLEMENUTEXT%", Align = TextAnchor.MiddleCenter, FontSize = 24, Color = "0.75 0.71 0.67 1.00" },
				//		new CuiRectTransformComponent() { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "4 -30", OffsetMax = "427 25" }
				//	}
				//});

				//layer.AddChildren(new CuiElement()
				//{
				//	Name = InterfaceBuilder.Layer + "-Search",
				//	Components =
				//	{
				//		new CuiTextComponent() { Text = "%INFOCLICKSKIN%", Color = "1 1 1 1", FontSize = 12, Align = TextAnchor.MiddleCenter },
				//		new CuiRectTransformComponent() { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 -185", OffsetMax = "-35 115" }
				//	}
				//});

				//lable.AddChildren(new CuiButton()
				//{
				//	RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "5 -15", OffsetMax = "35 15" },
				//	Button = { Color = "0.75 0.75 0.75 0.65", Command = "uiskinmenu close", Sprite = "assets/icons/close.png" },
				//	Text = { Text = "", Align = TextAnchor.MiddleCenter }
				//});

				//var lableIzb = skuliElement.AddChildren(new CuiPanel()
				//{
				//	Image = { Color = "0.33 0.32 0.32 1.00", ImageType = Image.Type.Tiled },
				//	RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "190 235", OffsetMax = "575 290" },
				//}, InterfaceBuilder.Layer + "-LableIzb");

				//lableIzb.AddChildren(new CuiElement()
				//{
				//	Components =
				//	{
				//		new CuiTextComponent() { Text = "%FAVSKINSLABLE%", Align = TextAnchor.MiddleCenter, FontSize = 24, Color = "0.75 0.71 0.67 1.00" },
				//		new CuiRectTransformComponent() { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "20 -25", OffsetMax = "350 25" }
				//	}
				//});

				//skuliElement.AddChildren(new CuiPanel()
				//{
				//	Image = { Color = "0 0 0 0" },
				//	RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "201 111", OffsetMax = "571 231" }
				//}, InterfaceBuilder.Layer + "-Selected");

				//_json = skuliElement.ToJson();
			}

			public string GetElement(string lableMenuText, string infoClickSkin, string favSkinable)
			{
				return _json.Replace("%LABLEMENUTEXT%", lableMenuText).Replace("%INFOCLICKSKIN%", infoClickSkin).Replace("%FAVSKINSLABLE%", favSkinable);
			}
		}

		private class ContainerInterface
		{
			private string _json = "[{\"name\":\"%Layer%\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"%OffsetMin%\",\"offsetmax\":\"%OffsetMax%\"}]}]";
			//	private SkuliElement _skuliElement = new SkuliElement("Overlay", false);

			public ContainerInterface()
			{
				//_skuliElement.AddChildren(new CuiPanel()
				//{
				//	Image = { Color = "0 0 0 0" },
				//	RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "%OffsetMin%", OffsetMax = "%OffsetMax%" }
				//},
				//"%Layer%");

				//Debug.Log(_skuliElement.ToJson());
			}

			public string GetElement(string offsetMin, string offsetMax, string layer)
			{
				return _json.Replace("%OffsetMin%", offsetMin).Replace("%OffsetMax%", offsetMax).Replace("%Layer%", layer);
			}
		}

		private class ContainerItemInterface //Динамический предмет 
		{
			//private SkuliElement _skuliElement = new SkuliElement("%Layer%", false);
			private string _json = "[{\"name\":\"6f1e1c3df3804b128afb75440617ec81\",\"parent\":\"%Layer%\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"uiskinmenu weaponSelect %ShortName% %SkinId%\",\"color\":\"0.65 0.65 0.65 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"%OffsetMin%\",\"offsetmax\":\"%OffsetMax%\"}]}]";
			public ContainerItemInterface()
			{
				//_skuliElement.AddChildren(new CuiButton()
				//{
				//	Button = { Color = "0.65 0.65 0.65 0", Command = $"uiskinmenu weaponSelect %ShortName% %SkinId%" },
				//	RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "%OffsetMin%", OffsetMax = "%OffsetMax%" }
				//});

				//Debug.Log(_skuliElement.ToJson());
			}

			public string GetElement(string offsetMin, string offsetMax, string layer, string shortName, ulong skinId)
			{
				return _json
					.Replace("%OffsetMin%", offsetMin)
					.Replace("%OffsetMax%", offsetMax)
					.Replace("%Layer%", layer)
					.Replace("%ShortName%", shortName)
					.Replace("%SkinId%", skinId.ToString());
			}
		}

		private class BlockItemInterface
		{
			private string _json = "[{\"parent\":\"%Layer%\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"color\":\"1 1 1 0.05\",\"png\":\"2001040039\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"%OffsetMin%\",\"offsetmax\":\"%OffsetMax%\"}]}]";
			//	private SkuliElement _skuliElement = new SkuliElement("%Layer%", false);

			public BlockItemInterface()
			{
				//_skuliElement.AddChildren(new CuiElement()
				//{
				//	Components =
				//	{
				//		new CuiRawImageComponent()
				//		{
				//			Png = ImageLibrary.Instance.GetImage("grid2"),
				//			Color = "1 1 1 0.05"
				//		},
				//		new CuiRectTransformComponent()
				//		{
				//			AnchorMin = "0 1",
				//			AnchorMax = "0 1",
				//			OffsetMin = "%OffsetMin%",
				//			OffsetMax  = "%OffsetMax%",
				//		}
				//	}
				//});

				//Debug.Log(_skuliElement.ToJson());
			}

			public string GetElement(string offsetMin, string offsetMax, string layer)
			{
				return _json.Replace("%OffsetMin%", offsetMin).Replace("%OffsetMax%", offsetMax).Replace("%Layer%", layer);
			}
		}

		private class ItemSkinInterface
		{
			private string _jsonOwnerElement = "[{\"name\":\"%ParrentLayer%%LayerName%\",\"parent\":\"%ParrentLayer%\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.35 0.35 0.35 0.65\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.5\",\"anchormax\":\"0 0.5\",\"offsetmin\":\"%OffsetMin%\",\"offsetmax\":\"%OffsetMax%\"}]},{\"parent\":\"%ParrentLayer%%LayerName%\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"itemid\":1,\"skinid\":1},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"%ImageOffsetMin%\",\"offsetmax\":\"%ImageOffsetMax%\"}]},{\"parent\":\"%ParrentLayer%%LayerName%\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"%Name%\",\"fontSize\":9,\"font\":\"robotocondensed-regular.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"0.5 0\",\"offsetmin\":\"%NameOffsetMin%\",\"offsetmax\":\"%NameOffsetMax%\"}]},{\"name\":\"5397032dd08d4ef4ac90d44e848ac005\",\"parent\":\"%ParrentLayer%%LayerName%\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"uiskinmenu setskin %SelectItemId% %SkinId%\",\"color\":\"0 0 0 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"%ImageOffsetMin%\",\"offsetmax\":\"%ImageOffsetMax%\"}]}]";
			private string _jsonSelectebleElement = "[{\"name\":\"21c13360b417459f8ac5a24ba73f244e\",\"parent\":\"%ParrentLayer%%LayerName%\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"uiskinmenu setSelected %ShortName% %SelectItemId% %SkinId% %Page% %LayerName%\",\"sprite\":\"assets/icons/favourite_servers.png\",\"color\":\"%ColorSelected%\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 1\",\"anchormax\":\"0 1\",\"offsetmin\":\"%SelectableOffsetMin%\",\"offsetmax\":\"%SelectableOffsetMax%\"}]}]";
			private string _jsonDefaultElement = "[{\"name\":\"fe1b35c48ccd4c0db6843c7b821aae33\",\"parent\":\"%ParrentLayer%%LayerName%\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"uiskinmenu setdefault %ShortName% %SelectItemId% %SkinId% %Page% %LayerName%\",\"sprite\":\"assets/icons/power.png\",\"color\":\"%ColorDefault%\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 1\",\"anchormax\":\"1 1\",\"offsetmin\":\"%DefaultOffsetMin%\",\"offsetmax\":\"%DefaultOffsetMax%\"}]}]";

			//private SkuliElement _skuliElement = new SkuliElement("%ParrentLayer%", false);
			//private SkuliElement _skuliElementSelecteble = new SkuliElement("%ParrentLayer%" + "%LayerName%", false);
			//private SkuliElement _skuliElementDefault = new SkuliElement("%ParrentLayer%" + "%LayerName%", false);

			public ItemSkinInterface()
			{
				//var layerNameElement = _skuliElement.AddChildren(new CuiElement()
				//{
				//	Name = "%ParrentLayer%" + "%LayerName%",
				//	Components =
				//	{
				//		new CuiImageComponent()
				//		{
				//			Color = "0.35 0.35 0.35 0.65",
				//		},
				//		new CuiRectTransformComponent
				//		{
				//			AnchorMin = "0 0.5",
				//			AnchorMax = "0 0.5",
				//			OffsetMin = "%OffsetMin%",
				//			OffsetMax = "%OffsetMax%"
				//		}
				//	}
				//});

				//layerNameElement.AddChildren(new CuiElement()
				//{
				//	Components =
				//	{
				//		new CuiImageComponent()
				//		{
				//			ItemId = 1,
				//			SkinId = 1
				//		},
				//		new CuiRectTransformComponent()
				//		{
				//			AnchorMin = "0.5 0.5",
				//			AnchorMax = "0.5 0.5",
				//			OffsetMin = "%ImageOffsetMin%", //-30 -30
				//			OffsetMax = "%ImageOffsetMax%" //30 30
				//		}
				//	}
				//});

				//layerNameElement.AddChildren(new CuiElement()
				//{
				//	Components =
				//	{
				//		new CuiTextComponent()
				//		{
				//			Text = "%Name%", Align = TextAnchor.MiddleCenter,
				//			Font = InterfaceBuilder.Regular,
				//			FontSize = 9
				//		},
				//		new CuiRectTransformComponent()
				//		{
				//			AnchorMin = "0.5 0",
				//			AnchorMax = "0.5 0",
				//			OffsetMin = "%NameOffsetMin%", //-40 -15
				//			OffsetMax = "%NameOffsetMax%" //40 0
				//		}
				//	}
				//});

				//layerNameElement.AddChildren(new CuiButton()
				//{
				//	RectTransform =
				//	{
				//		AnchorMin = "0.5 0.5",
				//		AnchorMax = "0.5 0.5",
				//		OffsetMin = "%ImageOffsetMin%",
				//		OffsetMax = "%ImageOffsetMax%"
				//	},
				//	Button =
				//	{
				//		Command = $"uiskinmenu setskin %SelectItemId% %SkinId%",
				//		Color = "0 0 0 0"
				//	},
				//	Text = { Text = "" }
				//});

				//_jsonOwnerElement = layerNameElement.ToJson();

				//_skuliElementSelecteble.AddChildren(new CuiButton()
				//{
				//	RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "%SelectableOffsetMin%", OffsetMax = "%SelectableOffsetMax%" }, //1 -18 "18 -1" 
				//	Button = { Command = $"uiskinmenu setSelected %ShortName% %SelectItemId% %SkinId% %Page%", Color = "%ColorSelected%", Sprite = "assets/icons/favourite_servers.png" },
				//	Text = { Text = "" }
				//});

				//_jsonSelectebleElement = _skuliElementSelecteble.ToJson();

				//	Debug.Log(_jsonSelectebleElement);

				//_skuliElementDefault.AddChildren(new CuiButton()
				//{
				//	RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "%DefaultOffsetMin%", OffsetMax = "%DefaultOffsetMax%" },
				//	Button = { Command = $"uiskinmenu setdefault %ShortName% %SelectItemId% %SkinId% %Page%", Color = "%ColorDefault%", Sprite = "assets/icons/power.png", },
				//	Text = { Text = "" }
				//});

				//_jsonDefaultElement = _skuliElementDefault.ToJson();

				//Debug.Log(_jsonDefaultElement);
			}

			public string GetElement(string offsetMin, string offsetMax, string shortName, Skin.Skin skin, ulong selectItemId, string ownLayer, string layerName, int page)
			{
				var json = _jsonOwnerElement
					.Replace("%LayerName%", layerName)
					.Replace("%Name%", skin.Name)
					.Replace("%SelectItemId%", selectItemId.ToString())
					.Replace("%SkinId%", skin.Id.ToString())
					.Replace("%Page%", page.ToString())
					.Replace("%ShortName%", shortName)
					.Replace("%OffsetMin%", offsetMin)
					.Replace("%OffsetMax%", offsetMax)
					.Replace("%ParrentLayer%", ownLayer);

				//Configuration.Instance.Grades.FirstOrDefault()
				if (ImageLibrary.Instance.HasImage(skin.Name))
				{
					json = json.Replace("\"type\":\"UnityEngine.UI.Image\",\"itemid\":1,\"skinid\":1", $"\"type\":\"UnityEngine.UI.RawImage\",\"png\":\"{ImageLibrary.Instance.GetImage(skin.Name)}\"");
				}
				else
				{
					json = json.Replace("\"itemid\":1", "\"itemid\":" + ItemExtension.GetItemId(shortName, skin.Id));

					if (skin.Id == 0)
					{
						json = json.Replace(",\"skinid\":1", "");
					}
					else
					{
						json = json.Replace("\"skinid\":1", "\"skinid\":" + skin.Id);
					}

				}

				return json;
			}

			public string GetElementSelectable(string shortName, ulong selectItemId, ulong skinId, int page, string layerName, string ownLayer, bool isSelected)
			{
				return _jsonSelectebleElement
					.Replace("%SelectItemId%", selectItemId.ToString())
					.Replace("%SkinId%", skinId.ToString())
					.Replace("%Page%", page.ToString())
					.Replace("%ShortName%", shortName)
					.Replace("%LayerName%", layerName)
					.Replace("%ColorSelected%", isSelected ? "0.87 0.68 0.22 1.00" : "1 1 1 1")
					.Replace("%ParrentLayer%", ownLayer);
			}

			public string GetElementDefault(string shortName, ulong selectItemId, ulong skinId, int page, string layerName, string ownLayer, bool isDefault)
			{
				return _jsonDefaultElement
					.Replace("%SelectItemId%", selectItemId.ToString())
					.Replace("%SkinId%", skinId.ToString())
					.Replace("%Page%", page.ToString())
					.Replace("%ShortName%", shortName)
					.Replace("%LayerName%", layerName)
					.Replace("%ColorDefault%", isDefault ? "0.21 0.62 0.28 1.00" : "0.98 0.31 0.23 1.00")
					.Replace("%ParrentLayer%", ownLayer);
			}
		}

		private class SearchSkinsInterface
		{

			string _json = "[{\"name\":\"UiSkuliSkins-Search\",\"parent\":\"UiSkuliSkins\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/icons/greyout.mat\",\"color\":\"0.33 0.32 0.32 0.00\",\"imagetype\":\"Filled\",\"png\":\"assets/standard assets/effects/imageeffects/textures/noise.png\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-400 -185\",\"offsetmax\":\"%OffsetMax%\"}]},{\"name\":\"UiSkuliSkins-Page\",\"parent\":\"UiSkuliSkins-Search\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/icons/greyout.mat\",\"color\":\"0.33 0.32 0.32 0.17\",\"imagetype\":\"Filled\",\"png\":\"assets/standard assets/effects/imageeffects/textures/noise.png\"},{\"type\":\"RectTransform\",\"anchormin\":\"1 0.5\",\"anchormax\":\"1 0.5\",\"offsetmin\":\"15 0\",\"offsetmax\":\"15 0\"}]},{\"name\":\"0d06821bfe8b478cbb868a378443a9a2\",\"parent\":\"UiSkuliSkins-Page\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"%CommandRightButton%\",\"color\":\"0.36 0.50 0.73 1.00\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-10 5\",\"offsetmax\":\"10 143\"}]},{\"parent\":\"0d06821bfe8b478cbb868a378443a9a2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"»\",\"fontSize\":20,\"align\":\"MiddleCenter\",\"color\":\"%ColorRightButton%\"},{\"type\":\"RectTransform\"}]},{\"name\":\"6b0b7f9ea38f4de283d5676c29e8a1d2\",\"parent\":\"UiSkuliSkins-Page\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"%CommandLeftButton%\",\"color\":\"0.36 0.50 0.73 1.00\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0.5\",\"anchormax\":\"0.5 0.5\",\"offsetmin\":\"-10 -137\",\"offsetmax\":\"10 -5\"}]},{\"parent\":\"6b0b7f9ea38f4de283d5676c29e8a1d2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"«\",\"fontSize\":20,\"align\":\"MiddleCenter\",\"color\":\"%ColorLeftButton%\"},{\"type\":\"RectTransform\"}]}]";

			public SearchSkinsInterface()
			{
				//var search = _skuliElement.AddChildren(new CuiPanel()
				//{
				//	Image = { ImageType = Image.Type.Filled, Png = "assets/standard assets/effects/imageeffects/textures/noise.png", Color = "0.33 0.32 0.32 0.00", Material = "assets/icons/greyout.mat" },
				//	RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 -185", OffsetMax = "%OffsetMax%" }
				//}, InterfaceBuilder.Layer + "-Search");

				//var pageElement = search.AddChildren(new CuiPanel()
				//{
				//	Image = { ImageType = Image.Type.Filled, Png = "assets/standard assets/effects/imageeffects/textures/noise.png", Color = "0.33 0.32 0.32 0.17", Material = "assets/icons/greyout.mat" },
				//	RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "15 0", OffsetMax = "15 0" }
				//}, InterfaceBuilder.Layer + "-Page");

				//pageElement.AddChildren(PageButtonInterface.MoveRightButton("%CommandRightButton%", "%ColorRightButton%"));
				//pageElement.AddChildren(PageButtonInterface.MoveLeftButton("%CommandLeftButton%", "%ColorLeftButton%"));

			}

			public string GetElement(string offsetMax, string commandRightButton, string colorRightButton, string commandLeftButton, string colorLeftButton)
			{
				return _json
					.Replace("%OffsetMax%", offsetMax)
					.Replace("%CommandRightButton%", commandRightButton)
					.Replace("%ColorRightButton%", colorRightButton)
					.Replace("%CommandLeftButton%", commandLeftButton)
					.Replace("%ColorLeftButton%", colorLeftButton);
			}
		}

		private class InterfaceBuilder : Sigleton<InterfaceBuilder>
		{
			public const string Layer = "UiSkuliSkins";
			public const string Regular = "robotocondensed-regular.ttf";

			private readonly List<IContainer> _wears = new List<IContainer>()
			{
				new MainContainer(),
				new BeltContainer(),
				new WearContainer(),
			};

			private DefaultInterface _defaultInterface = new DefaultInterface();
			private ContainerInterface _containerInterface = new ContainerInterface();
			private ContainerItemInterface _containerItemInterface = new ContainerItemInterface();
			private BlockItemInterface _blockItemInterface = new BlockItemInterface();
			private ItemSkinInterface _itemSkinInterface = new ItemSkinInterface();
			private SearchSkinsInterface _searchSkinsInterface = new SearchSkinsInterface();

			public void Draw(BasePlayer player, bool drawWears = true)
			{
				DestroyAllUI(player);

				CuiHelper.AddUi(player, _defaultInterface.GetElement(SSkinLang.Instance.Get("LABLEMENUTEXT", player.UserIDString),
																	SSkinLang.Instance.Get("INFOCLICKSKIN", player.UserIDString),
																	SSkinLang.Instance.Get("FAVSKINSLABLE", player.UserIDString)
																	));

				if (drawWears)
					foreach (var wear in _wears)
						LoadMainUI(player, wear);
			}

			private void LoadMainUI(BasePlayer player, IContainer iContainer)
			{
				string layer = Layer + "-" + iContainer.Type.ToString();
				CuiHelper.DestroyUi(player, layer);

				string json = _containerInterface.GetElement(iContainer.OffsetMin, iContainer.OffsetMax, layer);

				json = json.Remove(json.Length - 1, 1);

				var itemContainer = player.inventory.GetContainer(iContainer.Type);

				for (int i = 0; i < itemContainer.capacity; i++)
				{
					var offsets = iContainer.GetOffsets(i);

					json += ",";

					var item = itemContainer.GetSlot(i);
					if (item != null)
					{
						var shortname = item.info.shortname.Contains("hazmatsuit") ? "hazmatsuit" : item.info.shortname;
						var itemData = Items.Instance.Get(shortname);
						if (itemData != null)
						{
							var сontainerItemInterface = _containerItemInterface.GetElement(offsets.Item1, offsets.Item2, layer, item.info.shortname, item.uid.Value);
							json += сontainerItemInterface.Remove(сontainerItemInterface.Length - 1, 1).Remove(0, 1);
							continue;
						}
					}

					var blockItemInterface = _blockItemInterface.GetElement(offsets.Item1, offsets.Item2, layer);
					json += blockItemInterface.Remove(blockItemInterface.Length - 1, 1).Remove(0, 1);
				}

				json += "]";

				CuiHelper.AddUi(player, json);
			}

			public void DrawSkins(BasePlayer player, string shortName, ulong selectedItemId, int page)
			{
				if (shortName.Contains("hazmatsuit"))
					shortName = "hazmatsuit";

				var itemData = Items.Instance.Get(shortName);

				if (itemData == null) return;

				var playerData = Players.Instance.Get(player.userID);

				int skinsCount = 24;
				int pageXCount = skinsCount / 3;

				CuiHelper.DestroyUi(player, Layer + "-Search");

				string commandRightButton = "";
				string colorRightButton = "0.65 0.65 0.65 0.65";

				string commandLeftButton = "";
				string colorLeftButton = "0.65 0.65 0.65 0.65";

				if (0 < itemData.Skins.Count - skinsCount * page)
				{
					commandRightButton = $"uiskinmenu page {shortName} {selectedItemId} {page + 1}";
					colorRightButton = "";
				}

				if (page > 1)
				{
					commandLeftButton = $"uiskinmenu page {shortName} {selectedItemId} {page - 1}";
					colorLeftButton = "";
				}

				string json = _searchSkinsInterface.GetElement(
					$"{-400 + 90 * pageXCount} 115",
					commandRightButton,
					colorRightButton,
					commandLeftButton,
					colorLeftButton
				);

				json = json.Remove(json.Length - 1, 1);

				var blockedSkins = Configuration.Instance.GetBlockPermissionSkins(player);
				var whiteSkins = Configuration.Instance.GetPermissionSkins(player);

				bool useSelectable = itemData.Skins.Count > 12;
				bool useDefault = player.HasPermission(Configuration.Instance.DefaultSkinsPermission);

				foreach (var skinItem in itemData.Skins.
					Where(s => !blockedSkins.Contains(s.Id)).
					OrderByDescending(s => s.Id == 0 || whiteSkins.Contains(s.Id)).
					Select((i, t) => new { Skin = i, B = t - (page - 1) * skinsCount }).
					Skip((page - 1) * skinsCount).
					Take(skinsCount))
				{
					string offsetMin = $"{4 + skinItem.B * 90 - Math.Floor((double)skinItem.B / pageXCount) * pageXCount * 90} {60 - Math.Floor((double)skinItem.B / pageXCount) * 98}";
					string offsetMax = $"{90 + skinItem.B * 90 - Math.Floor((double)skinItem.B / pageXCount) * pageXCount * 90} {143 - Math.Floor((double)skinItem.B / pageXCount) * 98}";

					json += GetItem(offsetMin, offsetMax, skinItem.B.ToString(), Layer + "-Search", shortName, skinItem.Skin, selectedItemId, page, useDefault, useSelectable, playerData)
							.Replace("%ImageOffsetMin%", "-30 -30")
							.Replace("%ImageOffsetMax%", "30 30")
							.Replace("%NameOffsetMin%", "-40 -15")
							.Replace("%NameOffsetMax%", "40 0")
							.Replace("%SelectableOffsetMin%", "1 -18")
							.Replace("%SelectableOffsetMax%", "18 -1")
							.Replace("%DefaultOffsetMin%", "-16 -16")
							.Replace("%DefaultOffsetMax%", "-5 -5")
							;
				}
				json += "]";
				CuiHelper.AddUi(player, json);
			}

			private string GetItem(string offsetMin, string offsetMax, string layer, string layerParrent, string shortName, Skin.Skin skin, ulong selectedItemId, int page, bool useDefault, bool useSelectable, Player.Player player)
			{
				string json = "";

				var itemSkinJson = _itemSkinInterface.GetElement(
						offsetMin,
						offsetMax,
						shortName,
						skin,
						selectedItemId,
						layerParrent,
						layer,
						page);

				json += ",";

				json += itemSkinJson.Remove(itemSkinJson.Length - 1, 1).Remove(0, 1);

				if (useSelectable)
				{
					json += ",";
					var itemSkinJsonSelectable = _itemSkinInterface.GetElementSelectable(
								shortName,
								selectedItemId,
								skin.Id,
								page,
								layer,
								layerParrent,
								player.SelectedSkins.ContainsKey(shortName) && player.SelectedSkins[shortName].Contains(skin.Id)
					);

					json += itemSkinJsonSelectable.Remove(itemSkinJsonSelectable.Length - 1, 1).Remove(0, 1);
				}

				if (useDefault)
				{
					json += ",";

					var itemSkinJsonDefault = _itemSkinInterface.GetElementDefault(
								shortName,
								selectedItemId,
								skin.Id,
								page,
								layer,
								layerParrent,
								player.DefaultSkins.ContainsKey(shortName) && player.DefaultSkins[shortName] == skin.Id
					);


					json += itemSkinJsonDefault.Remove(itemSkinJsonDefault.Length - 1, 1).Remove(0, 1);
				}

				return json;
			}

			//Тут юи ещё не закончил 
			public void DrawSelectSkins(BasePlayer player, string shortname, ulong selectedItemId, int page)
			{
				var playerData = Players.Instance.Get(player.userID);

				CuiHelper.DestroyUi(player, Layer + "-Selected");

				if (!playerData.SelectedSkins.ContainsKey(shortname))
				{
					return;
				}

				var item = Items.Instance.Get(shortname);

				var container = new CuiElementContainer
				{
					{
						new CuiPanel()
						{
							Image = { Color = "0 0 0 0" },
							RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "201 111", OffsetMax = "571 231" }
						},
						"Overlay",
						Layer + "-Selected"
					}
				};

				if (item.Skins.Count < 12) return;

				int length = playerData.SelectedSkins[shortname].Count > 12 ? 12 : playerData.SelectedSkins[shortname].Count;

				var json = container.ToJson();

				json = json.Remove(json.Length - 1, 1);

				bool useDefault = player.HasPermission(Configuration.Instance.DefaultSkinsPermission);

				for (int i = 0; i < length && item.Skins.Count - 1 >= i; i++)
				{
					var skin = playerData.SelectedSkins[shortname][i];

					string offsetMin = $"{2 + i * 62 - Math.Floor((double)i / 6) * 6 * 62} {5 - Math.Floor((double)i / 6) * 62}";
					string offsetMax = $"{52 + i * 62 - Math.Floor((double)i / 6) * 6 * 62} {55 - Math.Floor((double)i / 6) * 62}";

					json += GetItem(offsetMin, offsetMax, i.ToString(), Layer + "-Selected", shortname, item.GetSkin(skin), selectedItemId, page, useDefault, true, playerData)
						.Replace("%ImageOffsetMin%", "-25 -25")
						.Replace("%ImageOffsetMax%", "25 25")
						.Replace("%NameOffsetMin%", "-30 -5")
						.Replace("%NameOffsetMax%", "30 10")
						.Replace("%SelectableOffsetMin%", "-5 -10")
						.Replace("%SelectableOffsetMax%", "10 5")
						.Replace("%DefaultOffsetMin%", "-7 -7")
						.Replace("%DefaultOffsetMax%", "3 3")
						.Replace("0.65", "0")
						;
				}

				json += "]";

				CuiHelper.AddUi(player, json);
			}

			public void UpdateItem(BasePlayer player, string shortName, ulong selectedItemId, ulong skinId, int page)
			{
				string json = "[";

				var itemData = Items.Instance.Get(shortName);
				var playerData = Players.Instance.Get(player.userID);

				bool useSelectable = itemData.Skins.Count > 12;
				bool useDefault = player.HasPermission(Configuration.Instance.DefaultSkinsPermission);

				int skinsCount = 24;
				int pageXCount = skinsCount / 3;


				var blockedSkins = Configuration.Instance.GetBlockPermissionSkins(player);
				var whiteSkins = Configuration.Instance.GetPermissionSkins(player);

				var skins = itemData.Skins.
					Where(s => !blockedSkins.Contains(s.Id)).
					OrderByDescending(s => s.Id == 0 || whiteSkins.Contains(s.Id)).
					Select((i, t) => new { Skin = i, B = t - (page - 1) * skinsCount }).
					Skip((page - 1) * skinsCount).
					Take(skinsCount);

				var skin = skins.FirstOrDefault(s => s.Skin.Id.Equals(skinId));

				if (skin == null) return;

				CuiHelper.DestroyUi(player, Layer + "-Search" + skin.B);

				string offsetMin = $"{4 + skin.B * 90 - Math.Floor((double)skin.B / pageXCount) * pageXCount * 90} {60 - Math.Floor((double)skin.B / pageXCount) * 98}";
				string offsetMax = $"{90 + skin.B * 90 - Math.Floor((double)skin.B / pageXCount) * pageXCount * 90} {143 - Math.Floor((double)skin.B / pageXCount) * 98}";

				json += GetItem(offsetMin, offsetMax, skin.B.ToString(), Layer + "-Search", shortName, skin.Skin, selectedItemId, page, useDefault, useSelectable, playerData)
						.Replace("%ImageOffsetMin%", "-30 -30")
						.Replace("%ImageOffsetMax%", "30 30")
						.Replace("%NameOffsetMin%", "-40 -15")
						.Replace("%NameOffsetMax%", "40 0")
						.Replace("%SelectableOffsetMin%", "1 -18")
						.Replace("%SelectableOffsetMax%", "18 -1")
						.Replace("%DefaultOffsetMin%", "-16 -16")
						.Replace("%DefaultOffsetMax%", "-5 -5").Remove(0, 1);


				//if (playerData.SelectedSkins.ContainsKey(shortName) && playerData.SelectedSkins[shortName].Contains(skinId))
				//{
				//	CuiHelper.DestroyUi(player, Layer + "-Selected" + layer);

				//	offsetMin = $"{2 + index * 62 - Math.Floor((double)index / 6) * 6 * 62} {5 - Math.Floor((double)index / 6) * 62}";
				//	offsetMax = $"{52 + index * 62 - Math.Floor((double)index / 6) * 6 * 62} {55 - Math.Floor((double)index / 6) * 62}";
				//	json += GetItem(offsetMin, offsetMax, layer, Layer + "-Selected", shortName, skin, selectedItemId, page, useDefault, true, playerData)
				//			.Replace("%ImageOffsetMin%", "-25 -25")
				//			.Replace("%ImageOffsetMax%", "25 25")
				//			.Replace("%NameOffsetMin%", "-30 -5")
				//			.Replace("%NameOffsetMax%", "30 10")
				//			.Replace("%SelectableOffsetMin%", "-5 -10")
				//			.Replace("%SelectableOffsetMax%", "10 5")
				//			.Replace("%DefaultOffsetMin%", "-7 -7")
				//			.Replace("%DefaultOffsetMax%", "3 3")
				//			.Replace("0.65", "0");

				//}

				json += "]";

				CuiHelper.AddUi(player, json);
			}

			public void DestroyAllUI(BasePlayer player)
			{
				CuiHelper.DestroyUi(player, Layer);
				foreach (var wear in _wears)
					CuiHelper.DestroyUi(player, Layer + "-" + wear.Type.ToString());

				CuiHelper.DestroyUi(player, Layer + "-Selected");
				CuiHelper.DestroyUi(player, Layer + "-Search");
				CuiHelper.DestroyUi(player, Layer + "-LableIzb");
			}
		}


		#endregion

		#region Monobehavior
		private class OpenMenuButton : MonoBehaviour
		{
			private BasePlayer _player;
			private float _lastCheck;

			private void Awake()
			{
				_player = GetComponent<BasePlayer>();
				_lastCheck = Time.realtimeSinceStartup;
			}

			private void FixedUpdate()
			{
				if (_player == null || !_player.IsConnected)
				{
					Destroy();
					return;
				}

				if (!_player.HasPermission(Configuration.Instance.HammerSettings.OpenSkinEntityPermission))
					return;

				if ((_player.GetActiveItem())?.info.shortname != "hammer") return;

				string format = null;

				if (_player.serverInput.WasJustPressed(Configuration.Instance.HammerSettings.OpenSkinEntityButton))
				{
					format = "entity";
                }
                else if (_player.serverInput.WasJustPressed(Configuration.Instance.HammerSettings.OpenSkinBuildingButton))
				{
                    format = "buildings";
                }

				if (string.IsNullOrWhiteSpace(format)) return;

                float currentTime = Time.realtimeSinceStartup;

                if (currentTime - _lastCheck >= 2f)
				{
					_player.SendConsoleCommand($"uiskinmenu openEntityUi {format}");
					_lastCheck = currentTime;
				}
			}

			public void Destroy()
			{
				Destroy(this);
			}
		}
		#endregion

		private void RegisterPermission(string perm)
		{
			if (string.IsNullOrEmpty(perm) || permission.PermissionExists(perm, this))
				return;

			permission.RegisterPermission(perm, this);
		}

		private class Helper : Sigleton<Helper>
		{
			private readonly Dictionary<string, string> _shortNamesEntity = new Dictionary<string, string>();

			public readonly Dictionary<string, string> WorkshopsNames = new Dictionary<string, string>()
			{
				{"ak47", "rifle.ak" },
				{"lr300", "rifle.lr300" },
				{"lr300.item", "rifle.lr300" },
				{"m39", "rifle.m39" },
				{"l96", "rifle.l96" },
				{"longtshirt", "tshirt.long" },
				{"cap", "hat.cap" },
				{"beenie", "hat.beenie" },
				{"boonie", "hat.boonie" },
				{"balaclava", "mask.balaclava" },
				{"pipeshotgun", "shotgun.waterpipe" },
				{"woodstorage", "box.wooden" },
				{"bearrug", "rug.bear" },
				{"boltrifle", "rifle.bolt" },
				{"bandana", "mask.bandana" },
				{"hideshirt", "attire.hide.vest" },
				{"snowjacket", "jacket.snow" },
				{"buckethat", "bucket.helmet" },
				{"semiautopistol", "pistol.semiauto" },
				{"roadsignvest", "roadsign.jacket" },
				{"roadsignpants", "roadsign.kilt" },
				{"burlappants", "burlap.trousers" },
				{"collaredshirt", "shirt.collared" },
				{"mp5", "smg.mp5" },
				{"sword", "salvaged.sword" },
				{"workboots", "shoes.boots" },
				{"vagabondjacket", "jacket" },
				{"hideshoes", "attire.hide.boots" },
				{"deerskullmask", "deer.skull.mask" },
				{"minerhat", "hat.miner" },
				{"burlapgloves", "burlap.gloves" },
				{"burlap.gloves", "burlap.gloves"},
				{"leather.gloves", "burlap.gloves"},
				{"python", "pistol.python" },
				{"woodendoubledoor", "door.double.hinged.wood" }
			};

			public Helper()
			{
				LoadShortNamesEntity();
				UpdateWorkshopShortName();
			}

			private void UpdateWorkshopShortName()
			{
				foreach (var itemDefinition in ItemManager.itemList)
				{
					if (itemDefinition.shortname == "ammo.snowballgun") continue;
					var name = itemDefinition.displayName.english.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "");
					if (!WorkshopsNames.ContainsKey(name))
						WorkshopsNames.Add(name, itemDefinition.shortname);
					if (!WorkshopsNames.ContainsKey(itemDefinition.shortname))
						WorkshopsNames.Add(itemDefinition.shortname, itemDefinition.shortname);
					if (!WorkshopsNames.ContainsKey(itemDefinition.shortname.Replace(".", "")))
						WorkshopsNames.Add(itemDefinition.shortname.Replace(".", ""), itemDefinition.shortname);
				}
			}
			private void LoadShortNamesEntity()
			{
				foreach (var itemDefinition in ItemManager.GetItemDefinitions())
				{
					var prefab = itemDefinition.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;

					if (string.IsNullOrEmpty(prefab)) continue;

					var shortPrefabName = Utility.GetFileNameWithoutExtension(prefab);

					if (string.IsNullOrEmpty(shortPrefabName) || _shortNamesEntity.ContainsKey(shortPrefabName))
						continue;

					_shortNamesEntity.Add(shortPrefabName, itemDefinition.shortname);
				}
			}

			public string GetShortNamePrefab(string shortPrefabName)
			{
				if (_shortNamesEntity.ContainsKey(shortPrefabName)) return "";

				return _shortNamesEntity[shortPrefabName];
			}

		}

		private class ImageLibrary : PluginSigleton<ImageLibrary>
		{
            public ImageLibrary(Plugin plugin) : base(plugin)
			{
				if (plugin == null)
					throw new Exception("[SSkin] Need add ImageLibrary");
			}

			public string GetImage(string shortname, ulong skin = 0) =>
				(string)Plugin.Call("GetImage", shortname, skin);

			public bool AddImage(string url, string shortname, ulong skin = 0) =>
				(bool)Plugin.Call("AddImage", url, shortname, skin);

			public bool HasImage(string imageName, ulong imageId = 0) => (bool)Plugin.Call("HasImage", imageName, imageId);
		}

		private class SSkinWeb : PluginSigleton<SSkinWeb>
		{
			private readonly WebRequests _webrequest = Interface.Oxide.GetLibrary<WebRequests>();
			
			public SSkinWeb(Plugin plugin) : base(plugin)
			{
			}

			public void DownloadSkin(ulong skinId)
			{
				var shortName = String.Empty;
				var marketName = String.Empty;

				_webrequest.Enqueue($"https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/", $"&itemcount=1&publishedfileids[0]={skinId}",
				(code, res) =>
				{
					if (res.Length < 200)
					{
						Debug.LogError($"[{Plugin.Name}] skind id {skinId} not find");
						return;
					}

					PublishedFileQueryResponse query =
						JsonConvert.DeserializeObject<PublishedFileQueryResponse>(res);

					if (query != null && query.response != null && query.response.publishedfiledetails.Length > 0)
					{
						foreach (var publishedFileQueryDetail in query.response.publishedfiledetails)
						{
							foreach (var tag in publishedFileQueryDetail.tags)
							{
								string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
								if (Helper.Instance.WorkshopsNames.ContainsKey(adjTag))
								{
									shortName = Helper.Instance.WorkshopsNames[adjTag];
									marketName = publishedFileQueryDetail.title;

									var itemData = Items.Instance.Get(shortName);

									if (itemData == null)
									{
										Items.Instance.Add(shortName).Skins.Add(new Skin.Skin()
										{
											Id = skinId,
											Name = marketName
										});
										continue;
									}

									if (itemData.GetSkin(skinId) != null) continue;

									itemData.Skins.Add(new Skin.Skin()
									{
										Id = skinId,
										Name = marketName
									});
									return;
								}
							}
						}
					}
				}, Plugin, RequestMethod.POST);
			}

			#region JSON Response Classes
			public class PublishedFileQueryResponse
			{
				public FileResponse response { get; set; }
			}

			public class FileResponse
			{
				public int result { get; set; }
				public int resultcount { get; set; }
				public PublishedFileQueryDetail[] publishedfiledetails { get; set; }
			}

			public class PublishedFileQueryDetail
			{
				public string publishedfileid { get; set; }
				public int result { get; set; }
				public string creator { get; set; }
				public int creator_app_id { get; set; }
				public int consumer_app_id { get; set; }
				public string filename { get; set; }
				public int file_size { get; set; }
				public string preview_url { get; set; }
				public string hcontent_preview { get; set; }
				public string title { get; set; }
				public string description { get; set; }
				public int time_created { get; set; }
				public int time_updated { get; set; }
				public int visibility { get; set; }
				public int banned { get; set; }
				public string ban_reason { get; set; }
				public int subscriptions { get; set; }
				public int favorited { get; set; }
				public int lifetime_subscriptions { get; set; }
				public int lifetime_favorited { get; set; }
				public int views { get; set; }
				public Tag[] tags { get; set; }

				public class Tag
				{
					public string tag { get; set; }
				}
			}

			public class CollectionQueryResponse
			{
				public CollectionResponse response { get; set; }
			}

			public class CollectionResponse
			{
				public int result { get; set; }
				public int resultcount { get; set; }
				public CollectionDetails[] collectiondetails { get; set; }
			}

			public class CollectionDetails
			{
				public string publishedfileid { get; set; }
				public int result { get; set; }
				public CollectionChild[] children { get; set; }
			}

			public class CollectionChild
			{
				public string publishedfileid { get; set; }
				public int sortorder { get; set; }
				public int filetype { get; set; }
			}

			#endregion
		}

		private class SSkinLang : PluginSigleton<SSkinLang>
		{
			protected Lang lang = Interface.Oxide.GetLibrary<Lang>();

			public SSkinLang(Plugin plugin) : base(plugin)
			{
			}

			public string Get(string message, string userId) => lang.GetMessage(message, Plugin, userId);
		}
	}

	namespace Helper
	{
		using Player;
		using Skin;

		#region Items.cs
		public class Items : SigletonData<Items, List<Item>>
		{
			public override string Name => "Items";

			public Item Add(string name)
			{
				Item item = new Item() { Name = name };
				Value.Add(item);
				return item;
			}
			public Item Get(string name) => Value.FirstOrDefault(i => i.Name.Equals(name));

			public Skin GetSkin(string name, ulong id) => Get(name)?.GetSkin(id);

			public void LoadSkinHazmats()
			{
				var item = Get("hazmatsuit") ?? Add("hazmatsuit");

				bool isAdd = false;

				foreach (var hazmat in ItemExtension.GetHazmats())
				{
					if (item.GetSkin(hazmat.Key) == null)
					{
						item.Skins.Add(new Skin()
						{
							Name = ItemManager.FindItemDefinition(hazmat.Value).displayName.english,
							Id = hazmat.Key,
						});
						isAdd = true;
					}
				}

				if (isAdd)
					Unload();
			}

			public void LoadSkinDefines()
			{
				foreach (var itemDefinition in ItemManager.GetItemDefinitions())
				{
					if (itemDefinition == null || itemDefinition.skins2 == null || itemDefinition.skins2.Length == 0) continue;

					var item = Get(itemDefinition.shortname);

					if (item == null)
					{
						item = Add(itemDefinition.shortname);
						item.Skins.Add(new Skin()
						{
							Name = itemDefinition.displayName.english,
						});
					}

					foreach (var playerItemDefinition in itemDefinition.skins2)
					{
						if (playerItemDefinition == null || itemDefinition.shortname == null) continue;

						var skinId = playerItemDefinition.WorkshopDownload == 0 ? ulong.Parse(playerItemDefinition.DefinitionId.ToString()) : playerItemDefinition.WorkshopDownload;

						if (item.GetSkin(skinId) == null)
						{
							item.Skins.Add(new Skin()
							{
								Name = playerItemDefinition.Name,
								Id = skinId,
							});
						}
					}
				}
			}

			public void LoadApprovedSkin()
			{
				foreach (var approvedSkinInfo in Rust.Workshop.Approved.All)
				{
					if (approvedSkinInfo.Value == null || approvedSkinInfo.Value.Skinnable == null || approvedSkinInfo.Value.Marketable == false) continue;
					var item = approvedSkinInfo.Value.Skinnable.ItemName;
					if (item.Contains("lr300")) item = "rifle.lr300";

					Item itemData = Get(item);

					if (itemData == null)
					{
						Add(item).Skins.Add(new Skin()
						{
							Id = approvedSkinInfo.Value.WorkshopdId,
							Name = approvedSkinInfo.Value.Name
						});
						continue;
					}

					if (itemData.GetSkin(approvedSkinInfo.Value.WorkshopdId) != null) continue;

					itemData.Skins.Add(new Skin()
					{
						Id = approvedSkinInfo.Value.WorkshopdId,
						Name = ItemManager.FindItemDefinition(approvedSkinInfo.Value.Name).displayName.english
					});
				}
			}
		}
		#endregion

		#region Players.cs
		public class Players : SigletonData<Players, List<Player>>
		{
			public override string Name => "Players";

			public Player Get(ulong steamId) => Value.FirstOrDefault(p => p.SteamId.Equals(steamId));
		}
		#endregion

		#region Sigleton.cs
		public abstract class PluginSigleton<T> : Sigleton<T> where T : PluginSigleton<T>
		{
			public Plugin Plugin { get; private set; }
			public PluginSigleton(Plugin plugin)
			{
				Plugin = plugin;
			}
		}

		public abstract class Sigleton<T> where T : Sigleton<T>
		{
			public static T Instance;

			public Sigleton()
			{
				Instance = (T)this;
			}
		}

		public abstract class SigletonData<B, T> : Sigleton<B> where B : SigletonData<B, T>
		{
			public T Value { get; protected set; }
			public abstract string Name { get; }

			public virtual void Load()
			{
				Value = Interface.uMod.DataFileSystem.ReadObject<T>("SSkin/" + Name);
				if (Value == null)
				{
					Value = default(T); // JsonConvert.DeserializeObject<T>("");
					Unload();
				}
			}

			public virtual void Unload()
			{
				Interface.uMod.DataFileSystem.WriteObject("SSkin/" + Name, Value);  // JsonConvert.DeserializeObject<T>("");
			}
		}
		#endregion
	}

	namespace Skin
	{
		#region Skin.cs
		public class Skin
		{
			public string Name { get; set; }
			public ulong Id { get; set; }
		}
		#endregion

		#region Item.cs
		public class Item
		{
			public string Name { get; set; }

			public List<Skin> Skins { get; set; } = new List<Skin>();

			public Skin GetSkin(ulong id) => Skins.FirstOrDefault(s => s.Id.Equals(id));
		}
		#endregion
	}

	namespace Player
	{
		#region Player.cs
		public class Player
		{
			public ulong SteamId { get; set; }

			public Dictionary<string, List<ulong>> SelectedSkins { get; set; } = new Dictionary<string, List<ulong>>();

			public Dictionary<string, ulong> DefaultSkins { get; set; } = new Dictionary<string, ulong>();

			public void AddOrRemoveSelectedSkin(string name, ulong skinId)
			{
				if (SelectedSkins.ContainsKey(name))
				{
					if (SelectedSkins[name].Contains(skinId))
					{
						SelectedSkins[name].Remove(skinId);
						return;
					}

					SelectedSkins[name].Add(skinId);
					return;
				}

				SelectedSkins.Add(name, new List<ulong>() { skinId });
				return;
			}
		}
		#endregion
	}

	namespace Extension
	{
		public static class HexExtension
		{
			public static string ToRustFormat(string hex)
			{
				if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
				var str = hex.Trim('#');
				if (str.Length == 6) str += "FF";
				if (str.Length != 8)
				{
					throw new Exception(hex);
				}

				var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
				var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
				var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
				var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

				Color color = new Color32(r, g, b, a);

				Debug.Log(hex + " " + $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}");

				return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
			}
		}

		public static class PlayerExtension
		{
			public static void SetDefaultSkin(this Player.Player player, Item item)
			{
				ulong skin;
				if (player.DefaultSkins.TryGetValue(item.info.shortname, out skin))
					item.SetItemSkin(skin);
			}

			public static void SetDefaultSkin(this Player.Player player, BaseEntity entity)
			{
				var shortName = entity.GetShortName();

				if (string.IsNullOrEmpty(shortName)) return;

				ulong skin;
				if (player.DefaultSkins.TryGetValue(shortName, out skin))
					entity.SetSkin(skin);
			}

			public static void SetDefaultSkin(this Player.Player player, BuildingBlock block, BuildingGrade.Enum grade = BuildingGrade.Enum.None)
			{
				ulong skin;
				if (player.DefaultSkins.TryGetValue(grade == BuildingGrade.Enum.None ? block.grade.ToString() : grade.ToString(), out skin))
				{
					block.skinID = skin;
					block.UpdateSkin(true);
					block.currentSkin.Refresh(block);
					block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
				}
			}

			public static BaseEntity FindConstructioninDirectionLook(this BasePlayer player)
			{
				RaycastHit rhit;

				if (!Physics.Raycast(player.eyes.HeadRay(), out rhit, 3f, LayerMask.GetMask("Deployed", "Construction", "Prevent Building"))) return null;
				var entity = rhit.GetEntity();

				if (entity == null) return null;

				return entity;
			}

			public static void SetSkin(this BaseEntity entity, ulong skinId)
			{
				if (entity is BaseVehicle)
				{
					var vehicle = entity as BaseVehicle;

					if (skinId == vehicle.skinID) return;

					BaseVehicle transport = GameManager.server.CreateEntity($"assets/content/vehicles/snowmobiles/{vehicle.ShortPrefabName}.prefab", vehicle.transform.position, vehicle.transform.rotation) as BaseVehicle;
					transport.health = vehicle.health;
					transport.skinID = skinId;

					vehicle.Kill();
					transport.Spawn();
					Effect.server.Run("assets/prefabs/deployable/repair bench/effects/skinchange_spraypaint.prefab", transport.transform.localPosition);
					return;
				}

				if (skinId == entity.skinID) return;

				entity.skinID = skinId;
				entity.SendNetworkUpdate();
				Effect.server.Run("assets/prefabs/deployable/repair bench/effects/skinchange_spraypaint.prefab", entity.transform.localPosition);

			}

			public static string GetShortName(this BaseEntity entity)
			{
				string shortName;

				if (entity is BaseVehicle)
				{
					var vehicle = entity as BaseVehicle;
					shortName = vehicle.ShortPrefabName;
				}
				else if (entity is BuildingBlock)
				{
					var block = entity as BuildingBlock;
					shortName = block.grade.ToString();
				}
				else
				{
					shortName = entity.ShortPrefabName;
				}

				if (string.IsNullOrEmpty(shortName) || Items.Instance.Get(shortName) == null)
					return "";

				return shortName;
			}

			public static bool HasPermission(this BasePlayer player, params string[] perms)
			{
				bool value = true;

				foreach (var perm in perms)
				{
					value &= player.HasPermission(perm);

					if (!value)
						return false;
				}

				return value;
			}

			public static bool HasPermission(this BasePlayer player, string perm)
			{
				if (string.IsNullOrEmpty(perm)) return true;

				return player.IPlayer.HasPermission(perm);
			}

			public static void LootContainer(this BasePlayer player, ItemContainer container)
			{
				player.inventory.loot.Clear();
				player.inventory.loot.PositionChecks = false;
				player.inventory.loot.entitySource = container.entityOwner ?? player;
				player.inventory.loot.itemSource = null;
				player.inventory.loot.MarkDirty();
				player.inventory.loot.AddContainer(container);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic_resizable");
			}
		}

		public static class ItemExtension
		{
			private static readonly Dictionary<string, int> _itemIds = new Dictionary<string, int>();

			private static readonly Dictionary<ulong, string> _hazmats = new Dictionary<ulong, string>()
			{
				[0] = "hazmatsuit",
				[1] = "hazmatsuit.spacesuit",
				[2] = "hazmatsuit.nomadsuit",
				[3] = "hazmatsuit.arcticsuit",
				[4] = "hazmatsuit.lumberjack"
			};

			public static IEnumerable<KeyValuePair<ulong, string>> GetHazmats() => _hazmats;

			public static void SetItemSkin(this Item item, ulong skinId)
			{
				if (item.info.shortname.Contains("hazmatsuit"))
				{
					var pos = item.position;
					var container = item.GetRootContainer();
					var uids = item.uid;
					item.DoRemove();
					item = ItemManager.CreateByName(_hazmats[skinId]);
					item.uid = uids;
					item.MoveToContainer(container, pos);
				}
				else
				{
					item.skin = skinId;
					var hend = item.GetHeldEntity();
					if (hend != null)
					{
						hend.skinID = skinId;
						hend.SendNetworkUpdate();
					}
				}

				item.MarkDirty();
			}

			public static int GetItemId(string name, ulong skinId)
			{
				if (name.Contains("hazmatsuit"))
					return GetItemId(_hazmats[skinId]);

				return GetItemId(name);
			}

			public static int GetItemId(string name)
			{
				int id;
				if (_itemIds.TryGetValue(name, out id))
					return id;

				var def = ItemManager.FindItemDefinition(name);
				if (!def)
					return _itemIds[name] = int.MinValue;

				return _itemIds[name] = def.itemid;
			}
		}
	}
}

// --- End of file: SSkin.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPWipeSchedule.cs ---
// --- Original Local Path: TPWipeSchedule.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TPWipeSchedule", "Sempai#3239", "3.0.0⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
    public class TPWipeSchedule : RustPlugin
    {
        #region Fields⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private string Layer = "UI_WipeSchedule";

        [PluginReference] Plugin ImageLibrary;
        public enum Types
        {
            None,
            GLOBAL_WIPE,
            WIPE
        }

        private Dictionary<int, string> DaysOfWeek = new Dictionary<int, string>()
        {
            [1] = "ПН",
            [2] = "ВТ",
            [3] = "СР",
            [4] = "ЧТ",
            [5] = "ПТ",
            [6] = "СБ",
            [7] = "ВС",
        };

        public List<DayClass> DaysList = new List<DayClass>();

        public class DayClass
        {
            public int day;
            public string color;
            public Types types;
            public string description;
        }
        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private ConfigData config;

        private class ConfigData
        {
            [JsonProperty("Раз во сколько секунд обновлять календарь?")]
            public int Delay;
            [JsonProperty("Цвет дней в нынешнем месяце (изображение)")]
            public string ActiveImage;
            [JsonProperty("Настройка")]
            public Dictionary<int, WipeClass> wipe;
        }

        private class WipeClass
        {
            [JsonProperty("Тип")]
            public Types type;
            [JsonProperty("Изображение с цветом кнопки")]
            public string image;
            [JsonProperty("Описание")]
            public string description;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                Delay = 7200,
                ActiveImage = "https://rustage.su/img/server/ui/calendar_day.png",
                wipe = new Dictionary<int, WipeClass>
                {
                    {
                        1, new WipeClass
                        {
                            image = "https://rustage.su/img/server/ui/calendar_wipe_global.png",
                            type = Types.GLOBAL_WIPE,
                            description = "ГЛОБАЛЬНЫЙ ВАЙП"
                        }
                    },
                    {
                        9, new WipeClass
                        {
                            image = "https://rustage.su/img/server/ui/calendar_wipe_map.png",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    },
                    {
                        16, new WipeClass
                        {
                            image = "https://rustage.su/img/server/ui/calendar_wipe_global.png",
                            type = Types.GLOBAL_WIPE,
                            description = "ГЛОБАЛЬНЫЙ ВАЙП"
                        }
                    },
                    {
                        23, new WipeClass
                        {
                            image = "https://rustage.su/img/server/ui/calendar_wipe_map.png",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    },
                    {
                        30, new WipeClass
                        {
                            image = "https://rustage.su/img/server/ui/calendar_wipe_map.png",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    }
                }
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://topplugin.ru/\n" +
            "     VK - https://vk.com/rustnastroika\n" +
            "     Discord - https://discord.com/invite/5DPTsRmd3G\n" +
            "-----------------------------");
            PrintWarning("  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
            PrintWarning($"     {Name} v{Version} loading");
            PrintWarning($"        Plugin loaded - OK");
            PrintWarning("  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
            ImageLibrary.Call("AddImage", $"https://rustage.su/img/server/ui/calendar_back.png", "ahDNpde");
            ImageLibrary.Call("AddImage", config.ActiveImage, config.ActiveImage);

            foreach (var check in config.wipe)
                ImageLibrary.Call("AddImage", check.Value.image, check.Value.image);
            
            cmd.AddConsoleCommand("UI_Schedule", this, nameof(CmdConsoleSchedule));

            CalculateTable();

            timer.Every(config.Delay, () => CalculateTable());
        }

        private void CmdConsoleSchedule(ConsoleSystem.Arg args)
        {
            var player = args.Player();

            int index = 0;
            if (!args.HasArgs(1) || !int.TryParse(args.Args[0], out index)) return;

            var check = DaysList[index];
            if (check.types != Types.None)
            {
                var container = new CuiElementContainer();
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{check.description}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 8, Font = "robotocondensed-regular.ttf" }
                }, Layer + $".Day.Of.{index}", Layer + $".Day.Of.{index}.Text");
                CuiHelper.DestroyUi(player, Layer + $".Day.Of.{index}.Text");
                CuiHelper.AddUi(player, container);
            }
        }
        #endregion

        #region Interface⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";

        void BuildUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            var monthName = FirstUpper(DateTime.Now.ToString("MMMM", CultureInfo.GetCultureInfo("ru-RU")));

            container.Add(new CuiElement
            {
                Name = "lay" + ".Main",
                Parent = ".Mains",
                Components = 
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "ahDNpde"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "lay" + ".Main", Layer + ".BG");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "lay" + ".Main");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.3 -245", OffsetMax = "200 210" },
                Image = { Color = "0 0 0 0" },
                CursorEnabled = true
            }, Layer + ".BG", Layer);

            #region Loop
            var xDaysSwitch = 17.0f;
            for (int i = 1; i <= 7; i++)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{xDaysSwitch} -130", OffsetMax = $"{xDaysSwitch + 20} -90" },
                    Text = { Text = DaysOfWeek[i], Align = TextAnchor.MiddleCenter, FontSize = 11, Color = "1 1 1 0.6", Font = "robotocondensed-regular.ttf" }
                }, Layer);
                xDaysSwitch += 39.0f;
            }

            var ySwitch = -16;
            var xSwitch = 15.5f;
            for (int i = 0; i < DaysList.Count; i++)
            {
                var check = DaysList[i];

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{xSwitch} {ySwitch - 157}", OffsetMax = $"{xSwitch + 35} {ySwitch - 120}" },
                    Button = { Color = "0 0 0 0", Command = $"UI_Schedule {i}", FadeIn = 1f },
                    Text = { Text = "" }
                }, Layer, Layer + $".Day.Of.{i}");

                if (check.color != "0 0 0 0")
                {
                    container.Add(new CuiElement
                    {
                        Parent = Layer + $".Day.Of.{i}",
                        Components = 
                        {
                            new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", check.color) },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        }
                    });
                }

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{check.day}", Color = "1 1 1 0.6", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                }, Layer + $".Day.Of.{i}", Layer + $".Day.Of.{i}.Text");

                xSwitch += 37.7f;

                if ((i + 1) % 7 == 0)
                {
                    xSwitch = 15.0f;
                    ySwitch -= 40;
                }
            }
            #endregion

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "320.5 290", OffsetMax = "333.5 318" },
                Image = { Color = "0 0 0 0" }
            }, Layer, Layer + ".GlobalWipe");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "5 -20", OffsetMax = "175 20" },
                Text = { Text = "- Глобал вайп с чертежами", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".GlobalWipe");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "320.5 315", OffsetMax = "333.5 347" },
                Image = { Color = "0 0 0 0", }
            }, Layer, Layer + ".Wipe");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "5 -20", OffsetMax = "175 20" },
                Text = { Text = "- Вайп без удаления чертежей", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Wipe");

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Utils⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void CalculateTable()
        {
            DaysList.Clear();

            Calendar myCal = CultureInfo.InvariantCulture.Calendar;
            DateTime myDT = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1, myCal);

            var PreviousMonth = myDT.AddMonths(-1);
            var DaysInPreviousMonth = (int)DateTime.DaysInMonth(PreviousMonth.Year, PreviousMonth.Month);

            int j = Convert.ToInt32(myCal.GetDayOfWeek(myDT)) - 1;

            j = j == -1 ? 6 : j;

            var LastDay = new DateTime(PreviousMonth.Year, PreviousMonth.Month, DaysInPreviousMonth);
            var backDays = LastDay.AddDays(-j + 1);
            for (int m = 0; m < j; m++)
            {
                DaysList.Add(new DayClass
                {
                    day = backDays.Day,
                    color = "0 0 0 0",
                    description = string.Empty,
                    types = Types.None
                });
                backDays = backDays.AddDays(1);
            }

            int month = myCal.GetMonth(myDT);
            while (myCal.GetMonth(myDT) == month)
            {
                var check = config.wipe.Where(x => x.Key == myDT.Day).FirstOrDefault().Value != null;

                DaysList.Add(new DayClass
                {
                    day = myDT.Day,
                    color = check ? config.wipe[myDT.Day].image : config.ActiveImage,
                    description = check ? config.wipe[myDT.Day].description : string.Empty,
                    types = check ? config.wipe[myDT.Day].type : Types.None
                });

                myDT = myDT.AddDays(1);
                j--;
            }

            if (DaysList.Count < 42)
            {
                var DaysToEndTable = 42 - DaysList.Count;

                for (int i = 1; i <= DaysToEndTable; i++)
                {
                    DaysList.Add(new DayClass
                    {
                        day = i,
                        color = "0 0 0 0",
                        description = string.Empty,
                        types = Types.None
                    });
                }
            }
        }

        public string FirstUpper(string str)
        {
            str = str.ToLower();
            string[] s = str.Split(' ');
            for (int i = 0; i < s.Length; i++)
            {
                if (s[i].Length > 1)
                    s[i] = s[i].Substring(0, 1).ToUpper() + s[i].Substring(1, s[i].Length - 1);
                else s[i] = s[i].ToUpper();
            }
            return string.Join(" ", s);
        }
        #endregion
    }
}

// --- End of file: TPWipeSchedule.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ProfanityFilter.cs ---
// --- Original Local Path: ProfanityFilter.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins {
    [Info("ProfanityFilter", "OwnProx", "1.0.1")]
    class ProfanityFilter : RustPlugin 
	{
		/*
		* Configurable Options
		*/
		string[] IllegalWords = {"fuck", "shit", "cunt", "whore", "nigger", "negro", "barstard", "arsehole", "dickhead", "bollocks", "bitch",
		"slag", "wanker", "bellend"};
		bool TempBanOnBadWords = true, BanOnBadWord = false, KickOnBadWord = true; //set both to false to just ignore the message in chat
		int TempBanTime = 1; //1 = 30 mins, 2 = 60, 3 = 90  and so on
		
		/* Do Not Edit */
		private Dictionary<ulong, float> Bans = new Dictionary<ulong, float>();
		private System.Timers.Timer timer;
		private DateTime NowTimePlease = new DateTime(2016, 2, 2, 0, 0, 0);
		private List<ulong> IdsToRemove = new List<ulong>();
		
		private object OnPlayerChat(ConsoleSystem.Arg arg)
		{
			if(arg != null)
			{
				string playerChat = arg.GetString(0, "text").ToLower();
				BasePlayer player = arg.connection.player as BasePlayer;
				if (player != null && playerChat != null)
				{
					for(int i = 0; i < IllegalWords.Length; i++) 
					if(playerChat.Contains(IllegalWords[i]))
					{
						if(TempBanOnBadWords)
						{
							Bans.Add(player.userID, (float)(GetTimestamp() + (300000f * TempBanTime)));
							Network.Net.sv.Kick(player.net.connection, "Stop swearing you've been banned for " + TempBanTime * 30 + " Minutes!");							
						}
						else
						{					
							if(BanOnBadWord) ConsoleSystem.Run.Server.Quiet(string.Format("banid {0} \"{1}\" \"{2}\"", player.UserIDString, player.displayName, "Banned for swearing!"),true);
							if(BanOnBadWord || KickOnBadWord) Network.Net.sv.Kick(player.net.connection, "Banned for swearing!");
						}
						return "handled";
					}
				}
			}
			return null;
		}
		
		private void OnPlayerInit(BasePlayer player)
		{
			float t = 0f;
			if(Bans.TryGetValue(player.userID, out t) && t > GetTimestamp()) Network.Net.sv.Kick(player.net.connection, "You are still banned for " + (int) Math.Round(((t-GetTimestamp()) / 60000), 0) + " minutes.");
		}
		
		private void Loaded()
        {
			timer = new System.Timers.Timer();
            timer.Interval = 1200000;
            timer.Elapsed += new System.Timers.ElapsedEventHandler(OnTimer);
			timer.Start();	
        }
		
		private void Unload()
		{
			Bans.Clear();
			timer.Stop();
			timer.Dispose();
		}
		
		private double GetTimestamp()
		{
			return System.DateTime.UtcNow.Subtract(NowTimePlease).TotalMilliseconds;
		}
	
		private void OnTimer(object sender, System.Timers.ElapsedEventArgs e)
        {
			double time = GetTimestamp();
			foreach(KeyValuePair<ulong, float> p in Bans) if(time > p.Value) IdsToRemove.Add(p.Key);
			foreach(ulong i in IdsToRemove) Bans.Remove(i);
			IdsToRemove.Clear();
		}
    }
}

// --- End of file: ProfanityFilter.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NPCGifts.cs ---
// --- Original Local Path: NPCGifts.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("NPCGifts", "Mabel", "1.0.2")]
    class NPCGifts : RustPlugin
    {
        private class ContainerData
        {
            public string Prefab { get; set; }
            public float SpawnChance { get; set; }
            public bool IsEnabled { get; set; }
            public string Permission { get; set; }
        }

        private class CooldownData
        {
            public ulong PlayerID { get; set; }
            public DateTime LastSpawnTime { get; set; }
        }

        private List<ContainerData> containerList;
        private Dictionary<ulong, CooldownData> cooldowns = new Dictionary<ulong, CooldownData>();
        private List<BaseEntity> spawnedContainers = new List<BaseEntity>();
        private float cooldownDurationMinutes = 60;
        private System.Random random;

        private string containerReceivedMessage;

        protected override void LoadDefaultConfig()
        {
            Config["Containers"] = new List<object>
            {
                new Dictionary<string, object>
                {
                    ["Prefab"] = "assets/prefabs/misc/xmas/sleigh/presentdrop.prefab",
                    ["SpawnChance"] = 0.5f,
                    ["IsEnabled"] = true,
                    ["Permission"] = "npcgifts.example1"
                },
                new Dictionary<string, object>
                {
                    ["Prefab"] = "assets/prefabs/missions/portal/proceduraldungeon/xmastunnels/loot/xmastunnellootbox.prefab",
                    ["SpawnChance"] = 0.5f,
                    ["IsEnabled"] = true,
                    ["Permission"] = "npcgifts.example2"
                },
                new Dictionary<string, object>
                {
                    ["Prefab"] = "assets/prefabs/misc/xmas/giftbox/giftbox_loot.prefab",
                    ["SpawnChance"] = 0.5f,
                    ["IsEnabled"] = true,
                    ["Permission"] = "npcgifts.example3"
                }
            };
            Config["CooldownDurationMinutes"] = cooldownDurationMinutes;

            containerReceivedMessage = Config.Get("ContainerReceivedMessage", " :santahat: Merry Christmas <color=#4A95CC>{player.name}</color> from <color=#4A95CC>{server.name}</color> :santahat:") as string;
            Config["ContainerReceivedMessage"] = containerReceivedMessage;

            SaveConfig();
        }

        void Init()
        {
            LoadConfigValues();
            cooldownDurationMinutes = Convert.ToSingle(Config["CooldownDurationMinutes"]);
            random = new System.Random();

            CheckAndCreatePermissions();

            timer.Once(300f, () => CleanupContainers());
        }

        private void CheckAndCreatePermissions()
        {
            foreach (var containerData in containerList)
            {
                if (!string.IsNullOrEmpty(containerData.Permission))
                {
                    if (!permission.PermissionExists(containerData.Permission, this))
                    {
                        permission.RegisterPermission(containerData.Permission, this);
                    }
                }
            }
        }

        void LoadConfigValues()
        {
            object configObject = Config["Containers"];
            if (configObject is List<object>)
            {
                containerList = (configObject as List<object>).Select(x =>
                {
                    var containerData = new ContainerData
                    {
                        Prefab = Convert.ToString(((Dictionary<string, object>)x).GetValueOrDefault("Prefab", string.Empty)),
                        SpawnChance = Convert.ToSingle(((Dictionary<string, object>)x).GetValueOrDefault("SpawnChance", 0.0f)),
                        IsEnabled = Convert.ToBoolean(((Dictionary<string, object>)x).GetValueOrDefault("IsEnabled", false)),
                        Permission = Convert.ToString(((Dictionary<string, object>)x).GetValueOrDefault("Permission", string.Empty))
                    };

                    return containerData;
                }).ToList();

                if (containerList.Any(c => string.IsNullOrEmpty(c.Permission)))
                {
                    foreach (var containerData in containerList)
                    {
                        if (string.IsNullOrEmpty(containerData.Permission))
                        {
                            containerData.Permission = $"npcgifts.example{containerList.IndexOf(containerData) + 1}";
                        }
                    }

                    Config["Containers"] = containerList.Cast<object>().ToList();
                    SaveConfig();
                    Puts("Added missing permissions to config.");
                }
            }
            else
            {
                PrintWarning("Failed to load the configuration file. Using default values.");
                LoadDefaultConfig();
                SaveConfig();
                LoadConfigValues();
            }

            containerReceivedMessage = Config.Get("ContainerReceivedMessage") as string;
            if (containerReceivedMessage == null)
            {
                containerReceivedMessage = " :santahat: Merry Christmas <color=#4A95CC>{player.name}</color> from <color=#4A95CC>{server.name}</color> :santahat:";
                Config["ContainerReceivedMessage"] = containerReceivedMessage;
                SaveConfig();
            }	
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null) return;

            BaseEntity killer = hitInfo.Initiator as BaseEntity;
            BasePlayer player = killer as BasePlayer;

            if (player != null && entity.GetComponent<HumanNPC>() != null)
            {
                if (!HasCooldown(player.userID))
                {
                    SpawnRandomContainer(entity.transform.position, player.userID);
                    SetCooldown(player.userID);
                }
            }
        }

        private void SpawnRandomContainer(Vector3 position, ulong playerID)
        {
            if (containerList == null || containerList.Count == 0) return;

            random = new System.Random();

            foreach (var containerData in containerList.Where(c => c.IsEnabled))
            {
                if (random.NextDouble() <= containerData.SpawnChance)
                {
                    if (string.IsNullOrEmpty(containerData.Permission) || permission.UserHasPermission(playerID.ToString(), containerData.Permission))
                    {
                        BaseEntity container = GameManager.server.CreateEntity(containerData.Prefab, position);

                        if (container != null)
                        {
                            container.Spawn();
                            spawnedContainers.Add(container);
                            BasePlayer player = BasePlayer.FindByID(playerID);
                            if (player != null)
                            {
                                SendChatMessage(player, ReplacePlaceholders(containerReceivedMessage, player));
                            }
                        }
                    }

                    break;
                }
            }
        }

        private void SendChatMessage(BasePlayer player, string message)
        {
            if (player == null || string.IsNullOrEmpty(message)) return;
            player.ChatMessage(message);
        }

        private bool HasCooldown(ulong playerID)
        {
            if (cooldowns.ContainsKey(playerID))
            {
                var cooldownData = cooldowns[playerID];
                var elapsedTime = DateTime.Now - cooldownData.LastSpawnTime;
                return elapsedTime.TotalMinutes < cooldownDurationMinutes;
            }
            return false;
        }

        private void SetCooldown(ulong playerID)
        {
            if (cooldowns.ContainsKey(playerID))
            {
                cooldowns[playerID].LastSpawnTime = DateTime.Now;
            }
            else
            {
                cooldowns[playerID] = new CooldownData
                {
                    PlayerID = playerID,
                    LastSpawnTime = DateTime.Now
                };
            }
        }

        private string ReplacePlaceholders(string message, BasePlayer player)
        {
            if (player == null || string.IsNullOrEmpty(message)) return message;

            string playerName = player.displayName;
            string serverName = ConVar.Server.hostname;

            return message.Replace("{player.name}", playerName).Replace("{server.name}", serverName);
        }

        private void CleanupContainers()
        {
            foreach (var container in spawnedContainers)
            {
                if (container != null && !container.IsDestroyed)
                {
                    container.Kill();
                }
            }
        }

        void Unload()
        {
            CleanupContainers();
        }
    }
}

// --- End of file: NPCGifts.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomSpawnPoints.cs ---
// --- Original Local Path: CustomSpawnPoints.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("CustomSpawnPoints", "Reneb", "1.0.4", ResourceId = 1076)]
    public class CustomSpawnPoints : RustPlugin
    {

        [PluginReference]
        Plugin Spawns;

        bool activated = false;


        /////////////////////////////////////////
        // Oxide Hooks
        /////////////////////////////////////////
        BasePlayer.SpawnPoint OnFindSpawnPoint()
        {
            if (!activated) return null;
            var targetpos = Spawns.Call("GetRandomSpawn", new object[] { spawnsname });
            if (targetpos is string)
                return null;
            BasePlayer.SpawnPoint point = new BasePlayer.SpawnPoint();
            point.pos = (Vector3)targetpos;
            Debug.Log(point.pos.ToString());
            point.rot = new Quaternion(0f, 0f, 0f, 1f);
            RaycastHit hit;
            if (checkDown != 0f)
            {
                if (Physics.Raycast(new Ray(point.pos + vectorUp, Vector3.down), out hit, checkDown, -1063190271))
                {
                    point.pos = hit.point;
                }
            }
            return point;
        }

        /////////////////////////////////////////
        // Config Manager
        /////////////////////////////////////////
        private static string spawnsname = "spawnfile";
        static string MessagesPermissionsNotAllowed = "You are not allowed to use this command";
        static string CheckUp = "1.0";
        static string CheckDown = "1.0";
        Vector3 vectorUp = new Vector3(0f, 1f, 0f);
        float checkDown = 2f;

        void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        
        void Init()
        {
            CheckCfg<string>("Settings - Spawn Database Name", ref spawnsname);
            CheckCfg<string>("Messages - Permissions - Not Allowed", ref MessagesPermissionsNotAllowed);
            CheckCfg<string>("Spawn Fix - Check from Xm up", ref CheckUp);
            CheckCfg<string>("Spawn Fix - Check to Xm down", ref CheckDown);
            vectorUp = new Vector3(0f, Convert.ToSingle(CheckUp), 0f);
            checkDown = Convert.ToSingle(CheckUp) + Convert.ToSingle(CheckDown);
            SaveConfig();
        }

        void OnServerInitialized()
        {
            LoadSpawns();
        }

        void LoadSpawns()
        {
            activated = false;
            object success = Spawns.Call("GetSpawnsCount", new object[] { spawnsname });
            if (success is string)
            {
                Debug.Log("Custom Spawn Points - ERROR:" + (string)success);
                return;
            }
            int count = 0;
            if (!int.TryParse(success.ToString(), out count))
            {
                Debug.Log(string.Format("Custom Spawn Points - ERROR: {0} is not a valid spawnfile",spawnsname));
                return;
            }
            if (count < 1)
            {
                Debug.Log("Custom Spawn Points - ERROR: You must have at least 1 spawn in your spawnfile");
                return;
            }
            Debug.Log(string.Format("Custom Spawn Points: {0} spawn points loaded", count.ToString()));
            activated = true;
        }

        bool hasAccess(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 2)
                {
                    SendReply(arg, MessagesPermissionsNotAllowed);
                    return false;
                }
            }
            return true;
        }
        [ConsoleCommand("spawns.config")]
        void ccmdSpawnFile(ConsoleSystem.Arg arg)
        {
            if (!hasAccess(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "spawns.config SPAWNFILENAME");
                return;
            }
            object success = Spawns.Call("GetSpawnsCount", new object[] { arg.Args[0] });
            if (success is string)
            {
                SendReply(arg, (string)success);
                return;
            }
            int count = 0;
            if(!int.TryParse(success.ToString(), out count))
            {
                SendReply(arg, "This is not a valid spawnfile");
                return;
            }
            if (count < 1)
            {
                SendReply(arg, "You must have at least 1 spawn in your spawnfile");
                return;
            }
            SendReply(arg,string.Format("{0} spawns loaded", count.ToString()));
            spawnsname = arg.Args[0];
            SaveConfig();
            LoadSpawns();
        }
    }
}


// --- End of file: CustomSpawnPoints.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ShopSystem.cs ---
// --- Original Local Path: ShopSystem.cs ---

using System.Collections.Generic;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using System;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("ShopSystem", "Sempai#3239", "1.0.0")]
    class ShopSystem : RustPlugin
    {
        #region Вар
        string Layer = "Shop_UI";

        ShopSystem ins;

        [PluginReference] Plugin ImageLibrary;

        Dictionary<ulong, string> ActiveButton = new Dictionary<ulong, string>();

        Dictionary<ulong, DataBase> DB = new Dictionary<ulong, DataBase>();

        public int Times = 70;
        public int RP = 100;
        #endregion

        #region Класс
        List<string> Category = new List<string>()
        {
            "All",
            "Ammunition",
            "Attire",
            "Components",
            "Construction",
            "Electrical",
            "Food",
            "Resources",
            "Tools",
            "Weapons"
        };

        public class Settings
        {
            public string ShortName;
            public int Amount;
            public int Price;
            public string Category;
        }

        public class DataBase
        {
            public int Rp = 0;
            public int Time = 70;
            public List<string> Item = new List<string>()
            {
                ""
            };
        }
        #endregion

        #region Конфиг
        Configuration config;
        class Configuration 
        {
            public List<Settings> settings;
            public static Configuration GetNewConfig() 
            {
                return new Configuration
                {
                    settings = new List<Settings>
                    {
                        new Settings
                        {
                            ShortName = "rifle.ak",
                            Amount = 1,
                            Price = 10,
                            Category = "Weapons"
                        }
                    }
                };
            }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        void OnServerInitialized()
        {
            foreach (var check in config.settings)
                ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{check.ShortName}.png", check.ShortName);

            foreach (var check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            CreateDataBase(player); 
            TimeUpdate(player);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason) => SaveDataBase(player.userID);

        void Unload() 
        {
            foreach(var check in DB)
                SaveDataBase(check.Key);
        }
        #endregion

        #region Дата
        void CreateDataBase(BasePlayer player)
        {
            var DataBase = Interface.Oxide.DataFileSystem.ReadObject<DataBase>($"ShopSystem/{player.userID}");
            
            if (!DB.ContainsKey(player.userID))
                DB.Add(player.userID, new DataBase());
             
            DB[player.userID] = DataBase ?? new DataBase();
        }

        void SaveDataBase(ulong userId) => Interface.Oxide.DataFileSystem.WriteObject($"ShopSystem/{userId}", DB[userId]);
        #endregion

        #region Команды
        [ConsoleCommand("shop")]
        void ConsoleShop(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "category")
                {
                    ActiveButton[player.userID] = args.Args[1];
                    ItemUI(player, args.Args[1]);
                }
                if (args.Args[0] == "all")
                {
                    var db = DB[player.userID].Item;
                    if (db.Contains(args.Args[1]))
                        db.Remove(args.Args[1]);
                    else
                       db.Add(args.Args[1]);

                    ItemUI(player, ActiveButton[player.userID]);
                }
                if (args.Args[0] == "skip")
                {
                    ItemUI(player, ActiveButton[player.userID], int.Parse(args.Args[1]));
                }
                if (args.Args[0] == "buy")
                {
                    if (player.inventory.containerMain.itemList.Count >= 24)
                    {
                        SendReply(player, "Not enough space");
                        return;
                    }
                    var check = config.settings.FirstOrDefault(z => z.ShortName == args.Args[1]);
                    if (DB[player.userID].Rp >= check.Price)
                    {
                        var item = ItemManager.CreateByName(check.ShortName, check.Amount);
                        item.MoveToContainer(player.inventory.containerMain);
                        Effect x = new Effect("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", player, 0, new Vector3(), new Vector3());
                        EffectNetwork.Send(x, player.Connection);
                        DB[player.userID].Rp -= check.Price;
                        UpdateBalance(player);
                    }
                }
            }
        }
        #endregion

        #region Интерфейс
        void ShopUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            ActiveButton[player.userID] = "Ammunition";

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.284 0", AnchorMax = "0.952 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.6" },
            }, "Menu", Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.032 0.893", AnchorMax = $"0.347 0.954", OffsetMax = "0 0" },
                Image = { Color = "0.86 0.55 0.35 1" }
            }, Layer, "Title");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"SHOP", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-bold.ttf" }
            }, "Title");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.36 0.893", AnchorMax = $"0.97 0.954", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer, "Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"Current play time: <color=#db8c5a>{FormatShortTime(TimeSpan.FromSeconds(DB[player.userID].Time))}</color>", Align = TextAnchor.MiddleCenter, FontSize = 26, Font = "robotocondensed-regular.ttf" }
            }, "Description");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.03 0.02", AnchorMax = $"0.25 0.07", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer, "Balance");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"Balance: {DB[player.userID].Rp} RP", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Balance");

            CuiHelper.AddUi(player, container);
            ItemUI(player, ActiveButton[player.userID]);
        }

        void ItemUI(BasePlayer player, string category, int page = 0)
        {
            CuiHelper.DestroyUi(player, "Item");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" },
            }, Layer, "Item");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.85 0.02", AnchorMax = $"0.97 0.07", OffsetMax = "0 0" },
                Button = { Color = "0.86 0.55 0.35 1", Command = $"shop skip {page + 1}" },
                Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Item");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.72 0.02", AnchorMax = $"0.84 0.07", OffsetMax = "0 0" },
                Button = { Color = "0.86 0.55 0.35 1", Command = page >= 1 ? $"shop skip {page - 1}" : "" },
                Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Item");

            float width = 0f, height = 0.055f, startxBox = 0.028f, startyBox = 0.86f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in Category)
            {
                if (check == "All")
                    width = 0.05f;
                else
                    width = 0.0993f;

                var text = check == "All" ? "" : check;
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Button = { Color = "0 0 0 0.5", Command = $"shop category {check}" },
                    Text = { Text = text, Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, "Item", "Color");

                var color = ActiveButton[player.userID] == check ? "1 1 1 1" : "0 0 0 0";
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.1", OffsetMax = "0 0" },
                    Image = { Color = color },
                }, "Color");

                if (check == "All")
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Color",
                        Components =
                        {
                            new CuiImageComponent { Sprite = "assets/icons/bleeding.png", FadeIn = 0.5f, Color = "0.86 0.55 0.35 1" },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "7 7", OffsetMax = "-7 -7" }
                        }
                    });
                }

                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }

            float width1 = 0.1572f, height1 = 0.18f, startxBox1 = 0.028f, startyBox1 = 0.8f - height1, xmin1 = startxBox1, ymin1 = startyBox1;

            if (ActiveButton[player.userID] == "All")
            {
                foreach (var items in DB[player.userID].Item.Skip(page * 24).Take(24))
                {
                            foreach (var check in config.settings.Where(z => z.ShortName == items))
            {
                if (DB[player.userID].Item.Contains(check.ShortName))
                {
                    Puts(check.ShortName);
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"{xmin1} {ymin1}", AnchorMax = $"{xmin1 + width1} {ymin1 + height1 * 1}", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                        Image = { Color = "1 1 1 0.15" }
                    }, "Item", "Items");

                    container.Add(new CuiElement
                    {
                        Parent = "Items",
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.ShortName), FadeIn = 0.5f },
                            new CuiRectTransformComponent { AnchorMin = "0 0.3", AnchorMax = "1 1", OffsetMin = "30 18", OffsetMax = "-30 -5" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.8 0.79", AnchorMax = "1 0.99", OffsetMax = "0 0" },
                        Button = { Color = "1 1 1 0", Command = $"shop all {check.ShortName}" },
                        Text = { Text = "" }
                    }, "Items", "All");

                    var color = DB[player.userID].Item.Contains(check.ShortName) ? "0.86 0.55 0.35 1" : "1 1 1 1";
                    container.Add(new CuiElement
                    {
                        Parent = "All",
                        Components =
                        {
                            new CuiImageComponent { Sprite = "assets/icons/bleeding.png", FadeIn = 0.5f, Color = color },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "3 3", OffsetMax = "-3 -3" }
                        }
                    });

                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0 0.2", AnchorMax = "1 0.43", OffsetMax = "0 0" },
                        Image = { Color = "1 1 1 0.6" },
                    }, "Items", "Name");

                    var item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(check.ShortName).itemid, 1, 0);
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = $"0.03 0", AnchorMax = $"0.8 1", OffsetMax = "0 0" },
                        Text = { Text = $"{item.info.displayName.english}", Color = "0 0 0 1", Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                    }, "Name");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.97 1", OffsetMax = "0 0" },
                        Text = { Text = $"x{check.Amount}", Color = "0 0 0 1", Align = TextAnchor.MiddleRight, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                    }, "Name");

                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2", OffsetMax = "0 0" },
                        Image = { Color = "0.38 0.37 0.38 1" },
                    }, "Items", "Price");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = $"0.03 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                        Text = { Text = $"{check.Price} RP", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                    }, "Price");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"0.7 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 1", Command = $"shop buy {check.ShortName}" },
                        Text = { Text = $"BUY", Align = TextAnchor.MiddleCenter, FontSize = 17, Font = "robotocondensed-bold.ttf" }
                    }, "Price");

                    xmin1 += width1;
                    if (xmin1 + width1 >= 1)
                    {
                        xmin1 = startxBox1;
                        ymin1 -= height1;
                    }
                }
            }
            }
            }
            else
            {
foreach (var check in config.settings.Where(z => z.Category == ActiveButton[player.userID]).Skip(page * 24).Take(24))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{xmin1} {ymin1}", AnchorMax = $"{xmin1 + width1} {ymin1 + height1 * 1}", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                    Image = { Color = "1 1 1 0.15" }
                }, "Item", "Items");

                container.Add(new CuiElement
                {
                    Parent = "Items",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.ShortName), FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0.3", AnchorMax = "1 1", OffsetMin = "30 18", OffsetMax = "-30 -5" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.8 0.79", AnchorMax = "1 0.99", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0", Command = $"shop all {check.ShortName}" },
                    Text = { Text = "" }
                }, "Items", "All");

                var color = DB[player.userID].Item.Contains(check.ShortName) ? "0.86 0.55 0.35 1" : "1 1 1 1";
                container.Add(new CuiElement
                {
                    Parent = "All",
                    Components =
                    {
                        new CuiImageComponent { Sprite = "assets/icons/bleeding.png", FadeIn = 0.5f, Color = color },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "3 3", OffsetMax = "-3 -3" }
                    }
                });

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0.2", AnchorMax = "1 0.43", OffsetMax = "0 0" },
                    Image = { Color = "1 1 1 0.6" },
                }, "Items", "Name");

                var item = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(check.ShortName).itemid, 1, 0);
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.03 0", AnchorMax = $"0.8 1", OffsetMax = "0 0" },
                    Text = { Text = $"{item.info.displayName.english}", Color = "0 0 0 1", Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                }, "Name");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.97 1", OffsetMax = "0 0" },
                    Text = { Text = $"x{check.Amount}", Color = "0 0 0 1", Align = TextAnchor.MiddleRight, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                }, "Name");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2", OffsetMax = "0 0" },
                    Image = { Color = "0.38 0.37 0.38 1" },
                }, "Items", "Price");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.03 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = $"{check.Price} RP", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "Price");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.7 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 1", Command = $"shop buy {check.ShortName}" },
                    Text = { Text = $"BUY", Align = TextAnchor.MiddleCenter, FontSize = 17, Font = "robotocondensed-bold.ttf" }
                }, "Price");

                xmin1 += width1;
                if (xmin1 + width1 >= 1)
                {
                    xmin1 = startxBox1;
                    ymin1 -= height1;
                }
            }
            }

            CuiHelper.AddUi(player, container);
        }

        void UpdateBalance(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "Balance");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.03 0.02", AnchorMax = $"0.25 0.07", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer, "Balance");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"Balance: {DB[player.userID].Rp} RP", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-regular.ttf" }
            }, "Balance");

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Хелпер
        Timer Timer = null;
        void TimeUpdate(BasePlayer player)
        {
            Timer = timer.Every(60f, () => {
                if (player.IsConnected)
                {
                    var db = DB[player.userID];
                    db.Time -= 60;
                    if (db.Time <= 0)
                    {
                        db.Time = Times;
                        db.Rp += RP;
                        Timer.Destroy();
                        TimeUpdate(player);
                    }
                }
            });
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            result = $"{time.Hours.ToString("00")}:";
            result += $"{time.Minutes.ToString("00")}:";
            result += $"{time.Seconds.ToString("00")}";
            return result;
        }

        double CurTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        #endregion
    }
}

// --- End of file: ShopSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VehicleNoDamage.cs ---
// --- Original Local Path: VehicleNoDamage.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace Oxide.Plugins
{
    [Info("VehicleNoDamage", "Frizen", "1.0.0")]

    public class VehicleNoDamage : RustPlugin
    {

        private object OnEntityTakeDamage(BaseVehicle entity, HitInfo hitInfo)
        {
            if (entity is BaseVehicle)
            {
                return false;
            }
            return null; 
        }

        bool CanMount = false;

        [ChatCommand("stop")]
        void CmdMountNo(BasePlayer player)
        {
            if (!player.IsAdmin) return;
            CanMount = false;
        }
        [ChatCommand("start")]
        void CmdMountYes(BasePlayer player)
        {
            if (!player.IsAdmin) return;
            CanMount = true;
        }


       
        object CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            if (CanMount == false) return false;
            return null;
        }


       
        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot, int amount)
        {
            if (item.info.shortname == "crankshaft3" || item.info.shortname == "carburetor3" || item.info.shortname == "piston3" || item.info.shortname == "sparkplug3" || item.info.shortname == "valve3" || item.info.shortname == "lowgradefuel") return false;
            return null;
        }




        private object OnEntityTakeDamage(BaseVehicleModule entity, HitInfo hitInfo)
        {
            if (entity is BaseVehicleModule)
            {
                return false;
            }
            return null;
        }


    }
}


// --- End of file: VehicleNoDamage.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MinicopterCombat.cs ---
// --- Original Local Path: MinicopterCombat.cs ---

﻿/* Copyright (c) 2019 Karuza */

using Oxide.Core;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries;

using System;
using System.Collections.Generic;
using UnityEngine;

using System.Linq;

using Rust;
using Newtonsoft.Json;
using ProtoBuf;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("MinicopterCombat", "Karuza", "01.00.02")]
    public class MinicopterCombat : RustPlugin
    {
        [PluginReference]
        Plugin BulletProjectile;

        #region Variables
        private static MinicopterCombat instance;

        private static string[] enabledMiniWeaponTypes;
        private static string[] enabledScrapWeaponTypes;

        private static readonly Dictionary<string, int> weaponsToAmmoTypeItemIdMap = new Dictionary<string, int>();
        private static Permission permissionHelper;

        private static string clear = "0 0 0 0";
        private static string green = "0 1 0 0.4";
        private static string darkGreen = "0 1 0 0.7";
        private static string red = "1 0 0 0.4";
        private static string darkRed = "1 0 0 0.7";
        private static string solidRed = "1 0 0 1";
        private static string white = "1.0 1.0 1.0";
        private static string orange = "0.7 0.4 0 0.7";

        private static string gold = "1.000000000 0.819607843 0.137254902";

        private static string permAdmin = "MinicopterCombat.AdminPerm";
        private static string reticleOverlayName = "AimReticle";
        private static string primaryAmmoOverlayName = "PrimaryAmmoCounter";
        private static string secondaryAmmoOverlayName = "SecondaryAmmoCounter";
        private static string flareAmmoOverlayName = "FlareAmmoCounter";

        private static string primaryCooldownOverlayName = "PrimaryCooldownGui";
        private static string secondaryCooldownOverlayName = "SecondaryCooldownGui";
        private static string flareCooldownOverlayName = "FlareCooldownGui";
        private static string weaponTypeOverlayName = "WeaponSelector";
        private static string targetLockGuiName = "TargetLockGui";
        private static string targetMessageGuiName = "TargetMessageGui";

        private static string flarePrefab = "assets/prefabs/tools/flareold/flare.deployed.prefab";

        private static LayerMask layerMask = LayerMask.GetMask("Vehicle Movement", "Vehicle Large");

        private static Configuration configuration;

        #endregion

        #region Methods

        private void RegisterPermissions()
        {
            permission.RegisterPermission(permAdmin, this);
            foreach (var weaponSetting in configuration.WeaponSettings)
            {
                permission.RegisterPermission(weaponSetting.Value.WeaponPermission, this);
            }

            foreach (var weaponSetting in configuration.ScrapcopterWeaponSettings)
            {
                permission.RegisterPermission(weaponSetting.Value.WeaponPermission, this);
            }

            permissionHelper = permission;
        }

        void DestroyMinicopterCombatWrappers()
        {
            var miniCopterCombatWrappers = UnityEngine.Object.FindObjectsOfType<MinicopterWrapper>();
            foreach (var miniCopterCombatWrapper in miniCopterCombatWrappers)
                UnityEngine.Object.Destroy(miniCopterCombatWrapper);

            var scrapWrappers = UnityEngine.Object.FindObjectsOfType<ScrapcopterWrapper>();
            foreach (var scrapWrapper in scrapWrappers)
                UnityEngine.Object.Destroy(scrapWrapper);
        }

        static void GetEnabledWeapons()
        {
            enabledMiniWeaponTypes = configuration.WeaponSettings
                .Where(kv => kv.Value.Enabled)
                .Select(kv => kv.Key)
                .ToArray();

            enabledScrapWeaponTypes = configuration.ScrapcopterWeaponSettings
                .Where(kv => kv.Value.Enabled)
                .Select(kv => kv.Key)
                .ToArray();
        }

        void UpdateExistingMinicopters()
        {
            DestroyMinicopterCombatWrappers();

            var miniCopters = BaseNetworkable.serverEntities.OfType<MiniCopter>();
            foreach (var miniCopter in miniCopters)
            {
                if (miniCopter.name.Contains("scraptransporthelicopter"))
                {
                    if (configuration.ApplyToScrapCopter)
                    {
                        miniCopter.gameObject.AddComponent<ScrapcopterWrapper>();
                    }
                    continue;
                }
                else
                {
                    miniCopter.gameObject.AddComponent<MinicopterWrapper>();
                }
            }
        }

        void GetWeaponAmmoTypeItemIds()
        {
            foreach (var wt in configuration.WeaponSettings)
            {
                AddAmmoTypeToAmmoTypeMap(wt.Value.FlareShortName);
                AddAmmoTypeToAmmoTypeMap(wt.Value.PrimaryWeapon?.AmmoTypeShortName);
                AddAmmoTypeToAmmoTypeMap(wt.Value.SecondaryWeapon?.AmmoTypeShortName);
            }

            foreach (var wt in configuration.ScrapcopterWeaponSettings)
            {
                AddAmmoTypeToAmmoTypeMap(wt.Value.FlareShortName);
                AddAmmoTypeToAmmoTypeMap(wt.Value.PrimaryWeapon?.AmmoTypeShortName);
                AddAmmoTypeToAmmoTypeMap(wt.Value.SecondaryWeapon?.AmmoTypeShortName);
            }
        }

        private void AddAmmoTypeToAmmoTypeMap(string ammoTypeShortName)
        {
            if (string.IsNullOrEmpty(ammoTypeShortName))
                return;

            if (!weaponsToAmmoTypeItemIdMap.ContainsKey(ammoTypeShortName))
                weaponsToAmmoTypeItemIdMap[ammoTypeShortName] = ItemManager.itemList.Find(x => x.shortname == ammoTypeShortName)?.itemid ?? 0;
        }

        private static float AngleOffAroundAxis(Vector3 v, Vector3 forward, Vector3 axis)
        {
            Vector3 right = Vector3.Cross(forward, axis);
            forward = Vector3.Cross(axis, right);
            return Mathf.Atan2(Vector3.Dot(v, right), Vector3.Dot(v, forward)) * Mathf.Rad2Deg;
        }

        #endregion

        #region Config

        public class Configuration
        {
            [JsonProperty]
            public float DebounceTimeSeconds { get; set; } = 4;

            [JsonProperty]
            public bool DisplayOutOfAmmoMessage { get; set; } = true;

            [JsonProperty]
            public bool DisplaySelectedWeaponMessage { get; set; } = true;

            [JsonProperty]
            public bool UnlimitedAmmo { get; set; } = false;

            [JsonProperty]
            public bool DisablePermissionCheck { get; set; } = false;

            [JsonProperty]
            public bool ApplyToScrapCopter { get; set; } = false;

            [JsonProperty]
            public string FlareFiredSfx { get; set; } = "assets/prefabs/deployable/research table/effects/research-table-deploy.prefab";

            [JsonProperty]
            public string SwitchWeaponSfx { get; set; } = "assets/prefabs/deployable/dropbox/effects/submit_items.prefab";

            [JsonProperty]
            public string AlarmSfx { get; set; } = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";

            [JsonProperty]
            public float CounterMeasureDespawnTime { get; set; } = 5f;

            [JsonProperty]
            public float WeaponSwitchDelay { get; set; } = 1f;

            [JsonProperty]
            public BUTTON FirePrimaryButton { get; set; } = BUTTON.FIRE_PRIMARY;

            [JsonProperty]
            public BUTTON FireSecondaryButton { get; set; } = BUTTON.FIRE_SECONDARY;

            [JsonProperty]
            public BUTTON SwitchWeaponButton { get; set; } = BUTTON.FIRE_THIRD;

            [JsonProperty]
            public BUTTON FireFlareButton { get; set; } = BUTTON.USE;

            [JsonProperty]
            public bool EnableScrapcopterGibs { get; set; }

            [JsonProperty]
            public float GibsDespawnTimerOverride { get; set; }

            [JsonProperty]
            public bool DisableFire { get; set; }

            [JsonProperty]
            public bool HideUnauthorizedWeapons { get; set; }

            [JsonProperty]
            public Dictionary<string, WeaponSettings> WeaponSettings = new Dictionary<string, WeaponSettings>()
            {
                {
                    "Disarm", new WeaponSettings()
                    {
                        DisplayShortName = "DISARM",
                        DisplayFullName = "DISARMED",
                        HudConfiguration = HUDConfiguration.None,
                        Enabled = true
                    }
                }
            };

            [JsonProperty]
            public Dictionary<string, WeaponSettings> ScrapcopterWeaponSettings = new Dictionary<string, WeaponSettings>()
            {
                {
                    "Disarm", new WeaponSettings()
                    {
                        DisplayShortName = "DISARM",
                        DisplayFullName = "DISARMED",
                        HudConfiguration = HUDConfiguration.None,
                        Enabled = true
                    }
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                configuration = Config.ReadObject<Configuration>();
                if (configuration == null)
                    throw new Exception();
            }
            catch
            {
                Config.WriteObject(configuration, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            configuration = new Configuration();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configuration);
        }

        #endregion

        #region Hooks

        void OnServerInitialized()
        {
            LoadConfig();
            GetEnabledWeapons();
            UpdateExistingMinicopters();
            GetWeaponAmmoTypeItemIds();

            RegisterPermissions();
            instance = this;
        }

        void Unload()
        {
            DestroyMinicopterCombatWrappers();
        }

        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            var heliWrapper = entity.VehicleParent()?.GetComponent<HelicopterWrapper>();

            if (heliWrapper == null)
                return;

            heliWrapper.SetPlayer(player);
        }

        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (player == null || entity == null)
                return;

            var heliWrapper = entity.VehicleParent()?.GetComponent<HelicopterWrapper>();
            if (heliWrapper == null)
                return;

            heliWrapper.RemovePlayer(player);
        }

        void OnEntitySpawned(HelicopterDebris debris)
        {
            if (!debris.name.Contains("servergibs_scraptransport"))
                return;

            NextTick(() =>
            {
                if (debris == null || debris.IsDestroyed)
                {
                    return;
                }

                if (!configuration.EnableScrapcopterGibs)
                {
                    debris.Kill();
                }
                else if (configuration.GibsDespawnTimerOverride > 0)
                {
                    timer.Once(configuration.GibsDespawnTimerOverride, () =>
                    {
                        debris.Kill();
                        debris.SendNetworkUpdate();
                    });

                    return;
                }
            });
        }

        void OnEntitySpawned(MiniCopter miniCopter)
        {
            if (miniCopter == null)
                return;

            if (miniCopter.name.Contains("scraptransporthelicopter"))
            {
                if (configuration.ApplyToScrapCopter)
                {
                    miniCopter.gameObject.AddComponent<ScrapcopterWrapper>();
                }
                return;
            }

            miniCopter.gameObject.AddComponent<MinicopterWrapper>();
        }


        #endregion

        #region MinicopterWrapper
        public class ScrapcopterWrapper : HelicopterWrapper
        {
            // todo update
            protected override float maxAngle { get { return 14f; } }
            protected override float minAngle { get { return -14f; } }
            protected override float centerX { get { return 0.491f; } }
            protected override float centerY { get { return 0.57675f; } }

            protected override string reticleGuiOverlayMin { get { return "0.4230 0.485"; } }
            protected override string reticleGuiOverlayMax { get { return "0.5730 0.635"; } }
            protected override string primaryAmmoMin { get { return "0.3445 0.586"; } }
            protected override string primaryAmmoMax { get { return "0.4215 0.609"; } }
            protected override string secondaryAmmoMin { get { return "0.5754 0.586"; } }
            protected override string secondaryAmmoMax { get { return "0.6524 0.609"; } }
            protected override string flareMin { get { return "0.473 0.4884"; } }
            protected override string flareMax { get { return "0.5236 0.5084"; } }
            protected override string lockGuiMin { get { return "0.46 0.461"; } }
            protected override string lockGuiMax { get { return "0.536 0.483"; } }

            protected override string GetNextWeaponType(string current)
            {
                int i = Array.IndexOf<string>(enabledScrapWeaponTypes, current) + 1;
                return (enabledScrapWeaponTypes.Length == i) ? enabledScrapWeaponTypes[0] : enabledScrapWeaponTypes[i];
            }

            protected override Dictionary<string, WeaponSettings> GetAvailableWeapons()
            {
                return configuration.ScrapcopterWeaponSettings;
            }
        }

        public class MinicopterWrapper : HelicopterWrapper
        {
            protected override float maxAngle { get { return 14f; } }
            protected override float minAngle { get { return -14f; } }
            protected override float centerX { get { return 0.491f; } }
            protected override float centerY { get { return 0.47675f; } }

            protected override string reticleGuiOverlayMin { get { return "0.4205 0.365"; } }
            protected override string reticleGuiOverlayMax { get { return "0.5705 0.515"; } }
            protected override string primaryAmmoMin { get { return "0.34295 0.466"; } }
            protected override string primaryAmmoMax { get { return "0.4195 0.489"; } }
            protected override string secondaryAmmoMin { get { return "0.573 0.466"; } }
            protected override string secondaryAmmoMax { get { return "0.65 0.489"; } }
            protected override string flareMin { get { return "0.473 0.368"; } }
            protected override string flareMax { get { return "0.5236 0.388"; } }
            protected override string lockGuiMin { get { return "0.46 0.341"; } }
            protected override string lockGuiMax { get { return "0.536 0.363"; } }

            protected override string GetNextWeaponType(string current)
            {
                int i = Array.IndexOf<string>(enabledMiniWeaponTypes, current) + 1;
                return (enabledMiniWeaponTypes.Length == i) ? enabledMiniWeaponTypes[0] : enabledMiniWeaponTypes[i];
            }

            protected override Dictionary<string, WeaponSettings> GetAvailableWeapons()
            {
                return configuration.WeaponSettings;
            }
        }

        public class HelicopterWrapper : MonoBehaviour, Lock
        {
            #region Variables
            public Guid Id { get; set; }
            public float ChanceToLoseLock { get { return weaponSettings.ChanceToLoseLock; } }
            public bool IsAlive { get; set; }

            private BasePlayer player { get; set; } = null;
            private string selectedWeaponType { get; set; } = "Disarm";
            private WeaponSettings weaponSettings { get; set; }

            private bool IsLocked { get { return locks.Count > 0; } }
            private bool primaryCooldownContainerActive = false;
            private bool primaryCooldownContainerContrastActive = false;

            private bool secondaryCooldownContainerActive = false;
            private bool secondaryCooldownContainerContrastActive = false;

            private bool flareCooldownContainerActive = false;
            private bool flareCooldownContainerContrastActive = false;


            // To prevent spamming the player, log the message time
            private float lastMsgTime = 0.0f;
            private float lastPrimaryWeaponFiredTime = 0.0f;
            private float lastSecondaryWeaponFiredTime = 0.0f;
            private float lastWeaponSwitchTime = 0.0f;

            private int primaryRoundsFired = 0;
            private int secondaryRoundsFired = 0;
            private int flareRoundsFired = 0;

            private float primaryCooldownTimer = 0f;
            private float secondaryCooldownTimer = 0f;
            private float flareCooldownTimer = 0f;

            private int primaryCurrentBarrel = 0;
            private int secondaryCurrentBarrel = 0;

            private BaseVehicle vehicle { get; set; } = null;

            #region GuiOverrides
            protected virtual string reticleGuiOverlayMin { get { return "0 0"; } }
            protected virtual string reticleGuiOverlayMax { get { return "0 0"; } }
            protected virtual string primaryAmmoMin { get { return "0 0"; } }
            protected virtual string primaryAmmoMax { get { return "0 0"; } }
            protected virtual string secondaryAmmoMin { get { return "0 0"; } }
            protected virtual string secondaryAmmoMax { get { return "0 0"; } }
            protected virtual string flareMin { get { return "0 0"; } }
            protected virtual string flareMax { get { return "0 0"; } }
            protected virtual string lockGuiMin { get { return "0 0"; } }
            protected virtual string lockGuiMax { get { return "0 0"; } }

            #endregion

            #region AARocketProperties
            private float lockOnSeconds = 0f;
            private float lockedAt = 0.0f;
            private bool isLockAlarmPlaying = false;
            private bool targetLocked = false;
            private bool acquiringLock = false;
            private BaseEntity target = null;

            protected virtual float maxAngle { get { return 0f; } }
            protected virtual float minAngle { get { return 0f; } }
            protected virtual float centerX { get { return 0f; } }
            protected virtual float centerY { get { return 0f; } }

            private float targetAngleX = 0.0f;
            private float targetAngleY = 0.0f;
            #endregion

            #region CounterMeasures
            private float timeBeforeFlaresExpire = 2f;
            private float lastFlaresFiredTime = 0.0f;
            private bool leftFlareFiredLast { get; set; } = false;
            private Dictionary<Guid, Lock> locks { get; set; } = new Dictionary<Guid, Lock>();
            #endregion

            #endregion

            #region WeaponSystemsMethods
            protected virtual Dictionary<string, WeaponSettings> GetAvailableWeapons()
            {
                return new Dictionary<string, WeaponSettings>();
            }

            private void UpdateWeapons()
            {
                UpdateTargetLock();
                Toggle_DrawTargetLock(true);
                Toggle_CooldownGui(true);

                if (player.serverInput.WasJustPressed(configuration.SwitchWeaponButton))
                    SwitchWeaponType();

                if (player.serverInput.WasJustPressed(configuration.FireFlareButton))
                    FireFlares();

                if (this.selectedWeaponType.Equals("Disarm", StringComparison.InvariantCultureIgnoreCase))
                    return;

                if (player.serverInput.IsDown(configuration.FirePrimaryButton))
                {
                    FireProjectile(this.weaponSettings.PrimaryWeapon);
                }

                if (this.weaponSettings.SecondaryWeapon != null)
                {
                    if (player.serverInput.IsDown(configuration.FireSecondaryButton))
                        FireProjectile(this.weaponSettings.SecondaryWeapon);
                    else if (this.weaponSettings.SecondaryWeapon.ProjectileType == ProjectileType.TargetLocker)
                        ClearTarget();
                }
            }

            private void FireFlares()
            {
                if (!weaponSettings.FlaresEnabled)
                    return;

                if (weaponSettings.FlaresBeforeCooldown > 0 && weaponSettings.FlaresBeforeCooldown <= flareRoundsFired)
                    return;

                float currentTime = UnityEngine.Time.realtimeSinceStartup;
                if (currentTime < (lastFlaresFiredTime + weaponSettings.FlareFireRate))
                    return;

                if (!weaponSettings.UnlimitedFlares && !DoesUserHaveAmmo(weaponSettings.FlareShortName, currentTime))
                    return;

                GameObject flareEnt = GameManager.server.CreatePrefab(flarePrefab, this.vehicle.transform.position, new Quaternion(), false);
                BaseEntity flareBaseEnt = flareEnt.GetComponent<BaseEntity>();

                flareBaseEnt.enableSaving = false;
                flareBaseEnt.Spawn();
                flareEnt.SetActive(true);
                flareBaseEnt.transform.position = Vector3.MoveTowards(this.vehicle.transform.position, this.vehicle.transform.localPosition + (this.vehicle.transform.right * (leftFlareFiredLast ? 25f : -25f)), 5f);
                flareEnt.AddComponent<CounterMeasure>();
                if (!string.IsNullOrEmpty(configuration.FlareFiredSfx))
                {
                    Effect.server.Run(configuration.FlareFiredSfx, flareBaseEnt, 0, Vector3.back, Vector3.forward, null);
                }

                leftFlareFiredLast = !leftFlareFiredLast;
                lastFlaresFiredTime = currentTime;
                flareRoundsFired++;

                foreach (var lck in locks.Values.ToList())
                {
                    if (lck.ChanceToLoseLock > 0 && lck.ChanceToLoseLock < 100 && Oxide.Core.Random.Range(0, 100) < lck.ChanceToLoseLock)
                        continue;
                    lck.SetLockTarget(flareBaseEnt);
                }

                if (!weaponSettings.UnlimitedFlares)
                    UseAmmo(weaponSettings.FlareShortName, null);
            }

            private void ResetRoundsFiredByConfig(WeaponConfiguration weaponConfiguration, float lastFiredTime, ref int roundsFired, ref float cooldownTimer)
            {
                // weaponConfiguration.ShotsBeforeCoolDown <= 0 || 
                if (weaponConfiguration == null)
                    return;

                ResetRoundsFired(weaponConfiguration.CoolDownDecay, lastFiredTime, ref roundsFired, ref cooldownTimer);
            }

            private void ResetRoundsFired(float coolDownDecay, float lastFiredTime, ref int roundsFired, ref float cooldownTimer)
            {
                if (roundsFired <= 0)
                    return;

                float currentTime = UnityEngine.Time.realtimeSinceStartup;
                float timeSinceLastFired = (currentTime - lastFiredTime);
                if (timeSinceLastFired <= 1)
                    return;

                float timeSinceLastCooldownCheck = (currentTime - cooldownTimer);
                if (timeSinceLastCooldownCheck > coolDownDecay)
                {
                    --roundsFired;
                    cooldownTimer = currentTime;
                }

                if (roundsFired < 0)
                    roundsFired = 0;
            }

            private Vector3 GetMuzzlePosition(WeaponConfiguration weaponConfiguration, int currentBarrel)
            {
                Vector3 muzzlePos = Vector3.zero;
                var vehicleTransform = this.vehicle.transform;
                switch (weaponConfiguration.BarrelConfiguration)
                {
                    case BarrelConfiguration.Bottom:
                        muzzlePos = this.player.transform.localPosition + Vector3.down;
                        break;
                    case BarrelConfiguration.Side:
                        muzzlePos = vehicleTransform.localPosition + ((vehicleTransform.forward * 2.5f) + (vehicleTransform.right * 1.5f * (currentBarrel % 2 == 0 ? 1 : -1)));
                        break;
                    case BarrelConfiguration.SideOuter:
                        muzzlePos = vehicleTransform.localPosition + ((vehicleTransform.forward * 2.5f) + (vehicleTransform.right * 2f * (currentBarrel % 2 == 0 ? 1 : -1)));
                        break;
                    case BarrelConfiguration.DualFront:
                        muzzlePos = vehicleTransform.localPosition + ((vehicleTransform.forward * 3.5f) + (vehicleTransform.right * 0.75f * (currentBarrel % 2 == 0 ? 1 : -1)));
                        break;
                    case BarrelConfiguration.CenterFront:
                        muzzlePos = vehicleTransform.localPosition + (vehicleTransform.forward * 3.5f);
                        break;
                    case BarrelConfiguration.Gattling:
                        muzzlePos = GetGattlingMuzzlePos(vehicleTransform, currentBarrel);
                        break;
                    default:
                        break;
                }

                return muzzlePos;
            }

            private Vector3 GetGattlingMuzzlePos(Transform vehicleTransform, int currentBarrel)
            {
                Vector3 modifier = Vector3.zero;
                switch (currentBarrel)
                {
                    case 0:
                        modifier = (vehicleTransform.up * 0.30f);
                        break;
                    case 1:
                        modifier = (vehicleTransform.right * 0.30f);
                        break;
                    case 2:
                        modifier = ((vehicleTransform.right + (vehicleTransform.up * -1)) * 0.30f);
                        break;
                    case 3:
                        modifier = ((vehicleTransform.right + vehicleTransform.up) * 0.30f) * -1;
                        break;
                    case 4:
                        modifier = (vehicleTransform.right * 0.30f * -1);
                        break;
                    default:
                        break;
                }

                return vehicleTransform.localPosition + ((vehicleTransform.forward * 3.5f) + modifier);
            }

            private void TriggerMuzzleEffect(WeaponConfiguration weaponConfiguration, int currentBarrel)
            {
                if (string.IsNullOrEmpty(weaponConfiguration.MuzzleEffect))
                    return;

                Vector3 posLocal;
                switch (weaponConfiguration.BarrelConfiguration)
                {
                    case BarrelConfiguration.Side:
                        posLocal = (currentBarrel % 2 == 0 ? Vector3.right : Vector3.left) * 2 + (Vector3.forward / 1.8f);
                        break;
                    case BarrelConfiguration.SideOuter:
                        posLocal = (currentBarrel % 2 == 0 ? Vector3.right : Vector3.left) * 3 + (Vector3.forward / 1.8f);
                        break;
                    case BarrelConfiguration.DualFront:
                        posLocal = (currentBarrel % 2 == 0 ? Vector3.right : Vector3.left) / 2 + (Vector3.forward * 2.1f);
                        break;
                    case BarrelConfiguration.CenterFront:
                        posLocal = (Vector3.forward);
                        break;
                    case BarrelConfiguration.Gattling:
                        posLocal = GetGattlingEffectPos(currentBarrel);
                        break;
                    case BarrelConfiguration.Bottom:
                    default:
                        return;
                }

                Effect.server.Run(weaponConfiguration.MuzzleEffect, this.vehicle, 0, posLocal, Vector3.forward, null);
            }


            private Vector3 GetGattlingEffectPos(int currentBarrel)
            {
                Vector3 modifier = Vector3.zero;
                switch (currentBarrel)
                {
                    case 0:
                        modifier = Vector3.up;
                        break;
                    case 1:
                        modifier = Vector3.right;
                        break;
                    case 2:
                        modifier = Vector3.right + (Vector3.up * -1);
                        break;
                    case 3:
                        modifier = Vector3.right + Vector3.up * -1;
                        break;
                    case 4:
                        modifier = Vector3.left;
                        break;
                    default:
                        break;
                }

                return modifier / 3f + (Vector3.forward * 2.1f);
            }

            private void FireProjectile(WeaponConfiguration weaponConfiguration)
            {
                int currentBarrel = 0;
                float lastFiredTime = 0f;
                int roundsFired = 0;

                float currentTime = UnityEngine.Time.realtimeSinceStartup;
                if (weaponConfiguration == weaponSettings.PrimaryWeapon)
                {
                    weaponConfiguration = this.weaponSettings.PrimaryWeapon;
                    lastFiredTime = lastPrimaryWeaponFiredTime;
                    currentBarrel = primaryCurrentBarrel;
                    roundsFired = primaryRoundsFired;
                }
                else
                {
                    weaponConfiguration = this.weaponSettings.SecondaryWeapon;
                    lastFiredTime = lastSecondaryWeaponFiredTime;
                    currentBarrel = secondaryCurrentBarrel;
                    roundsFired = secondaryRoundsFired;
                }

                if (weaponConfiguration.ShotsBeforeCoolDown > 0 && weaponConfiguration.ShotsBeforeCoolDown <= roundsFired)
                    return;

                if (currentTime < (lastFiredTime + weaponConfiguration.FireRate))
                    return;

                if (weaponConfiguration.RequiresAmmo && !DoesUserHaveAmmo(weaponConfiguration.AmmoTypeShortName, currentTime))
                    return;

                Vector3 muzzlePos = GetMuzzlePosition(weaponConfiguration, currentBarrel);
                if (muzzlePos == Vector3.zero)
                    return;

                switch (weaponConfiguration.ProjectileType)
                {
                    case ProjectileType.ServerProjectile:
                        TriggerMuzzleEffect(weaponConfiguration, currentBarrel);
                        FireWithServerProjectile(weaponConfiguration, muzzlePos);
                        break;
                    case ProjectileType.Bullet:
                        TriggerMuzzleEffect(weaponConfiguration, currentBarrel);
                        //FireWithProjectileSystem(weaponConfiguration, muzzlePos);
                        FireWithProjectileSystem(weaponConfiguration, muzzlePos);
                        break;
                    case ProjectileType.Air2Air:
                        if (!targetLocked || target == null)
                            return;
                        TriggerMuzzleEffect(weaponConfiguration, currentBarrel);
                        FireAARocket(weaponConfiguration, muzzlePos);
                        break;
                    case ProjectileType.TargetLocker:
                        TriggerMuzzleEffect(weaponConfiguration, currentBarrel);
                        LockTarget(muzzlePos, weaponConfiguration);
                        break;
                    default:
                        break;
                }

                if (weaponConfiguration == weaponSettings.PrimaryWeapon)
                {
                    lastPrimaryWeaponFiredTime = currentTime;
                    UpdateBarrel(weaponConfiguration.BarrelConfiguration, ref primaryCurrentBarrel);
                    primaryRoundsFired = ++roundsFired;
                    if (weaponConfiguration.RequiresAmmo)
                        UseAmmo(weaponConfiguration.AmmoTypeShortName, true);
                }
                else
                {
                    lastSecondaryWeaponFiredTime = currentTime;
                    UpdateBarrel(weaponConfiguration.BarrelConfiguration, ref secondaryCurrentBarrel);
                    secondaryRoundsFired = ++roundsFired;
                    if (weaponConfiguration.RequiresAmmo)
                        UseAmmo(weaponConfiguration.AmmoTypeShortName, false);
                }
            }

            private void UpdateBarrel(BarrelConfiguration barrelConfig, ref int nextBarrel)
            {
                switch (barrelConfig)
                {
                    case BarrelConfiguration.DualFront:
                    case BarrelConfiguration.Side:
                    case BarrelConfiguration.CenterFront:
                    case BarrelConfiguration.SideOuter:
                        if (++nextBarrel > 1)
                            nextBarrel = 0;
                        break;
                    case BarrelConfiguration.Bottom:
                        break;
                    case BarrelConfiguration.Gattling:
                        if (++nextBarrel > 4)
                            nextBarrel = 0;
                        break;
                    default:
                        break;
                }
            }

            private bool DoesUserHaveAmmo(string ammoTypeShortName, float currentTime)
            {
                if (configuration.UnlimitedAmmo)
                    return true;

                if (this.player.inventory.GetAmount(weaponsToAmmoTypeItemIdMap[ammoTypeShortName]) > 0)
                    return true;

                if (configuration.DisplayOutOfAmmoMessage && currentTime >= (lastMsgTime + configuration.DebounceTimeSeconds))
                {
                    player.ChatMessage("Out of Ammo");
                    lastMsgTime = currentTime;
                }
                return false;
            }

            private void FireWithProjectileSystem(WeaponConfiguration weaponConfiguration, Vector3 muzzlePos)
            {
                Vector3 modifiedAimDir = this.vehicle.transform.forward.normalized;
                if (weaponConfiguration.AimCone > 0)
                    modifiedAimDir = AimConeUtil.GetAimConeQuat(weaponConfiguration.AimCone) * modifiedAimDir;

                instance.BulletProjectile.CallHook("ShootProjectile", this.player, muzzlePos, modifiedAimDir * weaponConfiguration.WeaponSpeed, weaponConfiguration.DamageTypes, weaponConfiguration.AmmoPrefabPath);
            }

            private GameObject FireWithServerProjectile(WeaponConfiguration weaponConfiguration, Vector3 muzzlePos)
            {
                GameObject bulletEnt = GameManager.server.CreatePrefab(weaponConfiguration.AmmoPrefabPath, muzzlePos, new Quaternion(), false);
                ServerProjectile serverProjectile = bulletEnt.GetComponent<ServerProjectile>();
                TimedExplosive timedExplosive = bulletEnt.GetComponent<TimedExplosive>();

                var baseEnt = bulletEnt.GetComponent<BaseEntity>();
                baseEnt.creatorEntity = this.player;

                if (timedExplosive != null)
                {
                    timedExplosive.OwnerID = player.userID;

                    if (weaponConfiguration.DamageTypes != null && weaponConfiguration.DamageTypes.Any())
                    {
                        timedExplosive.damageTypes = weaponConfiguration.DamageTypes;
                    }

                    if (weaponConfiguration.MinBlastRadius > 0)
                    {
                        timedExplosive.minExplosionRadius = weaponConfiguration.MinBlastRadius;
                    }

                    if (weaponConfiguration.MaxBlastRadius > 0)
                    {
                        timedExplosive.explosionRadius = weaponConfiguration.MaxBlastRadius;
                    }

                    if (weaponConfiguration.DetonationTimerMin > 0)
                    {
                        timedExplosive.timerAmountMin = weaponConfiguration.DetonationTimerMin;
                    }

                    if (weaponConfiguration.DetonationTimerMax > 0)
                    {
                        timedExplosive.timerAmountMax = weaponConfiguration.DetonationTimerMax;
                    }
                }

                if (serverProjectile != null)
                {
                    serverProjectile.gravityModifier = 1f;
                    serverProjectile.speed = weaponConfiguration.WeaponSpeed;

                    if (weaponConfiguration.BarrelConfiguration != BarrelConfiguration.Bottom)
                    {
                        serverProjectile.InitializeVelocity(this.vehicle.transform.forward.normalized * weaponConfiguration.WeaponSpeed);
                    }
                }

                baseEnt.Spawn();
                bulletEnt.SetActive(true);
                return bulletEnt;
            }

            private void FireAARocket(WeaponConfiguration weaponConfiguration, Vector3 muzzlePos)
            {
                var projectile = FireWithServerProjectile(weaponConfiguration, muzzlePos);
                var homing = projectile.AddComponent<AARocket>();
                if (weaponConfiguration.AngleModifier > 0)
                    homing.AngleModifier = weaponConfiguration.AngleModifier;

                homing.Initialize(target, ChanceToLoseLock);

                if (weaponConfiguration.ClearAATargetOnFire)
                    ClearTarget();
            }

            private void UseAmmo(string ammoTypeShortName, bool? isPrimary)
            {
                var ammo = player.inventory.FindItemID(weaponsToAmmoTypeItemIdMap[ammoTypeShortName]);
                ammo?.UseItem(1);
                if (isPrimary == null)
                    Toggle_FlareAmmoGui(true);
                else
                    Toggle_AmmoGui(true, isPrimary);
            }

            private void SwitchWeaponType()
            {
                float currentTime = UnityEngine.Time.realtimeSinceStartup;
                if (currentTime < (lastWeaponSwitchTime + configuration.WeaponSwitchDelay))
                    return;

                string newSelection = selectedWeaponType;
                do
                {
                    newSelection = GetNextWeaponType(newSelection);
                }
                while (!newSelection.Equals("Disarm", StringComparison.InvariantCultureIgnoreCase) && !configuration.DisablePermissionCheck && !permissionHelper.UserHasPermission(this.player.userID.ToString(), this.GetAvailableWeapons()[newSelection].WeaponPermission));

                this.selectedWeaponType = newSelection;
                this.weaponSettings = this.GetAvailableWeapons()[this.selectedWeaponType];
                this.ResetWeapons();

                Effect.server.Run(configuration.SwitchWeaponSfx, this.player.transform.position + this.player.transform.forward);

                if (configuration.DisplaySelectedWeaponMessage)
                    player.ChatMessage($"Selected Weapon: {weaponSettings.DisplayFullName}");

                Toggle_ReticleGui(true);
                Toggle_AmmoGui(true, null);
                Toggle_FlareAmmoGui(true);
                Toggle_WeaponTypesGui(true);
                Toggle_CooldownGui(true);
                lastWeaponSwitchTime = currentTime;
            }

            protected virtual string GetNextWeaponType(string current)
            {
                throw new NotImplementedException();
            }

            public void TriggerLockAcquired(Lock lck)
            {
                locks.Add(lck.Id, lck);
                Toggle_ReticleGui(true);
            }

            public void TriggerLockLost(Lock lck)
            {
                locks.Remove(lck.Id);
                Toggle_ReticleGui(true);
            }

            private void LockTarget(Vector3 muzzlePos, WeaponConfiguration weaponConfiguration)
            {
                float currentTime = UnityEngine.Time.realtimeSinceStartup;
                if (targetLocked)
                {
                    bool exceedHud = (targetAngleX > maxAngle || targetAngleX < minAngle) || (targetAngleY > maxAngle || targetAngleY < minAngle);
                    if (exceedHud || target == null || currentTime > (lockedAt + weaponConfiguration.TimeBeforeLockExpires))
                    {
                        ClearTarget();
                    }
                }

                RaycastHit rayHit;
                if (!targetLocked && Physics.SphereCast(muzzlePos, 1f, this.vehicle.transform.forward, out rayHit, 500))
                {
                    var newTrack = rayHit.GetEntity();
                    var newTarget = newTrack;

                    if (newTarget != target)
                    {
                        CancelInvoke();
                        lockOnSeconds = 0;

                        isLockAlarmPlaying = false;
                        acquiringLock = false;
                        targetAngleX = 0.0f;
                        targetAngleY = 0.0f;
                        target = newTarget;
                    }

                    bool validTarget = false;

                    if (weaponConfiguration.AllowCH47HSR && newTarget is CH47Helicopter)
                    {
                        validTarget = true;
                    }
                    else if (weaponConfiguration.AllowPatrolHeliHSR && newTarget is BaseHelicopter)
                    {
                        validTarget = true;
                    }
                    else
                    {
                        var miniCopter = target as MiniCopter;
                        var miniCopterWrapper = target?.GetComponent<HelicopterWrapper>();
                        if (miniCopterWrapper == null)
                        {
                            var targetPlayer = target as BasePlayer;
                            miniCopterWrapper = targetPlayer?.GetMountedVehicle()?.GetComponent<HelicopterWrapper>();
                        }

                        if (miniCopterWrapper != null)
                            validTarget = true;
                    }

                    if (validTarget)
                    {
                        acquiringLock = true;
                        if (!isLockAlarmPlaying)
                        {
                            PlayLockAlarm();
                        }

                        lockOnSeconds += UnityEngine.Time.deltaTime;

                        if (lockOnSeconds >= weaponConfiguration.TimeToLock)
                        {
                            SetLockTarget(newTarget);
                            lockedAt = currentTime;
                        }
                    }
                }
            }

            private void ResetWeapons()
            {
                this.lastPrimaryWeaponFiredTime = 0.0f;
                this.lastSecondaryWeaponFiredTime = 0.0f;
                this.primaryCooldownTimer = 0.0f;
                this.secondaryCooldownTimer = 0.0f;
                this.primaryRoundsFired = 0;
                this.secondaryRoundsFired = 0;
                this.primaryCurrentBarrel = 0;
                this.secondaryCurrentBarrel = 0;
            }

            public static Vector2 WorldPosToImagePos(Vector3 worldPos)
            {
                Vector3 vector3_2 = new Vector3();
                vector3_2.x = worldPos.x;
                vector3_2.y = worldPos.y;

                return (Vector2)vector3_2;
            }

            public void ClearTarget()
            {
                CancelInvoke();
                isLockAlarmPlaying = false;
                lockOnSeconds = 0;
                if (target != null)
                {
                    var miniCopter = target as MiniCopter;
                    var miniCopterWrapper = miniCopter?.GetComponent<HelicopterWrapper>();
                    if (miniCopterWrapper != null)
                        miniCopterWrapper.TriggerLockLost(this);
                }
                targetAngleX = 0.0f;
                targetAngleY = 0.0f;
                target = null;
                targetLocked = false;
                acquiringLock = false;
            }

            private void PlayLockAlarm()
            {
                isLockAlarmPlaying = true;
                Effect.server.Run(configuration.AlarmSfx, this.player.transform.position);
                // Increase frequency if a lock is acquired
                Invoke("PlayLockAlarm", targetLocked ? 0.2f : 1f);
            }

            public void SetLockTarget(BaseEntity target)
            {
                acquiringLock = false;
                targetLocked = true;

                var miniCopterWrapper = this.target?.GetComponent<HelicopterWrapper>();
                if (miniCopterWrapper != null)
                    miniCopterWrapper.TriggerLockLost(this);

                this.target = target;

                miniCopterWrapper = this.target.GetComponent<HelicopterWrapper>();
                if (miniCopterWrapper != null)
                    miniCopterWrapper.TriggerLockAcquired(this);
            }

            #endregion

            #region Methods
            public void SetPlayer(BasePlayer player)
            {
                if (player == null)
                    return;

                if (this.player == player && this.vehicle.GetPlayerSeat(player) != 0)
                {
                    RemovePlayer(player);
                    return;
                }
                else if (this.vehicle.GetPlayerSeat(player) != 0)
                    return;

                this.player = player;
                ClearTarget();
                Toggle_WeaponTypesGui(true);
            }

            public void RemovePlayer(BasePlayer player)
            {
                if (player == null || this.player != player)
                    return;

                this.ClearTarget();
                this.ResetWeapons();

                Toggle_ReticleGui(false);
                Toggle_AmmoGui(false, null);
                Toggle_FlareAmmoGui(false);
                Toggle_CooldownGui(false);
                Toggle_WeaponTypesGui(false);
                Toggle_DrawTargetLock(false);

                this.player = null;
                this.selectedWeaponType = "Disarm";
            }

            #endregion

            #region Hooks

            private void Awake()
            {
                this.weaponSettings = this.GetAvailableWeapons()["Disarm"];
                vehicle = GetComponent<BaseVehicle>();
                this.IsAlive = true;
                if (configuration.DisableFire)
                {
                    var baseHeli = this.GetComponent<BaseHelicopterVehicle>();
                    baseHeli.fireBall.guid = string.Empty;
                }
            }

            private void FixedUpdate()
            {
                if (!this.IsAlive || this.vehicle == null || this.player == null || this.player.IsDestroyed || !this.player.IsConnected)
                    return;

                ResetRoundsFiredByConfig(weaponSettings.PrimaryWeapon, lastPrimaryWeaponFiredTime, ref primaryRoundsFired, ref primaryCooldownTimer);
                ResetRoundsFiredByConfig(weaponSettings.SecondaryWeapon, lastSecondaryWeaponFiredTime, ref secondaryRoundsFired, ref secondaryCooldownTimer);
                ResetRoundsFired(weaponSettings.FlareCooldownDecay, lastFlaresFiredTime, ref flareRoundsFired, ref flareCooldownTimer);

                if (this.vehicle.GetPlayerSeat(this.player) == 0)
                    UpdateWeapons();
            }

            private void OnDestroy()
            {
                this.IsAlive = false;
                this.RemovePlayer(this.player);
            }

            #endregion

            #region GUI
            private void Toggle_WeaponTypesGui(bool show)
            {
                CuiHelper.DestroyUi(this.player, weaponTypeOverlayName);

                if (!show)
                    return;

                var weaponSelectionContainer = UI.CreateElementContainer("Overlay", weaponTypeOverlayName, "0 0 0 0", "0.005 0.45", "0.049 0.6", false);
                Draw_WeaponSelectionBox(weaponSelectionContainer);

                CuiHelper.AddUi(this.player, weaponSelectionContainer);
            }

            private void Draw_WeaponSelectionBox(CuiElementContainer weaponSelectionContainer)
            {
                string disarmText = this.GetAvailableWeapons()["Disarm"].DisplayShortName;

                UI.CreatePanel(ref weaponSelectionContainer, weaponTypeOverlayName, selectedWeaponType.Equals("Disarm", StringComparison.InvariantCultureIgnoreCase) ? darkGreen : green, "0 .82", "1 1");
                UI.CreateLabel(ref weaponSelectionContainer, weaponTypeOverlayName, white, disarmText, 13, "0 .82", "1 1", TextAnchor.MiddleCenter);

                int column = 0;
                float heightMin = .62f;
                float heightMax = .80f;

                float widthLeftMin = 0f;
                float widthLeftMax = .46f;
                float widthRightMin = .51f;
                float widthRightMax = 1f;

                var enabledWeaponShortNames = this.GetAvailableWeapons().Where(wt => !wt.Key.Equals("Disarm", StringComparison.InvariantCultureIgnoreCase) && wt.Value.Enabled);
                foreach (var weaponType in enabledWeaponShortNames)
                {
                    float widthMin = column == 0 ? widthLeftMin : widthRightMin;
                    float widthMax = column == 0 ? widthLeftMax : widthRightMax;
                    string color = red;
                    if (configuration.DisablePermissionCheck || permissionHelper.UserHasPermission(this.player.userID.ToString(), this.GetAvailableWeapons()[weaponType.Key].WeaponPermission))
                    {
                        if (selectedWeaponType == weaponType.Key)
                            color = darkGreen;
                        else
                            color = green;
                    }
                    else if (configuration.HideUnauthorizedWeapons)
                    {
                        continue;
                    }

                    UI.CreatePanel(ref weaponSelectionContainer, weaponTypeOverlayName, color, $"{widthMin} {heightMin}", $"{widthMax} {heightMax}");
                    UI.CreateLabel(ref weaponSelectionContainer, weaponTypeOverlayName, white, weaponType.Value.DisplayShortName, 13, $"{widthMin} {heightMin}", $"{widthMax} {heightMax}", TextAnchor.MiddleCenter);
                    if (column == 1)
                    {
                        column = 0;
                        heightMin -= .20f;
                        heightMax -= .20f;
                    }
                    else
                    {
                        column++;
                    }
                }
            }

            private void Toggle_ReticleGui(bool show)
            {
                if (this.player == null)
                    return;

                CuiHelper.DestroyUi(this.player, reticleOverlayName);

                if (!show || this.weaponSettings.HudConfiguration == HUDConfiguration.None)
                    return;

                var reticleContainer = UI.CreateElementContainer("Overlay", reticleOverlayName, "0 0 0 0", this.reticleGuiOverlayMin, this.reticleGuiOverlayMax, false);
                Draw_ReticleBox(reticleContainer);
                Draw_ReticleByWeaponType(reticleContainer);

                CuiHelper.AddUi(this.player, reticleContainer);
            }

            private void UpdateTargetLock()
            {
                if (!acquiringLock && !targetLocked)
                    return;
                else if (target == null || target.IsDestroyed)
                {
                    ClearTarget();
                    return;
                }
                targetAngleY = AngleOffAroundAxis(this.vehicle.transform.forward, (target.transform.position - this.vehicle.transform.position), this.vehicle.transform.right);
                targetAngleX = AngleOffAroundAxis(this.vehicle.transform.forward, (target.transform.position - this.vehicle.transform.position), this.vehicle.transform.up);
            }

            private void Toggle_DrawTargetLock(bool show)
            {
                CuiHelper.DestroyUi(this.player, targetLockGuiName);
                CuiHelper.DestroyUi(this.player, targetMessageGuiName);

                if (!show || !acquiringLock && !targetLocked)
                    return;

                float modifiedTargetX = (targetAngleX) / 180;
                float modifiedTargetY = (targetAngleY) * -1 / 95;
                float targetBeginX = this.centerX + modifiedTargetX;
                float targetBeginY = this.centerY + modifiedTargetY;
                float targetEndX = targetBeginX + .015f;
                float targetEndY = targetBeginY + .025f;

                string color = green;
                string message = "Acquiring Target";
                if (targetLocked)
                {
                    color = red;
                    message = "Target Locked";
                }

                var messageContainer = UI.CreateElementContainer("Overlay", targetMessageGuiName, color, lockGuiMin, lockGuiMax, false);
                UI.CreateLabel(ref messageContainer, targetMessageGuiName, white, message, 13, "0.02 0", "1 1", TextAnchor.MiddleCenter);
                CuiHelper.AddUi(this.player, messageContainer);


                var reticleContainer = UI.CreateElementContainer("Overlay", targetLockGuiName, "0 0 0 0", "0 0", "1 1", false);
                UI.CreatePanel(ref reticleContainer, targetLockGuiName, color, $"{targetBeginX} {targetBeginY}", $"{targetEndX} {targetEndY}", false);
                CuiHelper.AddUi(this.player, reticleContainer);
            }

            private void Draw_ReticleBox(CuiElementContainer reticleContainer)
            {
                string color = green;
                if (IsLocked)
                    color = solidRed;
                // Left Line
                UI.CreatePanel(ref reticleContainer, reticleOverlayName, color, "0 0", "0.005 1.5", false);
                // Right Line
                UI.CreatePanel(ref reticleContainer, reticleOverlayName, color, "1 0", "1.005 1.5", false);
                // Top Line
                UI.CreatePanel(ref reticleContainer, reticleOverlayName, color, ".01 1.49", ".995 1.50", false);
                // Bottom Line
                UI.CreatePanel(ref reticleContainer, reticleOverlayName, color, ".01 0", ".995 0.01", false);
            }

            private void Draw_ReticleByWeaponType(CuiElementContainer reticleContainer)
            {
                string color = green;
                switch (weaponSettings.HudConfiguration)
                {
                    case HUDConfiguration.Bomb:
                        // Center Vertical Line
                        UI.CreatePanel(ref reticleContainer, reticleOverlayName, color, ".52 .4", "0.525 .74", false);
                        // Center Horizontal Line
                        UI.CreatePanel(ref reticleContainer, reticleOverlayName, color, ".38 .750", ".66 0.760", false);
                        break;
                    case HUDConfiguration.Shoot:
                    default:
                        // Center Vertical Line
                        UI.CreatePanel(ref reticleContainer, reticleOverlayName, color, ".52 .5", "0.525 1", false);
                        // Center Horizontal Line
                        UI.CreatePanel(ref reticleContainer, reticleOverlayName, color, ".38 .750", ".66 0.760", false);
                        break;
                }
            }

            private void Toggle_CooldownGui(bool show)
            {
                if (!show || this.selectedWeaponType.Equals("Disarm", StringComparison.InvariantCultureIgnoreCase))
                {
                    CuiHelper.DestroyUi(this.player, primaryCooldownOverlayName);
                    CuiHelper.DestroyUi(this.player, secondaryCooldownOverlayName);
                    CuiHelper.DestroyUi(this.player, flareCooldownOverlayName);

                    primaryCooldownContainerActive = false;
                    primaryCooldownContainerContrastActive = false;
                    secondaryCooldownContainerActive = false;
                    secondaryCooldownContainerContrastActive = false;
                    flareCooldownContainerActive = false;
                    flareCooldownContainerContrastActive = false;

                    return;
                }

                Draw_WeaponCooldownBox(this.weaponSettings.PrimaryWeapon, primaryRoundsFired, primaryCooldownOverlayName, ref primaryCooldownContainerActive, ref primaryCooldownContainerContrastActive);
                Draw_WeaponCooldownBox(this.weaponSettings.SecondaryWeapon, secondaryRoundsFired, secondaryCooldownOverlayName, ref secondaryCooldownContainerActive, ref secondaryCooldownContainerContrastActive);
                Draw_FlareCooldownBox();
            }

            private void Draw_FlareCooldownBox()
            {
                if (!weaponSettings.FlaresEnabled)
                    return;

                Draw_CooldownBox(flareMin, flareMax, this.weaponSettings.FlaresBeforeCooldown, flareRoundsFired, flareCooldownOverlayName, orange, ref flareCooldownContainerActive, ref flareCooldownContainerContrastActive);
            }

            private void Draw_WeaponCooldownBox(WeaponConfiguration weaponConfiguration, int roundsFired, string overlayName, ref bool cooldownContainerActive, ref bool cooldownContrastActive)
            {
                if (weaponConfiguration == null || weaponConfiguration.ProjectileType == ProjectileType.TargetLocker)
                {
                    CuiHelper.DestroyUi(this.player, overlayName);
                    cooldownContainerActive = false;
                    return;
                }

                string min = this.primaryAmmoMin;
                string max = this.primaryAmmoMax;
                if (weaponConfiguration != weaponSettings.PrimaryWeapon)
                {
                    min = this.secondaryAmmoMin;
                    max = this.secondaryAmmoMax;
                }

                Draw_CooldownBox(min, max, weaponConfiguration.ShotsBeforeCoolDown, roundsFired, overlayName, green, ref cooldownContainerActive, ref cooldownContrastActive);
            }

            private void Draw_CooldownBox(string min, string max, int shotsBeforeCooldown, float roundsFired, string overlayName, string color, ref bool cooldownContainerActive, ref bool cooldownContrastActive)
            {
                var cooldownContainer = UI.CreateElementContainer("Overlay", overlayName, clear, min, max, false);

                float panelMin = 0;
                if (shotsBeforeCooldown != 0 && roundsFired > 0)
                {
                    CuiHelper.DestroyUi(this.player, overlayName);
                    var currentTime = UnityEngine.Time.realtimeSinceStartup;
                    panelMin = (roundsFired / shotsBeforeCooldown);
                    UI.CreatePanel(ref cooldownContainer, overlayName, darkRed, $"0 0", $"{panelMin} 1");
                    cooldownContrastActive = true;
                }
                else if (cooldownContrastActive)
                {
                    CuiHelper.DestroyUi(this.player, overlayName);
                    cooldownContrastActive = false;
                }
                else if (cooldownContainerActive)
                {
                    return;
                }

                UI.CreatePanel(ref cooldownContainer, overlayName, color, $"{panelMin} 0", $"1 1");
                CuiHelper.AddUi(this.player, cooldownContainer);
                cooldownContainerActive = true;
            }

            private void Toggle_FlareAmmoGui(bool show)
            {
                CuiHelper.DestroyUi(this.player, flareAmmoOverlayName);

                if (!show || !weaponSettings.FlaresEnabled || this.selectedWeaponType.Equals("Disarm", StringComparison.InvariantCultureIgnoreCase))
                {
                    return;
                }

                Draw_AmmoText(weaponSettings.FlareShortName, flareAmmoOverlayName, flareMin, flareMax, "Flares");
            }

            private void Toggle_AmmoGui(bool show, bool? isPrimary)
            {
                if (!show || this.selectedWeaponType.Equals("Disarm", StringComparison.InvariantCultureIgnoreCase))
                {
                    CuiHelper.DestroyUi(this.player, primaryAmmoOverlayName);
                    CuiHelper.DestroyUi(this.player, secondaryAmmoOverlayName);
                    return;
                }

                bool drawPrimary = false;
                bool drawSecondary = false;
                if (isPrimary == null)
                {
                    drawPrimary = true;
                    drawSecondary = true;
                }
                else if (isPrimary.Value)
                {
                    drawPrimary = true;
                }
                else
                {
                    drawSecondary = true;
                }

                WeaponConfiguration primary = weaponSettings.PrimaryWeapon;
                if (drawPrimary && primary != null && primary.ProjectileType != ProjectileType.TargetLocker)
                {
                    CuiHelper.DestroyUi(this.player, primaryAmmoOverlayName);
                    Draw_AmmoText(primary.AmmoTypeShortName, primaryAmmoOverlayName, primaryAmmoMin, primaryAmmoMax);
                }

                WeaponConfiguration secondary = weaponSettings.SecondaryWeapon;
                if (secondary == null || secondary.ProjectileType == ProjectileType.TargetLocker)
                {
                    CuiHelper.DestroyUi(this.player, secondaryAmmoOverlayName);
                }
                else if (drawSecondary)
                {
                    CuiHelper.DestroyUi(this.player, secondaryAmmoOverlayName);
                    Draw_AmmoText(secondary.AmmoTypeShortName, secondaryAmmoOverlayName, secondaryAmmoMin, secondaryAmmoMax);
                }
            }

            private void Draw_AmmoText(string ammoShortName, string overlayName, string min, string max, string prefix = "Ammo")
            {
                var ammoContainer = UI.CreateElementContainer("Overlay", overlayName, clear, min, max, false);
                if (!configuration.UnlimitedAmmo)
                {
                    int ammoAmount = this.player.inventory.GetAmount(weaponsToAmmoTypeItemIdMap[ammoShortName]);
                    UI.CreateLabel(ref ammoContainer, overlayName, white, $"{prefix}: {ammoAmount}", 13, "0.02 0", "1 1", TextAnchor.MiddleLeft);
                }
                else
                {
                    UI.CreateLabel(ref ammoContainer, overlayName, white, $"{prefix}: ∞", 13, "0.02 0", "1 1", TextAnchor.MiddleCenter);
                }
                CuiHelper.AddUi(this.player, ammoContainer);
            }

            #endregion
        }
        #endregion

        #region AARocket
        private class AARocket : MonoBehaviour, Lock
        {
            public Guid Id { get; set; }
            public float ChanceToLoseLock { get; private set; }
            public float AngleModifier { get; set; } = 30f;

            private ServerProjectile projectile;
            private BaseEntity target;

            private void Awake()
            {
                projectile = GetComponent<ServerProjectile>();
            }

            private void FixedUpdate()
            {
                UpdateRocketPosition();
            }

            private void UpdateRocketPosition()
            {
                if (target == null || projectile == null || projectile.GetComponent<BaseEntity>().IsDestroyed)
                    return;

                Vector3 targetPos = target.transform.position + new Vector3(0, target.bounds.center.y / 2, 0);

                Vector3 targetDirection = (targetPos - projectile.transform.position).normalized;
                Vector3 currentDirection = (projectile.transform.localRotation * Vector3.forward);

                float maxAngleChange = (AngleModifier * UnityEngine.Time.fixedDeltaTime);
                float angleChange = Vector3.Angle(targetDirection, currentDirection);
                float maxChange = maxAngleChange < angleChange ? (maxAngleChange / angleChange) : 1;
                Vector3 change = Vector3.Slerp(currentDirection, targetDirection, maxChange);
                Vector3 modifiedDirection = change.normalized;

                projectile.InitializeVelocity(modifiedDirection * projectile.speed);
            }

            private void OnDestroy()
            {
                BaseEntity entity = projectile.GetComponent<BaseEntity>();

                if (entity != null && !entity.IsDestroyed)
                    entity.Kill();

                CancelInvoke();
            }

            public void Initialize(BaseEntity target, float chanceToLoseLock)
            {
                this.Id = Guid.NewGuid();
                this.ChanceToLoseLock = chanceToLoseLock;

                SetLockTarget(target);
            }

            public void SetLockTarget(BaseEntity target)
            {
                var miniCopterWrapper = this.target?.GetComponent<HelicopterWrapper>();
                if (miniCopterWrapper != null)
                    miniCopterWrapper.TriggerLockLost(this);

                this.target = target;

                miniCopterWrapper = this.target.GetComponent<HelicopterWrapper>();
                if (miniCopterWrapper != null)
                    miniCopterWrapper.TriggerLockAcquired(this);
            }
        }
        #endregion

        #region Countermeasures
        private class CounterMeasure : MonoBehaviour
        {
            private BaseEntity baseEntity;
            private Vector3 lastPosition;
            private float timeAlive = 0.0f;
            private float sparkSpawnLimiter = 1f;
            protected static Effect reusableInstance = new Effect();

            private void Awake()
            {
                baseEntity = GetComponent<BaseEntity>();
                lastPosition = baseEntity.transform.position;
                timeAlive = UnityEngine.Time.realtimeSinceStartup;
            }

            private void FixedUpdate()
            {
                var currentTime = UnityEngine.Time.realtimeSinceStartup;
                if (currentTime > (timeAlive + configuration.CounterMeasureDespawnTime) || lastPosition == baseEntity.transform.position)
                    Destroy(this);

                if (currentTime < (timeAlive + sparkSpawnLimiter))
                {
                    reusableInstance.Clear();

                    Vector3 posModifier;
                    switch (UnityEngine.Random.Range(0, 5))
                    {
                        case 0:
                            posModifier = Vector3.forward;
                            break;
                        case 1:
                            posModifier = Vector3.left;
                            break;
                        case 2:
                            posModifier = Vector3.right;
                            break;
                        case 3:
                            posModifier = Vector3.up;
                            break;
                        case 4:
                            posModifier = Vector3.down;
                            break;
                        case 5:
                            posModifier = Vector3.back;
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }

                    reusableInstance.Init(Effect.Type.Generic, baseEntity, 0, posModifier * 2, new Vector3(), null);
                    reusableInstance.scale = 5f;
                    reusableInstance.pooledString = "assets/prefabs/misc/orebonus/effects/hotspot_death.prefab";
                    EffectNetwork.Send(reusableInstance);
                }

                lastPosition = baseEntity.transform.position;
            }

            private void OnDestroy()
            {
                if (baseEntity != null && !baseEntity.IsDestroyed)
                    baseEntity.Kill();
            }
        }
        #endregion

        #region UI

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string parent, string panelName, string color, string aMin, string aMax, bool useCursor)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }

            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }


            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, RectTransform rectTransform, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = rectTransform.anchorMin.ToString(), AnchorMax = rectTransform.anchorMax.ToString() },
                    CursorEnabled = cursor
                },
                panel);
            }

            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
        }

        #endregion

        public class WeaponConfiguration
        {
            public string AmmoTypeShortName { get; set; }
            public string AmmoPrefabPath { get; set; }
            public string MuzzleEffect { get; set; } = "assets/prefabs/npc/patrol helicopter/effects/gun_fire.prefab";

            public ProjectileType ProjectileType { get; set; } = ProjectileType.ServerProjectile;

            public float WeaponSpeed { get; set; }
            public float FireRate { get; set; }
            public float MinBlastRadius { get; set; }
            public float MaxBlastRadius { get; set; }
            [JsonProperty(PropertyName = "CoolDownDecay: Speed at which the cooldown is decreased in seconds")]
            public float CoolDownDecay { get; set; } = 0.0f;

            [JsonProperty(PropertyName = "Min Detonation Time for Timed Explosives")]
            public float DetonationTimerMin { get; set; } = 0;
            [JsonProperty(PropertyName = "Max Detonation Time for Timed Explosives")]
            public float DetonationTimerMax { get; set; } = 0;
            [JsonProperty(PropertyName = "Air2Air: Angle Modifier for Rockets (Set to Override Default 30)")]
            public float AngleModifier { get; set; } = 0.0f;
            [JsonProperty(PropertyName = "TargetLocker: Time Before Losing the Lock")]
            public float TimeBeforeLockExpires { get; set; } = 0.0f;
            [JsonProperty(PropertyName = "TargetLocker: Time Required Before Locking Target")]
            public float TimeToLock { get; set; } = 0.0f;
            public float AimCone { get; set; } = 0.0f;

            public bool RequiresAmmo { get; set; } = true;
            public bool ClearAATargetOnFire { get; set; } = true;
            public bool AllowCH47HSR { get; set; } = false;
            public bool AllowPatrolHeliHSR { get; set; } = false;

            public int ShotsBeforeCoolDown { get; set; } = 0;

            public BarrelConfiguration BarrelConfiguration { get; set; } = BarrelConfiguration.DualFront;

            public List<DamageTypeEntry> DamageTypes { get; set; } = new List<DamageTypeEntry>();
        }

        public class WeaponSettings
        {
            public WeaponConfiguration PrimaryWeapon { get; set; } = null;
            public WeaponConfiguration SecondaryWeapon { get; set; } = null;

            public string DisplayShortName { get; set; }
            public string DisplayFullName { get; set; }
            public string WeaponPermission { get; set; }
            public string FlareShortName { get; set; } = "flare";

            public HUDConfiguration HudConfiguration { get; set; } = HUDConfiguration.Shoot;

            public float FlareFireRate { get; set; } = 1f;
            public float FlareCooldownDecay { get; set; } = 3f;
            public int FlaresBeforeCooldown { get; set; } = 6;

            [JsonProperty(PropertyName = "TargetLocker/Air2Air: % Chance to Lose Lock [0-100]")]
            public float ChanceToLoseLock { get; set; } = 10.0f;

            public bool UnlimitedFlares { get; set; } = false;
            public bool FlaresEnabled { get; set; } = true;

            public bool Enabled { get; set; }
        }

        public enum BarrelConfiguration
        {
            DualFront,
            Side,
            Bottom,
            CenterFront,
            SideOuter,
            Gattling
        }

        public enum HUDConfiguration
        {
            None,
            Shoot,
            Bomb
        }

        public enum ProjectileType
        {
            ServerProjectile,
            Bullet,
            Air2Air,
            TargetLocker
        }

        public interface Lock
        {
            Guid Id { get; set; }
            float ChanceToLoseLock { get; }
            void SetLockTarget(BaseEntity target);
        }
    }
}


// --- End of file: MinicopterCombat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerWear.cs ---
// --- Original Local Path: PlayerWear.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Color = UnityEngine.Color;
using Newtonsoft.Json;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("PlayerWear", "Drop Dead", "1.0.0")]
    public class PlayerWear : RustPlugin
    {
        public Dictionary<ulong, string> command = new Dictionary<ulong, string>();

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Title}/Players", command);
        }

        private void LoadData()
        {
            try
            {
                command = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>($"{Title}/Players");
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (command == null) command = new Dictionary<ulong, string>();
        }

        public class items
        {
            [JsonProperty("Шортнейм")]
            public string shortname = "";
            [JsonProperty("Количество")]
            public int amount = 1;
            [JsonProperty("Скин")]
            public ulong skinid = 0;
            [JsonProperty("Контейнер (wear/belt/main)")]
            public string container = "wear";
            [JsonProperty("Заблокировать перемещение?")]
            public bool move = false;
            [JsonProperty("Заблокировать дроп?")]
            public bool drop = false;
        }

        private PluginConfig cfg;

        public class PluginConfig
        {
            [JsonProperty("Предметы по группам")]
            public Dictionary<string, List<items>> perms = new Dictionary<string, List<items>>
            {
                ["raid"] = new List<items> { new items { shortname = "rifle.ak", amount = 1, skinid = 0, container = "belt" } },
                ["admin"] = new List<items> { new items { shortname = "ammo.rifle", amount = 1, skinid = 0, container = "main" } },
            };
        }

        private void Init()
        {
            cfg = Config.ReadObject<PluginConfig>();
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new PluginConfig(), true);
        }

        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList) OnPlayerConnected(player);
        }

        void Unload()
        {
            SaveData();
        }

        void OnServerSave()
        {
            SaveData();
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            CheckPlayer(player);
        }

        void CheckPlayer(BasePlayer player)
        {
            if (player == null) return;
            if (!command.ContainsKey(player.userID)) command.Add(player.userID, "raid");

            player.inventory.Strip();

            var items = cfg.perms[command[player.userID]];
            if (items == null) return;
            foreach (var item in items)
            {
                var newitem = ItemManager.CreateByName(item.shortname, item.amount, item.skinid);
                if (newitem == null) continue;
                if (item.container == "wear") player.inventory.containerWear.Insert(newitem);//newitem.MoveToContainer(player.inventory.containerWear);
                if (item.container == "belt") player.inventory.containerBelt.Insert(newitem);//newitem.MoveToContainer(player.inventory.containerBelt);
                if (item.container == "main") player.inventory.containerMain.Insert(newitem);//newitem.MoveToContainer(player.inventory.containerMain);
            }
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            CheckPlayer(player);
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot, int amount)
        {
            if (item == null) return null;
            foreach (var itemz in cfg.perms)
            {
                foreach (var items in itemz.Value)
                {
                    if (items.shortname == item.info.shortname && items.move) return false;
                }
            }
            return null;
        }

        object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (player == null || item == null) return null;
            if (action != "drop") return null;
            foreach (var itemz in cfg.perms)
            {
                foreach (var items in itemz.Value)
                {
                    if (items.shortname == item.info.shortname && items.drop) return false;
                }
            }
            return null;
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock @lock)
        {
            if (player == null || @lock == null || !@lock.IsLocked())
                return null;
            var parentEntity = @lock.GetParentEntity();
            var ownerID = @lock.OwnerID.IsSteamId() ? @lock.OwnerID : parentEntity != null ? parentEntity.OwnerID : 0;
            if (!ownerID.IsSteamId() || ownerID == player.userID)
                return null;
            if (player.IsAdmin) return true;
            if (@lock is CodeLock)
            {
                if (command[ownerID] == "admin" && command[player.userID] == "admin")
                {
                    var codeLock = @lock as CodeLock;
                    var whitelistPlayers = (List<ulong>)codeLock.guestPlayers;
                    if (!whitelistPlayers.Contains(player.userID))
                        whitelistPlayers.Add(player.userID);
                }
            }
            return null;
        }

        [ChatCommand("events")]
        void EventCmd(BasePlayer player, string commands, string[] args)
        {
            if (!player.IsAdmin) return;

            if (args.Length < 2)
            {
                player.ChatMessage("/event raid ник - добавить игрока в команду рейдеров\n/event admin ник - добавить игрока в команду админов");
                return;
            }

            if (args[0] != "raid" && args[0] != "admin")
            {
                player.ChatMessage("Вы не правильно указали группу в которую перенести игрока");
                return;
            }

            var target = BasePlayer.Find(args[1]);
            if (target == null)
            {
                player.ChatMessage("Игрок не найден, попробуйте уточнить имя или SteamID");
                return;
            }
            if (command.ContainsKey(target.userID))
            {
                if (command[target.userID] == args[0])
                {
                    player.ChatMessage($"Игрок {target.displayName} уже находится в той команде в которую вы пытаетесь его перенести");
                    return;
                }
                command[target.userID] = args[0];
                player.ChatMessage($"Вы успешно перенесли игрока {target.displayName} в другую команду. Его лут обновлён");
                CheckPlayer(target);
            }
        }
    }
}

// --- End of file: PlayerWear.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Guardian.cs ---
// --- Original Local Path: Guardian.cs ---

using Facepunch;
using Facepunch.Math;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Guardian", "WhiteDragon", "1.7.9")]
    [Description("Protects the server from various annoyances, cheats, and macro attacks.")]
    class Guardian : CovalencePlugin
    {
        [PluginReference] private Plugin Friends, PlaytimeTracker;

        private static Guardian _instance;

        #region _action_queue_

        private class ActionQueue
        {
            private Queue<Action> actions;

            public ActionQueue(float interval)
            {
                actions = new Queue<Action>();

                Timers.Add(interval, () => Scan());
            }

            public void Clear() => actions.Clear();

            public void Enqueue(Action callback)
            {
                if(callback != null)
                {
                    actions.Enqueue(callback);
                }
            }

            private void Scan()
            {
                if(actions.Count > 0)
                {
                    actions.Dequeue()?.Invoke();
                }
            }
        }

        #endregion _action_queue_

        #region _admin_

        private class Admin
        {
            public class Settings
            {
                public bool Broadcast;
                public bool Bypass;

                public Settings()
                {
                    Broadcast = true;
                    Bypass    = true;
                }
            }
        }

        #endregion _admin_

        #region _anticheat_

        private class AntiCheat
        {
            public class Settings
            {
                public Aim.Settings        Aim;
                public FireRate.Settings   FireRate;
                public Gravity.Settings    Gravity;
                public MeleeRate.Settings  MeleeRate;
                public Recoil.Settings     Recoil;
                public Server.Settings     Server;
                public Stash.Settings      Stash;
                public Trajectory.Settings Trajectory;
                public WallHack.Settings   WallHack;

                public Settings()
                {
                    Aim        = new Aim.Settings();
                    FireRate   = new FireRate.Settings();
                    Gravity    = new Gravity.Settings();
                    MeleeRate  = new MeleeRate.Settings();
                    Recoil     = new Recoil.Settings();
                    Server     = new Server.Settings();
                    Stash      = new Stash.Settings();
                    Trajectory = new Trajectory.Settings();
                    WallHack   = new WallHack.Settings();
                }

                public void Validate()
                {
                    Configuration.Validate(ref Aim,        () => new Aim.Settings(), () => Aim.Validate());
                    Configuration.Validate(ref FireRate,   () => new FireRate.Settings());
                    Configuration.Validate(ref Gravity,    () => new Gravity.Settings());
                    Configuration.Validate(ref MeleeRate,  () => new MeleeRate.Settings());
                    Configuration.Validate(ref Recoil,     () => new Recoil.Settings());
                    Configuration.Validate(ref Server,     () => new Server.Settings());
                    Configuration.Validate(ref Stash,      () => new Stash.Settings());
                    Configuration.Validate(ref Trajectory, () => new Trajectory.Settings());
                    Configuration.Validate(ref WallHack,   () => new WallHack.Settings());
                }
            }

            private const Key category = Key.AntiCheat;

            private const float epsilon = 9.5367431640625E-7f;

            public static void Configure()
            {
                Aim.Configure();
                FireRate.Configure();
                Gravity.Configure();
                MeleeRate.Configure();
                Recoil.Configure();
                Server.Configure();
                Stash.Configure();
                Trajectory.Configure();
                WallHack.Configure();

                Gravity.Scan();
                Server.Scan();
            }

            public static void Unload()
            {
                Aim.Unload();
                FireRate.Unload();
                Gravity.Unload();
                MeleeRate.Unload();
                Recoil.Unload();
                Server.Unload();
                Stash.Unload();
                Trajectory.Unload();
                WallHack.Unload();
            }

            public class Aim
            {
                public class Settings
                {
                    public bool       Ban;
                    public ulong      Cooldown;
                    public bool       Enabled;
                    public float      Sensitivity;
                    public AimTrigger Trigger;
                    public bool       Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Trigger     = new AimTrigger();
                        Warn        = true;
                    }

                    public class AimTrigger
                    {
                        public bool Animal;
                        public bool Bradley;
                        public bool Helicopter;
                        public bool NPC;
                    }

                    public void Validate()
                    {
                        Configuration.Validate(ref Trigger, () => new AimTrigger());
                    }
                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatAim;

                private static readonly Violation violation = new Violation(category);

                private static float aim_distance;
                private static float headshot_scale;
                private static float hit_scale;
                private static float pvp_distance;

                private static float sensitivity_lo;
                private static float sensitivity_hi;

                private static float spin_angle;

                private static float swing_angle;

                private class History
                {
                    public HitArea      boneArea;
                    public Counter      headshot;
                    public Counter      hit;
                    public HashSet<int> hits;
                    public Counter      repeat;

                    private static readonly Dictionary<ulong, History> histories = new Dictionary<ulong, History>();

                    private History()
                    {
                        boneArea = 0;
                        headshot = new Counter();
                        hit      = new Counter();
                        hits     = new HashSet<int>();
                        repeat   = new Counter();
                    }

                    public static void Clear() => histories.Clear();

                    public static bool Contains(ulong userid) => histories.ContainsKey(userid);

                    public static History Get(ulong userid)
                    {
                        History history;

                        if(!histories.TryGetValue(userid, out history))
                        {
                            histories.Add(userid, history = new History());
                        }

                        return history;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.Aim.Validate(900);

                    violation.Configure(settings, 2, 8, 900000);

                    aim_distance   =  6.00f + ( 6.0f * (1.0f - settings.Sensitivity));
                    headshot_scale =  1.50f +                  settings.Sensitivity;
                    hit_scale      =  0.25f +                  settings.Sensitivity;
                    pvp_distance   = 12.00f + (12.0f * (1.0f - settings.Sensitivity));
                    sensitivity_lo = -0.50f + ( 0.5f *         settings.Sensitivity);
                    sensitivity_hi = -1.00f - ( 0.5f * (1.0f - settings.Sensitivity));
                    spin_angle     = 35.00f + (35.0f * (1.0f - settings.Sensitivity));
                    swing_angle    = 10.00f + (10.0f * (1.0f - settings.Sensitivity));
                }

                public static void Trigger(BaseEntity entity, HitInfo info)
                {
                    var player = info.InitiatorPlayer;

                    if(Permissions.Bypass.AntiCheat.Aim(player.userID))
                    {
                        return;
                    }

                    var weapon = Weapon.Get(player.userID, info.ProjectileID);

                    if(weapon == null)
                    {
                        return;
                    }

                    _instance.NextTick(() =>
                    {
                        var position = info.HitPositionWorld;

                        var distance = Vector3.Distance(position, weapon.Position);

                        bool can_trigger = false, hit_location = true, pvp = false;

                        string target;

                        switch(Entity.GetType(entity, out target))
                        {
                        case Entity.Type.Animal:
                        case Entity.Type.Bear:
                        case Entity.Type.Boar:
                        case Entity.Type.Chicken:
                        case Entity.Type.Stag:       can_trigger = config.AntiCheat.Aim.Trigger.Animal; break;
                        case Entity.Type.Bradley:    can_trigger = config.AntiCheat.Aim.Trigger.Bradley; break;
                        case Entity.Type.Helicopter: can_trigger = config.AntiCheat.Aim.Trigger.Helicopter; break;
                        case Entity.Type.Bot:
                        case Entity.Type.Murderer:
                        case Entity.Type.NPC:
                        case Entity.Type.Scientist:  can_trigger = config.AntiCheat.Aim.Trigger.NPC; break;
                        case Entity.Type.Player:     can_trigger = pvp = true; break;
                        default:
                            hit_location = false; break;
                        }

                        if(can_trigger)
                        {
                            can_trigger = Entity.Health.Changed(entity);
                        }

                        var history = History.Get(player.userID);

                        if(hit_location)
                        {
                            if(info.boneArea == 0)
                            {
                                history.repeat.Decrement();
                            }
                            else
                            {
                                if(info.boneArea == history.boneArea)
                                {
                                    history.repeat.Increment();
                                }
                                else
                                {
                                    history.repeat.Decrement();
                                }
                            }

                            history.boneArea = info.boneArea;

                            if(pvp && (distance > pvp_distance))
                            {
                                if(history.boneArea == HitArea.Head)
                                {
                                    history.headshot.Increment();
                                }
                                else
                                {
                                    history.headshot.Decrement();
                                }
                            }
                        }

                        var range_modifier = (1.0f - (0.25f * history.repeat.Ratio())) * (1.0f - (0.025f * weapon.Speed));

                        var range_variance = 1.0f - (distance / (weapon.Range * range_modifier));

                        var angle = Vector3.Angle(weapon.AimAngle, info.ProjectileVelocity);

                        var angle_drop_off = 12.0f / (4.0f - (weapon.Range / weapon.Velocity));

                        var angle_variance = weapon.Accuracy - (angle / (angle_drop_off + weapon.AimCone));

                        var pvp_variance = weapon.Accuracy - (history.headshot.Ratio(headshot_scale) + history.hit.Ratio(hit_scale));

                        var deflection = false;

                        var violations = 0ul;

                        if(hit_location && (distance > aim_distance) && (can_trigger || (angle > spin_angle)))
                        {
                            history.hits.Add(info.ProjectileID);

                            if(range_variance < sensitivity_lo)
                            {
                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                                else if((range_variance < sensitivity_hi) && violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }

                            if(angle_variance < sensitivity_lo)
                            {
                                BasePlayer.FiredProjectile projectile;

                                if(player.firedProjectiles.TryGetValue(info.ProjectileID, out projectile))
                                {
                                    deflection = (projectile.ricochets > 0);
                                }

                                if(!deflection)
                                {
                                    var deflectors = Pool.GetList<BaseEntity>();

                                    Vis.Entities(position, aim_distance, deflectors);

                                    var d_squared = distance * distance;

                                    foreach(var deflector in deflectors)
                                    {
                                        if(deflector.SqrDistance(weapon.Position) < d_squared)
                                        {
                                            deflection = true;

                                            break;
                                        }
                                    }

                                    Pool.FreeList(ref deflectors);
                                }

                                if(!deflection || (angle > spin_angle))
                                {
                                    if(violation.Trigger(player.userID))
                                    {
                                        ++violations;
                                    }
                                    else if((angle_variance < sensitivity_hi) && violation.Trigger(player.userID))
                                    {
                                        ++violations;
                                    }

                                    if((angle > spin_angle) && violation.Trigger(player.userID))
                                    {
                                        ++violations;
                                    }
                                }
                            }

                            if(pvp && (distance > pvp_distance) && (pvp_variance < sensitivity_lo))
                            {
                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                                else if((pvp_variance < sensitivity_hi) && violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }

                            if((violations > 2) && (angle <= spin_angle))
                            {
                                violations = 2;
                            }
                        }

                        var bodypart = Text.BodyPart(info.boneArea);

                        if(config.Log.AntiCheat.Aim)
                        {
                            Log.Console(Key.LogAntiCheatAim, new Dictionary<string, string>
                            {
                                { "angle_variance", angle_variance.ToString("F6") },
                                { "bodypart", bodypart },
                                { "distance", distance.ToString("F1") },
                                { "playerid", player.UserIDString },
                                { "playername", Text.Sanitize(player.displayName) },
                                { "pvp_variance", pvp_variance.ToString("F6") },
                                { "range_variance", range_variance.ToString("F6") },
                                { "speed", weapon.Speed.ToString("F1") },
                                { "target", target },
                                { "weapon", $"{weapon.Name}{(deflection ? " (deflection)" : string.Empty)}" }
                            });
                        }

                        Projectile.Log.SetAim(player.userID, info.ProjectileID, angle_variance, pvp_variance, range_variance, pvp, deflection);

                        Projectile.Log.SetVictim(player.userID, info.ProjectileID, target);

                        Projectile.Log.SetHit(player.userID, info.ProjectileID, distance, info.boneArea);

                        if(config.AntiCheat.Aim.Enabled && (violations > 0))
                        {
                            Projectile.Log.SetAimViolations(player.userID, info.ProjectileID, violations);

                            var hit_angle = angle.ToString("F1");
                            var hit_distance = distance.ToString("F1");

                            violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationAim, new Dictionary<string, string>
                            {
                                { "angle", hit_angle },
                                { "bodypart", bodypart },
                                { "distance", hit_distance },
                                { "target", target },
                                { "weapon", weapon.Name }
                            }), violations, false, new Dictionary<string, string>
                            {
                                { "headshot_percent", history.headshot.Percent().ToString() },
                                { "hip_fire", (weapon.Zoom == 1.0f).ToString() },
                                { "hit_angle", hit_angle },
                                { "hit_area", Text.BodyPart(info.boneArea, "en") },
                                { "hit_distance", hit_distance },
                                { "hit_percent", history.hit.Percent().ToString() },
                                { "movement_speed", weapon.Speed.ToString("F1") },
                                { "projectile_id", info.ProjectileID.ToString() },
                                { "ricochet", deflection.ToString() },
                                { "swing_angle", "0.0" },
                                { "violation_id", weapon.Fired.Ticks.ToString() },
                                { "weapon_ammo", weapon.AmmoName },
                                { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                { "weapon_type", weapon.ShortName }
                            });
                        }
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }

                public static void Update(Weapon weapon)
                {
                    var player = weapon.Player;

                    if(!History.Contains(player.userID))
                    {
                        return;
                    }

                    var history = History.Get(player.userID);

                    foreach(var entry in weapon.Projectiles)
                    {
                        if(history.hits.Contains(entry))
                        {
                            history.hits.Remove(entry);

                            history.hit.Increment();

                            var angle = weapon.Swing;

                            if(config.AntiCheat.Aim.Enabled && (angle > swing_angle) && Projectile.Log.GetAimPvp(player.userID, entry))
                            {
                                var distance = Projectile.Log.GetHitDistance(player.userID, entry);
                                if(distance > pvp_distance)
                                {
                                    if(violation.Trigger(player.userID))
                                    {
                                        Projectile.Log.SetAimViolations(player.userID, entry, 1ul, true);

                                        var hit_angle    = Projectile.Log.GetAimAngle(player.userID, entry).ToString("F1");
                                        var hit_area     = Projectile.Log.GetHitLocation(player.userID, entry);
                                        var hit_distance = distance.ToString("F1");
                                        var swing_angle  = angle.ToString("F1");

                                        violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationAim, new Dictionary<string, string>
                                        {
                                            { "angle", $"{hit_angle}-{swing_angle}" },
                                            { "bodypart", Text.BodyPart(hit_area) },
                                            { "distance", hit_distance },
                                            { "target", Projectile.Log.GetVictim(player.userID, entry) },
                                            { "weapon", weapon.Name }
                                        }), 1ul, false, new Dictionary<string, string>
                                        {
                                            { "headshot_percent", history.headshot.Percent().ToString() },
                                            { "hip_fire", (weapon.Zoom == 1.0f).ToString() },
                                            { "hit_angle", hit_angle },
                                            { "hit_area", Text.BodyPart(hit_area, "en") },
                                            { "hit_distance", hit_distance },
                                            { "hit_percent", history.hit.Percent().ToString() },
                                            { "movement_speed", weapon.Speed.ToString("F1") },
                                            { "projectile_id", entry.ToString() },
                                            { "ricochet", Projectile.Log.GetRicochet(player.userID, entry).ToString() },
                                            { "swing_angle", swing_angle },
                                            { "violation_id", weapon.Fired.Ticks.ToString() },
                                            { "weapon_ammo", weapon.AmmoName },
                                            { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                            { "weapon_type", weapon.ShortName }
                                        });
                                    }
                                }
                            }
                        }
                        else
                        {
                            history.hit.Decrement();
                        }
                    }
                }
            }

            public class FireRate
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 10;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatFireRate;

                private static readonly Violation violation = new Violation(category);

                private static float sensitivity;

                private class History
                {
                    public int      entity;
                    public DateTime fired;
                    public float    repeat;

                    private static readonly Dictionary<ulong, History> histories = new Dictionary<ulong, History>();

                    private History()
                    {
                        entity = 0;
                        fired  = DateTime.MinValue;
                        repeat = 10.0f;
                    }

                    public static void Clear() => histories.Clear();

                    public static History Get(ulong userid)
                    {
                        History history;

                        if(!histories.TryGetValue(userid, out history))
                        {
                            histories.Add(userid, history = new History());
                        }

                        return history;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.FireRate.Validate(30);

                    violation.Configure(settings, 2, 8, 5000);

                    sensitivity = 0.3f + (0.3f * settings.Sensitivity);
                }

                private static uint Percent(float min, float delay, float max) =>
                    (uint)(100.0f * (max - delay) / (max - min));

                public static void Trigger(BaseEntity entity, HitInfo info)
                {
                    var player = info.InitiatorPlayer;

                    if(Permissions.Bypass.AntiCheat.FireRate(player.userID))
                    {
                        return;
                    }

                    var weapon = Weapon.Get(player.userID, info.ProjectileID);

                    if(weapon == null)
                    {
                        return;
                    }

                    _instance.NextTick(() =>
                    {
                        var current = entity.GetInstanceID();
                        var history = History.Get(player.userID);

                        if((weapon.Repeat == history.repeat) && (current == history.entity))
                        {
                            var delay = (float)weapon.Fired.Subtract(history.fired).TotalSeconds;

                            var max = weapon.Repeat * sensitivity;
                            var min = max * 0.1f;

                            if(config.AntiCheat.FireRate.Enabled && (min <= delay) && (delay <= max) && violation.Trigger(player.userID))
                            {
                                Projectile.Log.SetFireRateViolations(player.userID, info.ProjectileID, 1);

                                var attack_rate = delay.ToString("F3");

                                violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationFireRate, new Dictionary<string, string>
                                {
                                    { "delay", attack_rate },
                                    { "weapon", weapon.Name }
                                }), false, new Dictionary<string, string>
                                {
                                    { "attack_rate", attack_rate },
                                    { "movement_speed", weapon.Speed.ToString("F1") },
                                    { "projectile_id", info.ProjectileID.ToString() },
                                    { "rate_percent", Percent(min, delay, max).ToString() },
                                    { "violation_id", weapon.Fired.Ticks.ToString() },
                                    { "weapon_ammo", weapon.AmmoName },
                                    { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                    { "weapon_type", weapon.ShortName }
                                });
                            }
                        }

                        history.entity = current;
                        history.fired = weapon.Fired;
                        history.repeat = weapon.Repeat;
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class Gravity
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 10;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatGravity;

                private static readonly Violation violation = new Violation(category);

                private static float sensitivity_lo;
                private static float sensitivity_md;
                private static float sensitivity_hi;

                private class History
                {
                    private static readonly Dictionary<ulong, float> histories = new Dictionary<ulong, float>();

                    public static void Clear() => histories.Clear();

                    public static float Set(ulong userid, float new_value)
                    {
                        float old_value;

                        if(!histories.TryGetValue(userid, out old_value))
                        {
                            histories.Add(userid, new_value);

                            return float.MaxValue;
                        }

                        histories[userid] = new_value;

                        return old_value;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.Gravity.Validate(30);

                    violation.Configure(settings, 2, 8, 500);

                    sensitivity_lo = 1.55f + 1.5f * (1.0f - settings.Sensitivity);
                    sensitivity_md = sensitivity_lo * 2.0f;
                    sensitivity_hi = sensitivity_md * 2.0f;
                }

                private static bool Check(BasePlayer player)
                {
                    var position = player.transform.position; position.y += 0.05f;

                    if((History.Set(player.userID, position.y) >= position.y) || player.HasParent())
                    {
                        return false;
                    }
                    else if(Physics.Raycast(position, Vector3.down, sensitivity_md))
                    {
                        return false;
                    }
                    else if(position.y <= (Map.Terrain.Height(position) + sensitivity_lo))
                    {
                        return false;
                    }

                    bool flying = true;

                    var entities = Pool.GetList<BaseEntity>();

                    Vis.Entities(position, sensitivity_hi, entities);

                    foreach(var entity in entities)
                    {
                        if(player.IsStandingOnEntity(entity, -1))
                        {
                            flying = false; break;
                        }

                        switch(entity.ShortPrefabName)
                        {
                        case "cave_lift":
                        case "elevator_lift":
                        case "floor.ladder.hatch":
                        case "floor.triangle.ladder.hatch":
                        case "hopperoutput":
                        case "miningquarry":
                        case "miningquarry_static":
                        case "watchtower.wood":

                            if(player.Distance(entity.bounds.ClosestPoint(position)) <= sensitivity_lo)
                            {
                                flying = false;
                            }

                            break;

                        default:

                            if((entity is BaseVehicle) || (entity is BaseVehicleSeat))
                            {
                                if(player.Distance(entity.bounds.ClosestPoint(position)) <= sensitivity_lo)
                                {
                                    flying = false;
                                }
                            }
                            else if(entity.ShortPrefabName == "ladder.wooden.wall")
                            {
                                if(player.Distance(entity.bounds.ClosestPoint(position)) <= sensitivity_md)
                                {
                                    flying = false;
                                }
                            }
                            else if((entity is BaseHelicopterVehicle) || (entity is SupplyDrop) || (entity is TreeEntity))
                            {
                                flying = false;
                            }
                            else
                            {
                                var top = entity.bounds.max.y;

                                if((position.y >= top) && ((position.y - top) <= sensitivity_lo))
                                {
                                    var bot = new Vector3(position.x, position.y - sensitivity_lo, position.z);

                                    if(Physics.CheckCapsule(position, bot, 0.25f))
                                    {
                                        flying = false;
                                    }
                                }
                            }

                            break;
                        }

                        if(!flying)
                        {
                            break;
                        }
                    }

                    if(flying && (entities.Count == 0) && Vis.AnyColliders(position, sensitivity_lo))
                    {
                        flying = false;
                    }

                    Pool.FreeList(ref entities);

                    return flying;
                }

                public static void Scan()
                {
                    Timers.Add(1.0f, () =>
                    {
                        if(config.AntiCheat.Gravity.Enabled)
                        {
                            foreach(var player in BasePlayer.activePlayerList)
                            {
                                if(User.ShouldIgnore(player) || User.CanFly(player))
                                {
                                    continue;
                                }

                                if(player.isMounted || player.HasParent() || player.IsSwimming() || player.IsOnGround())
                                {
                                    continue;
                                }

                                var position = player.transform.position;

                                if(Map.Water.IsSurface(position) && !Map.Monument.IsNearby(position) && !Map.Entities.InRange(position))
                                {
                                    if((History.Set(player.userID, position.y) <= position.y))
                                    {
                                        Trigger(player, position.y, true);
                                    }
                                }
                            }
                        }
                    });
                }

                public static void Trigger(BasePlayer player, float amount, bool scanned = false)
                {
                    if(Permissions.Bypass.AntiCheat.Gravity(player.userID))
                    {
                        return;
                    }

                    if(config.Log.AntiCheat.Gravity)
                    {
                        var position = player.transform.position;

                        Log.Console(Key.LogAntiCheatGravity, new Dictionary<string, string>
                        {
                            { "amount", amount.ToString("F6") },
                            { "playerid", player.UserIDString },
                            { "playername", Text.Sanitize(player.displayName) },
                            { "position", $"({(int)position.x},{(int)position.y},{(int)position.z})" }
                        });
                    }

                    if(config.AntiCheat.Gravity.Enabled && (scanned || Check(player)) && violation.Trigger(player.userID))
                    {
                        violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationGravity, new Dictionary<string, string>
                        {
                            { "amount", amount.ToString("F6") }
                        }), false, new Dictionary<string, string>
                        {
                            { "elevation", player.transform.position.y.ToString("F1") },
                            { "movement_speed", player.estimatedSpeed.ToString("F1") },
                            { "violation_id", DateTime.UtcNow.Ticks.ToString() }
                        });
                    }
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class MeleeRate
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatMeleeRate;

                private static readonly Violation violation = new Violation(category);

                private static float sensitivity;

                private class History
                {
                    private static readonly Dictionary<ulong, DateTime> histories = new Dictionary<ulong, DateTime>();

                    public static void Clear() => histories.Clear();

                    public static float Set(ulong userid, DateTime new_value)
                    {
                        DateTime old_value;

                        if(!histories.TryGetValue(userid, out old_value))
                        {
                            histories.Add(userid, new_value);

                            return float.MaxValue;
                        }

                        histories[userid] = new_value;

                        return (float)new_value.Subtract(old_value).TotalSeconds;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.MeleeRate.Validate(900);

                    violation.Configure(settings, 2, 8, 15000);

                    sensitivity = 0.4f + (0.3f * settings.Sensitivity);
                }

                private static uint Percent(float delay, float max) =>
                    (uint)(100.0f * (max - delay) / max);

                public static void Trigger(BasePlayer player, HitInfo info)
                {
                    if(Permissions.Bypass.AntiCheat.MeleeRate(player.userID))
                    {
                        return;
                    }

                    BaseMelee melee = info?.Weapon?.GetComponent<BaseMelee>();

                    if(melee == null)
                    {
                        return;
                    }

                    var item = info.Weapon.GetItem();

                    if(item == null)
                    {
                        return;
                    }

                    var current = DateTime.UtcNow;

                    _instance.NextTick(() =>
                    {
                        var itemid = item.info.itemid;

                        var delay = History.Set(player.userID, current);

                        string target = Entity.GetName(info.HitEntity);

                        var weapon = item.info.displayName.translated ?? "null";

                        if(config.Log.AntiCheat.MeleeRate)
                        {
                            var delay_string = (delay >= (melee.repeatDelay * 2.0f)) ? Text.Get(Key.idle) : $"{delay:0.00}{Text.Get(Key.DurationSecondsUnit)}";

                            Log.Console(Key.LogAntiCheatMeleeRate, new Dictionary<string, string>
                            {
                                { "delay", delay_string },
                                { "playerid", player.UserIDString },
                                { "playername", Text.Sanitize(player.displayName) },
                                { "target", target },
                                { "weapon", weapon }
                            });
                        }

                        var chainsaw   = (itemid == 1104520648);
                        var jackhammer = (itemid == 1488979457);

                        var max = melee.repeatDelay * sensitivity;

                        if((delay <= max) && !(jackhammer || chainsaw))
                        {
                            if(config.AntiCheat.MeleeRate.Enabled && violation.Trigger(player.userID))
                            {
                                var attack_rate = delay.ToString("F3");

                                violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationMeleeRate, new Dictionary<string, string>
                                {
                                    { "delay", attack_rate},
                                    { "target", target },
                                    { "weapon", weapon }
                                }), false, new Dictionary<string, string>
                                {
                                    { "attack_rate", attack_rate },
                                    { "movement_speed", player.estimatedSpeed.ToString("F1") },
                                    { "rate_percent", Percent(delay, max).ToString() },
                                    { "violation_id", DateTime.UtcNow.Ticks.ToString() },
                                    { "weapon_type", item.info.shortname }
                                });
                            }
                        }
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class Recoil
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 10;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const float latency_min = 0.075f;
                private const float latency_max = 0.175f;

                private const float recoil_max   = 9.765625e-4f;
                private const float recoil_range = recoil_max - epsilon;
                private const float recoil_scale = 100.0f / recoil_range;

                private const float repeat_interval = 1.25f;

                private const Key type = Key.AntiCheatRecoil;

                private static readonly Violation violation = new Violation(category);

                private static ulong reset_limit;
                private static float sensitivity;

                private class History
                {
                    public Counter  count_r;
                    public Counter  count_x;
                    public Counter  count_y;
                    public DateTime fired;
                    public ulong    repeats;

                    private static readonly Dictionary<ulong, History> histories = new Dictionary<ulong, History>();

                    private History()
                    {
                        count_r = new Counter();
                        count_x = new Counter();
                        count_y = new Counter();
                        fired   = DateTime.MinValue;
                        repeats = 0;
                    }

                    public static void Clear() => histories.Clear();

                    public static History Get(BasePlayer player)
                    {
                        History history;

                        if(!histories.TryGetValue(player.userID, out history))
                        {
                            histories.Add(player.userID, history = new History());
                        }

                        return history;
                    }
                }

                public static void Configure()
                {
                    var settings = config.AntiCheat.Recoil.Validate(30);

                    violation.Configure(settings, 2, 8, 1000);

                    reset_limit = settings.Count(12, 20);

                    sensitivity = 0.00001f + (0.00009f * settings.Sensitivity);
                }

                private static float Latency(BasePlayer player, Weapon weapon)
                {
                    var connection = player?.net?.connection;

                    var latency = 0.0f;

                    if(connection != null)
                    {
                        latency = 0.001f * (Net.sv.GetAveragePing(connection) >> 1);
                    }

                    if(latency < weapon.Repeat)
                    {
                        latency = weapon.Repeat;
                    }

                    return Generic.Clamp(latency, latency_min, latency_max);
                }

                private static uint Percent(float value) =>
                    (uint)((recoil_range - Generic.Clamp(value, epsilon, recoil_max)) * recoil_scale);

                public static void Trigger(BasePlayer player, Weapon weapon)
                {
                    if(Permissions.Bypass.AntiCheat.Recoil(player.userID))
                    {
                        return;
                    }

                    if(weapon == null)
                    {
                        return;
                    }

                    _instance.timer.In(Latency(player, weapon), () =>
                    {
                        var current = player.eyes.HeadRay().direction;

                        weapon.SetSwing(Vector3.Angle(current, weapon.AimAngle));

                        var x = Math.Abs(current.x - weapon.AimAngle.x) / weapon.Yaw;
                        var y = Math.Abs(current.y - weapon.AimAngle.y) / weapon.Pitch;

                        var history = History.Get(player);

                        x *= 0.25f + history.count_x.Ratio(true);
                        y *= 0.25f + history.count_y.Ratio(true);

                        var delay  = weapon.Fired.Subtract(history.fired).TotalSeconds;
                        var repeat = delay <= (weapon.Repeat * repeat_interval);
                        var reset  = false;
                        var reset_full = false;

                        if(Math.Abs(current.y) > 0.85f)
                        {
                            reset = true; y = 1.0f;
                        }
                        else if((x < epsilon) && (y < epsilon))
                        {
                            if(reset = (history.repeats == 0) || (history.repeats >= (weapon.Automatic ? 1ul : 2ul)))
                            {
                                reset_full = true;
                            }
                        }

                        var violations = 0ul;

                        if(reset_full && (history.repeats > 0))
                        {
                            history.count_r.Increment();

                            if(history.count_r.Total() >= reset_limit)
                            {
                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }
                        }
                        else
                        {
                            history.count_r.Decrement();
                        }

                        var can_trigger = false;

                        if(repeat)
                        {
                            ++history.repeats;

                            can_trigger = !(reset || weapon.Shell);
                        }
                        else
                        {
                            history.repeats = 0;
                        }

                        if(can_trigger)
                        {
                            if(x <= sensitivity)
                            {
                                history.count_x.Increment();

                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }

                            if(y <= sensitivity)
                            {
                                history.count_y.Increment();

                                if(violation.Trigger(player.userID))
                                {
                                    ++violations;
                                }
                            }
                        }
                        else if(!reset)
                        {
                            history.count_x.Decrement();
                            history.count_y.Decrement();
                        }

                        history.fired = weapon.Fired;

                        var playername = Text.Sanitize(player.displayName);

                        if(config.Log.AntiCheat.Recoil)
                        {
                            Log.Console(Key.LogAntiCheatRecoil, new Dictionary<string, string>
                            {
                                { "count_x", history.count_x.Total().ToString("D2") },
                                { "count_y", history.count_y.Total().ToString("D2") },
                                { "pitch", y.ToString("F6") },
                                { "playerid", player.UserIDString },
                                { "playername", playername },
                                { "swing", weapon.Swing.ToString("F1") },
                                { "weapon", $"{weapon.Name}[{history.repeats}{(reset ? $" (reset)" : string.Empty)}]" },
                                { "yaw", x.ToString("F6") }
                            });
                        }

                        foreach(var projectileid in weapon.Projectiles)
                        {
                            Projectile.Log.SetAttacker(player.userID, projectileid, playername, player.userID);

                            Projectile.Log.SetRecoil(player.userID, projectileid, y, history.repeats, x, weapon.Swing);

                            Projectile.Log.SetWeapon(player.userID, projectileid, weapon.Speed, weapon.Name);
                        }

                        if(config.AntiCheat.Recoil.Enabled && (violations > 0))
                        {
                            foreach(var projectileid in weapon.Projectiles)
                            {
                                Projectile.Log.SetRecoilViolations(player.userID, projectileid, violations);
                            }

                            violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationRecoil, new Dictionary<string, string>
                            {
                                { "pitch", y.ToString("F6") },
                                { "weapon", weapon.Name },
                                { "yaw", x.ToString("F6") }
                            }), violations, false, new Dictionary<string, string>
                            {
                                { "movement_speed", weapon.Speed.ToString("F1") },
                                { "recoil_pitch", Percent(y).ToString() },
                                { "recoil_repeats", history.repeats.ToString() },
                                { "recoil_yaw", Percent(x).ToString() },
                                { "violation_id", weapon.Fired.Ticks.ToString() },
                                { "weapon_ammo", weapon.AmmoName },
                                { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                { "weapon_type", weapon.ShortName }
                            });
                        }
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class Server
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private static Vector3 sensitivity = Vector3.zero;

                private const Key type = Key.Server;

                private static readonly Violation violation = new Violation(category);

                public static void Configure()
                {
                    var settings = config.AntiCheat.Server.Validate(900);

                    sensitivity = new Vector3(0.0f, 0.125f + 0.25f * (1.0f - config.AntiCheat.Server.Sensitivity), 0.0f);

                    violation.Configure(settings, 4, 16, 60000);
                }

                public static void Scan()
                {
                    Timers.Add(1.0f, () =>
                    {
                        if(config.AntiCheat.Server.Enabled)
                        {
                            foreach(var player in BasePlayer.activePlayerList)
                            {
                                if(User.ShouldIgnore(player) || User.CanFly(player))
                                {
                                    continue;
                                }

                                if(player.isMounted || player.HasParent() || player.IsSwimming())
                                {
                                    continue;
                                }

                                if(!player.IsFlying)
                                {
                                    player.SendConsoleCommand("noclip");
                                    player.SendConsoleCommand("debugcamera");
                                    player.SendConsoleCommand("camspeed", "0");
                                }

                                var position = player.transform.position;
                                var highspot = position + sensitivity;

                                if(!Map.Cave.IsInside(highspot))
                                {
                                    if(Map.Terrain.IsInside(highspot, false))
                                    {
                                        _instance.OnPlayerViolation(player, AntiHackType.InsideTerrain, position.y);
                                    }
                                    else if(Map.Rock.IsInside(highspot, false))
                                    {
                                        _instance.OnPlayerViolation(player, AntiHackType.NoClip, position.y);
                                    }
                                }

                                if(Map.Building.InFoundation(highspot))
                                {
                                    _instance.OnPlayerViolation(player, AntiHackType.NoClip, position.y);
                                }
                            }
                        }
                    });
                }

                public static void Trigger(BasePlayer player, AntiHackType ahtype, float amount)
                {
                    if(Permissions.Bypass.AntiCheat.Server(player.userID))
                    {
                        return;
                    }

                    if(Math.Abs(amount) < epsilon)
                    {
                        return;
                    }

                    var position = player.transform.position;

                    if(config.Log.AntiCheat.Server)
                    {
                        var colliders = string.Empty;

                        if((ahtype == AntiHackType.InsideTerrain) || (ahtype == AntiHackType.NoClip))
                        {
                            colliders = Map.Collider.Info(position);
                        }

                        Log.Console(Key.LogAntiCheatServer, new Dictionary<string, string>
                        {
                            { "amount", amount.ToString("F6") },
                            { "colliders", colliders },
                            { "playerid", player.UserIDString },
                            { "playername", Text.Sanitize(player.displayName) },
                            { "position", $"({(int)position.x},{(int)position.y},{(int)position.z})" },
                            { "type", ahtype.ToString() }
                        });
                    }

                    if(violation.Trigger(player.userID))
                    {
                        var antihack_amount = amount.ToString("F6");
                        var antihack_type   = ahtype.ToString();

                        violation.Trigger(player.userID, type, $"{antihack_type}({antihack_amount})", false, new Dictionary<string, string>
                        {
                            { "antihack_amount", antihack_amount },
                            { "antihack_type", antihack_type },
                            { "movement_speed", player.estimatedSpeed.ToString("F1") },
                            { "violation_id", DateTime.UtcNow.Ticks.ToString() }
                        });
                    }
                }

                public static void Unload() => violation.Clear();
            }

            public class Stash
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 3600;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatStash;

                private static readonly Violation violation = new Violation(category);

                private class History
                {
                    private static readonly Dictionary<ulong, List<Vector3>> histories = new Dictionary<ulong, List<Vector3>>();

                    public static void Clear() => histories.Clear();

                    public static float Set(ulong userid, Vector3 position)
                    {
                        List<Vector3> history;

                        if(!histories.TryGetValue(userid, out history))
                        {
                            histories.Add(userid, history = new List<Vector3> { position });

                            return 0.0f;
                        }

                        var minimum = float.MaxValue;
                        var nearest = Vector3.zero;

                        foreach(var found in history)
                        {
                            var delta = (found - position).sqrMagnitude;

                            if(delta < minimum)
                            {
                                minimum = delta;
                                nearest = found;
                            }
                        }

                        if(!Map.InRange2D(position, nearest, 3.0f))
                        {
                            history.Add(position);
                        }

                        return (float)Math.Sqrt(minimum);
                    }
                }

                private static float sensitivity;

                public static void Configure()
                {
                    var settings = config.AntiCheat.Stash.Validate(14400);

                    violation.Configure(settings, 1, 1, 3600000);

                    sensitivity = 3.0f + 18.0f * (1.0f - settings.Sensitivity);
                }

                public static void Subscribe()
                {
                    if(config.AntiCheat.Stash.Enabled)
                    {
                        Hooks.Subscribe(nameof(CanSeeStash));
                    }
                    else
                    {
                        Hooks.Unsubscribe(nameof(CanSeeStash));
                    }
                }

                public static void Trigger(BasePlayer player, StashContainer stash)
                {
                    if(Permissions.Bypass.AntiCheat.Stash(player.userID))
                    {
                        return;
                    }

                    if((player.userID == stash.OwnerID) || User.IsTeamMate(player, stash.OwnerID) || User.IsFriend(player, stash.OwnerID))
                    {
                        return;
                    }

                    _instance.NextTick(() =>
                    {
                        var position = stash.transform.position;

                        var grid = Map.Grid(position);

                        if(config.Log.AntiCheat.Stash)
                        {
                            Log.Console(Key.LogAntiCheatStash, new Dictionary<string, string>
                            {
                                { "grid", grid },
                                { "ownerid", stash.OwnerID.ToString() },
                                { "playerid", player.UserIDString },
                                { "playername", Text.Sanitize(player.displayName) },
                                { "position", $"({(int)position.x},{(int)position.y},{(int)position.z})" }
                            });
                        }

                        float distance = History.Set(player.userID, position);

                        if(config.AntiCheat.Stash.Enabled && (distance >= sensitivity))
                        {
                            var triggered = violation.Trigger(player.userID);

                            if(triggered || config.AntiCheat.Stash.Warn)
                            {
                                var details = Text.GetPlain(Key.ViolationStash, new Dictionary<string, string>
                                {
                                    { "grid", grid },
                                    { "position", $"({(int)position.x},{(int)position.y},{(int)position.z})" }
                                });

                                var hook_details = new Dictionary<string, string>
                                {
                                    { "stash_distance", distance.ToString("F1") },
                                    { "movement_speed", player.estimatedSpeed.ToString("F1") },
                                    { "violation_id", DateTime.UtcNow.Ticks.ToString() }
                                };

                                if(triggered)
                                {
                                    violation.Trigger(player.userID, type, details, false, hook_details);
                                }
                                else
                                {
                                    violation.Warning(player.userID, type, details, hook_details);
                                }
                            }
                        }
                    });
                }

                public static void Unload()
                {
                    History.Clear();

                    violation.Clear();
                }
            }

            public class Trajectory
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 90;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatTrajectory;

                private static readonly Violation violation = new Violation(category);

                private static float sensitivity;
                private static float sensitivity_lo;
                private static float sensitivity_hi;

                public static void Configure()
                {
                    var settings = config.AntiCheat.Trajectory.Validate(300);

                    violation.Configure(settings, 2, 8, 1000);

                    sensitivity = 5.0f + (5.0f * (1.0f - settings.Sensitivity));

                    sensitivity_lo = 0.0625f + 0.125f * settings.Sensitivity;
                    sensitivity_hi = 0.5f * sensitivity_lo;
                }

                private static float Ratio(float a, float b) => (a + sensitivity) / (b + sensitivity);

                private static uint Percent(float value) =>
                    (uint)(100.0f * (1.0f - value));

                public static void Trigger(BaseCombatEntity entity, HitInfo info)
                {
                    var player = info.InitiatorPlayer;

                    if(Permissions.Bypass.AntiCheat.Trajectory(player.userID))
                    {
                        return;
                    }

                    var weapon = Weapon.Get(player.userID, info.ProjectileID);

                    if(weapon == null)
                    {
                        return;
                    }

                    var d_actual = Vector3.Distance(entity.transform.position, weapon.Position);

                    var d_server = info.ProjectileDistance;

                    _instance.NextTick(() =>
                    {
                        var variance = (d_actual < d_server) ? Ratio(d_actual, d_server) : Ratio(d_server, d_actual);

                        if(float.IsNaN(variance) || float.IsInfinity(variance))
                        {
                            variance = 1.0f;
                        }
                        else
                        {
                            variance = Math.Abs(variance);
                        }

                        ulong violations = 0;

                        if(variance < sensitivity_lo)
                        {
                            if(violation.Trigger(player.userID))
                            {
                                ++violations;
                            }

                            if((variance < sensitivity_hi) && violation.Trigger(player.userID))
                            {
                                ++violations;
                            }
                        }

                        if(config.Log.AntiCheat.Trajectory)
                        {
                            Log.Console(Key.LogAntiCheatTrajectory, new Dictionary<string, string>
                            {
                                { "distance", d_actual.ToString("F1") },
                                { "playerid", player.UserIDString },
                                { "playername", Text.Sanitize(player.displayName) },
                                { "reported", d_server.ToString("F1") },
                                { "weapon", $"{weapon.Name}[{Enum.GetName(typeof(DamageType), entity.lastDamage)}]" }
                            });
                        }

                        Projectile.Log.SetTrajectory(player.userID, info.ProjectileID, variance);

                        if(player.isMounted || User.HasParent<CargoShip>(player) || User.HasParent<HotAirBalloon>(player))
                        {
                            return;
                        }

                        if(config.AntiCheat.Trajectory.Enabled && (violations > 0))
                        {
                            Projectile.Log.SetTrajectoryViolations(player.userID, info.ProjectileID, violations);

                            var hit_distance = d_actual.ToString("F1");
                            var projectile_distance = d_server.ToString("F1");

                            violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationTrajectory, new Dictionary<string, string>
                            {
                                { "distance", hit_distance },
                                { "reported", projectile_distance },
                                { "weapon", weapon.Name }
                            }), violations, false, new Dictionary<string, string>
                            {
                                { "hit_distance", hit_distance },
                                { "movement_speed", weapon.Speed.ToString("F1") },
                                { "projectile_distance", projectile_distance },
                                { "projectile_id", info.ProjectileID.ToString() },
                                { "trajectory_percent", Percent(variance).ToString() },
                                { "violation_id", weapon.Fired.Ticks.ToString() },
                                { "weapon_ammo", weapon.AmmoName },
                                { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                { "weapon_type", weapon.ShortName }
                            });
                        }
                    });
                }

                public static void Unload() => violation.Clear();
            }

            public class WallHack
            {
                public class Settings
                {
                    public bool  Ban;
           