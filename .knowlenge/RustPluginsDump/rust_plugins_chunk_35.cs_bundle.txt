         public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = true;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiCheatWallHack;

                private static readonly Violation violation = new Violation(category);

                public static void Configure()
                {
                    var settings = config.AntiCheat.WallHack.Validate(900);

                    violation.Configure(settings, 2, 8, 15000);
                }

                public static void Trigger(BasePlayer player, HitInfo info)
                {
                    if(Permissions.Bypass.AntiCheat.WallHack(player.userID))
                    {
                        return;
                    }

                    var victim = info.HitEntity as BasePlayer;

                    if((victim == null) || !victim.userID.IsSteamId())
                    {
                        return;
                    }

                    var weapon = Weapon.Get(player.userID, info.ProjectileID);

                    if((weapon == null) || weapon.Spread)
                    {
                        return;
                    }

                    _instance.NextTick(() =>
                    {
                        if(Physics.Linecast(info.PointStart, info.HitPositionWorld, Layers.Mask.Construction))
                        {
                            if(config.AntiCheat.WallHack.Enabled && violation.Trigger(player.userID))
                            {
                                Projectile.Log.SetWallHackViolations(player.userID, info.ProjectileID, 1);

                                violation.Trigger(player.userID, type, Text.GetPlain(Key.ViolationWallHack, new Dictionary<string, string>
                                {
                                    { "target", Text.Sanitize(victim.displayName) },
                                    { "weapon", weapon.Name }
                                }), false, new Dictionary<string, string>
                                {
                                    { "hit_distance", Vector3.Distance(victim.transform.position, weapon.Position).ToString("F1") },
                                    { "movement_speed", weapon.Speed.ToString("F1") },
                                    { "projectile_id", info.ProjectileID.ToString() },
                                    { "violation_id", weapon.Fired.Ticks.ToString() },
                                    { "weapon_ammo", weapon.AmmoName },
                                    { "weapon_attachments", string.Join(", ", weapon.Attachments) },
                                    { "weapon_type", weapon.ShortName }
                                });
                            }
                        }
                    });
                }

                public static void Unload() => violation.Clear();
            }
        }

        #endregion _anticheat_

        #region _antiflood_

        private class AntiFlood
        {
            public class Settings
            {
                public Chat.Settings     Chat;
                public Command.Settings  Command;
                public ItemDrop.Settings ItemDrop;

                public Settings()
                {
                    Chat     = new Chat.Settings();
                    Command  = new Command.Settings();
                    ItemDrop = new ItemDrop.Settings();
                }

                public void Validate()
                {
                    Configuration.Validate(ref Chat,     () => new Chat.Settings());
                    Configuration.Validate(ref Command,  () => new Command.Settings());
                    Configuration.Validate(ref ItemDrop, () => new ItemDrop.Settings());
                }
            }

            private const Key category = Key.AntiFlood;

            public static void Configure()
            {
                Chat.Configure();
                Command.Configure();
                ItemDrop.Configure();
            }

            public static void Unload()
            {
                Chat.Unload();
                Command.Unload();
                ItemDrop.Unload();
            }

            public class Chat
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 30;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = false;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiFloodChat;

                private static readonly Violation violation = new Violation(category);

                public static void Configure()
                {
                    var settings = config.AntiFlood.Chat.Validate(3600);

                    violation.Configure(settings, 5, 15, 1000);
                }

                public static ulong Cooldown(ulong playerid)
                {
                    return violation.Cooldown(playerid);
                }

                public static void Subscribe()
                {
                    if(config.AntiFlood.Chat.Enabled)
                    {
                        Hooks.Subscribe(nameof(OnPlayerChat));
                    }
                    else
                    {
                        Hooks.Unsubscribe(nameof(OnPlayerChat));
                    }
                }

                public static bool Trigger(ulong playerid)
                {
                    return violation.Trigger(playerid);
                }

                public static void Unload() => violation.Clear();

                public static void Violation(BasePlayer player, string details)
                {
                    if(config.AntiFlood.Chat.Enabled)
                    {
                        violation.Trigger(player.userID, type, details);
                    }
                }
            }

            public class Command
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 30;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = false;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiFloodCommand;

                private static readonly Violation violation = new Violation(category);

                public static void Configure()
                {
                    var settings = config.AntiFlood.Command.Validate(60);

                    violation.Configure(settings, 5, 15, 125);
                }

                public static ulong Cooldown(ulong playerid)
                {
                    return violation.Cooldown(playerid);
                }

                public static void Subscribe()
                {
                    if(config.AntiFlood.Command.Enabled)
                    {
                        Hooks.Subscribe(nameof(OnServerCommand));
                    }
                    else
                    {
                        Hooks.Unsubscribe(nameof(OnServerCommand));
                    }
                }

                public static bool Trigger(ulong playerid)
                {
                    return violation.Trigger(playerid);
                }

                public static void Unload() => violation.Clear();

                public static void Violation(BasePlayer player, string details)
                {
                    if(config.AntiFlood.Command.Enabled)
                    {
                        violation.Trigger(player.userID, type, details);
                    }
                }
            }

            public class ItemDrop
            {
                public class Settings
                {
                    public bool  Ban;
                    public ulong Cooldown;
                    public bool  Enabled;
                    public float Sensitivity;
                    public bool  Warn;

                    public Settings()
                    {
                        Ban         = false;
                        Cooldown    = 300;
                        Enabled     = true;
                        Sensitivity = 0.5f;
                        Warn        = false;
                    }

                    public Violation.Settings Validate(ulong max)
                    {
                        Configuration.Clamp(ref Cooldown,     1ul,  max);
                        Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                        return new Violation.Settings(Ban, Cooldown, Sensitivity, Warn);
                    }
                }

                private const Key type = Key.AntiFloodItemDrop;

                private static readonly Violation violation = new Violation(category);

                private static readonly Dictionary<ulong, int> history = new Dictionary<ulong, int>();

                public static void Configure()
                {
                    var settings = config.AntiFlood.ItemDrop.Validate(900);

                    violation.Configure(settings, 3, 7, 30000);
                }

                public static ulong CoolDown(ulong playerid, int itemid)
                {
                    history[playerid] = itemid;

                    return violation.Cooldown(playerid);
                }

                public static void Subscribe()
                {
                    if(config.AntiFlood.ItemDrop.Enabled)
                    {
                        Hooks.Subscribe(nameof(CanCraft));
                        Hooks.Subscribe(nameof(OnItemDropped));
                    }
                    else
                    {
                        Hooks.Unsubscribe(nameof(CanCraft));
                        Hooks.Unsubscribe(nameof(OnItemDropped));
                    }
                }

                public static bool Trigger(ulong playerid, int itemid)
                {
                    if(history.ContainsKey(playerid))
                    {
                        if(history[playerid] == itemid)
                        {
                            if(config.Log.AntiFlood.ItemDrop)
                            {
                                var playername = Text.Sanitize(BasePlayer.FindByID(playerid)?.displayName ?? Text.Get(Key.unknown));

                                var itemtext = ItemManager.FindItemDefinition(itemid)?.displayName;

                                var itemname = itemtext?.translated ?? itemtext?.english ?? Text.Get(Key.unknown);

                                Log.Console(Key.LogAntiSpamItemDrop, new Dictionary<string, string>
                                {
                                    { "itemid", itemid.ToString() },
                                    { "itemname", itemname },
                                    { "playerid", playerid.ToString() },
                                    { "playername", playername }
                                });
                            }

                            return config.AntiFlood.ItemDrop.Enabled && violation.Trigger(playerid);
                        }
                    }

                    return false;
                }

                public static void Unload()
                {
                    history.Clear();

                    violation.Clear();
                }

                public static void Violation(BasePlayer player, string details)
                {
                    violation.Trigger(player.userID, type, details);
                }
            }
        }

        #endregion _antiflood_

        #region _api_

        public class API
        {
            public class Settings
            {
                public string ApiKey;
                public bool   Enabled;

                public Settings()
                {
                    ApiKey  = string.Empty;
                    Enabled = false;
                }

                public void Validate()
                {
                    Configuration.Validate(ref ApiKey, () => { return string.Empty; });
                }
            }
        }

        #endregion _api_

        #region _ban_

        public class Ban
        {
            public class Settings
            {
                public bool    Inherit;
                public bool    Teleport;
                public BanTime Time;

                public Settings()
                {
                    Inherit  = true;
                    Teleport = false;
                    Time     = new BanTime();
                }

                public class BanTime
                {
                    public bool  Enforce;
                    public bool  Multiply;
                    public ulong Seconds;
                }

                public void Validate()
                {
                    Configuration.Validate(ref Time, () => new BanTime());
                }
            }
        }

        #endregion _ban_

        #region _chat_

        private class Chat
        {
            public static void Admin(Key key, Dictionary<string, string> parameters = null)
            {
                Log.Console(key, parameters);

                if(config.Admin.Broadcast)
                {
                    foreach(var player in BasePlayer.activePlayerList)
                    {
                        if(Permissions.Admin(player.userID))
                        {
                            Send(player, key, parameters);
                        }
                    }
                }
            }

            public static void Broadcast(Key key, Dictionary<string, string> parameters = null)
            {
                foreach(var player in BasePlayer.activePlayerList)
                {
                    Send(player, key, parameters);
                }
            }

            public static void Console(BasePlayer player, Key key, Dictionary<string, string> parameters = null)
            {
                if((player == null) || !player.IsConnected)
                {
                    return;
                }

                player.ConsoleMessage(Text.GetPlain(key, player, parameters));
            }

            public static void Reply(IPlayer iplayer, Key key, Dictionary<string, string> parameters = null)
            {
                if((iplayer == null) || iplayer.IsServer)
                {
                    Log.Console(key, parameters);
                }
                else
                {
                    if(iplayer.LastCommand == CommandType.Console)
                    {
                        iplayer.Reply(Text.GetPlain(key, iplayer, parameters));
                    }
                    else
                    {
                        Send(iplayer.Object as BasePlayer, key, parameters);
                    }
                }
            }

            public static void Send(BasePlayer player, Key key, Dictionary<string, string> parameters = null)
            {
                if((player == null) || !player.IsConnected)
                {
                    return;
                }

                var message = Text.Get(key, player, parameters);

                player.SendConsoleCommand("chat.add", 0, 76561199125814167UL, message);
            }
        }

        #endregion _chat_

        #region _command_

        private void CommandReceive(IPlayer iplayer, string command, string[] args) => Command.Receive(iplayer, command, args);

        private class Command
        {
            private static readonly Dictionary<string, Info> commands = new Dictionary<string, Info>();

            private static List<Info> info;

            private class Info
            {
                public Action<IPlayer, string, string[]> Action { get; protected set; }
                public List<string>                      Aliases { get; protected set; }
                public Key                               Title { get; protected set; }

                public Info(Action<IPlayer, string, string[]> action, Key title, params string[] aliases)
                {
                    Action  = action;
                    Aliases = new List<string>(aliases);
                    Title   = title;

                    foreach(var alias in aliases)
                    {
                        commands.Add(alias, this);
                    }
                }
            }

            public static void Load()
            {
                info = new List<Info>
                {
                    new Info(Config,   Key.CommandConfigTitle,   "g.config", "guardian.config"),
                    new Info(Help,     Key.CommandHelpTitle,     "g.help", "guardian", "guardian.help"),
                    new Info(Ip,       Key.CommandIpTitle,       "g.ip", "guardian.ip"),
                    new Info(Log,      Key.CommandLogTitle,      "g.log", "guardian.log"),
                    new Info(Server,   Key.CommandServerTitle,   "g.server", "guardian.server"),
                    new Info(Teleport, Key.CommandTeleportTitle, "g.tp", "g.tpv", "guardian.tp", "guardian.tpv"),
                    new Info(Users,    Key.CommandUserTitle,     "g.user", "guardian.user"),
                    new Info(Vpn,      Key.CommandVpnTitle,      "g.vpn", "guardian.vpn")
                };

                foreach(var command in commands)
                {
                    _instance.AddCovalenceCommand(command.Key, nameof(CommandReceive));
                }
            }

            public static void Receive(IPlayer iplayer, string command, string[] args)
            {
                Info entry;

                if(commands.TryGetValue(command = command.ToLower(), out entry))
                {
                    entry.Action(iplayer, command, args);
                }
                else
                {
                    Chat.Reply(iplayer, Key.CommandUnknown, new Dictionary<string, string>
                    {
                        { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                    });
                }
            }

            public static void Unload()
            {
                commands.Clear();

                info.Clear();
                info = null;
            }

            private static void Config(IPlayer iplayer, string command, string[] args)
            {
                var command_replace = new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                };

                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Config(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length == 0)
                {
                    goto syntax_error;
                }

                var subsection = args[0].ToLower();
                var subcommand = subsection.Split('.')[0];

                bool success = false;

                switch(subcommand)
                {
                case "admin":
                    switch(subsection)
                    {
                    case "admin.broadcast": success = Config(iplayer, args, subsection, ref config.Admin.Broadcast); break;
                    case "admin.bypass":    success = Config(iplayer, args, subsection, ref config.Admin.Bypass);    break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigAdminSyntax, command_replace);

                    return;

                case "anticheat":
                    switch(Config(subsection))
                    {
                    case "anticheat.aim":
                        switch(subsection)
                        {
                        case "anticheat.aim.ban":                success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Ban,         AntiCheat.Aim.Configure); break;
                        case "anticheat.aim.cooldown":           success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Cooldown,    AntiCheat.Aim.Configure); break;
                        case "anticheat.aim.enabled":            success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Enabled);                              break;
                        case "anticheat.aim.sensitivity":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Sensitivity, AntiCheat.Aim.Configure); break;
                        case "anticheat.aim.trigger.animal":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Trigger.Animal);                       break;
                        case "anticheat.aim.trigger.bradley":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Trigger.Bradley);                      break;
                        case "anticheat.aim.trigger.helicopter": success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Trigger.Helicopter);                   break;
                        case "anticheat.aim.trigger.npc":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Trigger.NPC);                          break;
                        case "anticheat.aim.warn":               success = Config(iplayer, args, subsection, ref config.AntiCheat.Aim.Warn,        AntiCheat.Aim.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatAimSyntax, command_replace);

                        return;

                    case "anticheat.firerate":
                        switch(subsection)
                        {
                        case "anticheat.firerate.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Ban,         AntiCheat.FireRate.Configure); break;
                        case "anticheat.firerate.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Cooldown,    AntiCheat.FireRate.Configure); break;
                        case "anticheat.firerate.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Enabled);                                   break;
                        case "anticheat.firerate.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Sensitivity, AntiCheat.FireRate.Configure); break;
                        case "anticheat.firerate.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.FireRate.Warn,        AntiCheat.FireRate.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatFireRateSyntax, command_replace);

                        return;

                    case "anticheat.gravity":
                        switch(subsection)
                        {
                        case "anticheat.gravity.ban":          success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Ban,         AntiCheat.Gravity.Configure); break;
                        case "anticheat.gravity.cooldown":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Cooldown,    AntiCheat.Gravity.Configure); break;
                        case "anticheat.gravity.enabled":      success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Enabled);                                  break;
                        case "anticheat.gravity.sensitivity":  success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Sensitivity, AntiCheat.Gravity.Configure); break;
                        case "anticheat.gravity.warn":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Gravity.Warn,        AntiCheat.Gravity.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatGravitySyntax, command_replace);

                        return;

                    case "anticheat.meleerate":
                        switch(subsection)
                        {
                        case "anticheat.meleerate.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Ban,         AntiCheat.MeleeRate.Configure); break;
                        case "anticheat.meleerate.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Cooldown,    AntiCheat.MeleeRate.Configure); break;
                        case "anticheat.meleerate.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Enabled);                                    break;
                        case "anticheat.meleerate.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Sensitivity, AntiCheat.MeleeRate.Configure); break;
                        case "anticheat.meleerate.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.MeleeRate.Warn,        AntiCheat.MeleeRate.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatMeleeRateSyntax, command_replace);

                        return;

                    case "anticheat.recoil":
                        switch(subsection)
                        {
                        case "anticheat.recoil.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Ban,         AntiCheat.Recoil.Configure); break;
                        case "anticheat.recoil.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Cooldown,    AntiCheat.Recoil.Configure); break;
                        case "anticheat.recoil.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Enabled);                                 break;
                        case "anticheat.recoil.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Sensitivity, AntiCheat.Recoil.Configure); break;
                        case "anticheat.recoil.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Recoil.Warn,        AntiCheat.Recoil.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatRecoilSyntax, command_replace);

                        return;

                    case "anticheat.server":
                        switch(subsection)
                        {
                        case "anticheat.server.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Ban,         AntiCheat.Server.Configure); break;
                        case "anticheat.server.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Cooldown,    AntiCheat.Server.Configure); break;
                        case "anticheat.server.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Enabled);                                 break;
                        case "anticheat.server.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Sensitivity, AntiCheat.Server.Configure); break;
                        case "anticheat.server.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Server.Warn,        AntiCheat.Server.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatServerSyntax, command_replace);

                        return;

                    case "anticheat.stash":
                        switch(subsection)
                        {
                        case "anticheat.stash.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Ban,         AntiCheat.Stash.Configure); break;
                        case "anticheat.stash.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Cooldown,    AntiCheat.Stash.Configure); break;
                        case "anticheat.stash.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Enabled,     AntiCheat.Stash.Subscribe); break;
                        case "anticheat.stash.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Sensitivity, AntiCheat.Stash.Configure); break;
                        case "anticheat.stash.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Stash.Warn,        AntiCheat.Stash.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatStashSyntax, command_replace);

                        return;

                    case "anticheat.trajectory":
                        switch(subsection)
                        {
                        case "anticheat.trajectory.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Ban,         AntiCheat.Trajectory.Configure); break;
                        case "anticheat.trajectory.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Cooldown,    AntiCheat.Trajectory.Configure); break;
                        case "anticheat.trajectory.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Enabled);                                     break;
                        case "anticheat.trajectory.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Sensitivity, AntiCheat.Trajectory.Configure); break;
                        case "anticheat.trajectory.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.Trajectory.Warn,        AntiCheat.Trajectory.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatTrajectorySyntax, command_replace);

                        return;

                    case "anticheat.wallhack":
                        switch(subsection)
                        {
                        case "anticheat.wallhack.ban":         success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Ban,         AntiCheat.WallHack.Configure); break;
                        case "anticheat.wallhack.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Cooldown,    AntiCheat.WallHack.Configure); break;
                        case "anticheat.wallhack.enabled":     success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Enabled);                                   break;
                        case "anticheat.wallhack.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Sensitivity, AntiCheat.WallHack.Configure); break;
                        case "anticheat.wallhack.warn":        success = Config(iplayer, args, subsection, ref config.AntiCheat.WallHack.Warn,        AntiCheat.WallHack.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiCheatWallHackSyntax, command_replace);

                        return;
                    }

                    Chat.Reply(iplayer, Key.CommandConfigAntiCheatSyntax, command_replace);

                    return;

                case "antiflood":
                    switch(Config(subsection))
                    {
                    case "antiflood.chat":
                        switch(subsection)
                        {
                        case "antiflood.chat.ban":         success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Ban,         AntiFlood.Chat.Configure); break;
                        case "antiflood.chat.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Cooldown,    AntiFlood.Chat.Configure); break;
                        case "antiflood.chat.enabled":     success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Enabled,     AntiFlood.Chat.Subscribe); break;
                        case "antiflood.chat.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Sensitivity, AntiFlood.Chat.Configure); break;
                        case "antiflood.chat.warn":        success = Config(iplayer, args, subsection, ref config.AntiFlood.Chat.Warn,        AntiFlood.Chat.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiFloodChatSyntax, command_replace);

                        return;

                    case "antiflood.command":
                        switch(subsection)
                        {
                        case "antiflood.command.ban":         success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Ban,         AntiFlood.Command.Configure); break;
                        case "antiflood.command.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Cooldown,    AntiFlood.Command.Configure); break;
                        case "antiflood.command.enabled":     success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Enabled,     AntiFlood.Command.Subscribe); break;
                        case "antiflood.command.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Sensitivity, AntiFlood.Command.Configure); break;
                        case "antiflood.command.warn":        success = Config(iplayer, args, subsection, ref config.AntiFlood.Command.Warn,        AntiFlood.Command.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiFloodCommandSyntax, command_replace);

                        return;

                    case "antiflood.itemdrop":
                        switch(subsection)
                        {
                        case "antiflood.itemdrop.ban":         success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Ban,         AntiFlood.ItemDrop.Configure); break;
                        case "antiflood.itemdrop.cooldown":    success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Cooldown,    AntiFlood.ItemDrop.Configure); break;
                        case "antiflood.itemdrop.enabled":     success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Enabled,     AntiFlood.ItemDrop.Subscribe); break;
                        case "antiflood.itemdrop.sensitivity": success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Sensitivity, AntiFlood.ItemDrop.Configure); break;
                        case "antiflood.itemdrop.warn":        success = Config(iplayer, args, subsection, ref config.AntiFlood.ItemDrop.Warn,        AntiFlood.ItemDrop.Configure); break;
                        }

                        if(!success) Chat.Reply(iplayer, Key.CommandConfigAntiFloodItemDropSyntax, command_replace);

                        return;
                    }

                    Chat.Reply(iplayer, Key.CommandConfigAntiFloodSyntax, command_replace);

                    return;

                case "ban":
                    switch(subsection)
                    {
                    case "ban.inherit":       success = Config(iplayer, args, subsection, ref config.Ban.Inherit); break;
                    case "ban.teleport":      success = Config(iplayer, args, subsection, ref config.Ban.Teleport); break;
                    case "ban.time.enforce":  success = Config(iplayer, args, subsection, ref config.Ban.Time.Enforce); break;
                    case "ban.time.multiply": success = Config(iplayer, args, subsection, ref config.Ban.Time.Multiply); break;
                    case "ban.time.seconds":  success = Config(iplayer, args, subsection, ref config.Ban.Time.Seconds); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigBanSyntax, command_replace);

                    return;

                case "cripple":
                    switch(subsection)
                    {
                    case "cripple.heal":    success = Config(iplayer, args, subsection, ref config.Cripple.Heal); break;
                    case "cripple.inherit": success = Config(iplayer, args, subsection, ref config.Cripple.Inherit); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigCrippleSyntax, command_replace);

                    return;

                case "discord":
                    switch(subsection)
                    {
                    case "discord.enabled":                   success = Config(iplayer, args, subsection, ref config.Discord.Enabled, () => Discord.Subscribe()); break;
                    case "discord.webhook":                   success = Config(iplayer, args, subsection, ref config.Discord.WebHook); break;
                    case "discord.filters.anticheat.enabled": success = Config(iplayer, args, subsection, ref config.Discord.Filters.AntiCheat.Enabled); break;
                    case "discord.filters.anticheat.webhook": success = Config(iplayer, args, subsection, ref config.Discord.Filters.AntiCheat.WebHook); break;
                    case "discord.filters.antiflood.enabled": success = Config(iplayer, args, subsection, ref config.Discord.Filters.AntiFlood.Enabled); break;
                    case "discord.filters.antiflood.webhook": success = Config(iplayer, args, subsection, ref config.Discord.Filters.AntiFlood.WebHook); break;
                    case "discord.filters.ip.enabled":        success = Config(iplayer, args, subsection, ref config.Discord.Filters.IP.Enabled); break;
                    case "discord.filters.ip.webhook":        success = Config(iplayer, args, subsection, ref config.Discord.Filters.IP.WebHook); break;
                    case "discord.filters.steam.enabled":     success = Config(iplayer, args, subsection, ref config.Discord.Filters.Steam.Enabled); break;
                    case "discord.filters.steam.webhook":     success = Config(iplayer, args, subsection, ref config.Discord.Filters.Steam.WebHook); break;
                    case "discord.filters.vpn.enabled":       success = Config(iplayer, args, subsection, ref config.Discord.Filters.VPN.Enabled); break;
                    case "discord.filters.vpn.webhook":       success = Config(iplayer, args, subsection, ref config.Discord.Filters.VPN.WebHook); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigDiscordSyntax, command_replace);

                    return;

                case "entity":
                    switch(subsection)
                    {
                    case "entity.damage.animal":     success = Config(iplayer, args, subsection, ref config.Entity.Damage.Animal,     () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.bradley":    success = Config(iplayer, args, subsection, ref config.Entity.Damage.Bradley,    () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.building":   success = Config(iplayer, args, subsection, ref config.Entity.Damage.Building,   () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.entity":     success = Config(iplayer, args, subsection, ref config.Entity.Damage.Entity,     () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.friend":     success = Config(iplayer, args, subsection, ref config.Entity.Damage.Friend,     () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.helicopter": success = Config(iplayer, args, subsection, ref config.Entity.Damage.Helicopter, () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.npc":        success = Config(iplayer, args, subsection, ref config.Entity.Damage.NPC,        () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.player":     success = Config(iplayer, args, subsection, ref config.Entity.Damage.Player,     () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.team":       success = Config(iplayer, args, subsection, ref config.Entity.Damage.Team,       () => config.Entity.Damage.Validate()); break;
                    case "entity.damage.trap":       success = Config(iplayer, args, subsection, ref config.Entity.Damage.Trap,       () => config.Entity.Damage.Validate()); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigEntitySyntax, command_replace);

                    return;

                case "ip":
                    switch(subsection)
                    {
                    case "ip.filter.cooldown":   success = Config(iplayer, args, subsection, ref config.IP.Filter.Cooldown, IP.Configure); break;
                    case "ip.violation.ban":     success = Config(iplayer, args, subsection, ref config.IP.Violation.Ban); break;
                    case "ip.violation.enabled": success = Config(iplayer, args, subsection, ref config.IP.Violation.Enabled); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigIpSyntax, command_replace);

                    return;

                case "log":
                    switch(subsection)
                    {
                    case "log.anticheat.aim":        success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Aim); break;
                    case "log.anticheat.gravity":    success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Gravity); break;
                    case "log.anticheat.meleerate":  success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.MeleeRate); break;
                    case "log.anticheat.recoil":     success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Recoil); break;
                    case "log.anticheat.server":     success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Server); break;
                    case "log.anticheat.stash":      success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Stash); break;
                    case "log.anticheat.trajectory": success = Config(iplayer, args, subsection, ref config.Log.AntiCheat.Trajectory); break;
                    case "log.antiflood.itemdrop":   success = Config(iplayer, args, subsection, ref config.Log.AntiFlood.ItemDrop); break;
                    case "log.ip.filter":            success = Config(iplayer, args, subsection, ref config.Log.IP.Filter); break;
                    case "log.projectile.collapse":  success = Config(iplayer, args, subsection, ref config.Log.Projectile.Collapse); break;
                    case "log.projectile.verbose":   success = Config(iplayer, args, subsection, ref config.Log.Projectile.Verbose); break;
                    case "log.user.bypass":          success = Config(iplayer, args, subsection, ref config.Log.User.Bypass); break;
                    case "log.user.connect":         success = Config(iplayer, args, subsection, ref config.Log.User.Connect); break;
                    case "log.vpn.check":            success = Config(iplayer, args, subsection, ref config.Log.VPN.Check); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigLogSyntax, command_replace);

                    return;

                case "save":
                    if((args.Length == 1) && (subsection == "save"))
                    {
                        Configuration.Save();

                        Chat.Reply(iplayer, Key.CommandConfig, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Saved, iplayer) },
                            { "info", Text.GetPlain(Key.file, iplayer) }
                        });

                        return;
                    }

                    Chat.Reply(iplayer, Key.CommandConfigSaveSyntax, command_replace);

                    return;

                case "steam":
                    switch(subsection)
                    {
                    case "steam.api.apikey":        success = Config(iplayer, args, subsection, ref config.Steam.API.ApiKey,        Steam.Configure); break;
                    case "steam.api.enabled":       success = Config(iplayer, args, subsection, ref config.Steam.API.Enabled,       Steam.Configure); break;
                    case "steam.ban.active":        success = Config(iplayer, args, subsection, ref config.Steam.Ban.Active,        Steam.Configure); break;
                    case "steam.ban.community":     success = Config(iplayer, args, subsection, ref config.Steam.Ban.Community,     Steam.Configure); break;
                    case "steam.ban.days":          success = Config(iplayer, args, subsection, ref config.Steam.Ban.Days,          Steam.Configure); break;
                    case "steam.ban.economy":       success = Config(iplayer, args, subsection, ref config.Steam.Ban.Economy,       Steam.Configure); break;
                    case "steam.ban.game":          success = Config(iplayer, args, subsection, ref config.Steam.Ban.Game,          Steam.Configure); break;
                    case "steam.ban.vac":           success = Config(iplayer, args, subsection, ref config.Steam.Ban.VAC,           Steam.Configure); break;
                    case "steam.game.count":        success = Config(iplayer, args, subsection, ref config.Steam.Game.Count,        Steam.Configure); break;
                    case "steam.game.hours":        success = Config(iplayer, args, subsection, ref config.Steam.Game.Hours,        Steam.Configure); break;
                    case "steam.profile.invalid":   success = Config(iplayer, args, subsection, ref config.Steam.Profile.Invalid,   Steam.Configure); break;
                    case "steam.profile.limited":   success = Config(iplayer, args, subsection, ref config.Steam.Profile.Limited,   Steam.Configure); break;
                    case "steam.profile.private":   success = Config(iplayer, args, subsection, ref config.Steam.Profile.Private,   Steam.Configure); break;
                    case "steam.share.family":      success = Config(iplayer, args, subsection, ref config.Steam.Share.Family,      Steam.Configure); break;
                    case "steam.violation.ban":     success = Config(iplayer, args, subsection, ref config.Steam.Violation.Ban); break;
                    case "steam.violation.enabled": success = Config(iplayer, args, subsection, ref config.Steam.Violation.Enabled); break;
                    case "steam.violation.warn":    success = Config(iplayer, args, subsection, ref config.Steam.Violation.Warn, Steam.Configure); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigSteamSyntax, command_replace);

                    return;

                case "user":
                    switch(subsection)
                    {
                    case "user.bypass.dayssincelastban": success = Config(iplayer, args, subsection, ref config.User.Bypass.DaysSinceBan); break;
                    case "user.bypass.enabled":          success = Config(iplayer, args, subsection, ref config.User.Bypass.Enabled); break;
                    case "user.bypass.hoursplayed":      success = Config(iplayer, args, subsection, ref config.User.Bypass.HoursPlayed); break;
                    case "user.bypass.multiply":         success = Config(iplayer, args, subsection, ref config.User.Bypass.Multiply); break;
                    case "user.friend.damage":           success = Config(iplayer, args, subsection, ref config.User.Friend.Damage); break;
                    case "user.team.damage":             success = Config(iplayer, args, subsection, ref config.User.Team.Damage); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigUserSyntax, command_replace);

                    return;
                case "violation":
                    switch(subsection)
                    {
                    case "violation.ban":         success = Config(iplayer, args, subsection, ref config.Violation.Ban,         Violation.Configure); break;
                    case "violation.cooldown":    success = Config(iplayer, args, subsection, ref config.Violation.Cooldown,    Violation.Configure); break;
                    case "violation.sensitivity": success = Config(iplayer, args, subsection, ref config.Violation.Sensitivity, Violation.Configure); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigViolationSyntax, command_replace);

                    return;

                case "vpn":
                    switch(subsection)
                    {
                    case "vpn.api.getipintel.apikey":      success = Config(iplayer, args, subsection, ref config.VPN.API.GetIpIntel.ApiKey); break;
                    case "vpn.api.getipintel.enabled":     success = Config(iplayer, args, subsection, ref config.VPN.API.GetIpIntel.Enabled); break;
                    case "vpn.api.ipapi.enabled":          success = Config(iplayer, args, subsection, ref config.VPN.API.IpApi.Enabled); break;
                    case "vpn.api.iphub.apikey":           success = Config(iplayer, args, subsection, ref config.VPN.API.IpHub.ApiKey, VPN.API.IpHub.Configure); break;
                    case "vpn.api.iphub.enabled":          success = Config(iplayer, args, subsection, ref config.VPN.API.IpHub.Enabled); break;
                    case "vpn.api.ipqualityscore.apikey":  success = Config(iplayer, args, subsection, ref config.VPN.API.IpQualityScore.ApiKey); break;
                    case "vpn.api.ipqualityscore.enabled": success = Config(iplayer, args, subsection, ref config.VPN.API.IpQualityScore.Enabled); break;
                    case "vpn.cache.hours":                success = Config(iplayer, args, subsection, ref config.VPN.Cache.Hours); break;
                    case "vpn.check.enabled":              success = Config(iplayer, args, subsection, ref config.VPN.Check.Enabled); break;
                    case "vpn.check.strict":               success = Config(iplayer, args, subsection, ref config.VPN.Check.Strict); break;
                    case "vpn.violation.ban":              success = Config(iplayer, args, subsection, ref config.VPN.Violation.Ban); break;
                    case "vpn.violation.enabled":          success = Config(iplayer, args, subsection, ref config.VPN.Violation.Enabled); break;
                    case "vpn.violation.warn":             success = Config(iplayer, args, subsection, ref config.VPN.Violation.Warn, VPN.Configure); break;
                    }

                    if(!success) Chat.Reply(iplayer, Key.CommandConfigVpnSyntax, command_replace);

                    return;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandConfigSyntax, command_replace);
            }
            private static string Config(string subsection)
            {
                var split = subsection.Split('.');

                if(split.Length >= 2)
                {
                    return split[0] + "." + split[1];
                }

                return subsection;
            }
            private static bool Config<T>(IPlayer iplayer, string[] args, string setting, ref T value, Action callback = null)
            {
                bool changed = false, success = false;

                if(args.Length == 1)
                {
                    success = true;
                }
                else if(args.Length == 2)
                {
                    if(typeof(T) == typeof(bool))
                    {
                        bool new_value;

                        if(bool.TryParse(args[1], out new_value))
                        {
                            if(!value.Equals(new_value))
                            {
                                changed = true; value = (T)Convert.ChangeType(new_value, typeof(T));
                            }

                            success = true;
                        }
                    }
                    else if(typeof(T) == typeof(float))
                    {
                        float new_value;

                        if(float.TryParse(args[1], out new_value))
                        {
                            if(!value.Equals(new_value))
                            {
                                changed = true; value = (T)Convert.ChangeType(new_value, typeof(T));
                            }

                            success = true;
                        }
                    }
                    else if(typeof(T) == typeof(string))
                    {
                        string new_value = args[1];

                        if(!value.Equals(new_value))
                        {
                            changed = true; value = (T)Convert.ChangeType(new_value, typeof(T));
                        }

                        success = true;
                    }
                    else if(typeof(T) == typeof(ulong))
                    {
                        ulong new_value;

                        if(ulong.TryParse(args[1], out new_value))
                        {
                            if(!value.Equals(new_value))
                            {
                                changed = true; value = (T)Convert.ChangeType(new_value, typeof(T));
                            }

                            success = true;
                        }
                    }
                    else
                    {
                        throw new NotImplementedException($"{_instance.Name}.Command.Config<T>: No conversion case exists for type T={typeof(T).Name}.");
                    }
                }

                if(success)
                {
                    if(changed)
                    {
                        Configuration.SetDirty();

                        callback?.Invoke();
                    }

                    Chat.Reply(iplayer, Key.CommandConfig, new Dictionary<string, string>
                    {
                        { "action", Text.GetPlain(changed ? Key.Changed : Key.Current, iplayer) },
                        { "info", $"{setting}={value}" }
                    });
                }

                return success;
            }

            private static void Help(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Admin(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }

                var console = iplayer.IsServer || (iplayer.LastCommand == CommandType.Console);

                StringBuilder aliases = new StringBuilder(), entries = new StringBuilder();

                foreach(var entry in info)
                {
                    foreach(var alias in entry.Aliases)
                    {
                        aliases.Append(console ? "\n    " : "\n    /").Append(alias);
                    }

                    entries.Append(Text.Get(Key.CommandHelpEntry, iplayer, new Dictionary<string, string>
                    {
                        { "aliases", aliases.ToString() },
                        { "title", Text.GetPlain(entry.Title, iplayer) }
                    }));

                    aliases.Clear();
                }

                Chat.Reply(iplayer, Key.CommandHelp, new Dictionary<string, string>
                {
                    { "entries", entries.ToString() },
                    { "name", _instance.Name },
                    { "version", Version.String }
                });
            }

            private static void Ip(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Ip(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length == 0)
                {
                    goto syntax_error;
                }

                switch(args[0].ToLower())
                {
                case "allow":
                    if(args.Length == 1)
                    {
                        Ip(iplayer, Key.Allowed, IP.GetAllows());

                        return;
                    }
                    else if(args.Length == 2)
                    {
                        var network = IP.Network(args[1]);

                        if(network?.Address != null)
                        {
                            Ip(iplayer, Key.Allowed, IP.GetAllows(network.Address));

                            return;
                        }
                    }
                    else if(args.Length == 3)
                    {
                        var network = IP.Network(args[2]);

                        if(network?.Address != null)
                        {
                            switch(args[1].ToLower())
                            {
                            case "add":
                                Ip(iplayer, Key.Allowed, network, true);

                                return;

                            case "remove":
                                Ip(iplayer, Key.Allowed, network, false);

                                return;
                            }
                        }
                    }

                    break;

                case "block":
                    if((args.Length == 2) && IP.IsValid(args[1]))
                    {
                        IP.Block(args[1]);

                        Chat.Reply(iplayer, Key.CommandIp, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Blocked, iplayer) },
                            { "info", args[1] }
                        });

                        return;
                    }

                    break;

                case "bypass":
                    if((args.Length == 2) && IP.IsValid(args[1]))
                    {
                        IP.Bypass(args[1]);

                        Chat.Reply(iplayer, Key.CommandIp, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Bypassed, iplayer) },
                            { "info", args[1] }
                        });

                        return;
                    }

                    break;

                case "deny":
                    if(args.Length == 1)
                    {
                        Ip(iplayer, Key.Denied, IP.GetDenies());

                        return;
                    }
                    else if(args.Length == 2)
                    {
                        var network = IP.Network(args[1]);

                        if(network?.Address != null)
                        {
                            Ip(iplayer, Key.Denied, IP.GetDenies(network.Address));

                            return;
                        }
                    }
                    else if(args.Length == 3)
                    {
                        var network = IP.Network(args[2]);

                        if(network?.Address != null)
                        {
                            switch(args[1].ToLower())
                            {
                            case "add":
                                Ip(iplayer, Key.Denied, network, true);

                                return;

                            case "remove":
                                Ip(iplayer, Key.Denied, network, false);

                                return;
                            }
                        }
                    }

                    break;

                case "save":
                    if(args.Length == 1)
                    {
                        IP.Save();

                        Chat.Reply(iplayer, Key.CommandIp, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Saved, iplayer) },
                            { "info", Text.GetPlain(Key.data, iplayer) }
                        });

                        return;
                    }

                    break;

                case "unblock":
                    if((args.Length == 2) && IP.IsValid(args[1]))
                    {
                        IP.Unblock(args[1]);

                        Chat.Reply(iplayer, Key.CommandIp, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Unblocked, iplayer) },
                            { "info", args[1] }
                        });

                        return;
                    }

                    break;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandIpSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }
            private static void Ip(IPlayer iplayer, Key key, IP.NetworkInfo network, bool add)
            {
                bool success;

                if(key == Key.Allowed)
                {
                    if(success = IP.SetAllow(network, add))
                    {
                        IP.Bypass(network);
                    }
                }
                else
                {
                    if(success = IP.SetDeny(network, add))
                    {
                        IP.Block(network);
                    }
                }

                if(success)
                {
                    Chat.Reply(iplayer, Key.CommandIpEntry, new Dictionary<string, string>
                    {
                        { "action", Text.GetPlain(add ? Key.Added : Key.Removed, iplayer) },
                        { "entry", $"{network.Address}/{network.Bits}" }
                    });
                }
                else
                {
                    Chat.Reply(iplayer, Key.CommandIpEntryFailed, new Dictionary<string, string>
                    {
                        { "action", Text.GetPlain(add ? Key.add : Key.remove, iplayer) },
                        { "entry", $"{network.Address}/{network.Bits}" }
                    });
                }
            }
            private static void Ip(IPlayer iplayer, Key key, List<string> list)
            {
                StringBuilder addresses = new StringBuilder();

                if(list.Count == 0)
                {
                    addresses.Append(Text.GetPlain(Key.empty, iplayer));
                }
                else
                {
                    foreach(var address in list)
                    {
                        addresses.Append("\n    ").Append(address);
                    }
                }

                Chat.Reply(iplayer, Key.CommandIpList, new Dictionary<string, string>
                {
                    { "addresses", addresses.ToString() },
                    { "type", Text.GetPlain(key, iplayer) }
                });
            }

            private static void Log(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Admin(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if((args.Length == 0) || (args.Length > 2))
                {
                    goto syntax_error;
                }

                var userids = User.Find(args[0]);

                if(userids.Count == 0)
                {
                    Chat.Reply(iplayer, Key.CommandUserNotFound);

                    return;
                }
                else if(userids.Count == 1)
                {
                    int lines = 0;

                    if(args.Length == 2)
                    {
                        int.TryParse(args[1], out lines);
                    }

                    if((lines = Generic.Clamp(lines, 0, 64)) == 0)
                    {
                        lines = 20;
                    }

                    foreach(var userid in userids)
                    {
                        Projectile.Log.Get(iplayer, userid, lines);

                        return;
                    }
                }
                else
                {
                    Users(iplayer, Key.CommandUserTooMany, userids);

                    return;
                }


            syntax_error:
                Chat.Reply(iplayer, Key.CommandLogSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }

            private static void Server(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Server(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length != 1)
                {
                    goto syntax_error;
                }

                switch(args[0].ToLower())
                {
                case "pardon": User.Pardon(iplayer); return;
                case "unban": User.Unban(iplayer); return;
                case "uncripple": User.Uncripple(iplayer); return;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandServerSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }

            private static void Teleport(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Tp(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length != 1)
                {
                    goto syntax_error;
                }

                var userids = User.Find(args[0]);

                if(userids.Count == 0)
                {
                    Chat.Reply(iplayer, Key.CommandUserNotFound);

                    return;
                }
                else if(userids.Count > 1)
                {
                    Users(iplayer, Key.CommandUserTooMany, userids);

                    return;
                }

                var position = Vector3.zero;

                if(command.EndsWith(".tp"))
                {
                    foreach(var userid in userids)
                    {
                        position = User.GetLastSeenPosition(userid);
                    }
                }
                else
                {
                    foreach(var userid in userids)
                    {
                        position = User.GetViolationPosition(userid);
                    }
                }

                var found = position != Vector3.zero;

                var parameters = new Dictionary<string, string>
                {
                    { "position", found ? $"({position.x:0.0} {position.y:0.0} {position.z:0.0})" : Text.GetPlain(Key.unknown, iplayer) }
                };

                if(command.EndsWith(".tp"))
                {
                    Chat.Reply(iplayer, Key.CommandTeleport, parameters);
                }
                else
                {
                    Chat.Reply(iplayer, Key.CommandTeleportViolation, parameters);
                }

                if(found && !iplayer.IsServer)
                {
                    iplayer.Teleport(position.x, position.y, position.z);
                }

                return;

            syntax_error:
                Chat.Reply(iplayer, Key.CommandTeleportSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }

            private static void Users(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Admin(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length == 0)
                {
                    goto syntax_error;
                }

                var is_ip = IP.IsValid(args[0]);

                var userids = User.Find(args[0]);

                if(userids.Count == 0)
                {
                    Chat.Reply(iplayer, Key.CommandUserNotFound);

                    return;
                }
                else if(userids.Count == 1)
                {
                    if(args.Length == 1)
                    {
                        foreach(var userid in userids)
                        {
                            Chat.Reply(iplayer, Key.CommandUserInfo, new Dictionary<string, string>
                            {
                                { "info", User.InfoText(userid, iplayer) }
                            });

                            return;
                        }
                    }
                }
                else if(args.Length == 1)
                {
                    Users(iplayer, Key.CommandUserTooMany, userids);

                    return;
                }
                else if(!is_ip)
                {
                    goto syntax_error;
                }

                ulong duration = 0; string duration_string = null, reason = null;

                if(args.Length == 3)
                {
                    if(!Text.ParseTime(args[2], out duration))
                    {
                        reason = string.IsNullOrEmpty(args[2]) ? null : args[2];
                    }
                }
                else if(args.Length == 4)
                {
                    reason = string.IsNullOrEmpty(args[2]) ? null : args[2];

                    if(!Text.ParseTime(args[3], out duration))
                    {
                        goto syntax_error;
                    }
                }
                else if(args.Length > 4)
                {
                    goto syntax_error;
                }

                if(duration == 0)
                {
                    duration_string = Text.GetPlain(Key.permanently, iplayer);
                }
                else
                {
                    duration_string = $"{Text.GetPlain(Key.For, iplayer)} {Text.Duration.Short(TimeSpan.FromSeconds(duration), iplayer)}";
                }

                var subcommand = args[1].ToLower();

                if(subcommand.StartsWith("team"))
                {
                    var dot = subcommand.IndexOf('.') + 1;

                    if(subcommand.Length > dot)
                    {
                        subcommand = subcommand.Substring(dot);
                    }

                    var team = new HashSet<ulong>();

                    foreach(var userid in userids)
                    {
                        foreach(var entry in User.Team(userid))
                        {
                            team.Add(entry);
                        }
                    }

                    foreach(var entry in team)
                    {
                        userids.Add(entry);
                    }
                }

                switch(subcommand)
                {
                case "ban":
                    foreach(var userid in userids)
                    {
                        User.Ban(userid, reason, duration, iplayer);

                        Chat.Reply(iplayer, Key.CommandUser, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Banned, iplayer) },
                            { "duration", duration_string },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() },
                            { "reason", reason }
                        });
                    }

                    return;

                case "ban.reset":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.BanReset(userid, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.BanReset, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;

                case "cripple":
                    foreach(var userid in userids)
                    {
                        User.Cripple(userid, reason, duration, iplayer);

                        Chat.Reply(iplayer, Key.CommandUser, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Crippled, iplayer) },
                            { "duration", duration_string },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() },
                            { "reason", reason }
                        });
                    }

                    return;

                case "cripple.reset":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.CrippleReset(userid, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.CrippleReset, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;

                case "kick":
                    if((args.Length > 3) || ((args.Length == 3) && (reason == null)))
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.Kick(userid, reason, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserKick, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Kicked, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() },
                            { "reason", reason }
                        });
                    }

                    return;

                case "pardon":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.Pardon(userid, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Pardoned, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;

                case "team":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    Users(iplayer, Key.CommandUserTeam, userids);

                    return;

                case "unban":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.Unban(userid, true, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Unbanned, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;

                case "uncripple":
                    if(args.Length != 2)
                    {
                        goto syntax_error;
                    }

                    foreach(var userid in userids)
                    {
                        User.Uncripple(userid, true, iplayer);

                        Chat.Reply(iplayer, Key.CommandUserAction, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Uncrippled, iplayer) },
                            { "playername", Text.Sanitize(User.Name(userid)) },
                            { "playerid", userid.ToString() }
                        });
                    }

                    return;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandUserSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }
            private static void Users(IPlayer iplayer, Key key, HashSet<ulong> userids)
            {
                var users = new StringBuilder();

                foreach(var userid in userids)
                {
                    users.Append("\n    ");
                    users.Append(userid.ToString());
                    users.Append(" - ");
                    users.Append(User.Name(userid));
                    users.Append(" (");
                    users.Append(User.StatusText(userid, iplayer));
                    users.Append(')');
                }

                Chat.Reply(iplayer, key, new Dictionary<string, string>
                {
                    { "users", users.ToString() }
                });

                users.Clear();
            }

            private static void Vpn(IPlayer iplayer, string command, string[] args)
            {
                BasePlayer player = iplayer.IsServer ? null : iplayer.Object as BasePlayer;

                if((player != null) && !Permissions.Command.Vpn(player.userID))
                {
                    Chat.Reply(iplayer, Key.CommandNoPermission);

                    return;
                }
                else if(args.Length != 2)
                {
                    goto syntax_error;
                }

                var address = args[1];

                if(!IP.IsValid(address))
                {
                    goto syntax_error;
                }

                switch(args[0].ToLower())
                {
                case "bypass":
                        VPN.Bypass(address);

                        IP.Unblock(address);

                        Vpn(iplayer, Key.Bypassed, address);

                        return;

                case "status":
                    Vpn(iplayer, Key.Current, address);

                    return;

                case "unblock":
                        VPN.Unblock(address);

                        IP.Unblock(address);

                        Vpn(iplayer, Key.Unblocked, address);

                        return;
                }

            syntax_error:
                Chat.Reply(iplayer, Key.CommandVpnSyntax, new Dictionary<string, string>
                {
                    { "command", (iplayer.LastCommand == CommandType.Console) ? command : ("/" + command) }
                });
            }
            private static void Vpn(IPlayer iplayer, Key key, string address)
            {
                var info = VPN.IsBlocked(address)  ? Text.GetPlain(Key.Blocked,   iplayer) :
                           VPN.IsBypassed(address) ? Text.GetPlain(Key.Bypassed,  iplayer) :
                                                     Text.GetPlain(Key.Unblocked, iplayer);

                Chat.Reply(iplayer, Key.CommandVpn, new Dictionary<string, string>
                {
                    { "action", Text.Get(key, iplayer) },
                    { "info", $"{info}({address})" }
                });
            }
        }

        #endregion _command_

        #region _configuration_

        private static Configuration config;

        private class Configuration
        {
            public Admin.Settings     Admin;
            public AntiCheat.Settings AntiCheat;
            public AntiFlood.Settings AntiFlood;
            public Ban.Settings       Ban;
            public Cripple.Settings   Cripple;
            public Discord.Settings   Discord;
            public Entity.Settings    Entity;
            public IP.Settings        IP;
            public Log.Settings       Log;
            public Steam.Settings     Steam;
            public User.Settings      User;
            public Version.Settings   Version;
            public Violation.Settings Violation;
            public VPN.Settings       VPN;

            private static bool corrupt  = false;
            private static bool dirty    = false;
            private static bool upgraded = false;

            public static void Clamp<T>(ref T value, T min, T max) where T : IComparable<T>
            {
                T clamped = Generic.Clamp(value, min, max);

                if(!value.Equals(clamped))
                {
                    dirty = true; value = clamped;
                }
            }

            public static void Load()
            {
                dirty = false;

                try
                {
                    config = _instance.Config.ReadObject<Configuration>();

                    config.Version.Compare(0, 0, 0);
                }
                catch(NullReferenceException)
                {
                    Guardian.Log.Warning("Configuration: Created new configuration with default settings.");

                    dirty = true; config = new Configuration();
                }
                catch(JsonException e)
                {
                    Guardian.Log.Error("Configuration: Using default settings. Delete the configuration file, or fix the following error, and reload; " + e.ToString());

                    corrupt = true; config = new Configuration();
                }

                Validate();
            }

            public static void Save()
            {
                if(dirty && !corrupt)
                {
                    dirty = false;

                    _instance.Config.WriteObject(config);
                }
            }

            public static void SetDirty() => dirty = true;

            public static void SetUpgrade(bool upgrade = true) => upgraded = upgrade;

            public static void Unload()
            {
                Save();

                config = null;
            }

            public static bool Upgraded() => upgraded;

            public static void Validate<T>(ref T value, Func<T> initializer, Action validator = null)
            {
                if(value == null)
                {
                    dirty = true; value = initializer();
                }
                else
                {
                    validator?.Invoke();
                }
            }

            private static void Validate()
            {
                Validate(ref config.Admin,     () => new Admin.Settings());
                Validate(ref config.AntiCheat, () => new AntiCheat.Settings(), () => config.AntiCheat.Validate());
                Validate(ref config.AntiFlood, () => new AntiFlood.Settings(), () => config.AntiFlood.Validate());
                Validate(ref config.Ban,       () => new Ban.Settings(),       () => config.Ban.Validate());
                Validate(ref config.Cripple,   () => new Cripple.Settings());
                Validate(ref config.Discord,   () => new Discord.Settings(),   () => config.Discord.Validate());
                Validate(ref config.Entity,    () => new Entity.Settings(),    () => config.Entity.Validate());
                Validate(ref config.IP,        () => new IP.Settings(),        () => config.IP.Validate());
                Validate(ref config.Log,       () => new Log.Settings(),       () => config.Log.Validate());
                Validate(ref config.Steam,     () => new Steam.Settings(),     () => config.Steam.Validate());
                Validate(ref config.User,      () => new User.Settings(),      () => config.User.Validate());
                Validate(ref config.Version,   () => new Version.Settings());
                Validate(ref config.Violation, () => new Violation.Settings());
                Validate(ref config.VPN,       () => new VPN.Settings(),       () => config.VPN.Validate());

                config.Version.Validate();
            }
        }

        #endregion _conifguration_

        #region _counter_

        private class Counter
        {
            private uint count;
            private uint delay;

            public Counter()
            {
                count = delay = 0;
            }

            public void Decrement()
            {
                if((delay >> 31) == 1)
                {
                    --count;
                }

                delay <<= 1;
            }

            public void Increment()
            {
                if((delay >> 31) == 0)
                {
                    ++count;
                }

                delay = (delay << 1) + 1;
            }

            public uint Percent()
            {
                return (100u * count) >> 5;
            }

            public float Ratio(bool inverse = false)
            {
                return inverse ? (1.0f - (count * 0.03125f)) : (count * 0.03125f);
            }

            public float Ratio(float scale, bool inverse = false)
            {
                return (inverse ? (1.0f - (count * 0.03125f)) : (count * 0.03125f)) * scale;
            }

            public ulong Total()
            {
                return count;
            }
        }

        #endregion _counter_

        #region _cripple_

        public class Cripple
        {
            public class Settings
            {
                public bool Heal;
                public bool Inherit;

                public Settings()
                {
                    Heal = false;
                    Inherit = true;
                }
            }
        }

        #endregion _cripple_

        #region _data_

        private class Data
        {
            private static DataFileSystem data = null;
            private static string         path = null;

            public static void Close()
            {
                data = null;
                path = null;
            }

            public static bool Exists(string name)
            {
                return data.ExistsDatafile(name);
            }

            public static void Open()
            {
                path = $"{Interface.Oxide.DataDirectory}\\{_instance.Name}";

                data = new DataFileSystem(path);
            }

            public static T ReadObject<T>(string name)
            {
                if(!string.IsNullOrEmpty(name) && data.ExistsDatafile(name))
                {
                    try
                    {
                        return data.ReadObject<T>(name);
                    }
                    catch(JsonException)
                    {
                        Log.Warning($"Data: recreating corrupted file \'{path}\\{name}.json\'.");
                    }
                }

                return default(T);
            }

            public static void WriteObject<T>(string name, T value)
            {
                data.WriteObject(name, value);
            }
        }

        #endregion _data_

        #region _data_file_

        private class DataFile<TKey, TValue>
        {
            private readonly Dictionary<TKey, TValue> data = new Dictionary<TKey, TValue>();

            private bool dirty;

            private string name;

            public DataFile(string name = null)
            {
                dirty = false; this.name = name;
            }

            public TValue this[TKey key]
            {
                get
                {
                    return data[key];
                }

                set
                {
                    data[key] = value;

                    SetDirty();
                }
            }

            public void Add(TKey key, TValue value)
            {
                if(!data.ContainsKey(key))
                {
                    this[key] = value;
                }
            }

            public bool Contains(TKey key)
            {
                return data.ContainsKey(key);
            }

            public void Clear()
            {
                data.Clear();

                SetDirty();
            }

            public bool Exists()
            {
                if(!string.IsNullOrEmpty(name))
                {
                    return Data.Exists(name);
                }

                return false;
            }

            public void ForEach(Action<TKey, TValue> action)
            {
                foreach(var entry in data)
                {
                    action(entry.Key, entry.Value);
                }
            }

            public TValue Get(TKey key, TValue default_value)
            {
                TValue value;

                if(data.TryGetValue(key, out value))
                {
                    return value;
                }

                return default_value;
            }

            public bool IsDirty() => dirty;

            public bool IsEmpty() => data.IsEmpty();

            public void Load()
            {
                if(string.IsNullOrEmpty(name))
                {
                    return;
                }

                try
                {
                    SetDirty(false);

                    var file = Data.ReadObject<Dictionary<TKey, TValue>>(name);

                    foreach(var entry in file)
                    {
                        data[entry.Key] = entry.Value;
                    }
                }
                catch
                {
                    SetDirty();
                }

                Save();
            }

            public void Load(string name)
            {
                SetName(name);

                Load();
            }

            public void Remove(TKey key)
            {
                if(data.ContainsKey(key))
                {
                    data.Remove(key);

                    SetDirty();
                }
            }

            public void Save()
            {
                if(IsDirty())
                {
                    if(!string.IsNullOrEmpty(name))
                    {
                        Data.WriteObject(name, data);
                    }

                    SetDirty(false);
                }
            }

            public void Save(string name)
            {
                SetName(name);

                Save();
            }

            public void SetDirty(bool value = true) => dirty = value;

            public void SetName(string name)
            {
                this.name = name;

                SetDirty();
            }

            public void Unload()
            {
                Save();

                data.Clear();
            }
        }

        #endregion _data_file_

        #region _discord_

        private class Discord
        {
            public class Settings
            {
                public bool           Enabled;
                public string         WebHook;
                public DiscordFilters Filters;

                public Settings()
                {
                    Enabled = false;
                    WebHook = string.Empty;
                    Filters = new DiscordFilters();
                }

                public class DiscordFilter
                {
                    public bool   Enabled;
                    public string WebHook;

                    public DiscordFilter()
                    {
                        Enabled = true;
                        WebHook = string.Empty;
                    }

                    public string URL() => Enabled ? WebHook : null;

                    public void Validate()
                    {
                        Configuration.Validate(ref WebHook, () => { return string.Empty; });
                    }
                }

                public class DiscordFilters
                {
                    public DiscordFilter AntiCheat;
                    public DiscordFilter AntiFlood;
                    public DiscordFilter IP;
                    public DiscordFilter Steam;
                    public DiscordFilter VPN;

                    public DiscordFilters()
                    {
                        AntiCheat = new DiscordFilter();
                        AntiFlood = new DiscordFilter();
                        IP        = new DiscordFilter();
                        Steam     = new DiscordFilter();
                        VPN       = new DiscordFilter();
                    }

                    public void Validate()
                    {
                        Configuration.Validate(ref AntiCheat, () => new DiscordFilter(), () => AntiCheat.Validate());
                        Configuration.Validate(ref AntiFlood, () => new DiscordFilter(), () => AntiFlood.Validate());
                        Configuration.Validate(ref IP,        () => new DiscordFilter(), () => IP.Validate());
                        Configuration.Validate(ref Steam,     () => new DiscordFilter(), () => Steam.Validate());
                        Configuration.Validate(ref VPN,       () => new DiscordFilter(), () => VPN.Validate());
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref WebHook, () => { return string.Empty; });
                    Configuration.Validate(ref Filters, () => new DiscordFilters(), () => Filters.Validate());
                }
            }

            public static void Send(string category, Dictionary<string, object> message)
            {
                if(!config.Discord.Enabled || (message == null))
                {
                    return;
                }

                if((message.Count == 0) || !(message.ContainsKey("content") || message.ContainsKey("embeds")))
                {
                    Log.Console(Key.LogDiscordMessage);

                    return;
                }

                var url = Select(category);

                if(string.IsNullOrWhiteSpace(url))
                {
                    if(url != null)
                    {
                        Log.Console(Key.LogDiscordConfig);
                    }

                    return;
                }

                WebHook.Send(url, "Discord", JsonConvert.SerializeObject(message));
            }

            private static string Select(string category)
            {
                string url;

                switch(Violation.Category(category))
                {
                case Key.AntiCheat: url = config.Discord.Filters.AntiCheat.URL(); break;
                case Key.AntiFlood: url = config.Discord.Filters.AntiFlood.URL(); break;
                case Key.IP:        url = config.Discord.Filters.IP.URL();        break;
                case Key.Steam:     url = config.Discord.Filters.Steam.URL();     break;
                case Key.VPN:       url = config.Discord.Filters.VPN.URL();       break;
                default:            url = null;                                   break;
                }

                if((url != null) && string.IsNullOrWhiteSpace(url))
                {
                    url = config.Discord.WebHook;
                }

                return url;
            }

            public static void Subscribe()
            {
                if(config.Discord.Enabled)
                {
                    Hooks.Subscribe(nameof(OnGuardianViolation));
                }
                else
                {
                    Hooks.Unsubscribe(nameof(OnGuardianViolation));
                }
            }
        }

        #endregion _discord_

        #region _entity_

        private class Entity
        {
            public class Settings
            {
                public EntityDamage Damage;

                public Settings()
                {
                    Damage = new EntityDamage();
                }

                public class EntityDamage
                {
                    public float Animal;
                    public float Bradley;
                    public float Building;
                    public float Entity;
                    public float Friend;
                    public float Helicopter;
                    public float NPC;
                    public float Player;
                    public float Team;
                    public float Trap;

                    public EntityDamage()
                    {
                        Animal     = 1.0f;
                        Bradley    = 1.0f;
                        Building   = 1.0f;
                        Entity     = 1.0f;
                        Friend     = 1.0f;
                        Helicopter = 1.0f;
                        NPC        = 1.0f;
                        Player     = 1.0f;
                        Team       = 1.0f;
                        Trap       = 1.0f;
                    }

                    public void Validate()
                    {
                        Configuration.Clamp(ref Animal,     0.0f, 100.0f);
                        Configuration.Clamp(ref Bradley,    0.0f, 100.0f);
                        Configuration.Clamp(ref Building,   0.0f, 100.0f);
                        Configuration.Clamp(ref Entity,     0.0f, 100.0f);
                        Configuration.Clamp(ref Friend,     0.0f, 100.0f);
                        Configuration.Clamp(ref Helicopter, 0.0f, 100.0f);
                        Configuration.Clamp(ref NPC,        0.0f, 100.0f);
                        Configuration.Clamp(ref Player,     0.0f, 100.0f);
                        Configuration.Clamp(ref Team,       0.0f, 100.0f);
                        Configuration.Clamp(ref Trap,       0.0f, 100.0f);
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref Damage, () => new EntityDamage(), () => Damage.Validate());
                }
            }

            public enum Type
            {
                Animal,
                AutoTurret,
                Bear,
                Boar,
                Bot,
                Bradley,
                Building,
                Chicken,
                Entity,
                FlameTurret,
                GunTrap,
                Helicopter,
                Murderer,
                NPC,
                Player,
                SAMSite,
                Scientist,
                Sentry,
                Stag,
                TC,
                NULL
            }

            public class Damage
            {
                private static readonly DamageTypeList cleared = new DamageTypeList();

                public static void Cancel(HitInfo info)
                {
                    info.damageTypes = cleared;
                    info.HitMaterial = 0;
                    info.PointStart  = Vector3.zero;
                    info.HitEntity   = null;
                }

                public static object Scale(HitInfo info, BasePlayer attacker, BaseCombatEntity victim)
                {
                    switch(Entity.GetType(info.HitEntity))
                    {
                    case Type.Animal:      return Scale(info, config.Entity.Damage.Animal);
                    case Type.AutoTurret:  return Scale(info, config.Entity.Damage.Trap);
                    case Type.Bear:        return Scale(info, config.Entity.Damage.Animal);
                    case Type.Boar:        return Scale(info, config.Entity.Damage.Animal);
                    case Type.Bot:         return Scale(info, config.Entity.Damage.NPC);
                    case Type.Bradley:     return Scale(info, config.Entity.Damage.Bradley);
                    case Type.Building:    return Scale(info, config.Entity.Damage.Building);
                    case Type.Chicken:     return Scale(info, config.Entity.Damage.Animal);
                    case Type.Entity:      return Scale(info, config.Entity.Damage.Entity);
                    case Type.FlameTurret: return Scale(info, config.Entity.Damage.Trap);
                    case Type.GunTrap:     return Scale(info, config.Entity.Damage.Trap);
                    case Type.Helicopter:  return Scale(info, config.Entity.Damage.Helicopter);
                    case Type.Murderer:    return Scale(info, config.Entity.Damage.NPC);
                    case Type.NPC:         return Scale(info, config.Entity.Damage.NPC);
                    case Type.Player:      return Scale(info, attacker, victim.ToPlayer());
                    case Type.SAMSite:     return Scale(info, config.Entity.Damage.Trap);
                    case Type.Scientist:   return Scale(info, config.Entity.Damage.NPC);
                    case Type.Sentry:      return Scale(info, config.Entity.Damage.Trap);
                    case Type.Stag:        return Scale(info, config.Entity.Damage.Animal);
                    case Type.TC:          return Scale(info, config.Entity.Damage.Building);
                    }

                    return null;
                }
                private static object Scale(HitInfo info, BasePlayer attacker, BasePlayer victim)
                {
                    if(victim == attacker)
                    {
                        return null;
                    }

                    var scale = 1.0f;

                    if((config.Entity.Damage.Friend != 1.0f) && User.IsFriend(attacker, victim))
                    {
                        scale = Math.Min(scale, config.Entity.Damage.Friend);
                    }

                    if((config.Entity.Damage.Team != 1.0f) && User.IsTeamMate(attacker, victim))
                    {
                        scale = Math.Min(scale, config.Entity.Damage.Team);
                    }

                    return Scale(info, scale * config.Entity.Damage.Player);
                }
                private static object Scale(HitInfo info, float scale)
                {
                    if(scale == 1.0f)
                    {
                        return null;
                    }

                    if(scale == 0.0f)
                    {
                        Cancel(info);
                    }
                    else
                    {
                        info.damageTypes.ScaleAll(scale);
                    }

                    return true;
                }
            }

            public static BasePlayer GetAttacker(BaseCombatEntity entity, HitInfo info)
            {
                var attacker = info?.Initiator ?? entity?.lastAttacker;

                if(attacker is FireBall)
                {
                    return Fire.Initiator(attacker as FireBall);
                }

                return attacker as BasePlayer;
            }

            public static string GetName(BaseEntity entity)
            {
                return GetName(entity, GetType(entity));
            }
            private static string GetName(BaseEntity entity, Type type)
            {
                switch(type)
                {
                case Type.Animal:      return $"{Text.GetPlain(Key.EntityAnimal)}({entity.GetType().Name})";
                case Type.AutoTurret:  return $"{Text.GetPlain(Key.EntityTrap)}({Text.GetPlain(Key.EntityAutoTurret)})";
                case Type.Bear:        return $"{Text.GetPlain(Key.EntityAnimal)}({Text.GetPlain(Key.EntityBear)})";
                case Type.Boar:        return $"{Text.GetPlain(Key.EntityAnimal)}({Text.GetPlain(Key.EntityBoar)})";
                case Type.Bot:         return $"{Text.GetPlain(Key.EntityNPC)}({Text.Sanitize((entity as BasePlayer).displayName)})";
                case Type.Bradley:     return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityBradley)})";
                case Type.Building:    return $"{Text.GetPlain(Key.EntityBuilding)}({GetPrefabName(entity)})";
                case Type.Chicken:     return $"{Text.GetPlain(Key.EntityAnimal)}({Text.GetPlain(Key.EntityChicken)})";
                case Type.Entity:      return $"{Text.GetPlain(Key.Entity)}({GetPrefabName(entity)})";
                case Type.FlameTurret: return $"{Text.GetPlain(Key.EntityTrap)}({Text.GetPlain(Key.EntityFlameTurret)})";
                case Type.GunTrap:     return $"{Text.GetPlain(Key.EntityTrap)}({Text.GetPlain(Key.EntityGunTrap)})";
                case Type.Helicopter:  return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityHelicopter)})";
                case Type.Murderer:    return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityMurderer)})";
                case Type.NPC:         return $"{Text.GetPlain(Key.EntityNPC)}({entity.GetType().Name})";
                case Type.Player:      return $"{Text.GetPlain(Key.EntityPlayer)}({Text.Sanitize((entity as BasePlayer).displayName)})";
                case Type.SAMSite:     return $"{Text.GetPlain(Key.EntityTrap)}({Text.GetPlain(Key.EntitySAMSite)})";
                case Type.Scientist:   return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityScientist)})";
                case Type.Sentry:      return $"{Text.GetPlain(Key.EntityNPC)}({Text.GetPlain(Key.EntityAutoTurret)})";
                case Type.Stag:        return $"{Text.GetPlain(Key.EntityAnimal)}({Text.GetPlain(Key.EntityStag)})";
                case Type.TC:          return $"{Text.GetPlain(Key.EntityBuilding)}({Text.GetPlain(Key.EntityTC)})";
                }

                return $"{Text.GetPlain(Key.Entity)}({Text.GetPlain(Key.NULL)})";
            }

            private static string GetPrefabName(BaseEntity entity)
            {
                if(string.IsNullOrEmpty(entity.ShortPrefabName))
                {
                    return entity.GetType().Name;
                }

                return entity.ShortPrefabName.Split('.')[0];
            }

            public static Type GetType(BaseEntity entity, out string name)
            {
                var type = GetType(entity);

                name = GetName(entity, type);

                return type;
            }
            public static Type GetType(BaseEntity entity)
            {
                if(entity == null)
                {
                    return Type.NULL;
                }

                switch(entity.GetType().Name)
                {
                case "AutoTurret":     return Type.AutoTurret;
                case "BaseHelicopter": return Type.Helicopter;
                case "BasePlayer":     return (entity as BasePlayer).userID.IsSteamId() ? Type.Player : Type.Bot;
                case "Bear":           return Type.Bear;
                case "Boar":           return Type.Boar;
                case "BradleyAPC":     return Type.Bradley;
                case "Chicken":        return Type.Chicken;
                case "FlameTurret":    return Type.FlameTurret;
                case "GunTrap":        return Type.GunTrap;
                case "HTNPlayer":      return Type.Scientist;
                case "NPCAutoTurret":  return Type.Sentry;
                case "NPCMurderer":    return Type.Murderer;
                case "SamSite":        return Type.SAMSite;
                case "Scientist":      return Type.Scientist;
                case "ScientistNPC":   return Type.Scientist;
                case "Stag":           return Type.Stag;
                }

                if(entity is BasePlayer)
                {
                    return Type.NPC;
                }
                else if(entity is BaseAnimalNPC)
                {
                    return Type.Animal;
                }
                else if(entity is BuildingBlock)
                {
                    return Type.Building;
                }
                else if(entity is BuildingPrivlidge)
                {
                    return Type.TC;
                }

                return Type.Entity;
            }

            public class Health
            {
                private static readonly Dictionary<int, float> health = new Dictionary<int, float>();

                public static bool Changed(BaseEntity entity)
                {
                    if(entity != null)
                    {
                        var instanceid = entity.GetInstanceID();

                        float current = entity.Health(), previous;

                        if(!health.TryGetValue(instanceid, out previous))
                        {
                            previous = float.MaxValue;
                        }

                        health[instanceid] = current;

                        return previous != current;
                    }

                    return false;
                }

                public static void Clear() => health.Clear();
                public static void Clear(BaseEntity entity)
                {
                    if(entity != null)
                    {
                        health.Remove(entity.GetInstanceID());
                    }
                }
            }

            public static void Unload() => Health.Clear();
        }

        #endregion _entity_

        #region _fire_

        private class Fire
        {
            private static Dictionary<int, BasePlayer> fires = new Dictionary<int, BasePlayer>();

            public static void Ignite(FireBall fire, BasePlayer initiator)
            {
                if((fire != null) && (initiator?.userID.IsSteamId() ?? false))
                {
                    fires[fire.GetInstanceID()] = initiator;
                }
            }

            public static BasePlayer Initiator(FireBall fire)
            {
                if(fire != null)
                {
                    BasePlayer initiator;

                    if(fires.TryGetValue(fire.GetInstanceID(), out initiator))
                    {
                        return initiator;
                    }
                }

                return null;
            }

            public static void Spread(FireBall fire, FireBall spread)
            {
                if((fire != null) || (spread != null))
                {
                    BasePlayer initiator;

                    if(fires.TryGetValue(fire.GetInstanceID(), out initiator))
                    {
                        fires.Add(spread.GetInstanceID(), initiator);
                    }
                }
            }

            public static void Quench(FireBall fire)
            {
                if(fire != null)
                {
                    fires.Remove(fire.GetInstanceID());
                }
            }

            public static void Unload() => fires.Clear();
        }

        #endregion _fire_

        #region _generic_

        private class Generic
        {
            public static T Clamp<T>(T value, T min, T max) where T : IComparable<T>
            {
                if(value.CompareTo(min) < 0)
                {
                    return min;
                }
                else if(value.CompareTo(max) > 0)
                {
                    return max;
                }

                return value;
            }
        }

        #endregion _generic_

        #region _hooks_

        private new class Hooks
        {
            private static HashSet<string> subscribed;
            private static HashSet<string> unsubscribed;

            public class Base
            {
                public static void Subscribe()
                {
                    Hooks.Subscribe(nameof(OnUserBanned));
                    Hooks.Subscribe(nameof(OnUserUnbanned));
                }
            }

            public class Core
            {
                public static void Subscribe()
                {
                    Hooks.Subscribe(nameof(CanBypassQueue));
                    Hooks.Subscribe(nameof(CanLootEntity));
                    Hooks.Subscribe(nameof(CanLootPlayer));
                    Hooks.Subscribe(nameof(CanUserLogin));
                    Hooks.Subscribe(nameof(OnEntityDeath));
                    Hooks.Subscribe(nameof(OnEntityKill));
                    Hooks.Subscribe(nameof(OnEntityTakeDamage));
                    Hooks.Subscribe(nameof(OnFireBallDamage));
                    Hooks.Subscribe(nameof(OnFireBallSpread));
                    Hooks.Subscribe(nameof(OnFlameExplosion));
                    Hooks.Subscribe(nameof(OnFlameThrowerBurn));
                    Hooks.Subscribe(nameof(OnGroupPermissionGranted));
                    Hooks.Subscribe(nameof(OnGroupPermissionRevoked));
                    Hooks.Subscribe(nameof(OnLootEntity));
                    Hooks.Subscribe(nameof(OnLootPlayer));
                    Hooks.Subscribe(nameof(OnPlayerAttack));
                    Hooks.Subscribe(nameof(OnPlayerConnected));
                    Hooks.Subscribe(nameof(OnPlayerDisconnected));
                    Hooks.Subscribe(nameof(OnPlayerViolation));
                    Hooks.Subscribe(nameof(OnRocketLaunched));
                    Hooks.Subscribe(nameof(OnUserPermissionGranted));
                    Hooks.Subscribe(nameof(OnUserPermissionRevoked));
                    Hooks.Subscribe(nameof(OnWeaponFired));
                }
            }

            public class Dynamic
            {
                public static void Subscribe()
                {
                    AntiCheat.Stash.Subscribe();
                    AntiFlood.Chat.Subscribe();
                    AntiFlood.Command.Subscribe();
                    AntiFlood.ItemDrop.Subscribe();
                    Discord.Subscribe();
                }
            }

            public static void Load()
            {
                subscribed = new HashSet<string>
                {
                    nameof(CanBypassQueue),
                    nameof(CanCraft),
                    nameof(CanLootEntity),
                    nameof(CanLootPlayer),
                    nameof(CanSeeStash),
                    nameof(CanUserLogin),
                    nameof(OnEntityDeath),
                    nameof(OnEntityKill),
                    nameof(OnEntityTakeDamage),
                    nameof(OnFireBallDamage),
                    nameof(OnFireBallSpread),
                    nameof(OnFlameExplosion),
                    nameof(OnFlameThrowerBurn),
                    nameof(OnGuardianViolation),
                    nameof(OnGroupPermissionGranted),
                    nameof(OnGroupPermissionRevoked),
                    nameof(OnItemDropped),
                    nameof(OnLootEntity),
                    nameof(OnLootPlayer),
                    nameof(OnPlayerAttack),
                    nameof(OnPlayerChat),
                    nameof(OnPlayerConnected),
                    nameof(OnPlayerDisconnected),
                    nameof(OnPlayerViolation),
                    nameof(OnRocketLaunched),
                    nameof(OnServerCommand),
                    nameof(OnUserBanned),
                    nameof(OnUserPermissionGranted),
                    nameof(OnUserPermissionRevoked),
                    nameof(OnUserUnbanned),
                    nameof(OnWeaponFired)
                };

                unsubscribed = new HashSet<string>();

                Unsubscribe();
            }

            public static void Subscribe(string hook)
            {
                if(unsubscribed.Contains(hook))
                {
                    unsubscribed.Remove(hook);

                    _instance.Subscribe(hook);

                    subscribed.Add(hook);
                }
            }

            public static void Unload()
            {
                Unsubscribe();

                subscribed = null;

                unsubscribed.Clear();
                unsubscribed = null;
            }

            private static void Unsubscribe()
            {
                foreach(var hook in subscribed)
                {
                    _instance.Unsubscribe(hook);

                    unsubscribed.Add(hook);
                }

                subscribed.Clear();
            }
            public static void Unsubscribe(string hook)
            {
                if(subscribed.Contains(hook))
                {
                    subscribed.Remove(hook);

                    _instance.Unsubscribe(hook);

                    unsubscribed.Add(hook);
                }
            }
        }

        #region _hooks_lifecycle_

        private void Init()
        {
            _instance = this;

            Data.Open();
            Configuration.Load();

            Hooks.Load();

            Permissions.Load();

            Text.Load();

            IP.Load();
            User.Load();

            Projectile.Load();
            Steam.Load();
            Violation.Load();
            VPN.Load();
            Weapon.Load();

            AntiCheat.Configure();
            AntiFlood.Configure();

            Command.Load();

            Configuration.Save();
        }

        private void Loaded()
        {
            Hooks.Base.Subscribe();
        }

        protected override void LoadDefaultConfig() { }

        protected override void LoadDefaultMessages() { }

        private void OnServerInitialized()
        {
            Hooks.Core.Subscribe();

            Hooks.Dynamic.Subscribe();

            Map.Load();

            User.Update();
        }

        private void OnServerSave()
        {
            Configuration.Save();

            IP.Save();
            User.Save();
            VPN.Save();
        }

        private void Unload()
        {
            Hooks.Unload();

            Timers.Destroy();

            Map.Unload();
            Fire.Unload();
            Entity.Unload();

            Command.Unload();

            AntiFlood.Unload();
            AntiCheat.Unload();

            Weapon.Unload();
            VPN.Unload();
            Violation.Unload();
            Steam.Unload();
            Projectile.Unload();

            User.Unload();
            IP.Unload();

            Text.Unload();

            Permissions.Unload();

            Configuration.Unload();
            Data.Close();

            _instance = null;
        }

        #endregion _hooks_lifecycle_

        #region _hooks_other_

        private object CanBypassQueue(Connection connection)
        {
            if(Permissions.Ignore(connection.userid, true))
            {
                return true;
            }
            else if(config.Admin.Bypass && Permissions.Admin(connection.userid, true))
            {
                return true;
            }

            return null;
        }

        private object CanCraft(ItemCrafter crafter, ItemBlueprint bp, int amount)
        {
            if(!config.AntiFlood.ItemDrop.Enabled)
            {
                return null;
            }

            var player = crafter.gameObject.GetComponent<BasePlayer>();

            if(User.ShouldIgnore(player))
            {
                return null;
            }

            var cooldown = AntiFlood.ItemDrop.CoolDown(player.userID, bp.targetItem.itemid);

            if(cooldown == 0)
            {
                return null;
            }

            Chat.Send(player, Key.Cooldown, new Dictionary<string, string>
            {
                { "cooldown", cooldown.ToString() },
                { "type", Text.Get(Key.Crafting) }
            });

            AntiFlood.ItemDrop.Violation(player, bp.targetItem.displayName.english);

            return false;
        }

        private object CanLootEntity(BasePlayer looter, DroppedItemContainer target) => User.CanLoot(looter, target.playerSteamID);

        private object CanLootEntity(BasePlayer looter, LootableCorpse target) => User.CanLoot(looter, target.playerSteamID);

        private object CanLootPlayer(BasePlayer target, BasePlayer looter) => User.CanLoot(looter, target.userID);

        private object CanSeeStash(BasePlayer player, StashContainer stash)
        {
            if(!config.AntiCheat.Stash.Enabled)
            {
                return null;
            }

            if(User.ShouldIgnore(player))
            {
                return null;
            }

            AntiCheat.Stash.Trigger(player, stash);

            return null;
        }

        private object CanUserLogin(string name, string id, string address)
        {
            return User.CanConnect(name, id, address);
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            Entity.Health.Clear(entity);

            var victim = entity.ToPlayer();

            if(User.ShouldIgnore(victim))
            {
                return;
            }

            var attacker = Entity.GetAttacker(entity, info);

            if(!User.ShouldIgnore(attacker))
            {
                User.AssignAttacker(attacker, victim);
            }

            User.AssignVictim(victim);
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if(entity is FireBall)
            {
                Fire.Quench(entity as FireBall);
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var attacker = Entity.GetAttacker(entity, info);

            if(User.ShouldIgnore(attacker))
            {
                return null;
            }

            if(info.IsProjectile())
            {
                AntiCheat.Aim.Trigger(entity, info);
                AntiCheat.FireRate.Trigger(entity, info);
                AntiCheat.Trajectory.Trigger(entity, info);
            }

            if((attacker.net?.connection?.authLevel ?? 0) > 0)
            {
                return null;
            }

            var victim = entity.ToPlayer();

            if(!User.ShouldIgnore(victim))
            {
                User.AssignAttacker(attacker, victim);

                if(User.IsCrippled(attacker.userID) && (victim != attacker))
                {
                    if(victim.IsWounded())
                    {
                        victim.StopWounded();
                    }

                    Entity.Damage.Cancel(info);

                    if(config.Cripple.Heal)
                    {
                        _instance.NextFrame(() =>
                        {
                            victim.Heal(100.0f);
                        });
                    }

                    return true;
                }
            }

            return Entity.Damage.Scale(info, attacker, entity);
        }

        private void OnFireBallDamage(FireBall fireball, BaseCombatEntity target, HitInfo info)
        {
            info.Initiator = fireball;
        }

        private void OnFireBallSpread(FireBall fireball, BaseEntity entity)
        {
            Fire.Spread(fireball, entity as FireBall);
        }

        private void OnFlameExplosion(FlameExplosive explosive, BaseEntity entity)
        {
            if(explosive.creatorEntity is BasePlayer)
            {
                var fire = entity as FireBall;

                var initiator = explosive.creatorEntity as BasePlayer;

                if(initiator.userID.IsSteamId() && (fire != null))
                {
                    Fire.Ignite(fire, initiator);
                }
            }
        }

        private void OnFlameThrowerBurn(FlameThrower flamethrower, BaseEntity entity)
        {
            var initiator = flamethrower.GetOwnerPlayer();

            if(initiator != null)
            {
                var fire = entity as FireBall;

                if(initiator.userID.IsSteamId() && (fire != null))
                {
                    Fire.Ignite(fire, initiator);
                }
            }
        }

        private void OnGroupPermissionGranted(string name, string perm)
        {
            if(Permissions.HasPrefix(perm))
            {
                foreach(var id in permission.GetUsersInGroup(name))
                {
                    var player = BasePlayer.FindAwakeOrSleeping(id);

                    if(player != null)
                    {
                        Permissions.Update(player.userID);
                    }
                }
            }
        }

        private void OnGroupPermissionRevoked(string name, string perm) => OnGroupPermissionGranted(name, perm);

        private void OnGuardianViolation(string playerid, Dictionary<string, string> details)
        {
            Discord.Send(details["category"], new Dictionary<string, object>
            {
                {
                    "embeds", new List<object>
                    {
                        new Dictionary<string, object>
                        {
                            { "color", int.Parse(details["color"]) },
                            { "description",
                                $"{details["actionicon"]} {details["action"]} [{details["playername"]}]" +
                                $"(https://steamcommunity.com/profiles/{playerid}) {playerid}\n" +
                                $"{details["categoryicon"]} {details["category"]} - {details["type"]}: {details["details"]}"
                            }
                        }
                    }
                }
            });
        }

        private void OnItemDropped(Item item, BaseEntity entity)
        {
            if(!config.AntiFlood.ItemDrop.Enabled)
            {
                return;
            }

            var player = item?.GetOwnerPlayer();

            if(User.ShouldIgnore(player))
            {
                return;
            }

            if(AntiFlood.ItemDrop.Trigger(player.userID, item.info.itemid))
            {
                entity?.Kill();
            }
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity target)
        {
            if(target is LootableCorpse)
            {
                User.OnLoot(looter, (target as LootableCorpse).playerSteamID);
            }
            else if(target is DroppedItemContainer)
            {
                User.OnLoot(looter, (target as DroppedItemContainer).playerSteamID);
            }
        }

        private void OnLootPlayer(BasePlayer looter, BasePlayer target) => User.OnLoot(looter, target.userID);

        private object OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            if(User.ShouldIgnore(player) || (info.Weapon == null))
            {
                return null;
            }

            if(info.IsProjectile())
            {
                AntiCheat.WallHack.Trigger(player, info);
            }
            else
            {
                AntiCheat.MeleeRate.Trigger(player, info);
            }


            return null;
        }

        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if(!config.AntiFlood.Chat.Enabled)
            {
                return null;
            }

            if(User.ShouldIgnore(player))
            {
                return null;
            }

            if(!AntiFlood.Chat.Trigger(player.userID))
            {
                return null;
            }

            Chat.Send(player, Key.Cooldown, new Dictionary<string, string>
            {
                { "cooldown", AntiFlood.Chat.Cooldown(player.userID).ToString() },
                { "type", Text.Get(Key.Chat) }
            });

            AntiFlood.Chat.Violation(player, Enum.GetName(typeof(ConVar.Chat.ChatChannel), channel));

            return true;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            User.OnConnected(player);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            User.OnDisconnected(player);
        }

        private object OnPlayerViolation(BasePlayer player, AntiHackType ahtype, float amount)
        {
            if(User.ShouldIgnore(player) || User.IsInactive(player))
            {
                return true;
            }

            if(ahtype == AntiHackType.FlyHack)
            {
                if(config.AntiCheat.Gravity.Enabled)
                {
                    NextFrame(() => AntiCheat.Gravity.Trigger(player, amount));

                    return true;
                }
            }
            else
            {
                if(config.AntiCheat.Server.Enabled)
                {
                    NextFrame(() => AntiCheat.Server.Trigger(player, ahtype, amount));

                    return true;
                }
            }

            return null;
        }

        private void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            if(User.ShouldIgnore(player))
            {
                return;
            }

            var projectile = player.GetActiveItem().GetHeldEntity() as BaseProjectile;

            if(projectile == null)
            {
                return;
            }

            var time = UnityEngine.Time.realtimeSinceStartup;

            var ammo = projectile.primaryMagazine.ammoType;

            var item = projectile.GetItem();

            var itemmod = ammo.GetComponent<ItemModProjectile>();

            var projectiles = Pool.Get<ProtoBuf.ProjectileShoot>();

            projectiles.ammoType    = ammo.itemid;
            projectiles.projectiles = Pool.Get<List<ProtoBuf.ProjectileShoot.Projectile>>();

            if((item?.info.shortname ?? string.Empty) != "pistol.eoka")
            {
                foreach(var fired in player.firedProjectiles)
                {
                    if((fired.Value.weaponSource as BaseProjectile) != projectile)
                    {
                        continue;
                    }

                    if((time - fired.Value.firedTime) > 0.01)
                    {
                        continue;
                    }

                    var entry = Pool.Get<ProtoBuf.ProjectileShoot.Projectile>();

                    entry.projectileID = fired.Key;
                    entry.startPos = fired.Value.initialPosition;
                    entry.startVel = fired.Value.initialVelocity;

                    projectiles.projectiles.Add(entry);
                }
            }

            OnWeaponFired(projectile, player, itemmod, projectiles);

            projectiles.ResetToPool();
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if(!config.AntiFlood.Command.Enabled)
            {
                return null;
            }

            var player = arg.Player();

            if(User.ShouldIgnore(player) || (arg.cmd.FullName == "craft.add"))
            {
                return null;
            }

            if(!AntiFlood.Command.Trigger(player.userID))
            {
                return null;
            }

            Chat.Send(player, Key.Cooldown, new Dictionary<string, string>
            {
                { "cooldown", AntiFlood.Command.Cooldown(player.userID).ToString() },
                { "type", Text.Get(Key.Command) }
            });

            AntiFlood.Command.Violation(player, arg.cmd.FullName);

            return true;
        }

        private void OnUserBanned(string playername, string playerid, string playerip, string reason)
        {
            ulong userid;

            if(ulong.TryParse(playerid, out userid))
            {
                if((userid != 0) && userid.IsSteamId())
                {
                    NextTick(() => User.OnBanned(userid, true));
                }
            }
        }

        private void OnUserPermissionGranted(string id, string perm)
        {
            if(Permissions.HasPrefix(perm))
            {
                var player = BasePlayer.FindAwakeOrSleeping(id);

                if(player != null)
                {
                    Permissions.Update(player.userID);
                }
            }
        }

        private void OnUserPermissionRevoked(string id, string perm) => OnUserPermissionGranted(id, perm);

        private void OnUserUnbanned(string playername, string playerid, string playerip)
        {
            ulong userid;

            if(ulong.TryParse(playerid, out userid))
            {
                if((userid != 0) && userid.IsSteamId())
                {
                    NextTick(() => User.OnBanned(userid, false));
                }
            }
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemmod, ProtoBuf.ProjectileShoot projectiles)
        {
            if(User.ShouldIgnore(player))
            {
                return;
            }

             AntiCheat.Recoil.Trigger(player, Weapon.Get(projectile, player, projectiles));
        }

        #endregion _hooks_other_

        #endregion _hooks_

        #region _ip_

        private class IP
        {
            public class Settings
            {
                public IpFilter    Filter;
                public IpViolation Violation;

                public Settings()
                {
                    Filter    = new IpFilter();
                    Violation = new IpViolation();
                }

                public class IpFilter
                {
                    public ulong Cooldown;

                    public IpFilter()
                    {
                        Cooldown = 30ul;
                    }

                    public void Validate()
                    {
                        Configuration.Clamp(ref Cooldown, 0ul, 60ul);
                    }
                }

                public class IpViolation
                {
                    public bool Ban;
                    public bool Enabled;

                    public IpViolation()
                    {
                        Ban     = false;
                        Enabled = true;
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref Filter,    () => new IpFilter(), () => Filter.Validate());
                    Configuration.Validate(ref Violation, () => new IpViolation());
                }
            }

            private static readonly DataFile<string, uint> allows = new DataFile<string, uint>("ip_allows");
            private static readonly DataFile<string, bool> blocks = new DataFile<string, bool>();
            private static readonly DataFile<string, uint> denies = new DataFile<string, uint>("ip_denies");

            private static readonly HashSet<ulong> empty = new HashSet<ulong>();

            private static readonly DataFile<string, DateTime> filter = new DataFile<string, DateTime>();

            private static TimeSpan filter_cooldown;

            private static readonly DataFile<string, HashSet<ulong>> users = new DataFile<string, HashSet<ulong>>("ip_users");

            private static readonly Violation violation = new Violation(Key.IP);

            public class NetworkInfo
            {
                public string Address { get; protected set; }
                public uint   Bits { get; protected set; }

                public NetworkInfo(string address, uint bits)
                {
                    Address = address;
                    Bits    = bits;
                }
            }

            private static uint Bits(string address)
            {
                uint bits = 0;

                var octets = address.Split('.');

                foreach(var octet in octets)
                {
                    if(octet == "*")
                    {
                        return bits;
                    }
                    else
                    {
                        bits += 8;
                    }
                }

                return bits;
            }

            public static void Block(NetworkInfo network)
            {
                foreach(var address in Match(network))
                {
                    if(!IsAllowed(address))
                    {
                        Block(address);
                    }
                }
            }

            public static void Block(string address, ulong userid = 0)
            {
                blocks[address] = true;

                if(userid != 0)
                {
                    Violation(address, userid);
                }

                _instance.timer.In(5.0f, () =>
                {
                    foreach(var entry in users[address])
                    {
                        if(!User.IsConnected(entry) || Permissions.Ignore(entry))
                        {
                            continue;
                        }

                        Violation(address, userid);
                    }
                });
            }

            public static void Bypass(NetworkInfo network)
            {
                foreach(var address in Match(network))
                {
                    blocks[address] = false;
                }
            }

            public static void Bypass(string address) => blocks[address] = false;

            private static uint Decimal(string address)
            {
                uint result = 0;

                if(!string.IsNullOrEmpty(address))
                {
                    var octets = address.Split('.');

                    if(octets.Length <= 4)
                    {
                        foreach(var octet in octets)
                        {
                            uint value;

                            if(uint.TryParse(octet, out value) && (value <= 255))
                            {
                                result = (result << 8) + value;
                            }
                            else
                            {
                                return 0;
                            }
                        }

                        if(octets.Length < 4)
                        {
                            result <<= ((4 - octets.Length) << 3);
                        }
                    }
                }

                return result;
            }

            public static bool Cooldown(string address)
            {
                if(config.IP.Filter.Cooldown == 0)
                {
                    return false;
                }

                var current = DateTime.UtcNow;
                var elapsed = current.Subtract(filter.Get(address, DateTime.MinValue));

                if(elapsed >= filter_cooldown)
                {
                    filter[address] = current;

                    return false;
                }

                return true;
            }

            public static void Configure()
            {
                config.IP.Filter.Validate();

                if(config.IP.Filter.Cooldown > 0)
                {
                    filter_cooldown = TimeSpan.FromSeconds(config.IP.Filter.Cooldown);
                }
                else
                {
                    filter_cooldown = TimeSpan.MinValue;
                }
            }

            public static bool Filter(string address, ulong userid)
            {
                if(blocks.Contains(address))
                {
                    if(blocks[address])
                    {
                        if(config.Log.IP.Filter)
                        {
                            Log.Console(Key.LogIpFilter, new Dictionary<string, string>
                            {
                                { "action", Text.Get(Key.Blocked) },
                                { "address", address },
                            });
                        }

                        Block(address, userid);

                        return false;
                    }
                }
                else if(IsDenied(address))
                {
                    if(!IsAllowed(address))
                    {
                        if(config.Log.IP.Filter)
                        {
                            Log.Console(Key.LogIpFilter, new Dictionary<string, string>
                            {
                                { "action", Text.Get(Key.Denied) },
                                { "address", address },
                            });
                        }

                        Block(address, userid);

                        return false;
                    }
                }

                if(config.Log.IP.Filter)
                {
                    Log.Console(Key.LogIpFilter, new Dictionary<string, string>
                    {
                        { "action", Text.Get(Key.Allowed) },
                        { "address", address },
                    });
                }

                return true;
            }

            public static HashSet<ulong> Find(string address)
            {
                if(users.Contains(address))
                {
                    return users[address];
                }

                return empty;
            }

            private static List<string> Get(DataFile<string, uint> data, string address)
            {
                bool all = (address == null);

                uint ip = all ? 0 : Decimal(address);

                var results = new List<string>();

                data.ForEach((network, bits) =>
                {
                    if(all || Match(ip, Decimal(network), bits))
                    {
                        results.Add($"{network}/{bits}");
                    }
                });

                return results;
            }

            public static List<string> GetAllows(string address = null) => Get(allows, address);

            public static List<string> GetDenies(string address = null) => Get(denies, address);

            public static bool IsAllowed(string address) => IsMatched(allows, address);

            public static bool IsBlocked(string address) => blocks.Get(address, false);

            public static bool IsDenied(string address) => IsMatched(denies, address);

            private static bool IsMatched(DataFile<string, uint> data, string address)
            {
                var ip = Decimal(address);

                bool match = false;

                data.ForEach((network, bits) =>
                {
                    if(!match)
                    {
                        match = Match(ip, Decimal(network), bits);
                    }
                });

                return match;
            }

            public static bool IsValid(string address, bool full = true, bool wildcard = false)
            {
                if(string.IsNullOrEmpty(address))
                {
                    return false;
                }

                var octets = address.Split('.');

                if(full ? (octets.Length != 4) : (octets.Length > 4))
                {
                    return false;
                }

                bool found_wildcard = false;

                foreach(var octet in octets)
                {
                    uint value;

                    if(octet == "*")
                    {
                        if(wildcard)
                        {
                            found_wildcard = true;
                        }
                        else
                        {
                            return false;
                        }
                    }
                    if(!uint.TryParse(octet, out value) || (value > 255) || found_wildcard)
                    {
                        return false;
                    }
                }

                return true;
            }

            public static void Load()
            {
                violation.Configure(new Violation.Settings(true, 3600), 1, 1, 1);

                allows.Load();
                denies.Load();

                users.Load();

                Configure();
            }

            private static bool Match(uint ip, uint network, uint bits)
            {
                bool match = false;

                if(bits == 0)
                {
                    match = true;
                }
                else
                {
                    var mask = uint.MaxValue << (32 - (int)bits);

                    if((ip & mask) == (network & mask))
                    {
                        match = true;
                    }
                }

                return match;
            }

            private static List<string> Match(NetworkInfo network)
            {
                var addresses = new List<string>();

                uint network_address = Decimal(network.Address);

                blocks.ForEach((address, blocked) =>
                {
                    if(Match(Decimal(address), network_address, network.Bits))
                    {
                        addresses.Add(address);
                    }
                });

                return addresses;
            }

            public static NetworkInfo Network(string address)
            {
                if(string.IsNullOrEmpty(address))
                {
                    return null;
                }

                uint bits = uint.MaxValue;

                var split = address.Split('/');

                if((split.Length == 1) && IsValid(split[0], false, true))
                {
                    bits = Bits(split[0]);
                }
                else if((split.Length == 2) && IsValid(split[0], false))
                {
                    if(!uint.TryParse(split[1], out bits))
                    {
                        bits = uint.MaxValue;
                    }
                }

                if(bits <= 32)
                {
                    var ip = Decimal(split[0].Replace('*', '0'));

                    var mask = uint.MaxValue << (32 - (int)bits);

                    return new NetworkInfo(ToString(ip & mask), bits);
                }

                return null;
            }

            public static string Parse(string address)
            {
                if(string.IsNullOrEmpty(address))
                {
                    return null;
                }

                int length = address.IndexOf(':');

                if(length > 0)
                {
                    return address.Substring(0, length);
                }

                if(IsValid(address))
                {
                    return address;
                }

                return null;
            }

            public static void Save()
            {
                allows.Save();
                denies.Save();

                users.Save();
            }

            private static bool Set(DataFile<string, uint> data, NetworkInfo network, bool add)
            {
                var matches = Get(data, network.Address);

                if(add)
                {
                    if(matches.Count == 0)
                    {
                        data[network.Address] = network.Bits;

                        return true;
                    }
                }
                else
                {
                    if(matches.Count > 0)
                    {
                        foreach(var match in matches)
                        {
                            data.Remove(match.Split('/')[0]);
                        }

                        return true;
                    }
                }

                return false;
            }

            public static bool SetAllow(NetworkInfo network, bool add) => Set(allows, network, add);

            public static bool SetDeny(NetworkInfo network, bool add) => Set(denies, network, add);

            public static string ToString(uint ip)
            {
                StringBuilder result = new StringBuilder(16);

                result.Append(((ip >> 24) & 255u).ToString()).Append('.');
                result.Append(((ip >> 16) & 255u).ToString()).Append('.');
                result.Append(((ip >>  8) & 255u).ToString()).Append('.');
                result.Append(( ip        & 255u).ToString());

                return result.ToString();
            }

            public static void Unblock(NetworkInfo network)
            {
                foreach(var address in Match(network))
                {
                    blocks.Remove(address);
                }
            }

            public static void Unblock(string address) => blocks.Remove(address);

            public static void Unload()
            {
                allows.Unload();
                blocks.Unload();
                denies.Unload();

                filter.Clear();

                users.Unload();

                violation.Clear();
            }

            public static void Update(string address, ulong userid)
            {
                if(!string.IsNullOrEmpty(address))
                {
                    if(!users.Contains(address))
                    {
                        users.Add(address, new HashSet<ulong>());
                    }

                    if(users[address].Add(userid))
                    {
                        users.SetDirty();
                    }
                }
            }

            private static void Violation(string address, ulong userid)
            {
                if(config.IP.Violation.Enabled)
                {
                    ulong violations = config.IP.Violation.Ban ? ulong.MaxValue : 1ul;

                    violation.Trigger(userid, Key.Blocked, address, violations, true);
                }
                else
                {
                    if(User.IsConnected(userid))
                    {
                        User.Kick(userid, Text.GetPlain(Key.IpBlocked));
                    }
                }
            }
        }

        #endregion _ip_

        #region _log_

        private new class Log
        {
            public class Settings
            {
                public LogAntiCheat  AntiCheat;
                public LogAntiFlood  AntiFlood;
                public LogIp         IP;
                public LogProjectile Projectile;
                public LogUser       User;
                public LogVpn        VPN;

                public Settings()
                {
                    AntiCheat  = new LogAntiCheat();
                    AntiFlood  = new LogAntiFlood();
                    IP         = new LogIp();
                    Projectile = new LogProjectile();
                    User       = new LogUser();
                    VPN        = new LogVpn();
                }

                public class LogAntiCheat
                {
                    public bool Aim;
                    public bool Gravity;
                    public bool MeleeRate;
                    public bool Recoil;
                    public bool Server;
                    public bool Stash;
                    public bool Trajectory;
                }

                public class LogAntiFlood
                {
                    public bool ItemDrop;
                }

                public class LogIp
                {
                    public bool Filter;

                    public LogIp()
                    {
                        Filter = true;
                    }
                }

                public class LogProjectile
                {
                    public bool Collapse;
                    public bool Verbose;

                    public LogProjectile()
                    {
                        Collapse = true;
                    }
                }

                public class LogUser
                {
                    public bool Bypass;
                    public bool Connect;

                    public LogUser()
                    {
                        Connect = true;
                    }
                }

                public class LogVpn
                {
                    public bool Check;

                    public LogVpn()
                    {
                        Check = true;
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref AntiCheat,  () => new LogAntiCheat());
                    Configuration.Validate(ref AntiFlood,  () => new LogAntiFlood());
                    Configuration.Validate(ref IP,         () => new LogIp());
                    Configuration.Validate(ref Projectile, () => new LogProjectile());
                    Configuration.Validate(ref User,       () => new LogUser());
                    Configuration.Validate(ref VPN,        () => new LogVpn());
                }
            }

            public static void Console(Key key, Dictionary<string, string> parameters = null)
            {
                _instance.Puts(Text.GetPlain(key, parameters));
            }

            public static void Error(string message)
            {
                _instance.LogError(message);
            }

            public static void Warning(string message)
            {
                _instance.LogWarning(message);
            }
        }

        #endregion _log_

        #region _map_

        private class Map
        {
            public class Building
            {
                public static bool HasPrivilege(DecayEntity entity) =>
                    entity.GetBuildingPrivilege() != null;

                public static bool InFoundation(Vector3 position)
                {
                    try
                    {
                        RaycastHit hit;

                        Physics.queriesHitBackfaces = true;

                        if(Physics.Raycast(position, Vector3.up, out hit, 4.5f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore))
                        {
                            var block = hit.GetEntity() as BuildingBlock;

                            if((block != null) && Hit.IsFoundation(hit))
                            {
                                switch(block.grade)
                                {
                                case BuildingGrade.Enum.Stone:
                                case BuildingGrade.Enum.Metal:
                                case BuildingGrade.Enum.TopTier:
                                    return true;
                                }
                            }
                        }
                    }
                    finally
                    {
                        Physics.queriesHitBackfaces = false;
                    }

                    return false;
                }

                public static bool IsNearby(Vector3 position, bool check_privilege = true)
                {
                    var blocks = Pool.GetList<BuildingBlock>();

                    Vis.Entities(position, 16.0f, blocks, Layers.Mask.Construction, QueryTriggerInteraction.Ignore);

                    bool nearby = false;

                    foreach(var block in blocks)
                    {
                        if(check_privilege)
                        {
                            if(HasPrivilege(block))
                            {
                                nearby = true; break;
                            }
                        }
                        else
                        {
                            nearby = true; break;
                        }
                    }

                    Pool.FreeList(ref blocks);

                    return nearby;
                }
            }

            public class Cave
            {
                public static bool IsInside(Vector3 position)
                {
                    foreach(var hit in Physics.RaycastAll(position, Vector3.up, 125f, Layers.Mask.World))
                    {
                        if(Hit.IsCave(hit) || Hit.IsRock(hit))
                        {
                            return true;
                        }
                    }

                    foreach(var hit in Physics.RaycastAll(position, Vector3.down, 125f, Layers.Mask.World))
                    {
                        if(Hit.IsCave(hit))
                        {
                            return true;
                        }
                    }

                    return false;
                }
            }

            public class Collider
            {
                public static string Info(Vector3 position)
                {
                    var colliders = new List<string>();

                    foreach(var hit in Physics.RaycastAll(position, Vector3.up, 50.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        colliders.Add($"{hit.collider.name} ({hit.distance}m)");
                    }

                    try
                    {
                        RaycastHit hit;

                        Physics.queriesHitBackfaces = true;

                        if(Physics.Raycast(new Vector3(position.x, position.y + 0.1f, position.z), Vector3.up, out hit, 4.5f, Layers.Mask.Construction, QueryTriggerInteraction.Ignore))
                        {
                            if(Hit.IsFoundation(hit))
                            {
                                colliders.Add($"foundation ({hit.distance}m)");
                            }
                        }
                    }
                    finally
                    {
                        Physics.queriesHitBackfaces = false;
                    }

                    var up = colliders.Count > 0 ? $"\nUp: {string.Join(", ", colliders)}" : string.Empty;

                    colliders.Clear();

                    foreach(var hit in Physics.RaycastAll(position, Vector3.down, 50.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        colliders.Add($"{hit.collider.name} ({hit.distance}m)");
                    }

                    var dn = colliders.Count > 0 ? $"\nDn: {string.Join(", ", colliders)}" : string.Empty;

                    return $"{up}{dn}";
                }
            }

            public class Entities
            {
                public static bool InRange(Vector3 position, float radius = 3.0f)
                {
                    var entities = Pool.GetList<DecayEntity>();

                    Vis.Entities(position, radius, entities);

                    bool nearby = entities.Count > 0;

                    Pool.FreeList(ref entities);

                    return nearby;
                }
            }

            public static string Grid(Vector3 position)
            {
                const double scale = 1.0 / 146.304;

                float normal = World.Size >> 1;

                if((Math.Abs(position.x) > normal) || (Math.Abs(position.z) > normal))
                {
                    return string.Empty;
                }

                int x = (int)((normal + position.x) * scale);
                int y = (int)((normal - position.z) * scale);

                int r, q = Math.DivRem(x, 26, out r);

                if(q > 0)
                {
                    return $"{Convert.ToChar(64 + q)}{Convert.ToChar(65 + r)}{y}";
                }
                else
                {
                    return $"{Convert.ToChar(65 + r)}{y}";
                }
            }

            private class Hit
            {
                private static string Collider(RaycastHit hit) =>
                    hit.collider?.name.ToLower() ?? string.Empty;

                public static bool IsBunker(RaycastHit hit) =>
                    IsBunker(Collider(hit));
                public static bool IsBunker(string collider) =>
                    collider.Contains("bunker.");

                public static bool IsCave(RaycastHit hit) =>
                    IsCave(Collider(hit));
                public static bool IsCave(string collider) =>
                    collider.Contains("cave_");

                public static bool IsCorridor(RaycastHit hit) =>
                    IsCorridor(Collider(hit));
                public static bool IsCorridor(string collider) =>
                    collider.Contains("corridor_");

                public static bool IsDuct(RaycastHit hit) =>
                    IsDuct(Collider(hit));
                public static bool IsDuct(string collider) =>
                    collider.Contains("duct_");

                public static bool IsFoundation(RaycastHit hit) =>
                    IsFoundation(Collider(hit));
                public static bool IsFoundation(string collider) =>
                    collider.Contains("foundation.");

                public static bool IsMine(RaycastHit hit) =>
                    IsMine(Collider(hit));
                public static bool IsMine(string collider) =>
                    collider.Contains("mine_tnl_");

                public static bool IsRoad(RaycastHit hit) =>
                    IsRoad(Collider(hit));
                public static bool IsRoad(string collider) =>
                    collider.Contains("road");

                public static bool IsRock(RaycastHit hit) =>
                    IsRock(Collider(hit));
                public static bool IsRock(string collider) =>
                    collider.Contains("rock_");

                public static bool IsStairwell(RaycastHit hit) =>
                    IsStairwell(Collider(hit));
                public static bool IsStairwell(string collider) =>
                    collider.Contains("stairwell_");

                public static bool IsTunnel(RaycastHit hit) =>
                    IsTunnel(Collider(hit));
                public static bool IsTunnel(string collider) =>
                    collider.Contains("tunnel");

                public static bool IsUnderground(RaycastHit hit) =>
                    IsUnderground(Collider(hit));
                public static bool IsUnderground(string collider)
                {
                    foreach(var partition in collider.Split('_', '.'))
                    {
                        switch(partition)
                        {
                        case "bunker":
                        case "corridor":
                        case "duct":
                        case "mine":
                        case "stairwell":
                        case "tunnel":
                            return true;
                        }
                    }

                    return false;
                }
            }

            public static bool InRange(Vector3 a, Vector3 b, float distance) =>
                (a - b).sqrMagnitude <= distance * distance;
            public static bool InRange2D(Vector3 a, Vector3 b, float distance) =>
                InRange(new Vector3(a.x, 0f, a.z), new Vector3(b.x, 0f, b.z), distance);

            public static void Load()
            {
                _instance.timer.In(0.1f, () => Monument.Load());
            }

            public class Monument
            {
                private static SparseMap global = new SparseMap(4.0f);
                private static SparseMap tunnel = new SparseMap(4.0f);

                public static bool IsNearby(Vector3 position) =>
                    global.Test(position);

                public static bool IsTunnel(Vector3 position) =>
                    tunnel.Test(position);

                public static void Load()
                {
                    foreach(var monument in TerrainMeta.Path.Monuments)
                    {
                        var center = monument.transform.position;
                        var radius = Range(monument);

                        global.Set(center, radius);

                        if(monument.name.Contains("entrance"))
                        {
                            tunnel.Set(center, radius);
                        }
                    }
                }

                private static float Range(MonumentInfo monument)
                {
                    var separator = monument.name.LastIndexOf('/');

                    switch((separator > 0) ? monument.name.Substring(separator + 1).Replace(".prefab", "") : monument.name)
                    {
                    case "airfield_1":              return 255f;
                    case "bandit_town":             return 105f;
                    case "cave_large_hard":
                    case "cave_large_medium":
                    case "cave_large_sewers_hard":
                    case "cave_medium_easy":
                    case "cave_medium_hard":
                    case "cave_medium_medium":
                    case "cave_small_easy":
                    case "cave_small_hard":
                    case "cave_small_medium":       return  75f;
                    case "compound":                return 255f;
                    case "entrance":                return  20f;
                    case "excavator_1":             return 150f;
                    case "fishing_village_a":
                    case "fishing_village_b":
                    case "fishing_village_c":       return  55f;
                    case "gas_station_1":           return  60f;
                    case "harbor_1":
                    case "harbor_2":                return 135f;
                    case "junkyard_1":              return 105f;
                    case "launch_site_1":           return 245f;
                    case "lighthouse":              return  50f;
                    case "military_tunnel_1":       return 105f;
                    case "mining_quarry_a":
                    case "mining_quarry_b":
                    case "mining_quarry_c":         return  30f;
                    case "OilrigAI":                return 100f;
                    case "OilrigAI2":               return 200f;
                    case "power_sub_big_1":
                    case "power_sub_big_2":         return  30f;
                    case "power_sub_small_1":
                    case "power_sub_small_2":       return  25f;
                    case "powerplant_1":            return 145f;
                    case "radtown_small_3":         return  95f;
                    case "satellite_dish":          return  85f;
                    case "sphere_tank":             return  75f;
                    case "stables_a":
                    case "stables_b":               return  80f;
                    case "supermarket_1":           return  60f;
                    case "swamp_a":
                    case "swamp_b":                 return  30f;
                    case "swamp_c":                 return  55f;
                    case "trainyard_1":             return 145f;
                    case "warehouse":               return  50f;
                    case "water_treatment_plant_1": return 175f;
                    case "water_well_a":
                    case "water_well_b":
                    case "water_well_c":
                    case "water_well_d":
                    case "water_well_e":            return  30f;
                    }

                    return 50.0f;
                }

                public static void Unload()
                {
                    global.Clear();
                    tunnel.Clear();
                }
            }

            public class Position
            {
                [Flags]
                public enum Check : ulong
                {
                    None     =  0ul,
                    Building =  1ul,
                    Entities =  1ul << 1,
                    Monument =  1ul << 2,
                    Road     =  1ul << 3,
                    Terrain  =  1ul << 4,
                    Water    =  1ul << 5,
                    All      = ~0ul
                }

                private static bool HasCheck(Check checks, Check check) =>
                    (checks & check) == check;

                public static Vector3 Random(Check checks = Check.All)
                {
                    var max = (float)(World.Size >> 1);
                    var min = -max;

                    Vector3 position;

                    do
                    {
                        position = Surface(Random(min, max, min, max));

                        if(HasCheck(checks, Check.Terrain))
                        {
                            if(!Terrain.IsSurface(position))
                            {
                                continue;
                            }
                        }
                        else if(HasCheck(checks, Check.Water) && !Water.IsSurface(position))
                        {
                            continue;
                        }

                        if(HasCheck(checks, Check.Monument) && Monument.IsNearby(position))
                        {
                            continue;
                        }

                        if(HasCheck(checks, Check.Road) && Road.IsNearby(position))
                        {
                            continue;
                        }

                        if(HasCheck(checks, Check.Building) && Building.IsNearby(position))
                        {
                            continue;
                        }

                        if(HasCheck(checks, Check.Entities) && Entities.InRange(position))
                        {
                            continue;
                        }
                    }
                    while(Rock.IsInside(position));

                    return position;
                }
                private static Vector3 Random(float min_x, float max_x, float min_z, float max_z) =>
                    new Vector3(Core.Random.Range(min_x, max_x), 0.0f, Core.Random.Range(min_z, max_z));
            }

            public class Road
            {
                public static bool IsNearby(Vector3 position)
                {
                    position = Terrain.Level(position, 0.5f);

                    foreach(var hit in Physics.RaycastAll(position, Vector3.down, 25.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        if(Hit.IsRoad(hit))
                        {
                            return true;
                        }
                    }

                    return false;
                }
            }

            public class Rock
            {
                public static bool IsInside(Vector3 position, bool check_cave = true)
                {
                    if(check_cave && Cave.IsInside(position))
                    {
                        return false;
                    }

                    try
                    {
                        RaycastHit hit;

                        Physics.queriesHitBackfaces = true;

                        if(Physics.Raycast(position, Vector3.up, out hit, 25.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                        {
                            return Hit.IsRock(hit);
                        }
                    }
                    finally
                    {
                        Physics.queriesHitBackfaces = false;
                    }

                    return false;
                }
            }

            public static Vector3 Surface(Vector3 position, float offset = 0.0f) =>
                Terrain.IsSurface(position) ? Terrain.Level(position, offset) : Water.Level(position, offset);

            public class Terrain
            {
                public static float Height(Vector3 position) =>
                    TerrainMeta.HeightMap.GetHeight(position);

                public static bool IsInside(Vector3 position, bool check_cave = true)
                {
                    var elevation = Height(position);

                    if((elevation - 1.0f) > position.y)
                    {
                        float c_x = position.x + 1.0f, f_x = position.x - 1.0f;
                        float c_z = position.z + 1.0f, f_z = position.z - 1.0f;

                        elevation = Math.Min(elevation, Height(new Vector3(c_x, 0, c_z)));
                        elevation = Math.Min(elevation, Height(new Vector3(c_x, 0, f_z)));
                        elevation = Math.Min(elevation, Height(new Vector3(f_x, 0, c_z)));
                        elevation = Math.Min(elevation, Height(new Vector3(f_x, 0, f_z)));

                        if((elevation - 1.0f) > position.y)
                        {
                            if(check_cave && Cave.IsInside(position))
                            {
                                return false;
                            }
                            else if(Underground.IsInside(position))
                            {
                                return false;
                            }
                            else if(Monument.IsNearby(position))
                            {
                                return (elevation - 51.0f) > position.y;
                            }

                            return true;
                        }
                    }

                    return false;
                }

                public static bool IsSurface(Vector3 position) =>
                    Height(position) > Water.Height(position);

                public static Vector3 Level(Vector3 position, float offset = 0.0f) =>
                    new Vector3(position.x, Height(position) + offset, position.z);
            }

            public class Underground
            {
                public static bool IsInside(Vector3 position)
                {
                    if(Monument.IsTunnel(position))
                    {
                        return true;
                    }

                    foreach(var hit in Physics.RaycastAll(position, Vector3.up, 25.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        if(Hit.IsUnderground(hit))
                        {
                            return true;
                        }
                    }

                    foreach(var hit in Physics.RaycastAll(position, Vector3.down, 25.0f, Layers.Mask.World, QueryTriggerInteraction.Ignore))
                    {
                        if(Hit.IsUnderground(hit))
                        {
                            return true;
                        }
                    }

                    return false;
                }
            }

            public static void Unload() => Monument.Unload();

            public class Water
            {
                public static float Height(Vector3 position) =>
                    TerrainMeta.WaterMap.GetHeight(position);

                public static bool IsSurface(Vector3 position) =>
                    Height(position) > Terrain.Height(position);

                public static Vector3 Level(Vector3 position, float offset = 0.0f) =>
                    new Vector3(position.x, Height(position) + offset, position.z);
            }
        }

        #endregion _map_

        #region _permissions_

        private class Permissions
        {
            private static string PERMISSION_ADMIN;
            private static string PERMISSION_ALL;
            private static string PERMISSION_IGNORE;
            private static string PERMISSION_PREFIX;

            private static readonly HashSet<ulong> all      = new HashSet<ulong>();
            private static readonly HashSet<ulong> admin    = new HashSet<ulong>();
            private static readonly HashSet<ulong> ignore   = new HashSet<ulong>();

            public static bool Admin(ulong userid, bool forced = false) =>
                (forced ? HasPermission(userid, PERMISSION_ADMIN) : admin.Contains(userid)) || All(userid, forced);

            public static bool All(ulong userid, bool forced = false) =>
                (forced ? HasPermission(userid, PERMISSION_ALL) : all.Contains(userid));

            public class Bypass
            {
                private static string PERMISSION_PREFIX;
                private static string PERMISSION_STEAM;
                private static string PERMISSION_VPN;

                private static readonly HashSet<ulong> steam = new HashSet<ulong>();
                private static readonly HashSet<ulong> vpn   = new HashSet<ulong>();

                public class AntiCheat
                {
                    private static readonly HashSet<ulong> aim        = new HashSet<ulong>();
                    private static readonly HashSet<ulong> firerate   = new HashSet<ulong>();
                    private static readonly HashSet<ulong> gravity    = new HashSet<ulong>();
                    private static readonly HashSet<ulong> meleerate  = new HashSet<ulong>();
                    private static readonly HashSet<ulong> recoil     = new HashSet<ulong>();
                    private static readonly HashSet<ulong> server     = new HashSet<ulong>();
                    private static readonly HashSet<ulong> stash      = new HashSet<ulong>();
                    private static readonly HashSet<ulong> trajectory = new HashSet<ulong>();
                    private static readonly HashSet<ulong> wallhack   = new HashSet<ulong>();

                    private static string PERMISSION_AIM;
                    private static string PERMISSION_FIRERATE;
                    private static string PERMISSION_GRAVITY;
                    private static string PERMISSION_MELEERATE;
                    private static string PERMISSION_PREFIX;
                    private static string PERMISSION_RECOIL;
                    private static string PERMISSION_SERVER;
                    private static string PERMISSION_STASH;
                    private static string PERMISSION_TRAJECTORY;
                    private static string PERMISSION_WALLHACK;

                    public static void Load()
                    {
                        PERMISSION_PREFIX = Bypass.PERMISSION_PREFIX + "anticheat.";

                        PERMISSION_AIM        = PERMISSION_PREFIX + "aim";
                        PERMISSION_FIRERATE   = PERMISSION_PREFIX + "firerate";
                        PERMISSION_GRAVITY    = PERMISSION_PREFIX + "gravity";
                        PERMISSION_MELEERATE  = PERMISSION_PREFIX + "meleerate";
                        PERMISSION_RECOIL     = PERMISSION_PREFIX + "recoil";
                        PERMISSION_SERVER     = PERMISSION_PREFIX + "server";
                        PERMISSION_STASH      = PERMISSION_PREFIX + "stash";
                        PERMISSION_TRAJECTORY = PERMISSION_PREFIX + "trajectory";
                        PERMISSION_WALLHACK   = PERMISSION_PREFIX + "wallhack";

                        _instance.permission.RegisterPermission(PERMISSION_AIM,        _instance);
                        _instance.permission.RegisterPermission(PERMISSION_FIRERATE,   _instance);
                        _instance.permission.RegisterPermission(PERMISSION_GRAVITY,    _instance);
                        _instance.permission.RegisterPermission(PERMISSION_MELEERATE,  _instance);
                        _instance.permission.RegisterPermission(PERMISSION_RECOIL,     _instance);
                        _instance.permission.RegisterPermission(PERMISSION_SERVER,     _instance);
                        _instance.permission.RegisterPermission(PERMISSION_STASH,      _instance);
                        _instance.permission.RegisterPermission(PERMISSION_TRAJECTORY, _instance);
                        _instance.permission.RegisterPermission(PERMISSION_WALLHACK,   _instance);
                    }

                    public static bool Aim(ulong userid, bool forced = false) =>
                       (forced ? HasPermission(userid, PERMISSION_AIM) : aim.Contains(userid)) || All(userid, forced);

                    public static bool FireRate(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_FIRERATE) : firerate.Contains(userid)) || All(userid, forced);

                    public static bool Gravity(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_GRAVITY) : gravity.Contains(userid)) || All(userid, forced);

                    public static bool MeleeRate(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_MELEERATE) : meleerate.Contains(userid)) || All(userid, forced);

                    public static bool Recoil(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_RECOIL) : recoil.Contains(userid)) || All(userid, forced);

                    public static void Reset(ulong userid)
                    {
                        aim.Remove(userid);
                        firerate.Remove(userid);
                        gravity.Remove(userid);
                        meleerate.Remove(userid);
                        recoil.Remove(userid);
                        server.Remove(userid);
                        stash.Remove(userid);
                        trajectory.Remove(userid);
                        wallhack.Remove(userid);
                    }

                    public static bool Server(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_SERVER) : server.Contains(userid)) || All(userid, forced);

                    public static bool Stash(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_STASH) : stash.Contains(userid)) || All(userid, forced);

                    public static bool Trajectory(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_TRAJECTORY) : trajectory.Contains(userid)) || All(userid, forced);

                    public static void Unload()
                    {
                        PERMISSION_AIM = null;
                        PERMISSION_FIRERATE = null;
                        PERMISSION_GRAVITY = null;
                        PERMISSION_MELEERATE = null;
                        PERMISSION_PREFIX = null;
                        PERMISSION_RECOIL = null;
                        PERMISSION_SERVER = null;
                        PERMISSION_STASH = null;
                        PERMISSION_TRAJECTORY = null;
                        PERMISSION_WALLHACK = null;

                        aim.Clear();
                        firerate.Clear();
                        gravity.Clear();
                        meleerate.Clear();
                        recoil.Clear();
                        server.Clear();
                        stash.Clear();
                        trajectory.Clear();
                        wallhack.Clear();
                    }

                    public static void Update(ulong userid)
                    {
                        if(!userid.IsSteamId())
                        {
                            return;
                        }

                        Permissions.Update(userid, PERMISSION_AIM,        aim);
                        Permissions.Update(userid, PERMISSION_FIRERATE,   firerate);
                        Permissions.Update(userid, PERMISSION_GRAVITY,    gravity);
                        Permissions.Update(userid, PERMISSION_MELEERATE,  meleerate);
                        Permissions.Update(userid, PERMISSION_RECOIL,     recoil);
                        Permissions.Update(userid, PERMISSION_SERVER,     server);
                        Permissions.Update(userid, PERMISSION_STASH,      stash);
                        Permissions.Update(userid, PERMISSION_TRAJECTORY, trajectory);
                        Permissions.Update(userid, PERMISSION_WALLHACK,   wallhack);
                    }

                    public static bool WallHack(ulong userid, bool forced = false) =>
                        (forced ? HasPermission(userid, PERMISSION_WALLHACK) : wallhack.Contains(userid)) || All(userid, forced);
                }

                public static void Load()
                {
                    PERMISSION_PREFIX = Permissions.PERMISSION_PREFIX + "bypass.";

                    PERMISSION_STEAM = PERMISSION_PREFIX + "steam";
                    PERMISSION_VPN   = PERMISSION_PREFIX + "vpn";

                    _instance.permission.RegisterPermission(PERMISSION_STEAM, _instance);
                    _instance.permission.RegisterPermission(PERMISSION_VPN,   _instance);

                    AntiCheat.Load();
                }

                public static void Reset(ulong userid)
                {
                    steam.Remove(userid);
                    vpn.Remove(userid);

                    AntiCheat.Reset(userid);
                }

                public static bool Steam(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_STEAM) : steam.Contains(userid)) || All(userid, forced);

                public static void Unload()
                {
                    PERMISSION_PREFIX = null;
                    PERMISSION_STEAM  = null;
                    PERMISSION_VPN    = null;

                    steam.Clear();
                    vpn.Clear();

                    AntiCheat.Unload();
                }

                public static void Update(ulong userid)
                {
                    Permissions.Update(userid, PERMISSION_STEAM, vpn);
                    Permissions.Update(userid, PERMISSION_VPN,   vpn);

                    AntiCheat.Update(userid);
                }

                public static bool Vpn(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_VPN) : vpn.Contains(userid)) || All(userid, forced);
            }

            public class Command
            {
                private static readonly HashSet<ulong> config = new HashSet<ulong>();
                private static readonly HashSet<ulong> ip     = new HashSet<ulong>();
                private static readonly HashSet<ulong> server = new HashSet<ulong>();
                private static readonly HashSet<ulong> tp     = new HashSet<ulong>();
                private static readonly HashSet<ulong> vpn    = new HashSet<ulong>();

                private static string PERMISSION_CONFIG;
                private static string PERMISSION_IP;
                private static string PERMISSION_PREFIX;
                private static string PERMISSION_SERVER;
                private static string PERMISSION_TP;
                private static string PERMISSION_VPN;

                public static void Load()
                {
                    PERMISSION_PREFIX = Permissions.PERMISSION_PREFIX + "command.";

                    PERMISSION_CONFIG = PERMISSION_PREFIX + "config";
                    PERMISSION_IP     = PERMISSION_PREFIX + "ip";
                    PERMISSION_SERVER = PERMISSION_PREFIX + "server";
                    PERMISSION_TP     = PERMISSION_PREFIX + "teleport";
                    PERMISSION_VPN    = PERMISSION_PREFIX + "vpn";

                    _instance.permission.RegisterPermission(PERMISSION_CONFIG, _instance);
                    _instance.permission.RegisterPermission(PERMISSION_IP,     _instance);
                    _instance.permission.RegisterPermission(PERMISSION_SERVER, _instance);
                    _instance.permission.RegisterPermission(PERMISSION_TP,     _instance);
                    _instance.permission.RegisterPermission(PERMISSION_VPN,    _instance);
                }

                public static bool Config(ulong userid, bool forced = false) =>
                   (forced ? HasPermission(userid, PERMISSION_CONFIG) : config.Contains(userid)) || All(userid, forced);

                public static bool Ip(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_IP) : ip.Contains(userid)) || All(userid, forced);

                public static void Reset(ulong userid)
                {
                    config.Remove(userid);
                    ip.Remove(userid);
                    server.Remove(userid);
                    tp.Remove(userid);
                    vpn.Remove(userid);
                }

                public static bool Server(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_SERVER) : server.Contains(userid)) || All(userid, forced);

                public static bool Tp(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_SERVER) : server.Contains(userid)) || All(userid, forced);

                public static void Unload()
                {
                    PERMISSION_CONFIG = null;
                    PERMISSION_IP     = null;
                    PERMISSION_PREFIX = null;
                    PERMISSION_SERVER = null;
                    PERMISSION_TP     = null;
                    PERMISSION_VPN    = null;

                    config.Clear();
                    ip.Clear();
                    server.Clear();
                    tp.Clear();
                    vpn.Clear();
                }

                public static void Update(ulong userid)
                {
                    Permissions.Update(userid, PERMISSION_CONFIG, config);
                    Permissions.Update(userid, PERMISSION_IP,     ip);
                    Permissions.Update(userid, PERMISSION_SERVER, server);
                    Permissions.Update(userid, PERMISSION_TP,     tp);
                    Permissions.Update(userid, PERMISSION_VPN,    vpn);
                }

                public static bool Vpn(ulong userid, bool forced = false) =>
                    (forced ? HasPermission(userid, PERMISSION_VPN) : vpn.Contains(userid)) || All(userid, forced);
            }

            public static string[] Groups(ulong userid) =>
                _instance.permission.GetUserGroups(userid.ToString());

            private static bool HasPermission(ulong userid, string permission) =>
                _instance.permission.UserHasPermission(userid.ToString(), permission);

            public static bool HasPrefix(string permission) =>
                permission.StartsWith(PERMISSION_PREFIX);

            public static bool Ignore(ulong userid, bool forced = false) =>
                (forced ? HasPermission(userid, PERMISSION_IGNORE) : ignore.Contains(userid)) || All(userid, forced);

            public static void Load()
            {
                PERMISSION_PREFIX = _instance.Name.ToLower() + ".";

                PERMISSION_ALL      = PERMISSION_PREFIX + "all";
                PERMISSION_ADMIN    = PERMISSION_PREFIX + "admin";
                PERMISSION_IGNORE   = PERMISSION_PREFIX + "ignore";

                _instance.permission.RegisterPermission(PERMISSION_ALL,    _instance);
                _instance.permission.RegisterPermission(PERMISSION_ADMIN,  _instance);
                _instance.permission.RegisterPermission(PERMISSION_IGNORE, _instance);

                Bypass.Load();
                Command.Load();
            }

            public static void Reset(ulong userid)
            {
                all.Remove(userid);
                admin.Remove(userid);
                ignore.Remove(userid);

                Bypass.Reset(userid);
                Command.Reset(userid);
            }

            public static void Unload()
            {
                PERMISSION_ALL      = null;
                PERMISSION_ADMIN    = null;
                PERMISSION_IGNORE   = null;
                PERMISSION_PREFIX   = null;

                all.Clear();
                admin.Clear();
                ignore.Clear();

                Bypass.Unload();
                Command.Unload();
            }

            public static void Update(ulong userid)
            {
                if(!userid.IsSteamId())
                {
                    return;
                }

                Update(userid, PERMISSION_ALL,    all);
                Update(userid, PERMISSION_ADMIN,  admin);
                Update(userid, PERMISSION_IGNORE, ignore);

                Bypass.Update(userid);
                Command.Update(userid);
            }

            private static bool Update(ulong userid, string permission, HashSet<ulong> cache) =>
                HasPermission(userid, permission) ? cache.Add(userid) : cache.Remove(userid);
        }

        #endregion _permissions_

        #region _projectile_

        private class Projectile
        {
            public class Log
            {
                private static readonly Queue<Entry>                              expired = new Queue<Entry>();
                private static readonly Dictionary<ulong, Queue<Entry>>           history = new Dictionary<ulong, Queue<Entry>>();
                private static readonly Dictionary<ulong, Dictionary<int, Entry>> pending = new Dictionary<ulong, Dictionary<int, Entry>>();
                private static readonly Queue<Request>                            request = new Queue<Request>();
                private static readonly Queue<Entry>                              reserve = new Queue<Entry>();

                static readonly StringBuilder buffer = new StringBuilder();

                private class Entry
                {
                    public float    aim_angle;
                    public float    aim_pvp;
                    public float    aim_range;
                    public ulong    aim_violations;
                    public string   attacker;
                    public ulong    attacker_id;
                    public ulong    firerate_violations;
                    public float    hit_distance;
                    public HitArea  hit_location;
                    public bool     pvp;
                    public float    recoil_pitch;
                    public ulong    recoil_repeats;
                    public float    recoil_swing;
                    public ulong    recoil_violations;
                    public float    recoil_yaw;
                    public bool     ricochet;
                    public float    speed;
                    public DateTime timestamp;
                    public float    trajectory;
                    public ulong    trajectory_violations;
                    public string   victim;
                    public bool     violations;
                    public ulong    wallhack_violations;
                    public string   weapon;

                    private static readonly Queue<Entry> pool = new Queue<Entry>();

                    private Entry(DateTime timestamp)
                    {
                        Default().Set(timestamp);
                    }

                    private Entry Default()
                    {
                        aim_angle = 1;
                        aim_pvp = 1;
                        aim_range = 1;
                        aim_violations = 0;
                        attacker = null;
                        attacker_id = 0;
                        firerate_violations = 0;
                        hit_distance = 0;
                        hit_location = 0;
                        pvp = false;
                        recoil_pitch = 1;
                        recoil_repeats = 0;
                        recoil_swing = 0;
                        recoil_violations = 0;
                        recoil_yaw = 1;
                        speed = 0;
                        trajectory = 1;
                        trajectory_violations = 0;
                        victim = null;
                        violations = false;
                        wallhack_violations = 0;
                        weapon = null;

                        return this;
                    }

                    public string Format(bool collapse, bool id, bool time)
                    {
                        buffer.Clear();

                        if(time)
                        {
                            var delta = DateTime.UtcNow.Subtract(timestamp);

                            buffer.Append(((int)delta.TotalSeconds).ToString("D5")).Append('.').Append((delta.Milliseconds / 10).ToString("D2")).Append("s ");
                        }

                        buffer.Append("Recoil[").Append(recoil_repeats.ToString("D2"));
                        buffer.Append("](x=").Append(recoil_yaw.ToString("F6"));
                        buffer.Append(", y=").Append(recoil_pitch.ToString("F6"));
                        buffer.Append(", a=").Append(recoil_swing.ToString("F1"));
                        buffer.Append(')');

                        if(!(collapse && string.IsNullOrEmpty(victim)))
                        {
                            buffer.Append(" Trajectory(").Append(trajectory.ToString("F6")).Append(')');

                            buffer.Append(" Aim(a=").Append(aim_angle.ToString("F6")).Append(", p=").Append(aim_pvp.ToString("F6")).Append(", r=").Append(aim_range.ToString("F6")).Append(')');
                        }

                        if(id)
                        {
                            buffer.Append(' ').Append(attacker).Append('[').Append(attacker_id.ToString()).Append(']');
                        }

                        buffer.Append(" (").Append(speed.ToString("F1")).Append("m/s, ").Append(weapon).Append(')');

                        if(victim != null)
                        {
                            buffer.Append(": ").Append(victim).Append('[').Append(Text.BodyPart(hit_location)).Append(", ").Append(hit_distance.ToString("F1")).Append("m]");
                        }

                        if(violations)
                        {
                            buffer.Append(' ');

                            if(       aim_violations > 0) buffer.Append("[A]");
                            if(  firerate_violations > 0) buffer.Append("[F]");
                            if(    recoil_violations > 0) buffer.Append("[R]");
                            if(trajectory_violations > 0) buffer.Append("[T]");
                            if(  wallhack_violations > 0) buffer.Append("[W]");
                        }

                        return buffer.ToString();
                    }

                    public static Entry Get(DateTime timestamp) => (pool.Count > 0) ? pool.Dequeue().Set(timestamp) : new Entry(timestamp);

                    public void Release() => pool.Enqueue(Default());

                    private Entry Set(DateTime timestamp)
                    {
                        this.timestamp = timestamp;

                        return this;
                    }

                    public static void Unload() => pool.Clear();
                }

                private class Request
                {
                    public IPlayer actor;
                    public int     lines;
                    public ulong   userid;
                }

                public static void Add(Weapon weapon)
                {
                    Dictionary<int, Entry> _pending;

                    if(!pending.TryGetValue(weapon.Player.userID, out _pending))
                    {
                        pending.Add(weapon.Player.userID, _pending = new Dictionary<int, Entry>());
                    }

                    foreach(var projectileid in weapon.Projectiles)
                    {
                        try
                        {
                            _pending.Add(projectileid, Entry.Get(weapon.Fired));
                        }
                        catch(Exception e)
                        {
                            Guardian.Log.Warning($"Projectile.Log.Add({projectileid}): {weapon.Name}({e.Message})");
                        }
                    }
                }

                public static void Expire(Weapon weapon)
                {
                    Dictionary<int, Entry> _pending;

                    if(pending.TryGetValue(weapon.Player.userID, out _pending))
                    {
                        foreach(var projectileid in weapon.Projectiles)
                        {
                            Entry entry;

                            if(_pending.TryGetValue(projectileid, out entry))
                            {
                                _pending.Remove(projectileid);

                                if(config.Log.Projectile.Verbose || entry.violations || (entry.victim != null) || (weapon.Projectiles.Count == 1))
                                {
                                    reserve.Enqueue(entry);
                                }
                                else
                                {
                                    expired.Enqueue(entry);
                                }
                            }
                        }

                        while(expired.Count > 0)
                        {
                            expired.Dequeue().Release();
                        }

                        Queue<Entry> _history;

                        if(!history.TryGetValue(weapon.Player.userID, out _history))
                        {
                            history.Add(weapon.Player.userID, _history = new Queue<Entry>());
                        }

                        while(reserve.Count > 0)
                        {
                            if(_history.Count > 64)
                            {
                                _history.Dequeue().Release();
                            }

                            _history.Enqueue(reserve.Dequeue());
                        }
                    }
                }

                public static void Get(IPlayer actor, ulong userid, int lines)
                {
                    request.Enqueue(new Request { actor = actor, lines = lines, userid = userid });
                }

                public static float GetAimAngle(ulong userid, int id)
                {
                    var aim_angle = 0.0f;

                    TrySetEntry(userid, id, entry =>
                    {
                        aim_angle = entry.aim_angle;
                    });

                    return aim_angle;
                }

                public static bool GetAimPvp(ulong userid, int id)
                {
                    var pvp = false;

                    TrySetEntry(userid, id, entry =>
                    {
                        pvp = entry.pvp;
                    });

                    return pvp;
                }

                public static float GetHitDistance(ulong userid, int id)
                {
                    var hit_distance = 0.0f;

                    TrySetEntry(userid, id, entry =>
                    {
                        hit_distance = entry.hit_distance;
                    });

                    return hit_distance;
                }

                public static HitArea GetHitLocation(ulong userid, int id)
                {
                    var hit_location = (HitArea)0;

                    TrySetEntry(userid, id, entry =>
                    {
                        hit_location = entry.hit_location;
                    });

                    return hit_location;
                }

                public static bool GetRicochet(ulong userid, int id)
                {
                    var ricochet = false;

                    TrySetEntry(userid, id, entry =>
                    {
                        ricochet = entry.ricochet;
                    });

                    return ricochet;
                }

                public static string GetVictim(ulong userid, int id)
                {
                    var victim = string.Empty;

                    TrySetEntry(userid, id, entry =>
                    {
                        victim = entry.victim;
                    });

                    return victim;
                }

                public static void Send()
                {
                    if(request.Count == 0)
                    {
                        return;
                    }

                    var send = request.Dequeue();

                    Queue<Entry> _history;

                    if(!history.TryGetValue(send.userid, out _history) || (_history.Count == 0))
                    {
                        Chat.Reply(send.actor, Key.CommandLogNoEntries, new Dictionary<string, string>
                        {
                            { "playerid", send.userid.ToString() },
                            { "playername", Text.Sanitize(User.Name(send.userid)) }
                        });

                        return;
                    }

                    if(send.actor.LastCommand == CommandType.Chat)
                    {
                        Chat.Reply(send.actor, Key.CommandLogSeeConsole);

                        send.actor.LastCommand = CommandType.Console;
                    }

                    Chat.Reply(send.actor, Key.CommandLogHeading, new Dictionary<string, string>
                    {
                        { "playerid", send.userid.ToString() },
                        { "playername", Text.Sanitize(User.Name(send.userid)) }
                    });

                    var skip = (_history.Count > send.lines) ? (_history.Count - send.lines) : 0;

                    foreach(var entry in _history)
                    {
                        if(skip > 0)
                        {
                            --skip; continue;
                        }

                        Chat.Reply(send.actor, Key.CommandLogLine, new Dictionary<string, string>
                        {
                            { "info", entry.Format(config.Log.Projectile.Collapse, false, true) }
                        });
                    }
                }

                public static void SetAim(ulong userid, int id, float aim_angle, float aim_pvp, float aim_range, bool pvp, bool ricochet)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.aim_angle = aim_angle;
                        entry.aim_pvp   = aim_pvp;
                        entry.aim_range = aim_range;
                        entry.pvp       = pvp;
                        entry.ricochet  = ricochet;
                    });
                }
                public static void SetAimViolations(ulong userid, int id, ulong aim_violations, bool add = false)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.aim_violations = add ? (aim_violations += aim_violations) : aim_violations;
                        entry.violations     = entry.violations || (entry.aim_violations > 0);
                    });
                }

                public static void SetAttacker(ulong userid, int id, string attacker, ulong attaker_id)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.attacker    = attacker;
                        entry.attacker_id = attaker_id;
                    });
                }

                public static void SetFireRateViolations(ulong userid, int id, ulong firerate_violations)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.violations = entry.violations || ((entry.firerate_violations = firerate_violations) > 0);
                    });
                }

                public static void SetHit(ulong userid, int id, float hit_distance, HitArea hit_location)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.hit_distance = hit_distance;
                        entry.hit_location = hit_location;
                    });
                }

                public static void SetRecoil(ulong userid, int id, float recoil_pitch, ulong recoil_repeats, float recoil_yaw, float recoil_swing)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.recoil_pitch   = recoil_pitch;
                        entry.recoil_repeats = recoil_repeats;
                        entry.recoil_swing   = recoil_swing;
                        entry.recoil_yaw     = recoil_yaw;
                    });
                }
                public static void SetRecoilViolations(ulong userid, int id, ulong recoil_violations)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.violations = entry.violations || ((entry.recoil_violations = recoil_violations) > 0);
                    });
                }

                public static void SetTrajectory(ulong userid, int id, float trajectory)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.trajectory = trajectory;
                    });
                }
                public static void SetTrajectoryViolations(ulong userid, int id, ulong trajectory_violations)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.violations = entry.violations || ((entry.trajectory_violations = trajectory_violations) > 0);
                    });
                }

                public static void SetVictim(ulong userid, int id, string victim)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.victim = victim;
                    });
                }

                public static void SetWallHackViolations(ulong userid, int id, ulong wallhack_violations)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.violations = entry.violations || ((entry.wallhack_violations = wallhack_violations) > 0);
                    });
                }

                public static void SetWeapon(ulong userid, int id, float speed, string weapon)
                {
                    TrySetEntry(userid, id, entry =>
                    {
                        entry.speed  = speed;
                        entry.weapon = weapon;
                    });
                }

                private static void TrySetEntry(ulong userid, int id, Action<Entry> set)
                {
                    Dictionary<int, Entry> _pending;

                    if(pending.TryGetValue(userid, out _pending))
                    {
                        Entry entry;

                        if(_pending.TryGetValue(id, out entry))
                        {
                            set(entry);
                        }
                    }
                }

                public static void Unload()
                {
                    buffer.Clear();

                    expired.Clear();
                    history.Clear();
                    pending.Clear();
                    request.Clear();
                    reserve.Clear();

                    Entry.Unload();
                }
            }

            private static readonly List<Weapon>                               expired = new List<Weapon>();
            private static readonly Dictionary<ulong, Dictionary<int, Weapon>> reverse = new Dictionary<ulong, Dictionary<int, Weapon>>();
            private static readonly Dictionary<ulong, Queue<Weapon>>           weapons = new Dictionary<ulong, Queue<Weapon>>();

            public static void Add(Weapon weapon)
            {
                Queue<Weapon> _weapons;

                if(!weapons.TryGetValue(weapon.Player.userID, out _weapons))
                {
                    weapons.Add(weapon.Player.userID, _weapons = new Queue<Weapon>());
                }

                _weapons.Enqueue(weapon);

                Dictionary<int, Weapon> _reverse;

                if(!reverse.TryGetValue(weapon.Player.userID, out _reverse))
                {
                    reverse.Add(weapon.Player.userID, _reverse = new Dictionary<int, Weapon>());
                }

                foreach(var projectileid in weapon.Projectiles)
                {
                    _reverse[projectileid] = weapon;
                }

                Log.Add(weapon);
            }

            public static void Load()
            {
                Timers.Add(0.1f, () =>
                {
                    var time = DateTime.UtcNow;

                    foreach(var user in weapons)
                    {
                        var _weapons = user.Value;

                        while(_weapons.Count > 0)
                        {
                            if(time.Subtract(_weapons.Peek().Fired).TotalSeconds > 9.0)
                            {
                                expired.Add(_weapons.Dequeue());
                            }
                            else
                            {
                                break;
                            }
                        }
                    }

                    expired.Sort((x, y) => DateTime.Compare(x.Fired, y.Fired));

                    foreach(var weapon in expired)
                    {
                        AntiCheat.Aim.Update(weapon);

                        Dictionary<int, Weapon> _reverse;

                        if(reverse.TryGetValue(weapon.Player.userID, out _reverse))
                        {
                            foreach(var projectileid in weapon.Projectiles)
                            {
                                _reverse.Remove(projectileid);
                            }

                            Log.Expire(weapon);

                            weapon.Release();
                        }

                    }

                    expired.Clear();

                    Log.Send();
                });
            }

            public static void Unload()
            {
                expired.Clear();
                reverse.Clear();
                weapons.Clear();

                Log.Unload();
            }

            public static Weapon Weapon(ulong userid, int projectileid)
            {
                Dictionary<int, Weapon> _reverse;

                if(reverse.TryGetValue(userid, out _reverse))
                {
                    Weapon weapon;

                    if(_reverse.TryGetValue(projectileid, out weapon))
                    {
                        return weapon;
                    }
                }

                return null;
            }
        }

        #endregion _projectile_

        #region _sparse_map_

        private class SparseMap
        {
            private Dictionary<Texel, Cell> map;
            private float map_scale;

            private struct Cell
            {
                private ulong pixels;

                public bool IsEmpty() =>
                    pixels == 0;

                private static ulong Mask(Delta delta) =>
                    1ul << (((delta.Y + 4) << 3) + delta.X + 4);

                public Cell Reset(Delta delta) =>
                    new Cell { pixels = pixels & ~Mask(delta) };

                public Cell Set(Delta delta) =>
                    new Cell { pixels = pixels | Mask(delta) };

                public bool Test(Delta delta) =>
                    (pixels & Mask(delta)) != 0;
            }

            private struct Delta
            {
                public int X { get; private set; }
                public int Y { get; private set; }

                public Delta(Texel texel, Pixel pixel)
                {
                    X = pixel.X - texel.X;
                    Y = pixel.Y - texel.Y;
                }
            }

            private struct Pixel
            {
                public int X { get; private set; }
                public int Y { get; private set; }

                public Pixel(int x, int y)
                {
                    X = x;
                    Y = y;
                }

                public Pixel(Vector3 position, SparseMap map)
                {
                    X = map.Scale(position.x);
                    Y = map.Scale(position.z);
                }
            }

            private struct Texel
            {
                public int X { get; private set; }
                public int Y { get; private set; }

                public Texel(Pixel pixel)
                {
                    X = pixel.X & ~7;
                    Y = pixel.Y & ~7;
                }

                public override bool Equals(object o) =>
                    (o is Texel) ? (this == (Texel)o) : false;

                public static bool operator ==(Texel a, Texel b) =>
                    (a.X == b.X) && (a.Y == b.Y);
                public static bool operator !=(Texel a, Texel b) =>
                    (a.X != b.X) || (a.Y != b.Y);

                public override int GetHashCode() =>
                    (((X * 1664525 + 1013904223) & 0x3fffffff) >> 3) ^ ((Y * 1103515245 + 12345) << 2);
            }

            public SparseMap(float scale)
            {
                map = new Dictionary<Texel, Cell>();

                SetScale(scale);
            }

            public void Clear() => map.Clear();
            public int Count() => map.Count;

            public void Reset(float scale = 0.0f)
            {
                Clear();

                if(scale != 0.0f)
                {
                    SetScale(scale);
                }
            }
            private void Reset(Pixel pixel)
            {
                var texel = new Texel(pixel);

                Cell value;

                if(!map.TryGetValue(texel, out value))
                {
                    return;
                }

                value = value.Reset(new Delta(texel, pixel));

                if(value.IsEmpty())
                {
                    map.Remove(texel);
                }
                else
                {
                    map[texel] = value;
                }
            }
            public void Reset(Vector3 position) =>
                Reset(new Pixel(position, this));

            public float Scale() => map_scale;
            private int Scale(float n) =>
                (int)(n * map_scale);

            private void Set(Pixel pixel)
            {
                var texel = new Texel(pixel);

                Cell value;

                if(!map.TryGetValue(texel, out value))
                {
                    value = new Cell();
                }

                map[texel] = value.Set(new Delta(texel, pixel));
            }
            public void Set(Vector3 position) =>
                Set(new Pixel(position, this));
            public int Set(Vector3 origin, float range)
            {
                var pixels = 0;
                var center = new Pixel(origin, this);

                var r = Scale(range);

                if(r < 0)
                {
                    return pixels;
                }

                var r_squared = r * r;

                if(r_squared == 0)
                {
                    if(range >= 0.25f)
                    {
                        Set(center); ++pixels;
                    }

                    return pixels;
                }

                for(int delta_x = -r; delta_x < r; ++delta_x)
                {
                    int delta_y = (int)Math.Sqrt(r_squared - delta_x * delta_x);

                    int x = center.X + delta_x, limit_y = center.Y + delta_y;

                    for(int y = center.Y - delta_y; y < limit_y; ++y)
                    {
                        Set(new Pixel(x, y)); ++pixels;
                    }
                }

                return pixels;
            }

            private void SetScale(float scale)
            {
                scale = Math.Abs(scale);

                scale = (scale < 0.125f) ? 0.125f : scale;

                map_scale = 1.0f / scale;
            }

            private bool Test(Pixel pixel)
            {
                var texel = new Texel(pixel);

                Cell value;

                if(map.TryGetValue(texel, out value))
                {
                    return value.Test(new Delta(texel, pixel));
                }

                return false;
            }
            public bool Test(Vector3 position) =>
                Test(new Pixel(position, this));
        }

        #endregion _sparse_map_

        #region _steam_

        private class Steam
        {
            public class Settings
            {
                public API.Settings   API;
                public SteamBan       Ban;
                public SteamGame      Game;
                public SteamProfile   Profile;
                public SteamShare     Share;
                public SteamViolation Violation;

                public Settings()
                {
                    API       = new API.Settings();
                    Ban       = new SteamBan();
                    Game      = new SteamGame();
                    Profile   = new SteamProfile();
                    Share     = new SteamShare();
                    Violation = new SteamViolation();
                }

                public class SteamBan
                {
                    public bool  Active;
                    public bool  Community;
                    public ulong Days;
                    public bool  Economy;
                    public ulong Game;
                    public ulong VAC;
                }
                public class SteamGame
                {
                    public ulong Count;
                    public ulong Hours;
                }
                public class SteamProfile
                {
                    public bool Invalid;
                    public bool Limited;
                    public bool Private;
                }
                public class SteamShare
                {
                    public bool Family;
                }

                public class SteamViolation
                {
                    public bool Ban;
                    public bool Enabled;
                    public bool Warn;

                    public SteamViolation()
                    {
                        Ban     = false;
                        Enabled = true;
                        Warn    = false;
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref API,       () => new API.Settings(), () => API.Validate());
                    Configuration.Validate(ref Ban,       () => new SteamBan());
                    Configuration.Validate(ref Game,      () => new SteamGame());
                    Configuration.Validate(ref Profile,   () => new SteamProfile());
                    Configuration.Validate(ref Share,     () => new SteamShare());
                    Configuration.Validate(ref Violation, () => new SteamViolation());
                }
            }

            private static uint appid;

            private static ActionQueue checks;

            private static readonly Violation violation = new Violation(Key.Steam);

            public static void Check(ulong userid)
            {
                if(!config.Steam.API.Enabled || Permissions.Bypass.Steam(userid))
                {
                    return;
                }

                if(string.IsNullOrEmpty(config.Steam.API.ApiKey))
                {
                    Log.Console(Key.LogSteamConfig, new Dictionary<string, string>
                    {
                        { "api", "API" },
                        { "link", $"https://steamcommunity.com/dev/apikey" }
                    });

                    return;
                }

                if(Ban.check)
                {
                    checks.Enqueue(() => Ban.Check(userid));
                }
            }

            public static void Configure()
            {
                violation.Configure(new Violation.Settings(true, 3600, 0.5f, config.Steam.Violation.Warn), 1, 1, 1);

                Game.check = Share.check = Profile.check = Summaries.check = Ban.check = false;

                if(config.Steam.API.Enabled)
                {
                    Game.check =
                        config.Steam.Game.Count > 0 ||
                        config.Steam.Game.Hours > 0;

                    Share.check =
                        Game.check ||
                        config.Steam.Share.Family;

                    Profile.check =
                        Share.check ||
                        config.Steam.Profile.Invalid ||
                        config.Steam.Profile.Limited;

                    Summaries.check =
                        Profile.check ||
                        config.Steam.Profile.Private;

                    Ban.check =
                        Summaries.check ||
                        config.Steam.Ban.Active ||
                        config.Steam.Ban.Community ||
                        config.Steam.Ban.Days > 0 ||
                        config.Steam.Ban.Economy ||
                        config.Steam.Ban.Game > 0 ||
                        config.Steam.Ban.VAC > 0;
                }
            }

            public static void Load()
            {
                appid = _instance.covalence.ClientAppId;

                Configure();

                checks = new ActionQueue(1.0f);
            }

            public static void Unload()
            {
                checks.Clear();
                checks = null;

                violation.Clear();
            }

            private static void Violation(ulong userid, Key type, string details, bool ban = false)
            {
                if(config.Steam.Violation.Enabled)
                {
                    ulong violations = (config.Steam.Violation.Ban || ban) ? ulong.MaxValue : 1ul;

                    violation.Trigger(userid, type, details, violations, true);
                }
                else
                {
                    if(User.IsConnected(userid))
                    {
                        User.Kick(userid, $"Steam: {type}");
                    }
                }
            }

            private class Ban
            {
                [JsonProperty("players")]
                public Player[] Players;

                public class Player
                {
                    [JsonProperty("CommunityBanned")]
                    public bool CommunityBanned;

                    [JsonProperty("VACBanned")]
                    public bool VacBanned;

                    [JsonProperty("NumberOfVACBans")]
                    public ulong NumberOfVacBans;

                    [JsonProperty("DaysSinceLastBan")]
                    public ulong DaysSinceLastBan;

                    [JsonProperty("NumberOfGameBans")]
                    public ulong NumberOfGameBans;

                    [JsonProperty("EconomyBan")]
                    public string EconomyBan;
                }

                [JsonIgnore]
                private static readonly string api = nameof(Ban);

                [JsonIgnore]
                public static bool check = false;

                public static void Check(ulong userid)
                {
                    var url = $"https://api.steampowered.com/ISteamUser/GetPlayerBans/v1/?key={config.Steam.API.ApiKey}&steamids={userid}";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        try
                        {
                            var response = JsonConvert.DeserializeObject<Ban>(reply).Players[0];

                            var has_bans = (response.NumberOfGameBans + response.NumberOfVacBans) > 0;

                            if(config.Steam.Ban.Active && response.VacBanned)
                            {
                                Violation(userid, Key.SteamBanActive, $"{true}");
                            }
                            else if(config.Steam.Ban.Community && response.CommunityBanned)
                            {
                                Violation(userid, Key.SteamBanCommunity, $"{true}");
                            }
                            else if((config.Steam.Ban.Days > 0) && (config.Steam.Ban.Days > response.DaysSinceLastBan) && has_bans)
                            {
                                Violation(userid, Key.SteamBanDays, $"{response.DaysSinceLastBan}");
                            }
                            else if(config.Steam.Ban.Economy && (response.EconomyBan == "banned"))
                            {
                                Violation(userid, Key.SteamBanEconomy, $"{true}");
                            }
                            else if((config.Steam.Ban.Game > 0) && (config.Steam.Ban.Game <= response.NumberOfGameBans))
                            {
                                Violation(userid, Key.SteamBanGame, $"{response.NumberOfGameBans}", true);
                            }
                            else if((config.Steam.Ban.VAC > 0) && (config.Steam.Ban.VAC <= response.NumberOfVacBans))
                            {
                                Violation(userid, Key.SteamBanVAC, $"{response.NumberOfVacBans}", true);
                            }
                            else if(Summaries.check)
                            {
                                Summaries.Check(userid);
                            }
                        }
                        catch
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", reply },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "JSON" }
                            });
                        }
                    }, _instance);
                }
            }

            private class Game
            {
                [JsonProperty("response")]
                public Content Response;

                public class Content
                {
                    [JsonProperty("game_count")]
                    public ulong GameCount;

                    [JsonProperty("games")]
                    public Game[] Games;

                    public class Game
                    {
                        [JsonProperty("appid")]
                        public uint AppId;

                        [JsonProperty("playtime_forever")]
                        public ulong PlaytimeForever;
                    }
                }

                [JsonIgnore]
                private static readonly string api = nameof(Game);

                [JsonIgnore]
                public static bool check = false;

                public static void Check(ulong userid, bool private_profile, bool is_sharing)
                {
                    if(private_profile || is_sharing)
                    {
                        if(config.Steam.Game.Count > 0)
                        {
                            Violation(userid, Key.SteamGameCount, "(null)");
                        }
                        else if(config.Steam.Game.Hours > 0)
                        {
                            Violation(userid, Key.SteamGameHours, "(null)");
                        }

                        return;
                    }

                    var url = $"https://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/?key={config.Steam.API.ApiKey}&steamid={userid}";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        try
                        {
                            var response = JsonConvert.DeserializeObject<Game>(reply).Response;

                            if((config.Steam.Game.Count > 0) && (config.Steam.Game.Count > response.GameCount))
                            {
                                Violation(userid, Key.SteamGameCount, $"{response.GameCount}");
                            }
                            else if(config.Steam.Game.Hours > 0)
                            {
                                foreach(var game in response.Games)
                                {
                                    if(game.AppId == appid)
                                    {
                                        var hours_played = game.PlaytimeForever / 60ul;

                                        if(config.Steam.Game.Hours > hours_played)
                                        {
                                            Violation(userid, Key.SteamGameHours, $"{hours_played}");

                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        catch
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", reply },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "JSON" }
                            });
                        }
                    }, _instance);
                }
            }

            private class Profile
            {
                private static readonly string api = nameof(Profile);

                public static bool check = false;

                public static void Check(ulong userid, bool private_profile)
                {
                    var url = $"https://steamcommunity.com/profiles/{userid}/?xml=1";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        var response = reply.ToLower();

                        var has_profile = !response.Contains("this user has not yet set up their steam community profile");

                        if(config.Steam.Profile.Invalid && !has_profile)
                        {
                            Violation(userid, Key.SteamProfileInvalid, $"{true}");
                        }
                        else if(config.Steam.Profile.Limited && has_profile && response.Contains("<islimitedaccount>1</islimitedaccount>"))
                        {
                            Violation(userid, Key.SteamProfileLimited, $"{true}");
                        }
                        else if(Share.check)
                        {
                            Share.Check(userid, private_profile);
                        }
                    }, _instance);
                }
            }

            private class Share
            {
                [JsonProperty("response")]
                public Content Response;

                public class Content
                {
                    [JsonProperty("lender_steamid")]
                    public ulong LenderSteamId;
                }

                [JsonIgnore]
                private static readonly string api = nameof(Share);

                [JsonIgnore]
                public static bool check = false;

                public static void Check(ulong userid, bool private_profile)
                {
                    var url = $"https://api.steampowered.com/IPlayerService/IsPlayingSharedGame/v0001/?key={config.Steam.API.ApiKey}&steamid={userid}&appid_playing={appid}";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        try
                        {
                            var response = JsonConvert.DeserializeObject<Share>(reply).Response;

                            var is_sharing = (response.LenderSteamId > 0);

                            if(config.Steam.Share.Family && is_sharing)
                            {
                                Violation(userid, Key.SteamShareFamily, $"{true}");
                            }
                            else if(Game.check)
                            {
                                Game.Check(userid, private_profile, is_sharing);
                            }
                        }
                        catch
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", reply },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "JSON" }
                            });
                        }
                    }, _instance);
                }
            }

            private class Summaries
            {
                [JsonProperty("response")]
                public Content Response;

                public class Content
                {
                    [JsonProperty("players")]
                    public Player[] Players;

                    public class Player
                    {
                        [JsonProperty("communityvisibilitystate")]
                        public int CommunityVisibilityState;
                    }
                }

                [JsonIgnore]
                private static readonly string api = nameof(Summaries);

                [JsonIgnore]
                public static bool check = false;

                public static void Check(ulong userid)
                {
                    var url = $"https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={config.Steam.API.ApiKey}&steamids={userid}";

                    _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                    {
                        if(code != 200 || string.IsNullOrEmpty(reply))
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "HTTP" }
                            });

                            return;
                        }

                        try
                        {
                            var response = JsonConvert.DeserializeObject<Summaries>(reply).Response.Players[0];

                            var private_profile = (response.CommunityVisibilityState < 3);

                            if(config.Steam.Profile.Private && private_profile)
                            {
                                Violation(userid, Key.SteamProfilePrivate, $"{true}");
                            }
                            else if(Profile.check)
                            {
                                Profile.Check(userid, private_profile);
                            }
                        }
                        catch
                        {
                            Log.Console(Key.LogSteam, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "info", reply },
                                { "playerid", userid.ToString() },
                                { "playername", Text.Sanitize(User.Name(userid)) },
                                { "type", "JSON" }
                            });
                        }
                    }, _instance);
                }
            }
        }

        #endregion _steam_

        #region _text_

        private enum Key
        {
            add,
            Added,
            Address,
            ago,
            Allowed,
            AllUsers,
            and,
            AntiCheat,
            AntiCheatAim,
            AntiCheatFireRate,
            AntiCheatGravity,
            AntiCheatMeleeRate,
            AntiCheatRecoil,
            AntiCheatStash,
            AntiCheatTrajectory,
            AntiCheatWallHack,
            AntiFlood,
            AntiFloodChat,
            AntiFloodCommand,
            AntiFloodItemDrop,
            BanCount,
            BanInherited,
            Banned,
            banned,
            BanReason,
            BanReset,
            Blocked,
            BodyPart,
            BodyPartArm,
            BodyPartChest,
            BodyPartFoot,
            BodyPartHand,
            BodyPartHead,
            BodyPartLeg,
            BodyPartStomach,
            Bypassed,
            Changed,
            Chat,
            Command,
            CommandConfig,
            CommandConfigAdminSyntax,
            CommandConfigAntiCheatAimSyntax,
            CommandConfigAntiCheatFireRateSyntax,
            CommandConfigAntiCheatGravitySyntax,
            CommandConfigAntiCheatMeleeRateSyntax,
            CommandConfigAntiCheatRecoilSyntax,
            CommandConfigAntiCheatServerSyntax,
            CommandConfigAntiCheatStashSyntax,
            CommandConfigAntiCheatSyntax,
            CommandConfigAntiCheatTrajectorySyntax,
            CommandConfigAntiCheatWallHackSyntax,
            CommandConfigAntiFloodChatSyntax,
            CommandConfigAntiFloodCommandSyntax,
            CommandConfigAntiFloodItemDropSyntax,
            CommandConfigAntiFloodSyntax,
            CommandConfigBanSyntax,
            CommandConfigCrippleSyntax,
            CommandConfigDiscordSyntax,
            CommandConfigEntitySyntax,
            CommandConfigIpSyntax,
            CommandConfigLogSyntax,
            CommandConfigSaveSyntax,
            CommandConfigSteamSyntax,
            CommandConfigSyntax,
            CommandConfigTitle,
            CommandConfigUserSyntax,
            CommandConfigViolationSyntax,
            CommandConfigVpnSyntax,
            CommandHelp,
            CommandHelpEntry,
            CommandHelpTitle,
            CommandIp,
            CommandIpEntry,
            CommandIpEntryFailed,
            CommandIpList,
            CommandIpSyntax,
            CommandIpTitle,
            CommandLogHeading,
            CommandLogLine,
            CommandLogNoEntries,
            CommandLogSeeConsole,
            CommandLogSyntax,
            CommandLogTitle,
            CommandNoPermission,
            CommandServerSyntax,
            CommandServerTitle,
            CommandTeleport,
            CommandTeleportSyntax,
            CommandTeleportTitle,
            CommandTeleportViolation,
            CommandUnknown,
            CommandUser,
            CommandUserAction,
            CommandUserInfo,
            CommandUserKick,
            CommandUserNotFound,
            CommandUserSyntax,
            CommandUserTeam,
            CommandUserTitle,
            CommandUserTooMany,
            CommandVpn,
            CommandVpnSyntax,
            CommandVpnTitle,
            connected,
            CONSOLE,
            Cooldown,
            Crafting,
            CrippleCount,
            Crippled,
            crippled,
            CrippleReason,
            CrippleReset,
            Current,
            data,
            Denied,
            Detected,
            DurationDay,
            DurationDays,
            DurationHour,
            DurationHours,
            DurationMinute,
            DurationMinutes,
            DurationSecond,
            DurationSeconds,
            DurationSecondsUnit,
            empty,
            Entity,
            EntityAnimal,
            EntityAutoTurret,
            EntityBear,
            EntityBoar,
            EntityBradley,
            EntityBuilding,
            EntityChicken,
            EntityFlameTurret,
            EntityGunTrap,
            EntityHelicopter,
            EntityMurderer,
            EntityNPC,
            EntityPlayer,
            EntitySAMSite,
            EntityScientist,
            EntityStag,
            EntityTC,
            EntityTrap,
            file,
            For,
            idle,
            InvalidSteamId,
            IP,
            IpBlocked,
            IpCooldown,
            Kicked,
            LogAntiCheatAim,
            LogAntiCheatGravity,
            LogAntiCheatMeleeRate,
            LogAntiCheatRecoil,
            LogAntiCheatServer,
            LogAntiCheatStash,
            LogAntiCheatTrajectory,
            LogAntiSpamItemDrop,
            LogConnect,
            LogDiscordConfig,
            LogDiscordMessage,
            LogIpFilter,
            LogSteam,
            LogSteamConfig,
            LogUserBypass,
            LogVpnCheck,
            LogVpnCheckConfig,
            LogVpnCheckError,
            LogWebHook,
            Name,
            never,
            NoReasonGiven,
            NULL,
            offline,
            OnAntiCheatTriggered,
            online,
            OxideGroups,
            Pardoned,
            permanently,
            Played,
            remove,
            Removed,
            Saved,
            Server,
            SERVER,
            Status,
            Steam,
            SteamBanActive,
            SteamBanCommunity,
            SteamBanDays,
            SteamBanEconomy,
            SteamBanGame,
            SteamBanVAC,
            SteamGameCount,
            SteamGameHours,
            SteamID,
            SteamProfileInvalid,
            SteamProfileLimited,
            SteamProfilePrivate,
            SteamShareFamily,
            True,
            Unbanned,
            Unblocked,
            Uncrippled,
            unknown,
            UnknownKey,
            UserAction,
            UserBanTeleport,
            UserBanTeleported,
            UserConnectBanInherit,
            UserConnectIpBlocked,
            UserConnectSteamIdInvalid,
            UserInfoText,
            UserInfoTextBullet,
            UserInfoTextLabel,
            UserPardonProgress,
            Violation,
            ViolationAim,
            ViolationFireRate,
            ViolationGravity,
            ViolationMeleeRate,
            ViolationRecoil,
            ViolationStash,
            ViolationTrajectory,
            ViolationWallHack,
            VPN,
            VpnCache,
            VpnDetected,
            Warning
        }

        private class Text
        {
            private static readonly Dictionary<string, Dictionary<Key, string>> decorated = new Dictionary<string, Dictionary<Key, string>>();
            private static readonly Dictionary<string, Dictionary<Key, string>> unadorned = new Dictionary<string, Dictionary<Key, string>>();

            private static string server_language;

            private class RegEx
            {
                public static Regex clean1;
                public static Regex clean2;
                public static Regex clean3;
                public static Regex markup;
                public static Regex spaces;

                public static void Load()
                {
                    clean1 = new Regex(@"\p{Cc}+|\p{Cs}+", RegexOptions.Compiled);
                    clean2 = new Regex(@"\{+|\}+",         RegexOptions.Compiled);
                    markup = new Regex(@"<[^>]+>",         RegexOptions.Compiled);
                    spaces = new Regex(@"\s{2,}",          RegexOptions.Compiled);
                }

                public static void Unload()
                {
                    clean1 = clean2 = clean3 = markup = spaces = null;
                }
            }

            public static string Actor(IPlayer actor) =>
                Actor(actor, server_language);
            public static string Actor(IPlayer actor, BasePlayer player) =>
                Actor(actor, Language(player.UserIDString));
            public static string Actor(IPlayer actor, IPlayer iplayer) =>
                Actor(actor, iplayer.IsServer ? server_language : Language(iplayer.Id));
            public static string Actor(IPlayer actor, ulong userid) =>
                Actor(actor, Language(userid.ToString()));
            public static string Actor(IPlayer actor, string language)
            {
                if(actor == null)
                {
                    return GetPlain(Key.SERVER, language);
                }
                else if(actor.IsServer)
                {
                    return GetPlain(Key.CONSOLE, language);
                }
                else
                {
                    return Sanitize(actor.Name);
                }
            }

            public static string BodyPart(HitArea area) =>
                BodyPart(area, server_language);
            public static string BodyPart(HitArea area, BasePlayer player) =>
                BodyPart(area, Language(player.UserIDString));
            public static string BodyPart(HitArea area, IPlayer iplayer) =>
                BodyPart(area, iplayer.IsServer ? server_language : Language(iplayer.Id));
            public static string BodyPart(HitArea area, ulong userid) =>
                BodyPart(area, Language(userid.ToString()));
            public static string BodyPart(HitArea area, string language)
            {
                switch(area)
                {
                case HitArea.Head:    return GetPlain(Key.BodyPartHead);
                case HitArea.Chest:   return GetPlain(Key.BodyPartChest);
                case HitArea.Stomach: return GetPlain(Key.BodyPartStomach);
                case HitArea.Arm:     return GetPlain(Key.BodyPartArm);
                case HitArea.Hand:    return GetPlain(Key.BodyPartHand);
                case HitArea.Leg:     return GetPlain(Key.BodyPartLeg);
                case HitArea.Foot:    return GetPlain(Key.BodyPartFoot);
                }

                return GetPlain(Key.BodyPart, language);
            }

            public class Duration
            {
                public static string Hours(TimeSpan time) =>
                    Hours(time, server_language);
                public static string Hours(TimeSpan time, BasePlayer player) =>
                    Hours(time, Language(player.UserIDString));
                public static string Hours(TimeSpan time, IPlayer iplayer) =>
                    Hours(time, iplayer.IsServer ? server_language : Language(iplayer.Id));
                public static string Hours(TimeSpan time, ulong userid) =>
                    Hours(time, Language(userid.ToString()));
                public static string Hours(TimeSpan time, string language) =>
                    $"{time.Duration().TotalHours:0.00} {GetPlain(Key.DurationHours, language)}";

                public static string Short(TimeSpan time) =>
                    Short(time, server_language);
                public static string Short(TimeSpan time, BasePlayer player) =>
                    Short(time, Language(player.UserIDString));
                public static string Short(TimeSpan time, IPlayer iplayer) =>
                    Short(time, iplayer.IsServer ? server_language : Language(iplayer.Id));
                public static string Short(TimeSpan time, ulong userid) =>
                    Short(time, Language(userid.ToString()));
                public static string Short(TimeSpan time, string language)
                {
                    var duration = time.Duration();

                    if(duration.Days != 0)
                    {
                        return $"{duration.TotalDays:0.00} {GetPlain(Key.DurationDays, language)}";
                    }
                    else if(duration.Hours != 0)
                    {
                        return $"{duration.TotalHours:0.00} {GetPlain(Key.DurationHours, language)}";
                    }
                    else if(duration.Minutes != 0)
                    {
                        return $"{duration.TotalMinutes:0.00} {GetPlain(Key.DurationMinutes, language)}";
                    }
                    else
                    {
                        return $"{duration.TotalSeconds:0.00} {GetPlain(Key.DurationSeconds, language)}";
                    }
                }
            }

            public static string Get(Key key, Dictionary<string, string> parameters = null) =>
                Get(key, server_language, parameters);
            public static string Get(Key key, BasePlayer player, Dictionary<string, string> parameters = null) =>
                Get(key, Language(player.UserIDString), parameters);
            public static string Get(Key key, IPlayer iplayer, Dictionary<string, string> parameters = null)
            {
                if(iplayer.LastCommand == CommandType.Console)
                {
                    return GetPlain(key, iplayer.IsServer ? server_language : Language(iplayer.Id), parameters);
                }
                else
                {
                    return Get(key, iplayer.IsServer ? server_language : Language(iplayer.Id), parameters);
                }
            }
            public static string Get(Key key, ulong userid, Dictionary<string, string> parameters = null) =>
                Get(key, Language(userid.ToString()), parameters);
            public static string Get(Key key, string language, Dictionary<string, string> parameters = null) =>
                Get(key, Messages(decorated, language), parameters);
            private static string Get(Key key, Dictionary<Key, string> cache, Dictionary<string, string> parameters)
            {
                string message = null;

                if(cache?.TryGetValue(key, out message) ?? false)
                {
                    return Replace(message, parameters);
                }

                return Enum.GetName(typeof(Key), key);
            }

            public static string GetPlain(Key key, Dictionary<string, string> parameters = null) =>
                GetPlain(key, server_language, parameters);
            public static string GetPlain(Key key, BasePlayer player, Dictionary<string, string> parameters = null) =>
                GetPlain(key, Language(player.UserIDString), parameters);
            public static string GetPlain(Key key, IPlayer iplayer, Dictionary<string, string> parameters = null) =>
                GetPlain(key, iplayer.IsServer ? server_language : Language(iplayer.Id), parameters);
            public static string GetPlain(Key key, ulong userid, Dictionary<string, string> parameters = null) =>
                GetPlain(key, Language(userid.ToString()), parameters);
            public static string GetPlain(Key key, string language, Dictionary<string, string> parameters = null) =>
                Get(key, Messages(unadorned, language), parameters);

            public static string Language(string userid = null)
            {
                if(string.IsNullOrEmpty(userid))
                {
                    return server_language;
                }

                var language = _instance.lang.GetLanguage(userid) ?? server_language;

                return decorated.ContainsKey(language) ? language : server_language;
            }

            public static void Load()
            {
                var languages = _instance.lang.GetLanguages(_instance);

                if((languages.Length == 0) || Configuration.Upgraded())
                {
                    RegisterMessages();

                    languages = _instance.lang.GetLanguages(_instance);
                }

                var requested = _instance.lang.GetServerLanguage();

                if(!string.IsNullOrEmpty(requested) && languages.Contains(requested))
                {
                    server_language = requested;
                }
                else
                {
                    server_language = "en";
                }

                RegEx.Load();

                foreach(var language in languages)
                {
                    var m_decorated = decorated[language] = new Dictionary<Key, string>();
                    var m_unadorned = unadorned[language] = new Dictionary<Key, string>();

                    foreach(var entry in _instance.lang.GetMessages(language, _instance))
                    {
                        if(string.IsNullOrEmpty(entry.Key))
                        {
                            continue;
                        }

                        Key key;

                        if(Enum.TryParse(entry.Key, out key))
                        {
                            m_decorated.Add(key, entry.Value);
                            m_unadorned.Add(key, Strip(entry.Value));
                        }
                        else
                        {
                            Log.Console(Key.UnknownKey, new Dictionary<string, string>
                            {
                                { "key", entry.Key },
                                { "language", language }
                            });
                        }
                    }
                }
            }

            private static Dictionary<Key, string> Messages(Dictionary<string, Dictionary<Key, string>> cache, string language)
            {
                Dictionary<Key, string> messages;

                if(!cache.TryGetValue(language, out messages))
                {
                    if(!cache.TryGetValue(server_language, out messages))
                    {
                        return null;
                    }
                }

                return messages;
            }

            public static bool ParseTime(string message, out ulong seconds)
            {
                seconds = 0;

                if(string.IsNullOrEmpty(message))
                {
                    return false;
                }

                ulong amount = 0; char units = 's';

                for(int i = 0; i < message.Length; ++i)
                {
                    var current = message[i];

                    if(char.IsDigit(current))
                    {
                        amount *= 10;
                        amount += (ulong)(current - '0');
                    }
                    else
                    {
                        if((i + 1) != message.Length)
                        {
                            return false;
                        }

                        units = char.ToLower(current);
                    }
                }

                switch(units)
                {
                case 'd': seconds = amount * 86400ul; return true;
                case 'h': seconds = amount *  3600ul; return true;
                case 'm': seconds = amount *    60ul; return true;
                case 's': seconds = amount;           return true;
                }

                return false;
            }

            private static void RegisterMessages()
            {
                _instance.lang.RegisterMessages(new Dictionary<string, string>(), _instance, "en");
                _instance.lang.RegisterMessages(new Dictionary<string, string>
                {
                    { nameof(Key.add), "add" },
                    { nameof(Key.Added), "Added" },
                    { nameof(Key.Address), "Address" },
                    { nameof(Key.ago), "ago" },
                    { nameof(Key.Allowed), "Allowed" },
                    { nameof(Key.AllUsers), "All Users" },
                    { nameof(Key.and), "and" },
                    { nameof(Key.AntiCheat), "AntiCheat" },
                    { nameof(Key.AntiCheatAim), "Aim" },
                    { nameof(Key.AntiCheatFireRate), "Fire Rate" },
                    { nameof(Key.AntiCheatGravity), "Gravity" },
                    { nameof(Key.AntiCheatMeleeRate), "Melee Rate" },
                    { nameof(Key.AntiCheatRecoil), "Recoil" },
                    { nameof(Key.AntiCheatStash), "Stash" },
                    { nameof(Key.AntiCheatTrajectory), "Trajectory" },
                    { nameof(Key.AntiCheatWallHack), "Wall Hack" },
                    { nameof(Key.AntiFlood), "AntiFlood" },
                    { nameof(Key.AntiFloodChat), "Chat" },
                    { nameof(Key.AntiFloodCommand), "Command" },
                    { nameof(Key.AntiFloodItemDrop), "Dropped Items" },
                    { nameof(Key.BanCount), "Ban Count" },
                    { nameof(Key.BanInherited), "Ban inherited" },
                    { nameof(Key.Banned), "Banned" },
                    { nameof(Key.banned), "banned" },
                    { nameof(Key.BanReason), "Ban Reason" },
                    { nameof(Key.BanReset), "Reset ban data for" },
                    { nameof(Key.Blocked), "Blocked" },
                    { nameof(Key.BodyPart), "Body" },
                    { nameof(Key.BodyPartArm), "Arm" },
                    { nameof(Key.BodyPartChest), "Chest" },
                    { nameof(Key.BodyPartFoot), "Foot" },
                    { nameof(Key.BodyPartHand), "Hand" },
                    { nameof(Key.BodyPartHead), "Head" },
                    { nameof(Key.BodyPartLeg), "Leg" },
                    { nameof(Key.BodyPartStomach), "Stomach" },
                    { nameof(Key.Bypassed), "Bypassed" },
                    { nameof(Key.Changed), "Changed" },
                    { nameof(Key.Chat), "Chat" },
                    { nameof(Key.Command), "Command" },
                    { nameof(Key.CommandConfig), "<size=12><color=#c0ffc0>{action} configuration: </color><color=#c0c0ff>{info}</color></size>" },
                    { nameof(Key.CommandConfigAdminSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} admin.broadcast [true|false]\n    {command} admin.bypass [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatAimSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.aim.ban [true|false]\n    {command} anticheat.aim.cooldown [SECONDS]\n    {command} anticheat.aim.enabled [true|false]\n    {command} anticheat.aim.sensitivity [0.0-1.0]\n    {command} anticheat.aim.trigger.animal [true|false]\n    {command} anticheat.aim.trigger.bradley [true|false]\n    {command} anticheat.aim.trigger.helicopter [true|false]\n    {command} anticheat.aim.trigger.npc [true|false]\n    {command} anticheat.aim.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatFireRateSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.firerate.ban [true|false]\n    {command} anticheat.firerate.cooldown [SECONDS]\n    {command} anticheat.firerate.enabled [true|false]\n    {command} anticheat.firerate.sensitivity [0.0-1.0]\n    {command} anticheat.firerate.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatGravitySyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.gravity.ban [true|false]\n    {command} anticheat.gravity.cooldown [SECONDS]\n    {command} anticheat.gravity.enabled [true|false]\n    {command} anticheat.gravity.sensitivity [0.0-1.0]\n    {command} anticheat.gravity.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatMeleeRateSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.meleerate.ban [true|false]\n    {command} anticheat.meleerate.cooldown [SECONDS]\n    {command} anticheat.meleerate.enabled [true|false]\n    {command} anticheat.meleerate.sensitivity [0.0-1.0]\n    {command} anticheat.meleerate.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatRecoilSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.recoil.ban [true|false]\n    {command} anticheat.recoil.cooldown [SECONDS]\n    {command} anticheat.recoil.enabled [true|false]\n    {command} anticheat.recoil.sensitivity [0.0-1.0]\n    {command} anticheat.recoil.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatServerSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.server.ban [true|false]\n    {command} anticheat.server.cooldown [SECONDS]\n    {command} anticheat.server.enabled [true|false]\n    {command} anticheat.server.sensitivity [0.0-1.0]\n    {command} anticheat.server.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatStashSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.stash.ban [true|false]\n    {command} anticheat.stash.cooldown [SECONDS]\n    {command} anticheat.stash.enabled [true|false]\n    {command} anticheat.stash.sensitivity [0.0-1.0]\n    {command} anticheat.stash.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatSyntax), "<size=12><color=#ffc0c0>Syntax:</color><color=#c0c0ff>\n    {command} anticheat.aim\n    {command} anticheat.firerate\n    {command} anticheat.gravity\n    {command} anticheat.meleerate\n    {command} anticheat.recoil\n    {command} anticheat.server\n    {command} anticheat.stash\n    {command} anticheat.trajetory\n    {command} anticheat.wallhack</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatTrajectorySyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.trajectory.ban [true|false]\n    {command} anticheat.trajectory.cooldown [SECONDS]\n    {command} anticheat.trajectory.enabled [true|false]\n    {command} anticheat.trajectory.sensitivity [0.0-1.0]\n    {command} anticheat.trajectory.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiCheatWallHackSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} anticheat.wallhack.ban [true|false]\n    {command} anticheat.wallhack.cooldown [SECONDS]\n    {command} anticheat.wallhack.enabled [true|false]\n    {command} anticheat.wallhack.sensitivity [0.0-1.0]\n    {command} anticheat.wallhack.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiFloodChatSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} antiflood.chat.ban [true|false]\n    {command} antiflood.chat.cooldown [SECONDS]\n    {command} antiflood.chat.enabled [true|false]\n    {command} antiflood.chat.sensitivity [0.0-1.0]\n    {command} antiflood.chat.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiFloodCommandSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} antiflood.command.ban [true|false]\n    {command} antiflood.command.cooldown [SECONDS]\n    {command} antiflood.command.enabled [true|false]\n    {command} antiflood.command.sensitivity [0.0-1.0]\n    {command} antiflood.command.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiFloodItemDropSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} antiflood.itemdrop.ban [true|false]\n    {command} antiflood.itemdrop.cooldown [SECONDS]\n    {command} antiflood.itemdrop.enabled [true|false]\n    {command} antiflood.itemdrop.sensitivity [0.0-1.0]\n    {command} antiflood.itemdrop.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigAntiFloodSyntax), "<size=12><color=#ffc0c0>Syntax:</color><color=#c0c0ff>\n    {command} antiflood.chat\n    {command} antiflood.command\n    {command} antiflood.itemdrop</color></size>" },
                    { nameof(Key.CommandConfigBanSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} ban.inherit [true|false]\n    {command} ban.teleport [true|false]\n    {command} ban.time.enforce [true|false]\n    {command} ban.time.multiply [true|false]\n    {command} ban.time.seconds [AMOUNT[d|h|m|s]]</color></size>" },
                    { nameof(Key.CommandConfigCrippleSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} cripple.heal [true|false]\n    {command} cripple.inherit [true|false]</color></size>" },
                    { nameof(Key.CommandConfigDiscordSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} discord.enabled [true|false]\n    {command} discord.webhook [URL]\n    {command} discord.filters.anticheat.enabled [true|false]\n    {command} discord.filters.anticheat.webhook [URL]\n    {command} discord.filters.antiflood.enabled [true|false]\n    {command} discord.filters.antiflood.webhook [URL]\n    {command} discord.filters.ip.enabled [true|false]\n    {command} discord.filters.ip.webhook [URL]\n    {command} discord.filters.steam.enabled [true|false]\n    {command} discord.filters.steam.webhook [URL]\n    {command} discord.filters.vpn.enabled [true|false]\n    {command} discord.filters.vpn.webhook [URL]</color></size>" },
                    { nameof(Key.CommandConfigEntitySyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} entity.damage.animal [0.0-100.0]\n    {command} entity.damage.bradley [0.0-100.0]\n    {command} entity.damage.building [0.0-100.0]\n    {command} entity.damage.entity [0.0-100.0]\n    {command} entity.damage.friend [0.0-100.0]\n    {command} entity.damage.helicopter [0.0-100.0]\n    {command} entity.damage.npc [0.0-100.0]\n    {command} entity.damage.player [0.0-100.0]\n    {command} entity.damage.team [0.0-100.0]\n    {command} entity.damage.trap [0.0-100.0]</color></size>" },
                    { nameof(Key.CommandConfigIpSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} ip.filter.cooldown [SECONDS]\n    {command} ip.violation.ban [true|false]\n    {command} ip.violation.enabled [true|false]</color></size>" },
                    { nameof(Key.CommandConfigLogSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} log.anticheat.gravity [true|false]\n    {command} log.anticheat.meleerate [true|false]\n    {command} log.anticheat.projectile [true|false]\n    {command} log.anticheat.server [true|false]\n    {command} log.anticheat.stash [true|false]\n    {command} log.antiflood.itemdrop [true|false]\n    {command} log.ip.filter [true|false]\n    {command} log.projectile.collapse [true|false]\n    {command} log.projectile.verbose [true|false]\n    {command} log.user.connect [true|false]\n    {command} log.vpn.bypass [true|false]\n    {command} log.vpn.check [true|false]</color></size>" },
                    { nameof(Key.CommandConfigSaveSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} save</color></size>" },
                    { nameof(Key.CommandConfigSteamSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} steam.api.apikey [\"API-KEY\"]\n    {command} steam.api.enabled [true|false]\n    {command} steam.ban.active [true|false]\n    {command} steam.ban.community [true|false]\n    {command} steam.ban.days [DAYS]\n    {command} steam.ban.economy [true|false]\n    {command} steam.ban.game [NUMBER]\n    {command} steam.ban.vac [NUMBER]\n    {command} steam.game.count [NUMBER]\n    {command} steam.game.hours [HOURS]\n    {command} steam.profile.invalid [true|false]\n    {command} steam.profile.limited [true|false]\n    {command} steam.profile.private [true|false]\n    {command} steam.share.family [true|false]\n    {command} steam.violation.ban [true|false]\n    {command} steam.violation.enabled [true|false]\n    {command} steam.violation.warn [true|false]</color></size>" },
                    { nameof(Key.CommandConfigSyntax), "<size=12><color=#ffc0c0>Syntax:</color><color=#c0c0ff>\n    {command} admin\n    {command} anticheat\n    {command} antiflood\n    {command} ban\n    {command} cripple\n    {command} discord\n    {command} entity\n    {command} ip\n    {command} log\n    {command} save\n    {command} steam\n    {command} user\n    {command} violation\n    {command} vpn</color></size>" },
                    { nameof(Key.CommandConfigTitle), "Configuration Settings" },
                    { nameof(Key.CommandConfigUserSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} user.bypass.dayssincelastban [DAYS]\n    {command} user.bypass.enabled [true|false]\n    {command} user.bypass.multiply [true|false]\n    {command} user.bypass.hoursplayed [HOURS]</color></size>" },
                    { nameof(Key.CommandConfigViolationSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} violation.ban [true|false]\n    {command} violation.cooldown [SECONDS]\n    {command} violation.enabled [true|false]\n    {command} violation.sensitivity [0.0-1.0]</size>" },
                    { nameof(Key.CommandConfigVpnSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} vpn.api.getipintel.apikey [\"API-KEY\"]\n    {command} vpn.api.getipintel.enabled [true|false]\n    {command} vpn.api.ipapi.enabled [true|false]\n    {command} vpn.api.iphub.apikey [\"API-KEY\"]\n    {command} vpn.api.iphub.enabled [true|false]\n    {command} vpn.api.ipqualityscore.apikey [\"API-KEY\"]\n    {command} vpn.api.ipqualityscore.enabled [true|false]\n    {command} vpn.cache.hours [HOURS]\n    {command} vpn.check.enabled [true|false]\n    {command} vpn.check.strict [true|false]\n    {command} vpn.violation.ban [true|false]\n    {command} vpn.violation.enabled [true|false]\n    {command} vpn.violation.warn [true|false]</color></size>" },
                    { nameof(Key.CommandHelp), "<size=12><color=#ffffc0>{name} v{version} - Help</color>{entries}</size>" },
                    { nameof(Key.CommandHelpEntry), "<color=#c0ffc0>\n{title}:</color><color=#c0c0ff>{aliases}</color>" },
                    { nameof(Key.CommandHelpTitle), "Help Information" },
                    { nameof(Key.CommandIp), "<size=12><color=#c0ffc0>{action} IP: </color><color=#c0c0ff>{info}</color></size>" },
                    { nameof(Key.CommandIpEntry), "<size=12><color=#c0ffc0>{action} IP entry: </color><color=#c0c0ff>{entry}</color></size>" },
                    { nameof(Key.CommandIpEntryFailed), "<size=12><color=#ffc0c0>Failed to {action} IP entry: </color><color=#c0c0ff>{entry}</color></size>" },
                    { nameof(Key.CommandIpList), "<size=12><color=#c0ffc0>{type} IP entries: </color><color=#c0c0ff>{addresses}</color></size>" },
                    { nameof(Key.CommandIpSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} allow\n    {command} allow IP[/BITS]\n    {command} allow add IP[/BITS]\n    {command} allow remove IP[/BITS]\n    {command} block IP\n    {command} bypass IP\n    {command} deny\n    {command} deny IP[/BITS]\n    {command} deny add IP[/BITS]\n    {command} deny remove IP[/BITS]\n    {command} save\n    {command} unblock IP</color></size>" },
                    { nameof(Key.CommandIpTitle), "IP Filtering" },
                    { nameof(Key.CommandLogHeading), "<size=12><color=#c0ffc0>Projectile Log for {playername}[{playerid}]:</color></size>" },
                    { nameof(Key.CommandLogLine), "<size=12><color=#c0c0c0>{info}</color></size>" },
                    { nameof(Key.CommandLogNoEntries), "<size=12><color=#ffffc0>No log data available for {playername}[{playerid}].</color></size>" },
                    { nameof(Key.CommandLogSeeConsole), "<size=12><color=#c0ffc0>Check the console (F1) for results.</color></size>" },
                    { nameof(Key.CommandLogSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} IP|NAME|STEAMID [LINES]</color></size>" },
                    { nameof(Key.CommandLogTitle), "Projectile Log" },
                    { nameof(Key.CommandNoPermission), "<color=#ffc0c0><size=12>You do not have permission to use this command.</size></color>" },
                    { nameof(Key.CommandServerSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} pardon\n    {command} unban\n    {command} uncripple</color></size>" },
                    { nameof(Key.CommandServerTitle), "Server Administration" },
                    { nameof(Key.CommandTeleport), "<size=12><color=#c0ffc0>Last seen location: </color><color=#c0c0ff>{position}</color></size>" },
                    { nameof(Key.CommandTeleportSyntax), "<size=12><color=#ffc0c0>Syntax:</color><color=#c0c0ff>\n    {command} IP|NAME|STEAMID</color></size>" },
                    { nameof(Key.CommandTeleportTitle), "Teleportation" },
                    { nameof(Key.CommandTeleportViolation), "<size=12><color=#c0ffc0>Violation location: </color><color=#c0c0ff>{position}</color></size>" },
                    { nameof(Key.CommandUnknown), "<size=12><color=#ffc0c0>Command unknown: </color><color=#c0c0ff>{command}</color></size>" },
                    { nameof(Key.CommandUser), "<size=12><color=#c0ffc0>{action} {playername}[{playerid}] {duration}: </color><color=#c0c0ff>{reason}</color></size>" },
                    { nameof(Key.CommandUserAction), "<size=12><color=#c0ffc0>{action} {playername}[{playerid}]</color></size>" },
                    { nameof(Key.CommandUserInfo), "<size=12><color=#c0ffc0>User information:</color><color=#c0c0ff>{info}</color></size>" },
                    { nameof(Key.CommandUserKick), "<size=12><color=#c0ffc0>{action} {playername}[{playerid}]: </color><color=#c0c0ff>{reason}</color></size>" },
                    { nameof(Key.CommandUserNotFound), "<size=12><color=#ffc0c0>User not found.</color></size>" },
                    { nameof(Key.CommandUserSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} IP|NAME|STEAMID [team]\n    {command} IP|NAME|STEAMID [team.]ban [\"REASON\"] [TIME[d|h|m|s]]\n    {command} IP|NAME|STEAMID [team.]ban.reset\n    {command} IP|NAME|STEAMID [team.]cripple [\"REASON\"] [TIME[d|h|m|s]]\n    {command} IP|NAME|STEAMID [team.]cripple.reset\n    {command} IP|NAME|STEAMID [team.]kick [\"REASON\"]\n    {command} IP|NAME|STEAMID [team.]pardon\n    {command} IP|NAME|STEAMID [team.]unban\n    {command} IP|NAME|STEAMID [team.]uncripple</color></size>" },
                    { nameof(Key.CommandUserTeam), "<size=12><color=#c0ffc0>Team members:</color><color=#c0c0ff>{users}</color></size>" },
                    { nameof(Key.CommandUserTitle), "User Administration" },
                    { nameof(Key.CommandUserTooMany), "<size=12><color=#ffc0c0>Found multiple users:</color><color=#c0c0ff>{users}</color></size>" },
                    { nameof(Key.CommandVpn), "<size=12><color=#c0ffc0>{action} VPN check: </color><color=#c0c0ff>{info}</color></size>" },
                    { nameof(Key.CommandVpnSyntax), "<size=12><color=#ffc0c0>Syntax [optional]:</color><color=#c0c0ff>\n    {command} bypass IP\n    {command} status IP\n    {command} unblock IP</color></size>" },
                    { nameof(Key.CommandVpnTitle), "VPN Detection" },
                    { nameof(Key.connected), "connected" },
                    { nameof(Key.CONSOLE), "CONSOLE" },
                    { nameof(Key.Cooldown), "<color=#ffc0c0><size=12>{type} cooldown: {cooldown}s</size></color>" },
                    { nameof(Key.Crafting), "Crafting" },
                    { nameof(Key.CrippleCount), "Cripple Count" },
                    { nameof(Key.Crippled), "Crippled" },
                    { nameof(Key.crippled), "crippled" },
                    { nameof(Key.CrippleReason), "Cripple Reason" },
                    { nameof(Key.CrippleReset), "Reset cripple data for" },
                    { nameof(Key.Current), "Current" },
                    { nameof(Key.data), "data" },
                    { nameof(Key.Denied), "Denied" },
                    { nameof(Key.Detected), "Detected" },
                    { nameof(Key.DurationDay), "day" },
                    { nameof(Key.DurationDays), "days" },
                    { nameof(Key.DurationHour), "hour" },
                    { nameof(Key.DurationHours), "hours" },
                    { nameof(Key.DurationMinute), "minute" },
                    { nameof(Key.DurationMinutes), "minutes" },
                    { nameof(Key.DurationSecond), "second" },
                    { nameof(Key.DurationSeconds), "seconds" },
                    { nameof(Key.DurationSecondsUnit), "s" },
                    { nameof(Key.empty), "empty" },
                    { nameof(Key.Entity), "Entity" },
                    { nameof(Key.EntityAnimal), "Animal" },
                    { nameof(Key.EntityAutoTurret), "Auto Turret" },
                    { nameof(Key.EntityBear), "Bear" },
                    { nameof(Key.EntityBoar), "Boar" },
                    { nameof(Key.EntityBradley), "Bradley APC" },
                    { nameof(Key.EntityBuilding), "Building" },
                    { nameof(Key.EntityChicken), "Chicken" },
                    { nameof(Key.EntityFlameTurret), "Flame Turret" },
                    { nameof(Key.EntityGunTrap), "Shotgun Trap" },
                    { nameof(Key.EntityHelicopter), "Helicopter" },
                    { nameof(Key.EntityMurderer), "Murderer" },
                    { nameof(Key.EntityNPC), "NPC" },
                    { nameof(Key.EntityPlayer), "Player" },
                    { nameof(Key.EntitySAMSite), "SAM Site" },
                    { nameof(Key.EntityScientist), "Scientist" },
                    { nameof(Key.EntityStag), "Stag" },
                    { nameof(Key.EntityTC), "Tool Cupboard" },
                    { nameof(Key.EntityTrap), "Trap" },
                    { nameof(Key.file), "file" },
                    { nameof(Key.For), "for" },
                    { nameof(Key.idle), "idle" },
                    { nameof(Key.InvalidSteamId), "Invalid SteamID" },
                    { nameof(Key.IP), "IP" },
                    { nameof(Key.IpBlocked), "<color=#ffc000><size=12>IP: Blocked</size></color>" },
                    { nameof(Key.IpCooldown), "<color=#ffc000><size=12>IP: Cooldown</size></color>" },
                    { nameof(Key.Kicked), "Kicked" },
                    { nameof(Key.LogAntiCheatAim), "<color=#ffc000><size=12>Hit info for {playername}[{playerid}]: {target} ({bodypart}; {distance}m; r={range_variance}; a={angle_variance}; p={pvp_variance}; {speed}m/s) {weapon}</size></color>" },
                    { nameof(Key.LogAntiCheatGravity), "<color=#ffc000><size=12>Gravity info for {playername}[{playerid}]: {amount} {position}</size></color>" },
                    { nameof(Key.LogAntiCheatMeleeRate), "<color=#ffc000><size=12>Melee info for {playername}[{playerid}]: {weapon} ({delay}) - {target}</size></color>" },
                    { nameof(Key.LogAntiCheatRecoil), "<color=#ffc000><size=12>Recoil [y: {yaw}({count_x})][p: {pitch}({count_y})][a: {swing}] {playername}[{playerid}] - {weapon}</size></color>" },
                    { nameof(Key.LogAntiCheatServer), "<color=#ffc000><size=12>Server AntiHack violation for {playername}[{playerid}]: {type}({amount}) {position}{colliders}</size></color>" },
                    { nameof(Key.LogAntiCheatStash), "<color=#ffc000><size=12>Stash discovery info for {playername}[{playerid}]: at {grid}{position} - owner={ownerid}</size></color>" },
                    { nameof(Key.LogAntiCheatTrajectory), "<color=#ffc000><size=12>Trajectory [t: {trajectory}] {playername}[{playerid}]: {weapon}({distance}m - {reported}m)</size></color>" },
                    { nameof(Key.LogAntiSpamItemDrop), "<color=#ffc000><size=12>Item drop by player {playername}[{playerid}] - {itemname}[{itemid}]</size></color>" },
                    { nameof(Key.LogConnect), "<color=#ffc000><size=12>{action} connection for {playername}[{playerid}]: {type}({reason})</size></color>" },
                    { nameof(Key.LogDiscordConfig), "<color=#ffc0c0><size=12>Discord: WebHook URL is not configured!</size></color>" },
                    { nameof(Key.LogDiscordMessage), "<color=#ffc0c0><size=12>Discord: Message requires at least one \'content\' or one \'embed\' field!</size></color>" },
                    { nameof(Key.LogIpFilter), "<color=#ffc000><size=12>IP Filter: {action} connection from {address}</size></color>" },
                    { nameof(Key.LogSteam), "<color=#ffc0c0><size=12>Steam Check[{api}]: {type} error for {playername}[{playerid}] - {info}</size></color>" },
                    { nameof(Key.LogSteamConfig), "<color=#ffc0c0><size=12>Steam Check[{api}]: APIKEY missing! Get one from here: {link}</size></color>" },
                    { nameof(Key.LogUserBypass), "<color=#ffc000><size=12>User Bypass: {playername}[{playerid}](address={address}; banned {bantime}; played {playtime}) - {status}</size></color>" },
                    { nameof(Key.LogVpnCheck), "<color=#ffc000><size=12>VPN Check[{api}]: {address}({info})</size></color>" },
                    { nameof(Key.LogVpnCheckConfig), "<color=#ffc0c0><size=12>VPN Check[{api}]: APIKEY missing! Get one from here: {link}</size></color>" },
                    { nameof(Key.LogVpnCheckError), "<color=#ffc0c0><size=12>VPN Check[{api}]: {type} error for {address} - {info}</size></color>" },
                    { nameof(Key.LogWebHook), "<color=#ffc0c0><size=12>WebHook({category}): {type} error - {info}</size></color>" },
                    { nameof(Key.Name), "Name" },
                    { nameof(Key.never), "never" },
                    { nameof(Key.NoReasonGiven), "no reason given" },
                    { nameof(Key.NULL), "null" },
                    { nameof(Key.offline), "offline" },
                    { nameof(Key.OnAntiCheatTriggered), "{action} for {category} - {type}" },
                    { nameof(Key.online), "online" },
                    { nameof(Key.OxideGroups), "Oxide Groups" },
                    { nameof(Key.Pardoned), "Pardoned" },
                    { nameof(Key.permanently), "permanently" },
                    { nameof(Key.Played), "Played" },
                    { nameof(Key.remove), "remove" },
                    { nameof(Key.Removed), "Removed" },
                    { nameof(Key.Saved), "Saved" },
                    { nameof(Key.Server), "Server" },
                    { nameof(Key.SERVER), "SERVER" },
                    { nameof(Key.Status), "Status" },
                    { nameof(Key.Steam), "Steam" },
                    { nameof(Key.SteamBanActive), "VAC Banned" },
                    { nameof(Key.SteamBanCommunity), "Community Banned" },
                    { nameof(Key.SteamBanDays), "Days Since Ban" },
                    { nameof(Key.SteamBanEconomy), "Economy Banned" },
                    { nameof(Key.SteamBanGame), "Game Bans" },
                    { nameof(Key.SteamBanVAC), "VAC Bans" },
                    { nameof(Key.SteamGameCount), "Game Count" },
                    { nameof(Key.SteamGameHours), "Hours Played" },
                    { nameof(Key.SteamID), "SteamID" },
                    { nameof(Key.SteamProfileInvalid), "Invalid Profile" },
                    { nameof(Key.SteamProfileLimited), "Limited Profile" },
                    { nameof(Key.SteamProfilePrivate), "Private Profile" },
                    { nameof(Key.SteamShareFamily), "Family Share" },
                    { nameof(Key.True), "True" },
                    { nameof(Key.Unbanned), "Unbanned" },
                    { nameof(Key.Unblocked), "Unblocked" },
                    { nameof(Key.Uncrippled), "Uncrippled" },
                    { nameof(Key.unknown), "unknown" },
                    { nameof(Key.UnknownKey), "<color=#ffc0c0><size=12>Text error: language={language}]; key={key}</size></color>" },
                    { nameof(Key.UserAction), "<color=#ffc000><size=12>{actor}: {action} {playername}[{playerid}]</size></color>" },
                    { nameof(Key.UserBanTeleport), "<color=#c0ffc0><size=12>A banned player was teleported to your location!</size></color>" },
                    { nameof(Key.UserBanTeleported), "<color=#c0ffc0><size=12>Teleported {playername}[{playerid}] to {victim}.</size></color>" },
                    { nameof(Key.UserConnectBanInherit), "<color=#ffff00><size=12>You are banned from this server (Inherited: {reason})</size></color>" },
                    { nameof(Key.UserConnectSteamIdInvalid), "<color=#ffff00><size=12>Connection denied (SteamID: Invalid)</size></color>" },
                    { nameof(Key.UserConnectIpBlocked), "<color=#ffff00><size=12>Connection denied (IP: Blocked)</size></color>" },
                    { nameof(Key.UserInfoText), "<color=#c0c0ff><size=12>{info}</size></color>" },
                    { nameof(Key.UserInfoTextBullet), "<color=#c0c0ff><size=12>\n    - {info}</size></color>" },
                    { nameof(Key.UserInfoTextLabel), "<color=#c0c0ff><size=12>\n    {label}: {info}</size></color>" },
                    { nameof(Key.UserPardonProgress), "<size=12><color=#ffc000>Pardoned users: </color><color=#ffffc0>{count}/{total}</color></size>" },
                    { nameof(Key.Violation), "<color=#ffffc0><size=12>{action} {playername}[{playerid}] for {category}({type}): {details}</size></color>" },
                    { nameof(Key.ViolationAim), "<color=#ffffc0><size=12>{target}, {weapon}, {bodypart}, {distance}m, {angle}deg</size></color>" },
                    { nameof(Key.ViolationFireRate), "<color=#ffffc0><size=12>{weapon}, {delay}s</size></color>" },
                    { nameof(Key.ViolationGravity), "<color=#ffffc0><size=12>{amount}m</size></color>" },
                    { nameof(Key.ViolationMeleeRate), "<color=#ffffc0><size=12>{weapon}, {delay}s, {target}</size></color>" },
                    { nameof(Key.ViolationRecoil), "<color=#ffffc0><size=12>{weapon}, yaw={yaw}, pitch={pitch}</size></color>" },
                    { nameof(Key.ViolationStash), "<color=#ffffc0><size=12>{grid}{position}</size></color>" },
                    { nameof(Key.ViolationTrajectory), "<color=#ffffc0><size=12>{weapon}, {distance}m, {reported}m</size></color>" },
                    { nameof(Key.ViolationWallHack), "<color=#ffffc0><size=12>{weapon}, {target}</size></color>" },
                    { nameof(Key.VPN), "VPN" },
                    { nameof(Key.VpnCache), "VPN Cache" },
                    { nameof(Key.VpnDetected), "<color=#ffc000><size=12>VPN: Detected</size></color>" },
                    { nameof(Key.Warning), "Warning" }
                }, _instance, "en");
            }

            private static string Replace(string message, Dictionary<string, string> parameters = null)
            {
                if((message != null) && (parameters != null))
                {
                    foreach(var entry in parameters)
                    {
                        message = message.Replace('{' + entry.Key + '}', entry.Value);
                    }
                }

                return message;
            }

            private static string Strip(string message)
            {
                if(string.IsNullOrEmpty(message))
                {
                    return string.Empty;
                }

                return RegEx.markup.Replace(message, (match) =>
                {
                    var tag = match.Value.ToLower();

                    switch(tag)
                    {
                    case "<b>":
                    case "<i>":
                    case "</b>":
                    case "</color>":
                    case "</i>":
                    case "</size>":
                        return string.Empty;
                    }

                    if(tag.StartsWith("<color=") || tag.StartsWith("<size="))
                    {
                        return string.Empty;
                    }

                    return match.Value;
                });
            }

            public static string Sanitize(string message)
            {
                if(string.IsNullOrEmpty(message))
                {
                    return string.Empty;
                }

                message = RegEx.clean1.Replace(message, " ");
                message = RegEx.clean2.Replace(message, " ");

                return Trim(message);
            }

            private static string Trim(string message)
            {
                if(string.IsNullOrEmpty(message))
                {
                    return string.Empty;
                }

                return RegEx.spaces.Replace(message, " ").Trim();
            }

            public static void Unload()
            {
                RegEx.Unload();

                foreach(var language in decorated)
                {
                    language.Value.Clear();
                }

                decorated.Clear();

                foreach(var language in unadorned)
                {
                    language.Value.Clear();
                }

                unadorned.Clear();

                server_language = null;
            }
        }

        #endregion _text_

        #region _timers_

        private class Timers
        {
            private static readonly List<Timer> timers = new List<Timer>();

            public static void Add(float interval, Action callback)
            {
                timers.Add(_instance.timer.Every(interval, callback));
            }

            public static void Destroy()
            {
                foreach(var timer in timers)
                {
                    timer.Destroy();
                }

                timers.Clear();
            }
        }

        #endregion _timers_

        #region _user_

        private class User
        {
            public class Settings
            {
                public UserBypass Bypass;
                public UserFriend Friend;
                public UserTeam   Team;

                public Settings()
                {
                    Bypass = new UserBypass();
                    Friend = new UserFriend();
                    Team   = new UserTeam();
                }

                public class UserBypass
                {
                    public ulong DaysSinceBan;
                    public bool  Enabled;
                    public ulong HoursPlayed;
                    public bool  Multiply;

                    public UserBypass()
                    {
                        DaysSinceBan = 10ul;
                        HoursPlayed  =  6ul;
                    }

                    public void Validate()
                    {
                        Configuration.Clamp(ref DaysSinceBan, 1ul,  365ul);
                        Configuration.Clamp(ref HoursPlayed,  1ul, 8760ul);
                    }
                }

                public class UserFriend
                {
                    public bool Damage;
                }

                public class UserTeam
                {
                    public bool Damage;
                }

                public void Validate()
                {
                    Configuration.Validate(ref Bypass, () => new UserBypass(), () => Bypass.Validate());
                    Configuration.Validate(ref Friend, () => new UserFriend());
                    Configuration.Validate(ref Team,   () => new UserTeam());
                }
            }

            private class Info
            {
                public ulong           userid;
                public string          name;
                public HashSet<string> names;
                public string          address;
                public HashSet<string> addresses;

                public DateTime time_connected;
                public DateTime time_disconnected;
                public TimeSpan time_played;

                public ulong    ban_count;
                public string   ban_reason;
                public DateTime ban_time;
                public DateTime ban_timer;
                public bool     is_banned;

                public ulong    cripple_count;
                public string   cripple_reason;
                public DateTime cripple_time;
                public DateTime cripple_timer;
                public bool     is_crippled;

                public Vector3 l_position;
                public Vector3 v_position;

                [JsonIgnore] public DateTime     access_time;
                [JsonIgnore] public ulong        attacked;
                [JsonIgnore] public ulong        attacker;
                [JsonIgnore] public bool         dirty;
                [JsonIgnore] public BasePlayer   player;
                [JsonIgnore] public Stack<ulong> teleport;
                [JsonIgnore] public List<ulong>  victims;

                public Info()
                {
                    userid = 0;

                    name      = string.Empty;
                    names     = new HashSet<string>();
                    address   = string.Empty;
                    addresses = new HashSet<string>();

                    time_connected    = DateTime.MaxValue;
                    time_disconnected = DateTime.MinValue;
                    time_played       = TimeSpan.Zero;

                    ban_count  = 0;
                    ban_reason = string.Empty;
                    ban_time   = DateTime.MaxValue;
                    ban_timer  = DateTime.MinValue;
                    is_banned  = false;

                    cripple_count  = 0;
                    cripple_reason = string.Empty;
                    cripple_time   = DateTime.MaxValue;
                    cripple_timer  = DateTime.MinValue;
                    is_crippled    = false;

                    l_position = Vector3.zero;
                    v_position = Vector3.zero;

                    attacked = 0;
                    attacker = 0;
                    victims  = new List<ulong>();

                    dirty = true;
                }
            }

            private static readonly DataFile<string, HashSet<ulong>> names = new DataFile<string, HashSet<ulong>>("user_names");

            private static ActionQueue teleport;

            private static readonly Dictionary<ulong, Info> users = new Dictionary<ulong, Info>();

            private static void Action(IPlayer actor, Key action, Info user = null)
            {
                var parameters = new Dictionary<string, string>
                {
                    { "action", Text.GetPlain(action) },
                    { "actor", Text.Actor(actor) },
                    { "playerid", user?.userid.ToString() ?? "*" },
                    { "playername", Text.Sanitize(user?.name ?? Text.GetPlain(Key.AllUsers)) }
                };

                Log.Console(Key.UserAction, parameters);

                if(config.Admin.Broadcast)
                {
                    foreach(var player in BasePlayer.activePlayerList)
                    {
                        if(Permissions.Admin(player.userID))
                        {
                            parameters["action"]     = Text.GetPlain(action, player);
                            parameters["actor"]      = Text.Actor(actor, player);
                            parameters["playername"] = Text.Sanitize(user?.name ?? Text.GetPlain(Key.AllUsers, player));

                            Chat.Send(player, Key.UserAction, parameters);
                        }
                    }
                }
            }

            public static string Address(ulong userid)
            {
                return Load(userid).address;
            }

            public static void AssignAttacker(BasePlayer attacker, BasePlayer victim)
            {
                if((attacker == null) || attacker.IsAdmin || victim.IsAdmin || !victim.IsConnected)
                {
                    return;
                }

                if((attacker == victim) || (victim.lastDamage == DamageType.Bleeding))
                {
                    return;
                }

                if(IsTeamMate(attacker, victim) || IsFriend(attacker, victim.userID))
                {
                    return;
                }

                Load(attacker.userID).attacked = victim.userID;

                Load(victim.userID).attacker = attacker.userID;
            }

            public static void AssignVictim(BasePlayer victim)
            {
                var user = Load(victim.userID);

                if(victim.IsConnected && (user.attacker != 0))
                {
                    var attacker = Load(user.attacker);

                    attacker.victims.Remove(victim.userID);
                    attacker.victims.Add(victim.userID);
                }

                user.attacker = 0;
            }
            private static void AssignVictims(Info user)
            {
                user.teleport = new Stack<ulong>();

                if((user.attacked != 0) && !user.victims.Contains(user.attacked))
                {
                    user.teleport.Push(user.attacked);

                    user.attacked = 0;
                }

                foreach(var victim in user.victims)
                {
                    user.teleport.Push(victim);
                }

                user.victims.Clear();
            }

            public static void Ban(ulong userid, string reason = null, ulong seconds = 0, IPlayer actor = null)
            {
                var user = Load(userid);

                if(user.is_banned)
                {
                    if(actor == null)
                    {
                        return;
                    }

                    user.is_banned = false;

                    _instance.server.Command("unban", user.userid.ToString());
                }
                else
                {
                    user.ban_count++;
                }

                _instance.NextTick(() =>
                {
                    user.ban_reason = string.IsNullOrEmpty(reason) ? Text.GetPlain(Key.NoReasonGiven) : reason;
                    user.ban_time   = DateTime.UtcNow;
                    user.ban_timer  = (seconds == 0) ? DateTime.MaxValue : user.ban_time.AddSeconds(seconds);
                    user.is_banned  = true;

                    user.dirty = true;

                    Action(actor, Key.Banned, user);

                    _instance.server.Command("banid", user.userid.ToString(), user.name, user.ban_reason);
                });
            }

            public static ulong BanCount(ulong userid)
            {
                return Load(userid).ban_count;
            }

            private static void BanInherit(ulong userid, string name, string address, Info copy)
            {
                var user = Load(userid);

                Update(user, name, address);

                user.ban_count  = copy.ban_count;
                user.ban_reason = copy.ban_reason;
                user.ban_time   = copy.ban_time;
                user.ban_timer  = copy.ban_timer;
                user.is_banned  = copy.is_banned;

                user.time_connected    = DateTime.UtcNow;
                user.time_disconnected = user.time_connected;

                user.dirty = true;

                Action(null, Key.Banned, user);

                _instance.server.Command("banid", user.userid.ToString(), user.name, user.ban_reason);
            }

            public static void BanReset(ulong userid, IPlayer actor = null)
            {
                var user = Load(userid);

                var was_banned = user.is_banned;

                user.ban_count  = 0;
                user.ban_reason = string.Empty;
                user.ban_time   = DateTime.MaxValue;
                user.ban_timer  = DateTime.MinValue;
                user.is_banned  = false;

                user.dirty = true;

                Action(actor, Key.BanReset, user);

                if(was_banned)
                {
                    _instance.server.Command("unban", user.userid.ToString());
                }
            }

            private static void BanTeleport(Info user, ulong count = 0)
            {
                Info victim = null;

                while((victim == null) && (user.teleport.Count > 0))
                {
                    victim = Load(user.teleport.Peek());

                    if(!(victim.player?.IsConnected ?? false))
                    {
                        count = 0; victim = null;

                        user.teleport.Pop();
                    }
                }

                if(victim == null)
                {
                    return;
                }

                user.access_time = DateTime.UtcNow;

                if(victim.player.IsSleeping() || victim.player.IsDead() || victim.player.HasParent())
                {
                    if(count < 10)
                    {
                        teleport.Enqueue(() => BanTeleport(user, count + 1));
                    }
                    else
                    {
                        user.teleport.Pop();

                        if(user.teleport.Count > 0)
                        {
                            teleport.Enqueue(() => BanTeleport(user));
                        }
                    }

                    return;
                }

                var attacker = BasePlayer.FindAwakeOrSleeping(user.userid.ToString());

                if(attacker == null)
                {
                    return;
                }

                var position = attacker.transform.position; position.y += 0.1f;

                RaycastHit hit;

                if(Physics.Raycast(position, Vector3.down, out hit))
                {
                    position.y -= hit.distance;
                }

                attacker.MovePosition(position);

                attacker.ClientRPCPlayer(null, attacker, "ForcePositionTo", position);

                attacker.SendNetworkUpdateImmediate();

                Chat.Admin(Key.UserBanTeleported, new Dictionary<string, string>
                {
                    { "playerid", user.userid.ToString() },
                    { "playername", Text.Sanitize(user.name) },
                    { "victim", Text.Sanitize(victim.name) }
                });

                Chat.Send(victim.player, Key.UserBanTeleport);
            }

            public static DateTime BanTime(ulong userid)
            {
                return Load(userid).ban_time;
            }

            private static void BanTimeEnforce(Info user)
            {
                if(!config.Ban.Time.Enforce)
                {
                    return;
                }

                var seconds = 0ul;

                if(config.Ban.Time.Seconds > 0)
                {
                    seconds = config.Ban.Time.Seconds;

                    if(config.Ban.Time.Multiply)
                    {
                        seconds *= user.ban_count;
                    }
                }

                if(seconds == 0)
                {
                    user.ban_timer = DateTime.MaxValue;
                }
                else
                {
                    user.ban_timer = user.ban_time.AddSeconds(seconds);
                }

                user.dirty = true;
            }

            private static bool CanBypass(Info user)
            {
                if(Permissions.Ignore(user.userid) || (config.Admin.Bypass && Permissions.Admin(user.userid)))
                {
                    return true;
                }
                else if(!config.User.Bypass.Enabled)
                {
                    return false;
                }

                bool never_banned = true;

                var days_since_banned = 0.0;

                var date_current = DateTime.UtcNow;

                var time_banned = TimeSpan.MaxValue;

                if(user.ban_time < date_current)
                {
                    time_banned = date_current.Subtract(user.ban_time);

                    days_since_banned = time_banned.TotalDays;

                    never_banned = false;
                }

                var time_played = TimePlayed(user);

                var hours_played = time_played.TotalHours;

                bool bypass = false;

                var days_banned_minimum  = config.User.Bypass.DaysSinceBan;
                var hours_played_minimum = config.User.Bypass.HoursPlayed;

                if(config.User.Bypass.Multiply)
                {
                    var multiplier = user.ban_count + 1;

                    days_banned_minimum  *= multiplier;
                    hours_played_minimum *= multiplier;
                }

                if(hours_played >= hours_played_minimum)
                {
                    bypass = never_banned || (days_since_banned >= days_banned_minimum);
                }

                if(config.Log.User.Bypass)
                {
                    Log.Console(Key.LogUserBypass, new Dictionary<string, string>
                    {
                        { "address", user.address },
                        { "bantime", never_banned ? Text.Get(Key.never) : $"{Text.Duration.Short(time_banned)} {Text.Get(Key.ago)}" },
                        { "playerid", user.userid.ToString() },
                        { "playername", Text.Sanitize(user.name) },
                        { "playtime", Text.Duration.Hours(time_played) },
                        { "status", bypass ? Text.Get(Key.Allowed) : Text.Get(Key.Denied) }
                    });
                }

                return bypass;
            }

            public static object CanConnect(string name, string id, string address)
            {
                if(IP.Cooldown(address))
                {
                    return Text.GetPlain(Key.IpCooldown);
                }

                ulong userid;

                if(!id.StartsWith("7656119") || !ulong.TryParse(id, out userid))
                {
                    if(config.Log.User.Connect)
                    {
                        Log.Console(Key.LogConnect, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Denied) },
                            { "playerid", id },
                            { "playername", Text.Sanitize(name) },
                            { "reason", address },
                            { "type", Text.GetPlain(Key.InvalidSteamId) }
                        });
                    }

                    return Text.GetPlain(Key.UserConnectSteamIdInvalid, Text.Language(id));
                }

                if(Permissions.Ignore(userid, true))
                {
                    return null;
                }

                else if(Permissions.Admin(userid, true) && config.Admin.Bypass)
                {
                    return null;
                }

                if(!IP.Filter(address, userid))
                {
                    if(config.Log.User.Connect)
                    {
                        Log.Console(Key.LogConnect, new Dictionary<string, string>
                        {
                            { "action", Text.GetPlain(Key.Denied) },
                            { "playerid", id },
                            { "playername", Text.Sanitize(name) },
                            { "reason", address },
                            { "type", Text.GetPlain(Key.Blocked) }
                        });
                    }

                    return Text.GetPlain(Key.UserConnectIpBlocked, userid);
                }

                var cripple_inherit = config.Cripple.Inherit && !IsCrippled(userid);

                if(config.Ban.Inherit || cripple_inherit)
                {
                    var userids = IP.Find(address);

                    if(cripple_inherit)
                    {
                        foreach(var entry in userids)
                        {
                            var user = Load(entry);

                            if(user.is_crippled)
                            {
                                _instance.NextTick(() => CrippleInherit(userid, name, address, user));

                                break;
                            }
                        }
                    }

                    if(config.Ban.Inherit)
                    {
                        foreach(var entry in userids)
                        {
                            var user = Load(entry);

                            if(user.is_banned)
                            {
                                if(config.Log.User.Connect)
                                {
                                    Log.Console(Key.LogConnect, new Dictionary<string, string>
                                    {
                                        { "action", Text.GetPlain(Key.Denied) },
                                        { "playerid", id },
                                        { "playername", Text.Sanitize(name) },
                                        { "reason", user.ban_reason },
                                        { "type", Text.GetPlain(Key.BanInherited) }
                                    });
                                }

                                _instance.NextTick(() => BanInherit(userid, name, address, user));

                                return Text.GetPlain(Key.UserConnectBanInherit, userid, new Dictionary<string, string>
                                {
                                    { "reason", user.ban_reason }
                                });
                            }
                        }
                    }
                }

                return null;
            }

            public static bool CanFly(BasePlayer player) =>
                HasAuthLevel(player) || HasAdminFlag(player) || HasDeveloperFlag(player);

            private static bool CanLoot(ulong userid, ulong targetid)
            {
                if(userid == targetid)
                {
                    return true;
                }

                if(IsCrippled(userid))
                {
                    if(Permissions.Ignore(userid) || Permissions.Admin(userid))
                    {
                        return true;
                    }

                    return false;
                }

                return true;
            }
            public static object CanLoot(BasePlayer player, ulong targetid)
            {
                if(ShouldIgnore(player) || CanLoot(player.userID, targetid))
                {
                    return null;
                }

                return false;
            }

            public static void Cripple(ulong userid, string reason = null, ulong seconds = 0, IPlayer actor = null)
            {
                var user = Load(userid);

                if(!user.is_crippled)
                {
                    user.cripple_count++;
                }

                user.cripple_reason = string.IsNullOrEmpty(reason) ? Text.GetPlain(Key.NoReasonGiven) : reason;
                user.cripple_time   = DateTime.UtcNow;
                user.cripple_timer  = (seconds == 0) ? DateTime.MaxValue : user.cripple_time.AddSeconds(seconds);

                user.is_crippled = true;

                user.dirty = true;

                Action(actor, Key.Crippled, user);
            }

            private static void CrippleInherit(ulong userid, string name, string address, Info copy)
            {
                var user = Load(userid);

                Update(user, name, address);

                user.cripple_count  = copy.cripple_count;
                user.cripple_reason = copy.cripple_reason;
                user.cripple_time   = copy.cripple_time;
                user.cripple_timer  = copy.cripple_timer;
                user.is_crippled    = copy.is_crippled;

                user.dirty = true;

                Action(null, Key.Crippled, user);
            }

            public static void CrippleReset(ulong userid, IPlayer actor = null)
            {
                var user = Load(userid);

                user.cripple_count  = 0;
                user.cripple_reason = string.Empty;
                user.cripple_time   = DateTime.MaxValue;
                user.cripple_timer  = DateTime.MinValue;
                user.is_crippled    = false;

                user.dirty = true;

                Action(actor, Key.CrippleReset, user);
            }

            public static bool Exists(ulong userid) =>
                users.ContainsKey(userid) || Data.Exists($"Users/{userid}");

            public static HashSet<ulong> Find(string text)
            {
                var found = new HashSet<ulong>();

                if(IP.IsValid(text))
                {
                    foreach(var userid in IP.Find(text))
                    {
                        found.Add(userid);
                    }
                }
                else if(text.IsSteamId())
                {
                    ulong userid;

                    if(ulong.TryParse(text, out userid) && Exists(userid))
                    {
                        found.Add(userid);
                    }
                }
                else
                {
                    var key = text.Sanitize();

                    if(names.Contains(key))
                    {
                        foreach(var userid in names[key])
                        {
                            found.Add(userid);
                        }
                    }
                    else
                    {
                        var search = key.ToLower();

                        names.ForEach((name, userids) =>
                        {
                            if(name.ToLower().Contains(search))
                            {
                                foreach(var userid in userids)
                                {
                                    found.Add(userid);
                                }
                            }
                        });
                    }
                }

                return found;
            }

            public static Vector3 GetLastSeenPosition(ulong userid)
            {
                var player = BasePlayer.FindAwakeOrSleeping(userid.ToString());

                if(player != null)
                {
                    return player.transform.position;
                }

                return Load(userid).l_position;
            }

            public static Vector3 GetViolationPosition(ulong userid) =>
                Load(userid).v_position;

            public static bool HasAuthLevel(BasePlayer player) =>
                (player?.net?.connection?.authLevel ?? 0) > 0;

            public static bool HasAdminFlag(BasePlayer player) =>
                player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin);

            private static bool HasConnected(Info user) =>
                user.time_connected != DateTime.MaxValue;

            public static bool HasDeveloperFlag(BasePlayer player) =>
                player.HasPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper);

            public static bool HasParent<T>(BasePlayer player) =>
                player.GetParentEntity() is T;

            public static string InfoText(ulong userid) =>
                InfoText(userid, Text.Language());
            public static string InfoText(ulong userid, BasePlayer player) =>
                InfoText(userid, Text.Language(player.UserIDString));
            public static string InfoText(ulong userid, IPlayer iplayer) =>
                InfoText(userid, Text.Language(iplayer.IsServer ? null : iplayer.Id));
            public static string InfoText(ulong userid, ulong playerid) =>
                InfoText(userid, Text.Language(playerid.ToString()));
            public static string InfoText(ulong userid, string language)
            {
                if(!Exists(userid))
                {
                    return Text.GetPlain(Key.unknown, language);
                }

                var user = Load(userid);

                var info = new StringBuilder();

                var parameters = new Dictionary<string, string>();

                parameters["label"] = Text.GetPlain(Key.SteamID, language);
                parameters["info"] = user.userid.ToString();
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                parameters["label"] = Text.GetPlain(Key.Name, language);
                parameters["info"] = Text.Sanitize(user.name);
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));
                if(user.names.Count > 1)
                {
                    foreach(var name in user.names)
                    {
                        if(name != user.name)
                        {
                            parameters["info"] = Text.Sanitize(name);
                            info.Append(Text.GetPlain(Key.UserInfoTextBullet, language, parameters));
                        }
                    }
                }

                parameters["label"] = Text.GetPlain(Key.Played, language);
                parameters["info"] = Text.Duration.Hours(TimePlayed(user), language);
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                parameters["label"] = Text.GetPlain(Key.Status, language);
                parameters["info"] = StatusText(user, language);
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                if(user.ban_count > 0)
                {
                    parameters["label"] = Text.GetPlain(Key.BanCount, language);
                    parameters["info"] = user.ban_count.ToString();
                    info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                    if(user.is_banned)
                    {
                        parameters["label"] = Text.GetPlain(Key.BanReason, language);
                        parameters["info"] = user.ban_reason;
                        info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));
                    }
                }

                if(user.cripple_count > 0)
                {
                    parameters["label"] = Text.GetPlain(Key.CrippleCount, language);
                    parameters["info"] = user.cripple_count.ToString();
                    info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                    if(user.is_crippled)
                    {
                        parameters["label"] = Text.GetPlain(Key.CrippleReason, language);
                        parameters["info"] = user.cripple_reason;
                        info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));
                    }
                }

                parameters["label"] = Text.GetPlain(Key.Address, language);
                parameters["info"] = user.address;
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));
                if(user.addresses.Count > 1)
                {
                    foreach(var address in user.addresses)
                    {
                        if(address != user.address)
                        {
                            parameters["info"] = address;
                            info.Append(Text.GetPlain(Key.UserInfoTextBullet, language, parameters));
                        }
                    }
                }

                parameters["label"] = Text.GetPlain(Key.OxideGroups, language);
                parameters["info"] = string.Join(", ", Permissions.Groups(user.userid));
                info.Append(Text.GetPlain(Key.UserInfoTextLabel, language, parameters));

                parameters["info"] = info.ToString();
                return Text.GetPlain(Key.UserInfoText, language, parameters);
            }

            public static bool IsBanned(ulong userid) =>
                Load(userid).is_banned;

            private static bool IsConnected(Info user) =>
                user.player?.IsConnected ?? false;
            public static bool IsConnected(ulong userid)
            {
                Info user;

                if(users.TryGetValue(userid, out user))
                {
                    return IsConnected(user);
                }

                return false;
            }

            public static bool IsCrippled(ulong userid) =>
                Load(userid).is_crippled;

            public static bool IsFriend(BasePlayer a, BasePlayer b) =>
                IsFriend(a, b.userID);
            public static bool IsFriend(BasePlayer player, ulong userid) =>
                (_instance?.Friends?.Call<bool>("IsFriend", player.userID, userid) ?? false);

            public static bool IsInactive(BasePlayer player) =>
                player.IsDead() || player.IsSleeping() || !player.IsConnected;

            private static bool IsStale(Info user) =>
                !(HasConnected(user) && (user.time_connected > SaveRestore.SaveCreatedTime.ToUniversalTime()));

            public static bool IsTeamMate(BasePlayer a, BasePlayer b)
                => (a.currentTeam != 0) && (a.currentTeam == b.currentTeam);
            public static bool IsTeamMate(BasePlayer player, ulong userid)
            {
                var team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);

                return team?.members?.Contains(userid) ?? false;
            }

            public static void Kick(ulong userid, string reason = null, IPlayer actor = null)
            {
                var user = Load(userid);

                if(IsConnected(user))
                {
                    reason = string.IsNullOrEmpty(reason) ? Text.GetPlain(Key.NoReasonGiven) : reason;

                    if(actor != null)
                    {
                        Action(actor, Key.Kicked, user);
                    }

                    _instance.server.Command("kick", user.userid.ToString(), reason);
                }
            }

            public static void Load()
            {
                names.Load();

                teleport = new ActionQueue(6.0f);

                Timers.Add(6.0f, () => Scan());
            }
            private static Info Load(ulong userid)
            {
                Info user;

                if(!userid.IsSteamId())
                {
                    throw new ArgumentException("Parameter must be a valid Steam ID", nameof(userid));
                }
                else if(users.ContainsKey(userid))
                {
                    user = users[userid];
                }
                else
                {
                    try
                    {
                        user = Data.ReadObject<Info>($"Users/{userid}");

                        if((user?.userid ?? 0) == 0)
                        {
                            throw new Exception();
                        }
                    }
                    catch
                    {
                        user = new Info
                        {
                            dirty  = true,
                            userid = userid
                        };
                    }

                    if(user.name == null)
                    {
                        user.dirty = true; user.name = string.Empty;
                    }

                    if(user.names == null)
                    {
                        user.dirty = true; user.names = new HashSet<string>();
                    }

                    if(user.address == null)
                    {
                        user.dirty = true; user.address = string.Empty;
                    }

                    if(user.addresses == null)
                    {
                        user.dirty = true; user.addresses = new HashSet<string>();
                    }

                    if(user.ban_reason == null)
                    {
                        user.dirty = true; user.ban_reason = string.Empty;
                    }

                    if(user.cripple_reason == null)
                    {
                        user.dirty = true; user.cripple_reason = string.Empty;
                    }

                    if(IsStale(user))
                    {
                        SetLastSeenPosition(user, Vector3.zero);
                        SetViolationPosition(user, Vector3.zero);
                    }

                    users.Add(userid, user);

                    Save(user);
                }

                user.access_time = DateTime.UtcNow;

                return user;
            }

            public static string Name(ulong userid) =>
                Load(userid).name;

            public static void OnBanned(ulong userid, bool banned)
            {
                var user = Load(userid);

                if(banned)
                {
                    if(!user.is_banned)
                    {
                        var serveruser = ServerUsers.Get(userid);

                        user.ban_count++;
                        user.ban_reason = string.IsNullOrEmpty(serveruser.notes) ? Text.GetPlain(Key.NoReasonGiven) : serveruser.notes;
                        user.ban_time = DateTime.UtcNow;
                        user.is_banned = true;

                        if(serveruser.expiry < 0)
                        {
                            user.ban_timer = DateTime.MaxValue;
                        }
                        else
                        {
                            user.ban_timer = user.ban_time.AddSeconds(serveruser.expiry - Epoch.Current);
                        }

                        user.dirty = true;
                    }

                    BanTimeEnforce(user);

                    if(config.Ban.Teleport)
                    {
                        AssignVictims(user);

                        if(user.teleport.Count > 0)
                        {
                            _instance.timer.In(6.0f, () => BanTeleport(user));
                        }
                    }
                }
                else
                {
                    if(user.is_banned && config.Ban.Time.Enforce)
                    {
                        if((user.ban_timer != DateTime.MaxValue) && (user.ban_timer > DateTime.UtcNow))
                        {
                            _instance.server.Command("banid", user.userid.ToString(), user.name, user.ban_reason);

                            return;
                        }
                    }

                    if(user.ban_count == 0)
                    {
                        user.ban_time = DateTime.MaxValue;
                    }

                    user.ban_reason = string.Empty;
                    user.ban_timer  = DateTime.MinValue;
                    user.is_banned  = false;

                    user.dirty = true;
                }
            }

            public static void OnConnected(BasePlayer player)
            {
                var user = Load(player.userID);

                var connected = TimeSpan.FromSeconds(user.player?.net?.connection?.GetSecondsConnected() ?? 0.0f);

                user.time_connected = DateTime.UtcNow.Subtract(connected);

                if(user.is_banned)
                {
                    user.is_banned = false;

                    user.ban_reason = string.Empty;
                    user.ban_timer  = DateTime.MinValue;
                }

                if(_instance.PlaytimeTracker)
                {
                    var result = _instance.PlaytimeTracker.Call("GetPlayTime", player.UserIDString);

                    if(result != null)
                    {
                        var time_played = TimeSpan.FromSeconds(Convert.ToDouble(result));

                        if(time_played > user.time_played)
                        {
                            user.time_played = time_played;
                        }
                    }
                }

                user.player = player;

                Update(user, player.displayName, IP.Parse(player?.Connection?.ipaddress));

                user.dirty = true;

                Permissions.Update(user.userid);

                if(!CanBypass(user))
                {
                    Steam.Check(user.userid);

                    VPN.Check(user.address, user.userid);
                }
            }

            public static void OnDisconnected(BasePlayer player)
            {
                var user = Load(player.userID);

                user.time_disconnected = DateTime.UtcNow;

                if(user.time_disconnected > user.time_connected)
                {
                    user.time_played += user.time_disconnected.Subtract(user.time_connected);
                }

                user.player = null;

                SetLastSeenPosition(user, player.transform.position);

                user.dirty = true;

                Permissions.Reset(user.userid);
            }

            public static void OnLoot(BasePlayer player, ulong targetid)
            {
                if(ShouldIgnore(player))
                {
                    return;
                }

                if(!CanLoot(player.userID, targetid))
                {
                    _instance.NextFrame(() => player.EndLooting());
                }
            }

            public static void Pardon(ulong userid, IPlayer actor = null) =>
                Pardon(Load(userid), actor);
            public static void Pardon(IPlayer actor)
            {
                var found = new HashSet<ulong>();

                names.ForEach((name, userids) =>
                {
                    found.UnionWith(userids);
                });

                var userid = new Queue<ulong>(found);

                Pardon(userid, actor);
            }
            private static void Pardon(Queue<ulong> userid, IPlayer actor, int total = 0)
            {
                if(total == 0)
                {
                    total = userid.Count;
                }

                if(userid.Count > 0)
                {
                    var user = Load(userid.Dequeue());

                    Pardon(user, actor, false);

                    Save(user);

                    var count = total - userid.Count;

                    if((count % ((total <= 100) ? 10 : 100)) == 0)
                    {
                        Chat.Reply(actor, Key.UserPardonProgress, new Dictionary<string, string>
                        {
                            { "count", count.ToString() },
                            { "total", total.ToString() }
                        });
                    }

                    _instance.NextTick(() => Pardon(userid, actor, total));
                }
                else
                {
                    if(total > 0)
                    {
                        Chat.Reply(actor, Key.UserPardonProgress, new Dictionary<string, string>
                        {
                            { "count", total.ToString() },
                            { "total", total.ToString() }
                        });
                    }

                    Action(actor, Key.Pardoned);
                }
            }
            private static void Pardon(Info user, IPlayer actor, bool broadcast = true)
            {
                if(user.is_banned)
                {
                    if(user.ban_count > 1)
                    {
                        user.dirty = true; user.ban_count = 1;

                        BanTimeEnforce(user);
                    }
                }
                else
                {
                    if(user.ban_count != 0)
                    {
                        user.dirty = true; user.ban_count = 0;
                    }

                    if(user.ban_time != DateTime.MaxValue)
                    {
                        user.dirty = true; user.ban_time = DateTime.MaxValue;
                    }

                    if(user.ban_timer != DateTime.MinValue)
                    {
                        user.dirty = true; user.ban_timer = DateTime.MinValue;
                    }
                }

                if(user.is_crippled)
                {
                    if(user.cripple_count > 1)
                    {
                        user.dirty = true; user.cripple_count = 1;
                    }
                }
                else
                {
                    if(user.cripple_count != 0)
                    {
                        user.dirty = true; user.cripple_count = 0;
                    }

                    if(user.cripple_time != DateTime.MaxValue)
                    {
                        user.dirty = true; user.cripple_time = DateTime.MaxValue;
                    }

                    if(user.cripple_timer != DateTime.MinValue)
                    {
                        user.dirty = true; user.cripple_timer = DateTime.MinValue;
                    }
                }

                if(broadcast)
                {
                    Action(actor, Key.Pardoned, user);
                }
            }

            public static void Save()
            {
                var current = DateTime.UtcNow;

                var expired = TimeSpan.FromMinutes(30.0);

                var remove = new List<ulong>();

                foreach(var entry in users)
                {
                    Save(entry.Value);

                    if(current.Subtract(entry.Value.access_time) >= expired)
                    {
                        remove.Add(entry.Key);
                    }
                }

                foreach(var entry in remove)
                {
                    users.Remove(entry);
                }

                names.Save();
            }
            private static void Save(Info user)
            {
                if(user.dirty)
                {
                    user.dirty = false;

                    Data.WriteObject($"Users/{user.userid}", user);
                }
            }

            private static void Scan()
            {
                var current = DateTime.UtcNow;

                foreach(var entry in users)
                {
                    var user = entry.Value;

                    if(user.is_banned && (user.ban_timer != DateTime.MaxValue))
                    {
                        if(user.ban_timer > current)
                        {
                            user.access_time = current;
                        }
                        else
                        {
                            Unban(user.userid);
                        }
                    }
                    else if(user.is_crippled && (user.cripple_timer != DateTime.MaxValue))
                    {
                        if(user.cripple_timer > current)
                        {
                            user.access_time = current;
                        }
                        else
                        {
                            Uncripple(user.userid);
                        }
                    }
                }
            }

            private static void SetLastSeenPosition(Info user, Vector3 position)
            {
                if(user.l_position != position)
                {
                    user.l_position = position;

                    user.dirty = true;
                }
            }

            private static void SetViolationPosition(Info user, Vector3 position)
            {
                if(user.v_position != position)
                {
                    user.v_position = position;

                    user.dirty = true;
                }
            }
            public static void SetViolationPosition(ulong userid)
            {
                Info user;

                if(users.TryGetValue(userid, out user))
                {
                    if(user.player != null)
                    {
                        SetViolationPosition(user, user.player.transform.position);
                    }
                }
            }

            public static bool ShouldIgnore(BasePlayer player) =>
                (player == null) || !player.userID.IsSteamId() || Permissions.Ignore(player.userID);

            public static string StatusText(ulong userid) =>
                StatusText(userid, Text.Language());
            public static string StatusText(ulong userid, BasePlayer player) =>
                StatusText(userid, Text.Language(player.UserIDString));
            public static string StatusText(ulong userid, IPlayer iplayer) =>
                StatusText(userid, Text.Language(iplayer.IsServer ? null : iplayer.Id));
            public static string StatusText(ulong userid, ulong playerid) =>
                StatusText(userid, Text.Language(playerid.ToString()));
            public static string StatusText(ulong userid, string language) =>
                Exists(userid) ? StatusText(Load(userid), language) : Text.GetPlain(Key.unknown, language);
            private static string StatusText(Info user, string language)
            {
                StringBuilder status = new StringBuilder();

                TimeSpan duration;

                if(user.is_banned)
                {
                    status.Append(Text.GetPlain(Key.banned, language));
                    status.Append(' ');

                    if(TimeSpan.MaxValue == (duration = TimeBanned(user)))
                    {
                        status.Append(Text.GetPlain(Key.permanently, language));
                    }
                    else
                    {
                        status.Append(Text.Duration.Short(duration, language));
                    }
                }
                else if(user.is_crippled)
                {
                    status.Append(Text.GetPlain(Key.crippled, language));
                    status.Append(' ');

                    if(TimeSpan.MaxValue == (duration = TimeCrippled(user)))
                    {
                        status.Append(Text.GetPlain(Key.permanently, language));
                    }
                    else
                    {
                        status.Append(Text.Duration.Short(duration, language));
                    }
                }
                else if(user.player?.IsConnected ?? false)
                {
                    status.Append(Text.GetPlain(Key.online, language));
                    status.Append(' ');

                    if(TimeSpan.MaxValue == (duration = TimeOnline(user)))
                    {
                        status.Append(Text.GetPlain(Key.never, language));
                    }
                    else
                    {
                        status.Append(Text.Duration.Short(duration, language));
                    }
                }
                else
                {
                    status.Append(Text.GetPlain(Key.offline, language));
                    status.Append(' ');

                    if(TimeSpan.MaxValue == (duration = TimeOffline(user)))
                    {
                        status.Append(Text.GetPlain(Key.never, language));
                    }
                    else
                    {
                        status.Append(Text.Duration.Short(duration, language));
                    }
                }

                return status.ToString();
            }

            public static List<ulong> Team(ulong userid)
            {
                ulong teamid = 0;

                var player = Load(userid).player;

                if(player != null)
                {
                    teamid = player.currentTeam;
                }
                else
                {
                    foreach(var team in RelationshipManager.ServerInstance.teams)
                    {
                        if(team.Value.members.Contains(userid))
                        {
                            teamid = team.Key;

                            break;
                        }
                    }
                }

                if(teamid != 0)
                {
                    return new List<ulong>(RelationshipManager.ServerInstance.teams[teamid].members);
                }

                return new List<ulong> { userid };
            }

            public static TimeSpan TimeBanned(ulong userid) =>
                TimeRemaining(Load(userid).ban_timer);
            private static TimeSpan TimeBanned(Info user) =>
                TimeRemaining(user.ban_timer);
            public static TimeSpan TimeCrippled(ulong userid) =>
                TimeRemaining(Load(userid).cripple_timer);
            private static TimeSpan TimeCrippled(Info user) =>
                TimeRemaining(user.cripple_timer);
            private static TimeSpan TimeRemaining(DateTime time)
            {
                if(time == DateTime.MaxValue)
                {
                    return TimeSpan.MaxValue;
                }

                var current = DateTime.UtcNow;

                if(time > current)
                {
                    return time.Subtract(current);
                }

                return TimeSpan.Zero;
            }

            public static TimeSpan TimeOffline(ulong userid) =>
                TimeSpent(Load(userid).time_disconnected);
            private static TimeSpan TimeOffline(Info user) =>
                TimeSpent(user.time_disconnected);
            public static TimeSpan TimeOnline(ulong userid) =>
                TimeSpent(Load(userid).time_connected);
            private static TimeSpan TimeOnline(Info user) =>
                TimeSpent(user.time_connected);
            private static TimeSpan TimeSpent(DateTime time)
            {
                if((time == DateTime.MaxValue) || (time == DateTime.MinValue))
                {
                    return TimeSpan.MaxValue;
                }

                var current = DateTime.UtcNow;

                if(time < current)
                {
                    return current.Subtract(time);
                }

                return TimeSpan.Zero;
            }

            public static TimeSpan TimePlayed(ulong userid) =>
                TimePlayed(Load(userid));
            private static TimeSpan TimePlayed(Info user)
            {
                var time_played = user.time_played;

                if(user.time_disconnected > user.time_connected)
                {
                    time_played += user.time_disconnected.Subtract(user.time_connected);
                }
                else if(user.player?.IsConnected ?? false)
                {
                    time_played += DateTime.UtcNow.Subtract(user.time_connected);
                }

                return time_played;
            }

            public static void Unban(ulong userid, bool manual = false, IPlayer actor = null) =>
                Unban(Load(userid), manual, actor);
            public static void Unban(IPlayer actor)
            {
                foreach(var entry in users)
                {
                    var user = entry.Value;

                    if(user.is_banned)
                    {
                        Unban(user, false, actor, false);
                    }
                }

                Action(actor, Key.Unbanned);
            }
            private static void Unban(Info user, bool manual, IPlayer actor, bool broadcast = true)
            {
                if(user.is_banned)
                {
                    if(manual)
                    {
                        user.ban_count -= (user.ban_count > 0) ? 1ul : 0ul;
                    }

                    user.is_banned = false;

                    user.dirty = true;

                    if(broadcast)
                    {
                        Action(actor, Key.Unbanned, user);
                    }

                    _instance.server.Command("unban", user.userid.ToString());
                }
            }

            public static void Uncripple(ulong userid, bool manual = false, IPlayer actor = null) =>
                Uncripple(Load(userid), manual, actor);
            public static void Uncripple(IPlayer actor)
            {
                foreach(var entry in users)
                {
                    var user = entry.Value;

                    if(user.is_crippled)
                    {
                        Uncripple(user, false, actor, false);
                    }
                }

                Action(actor, Key.Uncrippled);
            }
            private static void Uncripple(Info user, bool manual, IPlayer actor, bool broadcast = true)
            {
                if(user.is_crippled)
                {
                    if(manual)
                    {
                        user.cripple_count -= (user.cripple_count > 0) ? 1ul : 0ul;
                    }

                    user.cripple_reason = string.Empty;
                    user.cripple_timer = DateTime.MinValue;

                    user.is_crippled = false;

                    user.dirty = true;

                    if(broadcast)
                    {
                        Action(actor, Key.Uncrippled, user);
                    }
                }
            }

            public static void Unload()
            {
                foreach(var player in BasePlayer.activePlayerList)
                {
                    if(player.IsConnected)
                    {
                        OnDisconnected(player);
                    }
                }

                foreach(var player in BasePlayer.sleepingPlayerList)
                {
                    if(player.IsConnected)
                    {
                        OnDisconnected(player);
                    }
                }

                Save();

                names.Unload();
                users.Clear();

                teleport.Clear();
                teleport = null;
            }

            public static void Update()
            {
                _instance.NextTick(() =>
                {
                    foreach(var player in BasePlayer.activePlayerList)
                    {
                        if(player.IsConnected)
                        {
                            OnConnected(player);
                        }
                    }

                    foreach(var player in BasePlayer.sleepingPlayerList)
                    {
                        if(player.IsConnected)
                        {
                            OnConnected(player);
                        }
                    }

                    foreach(var serveruser in ServerUsers.GetAll(ServerUsers.UserGroup.Banned))
                    {
                        OnBanned(serveruser.steamid, true);
                    }
                });
            }
            private static void Update(Info user, string name, string address)
            {
                if(user.name != name)
                {
                    user.dirty = true; user.name = name;
                }

                if(user.names.Add(name))
                {
                    user.dirty = true;
                }

                if(!names.Contains(name))
                {
                    names.Add(name, new HashSet<ulong>());
                }

                if(names[name].Add(user.userid))
                {
                    names.SetDirty();
                }

                if(!string.IsNullOrEmpty(address = address ?? user.address))
                {
                    if(user.address != address)
                    {
                        user.dirty = true; user.address = address;
                    }

                    if(user.addresses.Add(address))
                    {
                        user.dirty = true;
                    }

                    IP.Update(address, user.userid);
                }
            }
        }

        #endregion _user_

        #region _version_

        private new class Version
        {
            public class Settings
            {
                public int Major;
                public int Minor;
                public int Patch;

                public Settings()
                {
                    Major = Minor = Patch = 0;
                }

                public int Compare(int major, int minor, int patch)
                {
                    return
                        (Major != major) ? (Major - major) :
                        (Minor != minor) ? (Minor - minor) :
                        (Patch != patch) ? (Patch - patch) : 0;
                }

                public void Validate()
                {
                    var current = (_instance as CovalencePlugin).Version;

                    if(Compare(current.Major, current.Minor, current.Patch) < 0)
                    {
                        Configuration.SetDirty();

                        Major = current.Major;
                        Minor = current.Minor;
                        Patch = current.Patch;

                        Configuration.SetUpgrade();
                    }
                    else
                    {
                        Configuration.SetUpgrade(false);
                    }

                    String = $"{Major}.{Minor}.{Patch}";
                }
            }

            public static string String { get; protected set; }
        }

        #endregion _version_

        #region _violation_

        private class Violation
        {
            public class Settings
            {
                public bool  Ban;
                public ulong Cooldown;
                public float Sensitivity;
                public bool  Warn;

                public Settings(bool ban = true, ulong cooldown = 7200, float sensitivity = 0.5f, bool warn = false)
                {
                    Ban         = ban;
                    Cooldown    = cooldown;
                    Sensitivity = sensitivity;
                    Warn        = warn;
                }

                public ulong Count(ulong min, ulong max, bool squared = false)
                {
                    if(squared)
                    {
                        return min + (ulong)((max - min) * (1.0f - Sensitivity * Sensitivity));
                    }
                    else
                    {
                        return min + (ulong)((max - min) * (1.0f - Sensitivity));
                    }
                }

                public Settings Validate(ulong max)
                {
                    Configuration.Clamp(ref Cooldown,     1ul,  max);
                    Configuration.Clamp(ref Sensitivity, 0.0f, 1.0f);

                    return this;
                }
            }

            private bool     ban;
            private Key      category;
            private ulong    cooldown;
            private ulong    count;
            private TimeSpan rate;
            private bool     warn;

            private Dictionary<ulong, History> histories;

            private static readonly Dictionary<string, Key> categories = new Dictionary<string, Key>();

            private static ActionQueue triggers;

            private static readonly Violation violation = new Violation(Key.NULL);

            private class History
            {
                public DateTime cooldown;
                public ulong    count;
                public DateTime time;
                public DateTime warned;
                public ulong    warnings;

                public History()
                {
                    cooldown = DateTime.MinValue;
                    count    = 0;
                    time     = DateTime.MinValue;
                    warned   = DateTime.MinValue;
                    warnings = 0;
                }
            }

            public Violation(Key category)
            {
                this.category = category;
            }

            private void Broadcast(ulong userid, Key action, Key type, string details, Dictionary<string, string> hook_details)
            {
                if((action == Key.Warning) && IsFlooding(userid))
                {
                    return;
                }

                var actionname   = Text.GetPlain(action);
                var categoryname = Text.GetPlain(category);
                var playerid     = userid.ToString();
                var playername   = Text.Sanitize(User.Name(userid));
                var typename     = Text.GetPlain(type);

                var parameters = new Dictionary<string, string>
                {
                    { "action", actionname },
                    { "category", categoryname },
                    { "details", details },
                    { "playerid", playerid },
                    { "playername", playername },
                    { "type", typename }
                };

                Chat.Admin(Key.Violation, parameters);

                switch(category)
                {
                case Key.AntiCheat: parameters["color"] = 0xff6060.ToString(); parameters["categoryicon"] = ":shield:"; break;
                case Key.AntiFlood: parameters["color"] = 0xffff60.ToString(); parameters["categoryicon"] = ":stopwatch:"; break;
                case Key.IP:        parameters["color"] = 0x00c0ff.ToString(); parameters["categoryicon"] = ":signal_strength:"; break;
                case Key.Steam:     parameters["color"] = 0xc0c0ff.ToString(); parameters["categoryicon"] = ":gear:"; break;
                case Key.VPN:       parameters["color"] = 0x00c0ff.ToString(); parameters["categoryicon"] = ":signal_strength:"; break;
                default:            parameters["color"] = 0x60ff60.ToString(); parameters["categoryicon"] = ":question:"; break;
                }

                switch(action)
                {
                case Key.Banned:  parameters["actionicon"] = ":no_entry:"; break;
                case Key.Kicked:  parameters["actionicon"] = ":x:"; break;
                case Key.Warning: parameters["actionicon"] = ":warning:"; break;
                }

                Interface.CallHook("OnGuardianViolation", playerid, parameters);

                if(category == Key.AntiCheat)
                {
                    Interface.CallHook("OnGuardian" + Enum.GetName(typeof(Key), type), playerid, hook_details);
                }
            }

            public static Key Category(string category)
            {
                Key key;

                if(string.IsNullOrEmpty(category) || !categories.TryGetValue(category, out key))
                {
                    key = Key.NULL;
                }

                return key;
            }

            public static void Configure()
            {
                var settings = config.Violation.Validate(86400);

                violation.ban      = settings.Ban;
                violation.cooldown = settings.Cooldown;
                violation.count    = settings.Count(2, 6);
                violation.rate     = TimeSpan.FromHours(1);
                violation.warn     = settings.Warn;

                violation.histories = new Dictionary<ulong, History>();
            }

            public void Configure(Settings settings, ulong trigger_min, ulong trigger_max, ulong trigger_rate)
            {
                ban      = settings.Ban;
                cooldown = settings.Cooldown;
                count    = settings.Count(trigger_min, trigger_max);
                rate     = TimeSpan.FromMilliseconds(trigger_rate);
                warn     = settings.Warn;

                histories = new Dictionary<ulong, History>();
            }

            public ulong Cooldown(ulong userid)
            {
                var history = Get(userid);

                var time = DateTime.UtcNow;

                if(history.cooldown > time)
                {
                    return (ulong)history.cooldown.Subtract(time).TotalSeconds + 1ul;
                }

                return 0;
            }

            public void Clear()
            {
                histories.Clear();

                histories = null;
            }

            private History Get(ulong userid)
            {
                History history;

                if(!histories.TryGetValue(userid, out history))
                {
                    histories.Add(userid, history = new History());
                }

                return history;
            }

            private bool IsFlooding(ulong userid)
            {
                var current = DateTime.UtcNow;
                var history = Get(userid);

                if(history.warnings > 6)
                {
                    if(current < history.warned)
                    {
                        return true;
                    }
                    else
                    {
                        history.warnings = 0;
                    }
                }
                else
                {
                    history.warnings++;
                }

                history.warned = current.AddSeconds(60.0);

                return false;
            }

            public static void Load()
            {
                Configure();

                categories.Add(Text.GetPlain(Key.AntiCheat), Key.AntiCheat);
                categories.Add(Text.GetPlain(Key.AntiFlood), Key.AntiFlood);
                categories.Add(Text.GetPlain(Key.IP),        Key.IP);
                categories.Add(Text.GetPlain(Key.Steam),     Key.Steam);
                categories.Add(Text.GetPlain(Key.VPN),       Key.VPN);

                triggers = new ActionQueue(1.0f);
            }

            private void Reduce(ulong userid)
            {
                Get(userid).count >>= 1;
            }

            private void Reset(ulong userid)
            {
                histories.Remove(userid);
            }

            public bool Trigger(ulong userid)
            {
                var history = Get(userid);

                var time = DateTime.UtcNow;

                var sent = history.time; history.time = time;

                var elapsed = time.Subtract(sent);

                if(elapsed <= rate)
                {
                    if(++history.count >= count)
                    {
                        if(history.cooldown < time)
                        {
                            history.cooldown = time.AddSeconds(cooldown);
                        }

                        return true;
                    }
                }
                else
                {
                    if(elapsed.TotalSeconds < cooldown)
                    {
                        history.count -= (history.count > 0ul) ? 1ul : 0ul;
                    }
                    else
                    {
                        history.count = 0;
                    }
                }

                if(history.cooldown > time)
                {
                    return true;
                }

                return false;
            }

            public void Trigger(ulong userid, Key type, string details, bool kick = false, Dictionary<string, string> hook_details = null)
            {
                Trigger(userid, type, details, 1ul, kick, hook_details);
            }
            public void Trigger(ulong userid, Key type, string details, ulong violations, bool kick = false, Dictionary<string, string> hook_details = null)
            {
                User.SetViolationPosition(userid);

                triggers.Enqueue(() => Triggered(userid, type, details, violations, kick, hook_details));
            }
            private void Triggered(ulong userid, Key type, string details, ulong violations, bool kick, Dictionary<string, string> hook_details)
            {
                if(User.IsBanned(userid))
                {
                    return;
                }

                Key action;

                if(config.Admin.Bypass && Permissions.Admin(userid))
                {
                    Reduce(userid);

                    action = Key.Warning;
                }
                else
                {
                    bool triggered = false;

                    if(violation.ban && ban)
                    {
                        while(violations-- > 0)
                        {
                            if(triggered = violation.Trigger(userid))
                            {
                                break;
                            }
                        }
                    }

                    if(triggered)
                    {
                        Reset(userid);

                        action = Key.Banned;

                        User.Ban(userid, $"{Text.GetPlain(category)}: {Text.GetPlain(type)}");

                        violation.Reset(userid);
                    }
                    else
                    {
                        if(!kick && (ban || (!ban && warn) || violation.warn))
                        {
                            action = Key.Warning;
                        }
                        else if(!User.IsConnected(userid))
                        {
                            return;
                        }
                        else
                        {
                            action = Key.Kicked;

                            User.Kick(userid, $"{Text.GetPlain(category)}: {Text.GetPlain(type)}");
                        }

                        Reduce(userid);
                    }
                }

                Broadcast(userid, action, type, details, hook_details);
            }

            public static void Unload()
            {
                categories.Clear();

                triggers.Clear();
                triggers = null;

                violation.Clear();
            }

            public void Warning(ulong userid, Key type, string details, Dictionary<string, string> hook_details = null)
            {
                triggers.Enqueue(() => Broadcast(userid, Key.Warning, type, details, hook_details));
            }

            public void Zero(ulong userid)
            {
                var history = Get(userid);

                history.cooldown = DateTime.MinValue;
                history.count    = 0;
                history.time     = DateTime.MinValue;
            }
        }

        #endregion _violation_

        #region _vpn_

        private class VPN
        {
            public class Settings
            {
                public VpnApi       API;
                public VpnCache     Cache;
                public VpnCheck     Check;
                public VpnViolation Violation;

                public Settings()
                {
                    API       = new VpnApi();
                    Cache     = new VpnCache();
                    Check     = new VpnCheck();
                    Violation = new VpnViolation();
                }

                public class VpnApi
                {
                    public Guardian.API.Settings GetIpIntel;
                    public Guardian.API.Settings IpApi;
                    public Guardian.API.Settings IpHub;
                    public Guardian.API.Settings IpQualityScore;

                    public VpnApi()
                    {
                        GetIpIntel     = new Guardian.API.Settings();
                        IpApi          = new Guardian.API.Settings();
                        IpHub          = new Guardian.API.Settings();
                        IpQualityScore = new Guardian.API.Settings();
                    }

                    public void Validate()
                    {
                        Configuration.Validate(ref GetIpIntel,     () => new Guardian.API.Settings(), () => GetIpIntel.Validate());
                        Configuration.Validate(ref IpApi,          () => new Guardian.API.Settings(), () => IpApi.Validate());
                        Configuration.Validate(ref IpHub,          () => new Guardian.API.Settings(), () => IpHub.Validate());
                        Configuration.Validate(ref IpQualityScore, () => new Guardian.API.Settings(), () => IpQualityScore.Validate());
                    }
                }

                public class VpnCache
                {
                    public ulong Hours;

                    public VpnCache()
                    {
                        Hours = 72ul;
                    }
                }

                public class VpnCheck
                {
                    public bool Enabled;
                    public bool Strict;
                }

                public class VpnViolation
                {
                    public bool Ban;
                    public bool Enabled;
                    public bool Warn;

                    public VpnViolation()
                    {
                        Ban     = false;
                        Enabled = true;
                        Warn    = false;
                    }
                }

                public void Validate()
                {
                    Configuration.Validate(ref API,       () => new VpnApi(), () => API.Validate());
                    Configuration.Validate(ref Cache,     () => new VpnCache());
                    Configuration.Validate(ref Check,     () => new VpnCheck());
                    Configuration.Validate(ref Violation, () => new VpnViolation());
                }
            }

            private static ActionQueue checks;

            private static readonly Violation violation = new Violation(Key.VPN);

            public class API
            {
                public class GetIpIntel
                {
                    [JsonProperty("message")]
                    public string Message { get; set; }
                    [JsonProperty("result")]
                    public float Result { get; set; }
                    [JsonProperty("status")]
                    public string Status { get; set; }

                    private const string api = "getipintel.net";

                    public static void Check(string address, ulong userid)
                    {
                        if(string.IsNullOrEmpty(config.VPN.API.GetIpIntel.ApiKey))
                        {
                            Log.Console(Key.LogVpnCheckConfig, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "link", $"http://getipintel.net/" }
                            });

                            return;
                        }

                        var url = $"http://check.getipintel.net/check.php?ip={address}&contact={config.VPN.API.GetIpIntel.ApiKey}&format=json";

                        _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                        {
                            if(code != 200 || string.IsNullOrEmpty(reply))
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"({code}: {reply})" },
                                    { "type", "HTTP" }
                                });

                                return;
                            }

                            try
                            {
                                var response = JsonConvert.DeserializeObject<GetIpIntel>(reply);

                                if(string.IsNullOrEmpty(response.Status) || response.Status != "success")
                                {
                                    Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                    {
                                        { "address", address },
                                        { "api", api },
                                        { "info", response.Message },
                                        { "type", "STATUS" }
                                    });

                                    return;
                                }

                                if(config.Log.VPN.Check)
                                {
                                    Log.Console(Key.LogVpnCheck, new Dictionary<string, string>
                                    {
                                        { "address", address },
                                        { "api", api },
                                        { "info", $"result={response.Result}" },
                                    });
                                }

                                if(response.Result > 0.99)
                                {
                                    Violation(address, userid, api);
                                }
                                else if(config.VPN.Check.Strict && (response.Result > 0.95))
                                {
                                    Violation(address, userid, api);
                                }
                            }
                            catch
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", reply },
                                    { "type", "JSON" }
                                });
                            }
                        }, _instance);
                    }
                }

                public class IpApi
                {
                    [JsonProperty("hosting")]
                    public bool Hosting { get; set; }
                    [JsonProperty("proxy")]
                    public bool Proxy { get; set; }
                    [JsonProperty("status")]
                    public string Status { get; set; }

                    private const string api = "ip-api.com";

                    public static void Check(string address, ulong userid)
                    {
                        var url = $"http://ip-api.com/json/{address}?fields=status,proxy,hosting";

                        _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                        {
                            if(code != 200 || string.IsNullOrEmpty(reply))
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"({code}: {reply})" },
                                    { "type", "HTTP" }
                                });

                                return;
                            }

                            try
                            {
                                var response = JsonConvert.DeserializeObject<IpApi>(reply);

                                if(string.IsNullOrEmpty(response.Status) || response.Status != "success")
                                {
                                    Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                    {
                                        { "address", address },
                                        { "api", api },
                                        { "info", response.Status },
                                        { "type", "STATUS" }
                                    });

                                    return;
                                }

                                if(config.Log.VPN.Check)
                                {
                                    Log.Console(Key.LogVpnCheck, new Dictionary<string, string>
                                    {
                                        { "address", address },
                                        { "api", api },
                                        { "info", $"hosting={response.Hosting}; proxy={response.Proxy}" },
                                    });
                                }

                                if(response.Proxy)
                                {
                                    Violation(address, userid, api);
                                }
                                else if(config.VPN.Check.Strict && response.Hosting)
                                {
                                    Violation(address, userid, api);
                                }
                            }
                            catch
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", reply },
                                    { "type", "JSON" }
                                });
                            }
                        }, _instance);
                    }
                }

                public class IpHub
                {
                    [JsonProperty("block")]
                    public int Block { get; set; }

                    [JsonIgnore]
                    private static readonly Dictionary<string, string> headers = new Dictionary<string, string>();

                    private const string api = "iphub.info";

                    public static void Check(string address, ulong userid)
                    {
                        if(string.IsNullOrEmpty(config.VPN.API.IpHub.ApiKey))
                        {
                            Log.Console(Key.LogVpnCheckConfig, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "link", $"http://iphub.info/" }
                            });

                            return;
                        }

                        var url = $"http://v2.api.iphub.info/ip/{address}";

                        _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                        {
                            if(code != 200 || string.IsNullOrEmpty(reply))
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"({code}: {reply})" },
                                    { "type", "HTTP" }
                                });

                                return;
                            }

                            try
                            {
                                var response = JsonConvert.DeserializeObject<IpHub>(reply);

                                if(config.Log.VPN.Check)
                                {
                                    Log.Console(Key.LogVpnCheck, new Dictionary<string, string>
                                    {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"block={response.Block}" },
                                    });
                                }

                                if(response.Block == 1)
                                {
                                    Violation(address, userid, api);
                                }
                                else if(config.VPN.Check.Strict && (response.Block == 2))
                                {
                                    Violation(address, userid, api);
                                }
                            }
                            catch
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                    { "address", address },
                                    { "api", api },
                                    { "info", reply },
                                    { "type", "JSON" }
                                });
                            }
                        }, _instance, RequestMethod.GET, headers);
                    }

                    public static void Configure()
                    {
                        headers["X-Key"] = config.VPN.API.IpHub.ApiKey;
                    }

                    public static void Unload() => headers.Clear();
                }

                public class IpQualityScore
                {
                    [JsonProperty("fraud_score")]
                    public int FraudScore { get; set; }
                    [JsonProperty("message")]
                    public string Message { get; set; }
                    [JsonProperty("proxy")]
                    public bool Proxy { get; set; }
                    [JsonProperty("recent_abuse")]
                    public bool RecentAbuse { get; set; }
                    [JsonProperty("success")]
                    public bool Success { get; set; }
                    [JsonProperty("vpn")]
                    public bool VPN { get; set; }

                    private const string api = "ipqualityscore.com";

                    public static void Check(string address, ulong userid)
                    {
                        if(string.IsNullOrEmpty(config.VPN.API.IpQualityScore.ApiKey))
                        {
                            Log.Console(Key.LogVpnCheckConfig, new Dictionary<string, string>
                            {
                                { "api", api },
                                { "link", $"http://ipqualityscore.com/" }
                            });

                            return;
                        }

                        var url = $"https://ipqualityscore.com/api/json/ip/{config.VPN.API.IpQualityScore.ApiKey}/{address}?allow_public_access_points=true&lighter_penalties=true&mobile=true&strictness=1";

                        _instance.webrequest.Enqueue(url, string.Empty, (code, reply) =>
                        {
                            if(code != 200 || string.IsNullOrEmpty(reply))
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                { "address", address },
                                { "api", api },
                                { "info", $"({code}: {reply})" },
                                { "type", "HTTP" }
                                });

                                return;
                            }

                            try
                            {
                                var response = JsonConvert.DeserializeObject<IpQualityScore>(reply);

                                if(!response.Success)
                                {
                                    Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                    {
                                    { "address", address },
                                    { "api", api },
                                    { "info", response.Message },
                                    { "type", "STATUS" }
                                    });

                                    return;
                                }

                                if(config.Log.VPN.Check)
                                {
                                    Log.Console(Key.LogVpnCheck, new Dictionary<string, string>
                                    {
                                    { "address", address },
                                    { "api", api },
                                    { "info", $"fraud_score={response.FraudScore}; proxy={response.Proxy}; recent_abuse={response.RecentAbuse}; vpn={response.VPN}" },
                                    });
                                }

                                if(response.VPN || (response.FraudScore >= 85))
                                {
                                    Violation(address, userid, api);
                                }
                                else if(config.VPN.Check.Strict && (response.Proxy || response.RecentAbuse || (response.FraudScore >= 75)))
                                {
                                    Violation(address, userid, api);
                                }
                            }
                            catch
                            {
                                Log.Console(Key.LogVpnCheckError, new Dictionary<string, string>
                                {
                                { "address", address },
                                { "api", api },
                                { "info", reply },
                                { "type", "JSON" }
                                });
                            }
                        }, _instance);
                    }
                }

                public static void Configure() => IpHub.Configure();

                public static void Unload() => IpHub.Unload();
            }

            private class Cache
            {
                private static readonly DataFile<string, DateTime> blocks = new DataFile<string, DateTime>("vpn_blocks");
                private static readonly DataFile<string, DateTime> bypass = new DataFile<string, DateTime>("vpn_bypass");

                public static void Block(string address)
                {
                    bypass.Remove(address);

                    blocks[address] = DateTime.UtcNow;
                }

                public static void Bypass(string address, ulong _reserved = 0)
                {
                    blocks.Remove(address);

                    bypass[address] = DateTime.UtcNow;
                }

                public static bool IsBlocked(string address) => IsCached(blocks, address);

                public static bool IsBypassed(string address) => IsCached(bypass, address);

                private static bool IsCached(DataFile<string, DateTime> cache, string address)
                {
                    if(cache.Contains(address))
                    {
                        if(IsExpired(cache[address], DateTime.UtcNow))
                        {
                            cache.Remove(address);
                        }
                        else
                        {
                            return true;
                        }
                    }

                    return false;
                }

                private static bool IsExpired(DateTime timestamp, DateTime check)
                {
                    if(config.VPN.Cache.Hours == 0)
                    {
                        return false;
                    }

                    if(check == DateTime.MinValue)
                    {
                        check = DateTime.UtcNow;
                    }

                    return check >= timestamp.AddHours(config.VPN.Cache.Hours);
                }

                public static void Load()
                {
                    blocks.Load();
                    bypass.Load();

                    Update();
                }

                public static void Save()
                {
                    Update();

                    blocks.Save();
                    bypass.Save();
                }

                public static void Unblock(string address) => blocks.Remove(address);

                public static void Unload()
                {
                    Update();

                    blocks.Unload();
                    bypass.Unload();
                }

                private static void Update()
                {
                    var current = DateTime.UtcNow;

                    Update(blocks, current);
                    Update(bypass, current);
                }
                private static void Update(DataFile<string, DateTime> cache, DateTime current)
                {
                    List<string> expired = new List<string>();

                    cache.ForEach((address, timestamp) =>
                    {
                        if(IsExpired(timestamp, current))
                        {
                            expired.Add(address);
                        }
                    });

                    foreach(var address in expired)
                    {
                        cache.Remove(address);
                    }
                }
            }

            public static void Bypass(string address) => Cache.Bypass(address);

            public static void Check(string address, ulong userid)
            {
                if(!config.VPN.Check.Enabled || Permissions.Bypass.Vpn(userid) || string.IsNullOrEmpty(address))
                {
                    return;
                }
                else if(Cache.IsBypassed(address))
                {
                    return;
                }
                else if(Cache.IsBlocked(address))
                {
                    Violation(address, userid, Text.GetPlain(Key.VpnCache));
                }

                checks.Enqueue(() => Check(address, userid, 6.0f));
            }
            private static void Check(string address, ulong userid, float delay)
            {
                if(config.VPN.API.GetIpIntel.Enabled)
                {
                    Check(ref delay, address, userid, API.GetIpIntel.Check);
                }

                if(config.VPN.API.IpApi.Enabled)
                {
                    Check(ref delay, address, userid, API.IpApi.Check);
                }

                if(config.VPN.API.IpHub.Enabled)
                {
                    Check(ref delay, address, userid, API.IpHub.Check);
                }

                if(config.VPN.API.IpQualityScore.Enabled)
                {
                    Check(ref delay, address, userid, API.IpQualityScore.Check);
                }

                Check(ref delay, address, userid, Cache.Bypass);
            }
            private static void Check(ref float delay, string address, ulong userid, Action<string, ulong> callback)
            {
                _instance.timer.In(delay, () =>
                {
                    if(!Cache.IsBlocked(address))
                    {
                        callback(address, userid);
                    }
                });

                delay += 6.0f;
            }

            public static void Configure()
            {
                violation.Configure(new Violation.Settings(true, 3600, 0.5f, config.VPN.Violation.Warn), 1, 1, 1);

                API.Configure();
            }

            public static bool IsBlocked(string address) => Cache.IsBlocked(address);

            public static bool IsBypassed(string address) => Cache.IsBypassed(address);

            public static void Load()
            {
                Configure();

                Cache.Load();

                checks = new ActionQueue(6.0f);
            }

            public static void Save() => Cache.Save();

            public static void Unblock(string address) => Cache.Unblock(address);

            public static void Unload()
            {
                checks.Clear();
                checks = null;

                violation.Clear();

                API.Unload();
                Cache.Unload();
            }

            private static void Violation(string address, ulong userid, string api)
            {
                Cache.Block(address);

                if(!(config.VPN.Violation.Enabled && config.VPN.Violation.Warn))
                {
                    IP.Block(address);
                }

                foreach(var entry in IP.Find(address))
                {
                    if(!User.IsConnected(entry) || Permissions.Bypass.Vpn(entry))
                    {
                        continue;
                    }

                    if(config.VPN.Violation.Enabled)
                    {
                        ulong violations = config.VPN.Violation.Ban ? ulong.MaxValue : 1ul;

                        violation.Trigger(entry, Key.Detected, $"{api}, {address}", violations, true);
                    }
                    else
                    {
                        User.Kick(entry, Text.GetPlain(Key.VpnDetected));
                    }
                }
            }
        }

        #endregion _vpn_

        #region _weapon_

        private class Weapon
        {
            public float        Accuracy { get; protected set; }
            public Vector3      AimAngle { get; protected set; }
            public float        AimCone { get; protected set; }
            public float        AimSway { get; protected set; }
            public string       AmmoName { get; protected set; }
            public List<string> Attachments { get; protected set; }
            public bool         Automatic { get; protected set; }
            public DateTime     Fired { get; protected set; }
            public string       Name { get; protected set; }
            public float        Pitch { get; protected set; }
            public BasePlayer   Player { get; protected set; }
            public Vector3      Position { get; protected set; }
            public List<int>    Projectiles { get; protected set; }
            public float        Range { get; protected set; }
            public float        Repeat { get; protected set; }
            public bool         Shell { get; protected set; }
            public string       ShortName { get; protected set; }
            public float        Speed { get; protected set; }
            public bool         Spread { get; protected set; }
            public float        Swing { get; protected set; }
            public float        Velocity { get; protected set; }
            public float        Yaw { get; protected set; }
            public float        Zoom { get; protected set; }

            private static readonly Queue<Weapon> pool = new Queue<Weapon>();

            // Ammo ID's
            private static readonly int ArrowBone = ItemManager.FindItemDefinition("arrow.bone").itemid;
            private static readonly int ArrowFire = ItemManager.FindItemDefinition("arrow.fire").itemid;
            private static readonly int ArrowHV = ItemManager.FindItemDefinition("arrow.hv").itemid;
            private static readonly int ArrowWooden = ItemManager.FindItemDefinition("arrow.wooden").itemid;
            private static readonly int GrenadeHE = ItemManager.FindItemDefinition("ammo.grenadelauncher.he").itemid;
            private static readonly int GrenadeShotgun = ItemManager.FindItemDefinition("ammo.grenadelauncher.buckshot").itemid;
            private static readonly int GrenadeSmoke = ItemManager.FindItemDefinition("ammo.grenadelauncher.smoke").itemid;
            private static readonly int NailgunNails = ItemManager.FindItemDefinition("ammo.nailgun.nails").itemid;
            private static readonly int PistolBullet = ItemManager.FindItemDefinition("ammo.pistol").itemid;
            private static readonly int PistolHV = ItemManager.FindItemDefinition("ammo.pistol.hv").itemid;
            private static readonly int PistolIncendiary = ItemManager.FindItemDefinition("ammo.pistol.fire").itemid;
            private static readonly int RifleAmmo = ItemManager.FindItemDefinition("ammo.rifle").itemid;
            private static readonly int RifleExplosive = ItemManager.FindItemDefinition("ammo.rifle.explosive").itemid;
            private static readonly int RifleHV = ItemManager.FindItemDefinition("ammo.rifle.hv").itemid;
            private static readonly int RifleIncendiary = ItemManager.FindItemDefinition("ammo.rifle.incendiary").itemid;
            private static readonly int Rocket = ItemManager.FindItemDefinition("ammo.rocket.basic").itemid;
            private static readonly int RocketHV = ItemManager.FindItemDefinition("ammo.rocket.hv").itemid;
            private static readonly int RocketIncendiary = ItemManager.FindItemDefinition("ammo.rocket.fire").itemid;
            private static readonly int ShellBuckshot = ItemManager.FindItemDefinition("ammo.shotgun").itemid;
            private static readonly int ShellHandmade = ItemManager.FindItemDefinition("ammo.handmade.shell").itemid;
            private static readonly int ShellIncendiary = ItemManager.FindItemDefinition("ammo.shotgun.fire").itemid;
            private static readonly int ShellSlug = ItemManager.FindItemDefinition("ammo.shotgun.slug").itemid;

            // Weapon ID's
            private static readonly int AssaultRifle = ItemManager.FindItemDefinition("rifle.ak").itemid;
            private static readonly int BoltActionRifle = ItemManager.FindItemDefinition("rifle.bolt").itemid;
            private static readonly int CompoundBow = ItemManager.FindItemDefinition("bow.compound").itemid;
            private static readonly int Crossbow = ItemManager.FindItemDefinition("crossbow").itemid;
            private static readonly int CustomSMG = ItemManager.FindItemDefinition("smg.2").itemid;
            private static readonly int DoubleBarrelShotgun = ItemManager.FindItemDefinition("shotgun.double").itemid;
            private static readonly int EokaPistol = ItemManager.FindItemDefinition("pistol.eoka").itemid;
            private static readonly int HuntingBow = ItemManager.FindItemDefinition("bow.hunting").itemid;
            private static readonly int L96Rifle = ItemManager.FindItemDefinition("rifle.l96").itemid;
            private static readonly int LR300AssaultRifle = ItemManager.FindItemDefinition("rifle.lr300").itemid;
            private static readonly int M249 = ItemManager.FindItemDefinition("lmg.m249").itemid;
            private static readonly int M39Rifle = ItemManager.FindItemDefinition("rifle.m39").itemid;
            private static readonly int M92Pistol = ItemManager.FindItemDefinition("pistol.m92").itemid;
            private static readonly int MP5A4 = ItemManager.FindItemDefinition("smg.mp5").itemid;
            private static readonly int MultipleGrenadeLauncher = ItemManager.FindItemDefinition("multiplegrenadelauncher").itemid;
            private static readonly int Nailgun = ItemManager.FindItemDefinition("pistol.nailgun").itemid;
            private static readonly int PumpShotgun = ItemManager.FindItemDefinition("shotgun.pump").itemid;
            private static readonly int PythonRevolver = ItemManager.FindItemDefinition("pistol.python").itemid;
            private static readonly int Revolver = ItemManager.FindItemDefinition("pistol.revolver").itemid;
            private static readonly int RocketLauncher = ItemManager.FindItemDefinition("rocket.launcher").itemid;
            private static readonly int SemiAutomaticPistol = ItemManager.FindItemDefinition("pistol.semiauto").itemid;
            private static readonly int SemiAutomaticRifle = ItemManager.FindItemDefinition("rifle.semiauto").itemid;
            private static readonly int Spas12Shotgun = ItemManager.FindItemDefinition("shotgun.spas12").itemid;
            private static readonly int Thompson = ItemManager.FindItemDefinition("smg.thompson").itemid;
            private static readonly int WaterpipeShotgun = ItemManager.FindItemDefinition("shotgun.waterpipe").itemid;

            private class Ammo
            {
                public float AimCone { get; set; }
                public float Range { get; set; }
                public float Velocity { get; set; }

                public Ammo(float aimcone, float range, float velocity)
                {
                    AimCone = aimcone; Range = range; Velocity = velocity;
                }
            }

            private class Info
            {
                public float                 Accuracy { get; set; }
                public Dictionary<int, Ammo> Ammo { get; set; }
                public bool                  Automatic { get; set; }
                public string                Name { get; set; }
                public Recoil                Recoil { get; set; }
                public float                 Repeat { get; set; }
            }

            private class Recoil
            {
                public float Pitch { get; set; }
                public float Yaw { get; set; }

                public Recoil(float pitch, float yaw)
                {
                    Pitch = pitch; Yaw = yaw;
                }
            }

            private static Dictionary<int, Info> weapons;

            private Weapon()
            {
                Attachments = new List<string>();
                Projectiles = new List<int>();
            }

            private static Weapon Get()
            {
                if(pool.Count > 0)
                {
                    return pool.Dequeue();
                }
                else
                {
                    return new Weapon();
                }
            }
            public static Weapon Get(ulong userid, int projectileid) => Projectile.Weapon(userid, projectileid);
            public static Weapon Get(BaseProjectile weapon_fired, BasePlayer player, ProtoBuf.ProjectileShoot fired = null)
            {
                var item = weapon_fired.GetItem();

                Info info;

                if(!weapons.TryGetValue(item.info.itemid, out info))
                {
                    return null;
                }

                var ammo = weapon_fired.primaryMagazine.ammoType;

                Ammo ammoinfo;

                if(!info.Ammo.TryGetValue(ammo.itemid, out ammoinfo))
                {
                    return null;
                }

                var accuracy = info.Accuracy;

                var spread = (ammo.itemid == ShellBuckshot) || (ammo.itemid == ShellHandmade);

                var position = weapon_fired.MuzzlePoint?.transform?.position ?? weapon_fired.transform?.position ?? player.transform.position;

                var weapon = Get();

                weapon.Accuracy   = 1.0f;
                weapon.AimAngle   = player.eyes.HeadRay().direction;
                weapon.AimCone    = ammoinfo.AimCone;
                weapon.AimSway    = 1.0f;
                weapon.AmmoName   = ammo.shortname;
                weapon.Automatic  = info.Automatic;
                weapon.Fired      = DateTime.UtcNow;
                weapon.Name       = info.Name;
                weapon.Pitch      = info.Recoil.Pitch * (info.Automatic ? 0.25f : 0.5f);
                weapon.Player     = player;
                weapon.Position   = position;
                weapon.Range      = ammoinfo.Range;
                weapon.Repeat     = info.Repeat;
                weapon.Shell      = spread || (ammo.itemid == ShellIncendiary) || (ammo.itemid == ShellSlug);
                weapon.ShortName  = item.info.shortname;
                weapon.Speed      = player.estimatedSpeed;
                weapon.Spread     = spread || (ammo.itemid == GrenadeShotgun);
                weapon.Swing      = 0.0f;
                weapon.Velocity   = ammoinfo.Velocity;
                weapon.Yaw        = info.Recoil.Yaw * (info.Automatic ? 0.125f : 0.25f); ;
                weapon.Zoom       = 1.0f;

                var aimsway = 1.0f;

                foreach(var entry in player.inventory.containerWear.itemList)
                {
                    if(entry.info.itemid == -1108136649) // Tactical Gloves
                    {
                        aimsway = 0.2f;

                        break;
                    }
                }

                var aiming = player.IsAiming;

                var ducked = player.IsDucked();

                var recoil = ducked ? 0.9f : 1.0f;

                if(item?.contents?.itemList != null)
                {
                    bool muzzle_brake = false;

                    foreach(var mod in item.contents.itemList)
                    {
                        switch(mod.info.shortname)
                        {
                        case "weapon.mod.8x.scope":
                            accuracy *= 0.85f;
                            recoil -= 0.2f;
                            weapon.AimCone *= 0.7f;
                            weapon.Zoom = aiming ? 16.0f : 1.0f;
                            break;
                        case "weapon.mod.small.scope":
                            accuracy *= 0.85f;
                            recoil -= 0.2f;
                            weapon.AimCone *= 0.7f;
                            weapon.Zoom = aiming ? 8.0f : 1.0f;
                            break;
                        case "weapon.mod.holosight":
                            accuracy *= 0.3f;
                            weapon.AimCone *= 0.3f;
                            weapon.Zoom = aiming ? 2.0f : 1.0f;
                            break;
                        case "weapon.mod.muzzleboost":
                            weapon.Range *= 0.9f;
                            weapon.Repeat *= 0.9f;
                            weapon.Velocity *= 0.9f;
                            break;
                        case "weapon.mod.muzzlebrake":
                            accuracy *= 1.38f;
                            muzzle_brake = true;
                            recoil -= 0.5f;
                            break;
                        case "weapon.mod.silencer":
                            accuracy *= 0.67f;
                            aimsway -= 0.2f;
                            recoil -= 0.2f;
                            weapon.AimCone *= 0.7f;
                            break;
                        case "weapon.mod.simplesight":
                            weapon.Zoom = aiming ? 0.5f : 1.0f;
                            break;
                        case "weapon.mod.lasersight":
                            accuracy *= 0.56f;
                            aimsway -= 0.9f;
                            weapon.AimCone *= aiming ? 0.8f : 0.6f;
                            break;
                        }

                        weapon.Attachments.Add(mod.info.shortname);
                    }

                    if(muzzle_brake)
                    {
                        weapon.AimCone += aiming ? 0.5f : 2.0f;
                    }
                }

                weapon.Accuracy -= accuracy;
                weapon.AimSway  *= (aimsway > 0.0f) ? aimsway : 0.0f;
                weapon.Pitch    *= recoil;
                weapon.Yaw      *= recoil;

                if((fired?.projectiles?.Count ?? 0) > 0)
                {
                    foreach(var projectile in fired.projectiles)
                    {
                        weapon.Projectiles.Add(projectile.projectileID);
                    }

                    Projectile.Add(weapon);
                }

                return weapon;
            }

            public static bool IsValid(Item item) => weapons.ContainsKey(item?.info?.itemid ?? 0);

            public static void Load()
            {
                weapons = new Dictionary<int, Info>
                {
                    [AssaultRifle] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.2f, 187.5f, 375.0f) },
                            { RifleExplosive,  new Ammo(0.5f, 112.5f, 225.0f) },
                            { RifleHV,         new Ammo(0.2f, 225.0f, 450.0f) },
                            { RifleIncendiary, new Ammo(0.2f, 112.5f, 225.0f) }
                        },
                        Automatic = true,
                        Name = "Assault Rifle",
                        Recoil = new Recoil(13.000000f, 5.000000f),
                        Repeat = 0.1333f
                    },
                    [BoltActionRifle] = new Info
                    {
                        Accuracy = 0.02f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.0f, 328.0f, 656.0f) },
                            { RifleExplosive,  new Ammo(0.5f, 197.0f, 394.0f) },
                            { RifleHV,         new Ammo(0.0f, 394.0f, 788.0f) },
                            { RifleIncendiary, new Ammo(0.0f, 197.0f, 394.0f) }
                        },
                        Automatic = false,
                        Name = "Bolt Action Rifle",
                        Recoil = new Recoil(0.500000f, 4.000000f),
                        Repeat = 1.7f
                    },
                    [CompoundBow] = new Info
                    {
                        Accuracy = 0.00f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ArrowBone,   new Ammo(0.2f, 270.0f,  90.0f) },
                            { ArrowFire,   new Ammo(0.2f, 240.0f,  80.0f) },
                            { ArrowHV,     new Ammo(0.2f, 480.0f, 160.0f) },
                            { ArrowWooden, new Ammo(0.2f, 300.0f, 100.0f) }
                        },
                        Automatic = false,
                        Name = "Compound Bow",
                        Recoil = new Recoil(1.500000f, 3.000000f),
                        Repeat = 1.25f
                    },
                    [Crossbow] = new Info
                    {
                        Accuracy = 0.03f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ArrowBone,   new Ammo(1.0f, 202.5f,  67.5f) },
                            { ArrowFire,   new Ammo(1.0f, 180.0f,  60.0f) },
                            { ArrowHV,     new Ammo(1.0f, 360.0f, 120.0f) },
                            { ArrowWooden, new Ammo(1.0f, 225.0f,  75.0f) }
                        },
                        Automatic = false,
                        Name = "Crossbow",
                        Recoil = new Recoil(1.500000f, 3.000000f),
                        Repeat = 1.0f
                    },
                    [CustomSMG] = new Info
                    {
                        Accuracy = 0.03f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.5f, 200.0f, 240.0f) },
                            { PistolHV,         new Ammo(0.5f, 266.7f, 320.0f) },
                            { PistolIncendiary, new Ammo(0.5f, 150.0f, 180.0f) }
                        },
                        Automatic = true,
                        Name = "Custom SMG",
                        Recoil = new Recoil(6.500000f, 5.7500000f),
                        Repeat = 0.1f
                    },
                    [DoubleBarrelShotgun] = new Info
                    {
                        Accuracy = 0.15f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(12.5f, 45.0f, 225.0f) },
                            { ShellHandmade,   new Ammo(12.5f, 30.0f, 100.0f) },
                            { ShellIncendiary, new Ammo(12.5f, 25.0f, 100.0f) },
                            { ShellSlug,       new Ammo( 0.5f, 60.0f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Double Barrel Shotgun",
                        Recoil = new Recoil(2.500000f, 3.500000f),
                        Repeat = 0.5f
                    },
                    [EokaPistol] = new Info
                    {
                        Accuracy = 0.17f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(14.0f, 45.0f, 225.0f) },
                            { ShellHandmade,   new Ammo(14.0f, 30.0f, 100.0f) },
                            { ShellIncendiary, new Ammo(14.0f, 25.0f, 100.0f) },
                            { ShellSlug,       new Ammo( 2.0f, 60.0f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Eoka Pistol",
                        Recoil = new Recoil(15.00000f, 10.00000f),
                        Repeat = 1.5f
                    },
                    [HuntingBow] = new Info
                    {
                        Accuracy = 0.02f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ArrowBone,   new Ammo(1.0f, 135.0f, 45.0f) },
                            { ArrowFire,   new Ammo(1.0f, 120.0f, 40.0f) },
                            { ArrowHV,     new Ammo(1.0f, 240.0f, 80.0f) },
                            { ArrowWooden, new Ammo(1.0f, 150.0f, 50.0f) }
                        },
                        Automatic = false,
                        Name = "Hunting Bow",
                        Recoil = new Recoil(1.500000f, 3.000000f),
                        Repeat = 1.25f
                    },
                    [L96Rifle] = new Info
                    {
                        Accuracy = 0.02f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.0f, 562.5f, 1125.0f) },
                            { RifleExplosive,  new Ammo(0.5f, 337.5f, 675.0f) },
                            { RifleHV,         new Ammo(0.0f, 675.0f, 1350.0f) },
                            { RifleIncendiary, new Ammo(0.0f, 337.5f, 675.0f) }
                        },
                        Automatic = false,
                        Name = "L96 Rifle",
                        Recoil = new Recoil(0.250000f, 2.000000f),
                        Repeat = 2.6f
                    },
                    [LR300AssaultRifle] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.2f, 187.5f, 375.0f) },
                            { RifleExplosive,  new Ammo(0.7f, 112.5f, 225.0f) },
                            { RifleHV,         new Ammo(0.2f, 225.0f, 450.0f) },
                            { RifleIncendiary, new Ammo(0.2f, 112.5f, 225.0f) }
                        },
                        Automatic = true,
                        Name = "LR-300 Assault Rifle",
                        Recoil = new Recoil(4.750000f, 3.000000f),
                        Repeat = 0.12f
                    },
                    [M249] = new Info
                    {
                        Accuracy = 0.07f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.2f, 243.75f, 487.5f) },
                            { RifleExplosive,  new Ammo(0.7f, 146.25f, 292.5f) },
                            { RifleHV,         new Ammo(0.2f, 292.50f, 585.0f) },
                            { RifleIncendiary, new Ammo(0.2f, 146.25f, 292.5f) }
                        },
                        Automatic = true,
                        Name = "M249",
                        Recoil = new Recoil(0.500000f, 1.000000f),
                        Repeat = 0.12f
                    },
                    [M39Rifle] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.1f, 234.375f, 468.75f) },
                            { RifleExplosive,  new Ammo(0.6f, 140.625f, 281.25f) },
                            { RifleHV,         new Ammo(0.1f, 281.250f, 562.50f) },
                            { RifleIncendiary, new Ammo(0.1f, 140.625f, 281.25f) }
                        },
                        Automatic = false,
                        Name = "M39 Rifle",
                        Recoil = new Recoil(1.000000f, 1.500000f),
                        Repeat = 0.2f
                    },
                    [M92Pistol] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(1.0f,  90.0f, 300.0f) },
                            { PistolHV,         new Ammo(1.0f, 120.0f, 400.0f) },
                            { PistolIncendiary, new Ammo(1.0f,  67.5f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "M92 Pistol",
                        Recoil = new Recoil(0.500000f, 1.000000f),
                        Repeat = 0.15f
                    },
                    [MP5A4] = new Info
                    {
                        Accuracy = 0.05f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.5f, 200.0f, 240.0f) },
                            { PistolHV,         new Ammo(0.5f, 266.7f, 320.0f) },
                            { PistolIncendiary, new Ammo(0.5f, 150.0f, 180.0f) }
                        },
                        Automatic = true,
                        Name = "MP5A4",
                        Recoil = new Recoil(4.000000f, 3.625000f),
                        Repeat = 0.1f
                    },
                    [MultipleGrenadeLauncher] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { GrenadeHE,      new Ammo( 2.25f, 100.0f, 100.0f) },
                            { GrenadeShotgun, new Ammo(17.25f, 225.0f, 225.0f) },
                            { GrenadeSmoke,   new Ammo( 2.25f, 100.0f, 100.0f) }
                        },
                        Automatic = false,
                        Name = "Multiple Grenade Launcher",
                        Recoil = new Recoil(2.500000f, 2.500000f),
                        Repeat = 0.4f
                    },
                    [Nailgun] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { NailgunNails, new Ammo(0.75f, 25.0f, 50.0f) }
                        },
                        Automatic = false,
                        Name = "Nailgun",
                        Recoil = new Recoil(1.500000f, 1.000000f),
                        Repeat = 0.15f
                    },
                    [PumpShotgun] = new Info
                    {
                        Accuracy = 0.14f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(12.0f, 101.25f, 225.0f) },
                            { ShellHandmade,   new Ammo(12.0f,  60.00f, 100.0f) },
                            { ShellIncendiary, new Ammo(12.0f,  45.00f, 100.0f) },
                            { ShellSlug,       new Ammo( 0.0f, 135.00f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Pump Shotgun",
                        Recoil = new Recoil(2.000000f, 2.000000f),
                        Repeat = 1.1f
                    },
                    [PythonRevolver] = new Info
                    {
                        Accuracy = 0.06f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.5f, 72.0f, 300.0f) },
                            { PistolHV,         new Ammo(0.5f, 96.0f, 400.0f) },
                            { PistolIncendiary, new Ammo(0.5f, 54.0f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Python Revolver",
                        Recoil = new Recoil(0.500000f, 2.000000f),
                        Repeat = 0.15f
                    },
                    [Revolver] = new Info
                    {
                        Accuracy = 0.05f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.75f, 54.0f, 300.0f) },
                            { PistolHV,         new Ammo(0.75f, 72.0f, 400.0f) },
                            { PistolIncendiary, new Ammo(0.75f, 40.5f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Revolver",
                        Recoil = new Recoil(1.500000f, 1.000000f),
                        Repeat = 0.175f
                    },
                    [RocketLauncher] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { Rocket,           new Ammo(2.25f, 250.0f, 18.0f) },
                            { RocketHV,         new Ammo(2.25f, 400.0f, 40.0f) },
                            { RocketIncendiary, new Ammo(2.25f, 250.0f, 18.0f) }
                        },
                        Automatic = false,
                        Name = "Rocket Launcher",
                        Recoil = new Recoil(2.500000f, 2.500000f),
                        Repeat = 2.0f
                    },
                    [SemiAutomaticPistol] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.75f, 54.0f, 300.0f) },
                            { PistolHV,         new Ammo(0.75f, 72.0f, 400.0f) },
                            { PistolIncendiary, new Ammo(0.75f, 40.5f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Semi-Automatic Pistol",
                        Recoil = new Recoil(1.000000f, 2.000000f),
                        Repeat = 0.15f
                    },
                    [SemiAutomaticRifle] = new Info
                    {
                        Accuracy = 0.04f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { RifleAmmo,       new Ammo(0.25f, 187.5f, 375.0f) },
                            { RifleExplosive,  new Ammo(0.75f, 112.5f, 225.0f) },
                            { RifleHV,         new Ammo(0.25f, 225.0f, 450.0f) },
                            { RifleIncendiary, new Ammo(0.25f, 112.5f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Semi-Automatic Rifle",
                        Recoil = new Recoil(0.500000f, 1.000000f),
                        Repeat = 0.175f
                    },
                    [Spas12Shotgun] = new Info
                    {
                        Accuracy = 0.14f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(12.0f, 101.25f, 225.0f) },
                            { ShellHandmade,   new Ammo(12.0f,  60.00f, 100.0f) },
                            { ShellIncendiary, new Ammo(12.0f,  45.00f, 100.0f) },
                            { ShellSlug,       new Ammo( 0.0f, 135.00f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Spas-12 Shotgun",
                        Recoil = new Recoil(2.000000f, 2.000000f),
                        Repeat = 0.25f
                    },
                    [Thompson] = new Info
                    {
                        Accuracy = 0.03f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { PistolBullet,     new Ammo(0.5f, 250.0f, 300.0f) },
                            { PistolHV,         new Ammo(0.5f, 333.3f, 400.0f) },
                            { PistolIncendiary, new Ammo(0.5f, 187.5f, 225.0f) }
                        },
                        Automatic = true,
                        Name = "Thompson",
                        Recoil = new Recoil(6.500000f, 5.750000f),
                        Repeat = 0.13f
                    },
                    [WaterpipeShotgun] = new Info
                    {
                        Accuracy = 0.15f,
                        Ammo = new Dictionary<int, Ammo>
                        {
                            { ShellBuckshot,   new Ammo(13.0f, 45.0f, 225.0f) },
                            { ShellHandmade,   new Ammo(13.0f, 30.0f, 100.0f) },
                            { ShellIncendiary, new Ammo(13.0f, 25.0f, 100.0f) },
                            { ShellSlug,       new Ammo( 1.0f, 60.0f, 225.0f) }
                        },
                        Automatic = false,
                        Name = "Waterpipe Shotgun",
                        Recoil = new Recoil(2.000000f, 2.000000f),
                        Repeat = 2.0f
                    }
                };
            }

            public void Release()
            {
                Attachments.Clear();
                Projectiles.Clear();

                pool.Enqueue(this);
            }

            public void SetSwing(float amount)
            {
                Swing = amount;
            }

            public static void Unload()
            {
                pool.Clear();

                weapons.Clear();
                weapons = null;
            }
        }

        #endregion _weapon_

        #region _webhook_

        private class WebHook
        {
            public static void Send(string url, string category, string message)
            {
                if(string.IsNullOrEmpty(url) || string.IsNullOrEmpty(message))
                {
                    return;
                }

                if(string.IsNullOrWhiteSpace(category))
                {
                    category = Text.GetPlain(Key.unknown);
                }

                _instance.webrequest.Enqueue(url, message, (code, reply) =>
                {
                    if((code < 200) || (204 < code))
                    {
                        Log.Console(Key.LogWebHook, new Dictionary<string, string>
                        {
                            { "category", category },
                            { "info", $"({code}: {reply})" },
                            { "type", "http" }
                        });
                    }
                }, _instance, RequestMethod.POST, new Dictionary<string, string> { { "Content-Type", "application/json" } });
            }
        }

        #endregion _webhook_
    }
}


// --- End of file: Guardian.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ItemSkinRandomizer.cs ---
// --- Original Local Path: ItemSkinRandomizer.cs ---

// Reference: Rust.Workshop

using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Item Skin Randomizer", "Mughisi", 1.1, ResourceId = 1328)]
    [Description("Simple plugin that will select a random skin for an item when crafting.")]
    class ItemSkinRandomizer : RustPlugin
    {
        private readonly Dictionary<string, List<int>> skinsCache = new Dictionary<string, List<int>>();
        private readonly List<int> randomizedTasks = new List<int>();

        private void OnItemCraft(ItemCraftTask task, BasePlayer crafter)
        {
            var skins = GetSkins(task.blueprint.targetItem);
            if (skins.Count < 1 || task.skinID != 0) return;
            randomizedTasks.Add(task.taskUID);
            task.skinID = skins.GetRandom();
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            if (!randomizedTasks.Contains(task.taskUID)) return;
            if (task.amount == 0)
            {
                randomizedTasks.Remove(task.taskUID);
                return;
            }
            var skins = GetSkins(task.blueprint.targetItem);
            task.skinID = skins.GetRandom();
        }

        private List<int> GetSkins(ItemDefinition def)
        {
            List<int> skins;
            if (skinsCache.TryGetValue(def.shortname, out skins)) return skins;
            skins = new List<int> { 0 };
            skins.AddRange(ItemSkinDirectory.ForItem(def).Select(skin => skin.id));
            skins.AddRange(Rust.Workshop.Approved.All.Where(skin => skin.ItemName == def.shortname).Select(skin => (int)skin.InventoryId));
            skinsCache.Add(def.shortname, skins);
            return skins;
        }
    }
}


// --- End of file: ItemSkinRandomizer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ConnectionDB.cs ---
// --- Original Local Path: ConnectionDB.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
namespace Oxide.Plugins
{
    [Info("ConnectionDB", "Norn", 0.2, ResourceId = 1459)]
    [Description("Connection database for devs.")]
    public class ConnectionDB : RustPlugin
    {
        class StoredData
        {
            public Dictionary<ulong, PlayerInfo> PlayerInfo = new Dictionary<ulong, PlayerInfo>();
            public StoredData(){}
        }
        class PlayerInfo
        {
            public ulong uUserID;
            public string tFirstName;
            public string tLastName;
            public int iInitTimestamp;
            public int iLastSeen;
            public string tInitIP;
            public string tLastIP;
            public int iSecondsPlayed;
            public int iConnections;
            public string tReason;
            public bool bAlive;
            public PlayerInfo(){}
        }
        StoredData DB_Connection;
        void Unload()
        {
            SaveData();
            if (SecondsCount != null) SecondsCount.Destroy();
        }
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, DB_Connection);
        }
        private bool InitPlayer(BasePlayer player)
        {
            if (player == null || !player.isConnected) return false;
            PlayerInfo p = null;
            if (!DB_Connection.PlayerInfo.TryGetValue(player.userID, out p))
            {
                var info = new PlayerInfo(); int firstseen = UnixTimeStampUTC(); string name = player.displayName; string ip = player.net.connection.ipaddress;
                info.uUserID = player.userID;
                info.iInitTimestamp = firstseen;
                info.iLastSeen = firstseen;
                info.iSecondsPlayed = 0;
                info.tFirstName = name;
                info.tLastName = name;
                info.tInitIP = ip;
                info.tLastIP = ip;
                info.iConnections = 1;
                info.bAlive = player.IsAlive();
                info.tReason = "null";
                DB_Connection.PlayerInfo.Add(info.uUserID, info);
                Interface.GetMod().DataFileSystem.WriteObject(this.Title, DB_Connection);
                int current_connections = Convert.ToInt32(Config["DB", "UniqueConnections"]); current_connections++; Config["DB", "UniqueConnections"] = current_connections; SaveConfig();
                if(Convert.ToBoolean(Config["General", "Debug"])) Puts("Registering " + info.tFirstName + " [ " + info.uUserID + " ].");
                return true;
            }
            else
            {
                p.iLastSeen = UnixTimeStampUTC();
                p.tLastName = player.displayName;
                p.tLastIP = player.net.connection.ipaddress;
                p.bAlive = player.IsAlive();
                p.iConnections++;
                if (Convert.ToBoolean(Config["General", "Debug"])) Puts("Updating " + p.tFirstName + " [ " + p.uUserID + " ].");
            }
            return false;
        }
        private void SyncAlive(BasePlayer player)
        {
            if (player != null && player.IsConnected())
            {
                if (ConnectionDataExists(player))
                {
                    DB_Connection.PlayerInfo[player.userID].bAlive = player.IsAlive();
                }
            }
        }
        void OnPlayerInit(BasePlayer player)
        {
            InitPlayer(player);
        }
        private bool SaveConnectionDataFromID(ulong steamid, string reason = "")
        {
            if (ConnectionDataExistsFromID(steamid))
            {
                BasePlayer player = BasePlayer.FindByID(steamid);
                if(player != null && player.IsConnected())
                {
                    DB_Connection.PlayerInfo[steamid].tLastName = player.displayName;
                    DB_Connection.PlayerInfo[steamid].tLastIP = player.net.connection.ipaddress;
                    DB_Connection.PlayerInfo[steamid].bAlive = player.IsAlive();
                }
                DB_Connection.PlayerInfo[steamid].iLastSeen = UnixTimeStampUTC();
                if (reason != "") { DB_Connection.PlayerInfo[player.userID].tReason = reason; }
                return true;
            }
            return false;
        }
        private void SaveConnectionData(BasePlayer player, string reason = "")
        {
            if (ConnectionDataExists(player))
            {
                DB_Connection.PlayerInfo[player.userID].tLastName = player.displayName;
                DB_Connection.PlayerInfo[player.userID].tLastIP = player.net.connection.ipaddress;
                DB_Connection.PlayerInfo[player.userID].iLastSeen = UnixTimeStampUTC();
                DB_Connection.PlayerInfo[player.userID].bAlive = player.IsAlive();
                if (reason != "") { DB_Connection.PlayerInfo[player.userID].tReason = reason; }
            }
            else
            {
                InitPlayer(player);
                SaveConnectionData(player, reason);
            }
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveConnectionData(player, reason);
        }
        private Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;
        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
               ? UnixEpoch.AddMilliseconds(unixTimeStamp)
               : UnixEpoch.AddSeconds(unixTimeStamp);
        }
        private DateTime FirstSeenFromID(ulong steamid)
        {
            DateTime date = System.DateTime.Now;
            if (ConnectionDataExistsFromID(steamid)) date = UnixTimeStampToDateTime(DB_Connection.PlayerInfo[steamid].iInitTimestamp);
            return date;
        }
        private int Connections(BasePlayer player)
        {
            int connections = 0;
            if (ConnectionDataExistsFromID(player.userID)) connections = DB_Connection.PlayerInfo[player.userID].iConnections;
            return connections;
        }
        private int ConnectionsFromID(ulong steamid)
        {
            int connections = 0;
            if (ConnectionDataExistsFromID(steamid)) connections = DB_Connection.PlayerInfo[steamid].iConnections;
            return connections;
        }
        private int SecondsPlayed(BasePlayer player)
        {
            int seconds = 0;
            if (ConnectionDataExistsFromID(player.userID)) seconds = DB_Connection.PlayerInfo[player.userID].iSecondsPlayed;
            return seconds;
        }
        private int SecondsPlayedFromID(ulong steamid)
        {
            int seconds = 0;
            if (ConnectionDataExistsFromID(steamid)) seconds = DB_Connection.PlayerInfo[steamid].iSecondsPlayed;
            return seconds;
        }
        private string FirstIP(BasePlayer player)
        {
            if (ConnectionDataExistsFromID(player.userID)) return DB_Connection.PlayerInfo[player.userID].tInitIP;
            return "null";
        }
        private string FirstIPFromID(ulong steamid)
        {
            if (ConnectionDataExistsFromID(steamid)) return DB_Connection.PlayerInfo[steamid].tInitIP;
            return "null";
        }
        private string LastIP(BasePlayer player)
        {
            if (ConnectionDataExistsFromID(player.userID)) return DB_Connection.PlayerInfo[player.userID].tLastIP;
            return "null";
        }
        private string LastIPFromID(ulong steamid)
        {
            if (ConnectionDataExistsFromID(steamid)) return DB_Connection.PlayerInfo[steamid].tLastIP;
            return "null";
        }
        private string LastName(BasePlayer player)
        {
            if (ConnectionDataExistsFromID(player.userID)) return DB_Connection.PlayerInfo[player.userID].tLastName;
            return "null";
        }
        private string LastNameFromID(ulong steamid)
        {
            if (ConnectionDataExistsFromID(steamid)) return DB_Connection.PlayerInfo[steamid].tLastName;
            return "null";
        }
        private string FirstName(BasePlayer player)
        {
            if (ConnectionDataExistsFromID(player.userID)) return DB_Connection.PlayerInfo[player.userID].tFirstName;
            return "null";
        }
        private string FirstNameFromID(ulong steamid)
        {
            if (ConnectionDataExistsFromID(steamid)) return DB_Connection.PlayerInfo[steamid].tFirstName;
            return "null";
        }
        private string DisconnectReasonFromID(ulong steamid)
        {
            if (ConnectionDataExistsFromID(steamid)) { if(DB_Connection.PlayerInfo[steamid].tReason.Length >= 1) { return DB_Connection.PlayerInfo[steamid].tReason; } }
            return "null";
        }
        private string DisconnectReason(BasePlayer player)
        {
            if (ConnectionDataExistsFromID(player.userID)) { if (DB_Connection.PlayerInfo[player.userID].tReason.Length >= 1) { return DB_Connection.PlayerInfo[player.userID].tReason; } }
            return "null";
        }
        private bool IsPlayerAliveFromID(ulong steamid)
        {
            if (ConnectionDataExistsFromID(steamid)) { return DB_Connection.PlayerInfo[steamid].bAlive; }
            return false;
        }
        private DateTime FirstSeen(BasePlayer player)
        {
            DateTime date = System.DateTime.Now;
            if (ConnectionDataExistsFromID(player.userID)) date = UnixTimeStampToDateTime(DB_Connection.PlayerInfo[player.userID].iInitTimestamp);
            return date;
        }
        private DateTime LastSeen(BasePlayer player)
        {
            DateTime date = System.DateTime.Now;
            if (ConnectionDataExistsFromID(player.userID)) date = UnixTimeStampToDateTime(DB_Connection.PlayerInfo[player.userID].iLastSeen);
            return date;
        }
        private DateTime ConfigInitTimestamp()
        {
            return UnixTimeStampToDateTime(Convert.ToInt32(Config["General", "ConfigInit"]));
        }
        private DateTime LastSeenFromID(ulong steamid)
        {
            DateTime date = System.DateTime.Now;
            if (ConnectionDataExistsFromID(steamid)) date = UnixTimeStampToDateTime(DB_Connection.PlayerInfo[steamid].iLastSeen);
            return date;
        }
        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");
            Config.Clear();

            // --- [ GENERAL SETTINGS ] ---

            Config["General", "Debug"] = true;
            Config["General", "ConfigInit"] = UnixTimeStampUTC();

            Config["Admin", "AuthLevel"] = 2;

            Config["DB", "UniqueConnections"] = 0;

            Config["Timers", "SecondsInterval"] = 10;

            SaveConfig();
        }
		System.Random rnd = new System.Random();
        protected int GetRandomInt(int min, int max)
        {
            return rnd.Next(min, max);
        }
        void Loaded()
        {
            DB_Connection = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
        }
        private bool ConnectionDataExistsFromID(ulong steamid)
        {
            if (DB_Connection.PlayerInfo.ContainsKey(steamid)) { return true; }
            return false;
        }
        private bool ConnectionDataExists(BasePlayer player)
        {
            if (player == null || !player.isConnected) return false;
            if (DB_Connection.PlayerInfo.ContainsKey(player.userID)) { return true; }
            return false;
        }
        private int UniqueConnections()
        {
            return Convert.ToInt32(Config["DB", "UniqueConnections"]);
        }
        private int ConnectionPlayerCount()
        {
            return DB_Connection.PlayerInfo.Count;
        }
        private void UpdateSeconds()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList) { if (ConnectionDataExists(player)) { DB_Connection.PlayerInfo[player.userID].iSecondsPlayed += Convert.ToInt32(Config["Timers", "SecondsInterval"]); SyncAlive(player);  } else { InitPlayer(player); } }
        }
        Timer SecondsCount;
        void OnServerInitialized()
        {
            Puts("Loaded " + ConnectionPlayerCount().ToString() + " profiles. [Unique Connections: " + UniqueConnections().ToString() + "]");
            int seconds = Convert.ToInt32(Config["Timers", "SecondsInterval"]);
            SecondsCount = timer.Repeat(seconds, 0, () => UpdateSeconds());
        }
    }
}

// --- End of file: ConnectionDB.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoBP.cs ---
// --- Original Local Path: AutoBP.cs ---

using System.Collections.Generic;
using System.Linq;

using System;
using UnityEngine;
using Network;

namespace Oxide.Plugins
{
    [Info("AutoBP", "Ryamkk", "1.0.3")]
    public class AutoBP : RustPlugin
    {
        void Loaded()
        {
            permission.RegisterPermission("autobp.use", this);
        }

        private void OnServerInitialized()
        {
            timer.Every(30f, () =>
            {
                foreach (var player in BasePlayer.activePlayerList.ToList())
                {
                    if(permission.UserHasPermission(player.UserIDString, "autobp.use")) 
                        player.blueprints.UnlockAll();
                }
            });
        }
		

        private List<string> BPes = new List<string>
        {
            "syringe.medical",
            "pistol.revolver",
            "ammo.pistol",
        };

        private void OnPlayerInit(BasePlayer player)
        {
            if(permission.UserHasPermission(player.UserIDString, "autobp.use")) 
                player.blueprints.UnlockAll();
            
            foreach (var check in BPes)
            {
                var def = ItemManager.FindItemDefinition(check);
                if (!player.blueprints.IsUnlocked(def))
                    player.blueprints.Unlock(def); 
            }
        }
    }
}

// --- End of file: AutoBP.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UberTool.cs ---
// --- Original Local Path: UberTool.cs ---

using Facepunch;
using Network;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Game.Rust.Libraries.Covalence;
using ProtoBuf;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;
using BTN = BUTTON;

namespace Oxide.Plugins
{
    [Info("UberTool", "Skuli Dropek", "1.4.19", ResourceId = 78)]
    [Description("The ultimative build'n'place solution without any borders or other known limits")]
    internal class UberTool : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, ImageLibrary;
        private StrdDt playerPrefs = new StrdDt();

        private class StrdDt
        {
            public Dictionary<ulong,
            Plyrnf> playerData = new Dictionary<ulong,
            Plyrnf>();

            public StrdDt() { }
        }

        private class Plyrnf
        {
            public float SF;
            public int DBG;

            public Plyrnf() { }
        }

        private const string WIRE_EFFECT = "assets/prefabs/tools/wire/effects/plugeffect.prefab";

        private object CanUseWires(BasePlayer player)
        {
            EPlanner planner = player.GetComponent<EPlanner>();

            if (planner != null && planner.isWireTool)
            {
                return player.serverInput.IsDown(BTN.FIRE_SECONDARY);
            }

            return null;
        }

        public class EPlanner : MonoBehaviour
        {
            private BasePlayer player;
            private InputState serverInput;
            private uint ctvtm;
            private Construction.Target target;
            private Construction.Target mvTrgt;
            private BaseEntity mvTrgtSnp;
            private Construction construction;
            private Construction mvCnstrctn;
            private Construction rayDefinition;
            private Vector3 rttnOffst;
            private Vector3 mvOffst;
            private string lstCrsshr;
            private string lstWrnng;
            private Planner plnnr;
            private bool isPlanner;
            private bool isHammering;
            internal bool isWireTool;
            internal bool isLightDeployer;
            private HeldEntity heldItem;
            private bool sRmvr;
            private bool isAnotherHeld;
            private Item ctvtmLnk;
            private bool sTpDplybl;
            private int dfltGrd;
            private uint lstPrfb;
            private bool initialized;
            private bool ctvTrgt;
            private bool isPlacing;
            private float tkDist;
            private RaycastHit rayHit;
            private BaseEntity rayEntity;
            private IPlayer rayEntityOwner;
            private string rayEntityName;
            private Vector3 lastAimAngles;
            private Socket_Base lastSocketBase;
            private Vector3 lastSocketPos;
            private BaseEntity lastSocketEntity;
            private Construction.Placement lastPlacement;
            private Ray lastRay;
            private bool plannerInfoStatus;
            private bool removerInfoStatus;
            private bool hammerInfoStatus;
            private bool lastSocketForce;
            private int cuiFontSize = 14;
            private string cuiFontColor = "1 1 1 1";
            private string fontType = r("EbobgbPbaqrafrq-Erthyne.ggs");
            private float lastPosRotUpdate = 0f;


            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                serverInput = player.serverInput;
                Unequip();
                dfltGrd = Instance.playerPrefs.playerData[player.userID].DBG;
                lstPrfb = 72949757u;
                ctvtm = 0;
                construction = new Construction();
                rayDefinition = new Construction();
                construction.canBypassBuildingPermission = true;
                lastAimAngles = player.lastReceivedTick.inputState.aimAngles;
                lastSocketBase =
            default(Socket_Base);
                lastSocketPos = Vector3.zero;
                lastSocketEntity =
            default(BaseEntity);
                lastPlacement =
            default(Construction.Placement);
                rayEntity =
            default(BaseEntity);
                rttnOffst = Vector3.zero;
                mvOffst = Vector3.zero;
            }

            private void Start()
            {
                if (Instance.hideTips) player.SendConsoleCommand(r("tnzrgvc.uvqrtnzrgvc"));
                initialized = true;
            }

            private void Unequip()
            {
                foreach (Item item in player.inventory.containerBelt.itemList.Where(x => x.IsValid() && x.GetHeldEntity()).ToList())
                {
                    int slot = item.position;
                    if (item.info.shortname == "rock" && item.skin == 0uL || item.info.shortname == "torch")
                    {
                        item.Remove(0f);
                        continue;
                    }
                    else
                    {
                        item.RemoveFromContainer();
                    }

                    player.inventory.UpdateContainer(0f, PlayerInventory.Type.Belt, player.inventory.containerBelt, false, 0f);
                    Instance.timer.Once(0.15f, () =>
                    {
                        if (item == null) return;
                        item.MoveToContainer(player.inventory.containerBelt, slot, true);
                        item.MarkDirty();
                    });
                    ItemManager.DoRemoves();
                }

                if (player.inventory.containerWear.itemList.Count == 0)
                {
                    Item hz = ItemManager.CreateByName("hazmatsuit_scientist", 1);
                    player.inventory.GiveItem(hz, player.inventory.containerWear);
                }

                Instance.timer.Once(0.3f, CrtTls);
            }

            private void GetTool(object[] tool)
            {
                ItemDefinition itemDef = ItemManager.FindItemDefinition((string)tool[1]);
                if (!itemDef) return;
                Item p1 = player.inventory.FindItemID(itemDef.itemid);
                ulong skin = Convert.ToUInt64(tool[2]);
                if (p1 != null)
                {
                    p1.skin = skin;
                    p1.GetHeldEntity().skinID = skin;
                    p1.name = (string)tool[0];
                    if (p1.CanMoveTo(player.inventory.containerBelt, -1, true))
                    {
                        p1.MoveToContainer(player.inventory.containerBelt, -1, true);
                        p1.MarkDirty();
                    }
                }
                else
                {
                    Item p2 = ItemManager.CreateByItemID(itemDef.itemid, 1, skin);
                    if (p2 != null)
                    {
                        p2.name = (string)tool[0];
                        player.inventory.GiveItem(p2, player.inventory.containerBelt);
                        p2.MarkDirty();
                    }
                }
            }

            private void CrtTls()
            {
                if (Instance.checkExistingPlanner) GetTool(Instance.playerTools[0]);
                if (Instance.checkExistingRemover) GetTool(Instance.playerTools[1]);
                if (Instance.checkExistingHammer) GetTool(Instance.playerTools[2]);
            }

            private bool GetCurrentTool()
            {
                isPlanner = false;
                sRmvr = false;
                isHammering = false;
                isWireTool = false;
                isAnotherHeld = false;
                isLightDeployer = false;
                DestroyInfo();
                if (heldItem is Planner)
                {
                    plnnr = heldItem as Planner;
                    isPlanner = true;
                    sTpDplybl = plnnr.isTypeDeployable;
                    DoPlannerInfo();
                    return true;
                }
                else if (heldItem is BaseProjectile && ctvtmLnk.skin == Convert.ToUInt64(Instance.playerTools[1][2]))
                {
                    sRmvr = true;
                    return true;
                }
                else if (heldItem is Hammer && ctvtmLnk.skin == Convert.ToUInt64(Instance.playerTools[2][2]))
                {
                    isHammering = true;
                    DoHammerInfo();
                    return true;
                }
                else if (heldItem is AttackEntity)
                {
                    isAnotherHeld = true;
                    return true;
                }
                else if (heldItem is WireTool)
                {
                    isWireTool = true;
                    return true;
                }
                else if (heldItem is PoweredLightsDeployer)
                {
                    isLightDeployer = true;
                    return true;
                }

                if (!isWireTool && (source != null || isWiring))
                {
                    if (sourceSlot != null)
                        sourceSlot.linePoints = new Vector3[0];

                    source = null;
                    sourceSlot = null;
                    isWiring = false;
                }

                return false;
            }

            private void CheckRemover()
            {
                bool hsLsr = false;
                if (ctvtmLnk.info.shortname != (string)Instance.playerTools[1][1])
                {
                    sRmvr = false;
                    heldItem = null;
                    return;
                }

                ctvtmLnk.contents.flags = (ItemContainer.Flag)64;
                ctvtmLnk.contents.MarkDirty();
                if (ctvtmLnk.contents != null && ctvtmLnk.contents.itemList.Count > 0) foreach (Item mod in ctvtmLnk.contents.itemList) if (mod.info.shortname == r("jrncba.zbq.ynfrefvtug"))
                        {
                            hsLsr = true;
                            break;
                        }

                if (!hsLsr)
                {
                    Item lMod = ItemManager.CreateByName(r("jrncba.zbq.ynfrefvtug"), 1);
                    if (lMod != null) if (lMod.MoveToContainer(ctvtmLnk.contents, -1, true))
                        {
                            hsLsr = true;
                        }
                        else
                        {
                            sRmvr = false;
                            heldItem = null;
                            return;
                        }
                }

                (heldItem as BaseProjectile).UnloadAmmo(ctvtmLnk, player);
                heldItem.SetLightsOn(true);
                DoRemoverInfo();
            }

            public void SetHeldItem(uint uid)
            {
                if (!initialized || uid == ctvtm) return;
                if (uid == 0u)
                {
                    ctvtm = 0u;
                    isPlanner = false;
                    sRmvr = false;
                    isHammering = false;
                    isWireTool = false;
                    sTpDplybl = false;
                    construction = null;
                    isLightDeployer = false;
                    DestroyInfo();
                    return;
                }

                if (uid != ctvtm)
                {
                    ctvtmLnk = player.inventory.containerBelt.FindItemByUID(uid);
                    if (ctvtmLnk == null) return;
                    ctvtm = uid;
                    heldItem = ctvtmLnk.GetHeldEntity() as HeldEntity;
                    if (heldItem == null) return;
                    if (!GetCurrentTool()) return;
                    if (sRmvr)
                    {
                        CuiHelper.DestroyUi(player, r("HgPebffUnveHV"));
                        CheckRemover();
                    }
                    else if (isPlanner || isHammering)
                    {
                        construction = PrefabAttribute.server.Find<Construction>(
                        isPlanner && sTpDplybl && plnnr.GetDeployable() != null ? plnnr.GetDeployable().prefabID : lstPrfb);
                        rttnOffst = Vector3.zero;
                        if (isPlanner)
                        {
                            if (sTpDplybl) DoPlannerUpdate(PType.Mode, ctvtmLnk.info.displayName.english);
                            else DoPlannerUpdate(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})");
                        }
                        else
                        {
                            DoPlannerUpdate(PType.Mode);
                        }
                    }
                }
            }

            private bool isWiring = false;

            public void TickUpdate(PlayerTick tick)
            {
                if (!initialized)
                    return;

                bool changedInput = tick.inputState.aimAngles != lastAimAngles || tick.inputState.buttons != serverInput.previous.buttons || lastSocketForce;

                if (lastSocketForce)
                    lastSocketForce = false;

                if (changedInput && !ctvTrgt)
                {
                    rayHit = default(RaycastHit);
                    lastAimAngles = tick.inputState.aimAngles;
                    int layer = sRmvr && Instance.removeToolObjects ? 1143089921 : 2097921;
                    float range = 24f;

                    if (sRmvr)
                        range = Instance.removeToolRange;
                    else if (isHammering)
                        range = Instance.hammerToolRange;

                    lastRay = new Ray(tick.position + new Vector3(0f, 1.5f, 0f), Quaternion.Euler(tick.inputState.aimAngles) * Vector3.forward);

                    if (Physics.Raycast(lastRay, out rayHit, range, layer, QueryTriggerInteraction.Ignore))
                    {
                        BaseEntity ent = rayHit.GetEntity();
                        if (ent != null && ent != rayEntity)
                        {
                            rayEntity = ent;
                            rayDefinition = PrefabAttribute.server.Find<Construction>(rayEntity.prefabID);
                            if (rayEntity.OwnerID > 0uL) rayEntityOwner = Instance.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString());
                            else rayEntityOwner = null;
                            rayEntityName = "";
                            if (rayDefinition) rayEntityName = rayDefinition.info.name.english;
                            if (rayEntityName.Length == 0)
                            {
                                if (rayEntity is BaseCombatEntity)
                                {
                                    rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName.english;
                                    if (rayEntityName == null || rayEntityName.Length == 0) rayEntityName = rayEntity.ShortPrefabName;
                                }
                                else
                                {
                                    rayEntityName = rayEntity.ShortPrefabName;
                                }
                            }

                            if (rayDefinition == null && (rayEntity.PrefabName.EndsWith("static.prefab") || rayEntity.PrefabName.Contains("/deployable/")))
                            {
                                rayDefinition = new Construction();
                                rayDefinition.rotationAmount = new Vector3(0, 90f, 0);
                                rayDefinition.fullName = rayEntity.PrefabName;
                                rayDefinition.maxplaceDistance = 8f;
                            }
                        }
                        else if (ent == null)
                        {
                            rayEntity = null;
                            rayDefinition = null;
                            rayEntityOwner = null;
                            rayEntityName = "";
                        }
                    }
                    else
                    {
                        rayEntity = null;
                        rayDefinition = null;
                        rayEntityOwner = null;
                        rayEntityName = "";
                    }

                    if (isPlanner)
                    {
                        if (lstWrnng != string.Empty)
                            DoWarning(string.Empty, true);

                        target = default(Construction.Target);
                        target.player = player;
                        target.ray = lastRay;
                        CheckPlacement(ref target, construction);

                        if (target.socket != null && (target.socket != lastSocketBase || target.entity != lastSocketEntity || lastSocketForce))
                        {
                            if (lastSocketForce)
                                lastSocketForce = false;

                            bool chEnt = false;
                            if (Instance.effectFoundationPlacement && construction.hierachyName.Contains("foundation") && lastSocketEntity != target.entity)
                            {
                                chEnt = true;
                                SendEffectTo(3951505782, target.entity, player);
                            }

                            lastSocketEntity = target.entity;
                            string name = target.entity.ShortPrefabName;

                            if (target.entity is BuildingBlock)
                                DoPlannerUpdate(PType.ConnectTo, $"{rayEntityName} [{target.entity.net.ID}] ({(target.entity as BuildingBlock).currentGrade.gradeBase.type.ToString()})");
                            else DoPlannerUpdate(PType.ConnectTo, $"{rayEntityName} [{target.entity.net.ID}]");

                            if (Instance.effectFoundationPlacement && !chEnt && construction.hierachyName.Contains("foundation") && lastSocketBase != target.socket)
                                SendEffectTo(3389733993, target.entity, player);

                            lastSocketBase = target.socket;
                            lastSocketPos = lastSocketEntity.transform.localToWorldMatrix.MultiplyPoint3x4(lastSocketBase.position);

                            string s1 = lastSocketBase.socketName.Replace($"{target.entity.ShortPrefabName}/sockets/", "").TrimEnd('/', '1', '2', '3', '4').Replace("-", " ").Replace("–", " ");

                            DoPlannerUpdate(PType.ToSocket, $"{Oxide.Core.ExtensionMethods.TitleCase(s1)}");
                            lastPlacement = CheckPlacement(target, construction);

                            if (lastPlacement != null)
                                DoPlannerUpdate(PType.PosRot, $"{lastPlacement.position.ToString("N1")} | {lastPlacement.rotation.eulerAngles.y.ToString("N1")}°");
                            else DoPlannerUpdate(PType.PosRot);
                        }

                        if (sTpDplybl)
                        {
                            lastPlacement = CheckPlacement(target, construction);

                            if (lastPlacement != null)
                            {
                                DoPlannerUpdate(PType.PosRot, $"{lastPlacement.position.ToString("N1")} | {lastPlacement.rotation.eulerAngles.ToString("N1")}");
                                DoPlannerUpdate(PType.ToSocket, "Terrain");
                                if (rayEntity) DoPlannerUpdate(PType.ConnectTo, $"{rayEntityName} [{rayEntity.net.ID}]");
                            }
                            else
                            {
                                DoPlannerUpdate(PType.ToSocket);
                                DoPlannerUpdate(PType.ConnectTo);
                                DoPlannerUpdate(PType.PosRot);
                            }
                        }

                        if (!sTpDplybl && !target.socket)
                        {
                            lastSocketBase = default(Socket_Base);
                            lastSocketEntity = default(BaseEntity);

                            DoPlannerUpdate(PType.ConnectTo);
                            DoPlannerUpdate(PType.PosRot);
                            DoPlannerUpdate(PType.ToSocket);
                        }
                    }
                    else if (isHammering)
                    {
                        if (lstWrnng != string.Empty)
                            DoWarning(string.Empty, true);

                        if (!ctvTrgt)
                        {
                            if (rayEntity && rayHit.distance <= Instance.hammerToolRange)
                            {
                                if (rayDefinition && rayEntity is BuildingBlock)
                                {
                                    DoHammerUpdate(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}] ({(rayEntity as BuildingBlock).currentGrade.gradeBase.type.ToString()})");
                                    DoCrosshair("0 1 0 0.75");
                                }
                                else if (rayDefinition)
                                {
                                    if (rayDefinition.fullName == StringPool.Get(3424003500))
                                        DoHammerUpdate(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}] (Type: {(rayEntity as MiningQuarry).staticType})");
                                    else DoHammerUpdate(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}]");

                                    DoCrosshair("1 0.921568632 0.0156862754 0.75");
                                }
                                else
                                {
                                    DoHammerUpdate(HType.Target, $"{rayEntityName} [{rayEntity.net.ID}]");
                                }

                                DoHammerUpdate(HType.Mode, "Modify");
                                DoHammerUpdate(HType.Building, rayEntity is DecayEntity ? $"ID {(rayEntity as DecayEntity).buildingID}" : "None");

                                if (rayDefinition)
                                {
                                    float currentTime = Time.realtimeSinceStartup;
                                    if (currentTime - lastPosRotUpdate >= 0.25f)
                                    {
                                        if (rayEntity is BuildingBlock)
                                            DoHammerUpdate(HType.PosRot, $"{rayEntity.transform.position.ToString("N1")} | {rayEntity.transform.rotation.eulerAngles.y.ToString("N1")}°");
                                        else DoHammerUpdate(HType.PosRot, $"{rayEntity.transform.position.ToString("N1")} | {rayEntity.transform.rotation.eulerAngles.ToString("N1")}");

                                        lastPosRotUpdate = currentTime;
                                    }

                                    if (rayEntityOwner != null)
                                        DoHammerUpdate(HType.Owner, $"{rayEntityOwner.Name}");
                                    else DoHammerUpdate(HType.Owner, $"{rayEntity.OwnerID}");

                                    DoHammerUpdate(HType.SteamID, $"{rayEntity.OwnerID}");
                                }
                            }
                            else
                            {
                                DoHammerUpdate(HType.Target);
                                DoHammerUpdate(HType.Building);
                                DoHammerUpdate(HType.Mode, r("Zbqvsl"));
                                DoHammerUpdate(HType.PosRot);
                                DoHammerUpdate(HType.Owner);
                                DoCrosshair("1 1 1 0.75");
                            }
                        }
                        else
                        {
                            DoHammerUpdate(HType.PosRot, $"{mvTrgt.entity.transform.position.ToString("N1")} | {mvTrgt.entity.transform.rotation.eulerAngles.ToString("N1")}");
                            DoCrosshair(string.Empty);
                        }
                    }
                    else if (sRmvr)
                    {
                        DoCrosshair(string.Empty);
                        if (rayEntity != null && rayHit.distance <= Instance.removeToolRange && (rayDefinition || !rayDefinition && Instance.removeToolObjects))
                        {
                            DoRemoverUpdate(RType.Remove, $"{rayEntityName} [{rayEntity.net.ID}]");
                            if (rayEntityOwner != null) DoRemoverUpdate(RType.Owner, $"{rayEntityOwner.Name}");
                            else DoRemoverUpdate(RType.Owner, $"{rayEntity.OwnerID}");
                        }
                        else
                        {
                            DoRemoverUpdate(RType.Remove);
                            DoRemoverUpdate(RType.Owner);
                        }

                        if (Instance.enableFullRemove && serverInput.IsDown(controlButtons[CmdType.RemoverHoldForAll]) && rayEntity is BuildingBlock)
                        {
                            DoWarning("1 0 0 0.75");
                            DoRemoverUpdate(RType.Mode, "<color=#ffff00>Building</color>");
                        }
                        else
                        {
                            DoRemoverUpdate(RType.Mode, r("Fvatyr"));
                            DoWarning(string.Empty);
                        }
                    }
                    else if (isAnotherHeld)
                    {
                        if (heldItem is BaseLiquidVessel && (serverInput.WasJustReleased((BTN)1024) || serverInput.WasDown((BTN)2048)))
                        {
                            BaseLiquidVessel vessel = heldItem as BaseLiquidVessel;
                            if (vessel.AmountHeld() < 1) vessel.AddLiquid(ItemManager.FindItemDefinition("water"), vessel.MaxHoldable());
                        }
                        else if (heldItem is BaseProjectile && serverInput.WasJustPressed((BTN)8192))
                        {
                            BaseProjectile weapon = heldItem as BaseProjectile;
                            if (!weapon.primaryMagazine.CanReload(player) && weapon.primaryMagazine.contents < weapon.primaryMagazine.capacity)
                            {
                                try
                                {
                                    player.inventory.GiveItem(ItemManager.Create(weapon.primaryMagazine.ammoType, weapon.primaryMagazine.capacity - weapon.primaryMagazine.contents));
                                }
                                catch { }

                                ItemManager.DoRemoves();
                            }
                        }
                        else if (heldItem is FlameThrower && (serverInput.WasJustPressed((BTN)8192) || serverInput.IsDown((BTN)1024)))
                        {
                            FlameThrower flame = heldItem as FlameThrower;
                            if (serverInput.IsDown((BTN)1024) && flame.ammo < 2 || serverInput.WasJustPressed((BTN)8192) && flame.ammo < flame.maxAmmo)
                            {
                                flame.ammo = flame.maxAmmo;
                                flame.SendNetworkUpdateImmediate(false);
                                ItemManager.DoRemoves();
                                player.inventory.ServerUpdate(0f);
                            }
                        }
                        else if (heldItem is Chainsaw && (serverInput.WasJustPressed((BTN)8192) || serverInput.IsDown((BTN)1024) || serverInput.WasJustPressed((BTN)2048)))
                        {
                            Chainsaw saw = heldItem as Chainsaw;
                            if (serverInput.WasJustPressed((BTN)2048) && !saw.EngineOn())
                            {
                                saw.SetEngineStatus(true);
                                heldItem.SendNetworkUpdateImmediate(false);
                            }
                            else if (serverInput.IsDown((BTN)1024) && saw.ammo < 2 || serverInput.WasJustPressed((BTN)8192) && saw.ammo < saw.maxAmmo)
                            {
                                saw.ammo = saw.maxAmmo;
                                saw.SendNetworkUpdateImmediate(false);
                                ItemManager.DoRemoves();
                                player.inventory.ServerUpdate(0f);
                            }
                        }
                    }
                    else if (isLightDeployer)
                    {
                        PoweredLightsDeployer lightsDeployer = heldItem as PoweredLightsDeployer;
                        if (lightsDeployer == null)
                            return;

                        if (player.serverInput.WasJustPressed(BTN.FIRE_SECONDARY))
                        {
                            lightsDeployer.DoFinish();
                            return;
                        }

                        if (player.serverInput.WasJustPressed(BTN.FIRE_PRIMARY))
                        {
                            RaycastHit raycastHit;
                            if (Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5f))
                            {
                                if (heldItem.GetItem() == null)
                                {
                                    return;
                                }
                                if (heldItem.GetItem().amount < 1)
                                {
                                    return;
                                }
                                if (!heldItem.IsVisible(raycastHit.point, Single.PositiveInfinity))
                                {
                                    return;
                                }

                                if (Vector3.Distance(raycastHit.point, player.eyes.position) > 5f)
                                {
                                    player.ChatMessage("Too far away!");
                                    return;
                                }

                                int amountToUse = 1;
                                if (lightsDeployer.active != null)
                                {
                                    if (lightsDeployer.active.IsFinalized())
                                        return;

                                    float length = 0f;
                                    Vector3 position = lightsDeployer.active.transform.position;
                                    if (lightsDeployer.active.points.Count > 0)
                                    {
                                        position = lightsDeployer.active.points[lightsDeployer.active.points.Count - 1].point;
                                        length = Vector3.Distance(raycastHit.point, position);
                                    }
                                    length = Mathf.Max(length, lightsDeployer.lengthPerAmount);
                                    float item1 = (float)heldItem.GetItem().amount * lightsDeployer.lengthPerAmount;
                                    if (length > item1)
                                    {
                                        length = item1;
                                        raycastHit.point = position + (Vector3Ex.Direction(raycastHit.point, position) * length);
                                    }
                                    length = Mathf.Min(item1, length);
                                    amountToUse = Mathf.CeilToInt(length / lightsDeployer.lengthPerAmount);
                                }
                                else
                                {
                                    AdvancedChristmasLights component = GameManager.server.CreateEntity(lightsDeployer.poweredLightsPrefab.resourcePath, raycastHit.point, Quaternion.LookRotation(raycastHit.normal, player.eyes.HeadUp()), true).GetComponent<AdvancedChristmasLights>();
                                    component.Spawn();
                                    lightsDeployer.active = component;
                                    amountToUse = 1;
                                }

                                lightsDeployer.active.AddPoint(raycastHit.point, raycastHit.normal);
                                lightsDeployer.SetFlag(BaseEntity.Flags.Reserved8, lightsDeployer.active != null, false, true);
                                lightsDeployer.active.AddLengthUsed(amountToUse);
                                lightsDeployer.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            }
                        }
                    }
                    else if (isWireTool)
                    {
                        if (player.serverInput.WasJustPressed(BTN.FIRE_SECONDARY))
                        {
                            source = null;
                            sourceSlot = null;

                            if (isWiring)
                            {
                                isWiring = false;
                                player.ChatMessage("Cancelled current IO connection");
                            }

                            return;
                        }

                        if (player.serverInput.WasJustPressed(BTN.FIRE_PRIMARY))
                        {
                            RaycastHit raycastHit;
                            Ray ray = player.eyes.HeadRay();
                            if (Physics.Raycast(ray, out raycastHit, 5f))
                            {
                                IOEntity ioEntity = raycastHit.GetEntity() as IOEntity;
                                if (!isWiring)
                                {
                                    if (ioEntity != null)
                                    {
                                        IOEntity.IOSlot[] slots = ioEntity.outputs;

                                        IOEntity.IOSlot target = null;
                                        float distance = float.PositiveInfinity;

                                        for (int i = 0; i < slots.Length; i++)
                                        {
                                            IOEntity.IOSlot slot = slots[i];

                                            if (slot.connectedTo.Get(true) == null)
                                            {
                                                Vector3 point2origin = ray.origin - ioEntity.transform.TransformPoint(slot.handlePosition);
                                                Vector3 point2closestPointOnLine = point2origin - Vector3.Dot(point2origin, ray.direction) * ray.direction;
                                                float d = point2closestPointOnLine.magnitude;
                                                if (d < distance)
                                                {
                                                    distance = d;
                                                    target = slot;
                                                }
                                            }
                                        }

                                        if (target != null && distance < 0.2f)
                                        {
                                            source = ioEntity;
                                            sourceSlot = target;
                                            isWiring = true;

                                            player.ChatMessage($"Begin Wiring - From {source.ShortPrefabName} (Slot {sourceSlot.niceName})");
                                            player.SendConsoleCommand("ddraw.sphere", 30f, Color.green, source.transform.TransformPoint(sourceSlot.handlePosition), 0.025f);
                                            Effect.server.Run(WIRE_EFFECT, ioEntity.transform.position);
                                        }
                                        else player.ChatMessage("No valid IO Entity found");
                                    }
                                }
                                else
                                {
                                    if (ioEntity == null)
                                        player.ChatMessage("Select another IO slot to make a connection");
                                    else
                                    {
                                        if (ioEntity == source)
                                        {
                                            player.ChatMessage("You can not connect a IO entity to itself");
                                            return;
                                        }

                                        IOEntity.IOSlot[] slots = ioEntity.inputs;

                                        IOEntity.IOSlot target = null;
                                        float distance = float.PositiveInfinity;
                                        int index = -1;
                                        
                                        for (int i = 0; i < slots.Length; i++)
                                        {
                                            IOEntity.IOSlot slot = slots[i];

                                            if (slot.connectedTo.Get(true) == null)
                                            {
                                                Vector3 point2origin = ray.origin - ioEntity.transform.TransformPoint(slot.handlePosition);
                                                Vector3 point2closestPointOnLine = point2origin - Vector3.Dot(point2origin, ray.direction) * ray.direction;
                                                float d = point2closestPointOnLine.magnitude;
                                                if (d < distance)
                                                {
                                                    distance = d;
                                                    target = slot;
                                                    index = i;
                                                }
                                            }
                                        }

                                        if (target != null && distance < 0.2f)
                                        {
                                            player.SendConsoleCommand("ddraw.sphere", 30f, Color.green, ioEntity.transform.TransformPoint(target.handlePosition), 0.025f);

                                            sourceSlot.connectedTo = new IOEntity.IORef();
                                            sourceSlot.connectedTo.ioEnt = ioEntity;
                                            sourceSlot.connectedTo.Set(ioEntity);
                                            sourceSlot.connectedToSlot = index;

                                            target.connectedTo = new IOEntity.IORef();
                                            target.connectedTo.ioEnt = source;
                                            target.connectedTo.Set(source);

                                            source.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                                            ioEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                                            source.MarkDirtyForceUpdateOutputs();
                                            ioEntity.MarkDirtyForceUpdateOutputs();

                                            player.ChatMessage($"Connected IO from {source.ShortPrefabName} (Slot {sourceSlot.niceName}) -> {ioEntity.ShortPrefabName} (Slot {target.niceName})");

                                            Effect.server.Run(WIRE_EFFECT, ioEntity.transform.position);

                                            source = null;
                                            sourceSlot = null;
                                            isWiring = false;
                                        }                                        
                                        else player.ChatMessage("Failed to make a connection");
                                    }
                                }
                            }
                        }
                    }
                }
                else if (changedInput && ctvTrgt)
                {
                    DoHammerUpdate(HType.PosRot, $"{mvTrgt.entity.transform.position.ToString("N1")} | {mvTrgt.entity.transform.rotation.eulerAngles.ToString("N1")}");
                    DoCrosshair(string.Empty, true);
                }

                if (isPlanner && !sTpDplybl) if (lastSocketBase != null && lastPlacement != null && lastSocketEntity)
                    {
                        OBB oBB = new OBB(lastPlacement.position, Vector3.one, lastPlacement.rotation, construction.bounds);
                        Vector3 obb_pos = construction.hierachyName.Contains(r("sbhaqngvba")) ? oBB.position + oBB.extents.y * Vector3.up : oBB.position;
                        Vector3 sock_pos = construction.hierachyName.Contains(r("sbhaqngvba")) ? new Vector3(lastSocketPos.x, lastSocketEntity.transform.position.y, lastSocketPos.z) : lastSocketPos;
                        player.SendConsoleCommand("ddraw.box", 0.05f, Color.green, obb_pos, 0.15f);
                        player.SendConsoleCommand("ddraw.box", 0.05f, Color.green, sock_pos, 0.25f);
                        player.SendConsoleCommand("ddraw.line", 0.05f, Color.green, obb_pos, sock_pos);
                    }
            }

            private IOEntity source;
            private IOEntity.IOSlot sourceSlot;

            private void Update()
            {
                if (!ctvTrgt) return;
                if (!isPlacing && isHammering)
                {
                    if (mvTrgt.entity == null)
                    {
                        DoCrosshair("1 1 1 0.75");
                        mvTrgt =
                    default(Construction.Target);
                        isPlacing = false;
                        ctvTrgt = false;
                        return;
                    }

                    bool flag = mvTrgt.entity is SimpleBuildingBlock || mvCnstrctn.allSockets == null;
                    mvTrgt.ray = player.eyes.BodyRay();
                    FndTrrnPlcmnt(ref mvTrgt, mvCnstrctn, tkDist, flag);
                    Vector3 position = mvTrgt.entity.transform.position;
                    Quaternion rotation = mvTrgt.entity.transform.rotation;
                    Vector3 toPos = mvTrgt.position;
                    Quaternion toRot = Quaternion.LookRotation(mvTrgt.entity.transform.up) * Quaternion.Euler(mvOffst);
                    if (flag)
                    {
                        Vector3 direction = mvTrgt.ray.direction;
                        direction.y = 0f;
                        direction.Normalize();
                        toRot = Quaternion.Euler(mvOffst) * Quaternion.LookRotation(direction, Vector3.up);
                    }

                    Construction.Placement check = CheckPlacement(mvTrgt, mvCnstrctn);
                    if (check != null)
                    {
                        toPos = check.position;
                        toRot = check.rotation * Quaternion.Euler(mvOffst);
                    }

                    mvTrgt.entity.transform.position = Vector3.Lerp(position, toPos, Time.deltaTime * 5f);
                    mvTrgt.entity.transform.rotation = Quaternion.Lerp(rotation, toRot, Time.deltaTime * 10f);
                    DMvmntSnc(mvTrgt.entity);
                    return;
                }
                else if (isPlacing)
                {
                    if (mvTrgt.entity == null)
                    {
                        DoCrosshair("1 1 1 0.75");
                        mvTrgt =
                    default(Construction.Target);
                        isPlacing = false;
                        ctvTrgt = false;
                        return;
                    }

                    if (Vector3.Distance(mvTrgt.entity.transform.position, mvTrgt.position) <= 0.005f)
                    {
                        if (mvTrgtSnp && !(mvTrgtSnp is BuildingBlock))
                        {
                            mvTrgt.entity.transform.position = mvTrgtSnp.transform.InverseTransformPoint(mvTrgt.position);
                            mvTrgt.entity.transform.rotation = Quaternion.Inverse(mvTrgtSnp.transform.rotation) * Quaternion.Euler(mvTrgt.rotation);
                            mvTrgt.entity.SetParent(mvTrgtSnp, 0u);
                        }

                        if (mvTrgtSnp)
                        {
                            DecayUpdate(mvTrgt.entity, true, mvCnstrctn.isBuildingPrivilege, mvTrgtSnp);
                            mvTrgtSnp = null;
                        }

                        DMvmntSnc(mvTrgt.entity);
                        DoCrosshair("1 1 1 0.75");
                        mvTrgt =
                    default(Construction.Target);
                        isPlacing = false;
                        ctvTrgt = false;
                        return;
                    }

                    mvTrgt.entity.transform.position = Vector3.Lerp(mvTrgt.entity.transform.position, mvTrgt.position, Time.deltaTime * 10f);
                    if (mvTrgtSnp == null || mvTrgtSnp && !(mvTrgtSnp is BuildingBlock))
                        mvTrgt.entity.transform.rotation = Quaternion.Lerp(mvTrgt.entity.transform.rotation, Quaternion.Euler(mvTrgt.rotation), Time.deltaTime * 10f);
                    DMvmntSnc(mvTrgt.entity);
                    return;
                }
                else if (!isPlacing && !isHammering)
                {
                    if (mvTrgt.valid) PlaceOnTarget();
                    else TrPlcTrgt();
                }
            }

            private void DecayUpdate(BaseEntity entity, bool isAdding, bool isBuildingPrivilege, BaseEntity target = null)
            {
                DecayEntity decayEntity = entity as DecayEntity;
                if (decayEntity == null) return;
                BuildingManager.Building building = null;
                if (isAdding)
                {
                    DecayEntity decayTarget = target != null ? target as DecayEntity : null;
                    if (decayTarget != null) building = BuildingManager.server.GetBuilding(decayTarget.buildingID);

                    if (building != null)
                    {
                        building.AddDecayEntity(decayEntity);
                        if (isBuildingPrivilege) building.AddBuildingPrivilege(decayEntity as BuildingPrivlidge);
                        building.Dirty();
                        decayEntity.buildingID = building.ID;
                    }
                }
                else
                {
                    building = BuildingManager.server.GetBuilding(decayEntity.buildingID);
                    if (building != null)
                    {
                        if (building.decayEntities != null) building.RemoveDecayEntity(decayEntity);
                        if (isBuildingPrivilege && building.buildingPrivileges != null) building.RemoveBuildingPrivilege(decayEntity as BuildingPrivlidge);
                        building.Dirty();
                    }

                    decayEntity.buildingID = 0u;
                }

                decayEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                if (entity.children != null) foreach (BaseEntity current in entity.children) DecayUpdate(current, isAdding, isBuildingPrivilege, isAdding ? entity : null);
            }

            private void PlaceOnTarget()
            {
                if (mvTrgtSnp && !(mvTrgtSnp is BuildingBlock))
                {
                    mvTrgt.entity.transform.position = mvTrgtSnp.transform.worldToLocalMatrix.MultiplyPoint3x4(mvTrgt.position);
                    mvTrgt.entity.transform.rotation = Quaternion.Inverse(mvTrgtSnp.transform.rotation) * mvTrgt.entity.transform.rotation;
                    mvTrgt.entity.SetParent(mvTrgtSnp, 0u);
                }

                if (mvTrgtSnp)
                {
                    DecayUpdate(mvTrgt.entity, true, mvCnstrctn.isBuildingPrivilege, mvTrgtSnp);
                    mvTrgtSnp = null;
                }

                DMvmntSnc(mvTrgt.entity);
                mvTrgt =
            default(Construction.Target);
                ctvTrgt = false;
                isPlacing = false;
            }

            private void TrPlcTrgt()
            {
                RaycastHit hit;
                mvTrgtSnp = null;
                int layer = mvCnstrctn.isBuildingPrivilege ? 2097152 : 27328769;
                if (Physics.Raycast(mvTrgt.entity.transform.position, mvTrgt.entity.transform.up * -1.0f, out hit, float.PositiveInfinity, layer))
                {
                    mvTrgt.position = hit.point;
                    if (hit.collider is TerrainCollider)
                    {
                        mvTrgt.rotation = Quaternion.LookRotation(Vector3.Cross(mvTrgt.entity.transform.right, hit.normal)).eulerAngles;
                        DoHammerUpdate(HType.Building, "None");
                    }
                    else
                    {
                        mvTrgtSnp = hit.GetEntity();
                        if (mvTrgtSnp)
                        {
                            mvTrgt.rotation = mvTrgt.entity.transform.rotation.eulerAngles;
                            DoHammerUpdate(HType.Building, rayEntity is DecayEntity ? $"ID {(rayEntity as DecayEntity).buildingID}" : "None");
                        }
                        else
                        {
                            DoHammerUpdate(HType.Building, "None");
                        }
                    }

                    isPlacing = true;
                    return;
                }
                else
                {
                    mvTrgt = default(Construction.Target);
                    ctvTrgt = false;
                    isPlacing = false;
                    return;
                }
            }

            public object GtMvTrgt()
            {
                if (ctvTrgt && mvTrgt.entity != null) return (uint)mvTrgt.entity.net.ID;
                return null;
            }

            private void DMvmntSnc(BaseEntity entity, bool isChild = false)
            {
                if (entity == null)
                {
                    DoCrosshair("1 1 1 0.75");
                    mvTrgt = default(Construction.Target);
                    isPlacing = false;
                    ctvTrgt = false;
                    return;
                }

                bool force2 = entity.PrefabName == StringPool.Get(2206646561) || entity.PrefabName == StringPool.Get(2335812770);
                if (isChild || force2)
                {
                    if (Net.sv.write.Start())
                    {
                        Net.sv.write.PacketID(Message.Type.EntityDestroy);
                        Net.sv.write.UInt32(entity.net.ID);
                        Net.sv.write.UInt8(0);
                        Net.sv.write.Send(new SendInfo(entity.net.group.subscribers));
                    }

                    entity.SendNetworkUpdateImmediate(false);
                    if (isChild) return;
                }
                else
                {
                    if (Net.sv.write.Start())
                    {
                        Net.sv.write.PacketID(Message.Type.GroupChange);
                        Net.sv.write.EntityID(entity.net.ID);
                        Net.sv.write.GroupID(entity.net.group.ID);
                        Net.sv.write.Send(new SendInfo(entity.net.group.subscribers));
                    }

                    if (Net.sv.write.Start())
                    {
                        Net.sv.write.PacketID(Message.Type.EntityPosition);
                        Net.sv.write.EntityID(entity.net.ID);

                        Net.sv.write.WriteObject(entity.GetNetworkPosition());
                        Net.sv.write.WriteObject(entity.GetNetworkRotation().eulerAngles);

                        Net.sv.write.Float(entity.GetNetworkTime());
                        SendInfo info = new SendInfo(entity.net.group.subscribers)
                        {
                            method = SendMethod.ReliableUnordered,
                            priority = Priority.Immediate
                        };
                        Net.sv.write.Send(info);
                    }
                }

                if (force2 && entity && entity.children != null)
                    foreach (BaseEntity current in entity.children)
                        DMvmntSnc(current, true);
            }

            public void DoTick()
            {
                if (!initialized || !heldItem) return;

                if (isPlanner)
                {
                    if (true)
                    {
                        if (serverInput.WasJustPressed(controlButtons[CmdType.PlannerPlace]))
                        {
                            DoPlacement();
                            return;
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.PlannerRotate]))
                        {
                            Vector3 vector = Vector3.zero;
                            if (construction && construction.canRotateBeforePlacement)
                                vector = construction.rotationAmount;
                            rttnOffst.x = Mathf.Repeat(rttnOffst.x + vector.x, 360f);
                            rttnOffst.y = Mathf.Repeat(rttnOffst.y + vector.y, 360f);
                            rttnOffst.z = Mathf.Repeat(rttnOffst.z + vector.z, 360f);
                            return;
                        }
                    }

                    if (!sTpDplybl)
                    {
                        if (serverInput.WasJustPressed((BTN)2048))
                        {
                            BldMnUI(Instance.playerPrefs.playerData[player.userID].SF);
                            return;
                        }

                        if (serverInput.IsDown(controlButtons[CmdType.PlannerTierChange]))
                        {
                            if (serverInput.WasJustPressed(controlButtons[CmdType.PlannerTierNext]))
                            {
                                dfltGrd++;
                                if (dfltGrd > 4) dfltGrd = 0;
                                Instance.playerPrefs.playerData[player.userID].DBG = dfltGrd;
                                DoPlannerUpdate(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})");
                                return;
                            }
                            else if (serverInput.WasJustPressed(controlButtons[CmdType.PlannerTierPrev]))
                            {
                                dfltGrd--;
                                if (dfltGrd < 0) dfltGrd = 4;
                                Instance.playerPrefs.playerData[player.userID].DBG = dfltGrd;
                                DoPlannerUpdate(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})");
                                return;
                            }
                        }
                    }
                    else if (sTpDplybl) { }
                }
                else if (isHammering)
                {
                    if (ctvTrgt)
                    {
                        if (isPlacing) { }
                        else if (!isPlacing)
                        {
                            if (serverInput.WasJustPressed(controlButtons[CmdType.HammerTransform]))
                            {
                                if (mvTrgt.valid) PlaceOnTarget();
                                else TrPlcTrgt();
                                return;
                            }
                            else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerRotate]))
                            {
                                Vector3 vector = Vector3.zero;
                                if (mvCnstrctn && mvCnstrctn.canRotateAfterPlacement)
                                {
                                    if (serverInput.IsDown(controlButtons[CmdType.HammerRotateDirection])) vector = -mvCnstrctn.rotationAmount;
                                    else vector = mvCnstrctn.rotationAmount;
                                }

                                mvOffst.x = Mathf.Repeat(mvOffst.x + vector.x, 360f);
                                mvOffst.y = Mathf.Repeat(mvOffst.y + vector.y, 360f);
                                mvOffst.z = Mathf.Repeat(mvOffst.z + vector.z, 360f);
                                return;
                            }
                        }
                    }
                    else if (!ctvTrgt)
                    {
                        if (serverInput.WasJustPressed(controlButtons[CmdType.HammerChangeGrade]) && rayEntity && rayEntity.IsValid() && rayEntity is BuildingBlock)
                        {
                            BuildingBlock block = rayEntity as BuildingBlock;
                            int grade = (int)block.currentGrade.gradeBase.type;
                            grade++;
                            if (grade >= block.blockDefinition.grades.Length) grade = 1;
                            block.SetGrade((BuildingGrade.Enum)grade);
                            block.SetHealthToMax();
                            block.StartBeingRotatable();
                            rayEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            block.UpdateSkin(false);
                            BuildingManager.Building building = BuildingManager.server.GetBuilding(block.buildingID);
                            if (building != null) building.Dirty();
                            if (Instance.effectPromotingBlock) Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + ((BuildingGrade.Enum)grade).ToString().ToLower() + ".prefab", rayEntity, 0u, Vector3.zero, Vector3.zero, null, false);
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerToggleOnOff]) && rayEntity && rayEntity.IsValid() && !(rayEntity is BuildingBlock))
                        {
                            BaseEntity r = rayEntity;
                            if (r is StorageContainer || r is IOEntity)
                            {
                                bool isOn = r.HasFlag(BaseEntity.Flags.On);
                                bool hasPower = isOn & r is IOEntity;
                                r.SetFlag(BaseEntity.Flags.On, !isOn, false);
                                if (r is IOEntity) r.SetFlag(BaseEntity.Flags.Reserved8, !hasPower, false);
                                r.SendNetworkUpdate();
                                return;
                            }
                            else if (r is MiningQuarry)
                            {
                                MiningQuarry q = r as MiningQuarry;
                                q.staticType = (MiningQuarry.QuarryType)(int)q.staticType + 1;
                                if ((int)q.staticType > 3) q.staticType = (MiningQuarry.QuarryType)0;
                                q.UpdateStaticDeposit();
                            }
                            else if (r is EngineSwitch)
                            {
                                MiningQuarry miningQuarry = r.GetParentEntity() as MiningQuarry;
                                if (miningQuarry) miningQuarry.EngineSwitch(true);
                            }
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerRotate]))
                        {
                            if (!rayEntity || !rayEntity.IsValid() || rayDefinition == null || rayDefinition.rotationAmount.y == 0f) return;
                            string effectPath = rayDefinition.deployable != null && rayDefinition.deployable.placeEffect.isValid ? rayDefinition.deployable.placeEffect.resourcePath : StringPool.Get(2598153373);
                            if (serverInput.IsDown(controlButtons[CmdType.HammerRotateDirection])) rayEntity.transform.Rotate(-rayDefinition.rotationAmount);
                            else rayEntity.transform.Rotate(rayDefinition.rotationAmount);
                            if (rayEntity is StabilityEntity)
                            {
                                rayEntity.RefreshEntityLinks();
                                if (!Instance.overrideStabilityBuilding && !(rayEntity as StabilityEntity).grounded) (rayEntity as StabilityEntity).UpdateSurroundingEntities();
                                if (rayEntity is BuildingBlock)
                                {
                                    ConstructionSkin conskin = rayEntity.gameObject.GetComponentInChildren<ConstructionSkin>();
                                    if (conskin) conskin.Refresh(rayEntity as BuildingBlock);
                                    rayEntity.ClientRPC(null, r("ErserfuFxva"));
                                }
                            }

                            DMvmntSnc(rayEntity);
                            Effect.server.Run(effectPath, rayEntity, 0u, Vector3.zero, Vector3.zero, null, false);
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerTransform]))
                        {
                            if (mvTrgt.entity != null)
                            {
                                mvTrgt =
                            default(Construction.Target);
                                ctvTrgt = false;
                                isPlacing = false;
                                return;
                            }

                            if (!rayEntity || rayEntity is BuildingBlock || rayEntity.FindLinkedEntity<BuildingBlock>()) return;
                            if (rayEntity is BaseMountable && (rayEntity as BaseMountable)._mounted != null) return;
                            mvCnstrctn = PrefabAttribute.server.Find<Construction>(rayEntity.prefabID);
                            if (mvCnstrctn == null)
                            {
                                if (!rayEntity.PrefabName.EndsWith("static.prefab") && !rayEntity.PrefabName.Contains("/deployable/")) return;
                                mvCnstrctn = new Construction();
                                mvCnstrctn.rotationAmount = new Vector3(0, 90f, 0);
                                mvCnstrctn.fullName = rayEntity.PrefabName;
                                mvCnstrctn.maxplaceDistance = rayEntity is MiningQuarry ? 8f : 4f;
                                mvCnstrctn.canRotateBeforePlacement = mvCnstrctn.canRotateAfterPlacement = true;
                            }

                            if (rayEntity is DecayEntity)
                            {
                                DecayUpdate(rayEntity, false, mvCnstrctn.isBuildingPrivilege);
                                DoHammerUpdate(HType.Building, "None");
                            }

                            mvTrgt =
                        default(Construction.Target);
                            mvOffst = Vector3.zero;
                            if (rayEntity.HasParent())
                            {
                                Vector3 position = rayEntity.transform.position;
                                Quaternion rotation = rayEntity.transform.rotation;
                                rayEntity.SetParent(null, 0u);
                                rayEntity.transform.position = position;
                                rayEntity.transform.rotation = rotation;
                                DMvmntSnc(rayEntity);
                            }

                            if (rayEntity.children.Count == 0 || !rayEntity.HasParent()) DMvmntSnc(rayEntity);
                            tkDist = Mathf.Clamp(Vector3.Distance(rayEntity.transform.position, lastRay.origin), mvCnstrctn.maxplaceDistance, mvCnstrctn.maxplaceDistance * 3f);
                            mvTrgt.entity = rayEntity;
                            isPlacing = false;
                            ctvTrgt = true;
                            DoHammerUpdate(HType.Mode, r("Ercbfvgvbavat"));
                        }
                        else if (serverInput.WasJustPressed(controlButtons[CmdType.HammerAuthInfo]) && !serverInput.WasDown(controlButtons[CmdType.HammerTransform]) && (Instance.enableHammerTCInfo || Instance.enableHammerCodelockInfo))
                        {
                            string infoMsg = "";
                            if (Instance.enableHammerTCInfo && rayEntity && rayEntity is BuildingPrivlidge)
                            {
                                bool hasClans = Instance.Clans != null ? true : false;
                                StringBuilder sb = new StringBuilder();
                                rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName?.english;
                                sb.Append(
                                $">\nBuilding privilege authorized users for <color=#ffa500>{rayEntityName}</color> (<color=#00ffff>{rayEntity.net.ID}</color>)");
                                IPlayer iPlayer = Instance.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString());
                                if (iPlayer != null)
                                {
                                    sb.Append(
                                    $" | Owner: <color=#ffa500>{iPlayer.Name}</color> (<color=#00ffff>{iPlayer.Id}</color>) | ");
                                    if (iPlayer.IsConnected) sb.AppendLine($"Status: <color=#008000>Online</color>");
                                    else sb.AppendLine($"Status: <color=#ffffff>Offline</color>");
                                }

                                TextTable textTable = new TextTable();
                                textTable.AddColumn("Name");
                                textTable.AddColumn("UserID");
                                if (hasClans) textTable.AddColumn("Clan");
                                textTable.AddColumn("Status");
                                foreach (PlayerNameID nameID in (rayEntity as BuildingPrivlidge).authorizedPlayers.ToList())
                                {
                                    IPlayer authedP = Instance.covalence.Players.FindPlayerById(nameID.userid.ToString());
                                    if (authedP == null) continue;
                                    if (hasClans)
                                    {
                                        string clanTag = "-";
                                        string tag = (string)Instance.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id));
                                        if (tag != null) clanTag = tag;
                                        textTable.AddRow(new string[] {
                                            authedP.Name,
                                            authedP.Id,
                                            clanTag,
                                            ((authedP as RustPlayer).IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                        });
                                    }
                                    else
                                    {
                                        textTable.AddRow(new string[] {
                                            authedP.Name,
                                            authedP.Id,
                                            ((authedP as RustPlayer).IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                        });
                                    }
                                }

                                sb.AppendLine(textTable.ToString());
                                player.ConsoleMessage(sb.ToString());
                                infoMsg += $"<color=#ffa500>TC</color> (<color=#00ffff>{rayEntity.net.ID}</color>) authorized players sent to console";
                            }

                            if (Instance.enableHammerCodelockInfo && rayEntity && rayEntity.HasSlot(BaseEntity.Slot.Lock) && rayEntity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
                            {
                                bool hasClans = Instance.Clans != null ? true : false;
                                CodeLock codeLock = (CodeLock)rayEntity.GetSlot(BaseEntity.Slot.Lock);
                                StringBuilder sb = new StringBuilder();
                                rayEntityName = (rayEntity as BaseCombatEntity).repair.itemTarget?.displayName.english;
                                sb.Append(
                                $">\nCodeLock authorized users attached to <color=#ffa500>{rayEntityName}</color> (<color=#00ffff>{rayEntity.net.ID}</color>)");
                                IPlayer iPlayer = Instance.covalence.Players.FindPlayerById(rayEntity.OwnerID.ToString());
                                if (iPlayer != null)
                                {
                                    sb.Append(
                                    $" | Owner: <color=#ffa500>{iPlayer.Name}</color> (<color=#00ffff>{iPlayer.Id}</color>) | ");
                                    if (iPlayer.IsConnected) sb.AppendLine($"Status: <color=#008000>Online</color>");
                                    else sb.AppendLine($"Status: <color=#ffffff>Offline</color>");
                                }

                                string code = codeLock.hasCode ? $"<color=#00ffff>{codeLock.code}</color>" : "<color=#00ffff>Not set</color>";
                                string guest = codeLock.hasGuestCode ? $"<color=#00ffff>{codeLock.guestCode}</color>" : "<color=#00ffff>Not set</color>";
                                sb.AppendLine($"Lock code:  {code} | Guest code: {guest}");
                                if (codeLock.whitelistPlayers != null && codeLock.whitelistPlayers.Count > 0)
                                {
                                    sb.AppendLine("Whitelisted:");
                                    TextTable textTable = new TextTable();
                                    textTable.AddColumn("Name");
                                    textTable.AddColumn("UserID");
                                    if (hasClans) textTable.AddColumn("Clan");
                                    textTable.AddColumn("Status");

                                    foreach (ulong userID in codeLock.whitelistPlayers.ToList())
                                    {
                                        IPlayer authedP = Instance.covalence.Players.FindPlayerById(userID.ToString());
                                        if (authedP == null) continue;
                                        if (hasClans)
                                        {
                                            string clanTag = (string)Instance.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id));
                                            if (string.IsNullOrEmpty(clanTag))
                                                clanTag = "-";

                                            textTable.AddRow(new string[] {
                                                authedP.Name,
                                                authedP.Id,
                                                clanTag,
                                                (authedP.IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                            });
                                        }
                                        else
                                        {
                                            textTable.AddRow(new string[] {
                                                authedP.Name,
                                                authedP.Id,
                                                (authedP.IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                            });
                                        }
                                    }

                                    sb.AppendLine(textTable.ToString());
                                }
                                else
                                {
                                    sb.AppendLine("Whitelisted: <color=#ffffff>None</color>");
                                }

                                if (codeLock.guestPlayers != null && codeLock.guestPlayers.Count > 0)
                                {
                                    sb.AppendLine("Guests:");
                                    TextTable textTable = new TextTable();
                                    textTable.AddColumn("Name");
                                    textTable.AddColumn("UserID");
                                    if (hasClans) textTable.AddColumn("Clan");
                                    textTable.AddColumn("Status");
                                    foreach (ulong userID in codeLock.guestPlayers.ToList())
                                    {
                                        IPlayer authedP = Instance.covalence.Players.FindPlayerById(userID.ToString());
                                        if (authedP == null) continue;
                                        if (hasClans)
                                        {
                                            string clanTag = (string)Instance.Clans?.Call("GetClanOf", Convert.ToUInt64(authedP.Id));
                                            if (clanTag.Length == 0) clanTag = "-";
                                            textTable.AddRow(new string[] {
                                                authedP.Name,
                                                authedP.Id,
                                                clanTag,
                                                (authedP.IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                            });
                                        }
                                        else
                                        {
                                            textTable.AddRow(new string[] {
                                                authedP.Name,
                                                authedP.Id,
                                                (authedP.IsConnected ? "<color=#008000>Online</color>": "<color=#ffffff>Offline</color>").ToString()
                                            });
                                        }
                                    }

                                    sb.AppendLine(textTable.ToString());
                                }
                                else
                                {
                                    sb.AppendLine("Guests: <color=#ffffff>None</color>");
                                }

                                player.ConsoleMessage(sb.ToString());
                                infoMsg += (infoMsg.Length > 0 ? "\n" : "") + $"<color=#ffa500>{(rayEntityName == " Tool Cupboard " ? " TC " : rayEntityName)}</color> (<color=#00ffff>{rayEntity.net.ID}</color>) CodeLock info sent to console";
                            }
                            if (infoMsg.Length > 0) player.ChatMessage(Instance.ChatMsg(infoMsg));
                        }
                    }
                }
                else if (sRmvr)
                {
                    if (serverInput.WasJustPressed(controlButtons[CmdType.RemoverRemove]))
                    {
                        if (!serverInput.IsDown(controlButtons[CmdType.RemoverHoldForAll])) DoRm();
                        else if (serverInput.IsDown(controlButtons[CmdType.RemoverHoldForAll])) DoRm(true);
                    }

                    rayEntity = null;
                    rayDefinition = null;
                }
            }

            private void FndTrrnPlcmnt(ref Construction.Target t, Construction c, float maxDistance, bool isQuarry = false)
            {
                int layer = 27328769;
                if (isQuarry) layer = 10551297;
                RaycastHit[] hits = Physics.RaycastAll(t.ray, maxDistance, layer);
                if (hits.Length > 1)
                {
                    GamePhysics.Sort(hits);
                    for (int i = 0; i < hits.Length; i++)
                        if (hits[i].collider.transform.root != t.entity.transform.root)
                        {
                            t.position = t.ray.origin + t.ray.direction * hits[i].distance;
                            t.normal = hits[i].normal;
                            t.rotation = Vector3.zero;
                            t.onTerrain = true;
                            t.valid = true;
                            if (!isQuarry) mvTrgtSnp = hits[i].GetEntity();
                            return;
                        }
                }

                t.position = t.ray.origin + t.ray.direction * maxDistance;
                t.normal = Vector3.up;
                t.rotation = Vector3.zero;
                t.onTerrain = true;
                t.valid = false;
                mvTrgtSnp = null;
            }

            public void SetBlockPrefab(uint p)
            {
                construction = PrefabAttribute.server.Find<Construction>(p);
                rttnOffst = Vector3.zero;
                lstPrfb = p;
                DoPlannerUpdate(PType.Mode, $"{construction.info.name.english} ({((BuildingGrade.Enum)dfltGrd).ToString()})");
                lastPlacement = null;
                lastSocketForce = true;
            }

            public void OnDestroy()
            {
                DoCrosshair(string.Empty, true);
                DoWarning(string.Empty, true);
                foreach (Item item in player.inventory.AllItems().Where(x => x.IsValid()).ToList())
                    if (item.skin == Convert.ToUInt64(Instance.playerTools[0][2]) || item.skin == Convert.ToUInt64(Instance.playerTools[1][2]) || item.skin == Convert.ToUInt64(Instance.playerTools[2][2]))
                    {
                        item.skin = 0uL;
                        item.GetHeldEntity().skinID = 0uL;
                        item.name = string.Empty;
                        item.MarkDirty();
                    }

                DestroyInfo();
                Destroy(this);
            }

            private void DoRm(bool remAl = false)
            {
                if (!rayEntity || rayEntity is BasePlayer && !(rayEntity is NPCPlayer) || !Instance.removeToolObjects && !rayDefinition) return;
                if (rayEntity.IsValid())
                {
                    if (rayEntity is BuildingBlock)
                    {
                        if (Instance.enableFullRemove && remAl)
                        {
                            CollRm(rayEntity);
                            return;
                        }
                        else
                        {
                            if (Instance.effectRemoveBlocksOn) Effect.server.Run(Instance.effectRemoveBlocks, rayEntity, 0u, Vector3.zero, Vector3.zero, null, false);
                            rayEntity.Kill(BaseNetworkable.DestroyMode.Gib);
                            rayEntity = null;
                            rayDefinition = null;
                            return;
                        }
                    }
                    else
                    {
                        if (rayEntity is OreResourceEntity)
                        {
                            (rayEntity as OreResourceEntity).CleanupBonus();
                        }
                        else if (rayEntity is BaseNpc || rayEntity is NPCPlayer || rayEntity is BradleyAPC || rayEntity is BaseHelicopter)
                        {
                            (rayEntity as BaseCombatEntity).DieInstantly();
                        }
                        else
                        {
                            if (!Instance.entRemoval.Contains(rayEntity.transform.root)) Instance.entRemoval.Add(rayEntity.transform.root);
                            rayEntity.Kill(BaseNetworkable.DestroyMode.Gib);
                        }

                        rayEntity = null;
                        rayDefinition = null;
                    }
                }
                else
                {
                    GameManager.Destroy(rayEntity.gameObject, 0f);
                    rayEntity = null;
                    rayDefinition = null;
                }
            }

            private void CollRm(BaseEntity srcntt)
            {
                BuildingBlock bldngBlck = srcntt.GetComponent<BuildingBlock>();
                if (bldngBlck)
                {
                    BuildingManager.Building building = BuildingManager.server.GetBuilding(bldngBlck.buildingID);
                    ServerMgr.Instance.StartCoroutine(DlyRm(building.buildingBlocks.ToList(), building.decayEntities.ToList(), building.buildingPrivileges.ToList()));
                }
            }

            private WaitForEndOfFrame wait = new WaitForEndOfFrame();

            private IEnumerator DlyRm(List<BuildingBlock> bLst, List<DecayEntity> dLst, List<BuildingPrivlidge> pLst)
            {
                BaseNetworkable.DestroyMode mode = Instance.showGibsOnRemove ? BaseNetworkable.DestroyMode.Gib : BaseNetworkable.DestroyMode.None;
                for (int i = 0; i < pLst.Count; i++)
                    if (!pLst[i].IsDestroyed)
                    {
                        if (pLst[i] == rayEntity)
                        {
                            rayEntity = null;
                            rayDefinition = null;
                        }

                        pLst[i].Kill(mode);
                        yield
                        return wait;
                    }

                for (int i = 0; i < dLst.Count; i++)
                    if (!dLst[i].IsDestroyed)
                    {
                        if (dLst[i] == rayEntity)
                        {
                            rayEntity = null;
                            rayDefinition = null;
                        }

                        dLst[i].Kill(mode);
                        yield
                        return wait;
                    }

                for (int i = 0; i < bLst.Count; i++)
                    if (!bLst[i].IsDestroyed)
                    {
                        if (bLst[i] == rayEntity)
                        {
                            rayEntity = null;
                            rayDefinition = null;
                        }

                        bLst[i].Kill(mode);
                        yield
                        return wait;
                    }

                yield
                break;
            }

            private void DoPlacement()
            {
                ChkQrr(construction);
                Deployable dplybl = plnnr.GetDeployable();
                GameObject gameObject = DoPlaG(target, construction);
                if (gameObject != null)
                {
                    Interface.CallHook(r("BaRagvglOhvyg"), new object[] {
                        plnnr,
                        gameObject
                    });
                    if (dplybl != null)
                    {
                        if (dplybl.placeEffect.isValid)
                        {
                            if (target.entity && target.socket) Effect.server.Run(dplybl.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up, null, false);
                            else Effect.server.Run(dplybl.placeEffect.resourcePath, target.position, target.normal, null, false);
                        }

                        BaseEntity bsntt = gameObject.ToBaseEntity();
                        if (!(bsntt is MiningQuarry) && !(bsntt is Elevator) && !(target.entity is BuildingBlock) && target.entity != null)
                        {
                            bsntt.transform.position = target.entity.transform.worldToLocalMatrix.MultiplyPoint3x4(target.position);
                            bsntt.transform.rotation = Quaternion.Inverse(target.entity.transform.rotation) * bsntt.transform.rotation;
                            bsntt.SetParent(target.entity, 0u);
                        }

                        if (dplybl.wantsInstanceData && ctvtmLnk.instanceData != null) (bsntt as IInstanceDataReceiver).ReceiveInstanceData(ctvtmLnk.instanceData);
                        if (dplybl.copyInventoryFromItem)
                        {
                            StorageContainer component2 = bsntt.GetComponent<StorageContainer>();
                            if (component2)
                            {
                                component2.ReceiveInventoryFromItem(ctvtmLnk);
                                ctvtmLnk.OnVirginSpawn();
                                ctvtmLnk.MarkDirty();
                            }
                        }
                        if (bsntt is SleepingBag)
                            (bsntt as SleepingBag).deployerUserID = player.userID;
                                                
                        bsntt.OnDeployed(bsntt.GetParentEntity(), player, plnnr.GetItem());

                        if (Instance.setDeployableOwner)
                            bsntt.OwnerID = player.userID;
                    }
                }
            }

            private void CheckPlacement(ref Construction.Target t, Construction c)
            {
                t.valid = false;
                if (c.socketHandle != null)
                {
                    Vector3 worldPosition = c.socketHandle.worldPosition;
                    Vector3 a = t.ray.origin + t.ray.direction * c.maxplaceDistance;
                    Vector3 a2 = a - worldPosition;
                    Vector3 oldDir = t.ray.direction;
                    t.ray.direction = (a2 - t.ray.origin).normalized;
                }

                List<BaseEntity> list = Pool.GetList<BaseEntity>();
                float num = 3.40282347E+38f;
                Vis.Entities<BaseEntity>(t.ray.origin, c.maxplaceDistance * 2f, list, 18874625, QueryTriggerInteraction.Collide);
                foreach (BaseEntity current in list)
                {
                    Construction con = PrefabAttribute.server.Find<Construction>(current.prefabID);
                    if (!(con == null))
                    {
                        Socket_Base[] allSockets = con.allSockets;
                        for (int i = 0; i < allSockets.Length; i++)
                        {
                            Socket_Base socket_Base = allSockets[i];
                            if (socket_Base.female && !socket_Base.femaleDummy)
                            {
                                RaycastHit raycastHit;
                                if (socket_Base.GetSelectBounds(current.transform.position, current.transform.rotation).Trace(t.ray, out raycastHit, float.PositiveInfinity)) if (raycastHit.distance >= 1f) if (raycastHit.distance <= num) if (!current.IsOccupied(socket_Base))
                                            {
                                                Construction.Target trgt2 =
                                            default(Construction.Target);
                                                trgt2.socket = socket_Base;
                                                trgt2.entity = current;
                                                trgt2.ray = t.ray;
                                                trgt2.valid = true;
                                                trgt2.player = player;
                                                trgt2.rotation = rttnOffst;
                                                if (c.HasMaleSockets(trgt2))
                                                {
                                                    t = trgt2;
                                                    num = raycastHit.distance;
                                                }
                                            }
                            }
                        }
                    }
                }

                if (t.valid)
                {
                    Pool.FreeList<BaseEntity>(ref list);
                    return;
                }

                if (c.deployable == null && list.Count > 0)
                {
                    list.Clear();
                    Vis.Entities<BaseEntity>(t.ray.origin, 3f, list, 2097152, QueryTriggerInteraction.Ignore);
                    if (list.Count > 0)
                    {
                        Pool.FreeList<BaseEntity>(ref list);
                        return;
                    }
                }

                if (GamePhysics.Trace(t.ray, 0f, out rayHit, c.maxplaceDistance, 27328769, QueryTriggerInteraction.Ignore))
                {
                    t.position = t.ray.origin + t.ray.direction * rayHit.distance;
                    t.rotation = rttnOffst;
                    t.normal = rayHit.normal;
                    t.onTerrain = true;
                    t.valid = true;
                    t.entity = rayHit.GetEntity();
                }
                else
                {
                    t.position = t.ray.origin + t.ray.direction * c.maxplaceDistance;
                    t.rotation = rttnOffst;
                    t.normal = Vector3.up;
                    if (c.hierachyName.Contains(r("sbhaqngvba")))
                    {
                        t.valid = true;
                        t.onTerrain = true;
                    }
                    else
                    {
                        t.valid = false;
                        t.onTerrain = false;
                    }
                }

                Pool.FreeList<BaseEntity>(ref list);
            }

            private void ChkQrr(Construction c)
            {
                if (StringPool.Get(672916883).Equals(c.fullName))
                {
                    BaseEntity crt = GameManager.server.CreateEntity(StringPool.Get(2955484243), Vector3.zero, Quaternion.identity, true);
                    crt.transform.position = rayHit.point;
                    crt.Spawn();
                    CheckPlacement(ref target, construction);
                }

                if (StringPool.Get(1599225199).Equals(c.fullName))
                {
                    BaseEntity crt = GameManager.server.CreateEntity(StringPool.Get(1917257452), Vector3.zero, Quaternion.identity, true);
                    crt.transform.position = rayHit.point;
                    crt.Spawn();
                    CheckPlacement(ref target, construction);
                }
            }

            public GameObject DoPlaG(Construction.Target p, Construction component)
            {
                BaseEntity bsntt = CrtCnstrctn(p, component);
                if (!bsntt)
                {
                    return null;
                }
                float num = 1f;
                bsntt.skinID = ctvtmLnk.skin;
                bsntt.gameObject.AwakeFromInstantiate();
                BuildingBlock bBl = bsntt as BuildingBlock;
                if (bBl)
                {
                    bBl.blockDefinition = PrefabAttribute.server.Find<Construction>(bBl.prefabID);
                    if (!bBl.blockDefinition) return null;
                    bBl.SetGrade((BuildingGrade.Enum)dfltGrd);
                    float num2 = bBl.currentGrade.maxHealth;
                }

                BaseCombatEntity bsCmbtntt = bsntt as BaseCombatEntity;
                if (bsCmbtntt)
                {
                    float num2 = !(bBl != null) ? bsCmbtntt.startHealth : bBl.currentGrade.maxHealth;
                    bsCmbtntt.ResetLifeStateOnSpawn = false;
                    bsCmbtntt.InitializeHealth(num2 * num, num2);
                }

                bsntt.OwnerID = player.userID;

                StabilityEntity stabilityEntity = bsntt as StabilityEntity;
                bool setGrounded = false;
                if (stabilityEntity && Instance.overrideStabilityBuilding)
                {
                    stabilityEntity.grounded = true;
                    setGrounded = true;
                }

                if (Instance.disableGroundMissingChecks && !bBl)
                {
                    Destroy(bsntt.GetComponent<DestroyOnGroundMissing>());
                    Destroy(bsntt.GetComponent<GroundWatch>());
                }

                bsntt.Spawn();
                if (bBl && Instance.effectPlacingBlocksOn) Effect.server.Run(Instance.effectPlacingBlocks, bsntt, 0u, Vector3.zero, Vector3.zero);
                if (stabilityEntity && !setGrounded) stabilityEntity.UpdateSurroundingEntities();
                return bsntt.gameObject;
            }

            private BaseEntity CrtCnstrctn(Construction.Target target, Construction component)
            {
                string path = component.fullName;
                if (component.fullName.Equals(StringPool.Get(672916883))) path = StringPool.Get(3424003500);
                if (component.fullName.Equals(StringPool.Get(1599225199))) path = StringPool.Get(3449840583);
                GameObject gameObject = GameManager.server.CreatePrefab(path, Vector3.zero, Quaternion.identity, false);
                bool flag = UpdtPlcmnt(gameObject.transform, component, ref target);
                BaseEntity bsntt = gameObject.ToBaseEntity();

                Elevator elevator = bsntt as Elevator;
                if (elevator && rayEntity is Elevator)
                {
                    List<EntityLink> list = rayEntity.FindLink("elevator/sockets/elevator-female")?.connections;
                    if (list.Count > 0 && (list[0].owner as Elevator) != null)
                    {
                        player.ChatMessage("You can only stack elevators on the top level");
                        return null;
                    }

                    elevator.transform.position = rayEntity.transform.position + (Vector3.up * 3f);
                    elevator.transform.rotation = rayEntity.transform.rotation;

                    elevator.GetEntityLinks(true);
                    flag = true;
                }

                if (!flag)
                {
                    if (bsntt.IsValid()) bsntt.Kill(BaseNetworkable.DestroyMode.None);
                    else GameManager.Destroy(gameObject, 0f);
                    return null;
                }

                DecayEntity dcyEntt = bsntt as DecayEntity;
                if (dcyEntt) dcyEntt.AttachToBuilding(target.entity as DecayEntity);
                return bsntt;
            }

            private Construction.Placement CheckPlacement(Construction.Target t, Construction c)
            {
                List<Socket_Base> list = Pool.GetList<Socket_Base>();
                Construction.Placement plcmnt = null;
                if (c.allSockets == null || c.allSockets.Length == 0) return plcmnt;
                c.FindMaleSockets(t, list);
                foreach (Socket_Base current in list)
                    if (!(t.entity != null) || !(t.socket != null) || !t.entity.IsOccupied(t.socket)) plcmnt = current.DoPlacement(t);
                Pool.FreeList<Socket_Base>(ref list);
                return plcmnt;
            }

            private bool UpdtPlcmnt(Transform tn, Construction common, ref Construction.Target target)
            {
                if (!target.valid) return false;
                List<Socket_Base> list = Pool.GetList<Socket_Base>();
                common.canBypassBuildingPermission = true;
                common.FindMaleSockets(target, list);
                Construction.lastPlacementError = string.Empty;
                Regex _errOrr = new Regex(@"Not enough space|not in terrain|AngleCheck|Sphere Test|IsInArea|cupboard", RegexOptions.Compiled);
                foreach (Socket_Base current in list)
                {
                    Construction.Placement plcmnt = null;
                    if (!(target.entity != null) || !(target.socket != null) || !target.entity.IsOccupied(target.socket))
                    {
                        if (plcmnt == null) plcmnt = current.DoPlacement(target);
                        if (plcmnt != null)
                        {
                            DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(common.prefabID);
                            if (DeployVolume.Check(plcmnt.position, plcmnt.rotation, volumes, -1)) if (StringPool.Get(672916883).Contains(common.fullName) || StringPool.Get(1599225199).Contains(common.fullName))
                                {
                                    tn.position = plcmnt.position;
                                    tn.rotation = plcmnt.rotation;
                                    Pool.FreeList<Socket_Base>(ref list);
                                    return true;
                                }

                            if (BuildingProximity.Check(target.player, common, plcmnt.position, plcmnt.rotation))
                            {
                                tn.position = plcmnt.position;
                                tn.rotation = plcmnt.rotation;
                            }
                            else if (common.isBuildingPrivilege && !target.player.CanPlaceBuildingPrivilege(plcmnt.position, plcmnt.rotation, common.bounds))
                            {
                                tn.position = plcmnt.position;
                                tn.rotation = plcmnt.rotation;
                            }
                            else
                            {
                                tn.position = plcmnt.position;
                                tn.rotation = plcmnt.rotation;
                                Pool.FreeList<Socket_Base>(ref list);
                                return true;
                            }
                        }
                    }
                }

                Pool.FreeList<Socket_Base>(ref list);
                if (_errOrr.IsMatch(Construction.lastPlacementError)) return true;
                return false;
            }

            public void SendEffectTo(uint id, BaseEntity ent, BasePlayer player)
            {
                Effect effect = new Effect();
                effect.Init(Effect.Type.Generic, ent.transform.position, player.transform.forward, null);
                effect.pooledString = StringPool.Get(id);
                EffectNetwork.Send(effect, player.net.connection);
            }

            private void DestroyInfo(UType uType = UType.All)
            {
                CuiHelper.DestroyUi(player, r("HgPebffUnveHV"));
                if (uType == UType.All)
                {
                    CuiHelper.DestroyUi(player, UType.PlannerUi.ToString());
                    CuiHelper.DestroyUi(player, UType.RemoverUi.ToString());
                    CuiHelper.DestroyUi(player, UType.HammerUi.ToString());
                    plannerInfoStatus = false;
                    removerInfoStatus = false;
                    hammerInfoStatus = false;
                }
                else
                {
                    CuiHelper.DestroyUi(player, uType.ToString());
                    switch (uType)
                    {
                        case UType.PlannerUi:
                            plannerInfoStatus = false;
                            break;
                        case UType.RemoverUi:
                            removerInfoStatus = false;
                            break;
                        case UType.HammerUi:
                            hammerInfoStatus = false;
                            break;
                        default:
                            break;
                    }
                }
            }

            private void DoPlannerInfo()
            {
                if (!Instance.showPlannerInfo) return;
                string panelName = UType.PlannerUi.ToString();
                DestroyInfo(UType.PlannerUi);
                CuiElementContainer mainContainer = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}",
                                AnchorMax = $"{(panelPosX + 0.3f).ToString()} {(panelPosY + 0.15f).ToString()}"
                            }
                        },
                        new CuiElement().Parent = "Under",
                        panelName
                    }
                };
                CuiHelper.AddUi(player, mainContainer);
                plannerInfoStatus = true;
                DoPlannerUpdate(PType.Mode);
                DoPlannerUpdate(PType.ToSocket);
                DoPlannerUpdate(PType.PosRot);
                DoPlannerUpdate(PType.ConnectTo);
            }

            private void DoPlannerUpdate(PType pType, string infoMsg = " - ")
            {
                if (!isPlanner) return;
                if (!plannerInfoStatus) DoPlannerInfo();
                int maxRows = Enum.GetValues(typeof(PType)).Length;
                int rowNumber = (int)pType;
                string fieldName = pType.ToString();
                if (rowNumber == 0)
                {
                    if (sTpDplybl) fieldName = "Place";
                    else fieldName = "Build";
                }

                string mainPanel = UType.PlannerUi.ToString() + fieldName;
                CuiHelper.DestroyUi(player, mainPanel);
                float value = 1 / (float)maxRows;
                float positionMin = 1 - value * rowNumber;
                float positionMax = 2 - (1 - value * (1 - rowNumber));
                CuiElementContainer container = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = "0 " + positionMin.ToString("0.####"),
                                AnchorMax = $"1 " + positionMax.ToString("0.####")
                            },
                        },
                        new CuiElement().Parent = UType.PlannerUi.ToString(),
                        mainPanel
                    }
                };
                CuiElement innerLine = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = mainPanel,
                    Components = {
                        new CuiRawImageComponent {
                            Color = "0 0 0 1",
                            Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"),
                            Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng")
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "0.9 0.9"
                        }
                    }
                };
                container.Add(innerLine);
                CuiElement innerLineText1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = infoMsg,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.25 0.1",
                            AnchorMax = "1 1"
                        }
                    }
                };
                container.Add(innerLineText1);
                CuiElement innerLineText2 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = fieldName,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.025 0.1",
                            AnchorMax = "0.3 1"
                        }
                    }
                };
                container.Add(innerLineText2);
                CuiHelper.AddUi(player, container);
            }

            private void DoRemoverInfo()
            {
                if (!Instance.showRemoverInfo) return;
                string panelName = UType.RemoverUi.ToString();
                DestroyInfo(UType.RemoverUi);
                CuiElementContainer mainContainer = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}",
                                AnchorMax = $"{(panelPosX + 0.3f).ToString()} {(panelPosY + 0.115f).ToString()}"
                            }
                        },
                        new CuiElement().Parent = "Under",
                        panelName
                    }
                };
                CuiHelper.AddUi(player, mainContainer);
                removerInfoStatus = true;
                DoRemoverUpdate(RType.Remove);
                DoRemoverUpdate(RType.Mode, "Single");
                DoRemoverUpdate(RType.Owner);
            }

            private void DoRemoverUpdate(RType rType, string infoMsg = " - ", bool altMode = false)
            {
                if (!sRmvr) return;
                if (!removerInfoStatus) DoRemoverInfo();
                int maxRows = Enum.GetValues(typeof(RType)).Length;
                int rowNumber = (int)rType;
                string fieldName = rType.ToString();
                string mainPanel = UType.RemoverUi.ToString() + fieldName;
                if (infoMsg.Contains("Building")) fieldName = "<color=#ff0000>Mode</color>";
                CuiHelper.DestroyUi(player, mainPanel);
                float value = 1 / (float)maxRows;
                float positionMin = 1 - value * rowNumber;
                float positionMax = 2 - (1 - value * (1 - rowNumber));
                CuiElementContainer container = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = "0 " + positionMin.ToString("0.####"),
                                AnchorMax = $"1 " + positionMax.ToString("0.####")
                            },
                        },
                        new CuiElement().Parent = UType.RemoverUi.ToString(),
                        mainPanel
                    }
                };
                CuiElement innerLine = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = mainPanel,
                    Components = {
                        new CuiRawImageComponent {
                            Color = "0 0 0 1",
                            Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"),
                            Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng")
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "0.9 0.9"
                        }
                    }
                };
                container.Add(innerLine);
                CuiElement innerLineText1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = infoMsg,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.25 0.1",
                            AnchorMax = "1 1"
                        }
                    }
                };
                container.Add(innerLineText1);
                CuiElement innerLineText2 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = fieldName,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.025 0.1",
                            AnchorMax = "0.3 1"
                        }
                    }
                };
                container.Add(innerLineText2);
                CuiHelper.AddUi(player, container);
            }

            private void DoHammerInfo()
            {
                if (!Instance.showHammerInfo) return;
                string panelName = UType.HammerUi.ToString();
                DestroyInfo(UType.HammerUi);
                CuiElementContainer mainContainer = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = $"{panelPosX.ToString()} {panelPosY.ToString()}",
                                AnchorMax = $"{(panelPosX + 0.3f).ToString()} {(panelPosY + 0.19f).ToString()}"
                            }
                        },
                        new CuiElement().Parent = "Under",
                        panelName
                    }
                };
                CuiHelper.AddUi(player, mainContainer);
                hammerInfoStatus = true;
                DoHammerUpdate(HType.Target);
                DoHammerUpdate(HType.Building);
                DoHammerUpdate(HType.Mode);
                DoHammerUpdate(HType.PosRot);
                DoHammerUpdate(HType.Owner);
                DoHammerUpdate(HType.SteamID);
            }

            private void DoHammerUpdate(HType hType, string infoMsg = " - ")
            {
                if (!isHammering) return;
                if (!hammerInfoStatus) DoHammerInfo();
                int maxRows = Enum.GetValues(typeof(HType)).Length;
                int rowNumber = (int)hType;
                string fieldName = hType.ToString();
                string mainPanel = UType.HammerUi.ToString() + fieldName;
                CuiHelper.DestroyUi(player, mainPanel);
                float value = 1 / (float)maxRows;
                float positionMin = 1 - value * rowNumber;
                float positionMax = 2 - (1 - value * (1 - rowNumber));
                CuiElementContainer container = new CuiElementContainer() {
                    {
                        new CuiPanel {
                            Image = {
                                Color = "0 0 0 0"
                            },
                            RectTransform = {
                                AnchorMin = "0 " + positionMin.ToString("0.####"),
                                AnchorMax = $"1 " + positionMax.ToString("0.####")
                            },
                        },
                        new CuiElement().Parent = UType.HammerUi.ToString(),
                        mainPanel
                    }
                };
                CuiElement innerLine = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = mainPanel,
                    Components = {
                        new CuiRawImageComponent {
                            Color = "0 0 0 1",
                            Sprite = r("nffrgf/pbagrag/hv/qrirybcre/qrirybczragfxva/qrigno-abezny.cat"),
                            Material = r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng")
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0 0",
                            AnchorMax = "0.9 0.9"
                        }
                    }
                };
                container.Add(innerLine);
                CuiElement innerLineText1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = infoMsg,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.25 0.1",
                            AnchorMax = "1 1"
                        }
                    }
                };
                container.Add(innerLineText1);
                CuiElement innerLineText2 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerLine.Name,
                    Components = {
                        new CuiTextComponent {
                            Color = cuiFontColor,
                            Text = fieldName,
                            Font = fontType,
                            FontSize = cuiFontSize,
                            Align = TextAnchor.MiddleLeft
                        },
                        new CuiRectTransformComponent {
                            AnchorMin = "0.025 0.1",
                            AnchorMax = "0.3 1"
                        }
                    }
                };
                container.Add(innerLineText2);
                CuiHelper.AddUi(player, container);
            }

            private void BldMnUI(float factor)
            {
                CuiElementContainer element = new CuiElementContainer();
                string color = "0 0 0 0";
                string mainName = element.Add(
                new CuiPanel
                {
                    Image = {
                        Color = "0 0 0 0"
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                    CursorEnabled = true
                },
                "Overlay", r("OhvyqZrahHV"));
                element.Add(
                new CuiButton
                {
                    Button = {
                        Close = mainName,
                        Color = color
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                    Text = {
                        Text = string.Empty
                    }
                },
                mainName);
                Vector2 mC = new Vector2(0.5f, 0.5f);
                Vector2 mS = new Vector2(0.3425f, 0.475f);

                for (int i = 0; i < 20; i++)
                {
                    float scaled = 1f;
                    if ((i > 0 && i < 6) || (i > 8 && i < 11) || (i > 12 && i < 15))
                        scaled = 0.75f;

                    Vector2 center = RotateByRadians(mC, mS, index2Degrees[i] * Mathf.Deg2Rad, factor);
                    element.Add(BuildIconUI(mainName, center, r("nffrgf/vpbaf/pvepyr_tenqvrag.cat"), -0.040f * scaled, 0.040f * scaled, "1 1 1 1", factor, false));
                    element.Add(BuildIconUI(mainName, center, r("nffrgf/vpbaf/pvepyr_tenqvrag.cat"), -0.040f * scaled, 0.040f * scaled, "1 1 1 1", factor, false));
                    element.Add(BuildRawIconUI(mainName, center, Instance.prefabIdToImage[Instance.constructionIds[i]], -0.02f * scaled, 0.02f * scaled, "0.2 0.5 0.8 0.5", factor, true));
                    element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(center, mC, 0.06f), i, -0.020f * scaled, 0.020f * scaled, color, factor), mainName);
                    element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(center, mC, 0.03f), i, -0.025f * scaled, 0.025f * scaled, color, factor), mainName);
                    element.Add(BuildButtonUI(mainName, center, i, -0.030f * scaled, 0.030f * scaled, color, factor), mainName);
                    element.Add(BuildButtonUI(mainName, Vector2.MoveTowards(center, mC, -0.02f), i, -0.035f * scaled, 0.035f * scaled, color, factor), mainName);
                }

                element.Add(CustomIconUI(mainName, new Vector2(0.85f, 0.5f), r("nffrgf/vpbaf/rkvg.cat"), -0.025f, 0.025f, "1 1 1 1", factor));
                element.Add(CustomButtonUI(mainName, new Vector2(0.85f, 0.5f), "ut.prefab 6666", -0.025f, 0.025f, color, factor), mainName);
                CuiHelper.AddUi(player, element);
            }

            private float[] index2Degrees = new float[]
            {
                0f,
                19.2235f,
                32.06471f,
                45.24706f,
                59.02941f,
                72.00588f,
                85.00588f,
                103.4823f,
                126.0588f,
                143.9412f,
                158.8235f,
                177f,
                199.9765f,
                216.0588f,
                230.9412f,
                250.1176f,
                271.2941f,
                293.4706f,
                315.6471f,
                338.8235f,
            };

            private void DoCrosshair(string cColor = default(string), bool kill = false)
            {
                if (lstCrsshr == cColor && !kill) return;
                if (kill || cColor == string.Empty)
                {
                    lstCrsshr = string.Empty;
                    CuiHelper.DestroyUi(player, r("HgPebffUnveHV"));
                    return;
                }

                lstCrsshr = cColor;
                CuiElementContainer element = new CuiElementContainer();
                string mainName = element.Add(
                new CuiPanel
                {
                    Image = {
                        Color = "0 0 0 0"
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                "Under", r("HgPebffUnveHV"));
                element.Add(CustomIconUI(mainName, new Vector2(0.499f, 0.499f), r("nffrgf/vpbaf/gnetrg.cat"), -0.005f, 0.005f, cColor, Instance.playerPrefs.playerData[player.userID].SF));
                CuiHelper.DestroyUi(player, mainName);
                CuiHelper.AddUi(player, element);
            }

            private void DoWarning(string cColor = default(string), bool kill = false)
            {
                if (lstWrnng == cColor && !kill) return;
                if (kill || cColor == string.Empty)
                {
                    lstWrnng = string.Empty;
                    CuiHelper.DestroyUi(player, r("HgJneavatHV"));
                    return;
                }

                lstWrnng = cColor;
                CuiElementContainer element = new CuiElementContainer();
                string mainName = element.Add(
                new CuiPanel
                {
                    Image = {
                        Color = "0 0 0 0"
                    },
                    RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                },
                "Under", r("HgJneavatHV"));
                element.Add(CustomIconUI(mainName, new Vector2(0.499f, 0.35f), r("nffrgf/vpbaf/jneavat_2.cat"), -0.05f, 0.05f, cColor, Instance.playerPrefs.playerData[player.userID].SF));
                CuiHelper.DestroyUi(player, mainName);
                CuiHelper.AddUi(player, element);
            }
        }

        private enum PType
        {
            Mode = 0,
            ToSocket = 1,
            PosRot = 2,
            ConnectTo = 3
        }

        private enum RType
        {
            Remove = 0,
            Mode = 1,
            Owner = 2
        }

        private enum HType
        {
            Target = 0,
            Building = 1,
            Mode = 2,
            PosRot = 3,
            Owner = 4,
            SteamID = 5,
        }

        private enum UType
        {
            PlannerUi = 0,
            RemoverUi = 1,
            HammerUi = 2,
            All = 3
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string,
            object> data = Config[menu] as Dictionary<string,
            object>;
            if (data == null)
            {
                data = new Dictionary<string,
                object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        private bool Changed = false;
        private static UberTool Instance;

        private string[] iconFileNames = new string[]
        {
            "wall.low",
            "block.stair.ushape",
            "block.stair.lshape",
            "block.stair.spiral",
            "block.stair.spiral.triangle",
            "roof.triangle",
            "roof",
            "foundation",
            "foundation.triangle",
            "foundation.steps",
            "ramp",
            "floor",
            "floor.triangle",
            "floor.frame",
            "floor.triangle.frame",
            "wall",
            "wall.doorway",
            "wall.window",
            "wall.frame",
            "wall.half"
        };

        private List<uint> constructionIds = new List<uint>();


        private Dictionary<uint, string> prefabIdToImage = new Dictionary<uint, string>();

        private Dictionary<ulong, bool> ctvUbrTls;
        private Dictionary<ulong, EPlanner> activeUberObjects;
        private List<Transform> entRemoval = new List<Transform>();
        private string varChatToggle;
        private string varCmdToggle;
        private string varChatScale;
        private string varCmdScale;
        private string pluginPrefix;
        private string prefixColor;
        private string prefixFormat;
        private string colorTextMsg;
        private float scaleFactorDef;
        private bool hideTips;
        private bool showPlannerInfo;
        private bool showRemoverInfo;
        private bool showHammerInfo;
        private static float panelPosX;
        private static float panelPosY;
        private string effectRemoveBlocks;
        private bool effectRemoveBlocksOn;
        private string effectPlacingBlocks;
        private bool effectPlacingBlocksOn;
        private bool effectFoundationPlacement;
        private bool effectPromotingBlock;
        private bool showGibsOnRemove;
        private float removeToolRange;
        private float hammerToolRange;
        private bool removeToolObjects;
        private bool enableFullRemove;
        private bool disableGroundMissingChecks;
        private bool overrideStabilityBuilding;
        private bool disableStabilityStartup;
        private bool enablePerimeterRepair;
        private float perimeterRepairRange;
        private bool checkExistingPlanner;
        private bool checkExistingRemover;
        private bool checkExistingHammer;
        private bool enableHammerTCInfo;
        private bool enableHammerCodelockInfo;
        private List<object> pseudoAdminPerms = new List<object>();
        private List<string> psdPrms = new List<string>();
        private string pluginUsagePerm;
        private bool enableIsAdminCheck;
        private bool setDeployableOwner;

        private List<object[]> playerTools = new List<object[]> {
            {
                new object[] {
                    "UberTool",
                    "building.planner",
                    1195976254u
                }
            },
            {
                new object[] {
                    "UberRemove",
                    "pistol.semiauto",
                    1196004864u
                }
            },
            {
                new object[] {
                    "UberHammer",
                    "hammer",
                    1196009619u
                }
            },
        };

        private void LoadVariables()
        {
            bool configRemoval = false;
            setDeployableOwner = Convert.ToBoolean(GetConfig("Deployables", "Set player as deployable owner on placement", true));

            varChatToggle = Convert.ToString(GetConfig("Commands", "Plugin toggle by chat", "ubertool"));
            varCmdToggle = Convert.ToString(GetConfig("Commands", "Plugin toggle by console", "ut.toggle"));
            varChatScale = Convert.ToString(GetConfig("Commands", "Set scale by chat", "uberscale"));
            varCmdScale = Convert.ToString(GetConfig("Commands", "Set scale by console", "ut.scale"));
            enableIsAdminCheck = Convert.ToBoolean(GetConfig("Permission", "Grant usage right by IsAdmin check", true));
            pseudoAdminPerms = (List<object>)GetConfig("Permission", "PseudoAdmin permissions", new List<object> {
                "fauxadmin.allowed",
                "fakeadmin.allow"
            });
            pluginUsagePerm = Convert.ToString(GetConfig("Permission", "Plugin usage permission", "ubertool.canuse"));
            pluginPrefix = Convert.ToString(GetConfig("Formatting", "pluginPrefix", "UberTool"));
            prefixColor = Convert.ToString(GetConfig("Formatting", "prefixColor", "#468499"));
            prefixFormat = Convert.ToString(GetConfig("Formatting", "prefixFormat", "<color={0}>{1}</color>: "));
            colorTextMsg = Convert.ToString(GetConfig("Formatting", "colorTextMsg", "#b3cbce"));
            scaleFactorDef = Convert.ToSingle(GetConfig("Options", "Default scaling for matrix overlay (16:10)", 1.6f));
            hideTips = Convert.ToBoolean(GetConfig("Options", "Hide gametips at tool activation", true));
            showPlannerInfo = Convert.ToBoolean(GetConfig("Options", "Show planner info panel", true));
            showRemoverInfo = Convert.ToBoolean(GetConfig("Options", "Show remover info panel", true));
            showHammerInfo = Convert.ToBoolean(GetConfig("Options", "Show hammer info panel", true));
            panelPosX = Convert.ToSingle(GetConfig("Options", "info panel x coordinate", 0.6f));
            panelPosY = Convert.ToSingle(GetConfig("Options", "info panel y coordinate", 0.6f));
            showGibsOnRemove = Convert.ToBoolean(GetConfig("Effects", "Gibs on remove building", false));
            effectRemoveBlocks = Convert.ToString(GetConfig("Effects", "Effect on remove Blocks", StringPool.Get(2184296839)));
            effectRemoveBlocksOn = Convert.ToBoolean(GetConfig("Effects", "Effect on remove Blocks enabled", true));
            effectPlacingBlocks = Convert.ToString(GetConfig("Effects", "Effect on placing Blocks", StringPool.Get(172001365)));
            effectPlacingBlocksOn = Convert.ToBoolean(GetConfig("Effects", "Effect on placing Blocks enabled", true));
            effectFoundationPlacement = Convert.ToBoolean(GetConfig("Effects", "Click feedback at foundation placement", true));
            effectPromotingBlock = Convert.ToBoolean(GetConfig("Effects", "Effect on promoting Block enabled", true));
            removeToolRange = Convert.ToSingle(GetConfig("Tool", "Remover pistol range", 24f));
            hammerToolRange = Convert.ToSingle(GetConfig("Tool", "Hammer tool range", 24f));
            removeToolObjects = Convert.ToBoolean(GetConfig("Tool", "Remover pistol does shoot every object", false));
            enableFullRemove = Convert.ToBoolean(GetConfig("Tool", "Remover pistol can remove full buildings", true));
            disableGroundMissingChecks = Convert.ToBoolean(GetConfig("Tool", "Disable deployable ground-missing checks", true));
            overrideStabilityBuilding = Convert.ToBoolean(GetConfig("Tool", "Override stability while building", true));
            disableStabilityStartup = Convert.ToBoolean(GetConfig("Tool", "Temporary disable stability while startup", false));
            checkExistingPlanner = Convert.ToBoolean(GetConfig("Tool", "Check for existing Planner", true));
            checkExistingRemover = Convert.ToBoolean(GetConfig("Tool", "Check for existing Remover", true));
            checkExistingHammer = Convert.ToBoolean(GetConfig("Tool", "Check for existing Hammer", true));
            perimeterRepairRange = Convert.ToSingle(GetConfig("Tool", "Perimeter repair range", 3f));
            enablePerimeterRepair = Convert.ToBoolean(GetConfig("Tool", "Enable perimeter repair", true));
            enableHammerTCInfo = Convert.ToBoolean(GetConfig("Tool", "Enable Hammer TC info", true));
            enableHammerCodelockInfo = Convert.ToBoolean(GetConfig("Tool", "Enable Hammer CodeLock info", true));
            controlButtons = new Dictionary<CmdType,
            BTN>
            {
                [CmdType.HammerChangeGrade] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: change object grade", "FIRE_THIRD"))),
                [CmdType.HammerToggleOnOff] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: toggle object on/off/quarrytype", "FIRE_THIRD"))),
                [CmdType.HammerRotate] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: rotate object cw", "RELOAD"))),
                [CmdType.HammerRotateDirection] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: rotation direction ccw (hold)", "SPRINT"))),
                [CmdType.HammerTransform] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: object move/transform", "FIRE_SECONDARY"))),
                [CmdType.HammerAuthInfo] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Hammer: get object auth/lock info", "USE"))),
                [CmdType.PlannerPlace] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: place object/block", "FIRE_PRIMARY"))),
                [CmdType.PlannerRotate] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: rotate before placement", "RELOAD"))),
                [CmdType.PlannerTierChange] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: change grade activator (hold)", "DUCK"))),
                [CmdType.PlannerTierNext] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: choose higher grade", "LEFT"))),
                [CmdType.PlannerTierPrev] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Planner: choose lower grade", "RIGHT"))),
                [CmdType.RemoverRemove] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Remover: remove object/block", "FIRE_PRIMARY"))),
                [CmdType.RemoverHoldForAll] = ParseType<BTN>(Convert.ToString(GetConfig("ButtonConfig", "Remover: remove all activator (hold)", "FIRE_SECONDARY")))
            };
            if ((Config.Get("Tool") as Dictionary<string, object>).ContainsKey("Enable Hammer TC info by leftclick"))
            {
                (Config.Get("Tool") as Dictionary<string, object>).Remove("Enable Hammer TC info by leftclick");
                configRemoval = true;
            }

            if ((Config.Get("Tool") as Dictionary<string, object>).ContainsKey("Enable Hammer CodeLock info by leftclick"))
            {
                (Config.Get("Tool") as Dictionary<string, object>).Remove("Enable Hammer CodeLock info by leftclick");
                configRemoval = true;
            }

            if ((Config.Get("Effects") as Dictionary<string, object>).ContainsKey("Audio feedbacks on foundations placements"))
            {
                (Config.Get("Effects") as Dictionary<string, object>).Remove("Audio feedbacks on foundations placements");
                configRemoval = true;
            }

            SaveConf();
            if (!Changed && !configRemoval) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
            new Dictionary<string, string> {
                {
                    "Activated",
                    "Tool activated."
                },
                {
                    "Deactivated",
                    "Tool deactivated."
                },
                {
                    "ChangedGrade",
                    "Changed grade to <color=#32d38b>{0}</color>."
                },
                {
                    "SwitchedPlan",
                    "Switched plan to <color=#00c96f>{0}</color>."
                },
                {
                    "CurrentScale",
                    "Your current scale is <color=#00c96f>{0}</color>."
                },
                {
                    "NewScale",
                    "Your new scale is <color=#00c96f>{0}</color>."
                },
                {
                    "RepairedMulti",
                    "Repaired {0} damaged objects."
                },
            },
            this);
        }

        private void Loaded()
        {
            LoadVariables();
            LoadDefaultMessages();
            Instance = this;
            ctvUbrTls = new Dictionary<ulong,
            bool>();
            activeUberObjects = new Dictionary<ulong, EPlanner>();
            entRemoval = new List<Transform>();

            foreach (string pseudoPerm in pseudoAdminPerms.ConvertAll(obj => Convert.ToString(obj)).ToList())
            {
                if (permission.PermissionExists(pseudoPerm)) psdPrms.Add(pseudoPerm.ToLower());
            }

            if (!permission.PermissionExists(pluginUsagePerm)) permission.RegisterPermission(pluginUsagePerm, this);
        }

        private void Unload()
        {
            SaveData();
            List<EPlanner> objs = UnityEngine.Object.FindObjectsOfType<EPlanner>().ToList();
            if (objs.Count > 0)
            {
                for (int i = 0; i < objs.Count; i++)
                {
                    UnityEngine.Object.Destroy(objs[i]);
                }
            }
        }

        private const string IMAGE_URL = "http://www.rustedit.io/images/ubertool/{0}.png";

        private bool noImageLibrary = true;

        private void OnServerInitialized()
        {
            if (Instance.disableStabilityStartup && _disableStabilityStartup)
            {
                ConVar.Server.stability = true;
                Puts("Re-enabled server.stability");
            }

            Dictionary<string, Dictionary<ulong, string>> itemList = new Dictionary<string, Dictionary<ulong, string>>();

            for (int i = 0; i < iconFileNames.Length; i++)
            {
                string icon = iconFileNames[i];
                itemList.Add(icon, new Dictionary<ulong, string>
                {
                    [0] = string.Format(IMAGE_URL, icon)
                });
            }

            if (!ImageLibrary)
            {
                PrintError("UberTool requires ImageLibrary to display build menu icons! Please install ImageLibrary");
            }
            else ImageLibrary?.Call("ImportItemList", this.Title, itemList, false, new Action(GetIconIds));

            cmd.AddConsoleCommand(r("hg.cersno"), this, r("pzqCersno"));
            cmd.AddConsoleCommand(varCmdScale, this, r("pzqFpnyr"));
            cmd.AddConsoleCommand(varCmdToggle, this, r("pzqGbttyr"));
            cmd.AddChatCommand(varChatToggle, this, r("pungGbttyr"));
            cmd.AddChatCommand(varChatScale, this, r("pungFpnyr"));
            playerPrefs = Interface.GetMod().DataFileSystem.ReadObject<StrdDt>(Title);
            if (playerPrefs == null || playerPrefs.playerData == null) playerPrefs = new StrdDt();
            foreach (BasePlayer player in BasePlayer.activePlayerList.Where(p => HasPermission(p)).ToList())
            {
                Stsr(player);
                ctvUbrTls[player.userID] = false;
            }

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.Where(p => HasPermission(p)).ToList())
            {
                Stsr(player);
                ctvUbrTls[player.userID] = false;
            }

            UpdateHooks();

            Interface.Oxide.DataFileSystem.WriteObject(Title, playerPrefs);
        }

        private void UpdateHooks()
        {
            if (activeUberObjects.Count > 0)
            {
                Subscribe(nameof(CanBuild));
                Subscribe(nameof(OnItemDeployed));
                Subscribe(nameof(OnReloadMagazine));
                Subscribe(nameof(OnLoseCondition));
                Subscribe(nameof(OnPlayerTick));
                Subscribe(nameof(OnStructureRepair));
                Subscribe(nameof(OnServerCommand));
                Subscribe(nameof(OnMessagePlayer));
            }
            else
            {
                Unsubscribe(nameof(CanBuild));
                Unsubscribe(nameof(OnItemDeployed));
                Unsubscribe(nameof(OnReloadMagazine));
                Unsubscribe(nameof(OnLoseCondition));
                Unsubscribe(nameof(OnPlayerTick));
                Unsubscribe(nameof(OnStructureRepair));
                Unsubscribe(nameof(OnServerCommand));
                Unsubscribe(nameof(OnMessagePlayer));
            }
        }

        private void GetIconIds()
        {
            for (int i = 0; i < iconFileNames.Length; i++)
            {
                string shortname = iconFileNames[i];
                string prefabPath = string.Empty;
                foreach (string s in GameManifest.Current.entities)
                {
                    if (ToShortName(s).Equals(shortname))
                    {
                        prefabPath = s;
                        break;
                    }
                }

                if (string.IsNullOrEmpty(prefabPath))
                {
                    PrintError("Failed to find prefab ID for {shortname}");
                    continue;
                }
                constructionIds.Add(GameManager.server.FindPrefab(prefabPath).ToBaseEntity().prefabID);
                prefabIdToImage.Add(constructionIds[i], (string)ImageLibrary?.Call("GetImage", shortname));
            }

            PrintWarning("ImageLibrary has finished processing UberTool's required images. UberTool is now active");
            noImageLibrary = false;
        }

        private string ToShortName(string name)
        {
            return name.Split('/').Last().Replace(".prefab", "");
        }

        private enum CmdType
        {
            HammerChangeGrade,
            HammerToggleOnOff,
            HammerRotate,
            HammerRotateDirection,
            HammerTransform,
            HammerAuthInfo,
            PlannerPlace,
            PlannerRotate,
            PlannerTierChange,
            PlannerTierNext,
            PlannerTierPrev,
            RemoverRemove,
            RemoverHoldForAll
        }

        private static Dictionary<CmdType,
        BTN> controlButtons;

        private T ParseType<T>(string type)
        {
            T pT =
        default(T);
            try
            {
                pT = (T)Enum.Parse(typeof(T), type, true);
                return pT;
            }
            catch
            {
                return pT;
            }
        }

        private bool sPsdAdmn(string id)
        {
            foreach (string perm in psdPrms)
                if (permission.UserHasPermission(id, perm)) return true;
            return false;
        }

        private void OnUserPermissionGranted(string id, string perm)
        {
            if (psdPrms.Contains(perm.ToLower()) || perm.ToLower() == pluginUsagePerm.ToLower())
            {
                BasePlayer p = BasePlayer.Find(id);
                if (p)
                {
                    Stsr(p);
                    ctvUbrTls[p.userID] = false;
                }
            }
        }

        private void OnGroupPermissionGranted(string name, string perm)
        {
            if (psdPrms.Contains(perm.ToLower()) || perm.ToLower() == pluginUsagePerm.ToLower()) foreach (string id in permission.GetUsersInGroup(name).ToList())
                {
                    BasePlayer p = BasePlayer.Find(id.Substring(0, 17));
                    if (p)
                    {
                        Stsr(p);
                        ctvUbrTls[p.userID] = false;
                    }
                }
        }

        private void Stsr(BasePlayer player)
        {
            if (player == null) return;
            foreach (Item item in player.inventory.AllItems().Where(x => x.IsValid()).ToList())
                if (item.skin == Convert.ToUInt64(playerTools[0][2]) || item.skin == Convert.ToUInt64(playerTools[1][2]) || item.skin == Convert.ToUInt64(playerTools[2][2]))
                {
                    item.skin = 0uL;
                    item.GetHeldEntity().skinID = 0uL;
                    item.name = string.Empty;
                    item.MarkDirty();
                }

            Plyrnf p = null;
            if (!playerPrefs.playerData.TryGetValue(player.userID, out p))
            {
                Plyrnf info = new Plyrnf();
                info.SF = scaleFactorDef;
                info.DBG = 4;
                playerPrefs.playerData.Add(player.userID, info);
            }
        }

        private bool HasPermission(BasePlayer p)
        {
            return p.IsAdmin && enableIsAdminCheck || permission.UserHasPermission(p.UserIDString, pluginUsagePerm) || sPsdAdmn(p.UserIDString);
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, playerPrefs);
        }

        private bool _disableStabilityStartup = false;

        private void OnSaveLoad()
        {
            _disableStabilityStartup = false;
            if (Instance.disableStabilityStartup)
            {
                bool flag = ConVar.Server.stability;
                if (flag)
                {
                    _disableStabilityStartup = true;
                    ConVar.Server.stability = false;
                    Puts("Temp disabled server.stability");
                }
            }
        }

        private void OnPlayerConnected(BasePlayer p)
        {
            if (HasPermission(p))
            {
                Stsr(p);
                ctvUbrTls[p.userID] = false;
            }
        }

        private object CanBuild(Planner plan, Construction prefab, Construction.Target target)
        {
            if (plan != null)
            {
                BasePlayer p = plan?.GetOwnerPlayer();
                bool exists = false;
                if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists) return false;
            }

            return null;
        }

        private void OnItemDeployed(Deployer d)
        {
            if (d != null)
            {
                BasePlayer p = d?.GetOwnerPlayer();
                bool exists = false;
                if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists)
                {
                    Item i = d.GetItem();
                    i.amount++;
                }
            }
        }

        private object OnReloadMagazine(BasePlayer p, BaseProjectile bP)
        {
            bool exists = false;
            if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists && bP.skinID == Convert.ToUInt64(playerTools[1][2])) return false;
            return null;
        }

        private void OnLoseCondition(Item item, float amount)
        {
            bool exists = false;
            if (item != null)
            {
                BasePlayer p = item.GetOwnerPlayer();
                if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists) item.condition = item.maxCondition;
            }
        }

        private void OnPlayerTick(BasePlayer p, PlayerTick msg, bool wasPlayerStalled)
        {
            bool exists = false;
            if (p && ctvUbrTls.TryGetValue(p.userID, out exists) && exists)
            {
                if (!p.IsConnected || p.IsDead())
                {
                    ctvUbrTls[p.userID] = false;
                    activeUberObjects[p.userID].OnDestroy();
                    activeUberObjects.Remove(p.userID);
                    UpdateHooks();
                    return;
                }

                if (p.IsSleeping() || p.IsReceivingSnapshot || p.IsSpectating())
                    return;

                activeUberObjects[p.userID].SetHeldItem(msg.activeItem);

                if (msg.activeItem > 0u)
                {
                    Instance.activeUberObjects[p.userID].TickUpdate(msg);
                    if (msg.inputState != null) // && p.serverInput.current.buttons != p.serverInput.previous.buttons)
                        Instance.activeUberObjects[p.userID].DoTick();
                }
            }
        }

        private void cmdPrefab(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs(1)) return;
            BasePlayer player = arg.Player();
            if (!player || !HasPermission(player)) return;
            int id = -1;
            int.TryParse(arg.Args[0], out id);
            if (id < 0) return;
            if (id == 6666)
            {
                TgglTls(player);
                return;
            }

            activeUberObjects[player.userID].SetBlockPrefab(Instance.constructionIds[id]);
        }

        private void cmdScale(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player || !HasPermission(player)) return;
            if (!arg.HasArgs(1))
            {
                SendReply(arg, r("Pheerag fpnyr: ") + playerPrefs.playerData[player.userID].SF);
                return;
            }

            float f = 0f;
            if (arg.Args.Length == 1)
            {
                float.TryParse(arg.Args[0], out f);
                if (f == 0f) return;
            }
            else
            {
                float w;
                float.TryParse(arg.Args[0], out w);
                if (w <= 0f) return;
                float h;
                float.TryParse(arg.Args[1], out h);
                if (h <= 0f) return;
                f = w / h;
            }

            playerPrefs.playerData[arg.Connection.userid].SF = f;
            SendReply(arg, r("Arj fpnyr: ") + f);
        }

        private void chatScale(BasePlayer player, string command, string[] args)
        {
            if (player == null || !HasPermission(player)) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, string.Format(LangMsg(r("PheeragFpnyr"), player.UserIDString), playerPrefs.playerData[player.userID].SF));
                return;
            }

            float f = 0f;
            if (args.Length == 1)
            {
                float.TryParse(args[0], out f);
                if (f == 0f) return;
            }
            else
            {
                float w;
                float.TryParse(args[0], out w);
                if (w <= 0f) return;
                float h;
                float.TryParse(args[1], out h);
                if (h <= 0f) return;
                f = w / h;
            }

            playerPrefs.playerData[player.userID].SF = f;
            SendReply(player, string.Format(LangMsg(r("ArjFpnyr"), player.UserIDString), f));
        }

        private void cmdToggle(ConsoleSystem.Arg arg)
        {
            if (arg == null) return;
            BasePlayer p = arg.Connection.player as BasePlayer;
            if (p == null || !HasPermission(p)) return;
            if (noImageLibrary)
            {
                SendReply(arg, "ImageLibrary is either not installed, or it hasn't finished processing the images UberTool requires. If ImageLibrary is not installed do so now, otherwise wait for ImageLibrary to finish image processing");
                return;
            }
            TgglTls(p);
        }

        private void chatToggle(BasePlayer p, string command, string[] args)
        {
            if (p == null || !HasPermission(p)) return;
            if (noImageLibrary)
            {
                SendReply(p, "ImageLibrary is either not installed, or it hasn't finished processing the images UberTool requires. If ImageLibrary is not installed do so now, otherwise wait for ImageLibrary to finish image processing");
                return;
            }
            TgglTls(p);
        }

        private void TgglTls(BasePlayer p)
        {
            bool exists = false;
            if (!ctvUbrTls.TryGetValue(p.userID, out exists))
            {
                Stsr(p);
                ctvUbrTls[p.userID] = false;
            }

            if ((bool)ctvUbrTls[p.userID])
            {
                ctvUbrTls[p.userID] = false;
                activeUberObjects[p.userID].OnDestroy();
                activeUberObjects.Remove(p.userID);
                SendReply(p, string.Format(LangMsg(r("Qrnpgvingrq"), p.UserIDString)));
                UpdateHooks();
                return;
            }

            ctvUbrTls[p.userID] = true;
            activeUberObjects[p.userID] = p.gameObject.AddComponent<EPlanner>();
            SendReply(p, string.Format(LangMsg(r("Npgvingrq"), p.UserIDString)));
            UpdateHooks();
        }

        private void OnStructureRepair(BaseCombatEntity bsntt, BasePlayer player)
        {
            bool exists = false;
            if (player && ctvUbrTls.TryGetValue(player.userID, out exists) && exists)
            {
                if (enablePerimeterRepair)
                {
                    List<BaseCombatEntity> list = Pool.GetList<BaseCombatEntity>();
                    Vis.Entities<BaseCombatEntity>(bsntt.transform.position, perimeterRepairRange, list, 1 << 0 | 1 << 8 | 1 << 13 | 1 << 15 | 1 << 21);
                    int repaired = 0;
                    for (int i = 0; i < list.Count; i++)
                    {
                        BaseCombatEntity entity = list[i];
                        if (entity.health < entity.MaxHealth())
                        {
                            repaired++;
                            entity.health = entity.MaxHealth();
                            entity.SendNetworkUpdate();
                        }
                    }

                    Pool.FreeList<BaseCombatEntity>(ref list);
                    if (repaired > 0) SendReply(player, string.Format(LangMsg(r("ErcnverqZhygv"), player.UserIDString), repaired));
                }
                else
                {
                    bsntt.health = bsntt.MaxHealth();
                    bsntt.SendNetworkUpdate();
                }
            }
        }

        private string GetChatPrefix()
        {
            return string.Format(prefixFormat, prefixColor, pluginPrefix);
        }

        private void SaveConf()
        {
            if (Author != r("ShWvPhEn")) Author = r("Cvengrq Sebz ShWvPhEn");
        }

        private string ChatMsg(string str)
        {
            return GetChatPrefix() + $"<color={colorTextMsg}>" + str + "</color>";
        }

        private string LangMsg(string key, string id = null)
        {
            return GetChatPrefix() + $"<color={colorTextMsg}>" + lang.GetMessage(key, this, id) + "</color>";
        }

        public static Vector2 RotateByRadians(Vector2 center, Vector2 point, float angle, float factor)
        {
            Vector2 v = point - center;
            float x = v.x * Mathf.Cos(angle) + v.y * Mathf.Sin(angle);
            float y = (v.y * Mathf.Cos(angle) - v.x * Mathf.Sin(angle)) * factor;
            Vector2 B = new Vector2(x, y) + center;
            return B;
        }


        private static string GetAnchor(Vector2 m, float s, float f)
        {
            return $"{(m.x + s).ToString("F3")} {(m.y + s * f).ToString("F3")}";
        }

        private static CuiButton BuildButtonUI(string panelName, Vector2 p, int ct, float mi, float ma, string c, float f)
        {
            return new CuiButton
            {
                Button = {
                    Command = $"ut.prefab {ct.ToString()}",
                    Close = panelName,
                    Color = c
                },
                RectTransform = {
                    AnchorMin = GetAnchor(p, mi, f),
                    AnchorMax = GetAnchor(p, ma, f)
                },
                Text = {
                    Text = null
                }
            };
        }

        private static CuiElement BuildIconUI(string panel, Vector2 center, string sprite, float min, float max, string color, float factor, bool b)
        {
            return new CuiElement
            {
                Parent = panel,
                Components = {
                    new CuiImageComponent {
						//Color = "0 0 0 0"
						Sprite = sprite,
                        Color = color,
                        Material = b ? r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng") : r("nffrgf/vpbaf/vpbazngrevny.zng")
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = GetAnchor(center, min, factor),
                        AnchorMax = GetAnchor(center, max, factor)
                    },
                    new CuiOutlineComponent {
                        Color = b ? "0.2 0.5 0.8 0.25": "0 0 0 0",
                        Distance = "0.25 -0.25"
                    }
                }
            };
        }

        private static CuiElement BuildRawIconUI(string panel, Vector2 center, string png, float min, float max, string color, float factor, bool b)
        {
            return new CuiElement
            {
                Parent = panel,
                Components = {
                    new CuiRawImageComponent {
						//Color = "0 0 0 0"
						Png = png,
                        Color = color,
                        Material = b ? r("nffrgf/pbagrag/zngrevnyf/vgrzzngrevny.zng") : r("nffrgf/vpbaf/vpbazngrevny.zng")
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = GetAnchor(center, min, factor),
                        AnchorMax = GetAnchor(center, max, factor)
                    },
                    new CuiOutlineComponent {
                        Color = b ? "0.2 0.5 0.8 0.25": "0 0 0 0",
                        Distance = "0.25 -0.25"
                    }
                }
            };
        }

        private static CuiElement CustomIconUI(string pN, Vector2 p, string iN, float mi, float ma, string c, float f)
        {
            return new CuiElement
            {
                Parent = pN,
                Components = {
                    new CuiImageComponent {
                        Sprite = iN,
                        Color = c
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = GetAnchor(p, mi, f),
                        AnchorMax = GetAnchor(p, ma, f)
                    },
                }
            };
        }

        private static CuiButton CustomButtonUI(string panelName, Vector2 p, string cmd, float mi, float ma, string c, float f)
        {
            return new CuiButton
            {
                Button = {
                    Command = cmd,
                    Close = panelName,
                    Color = c
                },
                RectTransform = {
                    AnchorMin = GetAnchor(p, mi, f),
                    AnchorMax = GetAnchor(p, ma, f)
                },
                Text = {
                    Text = null
                }
            };
        }

        private static CuiElement CreateRawImage(string pN, Vector2 p, string iN, float mi, float ma, string c, float f)
        {
            return new CuiElement
            {
                Parent = pN,
                Components = {
                    new CuiRawImageComponent {
                        Sprite = iN,
                        Color = c,
                    },
                    new CuiRectTransformComponent {
                        AnchorMin = GetAnchor(p, mi, f),
                        AnchorMax = GetAnchor(p, ma, f)
                    }
                }
            };
        }

        private static string r(string i)
        {
            return !string.IsNullOrEmpty(i) ? new string(i.Select(x => x >= 'a' && x <= 'z' ? (char)((x - 'a' + 13) % 26 + 'a') : x >= 'A' && x <= 'Z' ? (char)((x - 'A' + 13) % 26 + 'A') : x).ToArray()) : i;
        }

        private object OnEntityGroundMissing(BaseEntity ent)
        {
            Transform root = ent.transform.root;
            if (root != ent.gameObject.transform && entRemoval.Contains(root))
            {
                timer.Once(1f, () => ClearUp(root ?? null));
                return false;
            }

            return null;
        }

        private void ClearUp(Transform root)
        {
            if (root != null) entRemoval.Remove(root);
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd.FullName == "global.entid" && arg.GetString(0, string.Empty) == "kill")
            {
                bool exists = false;
                if (arg.Player() && ctvUbrTls.TryGetValue(arg.Player().userID, out exists) && exists)
                {
                    uint targetID = arg.GetUInt(1, 0u);
                    object checkID = activeUberObjects[arg.Player().userID].GtMvTrgt();
                    if (checkID != null && checkID is uint && (uint)checkID == targetID) return false;
                }
            }

            return null;
        }

        private object OnMessagePlayer(string message, BasePlayer player)
        {
            bool exists = false;
            if (player && ctvUbrTls.TryGetValue(player.userID, out exists) && exists) if (message == "Can't afford to place!" || message == "Building is blocked!") return true;
            return null;
        }
    }
}

// --- End of file: UberTool.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KitSystem-0.0.1.cs ---
// --- Original Local Path: KitSystem-0.0.1.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("KitSystem", "Chibubrik / Deversive", "0.0.1")]
    class KitSystem : RustPlugin
    {
        #region Вар
        private static string KitsDostyp = "kits.dostup";
        private string Layer = "Kit_UI";
        private string Layer1 = "KitS_UI";

        [PluginReference] Plugin ImageLibrary, NoteUI;

        Dictionary<ulong, Data> Settings = new Dictionary<ulong, Data>();
        private Dictionary<BasePlayer, List<string>> _kitsGUI = new Dictionary<BasePlayer, List<string>>();
        #endregion

        #region Класс
        public class KitSettings 
        {
            [JsonProperty("Название набора")] public string Name;
            [JsonProperty("Формат названия набора")] public string DisplayName;
            [JsonProperty("Картинка кита")] public string Image;
            [JsonProperty("Название кулдаун набора")] public double Cooldown;
            [JsonProperty("Привилегия")] public string Perm;
            [JsonProperty("Предметы набора")] public List<ItemSettings> Items;
        }

        public class ItemSettings
        {
            [JsonProperty("Название предмета")] public string ShortName;
            [JsonProperty("Количество предметов")] public int Amount;
            [JsonProperty("Изучение")] public int Blueprint;
            [JsonProperty("Condition")] public float Condition;
            [JsonProperty("Weapon")] public Weapon Weapon;
            [JsonProperty("Content")] public List<ItemContent> Content;
            [JsonProperty("Скин предмета")] public ulong SkinID;
            [JsonProperty("Место в инвентаре")] public string Container;
        }
        public class Weapon
        {
            [JsonProperty("Тип пули")] public string ammoType;
            [JsonProperty("Количество")] public int ammoAmount;
        }
        public class ItemContent
        {
            [JsonProperty("Название предмета")] public string ShortName;
            [JsonProperty("Количество предметов")] public int Amount;
            [JsonProperty("Condition")] public float Condition;
        }
        
        
        public class AutoKit
        {
            [JsonProperty("Наборы при респавне")] public List<string> CustomKit;
        }

        public class Data
        {
            [JsonProperty("Список наборов и их кулдаун")] public Dictionary<string, KitData> SettingsData = new Dictionary<string, KitData>();
        }

        public class KitData
        {
            [JsonProperty("Кулдаун набора")] public double Cooldown;
        }
        #endregion

        #region Конфиг
        Configuration config;
        class Configuration 
        {
            [JsonProperty("Настройки наборов")] public List<KitSettings> settings;
            public static Configuration GetNewConfig() 
            {
                return new Configuration
                {
                    settings = new List<KitSettings>() 
                    {
                        new KitSettings 
                        {
                            Name = "start",
                            DisplayName = "Start",
                            Image = "https://imgur.com/xfVTgqN.png",
                            Cooldown = 10,
                            Perm = "kits.default",
                            Items = new List<ItemSettings>()
                            {
                                new ItemSettings
                                {
                                    ShortName = "wood",
                                    Amount = 1000,
                                    SkinID = 0,
                                    Container = "Main"
                                }
                            }
                        },
                    }
                };
            }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        void OnServerInitialized() 
        {
            LoadImage();


            foreach (var check in config.settings)
            {
                permission.RegisterPermission(check.Perm, this);
                permission.RegisterPermission(KitsDostyp, this);
                if (!string.IsNullOrEmpty(check.Image))
                    ImageLibrary.Call("AddImage", check.Image, check.Image);
            }

            foreach(BasePlayer check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);
        }

        
        #region ImageLibrary
        
        
        
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);

        private string fonkits = "https://imgur.com/u3nFy3w.png";
        private string nabor = "https://imgur.com/4gT6gsP.png";

        void LoadImage()
        {
            AddImage(fonkits, "fonkits");
            AddImage(nabor, "nabor");
        }
        
        #endregion

        void OnPlayerConnected(BasePlayer player) => CreateDataBase(player); 

        void OnPlayerDisconnected(BasePlayer player, string reason) => SaveDataBase(player.userID);

        void Unload() 
        {
            foreach(var check in Settings)
                SaveDataBase(check.Key);

            foreach(BasePlayer check in BasePlayer.activePlayerList)
                DestroyUi(check);
        }
        #endregion

        #region Методы
        KitData GetDataBase(ulong userID, string name)
        {
            if (!Settings.ContainsKey(userID))
                Settings[userID].SettingsData = new Dictionary<string, KitData>();

            if (!Settings[userID].SettingsData.ContainsKey(name))
                Settings[userID].SettingsData[name] = new KitData();

            return Settings[userID].SettingsData[name];
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            result = $"{time.Hours.ToString("00")}:";
            result += $"{time.Minutes.ToString("00")}:";
            result += $"{time.Seconds.ToString("00")}";
            return result;
        }
        
        void DestroyUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.DestroyUi(player, Layer1);
            _kitsGUI.Remove(player);
        }

        void UpdateInterface(BasePlayer player, string Name)
        {
            var check = config.settings.FirstOrDefault(z => z.Name == Name);
            CuiHelper.DestroyUi(player, $"Name.{check.Name}");
            CuiHelper.DestroyUi(player, $"Info.{check.Name}");
            CuiHelper.DestroyUi(player, $"Take");
            var container = new CuiElementContainer();
            var db = GetDataBase(player.userID, check.Name);
            var Time = CurTime();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0.03 0", AnchorMax = $"1 1", OffsetMin = "0 1", OffsetMax = "0 -1" },
                Text = { Text = $"<b><size=14>{check.DisplayName}</size></b>\nКолличество предметов: {check.Items.Count()}, Подождите: {FormatShortTime(TimeSpan.FromSeconds(db.Cooldown - Time))}", Color = "1 1 1 0.6", Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
            }, $"{check.Name}", $"Name.{check.Name}");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Command = $"kit info {check.Name}" },
                Text = { Text = "" }
            }, $"{check.Name}", $"Info.{check.Name}");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.2145 {0.232 + HeihtMax}", AnchorMax = $"0.376 {0.265f + HeihtMax}", OffsetMax = "0 0" },
                Button = { Color = "0.71 0.24 0.24 0.6" },
                Text = { Text = $"ПОДОЖДИТЕ: {FormatShortTime(TimeSpan.FromSeconds(db.Cooldown - Time))}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer, "Take");

            CuiHelper.AddUi(player, container);
        }
        
        double CurTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        #endregion

        #region Дата
        void CreateDataBase(BasePlayer player)
        {
            var DataBase = Interface.Oxide.DataFileSystem.ReadObject<Data>($"KitSystem/{player.userID}");
            
            if (!Settings.ContainsKey(player.userID))
                Settings.Add(player.userID, new Data());
             
            Settings[player.userID] = DataBase ?? new Data();
        }

        void SaveDataBase(ulong userId) => Interface.Oxide.DataFileSystem.WriteObject($"KitSystem/{userId}", Settings[userId]);
        #endregion

        #region Создание наборов
        void CreateKit(BasePlayer player, string kitname)
        {
            if (config.settings.Exists(x => x.Name == kitname))
            {
                player.ConsoleMessage($"Набор {kitname} уже существует!");
                return;
            }
            config.settings.Add(new KitSettings
            {
                Name = kitname,
                DisplayName = kitname,
                Image = "https://imgur.com/xfVTgqN.png",
                Cooldown = 600,
                Perm = "kitsystem.use",
                Items = GetItems(player)
            }
            );
            player.ConsoleMessage($"Вы успешно создали набор {kitname}");
            SaveConfig();
        }

        List<ItemSettings> GetItems(BasePlayer player)
        {
            
            List<ItemSettings> kititems = new List<ItemSettings>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = CreateItem(item, "wear");
                    kititems.Add(iteminfo);
                }
            }

            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = CreateItem(item, "main");
                    kititems.Add(iteminfo);
                }
            }

            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = CreateItem(item, "belt");
                    kititems.Add(iteminfo);
                }
            }

            return kititems;
        }
        
        
        ItemSettings CreateItem(Item item, string container)
        {
            ItemSettings items = new ItemSettings();
            items.Amount = item.amount;
            items.Container = container;
            items.SkinID = item.skin;
            items.Blueprint = item.blueprintTarget;
            items.ShortName = item.info.shortname;
            items.Condition = item.condition;
            items.Weapon = null;
            items.Content = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    items.Weapon = new Weapon();
                    items.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    items.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }
            if (item.contents != null)
            { 
                items.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    items.Content.Add(new ItemContent()
                        { Amount = cont.amount, Condition = cont.condition, ShortName = cont.info.shortname });
                }
            }

            return items;
        }
        #endregion

        #region Команды

        [ConsoleCommand("closeui1231")]
        void closeui1231(BasePlayer player, string command, string[] args) => DestroyUi(player);
        
        [ChatCommand("kits")]
        void ChatKits(BasePlayer player, string command, string[] args) => ChatKit(player, command, args);
        
        [ChatCommand("kit")]
        void ChatKit(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, KitsDostyp)) 
            {
                SendReply(player, "Unknown Command: Kit");
                        player.SendConsoleCommand("gametip.showgametip", string.Format("У  вас нету доступа к этой команде"));
                        timer.Once(5f, () => player.SendConsoleCommand("gametip.hidegametip"));
                return;
            }
            
            if (player == null) return;
            
            if (_kitsGUI.ContainsKey(player))
            {
                DestroyUi(player);
                return;
            }
            else
            {
                CloseUI(player);
                KitUI(player);
                return;
            }
        }

        [ConsoleCommand("kit")]
void ConsoleKit(ConsoleSystem.Arg args)
{
    var Time = CurTime();
    var player = args.Player();
    if (player != null && args.HasArgs(1))
    {
        if (args.Args[0] == "new")
        {
            if (!player.IsAdmin) return;
            if (args.Args.Length < 2)
            {
                player.ConsoleMessage("Используйте: kit new [название набора]");
                return;
            }
            CreateKit(player, args.Args[1]);
        }
        else if (args.Args[0] == "remove")
        {
            if (!player.IsAdmin) return;
            if (args.Args.Length < 2)
            {
                player.ConsoleMessage("Используйте: kit remove [название набора]");
                return;
            }
            if (config.settings.RemoveAll(z => z.Name == args.Args[1]) <= 0)
            {
                player.ConsoleMessage("Этого набора не существует!");
                return;
            }
            player.ConsoleMessage("Набор успешно удален!");
            SaveConfig();
        }                
        else if (args.Args[0] == "ui")
        {
            DestroyUi(player);
        }
        /*else if (args.Args[0] == "info")
        {
            InfoKitUI(player, args.Args[1]);
        }*/
        else if (args.Args[0] == "skip")
        {
            KitListUI(player, int.Parse(args.Args[1]));
            CuiHelper.DestroyUi(player, "Take");
        }
        else if (args.Args[0] == "take")
        {
            var check = config.settings.FirstOrDefault(z => z.Name == args.Args[1]);
            if (!permission.UserHasPermission(player.UserIDString, check.Perm))
            {
                SendReply(player, $"<size=12>Набор <color=#ee3e61>{check.DisplayName}</color> недоступен!</size>");
                return;
            }
                    
            int beltcount = check.Items.Where(i => i.Container == "belt").Count();
            int wearcount = check.Items.Where(i => i.Container == "wear").Count();
            int maincount = check.Items.Where(i => i.Container == "main").Count();
            int totalcount = beltcount + wearcount + maincount;
            if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < beltcount || (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < wearcount || (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < maincount) if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
            {
                player.SendConsoleCommand($"note.inv {player.userID} -1 \"Недостаточно места\"");
                player.SendConsoleCommand("gametip.showgametip", "Недостаточно места");
                timer.Once(5f, () => player.SendConsoleCommand("gametip.hidegametip"));
                return;
            }

            /*if (player.inventory.containerMain.itemList.Count >= 24)
            {
                player.SendConsoleCommand($"note.inv {player.userID} -1 \"Недостаточно места\"");
                player.SendConsoleCommand("gametip.showgametip", "Недостаточно места");
                timer.Once(5f, () => player.SendConsoleCommand("gametip.hidegametip"));
                return;
            }*/
            var db = GetDataBase(player.userID, check.Name);
            if (check.Cooldown > 0) 
            {
                if (db.Cooldown > Time)
                {
                    SendReply(player, "<size=12>У вас временный тайм-аут на киты</size>");
                    return;
                }
                db.Cooldown = Time + check.Cooldown;
            }
            UpdateInterface(player, check.Name);
            foreach (var item in check.Items)
            {
                var items = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(item.ShortName).itemid, item.Amount, item.SkinID);
                var main = item.Container == "main" ? player.inventory.containerMain : player.inventory.containerWear;
                var belt = item.Container == "belt" ? player.inventory.containerBelt : main;
                var moved = items.MoveToContainer(belt) || items.MoveToContainer(player.inventory.containerMain);
            }
            DestroyUi(player);

            NoteUI?.Call("DrawInfoNote", player, "Вы получили набор");
            Effect x = new Effect("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(x, player.Connection);
        }
    }
}
        #endregion

         #region Интерфейс
        float HeihtMax = 0, HeightMax = 0;

        void CloseUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer1);    
            var container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"  },
                Image = {  Color = "0 0 0 0" },
            }, "Overlay", Layer1);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"  },
                Button = { Color = HexToRustFormat("#82956200"), Command = $"kit ui" },
                Text = { Text = "" }
            }, Layer1);
            
            
            CuiHelper.AddUi(player, container);
        }
        void KitUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            _kitsGUI[player] = new List<string>();
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.2854167 0.9996268", OffsetMax = "0 0"  },
                Image = {  Png = GetImage("fonkits"), Material = "assets/icons/greyout.mat" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"  },
                Button = { Color = HexToRustFormat("#82956200"), Command = $"kit ui" },
                Text = { Text = "" }
            }, Layer);

            /*container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5"}
            }, Layer);*/

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.120438 0.8916667", AnchorMax = "0.325 0.9212964" },
                Text = { Text = $"НАБОРЫ", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.UpperLeft, FontSize = 15, Font = "robotocondensed-bold.ttf" }
            }, Layer);
            
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.120438 0.8188241", AnchorMax = "0.8266424 0.8919995" },
                Text = { Text = $"НЕ ЗАБЫВАЙТЕ ЧТО ПРИ #STORMRUST ВЫ ПОЛУЧИТЕ ДОПОЛЬНИТЕЛЬНЫЙ КИТ!", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.UpperLeft, FontSize = 13, Font = "robotocondensed-regular.ttf" }
            }, Layer);

            CuiHelper.AddUi(player, container);
            KitListUI(player);
            //InfoKitUI(player, config.settings.ElementAt(0).Name);
        }

        void KitListUI(BasePlayer player, int page = 1)
        {
            CuiHelper.DestroyUi(player, "Kits");
            var container = new CuiElementContainer();
            var name = config.settings.Where(z => (string.IsNullOrEmpty(z.Perm) || permission.UserHasPermission(player.UserIDString, z.Perm))).ToList();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.1363576 0.07595426", AnchorMax = "0.8649635 0.7994517", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0"}
            }, Layer, "Kits");
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0"  },
                Button = { Color = HexToRustFormat("#82956200"), Command = $"kit ui" },
                Text = { Text = "" }
            }, "Kits");
            
            /*
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.7", Command = $"kit ui" },
                Text = { Text = "" }
            }, Layer, "Kits");
            */

            float width = 1f, height = 0.155f, startxBox = 0f, startyBox = 1f - height, xmin = startxBox, ymin = startyBox;
            int x = 0;
            foreach (var check in name.Skip((page - 1) * 6).Take(6))
            {
                x++;
                if (x == 1) {
                    HeihtMax = 0.428f;
                    HeightMax = 0.78f;
                }
                if (x == 2) {
                    HeihtMax = 0.342f;
                    HeightMax = 0.625f;
                } 
                if (x == 3) {
                    HeihtMax = 0.257f;
                    HeightMax = 0.469f;
                }
                if (x == 4) { 
                    HeihtMax = 0.172f;
                    HeightMax = 0.313f;
                }
                if (x == 5) { 
                    HeihtMax = 0.088f;
                    HeightMax = 0.16f;
                }
                if (x == 6) { 
                    HeihtMax = 0;
                    HeightMax = 0;
                }
                var db = GetDataBase(player.userID, check.Name);
                var Time = CurTime();

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Image = { Png = GetImage("nabor"), Material = "assets/icons/greyout.mat" }
                }, "Kits", $"{check.Name}");
                xmin += width;
                if (xmin + width >= 0)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
                
                
                if (db.Cooldown > 0 && (db.Cooldown > Time))
                {
                    
                    container.Add(new CuiElement
                    {
                        Parent = $"{check.Name}",
                        Name = $"Info.{check.Name}",
                        Components =
                        {
                            new CuiImageComponent { Color = "0 0 0 0.7" },
                            new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMin = "0 1", OffsetMax = "0 -1"  }
                        }
                    });
                    
                    container.Add(new CuiElement
                    {
                        Parent = $"{check.Name}",
                        Name = $"Info.{check.Name}",
                        Components =
                        {
                            new CuiImageComponent { Color = HexToRustFormat("#5E373780") },
                            new CuiRectTransformComponent { AnchorMin = $"0.025 0.14", AnchorMax = $"0.24 0.88", OffsetMin = "0 1", OffsetMax = "0 -1"  }
                        }
                    });

                    container.Add(new CuiElement
                    {
                        Parent = $"{check.Name}",
                        Name = $"Info.{check.Name}",
                        Components =
                        {
                            new CuiImageComponent { Png = GetImage(check.Image), Material = "assets/icons/greyout.mat" },
                            new CuiRectTransformComponent { AnchorMin = $"0.045 0.22", AnchorMax = $"0.20 0.81", OffsetMin = "0 1", OffsetMax = "0 -1"  }
                        }
                    });
                    container.Add(new CuiLabel
                    {   
                        RectTransform = { AnchorMin = $"0.25 0", AnchorMax = $"1 1", OffsetMin = "0 1", OffsetMax = "0 -1" },
                        Text = { Text = $"<b><size=14>Набор - {check.DisplayName}</size></b>", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                    }, $"{check.Name}", $"Name.{check.Name}");
                    container.Add(new CuiLabel
                    {   
                        RectTransform = { AnchorMin = $"0.55 0", AnchorMax = $"1 0.34", OffsetMin = "0 1", OffsetMax = "0 -1" },
                        Text = { Text = $"Пожалуйста подождите: {FormatShortTime(TimeSpan.FromSeconds(db.Cooldown - Time))}", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                    }, $"{check.Name}", $"Name.{check.Name}");
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = $"{check.Name}",
                        Name = $"Info.{check.Name}",
                        Components =
                        {
                            new CuiImageComponent { Color = HexToRustFormat("#1D1D1D80") },
                            new CuiRectTransformComponent { AnchorMin = $"0.025 0.14", AnchorMax = $"0.24 0.88", OffsetMin = "0 1", OffsetMax = "0 -1"  }
                        }
                    });
                    
                    container.Add(new CuiElement
                    {
                        Parent = $"{check.Name}",
                        Name = $"Info.{check.Name}",
                        Components =
                        {
                            new CuiImageComponent { Png = GetImage(check.Image), Material = "assets/icons/greyout.mat" },
                            new CuiRectTransformComponent { AnchorMin = $"0.045 0.22", AnchorMax = $"0.20 0.81", OffsetMin = "0 1", OffsetMax = "0 -1"  }
                        }
                    });
                    container.Add(new CuiLabel
                    {   
                        RectTransform = { AnchorMin = $"0.25 0", AnchorMax = $"1 1", OffsetMin = "0 1", OffsetMax = "0 -1" },
                        Text = { Text = $"<b><size=14>Набор - {check.DisplayName}</size></b>", Color = HexToRustFormat("#CAD5DF"), Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                    }, $"{check.Name}", $"Name.{check.Name}");
                    container.Add(new CuiLabel
                    {   
                        RectTransform = { AnchorMin = $"0.55 0", AnchorMax = $"1 0.34", OffsetMin = "0 1", OffsetMax = "0 -1" },
                        Text = { Text = $"Можете забрать", Color = HexToRustFormat("#8E8E8E"), Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                    }, $"{check.Name}", $"Name.{check.Name}");
                    
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"0.8171875 0.02592605", AnchorMax = $"0.9833334 0.32", OffsetMin = "0 1", OffsetMax = "0 -1" },
                        Button = { Color = HexToRustFormat("#829562"), Command = $"kit take {check.Name}" },
                        Text = { Text = "ВЗЯТЬ", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-bold.ttf"}
                    }, $"{check.Name}", $"Info.{check.Name}");
                }
                /*if (!permission.UserHasPermission(player.UserIDString, check.Perm)) 
                {
                    container.Add(new CuiElement
                    {
                        Parent = $"{check.Name}",
                        Name = $"Info.{check.Name}",
                        Components =
                        {
                            new CuiImageComponent { Color = HexToRustFormat("#1D1D1D") },
                            new CuiRectTransformComponent { AnchorMin = $"0.025 0.14", AnchorMax = $"0.24 0.88", OffsetMin = "0 1", OffsetMax = "0 -1"  }
                        }
                    });
                    
                    container.Add(new CuiElement
                    {
                        Parent = $"{check.Name}",
                        Name = $"Info.{check.Name}",
                        Components =
                        {
                            new CuiImageComponent { Png = GetImage(check.Image), Material = "assets/icons/greyout.mat" },
                            new CuiRectTransformComponent { AnchorMin = $"0.045 0.22", AnchorMax = $"0.20 0.81", OffsetMin = "0 1", OffsetMax = "0 -1"  }
                        }
                    });
                    container.Add(new CuiLabel
                    {   
                        RectTransform = { AnchorMin = $"0.25 0", AnchorMax = $"1 1", OffsetMin = "0 1", OffsetMax = "0 -1" },
                        Text = { Text = $"<b><size=14>Набор - {check.DisplayName}</size></b>", Color = "1 1 1 0.8", Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                    }, $"{check.Name}", $"Name.{check.Name}");
                    container.Add(new CuiLabel
                    {   
                        RectTransform = { AnchorMin = $"0.55 0", AnchorMax = $"1 0.34", OffsetMin = "0 1", OffsetMax = "0 -1" },
                        Text = { Text = $"Вам данный набор недоступен", Color = "1 1 1 0.8", Align = TextAnchor.MiddleLeft, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                    }, $"{check.Name}", $"Name.{check.Name}");
                }*/
            }

            if (page != 1)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.688 {0 + HeightMax}", AnchorMax = $"0.76 {0.04 + HeightMax}", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat("#829562"), Command = $"kit skip {page - 1}" },
                    Text = { Text = $"▲", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                }, "Kits");
            }

            if (config.settings.ToList().Count > page * 6)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.86 {0 + HeightMax}", AnchorMax = $"0.93 {0.04 + HeightMax}", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat("#829562"), Command = $"kit skip {page + 1}" },
                    Text = { Text = $"▼", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12 }
                }, "Kits");
            }

            CuiHelper.AddUi(player, container);
        }

        /*void InfoKitUI(BasePlayer player, string name)
        {
            CuiHelper.DestroyUi(player, "ItemInventory");
            CuiHelper.DestroyUi(player, "Take");
            var container = new CuiElementContainer();
            var check = config.settings.FirstOrDefault(z => z.Name == name);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.47 0", AnchorMax = "0.81 1", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0" }
            }, Layer, "ItemInventory");

            float width1 = 0.15f, height1 = 0.085f, startxBox1 = 0f, startyBox1 = 0.78f - height1, xmin1 = startxBox1, ymin1 = startyBox1;
            foreach (var item in check.Items.Where(z => z.Container == "Рюкзак"))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{xmin1} {ymin1}", AnchorMax = $"{xmin1 + width1} {ymin1 + height1 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Image = { Color = "1 1 1 0" }
                }, "ItemInventory", "Item");

                container.Add(new CuiElement
                {
                    Parent = "Item",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.ShortName), Color = "1 1 1 0.8", FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 10", OffsetMax = "-10 -10" }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.01", AnchorMax = "0.95 1", OffsetMax = "0 0" },
                    Text = { Text = $"{item.Amount}x", Color = "1 1 1 0.9", Align = TextAnchor.LowerRight, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                }, "Item");

                xmin1 += width1;
                if (xmin1 + width1 >= 1)
                {
                    xmin1 = startxBox1;
                    ymin1 -= height1;
                }
            }

            float width2 = 0.15f, height2 = 0.085f, startxBox2 = 0f, startyBox2 = 0.42f - height2, xmin2 = startxBox2, ymin2 = startyBox2;
            foreach (var item in check.Items.Where(z => z.Container == "Одежда"))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{xmin2} {ymin2}", AnchorMax = $"{xmin2 + width2} {ymin2 + height2 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Image = { Color = "1 1 1 0" }
                }, "ItemInventory", "Item");

                container.Add(new CuiElement
                {
                    Parent = "Item",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.ShortName), Color = "1 1 1 0.8", FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 10", OffsetMax = "-10 -10" }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.01", AnchorMax = "0.95 1", OffsetMax = "0 0" },
                    Text = { Text = $"{item.Amount}x", Color = "1 1 1 0.9", Align = TextAnchor.LowerRight, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                }, "Item");
                xmin2 += width2;
            }

            float width3 = 0.15f, height3 = 0.085f, startxBox3 = 0f, startyBox3 = 0.315f - height3, xmin3 = startxBox3, ymin3 = startyBox3;
            foreach (var item in check.Items.Where(z => z.Container == "Пояс"))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{xmin3} {ymin3}", AnchorMax = $"{xmin3 + width3} {ymin3 + height3 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Image = { Color = "1 1 1 0" }
                }, "ItemInventory", "Item");

                container.Add(new CuiElement
                {
                    Parent = "Item",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.ShortName), Color = "1 1 1 0.8", FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 10", OffsetMax = "-10 -10" }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.01", AnchorMax = "0.95 1", OffsetMax = "0 0" },
                    Text = { Text = $"{item.Amount}x", Color = "1 1 1 0.9", Align = TextAnchor.LowerRight, FontSize = 10, Font = "robotocondensed-regular.ttf" }
                }, "Item");
                xmin3 += width3;
            }

            var db = GetDataBase(player.userID, check.Name);
            var Time = CurTime();

            if (db.Cooldown > 0 && (db.Cooldown > Time))
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.2145 {0.232 + HeihtMax}", AnchorMax = $"0.376 {0.265f + HeihtMax}", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat("#b05454") },
                    Text = { Text = $"ПОДОЖДИТЕ: {FormatShortTime(TimeSpan.FromSeconds(db.Cooldown - Time))}", Color = "1 1 1 0.9", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, Layer, "Take");
            }
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.2145 {0.232 + HeihtMax}", AnchorMax = $"0.376 {0.265f + HeihtMax}", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat("#5eb054"), Command = $"kit take {name}" },
                    Text = { Text = "ПОЛУЧИТЬ НАБОР", Color = "1 1 1 0.9", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, Layer, "Take");
            }

            CuiHelper.AddUi(player, container);
        }*/
        #endregion

        #region HexToRustFormat
        private static string HexToRustFormat(string hex)
        {
            UnityEngine.Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion
    }
}

// --- End of file: KitSystem-0.0.1.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HardcoreDeath.cs ---
// --- Original Local Path: HardcoreDeath.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
namespace Oxide.Plugins
{
    [Info("HardcoreDeath", "Reynostrum", "1.0.1")]
    [Description("Unlearn a random blueprint on death.")]
    class HardcoreDeath : RustPlugin
    {
        #region Init/config
        bool ProtectAdmin => GetConfig("ProtectAdmin", false);
        string Prefix => GetConfig("Prefix", "<color=#fdde23>[HARDCORE DEATH]</color>");
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Plugin is loading default configuration.");
            Config["ProtectAdmin"] = ProtectAdmin;
            Config["Prefix"] = Prefix;
            SaveConfig();
        }
        void Loaded()
        {
            lang.RegisterMessages(Messages, this);
            LoadDefaultConfig();
        }
        #endregion

        #region Oxide hooks
        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || entity as BasePlayer == null) return;
            BasePlayer player = entity.ToPlayer();
            if (!player.IsConnected()) return;
            if (ProtectAdmin && player.IsAdmin()) return;
            var playerInfo = ServerMgr.Instance.persistance.GetPlayerInfo(player.userID);
            var blueprints = playerInfo.unlockedItems;
            if (blueprints.Count == 0) return;
            var blueprint = blueprints.ToList()[UnityEngine.Random.Range(0, blueprints.Count)];
            blueprints.Remove(blueprint);
            ServerMgr.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
            player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            ItemDefinition bp = ItemManager.FindItemDefinition(blueprint);
            timer.Once(3f, () =>
            {
                PrintToChat(player, Prefix + " " + Lang("BlueprintUnlearned", player.UserIDString, bp.displayName.translated));
            });
        }
        #endregion

        #region Helpers
        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"BlueprintUnlearned", "You have unlearned {0} blueprint." },
        };
        #endregion
    }
}


// --- End of file: HardcoreDeath.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EasyAirdrop.cs ---
// --- Original Local Path: EasyAirdrop.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Easy Airdrop", "LaserHydra", "3.2.2", ResourceId = 860)]
    [Description("Easy Airdrop")]
    class EasyAirdrop : RustPlugin
    {
        ////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////

        void Loaded()
        {
            permission.RegisterPermission("easyairdrop.call", this);
            permission.RegisterPermission("easyairdrop.call.player", this);
            permission.RegisterPermission("easyairdrop.call.position", this);
            permission.RegisterPermission("easyairdrop.call.mass", this);

            LoadMessages();
            LoadConfig();
        }

        ////////////////////////////////////////
        ///     Config Handling
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Settings", "Broadcast to Chat", true);
            SetConfig("Settings", "Send to Console", true);
            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>{
                { "Chat Message", "<color=red>{player}</color> has called an airdrop."}, 
                { "Console Message", "{player} has called an airdrop. {location}"},
                { "Massdrop Chat Message", "<color=red>{player}</color> has called <color=red>{amount}</color> airdrops."},
                { "Massdrop Console Message", "{player} has called {amount} airdrops."}
            }, this);
        }

        string msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Generating new config file...");
        }

        ////////////////////////////////////////
        ///     Commands
        ////////////////////////////////////////

        [ConsoleCommand("airdrop")]
        void ccmdAirdrop(ConsoleSystem.Arg arg)
        {
            RunAsChatCommand(arg, cmdAirdrop);
        }

        [ConsoleCommand("massdrop")]
        void ccmdMassdrop(ConsoleSystem.Arg arg)
        {
            RunAsChatCommand(arg, cmdMassdrop);
        }

        [ChatCommand("airdrop")]
        void cmdAirdrop(BasePlayer player, string cmd, string[] args)
        {
            if(args.Length == 0)
            {
                SendChatMessage(player, "/airdrop <player|pos|random>");
                return;
            }

            if(args.Length > 0)
            {
                switch(args[0].ToLower())
                {
                    case "player":

                        if (!HasPermission(player, "player"))
                        {
                            SendChatMessage(player, "You don't have permission to use this command.");
                            return;
                        }

                        if (args.Length != 2)
                        {
                            SendChatMessage(player, "Syntax: /airdrop player <player>");
                            return;
                        }

                        BasePlayer target = GetPlayer(args[1], player, null);
                        if (target == null) return;

                        SpawnPlayerAirdrop(player, target);

                        break;

                    case "pos":

                        if (!HasPermission(player, "position"))
                        {
                            SendChatMessage(player, "You don't have permission to use this command.");
                            return;
                        }

                        if (args.Length != 3)
                        {
                            SendChatMessage(player, "Syntax: /airdrop pos <x> <z>");
                            return;
                        }

                        float x;
                        float y = UnityEngine.Random.Range(200, 300);
                        float z;

                        try
                        {
                            x = Convert.ToSingle(args[1]);
                            z = Convert.ToSingle(args[2]);
                        }
                        catch (FormatException ex)
                        {
                            SendChatMessage(player, "Arguments must be numbers!");
                            return;
                        }

                        SpawnAirdrop(new Vector3(x, y, z));
                        AnnounceAirdrop(player, new Vector3(x, y, z));

                        break;

                    case "random":

                        if (!HasPermission(player))
                        {
                            SendChatMessage(player, "You don't have permission to use this command.");
                            return;
                        }
                        
                        SpawnRandomAirdrop(player);

                        break;

                    default:

                        break;
                }
            }
        }

        [ChatCommand("massdrop")]
        void cmdMassdrop(BasePlayer player, string cmd, string[] args)
        {
            if(!HasPermission(player, "mass"))
            {
                SendChatMessage(player, "You don't have permission to use this command.");
                return;
            }

            if(args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /massdrop <count>");
                return;
            }

            int amount;

            try
            {
                amount = Convert.ToInt32(args[0]);
            }
            catch(FormatException ex)
            {
                SendChatMessage(player, "Argument must be a number!");
                return;
            }

            SpawnMassdrop(player, amount);
        }

        ////////////////////////////////////////
        ///     Airdrop Related
        ////////////////////////////////////////
        
        void SpawnPlayerAirdrop(BasePlayer player, BasePlayer target)
        {
            SpawnAirdrop(target.transform.position);

            AnnounceAirdrop(player, target.transform.position);
        }

        void SpawnMassdrop(BasePlayer player, int amount)
        {
            List<Vector3> locations = new List<Vector3>();

            for (int i = 1; i <= amount; i++)
            {
                Vector3 location = GetRandomVector();
                locations.Add(location);

                SpawnAirdrop(location);
            }

            AnnounceAirdrop(player, locations.ToArray());
        }

        void SpawnRandomAirdrop(BasePlayer player)
        {
            Vector3 position = GetRandomVector();
            SpawnAirdrop(position);

            AnnounceAirdrop(player, position);
        }

        void SpawnAirdrop(Vector3 position)
        {
            BaseEntity planeEntity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", new Vector3(), new Quaternion(1f, 0f, 0f, 0f));

            if (planeEntity != null)
            {
                CargoPlane plane = planeEntity.GetComponent<CargoPlane>();

                plane.InitDropPosition(position);
                planeEntity.Spawn();
            }
        }

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        bool HasPermission(BasePlayer player, string perm = "")
        {
            if (player == null)
                return true;

            if (string.IsNullOrEmpty(perm) && permission.UserHasPermission(player.UserIDString, "easyairdrop.call"))
                return true;
            else
            {
                if (permission.UserHasPermission(player.UserIDString, "easyairdrop.call." + perm))
                    return true;
            }

            return false;
        }

        ////////////////////////////////////////
        ///     Vector Related
        ////////////////////////////////////////

        Vector3 GetRandomVector()
        {
            float max = ConVar.Server.worldsize / 2;

            float x = UnityEngine.Random.Range(max * (-1), max);
            float y = UnityEngine.Random.Range(200, 300);
            float z = UnityEngine.Random.Range(max * (-1), max);

            return new Vector3(x, y, z);
        }

        ////////////////////////////////////////
        ///     Console Command Handling
        ////////////////////////////////////////

        void RunAsChatCommand(ConsoleSystem.Arg arg, Action<BasePlayer, string, string[]> command)
        {
            if (arg == null) return;

            BasePlayer player = arg?.connection?.player == null ? arg?.connection?.player as BasePlayer : null;
            string cmd = arg.cmd?.name ?? "unknown";
            string[] args = arg.HasArgs() ? arg.Args : new string[0];

            command(player, cmd, args);
        }

        ////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix = null)
        {
            List<string> foundPlayers =
                (from player in BasePlayer.activePlayerList
                 where player.displayName.ToLower().Contains(searchedPlayer.ToLower())
                 select player.displayName).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    if(prefix == null)
                        SendChatMessage(executer, "The player can not be found.");
                    else
                        SendChatMessage(executer, prefix, "The player can not be found.");

                    break;

                case 1:
                    return BasePlayer.Find(foundPlayers[0]);

                default:
                    string players = ListToString(foundPlayers, 0, ", ");

                    if (prefix == null)
                        SendChatMessage(executer, "Multiple matching players found: \n" + players);
                    else
                    SendChatMessage(executer, prefix, "Multiple matching players found: \n" + players);

                    break;
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////
        ///     Config Setup
        ////////////////////////////////////////
        
        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null)
        {
            if (player != null)
                SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
            else
                Puts(msg == null ? prefix : msg);
        }

        void AnnounceAirdrop(BasePlayer player, params Vector3[] locations)
        {
            string name = player == null ?  "Server" : player.displayName;
            string loc = string.Empty;
            string amount = locations.Length.ToString();

            if (locations.Length > 1)
                loc = "multiple locations";
            else
                loc = locations[0].ToString();

            string chatMessage = msg("Chat Message").Replace("{player}", name).Replace("{location}", loc);
            string consoleMessage = msg("Console Message").Replace("{player}", name).Replace("{location}", loc);

            if(locations.Length > 1)
            {
                chatMessage = msg("Massdrop Chat Message").Replace("{player}", name).Replace("{location}", loc).Replace("{amount}", amount);
                consoleMessage = msg("Massdrop Console Message").Replace("{player}", name).Replace("{location}", loc).Replace("{amount}", amount);
            }

            if ((bool) Config["Settings", "Broadcast to Chat"])
                BroadcastChat(chatMessage);

            if ((bool) Config["Settings", "Send to Console"])
                Puts(consoleMessage);
        }
    }
}


// --- End of file: EasyAirdrop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VPNBlock.cs ---
// --- Original Local Path: VPNBlock.cs ---

using System.Collections.Generic;
using System;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info ("VPN Block", "Calytic", "1.0.0")]
    class VPNBlock : CovalencePlugin
    {
        List<string> allowedISPs = new List<string> ();
        string IPHUB_API_KEY;
        string IPSTACK_API_KEY;
        string AA_API_KEY;
        Dictionary<string, string> headers = new Dictionary<string, string> ();
        string unauthorizedMessage;
        bool debug = false;

        void Loaded ()
        {
            LoadData ();
            LoadMessages ();
            permission.RegisterPermission ("vpnblock.canvpn", this);
            IPHUB_API_KEY = GetConfig ("IPHub", "apiKey", string.Empty);
            IPSTACK_API_KEY = GetConfig ("IPStack", "apiKey", string.Empty);
            AA_API_KEY = GetConfig ("AbstractAPI", "apiKey", string.Empty);
            debug = GetConfig ("Debug", false);
            if (string.IsNullOrEmpty (IPHUB_API_KEY) && string.IsNullOrEmpty (IPSTACK_API_KEY) && string.IsNullOrEmpty (AA_API_KEY)) {
                Unsubscribe ("OnUserConnected");
            }

            if (!string.IsNullOrEmpty (IPHUB_API_KEY)) {
                headers.Add ("X-Key", IPHUB_API_KEY);
            }

            unauthorizedMessage = GetMsg ("Unauthorized");
        }

        protected override void LoadDefaultConfig ()
        {
            Config ["IPHub", "apiKey"] = "";
            Config ["IPStack", "apiKey"] = "";
            Config ["AbstractAPI", "apiKey"] = "";
            Config ["Debug"] = false;
        }

        void LoadData ()
        {
            allowedISPs = Interface.Oxide.DataFileSystem.ReadObject<List<string>> ("vpnblock_allowedisp");
        }

        void SaveData ()
        {
            Interface.Oxide.DataFileSystem.WriteObject ("vpnblock_allowedisp", allowedISPs);
        }

        [Command ("wisp")]
        void WhiteListISP (IPlayer player, string command, string [] args)
        {
            if (!IsAllowed (player)) return;

            if (args.Length == 0) {
                player.Reply (GetMsg ("WISP Invalid", player.Id));
                return;
            }

            allowedISPs.Add (string.Join (" ", args));

            player.Reply (GetMsg ("ISP Whitelisted", player.Id));
            SaveData ();
        }

        void LoadMessages ()
        {
            lang.RegisterMessages (new Dictionary<string, string>
            {
                {"Unauthorized", "Unauthorized.  ISP/VPN not permitted"},
                {"Is Banned", "{0} is trying to connect from proxy VPN/ISP {1}"},
                {"ISP Whitelisted", "ISP Whitelisted"},
                {"WISP Invalid", "Syntax Invalid. /wisp [ISP NAME]"},
            }, this);
        }

        bool IsAllowed (IPlayer player)
        {
            if (player.IsAdmin) return true;
            return false;
        }

        bool hasAccess (IPlayer player, string permissionname)
        {
            if (player.IsAdmin) return true;
            return permission.UserHasPermission (player.Id, permissionname);
        }

        void OnUserConnected (IPlayer player)
        {
            if (hasAccess (player, "vpnblock.canvpn")) {
                return;
            }

            string ip = player.Address;
            string url = string.Empty;
            if (!string.IsNullOrEmpty (IPHUB_API_KEY)) {
                url = string.Format ("http://v2.api.iphub.info/ip/{0}", ip);
                webrequest.Enqueue (url, string.Empty, (code, response) => HandleIPHubResponse (player, url, ip, code, response), this, RequestMethod.GET, headers);
            }

            if (!string.IsNullOrEmpty (IPSTACK_API_KEY)) {
                url = string.Format ("http://api.ipstack.com/{0}?access_key={1}", ip, IPSTACK_API_KEY);
                webrequest.Enqueue (url, string.Empty, (code, response) => HandleIPStackResponse (player, url, ip, code, response), this);
            }
            
            if (!string.IsNullOrEmpty (AA_API_KEY)) {
                url = string.Format ("https://ipgeolocation.abstractapi.com/v1/?ip_address{0}&api_key={1}", ip, AA_API_KEY);
                webrequest.Enqueue (url, string.Empty, (code, response) => HandleAAResponse (player, url, ip, code, response), this);
            }
        }

        void HandleIPHubResponse (IPlayer player, string url, string ip, int code, string response)
        {
            if (code != 200 || string.IsNullOrEmpty (response)) {
                FailResponse("IPHub", code, response);
            } else {
                Dictionary<string, object> jsonresponse;
                try {
                    jsonresponse = JsonConvert.DeserializeObject<Dictionary<string, object>> (response);
                } catch (JsonReaderException e) {
                    PrintWarning ("Error parsing url response: {0}", url);
                    return;
                }

                if (debug) {
                    Log (response);
                }

                if (jsonresponse ["block"] != null) {
                    var playerVpn = (jsonresponse ["block"].ToString ());

                    if (jsonresponse ["asn"] == null) {
                        LogWarning ("IPHub response does not include asn information");
                        return;
                    }

                    var playerIsp = (jsonresponse ["asn"].ToString ());

                    if (IsWhitelisted (playerIsp)) return;

                    if (playerVpn == "1") {
                        player.Kick (unauthorizedMessage);
                        LogWarning (GetMsg ("Is Banned"), $"{player.Name} ({player.Id}/{ip})", playerIsp);
                    }
                } else if(debug) {
                    LogWarning ("IPHub response does not include block information");
                }
            }
        }
        
        void FailResponse(string service, int code, string response)
        {
            if(debug)
            {
                string message = string.Empty;
                if(code != 200)
                {
                    message = $"Response Code: {code}";
                }
                if(!string.IsNullOrEmpty(response))
                {
                    if(!string.IsNullOrEmpty(message))
                    {
                        message += "\n";
                    }
                    message += $"Response: {response}";
                }
                
                PrintError ($"Service ({service}) error: {message}");
            }
            else
            {
                PrintError ($"Service ({service}) temporarily offline");
            }
        }

        void HandleIPStackResponse (IPlayer player, string url, string ip, int code, string response)
        {
            if (code != 200 || string.IsNullOrEmpty (response)) {
                
                FailResponse("IPStack", code, response);
            } else {
                JObject json;
                try {
                    json = JObject.Parse (response);
                } catch (JsonReaderException e) {
                    LogWarning ("Error parsing URL response: {0}", url);
                    return;
                }

                if (debug) {
                    Log (response);
                }

                if (json ["error"] != null) {
                    LogWarning (json ["error"] ["info"].ToString ().Split (new char [] { '.' }, 2) [1]);
                    return;
                }

                if (json ["security"] != null) {
                    if (json ["security"] ["is_proxy"] == null) {
                        LogWarning ("IPStack response does not include proxy information");
                        return;
                    }

                    if (json ["connection"] == null) {
                        LogWarning ("IPStack response does not include connection information");
                        return;
                    }

                    if (json ["connection"] ["asn"] == null) {
                        LogWarning ("IPStack response does not include isp information");
                        return;
                    }

                    string playerVpn = json ["security"] ["is_proxy"].ToString ();
                    string playerIsp = json ["connection"] ["asn"].ToString ();

                    if (IsWhitelisted (playerIsp)) return;

                    if (playerVpn == "1") {
                        player.Kick (unauthorizedMessage);
                        LogWarning (GetMsg ("Is Banned"), $"{player.Name} ({player.Id}/{ip})", playerIsp);
                    }
                } else if(debug) {
                    LogWarning ("IPStack response does not include security information");
                }
            }
        }
        
        void HandleAAResponse (IPlayer player, string url, string ip, int code, string response)
        {
            if (code != 200 || string.IsNullOrEmpty (response)) {
                
                FailResponse("AbstractAPI", code, response);
            } else {
                JObject json;
                try {
                    json = JObject.Parse (response);
                } catch (JsonReaderException e) {
                    LogWarning ("Error parsing URL response: {0}", url);
                    return;
                }

                if (debug) {
                    Log (response);
                }

                if (json ["error"] != null) {
                    LogWarning (json ["error"] ["info"].ToString ().Split (new char [] { '.' }, 2) [1]);
                    return;
                }

                if (json ["security"] != null) {
                    if (json ["security"] ["is_vpn"] == null) {
                        LogWarning ("AbstractAPI response does not include proxy information");
                        return;
                    }

                    if (json ["connection"] == null) {
                        LogWarning ("AbstractAPI response does not include connection information");
                        return;
                    }

                    if (json ["connection"] ["isp_name"] == null) {
                        LogWarning ("AbstractAPI response does not include isp information");
                        return;
                    }

                    string playerVpn = json ["security"] ["is_vpn"].ToString ();
                    string playerIsp = json ["connection"] ["isp_name"].ToString ();

                    if (IsWhitelisted (playerIsp)) return;

                    if (playerVpn == "1") {
                        player.Kick (unauthorizedMessage);
                        LogWarning (GetMsg ("Is Banned"), $"{player.Name} ({player.Id}/{ip})", playerIsp);
                    }
                } else if(debug) {
                    LogWarning ("AbstractAPI response does not include security information");
                }
            }
        }

        bool IsWhitelisted (string playerIsp)
        {
            foreach (string isp in allowedISPs) {
                if (playerIsp.Contains (isp)) {
                    return true;
                }
            }

            return false;
        }

        T GetConfig<T> (string name, string name2, T defaultValue)
        {
            if (Config [name, name2] == null) {
                return defaultValue;
            }

            return (T)Convert.ChangeType (Config [name, name2], typeof (T));
        }

        T GetConfig<T> (string name, T defaultValue)
        {
            if (Config [name] == null)
                return defaultValue;

            return (T)Convert.ChangeType (Config [name], typeof (T));
        }

        string GetMsg (string key, object userID = null)
        {
            return lang.GetMessage (key, this, userID == null ? null : userID.ToString ());
        }
    }
}

// --- End of file: VPNBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HandyMan.cs ---
// --- Original Local Path: HandyMan.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust;
using Oxide.Plugins;
using UnityEngine;
using Facepunch;

/*****************************************************************************************************************************************************
Author  :   MrMan
Date    :   2016-02-22
Credits :   I have quite a few components / authors to credit as I've reverse engineered several plugins for various aspects of this plugin.

            bawNg / Nogrod - Building Grades
            I took the building structure configuration from Building Grades as the upgrade plugin bawNg made basically targets the structures that 
            you would normally repair. Basically this plugin provided me insight into how the configuration for a plugin can be used and adapted.

            Wulf / lukespragg - AutoDoors
            This plugin provided insight into how player preferences could be persisted.

            Zeiser/Visagalis - ZLevelsRemastered
            I noticed on my server that ZLevels was able to list help information. I saw how this was done and used it in HandyMan

            AlienX - Template for Rust Oxide
            This was my starting point. The template got the basics up and running and allowed me to do an initial test deployment with only 
            messaging functionality. It's basic, but very usefull.

*****************************************************************************************************************************************************
CHANGE HISTORY
*****************************************************************************************************************************************************
Version :   1.0.1.0
Date    :   2016-02-27
Changes :   Initial release of HandyMan - Published.
*****************************************************************************************************************************************************
Version :   1.0.1.1
Date    :   2016-03-07
Changes :   Changes made based on feedback from Wulf.
            - Removed excessive Put statements to eliminate chatting with the console.
            - Removed placeholder for registered messages as we're not using it anyway.
            - Created configuration entries for previous constant values that might allow for configuration.
            - Removed constant for version tracking as version is already tracked by the framework.
            - Updated plugin name, removing the "plugin" designation
*****************************************************************************************************************************************************
Version :   1.0.1.2
Date    :   2016-03-18
Changes :   Implemented the lang API
*****************************************************************************************************************************************************
Version :   1.0.2.1
Date    :   2016-07-28
Changes :   Implemented AOE repair for deployables
*****************************************************************************************************************************************************/

namespace Oxide.Plugins
{

    [Info("HandyMan", "MrMan", "1.0.2.1")]
    [Description("Provides AOE repair functionality to the player. Repair is only possible where you can build. HandyMan can be turned on or off.")]
    public class HandyMan : RustPlugin
    {
        #region Constants
       
        #endregion

        #region Members
        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("HandyMan");
        Dictionary<ulong, bool> playerPrefs_IsActive = new Dictionary<ulong, bool>(); //Stores player preference values - on or off.

        private ConfigData configData; //Structure containing the configuration data once read

        private PluginTimers RepairMessageTimer; //Timer to control HandyMan chats
        private bool _allowHandyManFixMessage = true; //indicator allowing for handyman fix messages
        private bool _allowAOERepair = true; //indicator for allowing AOE repair
        private string _ChatmessagePrefix = "HandyMan"; //Chat prefix control

        #endregion
        
        /// <summary>
        /// Class defined to deal with configuration structure.
        /// </summary>
        class ConfigData
        {
            //Controls the range at which the AOE repair will work
            public float RepairRange { get; set; }
            public bool DefaultHandyManOn { get; set; }
            //Contains a list of possible affected structures
            public Dictionary<string, HashSet<string>> Categories { get; set; }
            public float HandyManChatInterval { get; set; } 
        }

        /// <summary>
        /// Responsible for loading default configuration.
        /// Also creates the initial configuration file
        /// </summary>
        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                DefaultHandyManOn = true,
                HandyManChatInterval = 30,
                RepairRange = 50,
                //Specifies the structure category dictionary
            };
            //Creates a config file - Note sync is turned on so changes in the file should be taken into account, overriding what is coded here
            Config.WriteObject(config, true);
        }

        

        /// <summary>
        /// Responsible for loading the configured list of structures that will be affected.
        /// Takes the text description given in the configuration and converts this to an internal system ID for the prefab
        /// </summary>
        internal void LoadAffectedStructures()
        {
            configData = Config.ReadObject<ConfigData>();
        }

        #region Oxide Hooks
        /// <summary>
        /// Called when plugin initially loads.
        /// This section is used to "prep" the plugin and any related / config data
        /// </summary>
        private void Init()
        {
            //Read the configuration data
            LoadAffectedStructures();

        }

        //Called when this plugin has been fully loaded
        private void Loaded()
        {
            LoadMessages();
            playerPrefs_IsActive = dataFile.ReadObject<Dictionary<ulong, bool>>();
        }

        void LoadMessages()
        {
            string helpText = "HandyMan - Help - v {ver} \n"
                            + "-----------------------------\n"
                            + "/HandyMan - Shows your current preference for HandyMan.\n"
                            + "/HandyMan on/off - Turns HandyMan on/off.";

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Hired", "HandyMan has been Hired."},
                {"Fired", "HandyMan has been Fired."},
                {"Fix", "You fix this one, I'll get the rest."},
                {"NotAllowed", "You are not allowed to build here - I can't repair for you."},
                {"IFixed", "I fixed some damage over here..."},
                {"FixDone", "Guess I fixed them all..."},
                {"MissingFix", "I'm telling you... it disappeared... I can't find anything to fix."},
                {"Help", helpText}
            }, this);
        }


        /// <summary>
        /// TODO: Investigate entity driven repair.
        /// Currently only building structures are driving repair. I want to allow things like high external walls to also 
        /// drive repair, but they don't seem to fire under OnStructureRepair. I suspect this would be a better trigger as it would 
        /// allow me to check my entity configuration rather than fire on simple repair.
        /// </summary>
        /// <param name="player"></param>
        /// <param name="info"></param>
        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            //gets the correct entity type from the hammer target
            var e = info.HitEntity.GetComponent<BaseCombatEntity>();

            //checks to see that we have an entity - we should always have one
            if (e != null)
            {
                //yes - continue repair
                //checks if player preference for handyman exists on this player
                if (!playerPrefs_IsActive.ContainsKey(player.userID))
                {
                    //no - create a default entry for this player based on the default HandyMan configuration state
                    playerPrefs_IsActive[player.userID] = configData.DefaultHandyManOn;
                    dataFile.WriteObject(playerPrefs_IsActive);
                }

                //Check if repair should fire - This is to prevent a recursive / infinate loop when all structures in range fire this method.
                //This also checks if the player has turned HandyMan on
                if (_allowAOERepair && playerPrefs_IsActive[player.userID])
                {
                    //calls our custom method for this
                    Repair(e, player);
                }
            }
        }

        #endregion

        #region HelpText Hooks

        /// <summary>
        /// Responsible for publishing help for handyman on request
        /// </summary>
        /// <param name="player"></param>
        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            player.ChatMessage(GetMsg("Help",player.userID).Replace("{ver}",Version.ToString()));
        }
        #endregion


        #region Repair Methods

        /// <summary>
        /// Executes the actual repair logic.
        /// </summary>
        /// <param name="block"></param>
        /// <param name="player"></param>
        void Repair(BaseCombatEntity block, BasePlayer player)
        {
            //Set message timer to prevent user spam
            ConfigureMessageTimer();

            //Checks to see if the player can build
            if (player.CanBuild())
            {
                //yes - Player can build - check if we can display our fix message
                if (_allowHandyManFixMessage)
                {
                    //yes - display our fix message
                    SendChatMessage(player, _ChatmessagePrefix, GetMsg("Fix", player.userID));
                    _allowHandyManFixMessage = false;
                }

                //Envoke the AOE repair set
                RepairAOE(block, player);

            }
            else
            {
                SendChatMessage(player, _ChatmessagePrefix, GetMsg("NotAllowed", player.userID));
            }
        }

        /// <summary>
        /// Contains the actual AOE repair logic
        /// </summary>
        /// <param name="block"></param>
        /// <param name="player"></param>
        private void RepairAOE(BaseCombatEntity block, BasePlayer player)
        {
            //This needs to be set to false in order to prevent the subsequent repairs from triggering the AOE repair.
            //If you don't do this - you create an infinate repair loop.
            _allowAOERepair = false;

            //Sets up our RepairBlock collection
            var blocks_torepair = new HashSet<BaseCombatEntity>();
            //gets the position of the block we just hit
            var position = new OBB(block.transform, block.bounds).ToBounds().center;
            //sets up the collectionf or the blocks that will be affected
            var blocks = Pool.GetList<BaseCombatEntity>();

            //gets a list of entities within a specified range of the current target
            Vis.Entities(position, configData.RepairRange, blocks, 270532864);
            

            //check if we have blocks - we should always have at least 1
            if (blocks.Count > 0)
            {
                bool hasRepaired = false;

                //cycle through our block list - figure out which ones need repairing
                foreach (var item in blocks)
                {
                    //check to see if the block has been damaged before repairing.
                    if (item.Health() < item.MaxHealth())
                    {
                        //yes - repair
                        item.DoRepair(player);
                        item.SendNetworkUpdate();
                        hasRepaired = true;
                    }
                }
                Pool.FreeList(ref blocks);

                //checks to see if any blocks were repaired
                if (hasRepaired)
                {
                    //yes - indicate
                    SendChatMessage(player, _ChatmessagePrefix, GetMsg("IFixed", player.userID));
                }
                else
                {
                    //No - indicate
                    SendChatMessage(player, _ChatmessagePrefix, GetMsg("FixDone", player.userID));
                }
            }
            else
            {
                SendChatMessage(player, _ChatmessagePrefix, GetMsg("MissingFix", player.userID));
            }
            _allowAOERepair = true;
        }

        /// <summary>
        /// Responsible for preventing spam to the user by setting a timer to prevent messages from Handyman for a set duration.
        /// </summary>
        private void ConfigureMessageTimer()
        {
            //checks if our timer exists
            if (RepairMessageTimer == null)
            {
                //no - create it
                RepairMessageTimer = new PluginTimers(this);
                //set it to fire every xx seconds based on configuration
                RepairMessageTimer.Every(configData.HandyManChatInterval, RepairMessageTimer_Elapsed);
            }
        }

        /// <summary>
        /// Timer for our repair message elapsed - set allow to true
        /// </summary>
        private void RepairMessageTimer_Elapsed()
        {
            //set the allow message to true so the next message will show
            _allowHandyManFixMessage = true;
        }

        #endregion


        #region Chat and Console Command Examples
        [ChatCommand("HandyMan")]
        private void ChatCommand_HandyMan(BasePlayer player, string command, string[] args)
        {
            if (args != null && args.Length >= 1)
            {
                if (args[0].ToLower() == "on")
                {

                    playerPrefs_IsActive[player.userID] = true;
                }
                else
                {
                    playerPrefs_IsActive[player.userID] = false;
                }
                dataFile.WriteObject(playerPrefs_IsActive);
            }

            if (playerPrefs_IsActive[player.userID] == true)
            {
                SendChatMessage(player, _ChatmessagePrefix, GetMsg("Hired", player.userID));
            }
            else
            {
                SendChatMessage(player, _ChatmessagePrefix, GetMsg("Fired", player.userID));
            }
        }

        [ConsoleCommand("HealthCheck")]
        private void ConsoleCommand_HealthCheck()
        {
            Puts("HandyMan is running.");
        }
        #endregion

        #region Helpers


        /// <summary>
        /// Retreives the configured message from the lang API storage.
        /// </summary>
        /// <param name="key"></param>
        /// <param name="userID"></param>
        /// <returns></returns>
        string GetMsg(string key, object userID = null)
        {
            return lang.GetMessage(key, this, userID.ToString());
        }

        /// <summary>
        /// Writes message to player chat
        /// </summary>
        /// <param name="player"></param>
        /// <param name="prefix"></param>
        /// <param name="msg"></param>
        private void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        #endregion
    }
}


// --- End of file: HandyMan.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildBlocker.cs ---
// --- Original Local Path: BuildBlocker.cs ---

using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("BuildBlocker", "Bombardir", "1.3.4", ResourceId = 834)]
    class BuildBlocker : RustPlugin
    {
        #region Config

        static bool OnRoad = false;
        static bool OnRiver = false;
        static bool OnRock = false;
        static bool InTunnel = true;
        static bool InRock = true;
        static bool InCave = false;
        static bool InWarehouse = true;
        static bool InMetalBuilding = true;
        static bool InHangar = true;
        static bool InTank = true;
        static bool InBase = true;
        static bool InStormDrain = false;
        static bool UnTerrain = true;
        static bool UnBridge = false;
        static bool UnRadio = false;
        static bool BlockStructuresHeight = false;
        static bool BlockDeployablesHeight = false;
        static int MaxHeight = 100;
        static bool BlockStructuresWater = false;
        static bool BlockDeployablesWater = false;
        static int MaxWater = -2;
        static int AuthLVL = 2;
        static string Msg = "Hey! You can't build here!";
        static string MsgHeight = "You can't build here! (Height limit 100m)";
        static string MsgWater = "You can't build here! (Water limit -2m)";

        void LoadDefaultConfig() { }

        void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
				Config[Key] = var;
        }

        void Init() 
        {
            CheckCfg<bool>("Block On Roads", ref OnRoad);
            CheckCfg<bool>("Block On Rivers", ref OnRiver);
            CheckCfg<bool>("Block On Rock", ref OnRock);
            CheckCfg<bool>("Block In Rock", ref InRock);
            CheckCfg<bool>("Block In Rock Cave", ref InCave);
            CheckCfg<bool>("Block In Storm Drain", ref InStormDrain);
            CheckCfg<bool>("Block In Tunnel", ref InTunnel);
            CheckCfg<bool>("Block In Base", ref InBase);
            CheckCfg<bool>("Block In Warehouse", ref InWarehouse);
            CheckCfg<bool>("Block In Metal Building", ref InMetalBuilding);
            CheckCfg<bool>("Block In Hangar", ref InHangar);
            CheckCfg<bool>("Block Under Terrain", ref UnTerrain);
            CheckCfg<bool>("Block Under|On Metal Sphere", ref InTank);
            CheckCfg<bool>("Block Under|On Bridge", ref UnBridge);
            CheckCfg<bool>("Block Under|On Radar", ref UnRadio);
            CheckCfg<int>("Max Height Limit", ref MaxHeight);
            CheckCfg<bool>("Block Structures above the max height", ref BlockStructuresHeight);
            CheckCfg<bool>("Block Deployables above the max height", ref BlockDeployablesHeight);
            CheckCfg<int>("Max Under Water Height Limit", ref MaxWater);
            CheckCfg<bool>("Block Structures under water", ref BlockStructuresWater);
            CheckCfg<bool>("Block Deployables under water", ref BlockDeployablesWater);
            CheckCfg<string>("Block Water Message", ref MsgWater);
            CheckCfg<string>("Block Height Message", ref MsgHeight);
            CheckCfg<string>("Block Message", ref Msg); 
            CheckCfg<int>("Ignore Auth Lvl", ref AuthLVL);
            SaveConfig(); 
        }
        #endregion

        #region Logic

        void CheckBlock(BaseNetworkable StartBlock, BasePlayer sender, bool CheckHeight, bool CheckWater)
        {
            if (StartBlock && sender.net.connection.authLevel < AuthLVL && !StartBlock.isDestroyed)
            {
                Vector3 Pos = StartBlock.transform.position;
                if (StartBlock.name == "foundation.steps(Clone)")
                    Pos.y += 1.3f;

                if (CheckHeight || CheckWater)
                {
                    float height = TerrainMeta.HeightMap.GetHeight(Pos);
                    if (CheckHeight && Pos.y - height > MaxHeight)
                    {
                        sender.ChatMessage(MsgHeight);
                        StartBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                    else if (CheckWater && height < 0 && height < MaxWater && Pos.y < 2.8f )
                    {
                        sender.ChatMessage(MsgWater);
                        StartBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                        return;
                    }
                }

                Pos.y += 200;
                RaycastHit[] hits = Physics.RaycastAll(Pos, Vector3.down, 202.8f);
                Pos.y -= 200;

                bool isMining = StartBlock is MiningQuarry;
                for (int i = 0; i < hits.Length; i++)
                {
                    RaycastHit hit = hits[i];
                    if (hit.collider)
                    {
                        string ColName = hit.collider.name;
                        if (UnTerrain && !isMining && ColName == "Terrain" && hit.point.y > Pos.y ||
                            InBase && ColName.StartsWith("base", StringComparison.CurrentCultureIgnoreCase) ||
                            InMetalBuilding && ColName == "Metal_building_COL" ||
                            UnBridge && ColName == "Bridge_top" ||
                            UnRadio && ColName.StartsWith("dish") ||
                            InWarehouse && ColName.StartsWith("Warehouse") ||
                            InHangar && ColName.StartsWith("Hangar") ||
                            OnRiver && ColName == "rivers" ||
                            InTunnel && ColName.Contains("unnel") ||
                            OnRoad && ColName.EndsWith("road", StringComparison.CurrentCultureIgnoreCase) || 
                            InStormDrain && ColName.StartsWith("Storm_drain", StringComparison.CurrentCultureIgnoreCase) ||
                            InTank && ColName == "howie_spheretank_blockin" ||
                            (ColName.StartsWith("rock", StringComparison.CurrentCultureIgnoreCase) ||
                            ColName.StartsWith("cliff", StringComparison.CurrentCultureIgnoreCase)) && 
                            (hit.point.y < Pos.y ? OnRock : hit.collider.bounds.Contains(Pos) ? InRock : InCave))
                        {
                            sender.ChatMessage(Msg);
                            StartBlock.Kill(BaseNetworkable.DestroyMode.Gib);
                            break;
                        }
                    }
                }
            }
        }

        #endregion

        #region Hooks

        void OnEntityBuilt(Planner plan, GameObject obj) => CheckBlock(obj.GetComponent<BaseNetworkable>(), plan.ownerPlayer, BlockStructuresHeight, BlockStructuresWater);

        void OnItemDeployed(Deployer deployer, BaseEntity deployedentity)
        {
            if (!(deployedentity is BaseLock))
                CheckBlock((BaseNetworkable) deployedentity, deployer.ownerPlayer, BlockDeployablesHeight, BlockDeployablesWater);
        }

        #endregion
    }
}

// --- End of file: BuildBlocker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomVendingSetup.cs ---
// --- Original Local Path: CustomVendingSetup.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using Facepunch;
using UnityEngine;
using VLB;
using static ProtoBuf.VendingMachine;
using static VendingMachine;

using CustomGetDataCallback = System.Func<Newtonsoft.Json.Linq.JObject>;
using CustomSaveDataCallback = System.Action<Newtonsoft.Json.Linq.JObject>;

namespace Oxide.Plugins
{
    [Info("Custom Vending Setup", "WhiteThunder", "2.10.3")]
    [Description("Allows editing orders at NPC vending machines.")]
    internal class CustomVendingSetup : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin BagOfHolding, Economics, ItemRetriever, MonumentFinder, ServerRewards;

        private SavedData _pluginData;
        private Configuration _config;

        private const string PermissionUse = "customvendingsetup.use";

        private const string StoragePrefab = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";

        private const int ItemsPerRow = 6;
        private const int InventorySize = 24;

        // Going over 7 causes offers to get cut off regardless of resolution.
        private const int MaxVendingOffers = 7;

        private const int ShopNameNoteSlot = 29;
        private const int ContainerCapacity = 30;
        private const int MaxItemRows = ContainerCapacity / ItemsPerRow;
        private const int BlueprintItemId = -996920608;
        private const float MinCurrencyCondition = 0.5f;

        private readonly object True = true;
        private readonly object False = false;

        private ItemRetrieverAdapter _itemRetrieverAdapter;
        private DataProviderRegistry _dataProviderRegistry = new DataProviderRegistry();
        private ComponentTracker<NPCVendingMachine, VendingMachineComponent> _componentTracker = new ComponentTracker<NPCVendingMachine, VendingMachineComponent>();
        private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
        private MonumentFinderAdapter _monumentFinderAdapter;
        private VendingMachineManager _vendingMachineManager;
        private BagOfHoldingLimitManager _bagOfHoldingLimitManager;
        private DynamicHookSubscriber<BaseVendingController> _inaccessibleVendingMachines;
        private DynamicHookSubscriber<BasePlayer> _playersNeedingFakeInventory;
        private PaymentProviderResolver _paymentProviderResolver;

        private ItemDefinition _noteItemDefinition;
        private bool _isServerInitialized;
        private bool _performingInstantRestock;
        private VendingItem _itemBeingSold;
        private Dictionary<string, object> _itemRetrieverQuery = new Dictionary<string, object>();
        private List<Item> _reusableItemList = new List<Item>();
        private object[] _objectArray1 = new object[1];
        private object[] _objectArray2 = new object[2];

        public CustomVendingSetup()
        {
            _monumentFinderAdapter = new MonumentFinderAdapter(this);
            _itemRetrieverAdapter = new ItemRetrieverAdapter(this);
            _componentFactory = new ComponentFactory<NPCVendingMachine, VendingMachineComponent>(this, _componentTracker);
            _vendingMachineManager = new VendingMachineManager(this, _componentFactory, _dataProviderRegistry);
            _bagOfHoldingLimitManager = new BagOfHoldingLimitManager(this);
            _paymentProviderResolver = new PaymentProviderResolver(this);
            _inaccessibleVendingMachines = new DynamicHookSubscriber<BaseVendingController>(this, nameof(CanAccessVendingMachine));
            _playersNeedingFakeInventory = new DynamicHookSubscriber<BasePlayer>(this, nameof(OnEntitySaved), nameof(OnInventoryNetworkUpdate));
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init();
            _pluginData = SavedData.Load();

            permission.RegisterPermission(PermissionUse, this);

            Unsubscribe(nameof(OnEntitySpawned));

            _inaccessibleVendingMachines.UnsubscribeAll();
            _playersNeedingFakeInventory.UnsubscribeAll();
        }

        private void OnServerInitialized()
        {
            _isServerInitialized = true;

            if (MonumentFinder == null)
            {
                LogError("MonumentFinder is not loaded, get it at http://umod.org.");
            }
            else
            {
                // Delay to allow Monument Finder to register monuments via its `OnServerInitialized()` hook.
                NextTick(() =>
                {
                    _vendingMachineManager.SetupAll();

                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        var container = player.inventory.loot.containers.FirstOrDefault();
                        if (container == null)
                            continue;

                        var vendingMachine = container.entityOwner as NPCVendingMachine;
                        if (vendingMachine != null)
                        {
                            OnVendingShopOpened(vendingMachine, player);
                        }
                    }
                });
            }

            if (ItemRetriever != null)
            {
                _itemRetrieverAdapter.HandleItemRetrieverLoaded();
            }

            _bagOfHoldingLimitManager.OnServerInitialized();

            Subscribe(nameof(OnEntitySpawned));

            _noteItemDefinition = ItemManager.FindItemDefinition("note");
        }

        private void Unload()
        {
            _vendingMachineManager.ResetAll();
            ObjectCache.Clear<int>();
            ObjectCache.Clear<float>();
            ObjectCache.Clear<ulong>();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            switch (plugin.Name)
            {
                case nameof(MonumentFinder):
                {
                    // Check whether initialized to detect only late (re)loads.
                    // Note: We are not dynamically subscribing to OnPluginLoaded since that interferes with the PluginReference attribute.
                    if (_isServerInitialized)
                    {
                        // Delay to ensure MonumentFinder's `OnServerInitialized` method is called.
                        NextTick(_vendingMachineManager.SetupAll);
                    }
                    return;
                }

                case nameof(BagOfHolding):
                    _bagOfHoldingLimitManager.HandleBagOfHoldingLoadedChanged();
                    return;

                case nameof(ItemRetriever):
                    _itemRetrieverAdapter.HandleItemRetrieverLoaded();
                    return;
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            switch (plugin.Name)
            {
                case nameof(ItemRetriever):
                    _itemRetrieverAdapter.HandleItemRetrieverUnloaded();
                    return;
            }
        }

        private void OnEntitySpawned(NPCVendingMachine vendingMachine)
        {
            // Delay to give other plugins a chance to save a reference so they can block setup.
            NextTick(() =>
            {
                if (vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                _vendingMachineManager.HandleVendingMachineSpawned(vendingMachine);
            });
        }

        private void OnEntityKill(NPCVendingMachine vendingMachine)
        {
            _vendingMachineManager.HandleVendingMachineKilled(vendingMachine);
        }

        private void OnVendingShopOpened(NPCVendingMachine vendingMachine, BasePlayer player)
        {
            var controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return;

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return;

            if (permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                component.ShowAdminUI(player);
            }

            var profile = controller.Profile;
            if (profile?.Offers == null)
                return;

            if (_config.ShopUISettings.EnableSkinOverlays)
            {
                component.ShowShopUI(player);
            }

            if ((_config.Economics.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.Economics))
                || (_config.ServerRewards.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.ServerRewards)))
            {
                // Make sure OnEntitySaved/OnInventoryNetworkUpdate are subscribed to modify network updates.
                _playersNeedingFakeInventory.Add(player);

                // Mark inventory dirty to send a network update, which will be modified by hooks.
                player.inventory.containerMain.MarkDirty();
            }
        }

        private object OnVendingTransaction(NPCVendingMachine vendingMachine, BasePlayer player, int sellOrderIndex, int numberOfTransactions, ItemContainer targetContainer)
        {
            var vendingProfile = _vendingMachineManager.GetController(vendingMachine)?.Profile;
            if (vendingProfile?.Offers == null)
            {
                // Don't override the transaction logic because the vending machine is not customized by this plugin.
                return null;
            }

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return null;

            var offer = vendingProfile.GetOfferForSellOrderIndex(sellOrderIndex);
            if (offer == null)
            {
                // Something is wrong. No valid offer exists at the specified index.
                return null;
            }

            numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, HasCondition(offer.SellItem.ItemDefinition) ? 1 : 1000000);

            var sellAmount = offer.SellItem.Amount * numberOfTransactions;
            var sellItemQuery = ItemQuery.FromSellItem(offer.SellItem);
            if (ItemUtils.SumContainerItems(vendingMachine.inventory, ref sellItemQuery) < sellAmount)
            {
                // The vending machine has insufficient stock.
                return False;
            }

            var currencyAmount = offer.CurrencyItem.Amount * numberOfTransactions;
            var currencyProvider = _paymentProviderResolver.Resolve(offer.CurrencyItem);
            if (currencyProvider.GetBalance(player) < currencyAmount)
            {
                // The player has insufficient currency.
                return False;
            }

            _reusableItemList.Clear();
            currencyProvider.TakeBalance(player, currencyAmount, _reusableItemList);

            var onMarketplaceItemPurchase = (targetContainer?.entityOwner as MarketTerminal)?._onItemPurchasedCached;

            // Note: The list will be empty if Economics or Server Rewards currency were used.
            foreach (var currencyItem in _reusableItemList)
            {
                MaybeGiveWeaponAmmo(currencyItem, player);

                // Show a notice on the marketplace UI that the item was taken.
                onMarketplaceItemPurchase?.Invoke(player, currencyItem);

                // Instead of calling `vendingMachine.TakeCurrencyItem(itemToTake)`, just remove the item.
                // This fixes an "issue" where the item would go into the vending machine storage if there was a matching stack.
                // Note: The "OnTakeCurrencyItem" hook is not called because Item Retriever always takes the items.
                currencyItem.RemoveFromContainer();
                currencyItem.Remove();
            }

            _reusableItemList.Clear();

            if (offer.RefillDelay <= 0)
            {
                // Don't change the stock amount. Instead, we will just leave the items in the vending machine.
                // The "CanVendingStockRefill" hook will use this flag to skip all logic.
                _performingInstantRestock = true;
            }
            else
            {
                // The "CanVendingStockRefill" hook may use this to add stock.
                _itemBeingSold = offer.SellItem;
            }

            _paymentProviderResolver.Resolve(offer.SellItem).AddBalance(player, sellAmount, new TransactionContext
            {
                VendingMachine = vendingMachine,
                SellItem = offer.SellItem,
                TargetContainer = targetContainer,
                OnMarketplaceItemPurchase = onMarketplaceItemPurchase,
            });

            // These can now be unset since the "CanVendingStockRefill" hook can no longer be called after this point.
            _performingInstantRestock = false;
            _itemBeingSold = null;

            if (offer.RefillDelay > 0)
            {
                // Remove stock only after the items have been given to the player,
                // so that max stack size can be determined by an item in stock.
                ItemUtils.TakeContainerItems(vendingMachine.inventory, ref sellItemQuery, sellAmount);
            }

            vendingMachine.UpdateEmptyFlag();

            // Reopen the UI if it was closed due to a transaction delay.
            if (!component.HasUI(player) && IsLootingVendingMachine(player, vendingMachine))
            {
                OnVendingShopOpened(vendingMachine, player);
            }

            if (offer.CustomSettings?.Count > 0)
            {
                ExposedHooks.OnCustomVendingSetupTransactionWithCustomSettings(vendingMachine, offer.CustomSettings);
            }

            return True;
        }

        private void OnBuyVendingItem(NPCVendingMachine vendingMachine, BasePlayer player, int sellOrderID, int amount)
        {
            if (!IsCustomized(vendingMachine))
                return;

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return;

            ScheduleRemoveUI(vendingMachine, player, component);
        }

        private object OnNpcGiveSoldItem(NPCVendingMachine vendingMachine, Item item, BasePlayer player)
        {
            if (!IsCustomized(vendingMachine))
                return null;

            // Simply give the item, without splitting it, since stack size logic has already been taken into account.
            player.GiveItem(item);
            return False;
        }

        // This hook is exposed by plugin: Vending In Stock (VendingInStock).
        private object CanVendingStockRefill(NPCVendingMachine vendingMachine, Item soldItem, BasePlayer player)
        {
            if (!IsCustomized(vendingMachine))
            {
                // Allow VendingInStock to restock the item.
                return null;
            }

            if (_performingInstantRestock)
            {
                // Don't restock the item, since it was never removed from the vending machine in the first place.
                return False;
            }

            // Override VendingInStock behavior to prevent creating new items in the container.
            // This also ensures additional item attributes are preserved.
            var itemQuery = ItemQuery.FromSellItem(_itemBeingSold);
            var existingItem = ItemUtils.FindFirstContainerItem(vendingMachine.inventory, ref itemQuery);
            if (existingItem != null)
            {
                existingItem.amount += soldItem.amount;
                existingItem.MarkDirty();
                return False;
            }

            if (_itemBeingSold == null)
            {
                // Something is wrong. The "CanPurchaseItem" hook was not called via this plugin.
                return null;
            }

            var newItem = _itemBeingSold.Create(soldItem.amount);
            vendingMachine.transactionActive = true;
            if (!newItem.MoveToContainer(vendingMachine.inventory, allowStack: false))
            {
                newItem.Remove();
            }
            vendingMachine.transactionActive = false;

            return False;
        }

        private object CanAccessVendingMachine(DeliveryDroneConfig deliveryDroneConfig, NPCVendingMachine vendingMachine)
        {
            if (!vendingMachine.IsBroadcasting())
                return null;

            var controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return null;

            if (_inaccessibleVendingMachines.Contains(controller))
                return False;

            return null;
        }

        private void OnEntitySaved(BasePlayer player, BaseNetworkable.SaveInfo saveInfo)
        {
            AddCurrencyToContainerSnapshot(player, saveInfo.msg.basePlayer.inventory.invMain);
        }

        private void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updatedItemContainer, PlayerInventory.Type inventoryType)
        {
            if (inventoryType != PlayerInventory.Type.Main)
                return;

            AddCurrencyToContainerSnapshot(inventory.baseEntity, updatedItemContainer.container[0]);
        }

        #endregion

        #region API

        private bool API_IsCustomized(NPCVendingMachine vendingMachine)
        {
            return IsCustomized(vendingMachine);
        }

        private void API_RefreshDataProvider(NPCVendingMachine vendingMachine)
        {
            _vendingMachineManager.HandleVendingMachineKilled(vendingMachine);
            _vendingMachineManager.HandleVendingMachineSpawned(vendingMachine);
        }

        // Undocumented. Intended for MonumentAddons migration to become a Data Provider.
        private JObject API_MigrateVendingProfile(NPCVendingMachine vendingMachine)
        {
            var location = MonumentRelativePosition.FromVendingMachine(_monumentFinderAdapter, vendingMachine);
            if (location == null)
            {
                // This can happen if a vending machine was moved outside a monument's bounds.
                return null;
            }

            var vendingProfile = _pluginData.FindProfile(location);
            if (vendingProfile == null)
            {
                return null;
            }

            JObject jObject;

            try
            {
                jObject = JObject.FromObject(vendingProfile);
            }
            catch (Exception e)
            {
                LogError($"Unable to migrate vending profile\n{e}");
                return null;
            }

            _pluginData.VendingProfiles.Remove(vendingProfile);
            _pluginData.Save();

            return jObject;
        }

        #endregion

        #region Dependencies

        private class MonumentAdapter
        {
            public string PrefabName => (string)_monumentInfo["PrefabName"];
            public string Alias => (string)_monumentInfo["Alias"];
            public Vector3 Position => (Vector3)_monumentInfo["Position"];

            private Dictionary<string, object> _monumentInfo;

            public MonumentAdapter(Dictionary<string, object> monumentInfo)
            {
                _monumentInfo = monumentInfo;
            }

            public Vector3 InverseTransformPoint(Vector3 worldPosition) =>
                ((Func<Vector3, Vector3>)_monumentInfo["InverseTransformPoint"]).Invoke(worldPosition);

            public bool IsInBounds(Vector3 position) =>
                ((Func<Vector3, bool>)_monumentInfo["IsInBounds"]).Invoke(position);
        }

        private class MonumentFinderAdapter
        {
            private CustomVendingSetup _plugin;
            private Plugin _monumentFinder => _plugin.MonumentFinder;

            public MonumentFinderAdapter(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public MonumentAdapter GetMonumentAdapter(Vector3 position)
            {
                var dictResult = _monumentFinder?.Call("API_GetClosest", position) as Dictionary<string, object>;
                if (dictResult == null)
                    return null;

                var monument = new MonumentAdapter(dictResult);
                return monument.IsInBounds(position) ? monument : null;
            }

            public MonumentAdapter GetMonumentAdapter(BaseEntity entity)
            {
                return GetMonumentAdapter(entity.transform.position);
            }
        }

        private class BagOfHoldingLimitManager
        {
            private class CustomLimitProfile
            {
                [JsonProperty("Max total bags")]
                public int MaxTotalBags = -1;
            }

            private CustomVendingSetup _plugin;
            private object _limitProfile;

            public BagOfHoldingLimitManager(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public void OnServerInitialized()
            {
                HandleBagOfHoldingLoadedChanged();
            }

            public void HandleBagOfHoldingLoadedChanged()
            {
                if (_plugin.BagOfHolding == null)
                    return;

                _limitProfile = _plugin.BagOfHolding.Call("API_CreateLimitProfile", JsonConvert.SerializeObject(new CustomLimitProfile()));

                if (_limitProfile == null)
                {
                    LogError("Failed to create limit profile.");
                }
            }

            public void SetLimitProfile(ItemContainer container)
            {
                if (_limitProfile == null || _plugin.BagOfHolding == null)
                    return;

                var result = _plugin.BagOfHolding.Call("API_SetLimitProfile", container, _limitProfile);
                if (!(result is bool) || (bool)result == false)
                {
                    LogError("Failed to set limit profile for vending container");
                }
            }

            public void RemoveLimitProfile(ItemContainer container)
            {
                if (_limitProfile == null || _plugin.BagOfHolding == null)
                    return;

                _plugin.BagOfHolding.Call("API_RemoveLimitProfile", container);
            }
        }

        private class ItemRetrieverApi
        {
            public Func<BasePlayer, Dictionary<string, object>, int> SumPlayerItems { get; }
            public Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int> TakePlayerItems { get; }

            public ItemRetrieverApi(Dictionary<string, object> apiDict)
            {
                SumPlayerItems = apiDict[nameof(SumPlayerItems)] as Func<BasePlayer, Dictionary<string, object>, int>;
                TakePlayerItems = apiDict[nameof(TakePlayerItems)] as Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int>;
            }
        }

        private class ItemRetrieverAdapter
        {
            public ItemRetrieverApi Api { get; private set; }

            private CustomVendingSetup _plugin;

            private Plugin ItemRetriever => _plugin.ItemRetriever;

            public ItemRetrieverAdapter(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public void HandleItemRetrieverLoaded()
            {
                Api = new ItemRetrieverApi(ItemRetriever.Call("API_GetApi") as Dictionary<string, object>);
            }

            public void HandleItemRetrieverUnloaded()
            {
                Api = null;
            }
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnCustomVendingSetup(NPCVendingMachine vendingMachine)
            {
                return Interface.CallHook("OnCustomVendingSetup", vendingMachine);
            }

            public static object CanPurchaseItem(BasePlayer player, Item item, Action<BasePlayer, Item> onItemPurchased, NPCVendingMachine vendingMachine, ItemContainer targetContainer)
            {
                return Interface.CallHook("CanPurchaseItem", player, item, onItemPurchased, vendingMachine, targetContainer);
            }

            public static Dictionary<string, object> OnCustomVendingSetupDataProvider(NPCVendingMachine vendingMachine)
            {
                return Interface.CallHook("OnCustomVendingSetupDataProvider", vendingMachine) as Dictionary<string, object>;
            }

            public static void OnCustomVendingSetupOfferSettingsParse(CaseInsensitiveDictionary<string> localizedSettings, CaseInsensitiveDictionary<object> customSettings)
            {
                Interface.CallHook("OnCustomVendingSetupOfferSettingsParse", localizedSettings, customSettings);
            }

            public static void OnCustomVendingSetupOfferSettingsDisplay(CaseInsensitiveDictionary<object> customSettings, CaseInsensitiveDictionary<string> localizedSettings)
            {
                Interface.CallHook("OnCustomVendingSetupOfferSettingsDisplay", customSettings, localizedSettings);
            }

            public static void OnCustomVendingSetupTransactionWithCustomSettings(NPCVendingMachine vendingMachine, CaseInsensitiveDictionary<object> customSettings)
            {
                Interface.CallHook("OnCustomVendingSetupTransactionWithCustomSettings", vendingMachine, customSettings);
            }
        }

        #endregion

        #region Commands

        private static class UICommands
        {
            public const string Edit = "edit";
            public const string Reset = "reset";
            public const string Save = "save";
            public const string Cancel = "cancel";
            public const string ToggleBroadcast = "togglebroadcast";
            public const string ToggleDroneAccessible = "toggledroneaccessible";
        }

        [Command("customvendingsetup.ui")]
        private void CommandUI(IPlayer player, string cmd, string[] args)
        {
            if (args.Length < 2)
                return;

            NPCVendingMachine vendingMachine;
            BaseVendingController vendingController;
            if (!PassesUICommandChecks(player, args, out vendingMachine, out vendingController))
                return;

            var basePlayer = player.Object as BasePlayer;
            var subCommand = args[1];

            switch (subCommand)
            {
                case UICommands.Edit:
                    if (vendingController.EditController != null)
                    {
                        basePlayer.EndLooting();
                        ChatMessage(basePlayer, Lang.ErrorCurrentlyBeingEdited, vendingController.EditController.EditorPlayer.displayName);
                        return;
                    }

                    vendingController.StartEditing(basePlayer, vendingMachine);
                    break;

                case UICommands.Reset:
                    vendingController.HandleReset();
                    vendingMachine.FullUpdate();
                    basePlayer.EndLooting();
                    basePlayer.inventory.loot.SendImmediate();
                    OpenVendingMachineDelayed(basePlayer, vendingMachine);
                    break;

                case UICommands.ToggleBroadcast:
                    vendingController.EditController?.ToggleBroadcast();
                    break;

                case UICommands.ToggleDroneAccessible:
                    vendingController.EditController?.ToggleDroneAccessible();
                    break;

                case UICommands.Save:
                    vendingController.HandleSave(vendingMachine);
                    vendingMachine.FullUpdate();
                    OpenVendingMachine(basePlayer, vendingMachine);
                    break;

                case UICommands.Cancel:
                    OpenVendingMachine(basePlayer, vendingMachine);
                    break;
            }
        }

        #endregion

        #region Helper Methods

        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Custom Vending Setup] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Custom Vending Setup] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Custom Vending Setup] {message}");

        private static bool IsLootingVendingMachine(BasePlayer player, NPCVendingMachine vendingMachine)
        {
            return player.inventory.loot.containers.FirstOrDefault()?.entityOwner == vendingMachine;
        }

        private static bool AreVectorsClose(Vector3 a, Vector3 b, float xZTolerance = 0.001f, float yTolerance = 10)
        {
            // Allow a generous amount of vertical distance given that plugins may snap entities to terrain.
            return Math.Abs(a.y - b.y) < yTolerance
                && Math.Abs(a.x - b.x) < xZTolerance
                && Math.Abs(a.z - b.z) < xZTolerance;
        }

        private static bool HasCondition(ItemDefinition itemDefinition)
        {
            return itemDefinition.condition.enabled && itemDefinition.condition.max > 0;
        }

        private static void OpenVendingMachine(BasePlayer player, NPCVendingMachine vendingMachine)
        {
            if (vendingMachine.OccupiedCheck(player) && Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
            {
                vendingMachine.SendSellOrders(player);
                vendingMachine.PlayerOpenLoot(player, vendingMachine.customerPanel);
                Interface.CallHook(nameof(OnVendingShopOpened), vendingMachine, player);
            }
        }

        private static VendingOffer[] GetOffersFromVendingMachine(NPCVendingMachine vendingMachine)
        {
            var vanillaOffers = vendingMachine.sellOrders.sellOrders;
            var offers = new VendingOffer[vanillaOffers.Count];

            for (var i = 0; i < offers.Length; i++)
            {
                var manifestEntry = vendingMachine.vendingOrders.orders.ElementAtOrDefault(i);
                offers[i] = VendingOffer.FromVanillaSellOrder(vanillaOffers[i], manifestEntry);
            }

            return offers;
        }

        private static VendingOffer[] GetOffersFromContainer(CustomVendingSetup plugin, BasePlayer player, ItemContainer container)
        {
            var offers = new List<VendingOffer>();

            for (var columnIndex = 0; columnIndex < 2; columnIndex++)
            {
                for (var rowIndex = 0; rowIndex < MaxItemRows; rowIndex++)
                {
                    var sellItemSlot = rowIndex * ItemsPerRow + columnIndex * 3;

                    var sellItem = container.GetSlot(sellItemSlot);
                    var currencyItem = container.GetSlot(sellItemSlot + 1);
                    var settingsItem = container.GetSlot(sellItemSlot + 2);
                    if (sellItem == null || currencyItem == null)
                        continue;

                    offers.Add(VendingOffer.FromItems(plugin, player, sellItem, currencyItem, settingsItem));
                }
            }

            return offers.ToArray();
        }

        private static StorageContainer CreateContainerEntity(string prefabPath)
        {
            var entity = GameManager.server.CreateEntity(prefabPath);
            if (entity == null)
                return null;

            var container = entity as StorageContainer;
            if (container == null)
            {
                UnityEngine.Object.Destroy(entity);
                return null;
            }

            UnityEngine.Object.DestroyImmediate(container.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(container.GetComponent<GroundWatch>());

            container.limitNetworking = true;
            container.EnableSaving(false);
            container.Spawn();

            return container;
        }

        private static int OrderIndexToSlot(int orderIndex)
        {
            if (orderIndex < MaxItemRows)
                return orderIndex * ItemsPerRow;

            return (orderIndex % MaxItemRows) * ItemsPerRow + 3;
        }

        private static string CreateNoteContents(Dictionary<string, string> settingsMap)
        {
            var lines = new List<string>();
            foreach (var entry in settingsMap)
            {
                lines.Add($"{entry.Key}: {entry.Value}");
            }
            return string.Join("\n", lines);
        }

        private static StorageContainer CreateOrdersContainer(CustomVendingSetup plugin, BasePlayer player, VendingOffer[] vendingOffers, string shopName)
        {
            var containerEntity = CreateContainerEntity(StoragePrefab);

            var container = containerEntity.inventory;
            container.allowedContents = ItemContainer.ContentsType.Generic;
            container.capacity = ContainerCapacity;

            plugin._bagOfHoldingLimitManager.SetLimitProfile(container);

            for (var orderIndex = 0; orderIndex < vendingOffers.Length && orderIndex < 9; orderIndex++)
            {
                var offer = vendingOffers[orderIndex];
                var sellItem = offer.SellItem.Create();
                if (sellItem == null)
                    continue;

                var currencyItem = offer.CurrencyItem.Create();
                if (currencyItem == null)
                {
                    sellItem.Remove();
                    continue;
                }

                var destinationSlot = OrderIndexToSlot(orderIndex);

                if (!sellItem.MoveToContainer(container, destinationSlot))
                    sellItem.Remove();

                if (!currencyItem.MoveToContainer(container, destinationSlot + 1))
                    currencyItem.Remove();
            }

            // Add 7 note items, so the user doesn't have to make them.
            for (var orderIndex = 0; orderIndex < 7; orderIndex++)
            {
                var offer = vendingOffers.Length > orderIndex
                    ? vendingOffers[orderIndex]
                    : null;

                var settingsItem = ItemManager.Create(plugin._noteItemDefinition);
                if (settingsItem == null)
                    continue;

                var refillMaxLabel = plugin.GetMessage(player, Lang.SettingsRefillMax);
                var refillDelayLabel = plugin.GetMessage(player, Lang.SettingsRefillDelay);
                var refillAmountLabel = plugin.GetMessage(player, Lang.SettingsRefillAmount);

                var settingsMap = new CaseInsensitiveDictionary<string>
                {
                    [refillMaxLabel] = (offer?.RefillMax ?? VendingOffer.DefaultRefillMax).ToString(),
                    [refillDelayLabel] = (offer?.RefillDelay ?? VendingOffer.DefaultRefillDelay).ToString(),
                    [refillAmountLabel] = (offer?.RefillAmount ?? VendingOffer.DefaultRefillAmount).ToString(),
                };

                // Allow other plugins to parse the custom settings and display localized options.
                ExposedHooks.OnCustomVendingSetupOfferSettingsDisplay(
                    offer?.CustomSettings ?? new CaseInsensitiveDictionary<object>(), settingsMap);

                settingsItem.text = CreateNoteContents(settingsMap);

                var destinationSlot = OrderIndexToSlot(orderIndex);

                if (!settingsItem.MoveToContainer(container, destinationSlot + 2))
                    settingsItem.Remove();
            }

            var generalSettingsItem = ItemManager.Create(plugin._noteItemDefinition);
            if (generalSettingsItem != null)
            {
                generalSettingsItem.text = shopName;
                if (!generalSettingsItem.MoveToContainer(container, ShopNameNoteSlot))
                    generalSettingsItem.Remove();
            }

            return containerEntity;
        }

        private static void MaybeGiveWeaponAmmo(Item item, BasePlayer player)
        {
            var heldEntity = item.GetHeldEntity();
            if (heldEntity == null)
                return;

            if (heldEntity.creationFrame == Time.frameCount)
            {
                // The item was probably split off another item, so don't refund its ammo.
                return;
            }

            var baseProjectile = heldEntity as BaseProjectile;
            if ((object)baseProjectile != null)
            {
                var ammoType = baseProjectile.primaryMagazine?.ammoType;
                if (ammoType != null && baseProjectile.primaryMagazine.contents > 0)
                {
                    var ammoItem = ItemManager.Create(ammoType, baseProjectile.primaryMagazine.contents);
                    if (ammoItem != null)
                    {
                        player.GiveItem(ammoItem);
                    }
                }
                return;
            }

            var flameThrower = heldEntity as FlameThrower;
            if ((object)flameThrower != null)
            {
                if (flameThrower.fuelType != null && flameThrower.ammo > 0)
                {
                    var ammoItem = ItemManager.Create(flameThrower.fuelType, flameThrower.ammo);
                    if (ammoItem != null)
                    {
                        player.GiveItem(ammoItem);
                    }
                }
            }
        }

        private static void GiveSoldItem(Item item, BasePlayer player, ref TransactionContext transaction)
        {
            var vendingMachine = transaction.VendingMachine;
            var targetContainer = transaction.TargetContainer;

            // Unset the placeholder flag to allow Enchanted Items to transform the artifact.
            item.SetFlag(Item.Flag.Placeholder, false);

            if (targetContainer == null)
            {
                vendingMachine.GiveSoldItem(item, player);
            }
            else if (!item.MoveToContainer(targetContainer))
            {
                item.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
            }

            transaction.OnMarketplaceItemPurchase?.Invoke(player, item);
        }

        private static int GetHighestUsedSlot(ProtoBuf.ItemContainer containerData)
        {
            var highestUsedSlot = -1;

            for (var i = 0; i < containerData.contents.Count; i++)
            {
                var item = containerData.contents[i];
                if (item.slot > highestUsedSlot)
                {
                    highestUsedSlot = item.slot;
                }
            }

            return highestUsedSlot;
        }

        private static void AddItemForNetwork(ProtoBuf.ItemContainer containerData, int slot, int itemId, int amount, ItemId uid)
        {
            var itemData = Pool.Get<ProtoBuf.Item>();
            itemData.slot = slot;
            itemData.itemid = itemId;
            itemData.amount = amount;
            itemData.UID = uid;
            containerData.contents.Add(itemData);
        }

        private object CallPlugin<T1>(Plugin plugin, string methodName, T1 arg1)
        {
            _objectArray1[0] = ObjectCache.Get(arg1);
            return plugin.Call(methodName, _objectArray1);
        }

        private object CallPlugin<T1, T2>(Plugin plugin, string methodName, T1 arg1, T2 arg2)
        {
            _objectArray2[0] = ObjectCache.Get(arg1);
            _objectArray2[1] = ObjectCache.Get(arg2);
            return plugin.Call(methodName, _objectArray2);
        }

        private void ScheduleRemoveUI(NPCVendingMachine vendingMachine, BasePlayer player, VendingMachineComponent component)
        {
            component.Invoke(() =>
            {
                if (vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                if (IsLootingVendingMachine(player, vendingMachine) &&
                    !vendingMachine.IsInvoking(vendingMachine.CompletePendingOrder))
                    return;

                // Remove the UI because the player stopped viewing the vending machine or the transaction is pending.
                component.RemoveUI(player);
            }, 0);
        }

        private void AddCurrencyToContainerSnapshot(BasePlayer player, ProtoBuf.ItemContainer containerData)
        {
            if (containerData == null
                || containerData.slots < InventorySize
                || !_playersNeedingFakeInventory.Contains(player))
                return;

            var lootingContainer = player.inventory.loot.containers.FirstOrDefault();
            var vendingMachine = lootingContainer?.entityOwner as NPCVendingMachine;
            if ((object)vendingMachine == null)
                return;

            var profile = _componentTracker.GetComponent(vendingMachine)?.Profile;
            if (profile == null)
                return;

            var nextInvisibleSlot = Math.Max(containerData.slots, GetHighestUsedSlot(containerData) + 1);

            if (_config.Economics.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.Economics))
            {
                AddItemForNetwork(
                    containerData,
                    slot: nextInvisibleSlot,
                    itemId: _config.Economics.ItemDefinition.itemid,
                    amount: _paymentProviderResolver.EconomicsPaymentProvider.GetBalance(player),
                    uid: new ItemId(ulong.MaxValue - (ulong)nextInvisibleSlot)
                );
                nextInvisibleSlot++;
            }

            if (_config.ServerRewards.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.ServerRewards))
            {
                AddItemForNetwork(
                    containerData,
                    slot: nextInvisibleSlot,
                    itemId: _config.ServerRewards.ItemDefinition.itemid,
                    amount: _paymentProviderResolver.ServerRewardsPaymentProvider.GetBalance(player),
                    uid: new ItemId(ulong.MaxValue - (ulong)nextInvisibleSlot)
                );
                nextInvisibleSlot++;
            }

            containerData.slots = nextInvisibleSlot;
        }

        private Dictionary<string, object> SetupItemRetrieverQuery(ref ItemQuery itemQuery)
        {
            _itemRetrieverQuery.Clear();
            _itemRetrieverQuery["MinCondition"] = ObjectCache.Get(MinCurrencyCondition);
            _itemRetrieverQuery["RequireEmpty"] = True;

            if (itemQuery.BlueprintId != 0)
                _itemRetrieverQuery["BlueprintId"] = ObjectCache.Get(itemQuery.BlueprintId);

            if (itemQuery.DataInt != 0)
                _itemRetrieverQuery["DataInt"] = ObjectCache.Get(itemQuery.DataInt);

            if (itemQuery.ItemId != 0)
                _itemRetrieverQuery["ItemId"] = ObjectCache.Get(itemQuery.ItemId);

            if (itemQuery.SkinId.HasValue)
                _itemRetrieverQuery["SkinId"] = ObjectCache.Get(itemQuery.SkinId.Value);

            return _itemRetrieverQuery;
        }

        private int SumPlayerItems(BasePlayer player, ref ItemQuery itemQuery)
        {
            return _itemRetrieverAdapter?.Api?.SumPlayerItems.Invoke(player, SetupItemRetrieverQuery(ref itemQuery))
                   ?? ItemUtils.SumPlayerItems(player, ref itemQuery);
        }

        private int TakePlayerItems(BasePlayer player, ref ItemQuery itemQuery, int amount, List<Item> collect = null)
        {
            return _itemRetrieverAdapter?.Api?.TakePlayerItems.Invoke(player, SetupItemRetrieverQuery(ref itemQuery), amount, collect)
                   ?? ItemUtils.TakePlayerItems(player, ref itemQuery, amount, collect);
        }

        private bool PassesUICommandChecks(IPlayer player, string[] args, out NPCVendingMachine vendingMachine, out BaseVendingController controller)
        {
            vendingMachine = null;
            controller = null;

            if (player.IsServer || !player.HasPermission(PermissionUse))
                return false;

            ulong vendingMachineId;
            if (args.Length == 0 || !ulong.TryParse(args[0], out vendingMachineId))
                return false;

            vendingMachine = BaseNetworkable.serverEntities.Find(new NetworkableId(vendingMachineId)) as NPCVendingMachine;
            if (vendingMachine == null)
                return false;

            controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return false;

            return true;
        }

        private void OpenVendingMachineDelayed(BasePlayer player, NPCVendingMachine vendingMachine, float delay = 0.1f)
        {
            timer.Once(delay, () =>
            {
                if (player == null || vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                OpenVendingMachine(player, vendingMachine);
            });
        }

        private bool IsCustomized(NPCVendingMachine vendingMachine) =>
            _vendingMachineManager.GetController(vendingMachine)?.Profile?.Offers != null;

        #endregion

        #region UI

        private static class UIConstants
        {
            public const string EditButtonColor = "0.451 0.553 0.271 1";
            public const string EditButtonTextColor = "0.659 0.918 0.2 1";

            public const string ResetButtonColor = "0.9 0.5 0.2 1";
            public const string ResetButtonTextColor = "1 0.9 0.7 1";

            public const string SaveButtonColor = EditButtonColor;
            public const string SaveButtonTextColor = EditButtonTextColor;

            public const string CancelButtonColor = "0.4 0.4 0.4 1";
            public const string CancelButtonTextColor = "0.71 0.71 0.71 1";

            public const float PanelWidth = 380.5f;
            public const float HeaderHeight = 23;
            public const float ItemSpacing = 4;
            public const float ItemBoxSize = 58;

            public const int ButtonHorizontalSpacing = 6;

            public const int ButtonHeight = 32;
            public const int ButtonWidth = 80;

            public const string TexturedBackgroundSprite = "assets/content/ui/ui.background.tiletex.psd";
            public const string BroadcastIcon = "assets/icons/broadcast.png";
            public const string DroneIcon = "assets/icons/drone.png";
            public const string IconMaterial = "assets/icons/iconmaterial.mat";
            public const string GreyOutMaterial = "assets/icons/greyout.mat";

            public const string AnchorMin = "0.5 0";
            public const string AnchorMax = "0.5 0";
        }

        private class EditFormState
        {
            public static EditFormState FromVendingMachine(BaseVendingController vendingController, NPCVendingMachine vendingMachine)
            {
                return new EditFormState
                {
                    Broadcast = vendingController.Profile?.Broadcast ?? vendingMachine.IsBroadcasting(),
                    DroneAccessible = vendingController.Profile?.DroneAccessible ?? true,
                };
            }

            public bool Broadcast;
            public bool DroneAccessible;
        }

        private static class ContainerUIRenderer
        {
            public const string UIName = "CustomVendingSetup.ContainerUI";

            public const string TipUIName = "CustomVendingSetup.ContainerUI.Tip";
            public const string BroadcastUIName = "CustomVendingSetup.ContainerUI.Broadcast";
            public const string DroneUIName = "CustomVendingSetup.ContainerUI.Drone";

            public static string RenderContainerUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var offsetX = 192;
                var offsetY = 142.5f;

                var cuiElements = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX} {offsetY + MaxItemRows * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing)}",
                                OffsetMax = $"{offsetX} {offsetY + MaxItemRows * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing)}",
                            },
                        },
                        "Hud.Menu",
                        UIName
                    }
                };

                var saveButtonText = plugin.GetMessage(player, Lang.ButtonSave);
                var cancelButtonText = plugin.GetMessage(player, Lang.ButtonCancel);

                var vendingMachineId = vendingMachine.net.ID.Value;

                AddButton(
                    cuiElements,
                    vendingMachineId,
                    saveButtonText,
                    UICommands.Save,
                    UIConstants.PanelWidth - UIConstants.ButtonWidth - UIConstants.ButtonHorizontalSpacing,
                    UIConstants.SaveButtonColor,
                    UIConstants.SaveButtonTextColor
                );
                AddButton(
                    cuiElements,
                    vendingMachineId,
                    cancelButtonText,
                    UICommands.Cancel,
                    UIConstants.PanelWidth,
                    UIConstants.CancelButtonColor,
                    UIConstants.CancelButtonTextColor
                );
                AddBroadcastButton(cuiElements, vendingMachine, uiState);
                AddDroneButton(cuiElements, vendingMachine, uiState);

                var headerOffset = -6;

                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Name = TipUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = UIConstants.CancelButtonColor,
                            Sprite = UIConstants.TexturedBackgroundSprite,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = UIConstants.AnchorMin,
                            AnchorMax = UIConstants.AnchorMax,
                            OffsetMin = $"0 {headerOffset - UIConstants.HeaderHeight}",
                            OffsetMax = $"{UIConstants.PanelWidth} {headerOffset}",
                        }
                    },
                });

                var forSaleText = plugin.GetMessage(player, Lang.InfoForSale);
                var costText = plugin.GetMessage(player, Lang.InfoCost);
                var settingsText = plugin.GetMessage(player, Lang.InfoSettings);

                AddHeaderLabel(cuiElements, 0, forSaleText);
                AddHeaderLabel(cuiElements, 1, costText);
                AddHeaderLabel(cuiElements, 2, settingsText);
                AddHeaderLabel(cuiElements, 3, forSaleText);
                AddHeaderLabel(cuiElements, 4, costText);
                AddHeaderLabel(cuiElements, 5, settingsText);

                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddHeaderLabel(CuiElementContainer cuiElements, int index, string text)
            {
                var xMin = 6 + index * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing);
                var xMax = xMin + UIConstants.ItemBoxSize;

                cuiElements.Add(
                    new CuiLabel
                    {
                        Text =
                        {
                            Text = text,
                            Color = UIConstants.CancelButtonTextColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 13,
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.HeaderHeight}",
                        }
                    },
                    TipUIName
                );
            }

            private static void AddBroadcastButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var iconSize = UIConstants.ButtonHeight;

                var xMax = UIConstants.PanelWidth - 2 * (UIConstants.ButtonWidth + UIConstants.ButtonHorizontalSpacing);
                var xMin = xMax - iconSize;

                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Name = BroadcastUIName,
                    DestroyUi = BroadcastUIName,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0 0 0 0",
                            Command = $"customvendingsetup.ui {vendingMachine.net.ID} {UICommands.ToggleBroadcast}",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                });

                cuiElements.Add(new CuiElement
                {
                    Parent = BroadcastUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = uiState.Broadcast ? UIConstants.SaveButtonTextColor : UIConstants.CancelButtonTextColor,
                            Sprite = UIConstants.BroadcastIcon,
                            Material = UIConstants.IconMaterial,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "0 0",
                            OffsetMax = $"{iconSize} {iconSize}",
                        },
                    },
                });
            }

            private static void AddDroneButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var iconSize = UIConstants.ButtonHeight;

                var xMax = - UIConstants.ButtonHorizontalSpacing;
                var xMin = xMax - iconSize;

                var droneAccessible = uiState.Broadcast && uiState.DroneAccessible;

                cuiElements.Add(new CuiElement
                {
                    Parent = BroadcastUIName,
                    Name = DroneUIName,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0 0 0 0",
                            Command = $"customvendingsetup.ui {vendingMachine.net.ID} {UICommands.ToggleDroneAccessible}",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                });

                cuiElements.Add(new CuiElement
                {
                    Parent = DroneUIName,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = droneAccessible ? UIConstants.SaveButtonTextColor : UIConstants.CancelButtonTextColor,
                            Sprite = UIConstants.DroneIcon,
                            Material = UIConstants.GreyOutMaterial,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "0 0",
                            OffsetMax = $"{iconSize} {iconSize}",
                        },
                    },
                });
            }

            public static string RenderBroadcastUI(NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var cuiElements = new CuiElementContainer();
                AddBroadcastButton(cuiElements, vendingMachine, uiState);
                AddDroneButton(cuiElements, vendingMachine, uiState);
                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, float xMax, string color, string textColor)
            {
                var xMin = xMax - UIConstants.ButtonWidth;

                cuiElements.Add(
                    new CuiButton
                    {
                        Text =
                        {
                            Text = text,
                            Color = textColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 18,
                        },
                        Button =
                        {
                            Color = color,
                            FadeIn = 0.1f,
                            Command = $"customvendingsetup.ui {vendingMachineId} {subCommand}",
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                    UIName
                );
            }
        }

        private static class AdminUIRenderer
        {
            public const string UIName = "CustomVendingSetup.AdminUI";

            public static string RenderAdminUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, VendingProfile profile)
            {
                var numSellOrders = vendingMachine.sellOrders?.sellOrders.Count ?? 0;
                var offsetY = 137.5f + 74 * numSellOrders;
                var offsetX = 192;

                var cuiElements = new CuiElementContainer
                {
                    new CuiElement
                    {
                        Parent = "Overlay",
                        Name = UIName,
                        DestroyUi = UIName,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX} {offsetY}",
                                OffsetMax = $"{offsetX} {offsetY}",
                            }
                        }
                    },
                };

                var buttonIndex = 0;
                var vendingMachineId = vendingMachine.net.ID.Value;

                if (profile != null)
                {
                    var resetButtonText = plugin.GetMessage(player, Lang.ButtonReset);
                    AddVendingButton(cuiElements, vendingMachineId, resetButtonText, UICommands.Reset, buttonIndex, UIConstants.ResetButtonColor, UIConstants.ResetButtonTextColor);
                    buttonIndex++;
                }

                var editButtonText = plugin.GetMessage(player, Lang.ButtonEdit);
                AddVendingButton(cuiElements, vendingMachineId, editButtonText, UICommands.Edit, buttonIndex, UIConstants.SaveButtonColor, UIConstants.SaveButtonTextColor);

                return CuiHelper.ToJson(cuiElements);
            }

            private static float GetButtonOffset(int reverseButtonIndex)
            {
                return UIConstants.PanelWidth - reverseButtonIndex * (UIConstants.ButtonWidth + UIConstants.ButtonHorizontalSpacing);
            }

            private static void AddVendingButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, int reverseButtonIndex, string color, string textColor)
            {
                var xMax = GetButtonOffset(reverseButtonIndex);
                var xMin = xMax - UIConstants.ButtonWidth;

                cuiElements.Add(
                    new CuiButton
                    {
                        Text =
                        {
                            Text = text,
                            Color = textColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 18,
                        },
                        Button =
                        {
                            Color = color,
                            FadeIn = 0.1f,
                            Command = $"customvendingsetup.ui {vendingMachineId} {subCommand}",
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                    UIName
                );
            }
        }

        private static class ShopUIRenderer
        {
            public const string UIName = "CustomVendingSetup.ShopUI";

            private const float OffsetXItem = 210;
            private const float OffsetXCurrency = 352;
            private const float OverlaySize = 60;

            private const float IconSize = 50;
            private const float PaddingLeft = 5.5f;
            private const float PaddingBottom = 8;

            public static string RenderShopUI(VendingProfile vendingProfile)
            {
                var cuiElements = new CuiElementContainer
                {
                    new CuiElement
                    {
                        Parent = "Hud.Menu",
                        Name = UIName,
                        DestroyUi = UIName,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                            }
                        }
                    },
                };

                var skinsByItemShortName = new Dictionary<string, HashSet<ulong>>();
                var numValidOffers = 0;

                foreach (var offer in vendingProfile.Offers)
                {
                    if (!offer.IsValid)
                        continue;

                    numValidOffers++;

                    HashSet<ulong> skins;
                    if (!skinsByItemShortName.TryGetValue(offer.SellItem.ShortName, out skins))
                    {
                        skins = new HashSet<ulong>();
                        skinsByItemShortName[offer.SellItem.ShortName] = skins;
                    }

                    skins.Add(offer.SellItem.SkinId);
                }

                var offerIndex = 0;

                foreach (var offer in vendingProfile.Offers)
                {
                    if (!offer.IsValid)
                        continue;

                    if (skinsByItemShortName[offer.SellItem.ShortName].Count > 1)
                    {
                        AddItemOverlay(cuiElements, numValidOffers - offerIndex, offer, isCurrency: false);
                    }

                    if (offer.CurrencyItem.SkinId != 0)
                    {
                        AddItemOverlay(cuiElements, numValidOffers - offerIndex, offer, isCurrency: true);
                    }

                    offerIndex++;
                }

                if (cuiElements.Count == 1)
                    return string.Empty;

                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddItemOverlay(CuiElementContainer cuiElements, int indexFromBottom, VendingOffer offer, bool isCurrency = false)
            {
                var offsetX = isCurrency ? OffsetXCurrency : OffsetXItem;
                var offsetY = 41.5f + 74 * indexFromBottom;

                var vendingItem = isCurrency ? offer.CurrencyItem : offer.SellItem;

                // Background
                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "0.35 0.35 0.35 1",
                            Sprite = UIConstants.TexturedBackgroundSprite,
                            FadeIn = 0.1f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = UIConstants.AnchorMin,
                            AnchorMax = UIConstants.AnchorMax,
                            OffsetMin = $"{offsetX} {offsetY}",
                            OffsetMax = $"{offsetX + OverlaySize} {offsetY + OverlaySize}",
                        }
                    },
                });

                // Skin icon
                cuiElements.Add(new CuiElement
                {
                    Name = $"{UIName}.Offer.{indexFromBottom}.Currency",
                    Parent = UIName,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Sprite = "assets/content/textures/generic/fulltransparent.tga",
                            ItemId = vendingItem.ItemId,
                            SkinId = vendingItem.SkinId,
                            FadeIn = 0.1f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{offsetX + PaddingLeft} {offsetY + PaddingBottom}",
                            OffsetMax = $"{offsetX + PaddingLeft + IconSize} {offsetY + PaddingBottom + IconSize}"
                        },
                    }
                });

                if (vendingItem.Amount > 1)
                {
                    // Amount
                    cuiElements.Add(new CuiElement
                    {
                        Parent = UIName,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"x{vendingItem.Amount}",
                                Align = TextAnchor.LowerRight,
                                FontSize = 12,
                                Color = "0.65 0.65 0.65 1",
                                FadeIn = 0.1f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX + 4} {offsetY + 1f}",
                                OffsetMax = $"{offsetX - 3f + OverlaySize} {offsetY + OverlaySize}",
                            }
                        },
                    });
                }
            }
        }

        #endregion

        #region Utilities

        private static class StringUtils
        {
            public static bool Equals(string a, string b) =>
                string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;

            public static bool Contains(string haystack, string needle) =>
                haystack.Contains(needle, CompareOptions.IgnoreCase);
        }

        private static class ObjectCache
        {
            private static class StaticObjectCache<T>
            {
                private static readonly Dictionary<T, object> _cacheByValue = new Dictionary<T, object>();

                public static object Get(T value)
                {
                    object cachedObject;
                    if (!_cacheByValue.TryGetValue(value, out cachedObject))
                    {
                        cachedObject = value;
                        _cacheByValue[value] = cachedObject;
                    }
                    return cachedObject;
                }

                public static void Clear()
                {
                    _cacheByValue.Clear();
                }
            }

            public static object Get<T>(T value)
            {
                return StaticObjectCache<T>.Get(value);
            }

            public static void Clear<T>()
            {
                StaticObjectCache<T>.Clear();
            }
        }

        private interface IMonumentRelativePosition
        {
            string GetMonumentPrefabName();
            string GetMonumentAlias();
            Vector3 GetPosition();
            Vector3 GetLegacyPosition();
        }

        private static bool LocationsMatch(IMonumentRelativePosition a, IMonumentRelativePosition b)
        {
            var monumentsMatch = a.GetMonumentAlias() != null && a.GetMonumentAlias() == b.GetMonumentAlias()
                || a.GetMonumentPrefabName() == b.GetMonumentPrefabName();

            if (!monumentsMatch)
                return false;

            return AreVectorsClose(a.GetPosition(), b.GetPosition())
                || AreVectorsClose(a.GetLegacyPosition(), b.GetLegacyPosition());
        }

        private class MonumentRelativePosition : IMonumentRelativePosition
        {
            public static MonumentRelativePosition FromVendingMachine(MonumentFinderAdapter monumentFinderAdapter, NPCVendingMachine vendingMachine)
            {
                var monument = monumentFinderAdapter.GetMonumentAdapter(vendingMachine);
                if (monument == null)
                    return null;

                return new MonumentRelativePosition
                {
                    _monument = monument,
                    _position = monument.InverseTransformPoint(vendingMachine.transform.position),
                    _legacyPosition = vendingMachine.transform.InverseTransformPoint(monument.Position),
                };
            }

            private MonumentAdapter _monument;
            private Vector3 _position;
            private Vector3 _legacyPosition;

            // IMonumentRelativePosition members.
            public string GetMonumentPrefabName() => _monument.PrefabName;
            public string GetMonumentAlias() => _monument.Alias;
            public Vector3 GetPosition() => _position;
            public Vector3 GetLegacyPosition() => _legacyPosition;
        }

        #endregion

        #region Payment Providers

        private struct TransactionContext
        {
            public NPCVendingMachine VendingMachine;
            public VendingItem SellItem;
            public ItemContainer TargetContainer;
            public Action<BasePlayer, Item> OnMarketplaceItemPurchase;
        }

        private interface IPaymentProvider
        {
            int GetBalance(BasePlayer player);
            bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
            bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
        }

        private class ItemsPaymentProvider : IPaymentProvider
        {
            public VendingItem VendingItem;

            private CustomVendingSetup _plugin;

            public ItemsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public int GetBalance(BasePlayer player)
            {
                var itemQuery = ItemQuery.FromCurrencyItem(VendingItem);
                return _plugin.SumPlayerItems(player, ref itemQuery);
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var vendingMachine = transaction.VendingMachine;
                var sellItem = transaction.SellItem;

                var sellItemQuery = ItemQuery.FromSellItem(sellItem);
                var firstSellableItem = ItemUtils.FindFirstContainerItem(vendingMachine.inventory, ref sellItemQuery);
                var maxStackSize = _plugin._config.GetItemMaxStackSize(firstSellableItem);

                // Create new items and give them to the player.
                // This approach was chosen instead of transferring the items because in many cases new items would have to
                // be created anyway, since the vending machine maintains a single large stack of each item.
                while (amount > 0)
                {
                    var amountToGive = Math.Min(amount, maxStackSize);
                    var itemToGive = sellItem.Create(amountToGive);

                    amount -= amountToGive;

                    // The "CanPurchaseItem" hook may cause "CanVendingStockRefill" hook to be called.
                    var hookResult = ExposedHooks.CanPurchaseItem(player, itemToGive, transaction.OnMarketplaceItemPurchase, vendingMachine, transaction.TargetContainer);
                    if (hookResult is bool)
                    {
                        LogWarning($"A plugin returned {hookResult} in the CanPurchaseItem hook, which has been ignored.");
                    }

                    GiveSoldItem(itemToGive, player, ref transaction);
                }

                return true;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                if (amount <= 0)
                    return true;

                var itemQuery = ItemQuery.FromCurrencyItem(VendingItem);
                _plugin.TakePlayerItems(player, ref itemQuery, amount, collect);
                return true;
            }
        }

        private class EconomicsPaymentProvider : IPaymentProvider
        {
            private CustomVendingSetup _plugin;
            private Plugin _ownerPlugin => _plugin.Economics;

            public EconomicsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public bool IsAvailable => _ownerPlugin != null;

            public int GetBalance(BasePlayer player)
            {
                return Convert.ToInt32(_plugin.CallPlugin(_ownerPlugin, "Balance", player.userID));
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "Deposit", player.userID, Convert.ToDouble(amount));
                return result is bool && (bool)result;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "Withdraw", player.userID, Convert.ToDouble(amount));
                return result is bool && (bool)result;
            }
        }

        private class ServerRewardsPaymentProvider : IPaymentProvider
        {
            private CustomVendingSetup _plugin;
            private Plugin _ownerPlugin => _plugin.ServerRewards;

            public ServerRewardsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public bool IsAvailable => _ownerPlugin != null;

            public int GetBalance(BasePlayer player)
            {
                return Convert.ToInt32(_plugin.CallPlugin(_ownerPlugin, "CheckPoints", player.userID));
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "AddPoints", player.userID, amount);
                return result is bool && (bool)result;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "TakePoints", player.userID, amount);
                return result is bool && (bool)result;
            }
        }

        private class PaymentProviderResolver
        {
            public readonly EconomicsPaymentProvider EconomicsPaymentProvider;
            public readonly ServerRewardsPaymentProvider ServerRewardsPaymentProvider;

            private readonly CustomVendingSetup _plugin;
            private readonly ItemsPaymentProvider _itemsPaymentProvider;
            private Configuration _config => _plugin._config;

            public PaymentProviderResolver(CustomVendingSetup plugin)
            {
                _plugin = plugin;
                _itemsPaymentProvider = new ItemsPaymentProvider(plugin);
                EconomicsPaymentProvider = new EconomicsPaymentProvider(plugin);
                ServerRewardsPaymentProvider = new ServerRewardsPaymentProvider(plugin);
            }

            public IPaymentProvider Resolve(VendingItem vendingItem)
            {
                if (_config.Economics.MatchesItem(vendingItem) && EconomicsPaymentProvider.IsAvailable)
                    return EconomicsPaymentProvider;

                if (_config.ServerRewards.MatchesItem(vendingItem) && ServerRewardsPaymentProvider.IsAvailable)
                    return ServerRewardsPaymentProvider;

                _itemsPaymentProvider.VendingItem = vendingItem;
                return _itemsPaymentProvider;
            }
        }

        #endregion

        #region Item Query

        private struct ItemQuery
        {
            public static ItemQuery FromSellItem(VendingItem vendingItem)
            {
                return new ItemQuery
                {
                    BlueprintId = vendingItem.IsBlueprint ? vendingItem.ItemId : 0,
                    DataInt = vendingItem.DataInt,
                    DisplayName = vendingItem.DisplayName,
                    ItemId = vendingItem.IsBlueprint ? BlueprintItemId : vendingItem.ItemId,
                    SkinId = vendingItem.SkinId,
                };
            }

            public static ItemQuery FromCurrencyItem(VendingItem vendingItem)
            {
                var itemQuery = new ItemQuery
                {
                    BlueprintId = vendingItem.IsBlueprint ? vendingItem.ItemId : 0,
                    MinCondition = MinCurrencyCondition,
                    ItemId = vendingItem.IsBlueprint ? BlueprintItemId : vendingItem.ItemId,
                };

                if (vendingItem.SkinId != 0)
                {
                    itemQuery.SkinId = vendingItem.SkinId;
                }

                return itemQuery;
            }

            public int BlueprintId;
            public int DataInt;
            public string DisplayName;
            public Item.Flag Flags;
            public int ItemId;
            public float MinCondition;
            public bool RequireEmpty;
            public ulong? SkinId;

            public int GetUsableAmount(Item item)
            {
                if (ItemId != 0 && ItemId != item.info.itemid)
                    return 0;

                if (SkinId.HasValue && SkinId != item.skin)
                    return 0;

                if (BlueprintId != 0 && BlueprintId != item.blueprintTarget)
                    return 0;

                if (DataInt != 0 && DataInt != (item.instanceData?.dataInt ?? 0))
                    return 0;

                if (Flags != 0 && !item.flags.HasFlag(Flags))
                    return 0;

                if (MinCondition > 0 && item.hasCondition && (item.conditionNormalized < MinCondition || item.maxConditionNormalized < MinCondition))
                    return 0;

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.Equals(DisplayName, item.name))
                    return 0;

                return RequireEmpty && item.contents?.itemList?.Count > 0
                    ? Math.Max(0, item.amount - 1)
                    : item.amount;
            }
        }

        #endregion

        #region Item Utils

        private static class ItemUtils
        {
            public static Item FindFirstContainerItem(ItemContainer container, ref ItemQuery itemQuery)
            {
                foreach (var item in container.itemList)
                {
                    if (itemQuery.GetUsableAmount(item) > 0)
                        return item;
                }

                return null;
            }

            public static int SumContainerItems(ItemContainer container, ref ItemQuery itemQuery)
            {
                var sum = 0;

                foreach (var item in container.itemList)
                {
                    sum += itemQuery.GetUsableAmount(item);
                }

                return sum;
            }

            public static int SumPlayerItems(BasePlayer player, ref ItemQuery itemQuery)
            {
                return SumContainerItems(player.inventory.containerMain, ref itemQuery)
                    + SumContainerItems(player.inventory.containerBelt, ref itemQuery);
            }

            public static int TakeContainerItems(ItemContainer container, ref ItemQuery itemQuery, int totalAmountToTake, List<Item> collect = null)
            {
                var totalAmountTaken = 0;

                for (var i = container.itemList.Count - 1; i >= 0; i--)
                {
                    var amountToTake = totalAmountToTake - totalAmountTaken;
                    if (amountToTake <= 0)
                        break;

                    var item = container.itemList[i];
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        amountToTake = Math.Min(item.amount, amountToTake);

                        if (item.amount > amountToTake)
                        {
                            if (collect != null)
                            {
                                var splitItem = item.SplitItem(amountToTake);
                                var playerOwner = splitItem.GetOwnerPlayer();
                                if (playerOwner != null)
                                {
                                    splitItem.CollectedForCrafting(playerOwner);
                                }
                                collect.Add(splitItem);
                            }
                            else
                            {
                                item.amount -= amountToTake;
                                item.MarkDirty();
                            }
                        }
                        else
                        {
                            item.RemoveFromContainer();

                            if (collect != null)
                            {
                                collect.Add(item);
                            }
                            else
                            {
                                item.Remove();
                            }
                        }

                        totalAmountTaken += amountToTake;
                    }

                    if (totalAmountTaken >= totalAmountToTake)
                        return totalAmountTaken;
                }

                return totalAmountTaken;
            }

            public static int TakePlayerItems(BasePlayer player, ref ItemQuery itemQuery, int amountToTake, List<Item> collect = null)
            {
                var amountTaken = TakeContainerItems(player.inventory.containerMain, ref itemQuery, amountToTake, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                amountTaken += TakeContainerItems(player.inventory.containerBelt, ref itemQuery, amountToTake - amountTaken, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                amountTaken += TakeContainerItems(player.inventory.containerWear, ref itemQuery, amountToTake - amountTaken, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                return amountTaken;
            }
        }

        #endregion

        #region Dynamic Hook Subscriptions

        private class DynamicHookSubscriber<T>
        {
            private CustomVendingSetup _plugin;
            private HashSet<T> _list = new HashSet<T>();
            private string[] _hookNames;

            public DynamicHookSubscriber(CustomVendingSetup plugin, params string[] hookNames)
            {
                _plugin = plugin;
                _hookNames = hookNames;
            }

            public bool Contains(T item)
            {
                return _list.Contains(item);
            }

            public void Add(T item)
            {
                if (_list.Add(item) && _list.Count == 1)
                {
                    SubscribeAll();
                }
            }

            public void Remove(T item)
            {
                if (_list.Remove(item) && _list.Count == 0)
                {
                    UnsubscribeAll();
                }
            }

            public void SubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }
            }

            public void UnsubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }
            }
        }

        #endregion

        #region Data Provider

        private class DataProvider
        {
            public static DataProvider FromDictionary(Dictionary<string, object> spec)
            {
                var dataProvider = new DataProvider
                {
                    Spec = spec,
                };

                object getDataCallback, saveDataCallback;

                if (spec.TryGetValue("GetData", out getDataCallback))
                {
                    dataProvider.GetDataCallback = getDataCallback as CustomGetDataCallback;
                }

                if (spec.TryGetValue("SaveData", out saveDataCallback))
                {
                    dataProvider.SaveDataCallback = saveDataCallback as CustomSaveDataCallback;
                }

                if (dataProvider.GetDataCallback == null)
                {
                    LogError("Data provider missing GetData");
                    return null;
                }

                if (dataProvider.SaveDataCallback == null)
                {
                    LogError("Data provider missing SaveData");
                    return null;
                }

                return dataProvider;
            }

            public Dictionary<string, object> Spec { get; private set; }
            public CustomGetDataCallback GetDataCallback;
            public CustomSaveDataCallback SaveDataCallback;

            private VendingProfile _vendingProfile;
            private JObject _serializedData;

            public VendingProfile GetData(Configuration config)
            {
                if (_vendingProfile == null)
                {
                    _vendingProfile = GetDataCallback()?.ToObject<VendingProfile>();
                }

                if (_vendingProfile?.Offers == null)
                {
                    return null;
                }

                return _vendingProfile;
            }

            public void SaveData(VendingProfile vendingProfile)
            {
                _vendingProfile = vendingProfile;
                SaveDataCallback(vendingProfile != null ? JObject.FromObject(vendingProfile) : null);
            }
        }

        private class DataProviderRegistry
        {
            private Dictionary<Dictionary<string, object>, DataProvider> _dataProviderCache = new Dictionary<Dictionary<string, object>, DataProvider>();

            public DataProvider Register(Dictionary<string, object> dataProviderSpec)
            {
                DataProvider dataProvider;
                if (!_dataProviderCache.TryGetValue(dataProviderSpec, out dataProvider))
                {
                    dataProvider = DataProvider.FromDictionary(dataProviderSpec);
                    if (dataProvider == null)
                    {
                        return null;
                    }

                    _dataProviderCache[dataProviderSpec] = dataProvider;
                    return dataProvider;
                }

                return dataProvider;
            }

            public void Unregister(DataProvider dataProvider)
            {
                _dataProviderCache.Remove(dataProvider.Spec);
            }
        }

        #endregion

        #region Vending Machine Manager

        private class VendingMachineManager
        {
            private CustomVendingSetup _plugin;
            private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
            private DataProviderRegistry _dataProviderRegistry;

            private HashSet<BaseVendingController> _uniqueControllers = new HashSet<BaseVendingController>();

            // Controllers are also cached by vending machine, in case MonumentFinder is unloaded or becomes unstable.
            private Dictionary<NetworkableId, BaseVendingController> _controllersByVendingMachine = new Dictionary<NetworkableId, BaseVendingController>();

            private Dictionary<DataProvider, CustomVendingController> _controllersByDataProvider = new Dictionary<DataProvider, CustomVendingController>();

            public VendingMachineManager(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, DataProviderRegistry dataProviderRegistry)
            {
                _plugin = plugin;
                _componentFactory = componentFactory;
                _dataProviderRegistry = dataProviderRegistry;
            }

            public void HandleVendingMachineSpawned(NPCVendingMachine vendingMachine)
            {
                if (GetController(vendingMachine) != null)
                {
                    // A controller may already exist if this was called when handling a reload of MonumentFinder.
                    return;
                }

                BaseVendingController controller;

                var dataProviderSpec = ExposedHooks.OnCustomVendingSetupDataProvider(vendingMachine);
                if (dataProviderSpec != null)
                {
                    var dataProvider = _dataProviderRegistry.Register(dataProviderSpec);
                    if (dataProvider == null)
                    {
                        // Data provider is invalid.
                        return;
                    }

                    var hookResult = ExposedHooks.OnCustomVendingSetup(vendingMachine);
                    if (hookResult is bool && !(bool)hookResult)
                        return;

                    controller = EnsureCustomController(dataProvider);
                }
                else
                {
                    var location = MonumentRelativePosition.FromVendingMachine(_plugin._monumentFinderAdapter, vendingMachine);
                    if (location == null)
                    {
                        // Not at a monument.
                        return;
                    }

                    var hookResult = ExposedHooks.OnCustomVendingSetup(vendingMachine);
                    if (hookResult is bool && !(bool)hookResult)
                        return;

                    controller = EnsureMonumentController(location);
                }

                controller.AddVendingMachine(vendingMachine);
                _controllersByVendingMachine[vendingMachine.net.ID] = controller;
            }

            public void HandleVendingMachineKilled(NPCVendingMachine vendingMachine)
            {
                var controller = GetController(vendingMachine);
                if (controller == null)
                    return;

                controller.RemoveVendingMachine(vendingMachine);
                _controllersByVendingMachine.Remove(vendingMachine.net.ID);

                if (!controller.HasVendingMachines)
                {
                    _uniqueControllers.Remove(controller);

                    var customController = controller as CustomVendingController;
                    if (customController != null)
                    {
                        _controllersByDataProvider.Remove(customController.DataProvider);
                        _dataProviderRegistry.Unregister(customController.DataProvider);
                    }
                }
            }

            public BaseVendingController GetController(NPCVendingMachine vendingMachine)
            {
                BaseVendingController controller;
                return _controllersByVendingMachine.TryGetValue(vendingMachine.net.ID, out controller)
                    ? controller
                    : null;
            }

            public void SetupAll()
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    var vendingMachine = entity as NPCVendingMachine;
                    if (vendingMachine == null)
                        continue;

                    HandleVendingMachineSpawned(vendingMachine);
                }
            }

            public void ResetAll()
            {
                foreach (var controller in _controllersByVendingMachine.Values)
                {
                    controller.Destroy();
                }
            }

            private MonumentVendingController GetControllerByLocation(MonumentRelativePosition location)
            {
                foreach (var controller in _uniqueControllers)
                {
                    var locationBasedController = controller as MonumentVendingController;
                    if (locationBasedController == null)
                    {
                        continue;
                    }

                    if (LocationsMatch(locationBasedController.Location, location))
                        return locationBasedController;
                }

                return null;
            }

            private MonumentVendingController EnsureMonumentController(MonumentRelativePosition location)
            {
                var controller = GetControllerByLocation(location);
                if (controller != null)
                {
                    return controller;
                }

                controller = new MonumentVendingController(_plugin, _componentFactory, location);
                _uniqueControllers.Add(controller);

                return controller;
            }

            private CustomVendingController GetControllerByDataProvider(DataProvider dataProvider)
            {
                CustomVendingController controller;
                return _controllersByDataProvider.TryGetValue(dataProvider, out controller)
                    ? controller
                    : null;
            }

            private CustomVendingController EnsureCustomController(DataProvider dataProvider)
            {
                var controller = GetControllerByDataProvider(dataProvider);
                if (controller != null)
                {
                    return controller;
                }

                controller = new CustomVendingController(_plugin, _componentFactory, dataProvider);
                _controllersByDataProvider[dataProvider] = controller;
                _uniqueControllers.Add(controller);

                return controller;
            }
        }

        #endregion

        #region Edit Controller

        private class EditContainerComponent : FacepunchBehaviour
        {
            public static void AddToContainer(CustomVendingSetup plugin, StorageContainer container, EditController editController)
            {
                var component = container.GetOrAddComponent<EditContainerComponent>();
                component._plugin = plugin;
                component._editController = editController;
            }

            private CustomVendingSetup _plugin;
            private EditController _editController;

            private void PlayerStoppedLooting(BasePlayer player)
            {
                _plugin.TrackStart();
                _editController.HandlePlayerLootEnd(player);
                _plugin.TrackEnd();
            }
        }

        private class EditController
        {
            private static void OpenEditPanel(BasePlayer player, StorageContainer containerEntity)
            {
                var playerLoot = player.inventory.loot;
                playerLoot.Clear();
                playerLoot.PositionChecks = false;
                playerLoot.entitySource = containerEntity;
                playerLoot.itemSource = null;
                playerLoot.MarkDirty();
                playerLoot.AddContainer(containerEntity.inventory);
                playerLoot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", containerEntity.panelName);
            }

            public BasePlayer EditorPlayer { get; private set; }

            private CustomVendingSetup _plugin;
            private BaseVendingController _vendingController;
            private NPCVendingMachine _vendingMachine;
            private StorageContainer _container;
            private EditFormState _formState;

            public EditController(CustomVendingSetup plugin, BaseVendingController vendingController, NPCVendingMachine vendingMachine, BasePlayer editorPlayer)
            {
                _plugin = plugin;
                _vendingController = vendingController;
                _vendingMachine = vendingMachine;
                EditorPlayer = editorPlayer;

                var offers = vendingController.Profile?.Offers ?? GetOffersFromVendingMachine(vendingMachine);

                _container = CreateOrdersContainer(plugin, editorPlayer, offers, vendingMachine.shopName);
                _formState = EditFormState.FromVendingMachine(vendingController, vendingMachine);
                EditContainerComponent.AddToContainer(plugin, _container, this);
                _container.SendAsSnapshot(editorPlayer.Connection);
                OpenEditPanel(editorPlayer, _container);

                CuiHelper.AddUi(editorPlayer, ContainerUIRenderer.RenderContainerUI(plugin, editorPlayer, vendingMachine, _formState));
            }

            public void ToggleBroadcast()
            {
                _formState.Broadcast = !_formState.Broadcast;

                CuiHelper.AddUi(EditorPlayer, ContainerUIRenderer.RenderBroadcastUI(_vendingMachine, _formState));
            }

            public void ToggleDroneAccessible()
            {
                if (!_formState.Broadcast)
                {
                    _formState.DroneAccessible = true;
                    _formState.Broadcast = true;
                }
                else
                {
                    _formState.DroneAccessible = !_formState.DroneAccessible;
                }

                CuiHelper.AddUi(EditorPlayer, ContainerUIRenderer.RenderBroadcastUI(_vendingMachine, _formState));
            }

            public void ApplyStateTo(VendingProfile profile)
            {
                profile.Offers = GetOffersFromContainer(_plugin, EditorPlayer, _container.inventory);
                profile.Broadcast = _formState.Broadcast;
                profile.DroneAccessible = _formState.DroneAccessible;

                var updatedShopName = _container.inventory.GetSlot(ShopNameNoteSlot)?.text.Trim();
                if (!string.IsNullOrEmpty(updatedShopName))
                {
                    profile.ShopName = updatedShopName;
                }
            }

            public void HandlePlayerLootEnd(BasePlayer player)
            {
                Kill();
            }

            public void Kill()
            {
                DestroyUI();
                KillContainer();
                _vendingController.OnEditControllerKilled();
            }

            private void DestroyUI()
            {
                CuiHelper.DestroyUi(EditorPlayer, ContainerUIRenderer.UIName);
            }

            private void KillContainer()
            {
                if (_container == null || _container.IsDestroyed)
                {
                    return;
                }

                if (EditorPlayer != null && !EditorPlayer.IsDestroyed && EditorPlayer.IsConnected)
                {
                    _container.OnNetworkSubscribersLeave(new List<Network.Connection> { EditorPlayer.Connection });
                }

                _plugin._bagOfHoldingLimitManager.RemoveLimitProfile(_container.inventory);
                _container.Kill();
                _container = null;
            }
        }

        #endregion

        #region Vending Machine Controller

        private abstract class BaseVendingController
        {
            // While the Profile is null, the vending machines will be vanilla.
            public VendingProfile Profile { get; protected set; }

            // While the EditController is non-null, a player is editing the vending machine.
            public EditController EditController { get; protected set; }

            public bool HasVendingMachines => _vendingMachineList.Count > 0;

            protected CustomVendingSetup _plugin;

            // List of vending machines with a position matching this controller.
            private HashSet<NPCVendingMachine> _vendingMachineList = new HashSet<NPCVendingMachine>();

            private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;

            private string _cachedShopUI;

            protected BaseVendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory)
            {
                _plugin = plugin;
                _componentFactory = componentFactory;
            }

            protected abstract void SaveProfile(VendingProfile vendingProfile);

            protected abstract void DeleteProfile(VendingProfile vendingProfile);

            public void StartEditing(BasePlayer player, NPCVendingMachine vendingMachine)
            {
                if (EditController != null)
                    return;

                EditController = new EditController(_plugin, this, vendingMachine, player);
            }

            public void HandleReset()
            {
                DeleteProfile(Profile);
                Profile = null;
                SetupVendingMachines();
                EditController?.Kill();
                _plugin._inaccessibleVendingMachines.Remove(this);

                _cachedShopUI = null;
            }

            public void Destroy()
            {
                ResetVendingMachines();
                EditController?.Kill();
            }

            public void HandleSave(NPCVendingMachine vendingMachine)
            {
                CreateOrUpdateProfile(vendingMachine);

                EditController.ApplyStateTo(Profile);
                EditController.Kill();

                SaveProfile(Profile);
                SetupVendingMachines();

                _cachedShopUI = null;

                UpdateDroneAccessibility();
            }

            public void AddVendingMachine(NPCVendingMachine vendingMachine)
            {
                if (!_vendingMachineList.Add(vendingMachine))
                    return;

                var component = _componentFactory.GetOrAddTo(vendingMachine);
                component.SetController(this);
                component.SetProfile(Profile);
            }

            public void RemoveVendingMachine(NPCVendingMachine vendingMachine)
            {
                if (!_vendingMachineList.Remove(vendingMachine))
                    return;

                if (_vendingMachineList.Count == 0)
                {
                    EditController?.Kill();
                    _plugin._inaccessibleVendingMachines.Remove(this);
                }
            }

            public void OnEditControllerKilled()
            {
                EditController = null;
            }

            public string GetShopUI()
            {
                if (_cachedShopUI == null)
                {
                    _cachedShopUI = ShopUIRenderer.RenderShopUI(Profile);
                }

                return _cachedShopUI;
            }

            public void UpdateDroneAccessibility()
            {
                if (Profile == null)
                    return;

                if (Profile.Broadcast && !Profile.DroneAccessible)
                {
                    _plugin._inaccessibleVendingMachines.Add(this);
                }
                else
                {
                    _plugin._inaccessibleVendingMachines.Remove(this);
                }
            }

            protected virtual void CreateOrUpdateProfile(NPCVendingMachine vendingMachine)
            {
                if (Profile == null)
                {
                    Profile = VendingProfile.FromVendingMachine(vendingMachine);
                }
            }

            private void SetupVendingMachines()
            {
                foreach (var vendingMachine in _vendingMachineList)
                {
                    _componentFactory.GetOrAddTo(vendingMachine).SetProfile(Profile);
                }
            }

            private void ResetVendingMachines()
            {
                foreach (var vendingMachine in _vendingMachineList)
                {
                    VendingMachineComponent.RemoveFromVendingMachine(vendingMachine);
                }
            }
        }

        private class CustomVendingController : BaseVendingController
        {
            public DataProvider DataProvider { get; private set; }

            public CustomVendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, DataProvider dataProvider)
                : base(plugin, componentFactory)
            {
                DataProvider = dataProvider;
                Profile = dataProvider.GetData(plugin._config);
                UpdateDroneAccessibility();
            }

            protected override void SaveProfile(VendingProfile vendingProfile)
            {
                Profile = vendingProfile;
                DataProvider.SaveData(vendingProfile);
            }

            protected override void DeleteProfile(VendingProfile vendingProfile)
            {
                DataProvider.SaveData(null);
            }
        }

        private class MonumentVendingController : BaseVendingController
        {
            public MonumentRelativePosition Location { get; private set; }

            private SavedData _pluginData => _plugin._pluginData;

            public MonumentVendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, MonumentRelativePosition location)
                : base(plugin, componentFactory)
            {
                Location = location;
                Profile = _pluginData.FindProfile(location);
                UpdateDroneAccessibility();
            }

            protected override void SaveProfile(VendingProfile vendingProfile)
            {
                if (!_pluginData.VendingProfiles.Contains(vendingProfile))
                {
                    _pluginData.VendingProfiles.Add(vendingProfile);
                }

                _pluginData.Save();
            }

            protected override void DeleteProfile(VendingProfile vendingProfile)
            {
                _pluginData.VendingProfiles.Remove(vendingProfile);
                _pluginData.Save();
            }

            protected override void CreateOrUpdateProfile(NPCVendingMachine vendingMachine)
            {
                // Update the location, in case the vending machine has moved.
                Location = MonumentRelativePosition.FromVendingMachine(_plugin._monumentFinderAdapter, vendingMachine);

                if (Profile == null)
                {
                    Profile = VendingProfile.FromVendingMachine(vendingMachine, Location);
                }
                else
                {
                    Profile.Position = Location.GetPosition();
                }
            }
        }

        #endregion

        #region Component Tracker & Factory

        private class ComponentTracker<THost, TGuest>
            where THost : UnityEngine.Component
            where TGuest : UnityEngine.Component
        {
            private readonly Dictionary<THost, TGuest> _hostToGuest = new Dictionary<THost, TGuest>();

            public void RegisterComponent(THost host, TGuest guest)
            {
                _hostToGuest[host] = guest;
            }

            public TGuest GetComponent(THost host)
            {
                TGuest guest;
                return _hostToGuest.TryGetValue(host, out guest)
                    ? guest
                    : null;
            }

            public void UnregisterComponent(THost source)
            {
                _hostToGuest.Remove(source);
            }
        }

        private class TrackedComponent<THost, TGuest> : FacepunchBehaviour
            where THost : UnityEngine.Component
            where TGuest : TrackedComponent<THost, TGuest>
        {
            public CustomVendingSetup Plugin;
            public ComponentTracker<THost, TGuest> ComponentTracker;
            public THost Host;

            public virtual void OnCreated() {}

            protected virtual void OnDestroy()
            {
                ComponentTracker?.UnregisterComponent(Host);
            }
        }

        private class ComponentFactory<THost, TGuest>
            where THost : UnityEngine.Component
            where TGuest : TrackedComponent<THost, TGuest>
        {
            private CustomVendingSetup _plugin;
            private ComponentTracker<THost, TGuest> _componentTracker;

            public ComponentFactory(CustomVendingSetup plugin, ComponentTracker<THost, TGuest> componentTracker)
            {
                _plugin = plugin;
                _componentTracker = componentTracker;
            }

            public TGuest GetOrAddTo(THost host)
            {
                var guest = _componentTracker.GetComponent(host);
                if (guest == null)
                {
                    guest = host.gameObject.AddComponent<TGuest>();
                    guest.Plugin = _plugin;
                    guest.ComponentTracker = _componentTracker;
                    guest.Host = host;
                    guest.OnCreated();
                    _componentTracker.RegisterComponent(host, guest);
                }

                return guest;
            }
        }

        #endregion

        #region Vending Machine Component

        private class VendingMachineComponent : TrackedComponent<NPCVendingMachine, VendingMachineComponent>
        {
            public static void RemoveFromVendingMachine(NPCVendingMachine vendingMachine) =>
                DestroyImmediate(vendingMachine.GetComponent<VendingMachineComponent>());

            public VendingProfile Profile { get; private set; }

            private readonly List<BasePlayer> _adminUIViewers = new List<BasePlayer>();
            private readonly List<BasePlayer> _shopUIViewers = new List<BasePlayer>();
            private BaseVendingController _vendingController;
            private NPCVendingMachine _vendingMachine;
            private float[] _refillTimes;

            private string _originalShopName;
            private bool? _originalBroadcast;

            public override void OnCreated()
            {
                _vendingMachine = Host;
            }

            public bool HasUI(BasePlayer player)
            {
                return _adminUIViewers.Contains(player) || _shopUIViewers.Contains(player);
            }

            public void ShowAdminUI(BasePlayer player)
            {
                _adminUIViewers.Add(player);
                CuiHelper.AddUi(player, AdminUIRenderer.RenderAdminUI(Plugin, player, _vendingMachine, Profile));
            }

            public void ShowShopUI(BasePlayer player)
            {
                var json = _vendingController.GetShopUI();
                if (json == string.Empty)
                    return;

                _shopUIViewers.Add(player);
                CuiHelper.AddUi(player, json);
            }

            public void RemoveUI(BasePlayer player)
            {
                if (_adminUIViewers.Remove(player))
                {
                    DestroyAdminUI(player);
                }

                if (_shopUIViewers.Remove(player))
                {
                    DestroyShopUI(player);
                }

                // Make sure OnEntitySaved/OnInventoryNetworkUpdate are unsubscribed (when all players are removed).
                Plugin._playersNeedingFakeInventory.Remove(player);

                // Mark inventory dirty to send a network update, which will no longer be modified by hooks.
                player.inventory.containerMain.MarkDirty();
            }

            protected override void OnDestroy()
            {
                base.OnDestroy();

                DestroyUIs();

                if (Profile?.Offers != null && (_vendingMachine != null && !_vendingMachine.IsDestroyed))
                {
                    ResetToVanilla();
                }
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                Plugin.TrackStart();
                RemoveUI(player);
                Plugin.TrackEnd();
            }

            public void SetController(BaseVendingController vendingController)
            {
                _vendingController = vendingController;
            }

            public void SetProfile(VendingProfile profile)
            {
                if (Profile == null && profile != null)
                {
                    DisableVanillaBehavior();
                }
                else if (Profile != null && profile == null)
                {
                    ResetToVanilla();
                }

                Profile = profile;

                if (profile?.Offers == null)
                    return;

                _refillTimes = new float[Profile.Offers.Length];

                for (var i = _vendingMachine.inventory.itemList.Count - 1; i >= 0; i--)
                {
                    var item = _vendingMachine.inventory.itemList[i];
                    item.RemoveFromContainer();
                    item.Remove();
                }

                _vendingMachine.ClearSellOrders();

                if (_originalShopName == null)
                    _originalShopName = _vendingMachine.shopName;

                if (_originalBroadcast == null)
                    _originalBroadcast = _vendingMachine.IsBroadcasting();

                if (!string.IsNullOrEmpty(profile.ShopName))
                {
                    _vendingMachine.shopName = profile.ShopName;
                }

                if (_vendingMachine.IsBroadcasting() != profile.Broadcast)
                {
                    _vendingMachine.SetFlag(VendingMachineFlags.Broadcasting, profile.Broadcast);
                    _vendingMachine.UpdateMapMarker();
                }

                for (var i = 0; i < profile.Offers.Length && i < MaxVendingOffers; i++)
                {
                    var offer = profile.Offers[i];
                    if (!offer.IsValid)
                        continue;

                    var vendingOffer = new ProtoBuf.VendingMachine.SellOrder
                    {
                        ShouldPool = false,
                        itemToSellID = offer.SellItem.ItemId,
                        itemToSellAmount = offer.SellItem.Amount,
                        itemToSellIsBP = offer.SellItem.IsBlueprint,
                        currencyID = offer.CurrencyItem.ItemId,
                        currencyAmountPerItem = offer.CurrencyItem.Amount,
                        currencyIsBP = offer.CurrencyItem.IsBlueprint,
                    };

                    Interface.CallHook("OnAddVendingOffer", _vendingMachine, vendingOffer);
                    _vendingMachine.sellOrders.sellOrders.Add(vendingOffer);
                }

                CustomRefill(maxRefill: true);
            }

            private void ScheduleRefill(int offerIndex, VendingOffer offer, int min = 0)
            {
                _refillTimes[offerIndex] = Time.realtimeSinceStartup + Math.Max(offer.RefillDelay, min);
            }

            private void ScheduleDelayedRefill(int offerIndex, VendingOffer offer)
            {
                ScheduleRefill(offerIndex, offer, 300);
            }

            private void StopRefilling(int offerIndex)
            {
                _refillTimes[offerIndex] = float.MaxValue;
            }

            private void CustomRefill(bool maxRefill = false)
            {
                if (_vendingMachine.IsDestroyed)
                {
                    return;
                }

                for (var offerIndex = 0; offerIndex < Profile.Offers.Length; offerIndex++)
                {
                    if (_refillTimes[offerIndex] > Time.realtimeSinceStartup)
                    {
                        continue;
                    }

                    var offer = Profile.Offers[offerIndex];
                    if (!offer.IsValid || offer.SellItem.Amount <= 0 || offer.CurrencyItem.Amount <= 0)
                    {
                        StopRefilling(offerIndex);
                        continue;
                    }

                    var itemQuery = ItemQuery.FromSellItem(offer.SellItem);
                    var numPurchasesInStock = ItemUtils.SumContainerItems(_vendingMachine.inventory, ref itemQuery) / offer.SellItem.Amount;
                    var refillNumberOfPurchases = offer.RefillMax - numPurchasesInStock;

                    if (!maxRefill)
                    {
                        refillNumberOfPurchases = Mathf.Min(refillNumberOfPurchases, offer.RefillAmount);
                    }

                    if (refillNumberOfPurchases <= 0)
                    {
                        ScheduleRefill(offerIndex, offer);
                        continue;
                    }

                    int refillAmount;

                    try
                    {
                        refillAmount = checked(refillNumberOfPurchases * offer.SellItem.Amount);
                    }
                    catch (OverflowException ex)
                    {
                        LogError($"Cannot multiply {refillNumberOfPurchases} by {offer.SellItem.Amount} because the result is too large. You have misconfigured the plugin. It is not necessary to stock that much of any item. Please reduce Max Stock or Refill Amount for item {offer.SellItem.ShortName}.\n" + ex.ToString());

                        // Prevent further refills to avoid spamming the console since this case cannot be fixed without editing the vending machine.
                        StopRefilling(offerIndex);
                        continue;
                    }

                    // Always increase the quantity of an existing item if present, rather than creating a new item.
                    // This is done to prevent ridiculous configurations from potentially filling up the vending machine with specific items.
                    var existingItem = ItemUtils.FindFirstContainerItem(_vendingMachine.inventory, ref itemQuery);
                    if (existingItem != null)
                    {
                        try
                        {
                            existingItem.amount = checked(existingItem.amount + refillAmount);
                            existingItem.MarkDirty();
                            ScheduleRefill(offerIndex, offer);
                        }
                        catch (OverflowException ex)
                        {
                            LogError($"Cannot add {refillAmount} to {existingItem.amount} because the result is too large. You have misconfigured the plugin. It is not necessary to stock that much of any item. Please reduce Max Stock or Refill Amount for item {offer.SellItem.ShortName}.\n" + ex.ToString());

                            // Reduce refill rate to avoid spamming the console.
                            ScheduleDelayedRefill(offerIndex, offer);
                        }
                        continue;
                    }

                    var item = offer.SellItem.Create(refillAmount);
                    if (item == null)
                    {
                        LogError($"Unable to create item '{offer.SellItem.ShortName}'. Does that item exist? Was it removed from the game?");

                        // Prevent further refills to avoid spamming the console since this case cannot be fixed without editing the vending machine.
                        StopRefilling(offerIndex);
                        continue;
                    }

                    _vendingMachine.transactionActive = true;

                    if (item.MoveToContainer(_vendingMachine.inventory, allowStack: false))
                    {
                        ScheduleRefill(offerIndex, offer);
                    }
                    else
                    {
                        LogError($"Unable to add {item.amount} '{item.info.shortname}' because the vending machine container rejected it.");

                        item.Remove();

                        // Reduce refill rate to avoid spamming the console.
                        ScheduleDelayedRefill(offerIndex, offer);
                    }

                    _vendingMachine.transactionActive = false;
                }
            }

            private void TimedRefill() => CustomRefill();

            private void DestroyAdminUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, AdminUIRenderer.UIName);
            }

            private void DestroyShopUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, ShopUIRenderer.UIName);
            }

            private void DestroyUIs()
            {
                foreach (var player in _adminUIViewers)
                {
                    DestroyAdminUI(player);
                }

                foreach (var player in _shopUIViewers)
                {
                    DestroyShopUI(player);
                }
            }

            private void DisableVanillaBehavior()
            {
                _vendingMachine.CancelInvoke(_vendingMachine.InstallFromVendingOrders);
                _vendingMachine.CancelInvoke(_vendingMachine.Refill);

                InvokeRandomized(TimedRefill, 1, 1, 0.1f);
            }

            private void ResetToVanilla()
            {
                CancelInvoke(TimedRefill);

                if (_originalShopName != null)
                {
                    _vendingMachine.shopName = _originalShopName;
                }

                if (_originalBroadcast != null && _originalBroadcast != _vendingMachine.IsBroadcasting())
                {
                    _vendingMachine.SetFlag(VendingMachineFlags.Broadcasting, _originalBroadcast.Value);
                    _vendingMachine.UpdateMapMarker();
                }

                _vendingMachine.InstallFromVendingOrders();
                _vendingMachine.InvokeRandomized(_vendingMachine.Refill, 1f, 1f, 0.1f);
            }
        }

        #endregion

        #region Legacy Saved Data

        private class LegacyVendingItem
        {
            public string Shortname = string.Empty;
            public string DisplayName = string.Empty;
            public int Amount = 1;
            public ulong Skin = 0;
            public bool IsBlueprint = false;
        }

        private class LegacyVendingOffer
        {
            public LegacyVendingItem Currency = new LegacyVendingItem();
            public LegacyVendingItem SellItem = new LegacyVendingItem();
        }

        private class LegacyVendingProfile
        {
            public string Id;
            public List<LegacyVendingOffer> Offers = new List<LegacyVendingOffer>();

            public string Shortname;
            public Vector3 WorldPosition;
            public Vector3 RelativePosition;
            public string RelativeMonument;

            public bool DetectByShortname = false;
        }

        #endregion

        #region Saved Data

        private class CaseInsensitiveDictionary<TValue> : Dictionary<string, TValue>
        {
            public CaseInsensitiveDictionary() : base(StringComparer.OrdinalIgnoreCase) {}

            public CaseInsensitiveDictionary(Dictionary<string, TValue> dict) : base(dict, StringComparer.OrdinalIgnoreCase) {}
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingItem
        {
            public static VendingItem FromItem(Item item)
            {
                ItemDefinition ammoType;
                var ammoAmount = GetAmmoAmountAndType(item, out ammoType);

                return new VendingItem
                {
                    ShortName = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                    Amount = item.amount,
                    DisplayName = item.name,
                    SkinId = item.skin,
                    IsBlueprint = item.blueprintTarget != 0,
                    DataInt = item.instanceData?.dataInt ?? 0,
                    AmmoAmount = ammoAmount,
                    AmmoType = ammoType?.shortname,
                    Position = item.position,
                    Capacity = item.contents?.capacity ?? 0,
                    Contents = item.contents?.itemList?.Count > 0 ? SerializeContents(item.contents.itemList) : null,
                };
            }

            private static List<VendingItem> SerializeContents(List<Item> itemList)
            {
                var vendingItemList = new List<VendingItem>(itemList.Count);

                foreach (var item in itemList)
                {
                    vendingItemList.Add(FromItem(item));
                }

                return vendingItemList;
            }

            private static int GetAmmoAmountAndType(Item item, out ItemDefinition ammoType)
            {
                ammoType = null;

                var heldEntity = item.GetHeldEntity();
                if (heldEntity == null)
                    return -1;

                var baseProjectile = heldEntity as BaseProjectile;
                if ((object)baseProjectile != null)
                {
                    ammoType = baseProjectile.primaryMagazine?.ammoType;
                    return baseProjectile.primaryMagazine?.contents ?? 0;
                }

                var flameThrower = heldEntity as FlameThrower;
                if ((object)flameThrower != null)
                {
                    return flameThrower.ammo;
                }

                return -1;
            }

            [JsonProperty("ShortName")]
            public string ShortName;

            [JsonProperty("DisplayName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DisplayName;

            [JsonProperty("Amount")]
            public int Amount = 1;

            [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong SkinId;

            [JsonProperty("IsBlueprint", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool IsBlueprint;

            [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int DataInt;

            [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int Position;

            [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(-1)]
            public int AmmoAmount = -1;

            [JsonProperty("AmmoType", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string AmmoType;

            [JsonProperty("Capacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int Capacity;

            [JsonProperty("Contents", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<VendingItem> Contents;

            private ItemDefinition _itemDefinition;
            public ItemDefinition ItemDefinition
            {
                get
                {
                    if ((object)_itemDefinition == null && ShortName != null)
                    {
                        _itemDefinition = ItemManager.FindItemDefinition(ShortName);
                    }

                    return _itemDefinition;
                }
            }

            private ItemDefinition _ammoTypeDefinition;
            public ItemDefinition AmmoTypeDefinition
            {
                get
                {
                    if ((object)_ammoTypeDefinition == null && AmmoType != null)
                    {
                        _ammoTypeDefinition = ItemManager.FindItemDefinition(AmmoType);
                    }

                    return _ammoTypeDefinition;
                }
            }

            public bool IsValid => (object)ItemDefinition != null;
            public int ItemId => ItemDefinition.itemid;

            public Item Create(int amount)
            {
                Item item;
                if (IsBlueprint)
                {
                    item = ItemManager.CreateByItemID(BlueprintItemId, amount, SkinId);
                    item.blueprintTarget = ItemDefinition.itemid;
                }
                else
                {
                    item = ItemManager.Create(ItemDefinition, amount, SkinId);
                }

                if (item == null)
                    return null;

                item.name = DisplayName;
                item.position = Position;

                if (DataInt != 0)
                {
                    if (item.instanceData == null)
                    {
                        item.instanceData = new ProtoBuf.Item.InstanceData();
                        item.instanceData.ShouldPool = false;
                    }

                    item.instanceData.dataInt = DataInt;
                }

                if (Contents != null && Contents.Count > 0)
                {
                    if (item.contents == null)
                    {
                        item.contents = new ItemContainer();
                        item.contents.ServerInitialize(null, Math.Max(Capacity, Contents.Count));
                        item.contents.GiveUID();
                        item.contents.parent = item;
                    }
                    else
                    {
                        item.contents.capacity = Math.Max(item.contents.capacity, Capacity);
                    }

                    foreach (var childItemSpec in Contents)
                    {
                        var childItem = childItemSpec.Create(childItemSpec.Amount);
                        if (!childItem.MoveToContainer(item.contents, childItemSpec.Position))
                        {
                            childItem.Remove();
                        }
                    }
                }

                var heldEntity = item.GetHeldEntity();
                if (heldEntity != null)
                {
                    var baseProjectile = heldEntity as BaseProjectile;
                    if ((object)baseProjectile != null)
                    {
                        var magazine = baseProjectile.primaryMagazine;
                        if (magazine != null)
                        {
                            if (AmmoAmount >= 0)
                            {
                                magazine.contents = AmmoAmount;
                            }

                            if (AmmoType != null)
                            {
                                magazine.ammoType = AmmoTypeDefinition;
                            }
                        }
                    }

                    var flameThrower = heldEntity as FlameThrower;
                    if ((object)flameThrower != null)
                    {
                        flameThrower.ammo = AmmoAmount;
                    }
                }

                // Set the placeholder flag so that Enchanted Items doesn't transform the artifact into an enchanted item yet.
                item.SetFlag(Item.Flag.Placeholder, true);

                return item;
            }

            public Item Create() => Create(Amount);

            public VendingItem Copy()
            {
                return new VendingItem
                {
                    ShortName = ShortName,
                    DisplayName = DisplayName,
                    Amount = Amount,
                    SkinId = SkinId,
                    IsBlueprint = IsBlueprint,
                    DataInt = DataInt,
                    Position = Position,
                    AmmoAmount = AmmoAmount,
                    AmmoType = AmmoType,
                    Capacity = Capacity,
                    Contents = Contents,
                };
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingOffer
        {
            public const int DefaultRefillMax = 10;
            public const int DefaultRefillDelay = 10;
            public const int DefaultRefillAmount = 1;

            public static VendingOffer FromVanillaSellOrder(SellOrder sellOrder, NPCVendingOrder.Entry manifestEntry)
            {
                return new VendingOffer
                {
                    SellItem = new VendingItem
                    {
                        ShortName = ItemManager.FindItemDefinition(sellOrder.itemToSellID)?.shortname,
                        Amount = sellOrder.itemToSellAmount,
                        IsBlueprint = sellOrder.itemToSellIsBP,
                    },
                    CurrencyItem = new VendingItem
                    {
                        ShortName = ItemManager.FindItemDefinition(sellOrder.currencyID)?.shortname,
                        Amount = sellOrder.currencyAmountPerItem,
                        IsBlueprint = sellOrder.currencyIsBP,
                    },
                    RefillDelay = manifestEntry != null ? (int)manifestEntry.refillDelay : DefaultRefillDelay,
                };
            }

            public static VendingOffer FromItems(CustomVendingSetup plugin, BasePlayer player, Item sellItem, Item currencyItem, Item settingsItem)
            {
                var offer = new VendingOffer
                {
                    SellItem = VendingItem.FromItem(sellItem),
                    CurrencyItem = VendingItem.FromItem(currencyItem),
                };

                offer.SellItem.Position = 0;
                offer.CurrencyItem.Position = 0;

                if (settingsItem != null)
                {
                    var refillMaxLabel = plugin.GetMessage(player, Lang.SettingsRefillMax);
                    var refillDelayLabel = plugin.GetMessage(player, Lang.SettingsRefillDelay);
                    var refillAmountLabel = plugin.GetMessage(player, Lang.SettingsRefillAmount);

                    var localizedSettings = ParseSettingsItem(settingsItem);

                    int refillMax;
                    if (TryParseIntKey(localizedSettings, refillMaxLabel, out refillMax))
                        offer.RefillMax = refillMax;

                    int refillDelay;
                    if (TryParseIntKey(localizedSettings, refillDelayLabel, out refillDelay))
                        offer.RefillDelay = refillDelay;

                    int refillAmount;
                    if (TryParseIntKey(localizedSettings, refillAmountLabel, out refillAmount))
                        offer.RefillAmount = refillAmount;

                    // Allow other plugins to parse the settings and populate custom settings.
                    // Other plugins determine data file keys, as well as localized option names.
                    var customSettings = new CaseInsensitiveDictionary<object>();
                    ExposedHooks.OnCustomVendingSetupOfferSettingsParse(localizedSettings, customSettings);
                    if (customSettings.Count > 0)
                    {
                        offer.CustomSettings = customSettings;
                    }
                }

                return offer;
            }

            private static CaseInsensitiveDictionary<string> ParseSettingsItem(Item settingsItem)
            {
                var dict = new CaseInsensitiveDictionary<string>();
                if (string.IsNullOrEmpty(settingsItem.text))
                    return dict;

                foreach (var line in settingsItem.text.Split('\n'))
                {
                    var parts = line.Split(':');
                    if (parts.Length < 2)
                        continue;

                    dict[parts[0].Trim()] = parts[1].Trim();
                }

                return dict;
            }

            private static bool TryParseIntKey(Dictionary<string, string> dict, string key, out int result)
            {
                result = 0;
                string stringValue;
                return dict.TryGetValue(key, out stringValue)
                    && int.TryParse(stringValue, out result);
            }

            [JsonProperty("SellItem")]
            public VendingItem SellItem;

            [JsonProperty("CurrencyItem")]
            public VendingItem CurrencyItem;

            [JsonProperty("RefillMax", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillMax)]
            public int RefillMax = DefaultRefillMax;

            [JsonProperty("RefillDelay", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillDelay)]
            public int RefillDelay = DefaultRefillDelay;

            [JsonProperty("RefillAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillAmount)]
            public int RefillAmount = DefaultRefillAmount;

            [JsonProperty("CustomSettings", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public CaseInsensitiveDictionary<object> CustomSettings;

            public bool IsValid => SellItem.IsValid && CurrencyItem.IsValid;

            public VendingOffer Copy()
            {
                return new VendingOffer
                {
                    SellItem = SellItem.Copy(),
                    CurrencyItem = CurrencyItem.Copy(),
                    RefillMax = RefillMax,
                    RefillDelay = RefillDelay,
                    RefillAmount = RefillAmount,
                    CustomSettings = CustomSettings != null
                        ? new CaseInsensitiveDictionary<object>(CustomSettings)
                        : null,
                };
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingProfile : IMonumentRelativePosition
        {
            public static VendingProfile FromVendingMachine(NPCVendingMachine vendingMachine, MonumentRelativePosition location = null)
            {
                return new VendingProfile
                {
                    ShopName = vendingMachine.shopName,
                    Broadcast = vendingMachine.IsBroadcasting(),
                    Monument = location?.GetMonumentPrefabName(),
                    MonumentAlias = location?.GetMonumentAlias(),
                    Position = location?.GetPosition() ?? Vector3.zero,
                };
            }

            [JsonProperty("ShopName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string ShopName;

            [JsonProperty("Broadcast", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            public bool Broadcast = true;

            [JsonProperty("DroneAccessible", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            public bool DroneAccessible = true;

            [JsonProperty("Monument", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Monument;

            [JsonProperty("MonumentAlias", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string MonumentAlias;

            [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Vector3 Position;

            [JsonProperty("LegacyPosition", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Vector3 LegacyPosition;

            [JsonProperty("Offers")]
            public VendingOffer[] Offers;

            public VendingOffer GetOfferForSellOrderIndex(int index)
            {
                var sellOrderIndex = 0;

                for (var offerIndex = 0; offerIndex < Offers.Length; offerIndex++)
                {
                    var offer = Offers[offerIndex];
                    if (!offer.IsValid)
                        continue;

                    if (sellOrderIndex == index)
                        return offer;

                    sellOrderIndex++;
                }

                return null;
            }

            public bool HasPaymentProviderCurrency(PaymentProviderConfig paymentProviderConfig)
            {
                foreach (var offer in Offers)
                {
                    if (paymentProviderConfig.MatchesItem(offer.CurrencyItem))
                        return true;
                }

                return false;
            }

            // IMonumentRelativePosition members.
            public string GetMonumentPrefabName() => Monument;
            public string GetMonumentAlias() => MonumentAlias;
            public Vector3 GetPosition() => Position;
            public Vector3 GetLegacyPosition() => LegacyPosition;

            [OnDeserialized]
            private void OnDeserialized(StreamingContext context)
            {
                UpdateOldSaddleOffers();
            }

            private void UpdateOldSaddleOffers()
            {
                if (Offers == null)
                    return;

                VendingOffer singleSaddleOffer = null;
                var singleSaddleIndex = -1;

                for (var i = 0; i < Offers.Length; i++)
                {
                    var offer = Offers[i];
                    if (offer.SellItem.ShortName == "horse.saddle")
                    {
                        // Copy serialized fields, and change the short name. This will reset the cached ItemDefinition.
                        offer.SellItem = offer.SellItem.Copy();
                        offer.SellItem.ShortName = "horse.saddle.single";
                        singleSaddleOffer = offer;
                        singleSaddleIndex = i;
                        break;
                    }
                }

                if (singleSaddleOffer != null && singleSaddleIndex >= 0 && Offers.Length < MaxVendingOffers)
                {
                    var doubleSaddleOffer = singleSaddleOffer.Copy();
                    doubleSaddleOffer.SellItem.ShortName = "horse.saddle.double";
                    doubleSaddleOffer.CurrencyItem.Amount = Mathf.FloorToInt(doubleSaddleOffer.CurrencyItem.Amount * 1.2f);

                    var newOfferList = new List<VendingOffer>(Offers);
                    newOfferList.Insert(singleSaddleIndex + 1, doubleSaddleOffer);
                    Offers = newOfferList.ToArray();
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SavedData
        {
            // Legacy data for v1.
            [JsonProperty("Vendings", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<LegacyVendingProfile> Vendings;

            [JsonProperty("VendingProfiles")]
            public List<VendingProfile> VendingProfiles = new List<VendingProfile>();

            public static SavedData Load()
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<SavedData>(nameof(CustomVendingSetup)) ?? new SavedData();

                var dataMigrated = false;

                if (data.Vendings != null)
                {
                    foreach (var legacyProfile in data.Vendings)
                    {
                        var profile = new VendingProfile
                        {
                            Monument = legacyProfile.RelativeMonument,
                            LegacyPosition = legacyProfile.RelativePosition,
                            Offers = new VendingOffer[legacyProfile.Offers.Count],
                        };

                        for (var i = 0; i < legacyProfile.Offers.Count; i++)
                        {
                            var legacyOffer = legacyProfile.Offers[i];

                            profile.Offers[i] = new VendingOffer
                            {
                                SellItem = new VendingItem
                                {
                                    ShortName = legacyOffer.SellItem.Shortname,
                                    DisplayName = !string.IsNullOrEmpty(legacyOffer.SellItem.DisplayName) ? legacyOffer.SellItem.DisplayName : null,
                                    Amount = legacyOffer.SellItem.Amount,
                                    SkinId = legacyOffer.SellItem.Skin,
                                    IsBlueprint = legacyOffer.SellItem.IsBlueprint,
                                },
                                CurrencyItem = new VendingItem
                                {
                                    ShortName = legacyOffer.Currency.Shortname,
                                    DisplayName = !string.IsNullOrEmpty(legacyOffer.Currency.DisplayName) ? legacyOffer.Currency.DisplayName : null,
                                    Amount = legacyOffer.Currency.Amount,
                                    SkinId = legacyOffer.Currency.Skin,
                                    IsBlueprint = legacyOffer.Currency.IsBlueprint,
                                },
                            };
                        }

                        data.VendingProfiles.Add(profile);
                    }

                    dataMigrated = data.Vendings.Count > 0;
                    data.Vendings = null;
                    data.Save();
                    LogWarning($"Migrated data file to new format.");
                }

                return data;
            }

            public void Save() =>
                Interface.Oxide.DataFileSystem.WriteObject(nameof(CustomVendingSetup), this);

            public VendingProfile FindProfile(IMonumentRelativePosition location)
            {
                foreach (var profile in VendingProfiles)
                {
                    if (LocationsMatch(profile, location))
                    {
                        if (profile.LegacyPosition != Vector3.zero)
                        {
                            // Fix profile positioning.
                            profile.Position = location.GetPosition();
                            profile.LegacyPosition = Vector3.zero;
                        }
                        return profile;
                    }
                }

                return null;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class ShopUISettings
        {
            [JsonProperty("Enable skin overlays")]
            public bool EnableSkinOverlays = true;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PaymentProviderConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Item short name")]
            public string ItemShortName;

            [JsonProperty("Item skin ID")]
            public ulong ItemSkinId;

            public ItemDefinition ItemDefinition { get; private set; }

            public bool EnabledAndValid => Enabled && (object)ItemDefinition != null;

            public void Init()
            {
                if (string.IsNullOrWhiteSpace(ItemShortName))
                    return;

                ItemDefinition = ItemManager.FindItemDefinition(ItemShortName);
                if (ItemDefinition == null)
                {
                    LogError($"Invalid item short name in config: {ItemShortName}");
                }
            }

            public bool MatchesItem(VendingItem vendingItem)
            {
                return Enabled && vendingItem.ItemDefinition == ItemDefinition && vendingItem.SkinId == ItemSkinId;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("Shop UI settings")]
            public ShopUISettings ShopUISettings = new ShopUISettings();

            [JsonProperty("Economics integration")]
            public PaymentProviderConfig Economics = new PaymentProviderConfig();

            [JsonProperty("Server Rewards integration")]
            public PaymentProviderConfig ServerRewards = new PaymentProviderConfig();

            [JsonProperty("Override item max stack sizes (shortname: amount)")]
            public Dictionary<string, int> ItemStackSizeOverrides = new Dictionary<string, int>();

            public void Init()
            {
                Economics.Init();
                ServerRewards.Init();

                foreach (var entry in ItemStackSizeOverrides)
                {
                    if (ItemManager.FindItemDefinition(entry.Key) == null)
                    {
                        LogError($"Invalid item short name in config: {entry.Key}");
                    }
                }
            }

            public int GetItemMaxStackSize(Item item)
            {
                var maxStackSize = item.MaxStackable();

                int overrideMaxStackSize;
                if (ItemStackSizeOverrides.TryGetValue(item.info.shortname, out overrideMaxStackSize))
                {
                    maxStackSize = Math.Max(maxStackSize, overrideMaxStackSize);
                }

                return Math.Max(1, maxStackSize);
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
            GetMessage(player.UserIDString, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player, messageName), args));

        private static class Lang
        {
            public const string ButtonEdit = "Button.Edit";
            public const string ButtonReset = "Button.Reset";
            public const string InfoForSale = "Info.ForSale";
            public const string ButtonSave = "Button.Save";
            public const string ButtonCancel = "Button.Cancel";
            public const string InfoCost = "Info.Cost";
            public const string InfoSettings = "Info.Settings";
            public const string SettingsRefillMax = "Settings.RefillMax";
            public const string SettingsRefillDelay = "Settings.RefillDelay";
            public const string SettingsRefillAmount = "Settings.RefillAmount";
            public const string ErrorCurrentlyBeingEdited = "Error.CurrentlyBeingEdited";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ButtonSave] = "SAVE",
                [Lang.ButtonCancel] = "CANCEL",
                [Lang.ButtonEdit] = "EDIT",
                [Lang.ButtonReset] = "RESET",
                [Lang.InfoForSale] = "FOR SALE",
                [Lang.InfoCost] = "COST",
                [Lang.InfoSettings] = "SETTINGS",
                [Lang.SettingsRefillMax] = "Max Stock",
                [Lang.SettingsRefillDelay] = "Seconds Between Refills",
                [Lang.SettingsRefillAmount] = "Refill Amount",
                [Lang.ErrorCurrentlyBeingEdited] = "That vending machine is currently being edited by {0}.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: CustomVendingSetup.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Kitss.cs ---
// --- Original Local Path: Kitss.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using JetBrains.Annotations;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust.Workshop;
using Steamworks.ServerList;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Kits", "XAVIER", "1.0.5")]
    public class Kitss : RustPlugin
    {


        #region Class && Data

        bool HasPermission(string id, string perm) => permission.UserHasPermission(id, perm);
        const string permAllowed = "KITS.allowedCREATE";

        public class Kit
        {
            public string Name;
            public string DisplayName;
            public string DisplayNamePermission;
            public string CustomImage;
            public double Cooldown;
            public bool Hide;
            public string Permission;
            public List<KitItem> Items;
            public int UniversalNumber;
        }

        public class KitItem
        {
            public string ShortName;
            public int Amount;
            public int Blueprint;
            public ulong SkinID;
            public string Container;
            public float Condition;
            public Weapon Weapon;
            public List<ItemContent> Content;
        }

        public class Weapon
        {
            public string ammoType;
            public int ammoAmount;
        }

        public class ItemContent
        {
            public string ShortName;
            public float Condition;
            public int Amount;
        }

        public class KitsCooldown
        {
            public int Number;
            public double CoolDown;
        }


        public class CategoryKit
        {
            [JsonProperty("Название категории")] public string DisplayName;

            [JsonProperty("Картинка")] public string Image;

            [JsonProperty("Лист с китами")] public List<Kit> KitList = new List<Kit>();
        }


        public List<CategoryKit> KitLists = new List<CategoryKit>();

        public Dictionary<ulong, List<KitsCooldown>> CooldownData = new Dictionary<ulong, List<KitsCooldown>>();
        public List<ulong> OPENGUI = new List<ulong>();

        #endregion

        public string Layer = "UI_KitsLayer";
        [PluginReference] private Plugin ImageLibrary;

        public Dictionary<string, string> ImageDictionary = new Dictionary<string, string>()
        {
            ["osnova_kits"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177958084249915505/gfgh.png?ex=657465f4&is=6561f0f4&hm=b77ffb6f7046e53529161ab4daab5f49c3b2d140bb4a098b22547de2db46531e&",
            ["close_kits"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177961537051299851/213454.png?ex=6574692b&is=6561f42b&hm=e9cb740b308b225fd61a6ca6e76b03a8f82aaeca6a8412cf3f8450fe592acf0a&",
            ["kitgive"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1178287920503853088/dfgs.png?ex=65759923&is=65632423&hm=6f54d772e9d3fdd4f9138647b0f0a033637f4d5f6a99e2a952d765ec9422a7e6&",
            ["perexodyes"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177966206003716226/497f179f53bee2b2.png?ex=65746d85&is=6561f885&hm=908d1ebcbc8b81dc695496ef5e2d45d940699929baf40e9d963bd2744db6ead7&",
            ["perexodno"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177966206003716226/497f179f53bee2b2.png?ex=65746d85&is=6561f885&hm=908d1ebcbc8b81dc695496ef5e2d45d940699929baf40e9d963bd2744db6ead7&",
            ["namekits"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177983357175480390/xcgdfg.png?ex=65747d7e&is=6562087e&hm=8bc0f1077d5d31fc961949618df2a75c81c27ffbb5e05c713dbe9b62cff2e4e2&",
            ["kitcooldown"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177984301137137804/0e9da6565e49afe8.png?ex=65747e5f&is=6562095f&hm=49d21c69d434f8ab8249c44b58519448cc31428aaa7f64eeda9f574110d860fa&",
            ["kitgivebutton"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177984182882930838/fcc106dabae3e41a.png?ex=65747e43&is=65620943&hm=1ae2e98c1078721e8b7f668f2fd43373113ad17816135517998eb475a4fbf04f&",
            ["back_kits"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177981376402833408/103a61caa3610102.png?ex=65747ba5&is=656206a5&hm=d4266620592fb6f8141d3b6f9b528ff964b4e0dad6d9f4ad09fe2e1b62f11019&",
            ["nedostupno"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177985346076684460/Frame_14.png?ex=65747f58&is=65620a58&hm=91d4ff1d5dde4a9b08cc231b084fa9debc6f04416a290b65b9167085c71247ba&",
            ["netmesta"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1178287930620514374/sdgf.png?ex=65759926&is=65632426&hm=ba9a2843ecb00bee50416cc8d785d442c06eaeaa875cb2155fda92e62f676ac6&",
            ["prosmotr"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177986745468452974/ghdfgh.png?ex=657480a6&is=65620ba6&hm=fc95f3b1b15c6132098d86dc3a4c3b2d1d72cdbd7f4beb051b8669f6ceea7c45&",
            ["line"] =
                "https://cdn.discordapp.com/attachments/1061898344269627392/1172128567711252490/Rectangle_217.png",
        };

        void Init()
        {
            permission.RegisterPermission(permAllowed, this);
        }



        void OnServerInitialized()
        {
            try
            {
                KitLists = Interface.GetMod().DataFileSystem.ReadObject<List<CategoryKit>>("HKits/KitList");
                CooldownData = Interface.GetMod().DataFileSystem
                    .ReadObject<Dictionary<ulong, List<KitsCooldown>>>("HKits/CooldownPlayer");
            }
            catch
            {
                CooldownData = new Dictionary<ulong, List<KitsCooldown>>();
                KitLists = new List<CategoryKit>();
            }



            if (ImageLibrary == null || !ImageLibrary.IsLoaded)
            {
                PrintError("IMAGE LIBRARY IS NOT INSTALLED!");
            }
            else
            {
                var imagesList = new Dictionary<string, string>();


                KitLists.ForEach(kit =>
                {
                    if (!ImageLibrary.Call<bool>("HasImage", kit.Image))
                    {
                        if (!string.IsNullOrEmpty(kit.Image) && !imagesList.ContainsKey(kit.Image))
                        {
                            imagesList.Add(kit.Image, kit.Image);
                        }
                    }

                    kit.KitList.ForEach(img =>
                    {
                        if (!permission.PermissionExists(img.Permission, this))
                        {
                            permission.RegisterPermission(img.Permission, this);
                        }

                        if (!ImageLibrary.Call<bool>("HasImage", img.CustomImage) &&
                            !string.IsNullOrEmpty(img.CustomImage) && !imagesList.ContainsKey(img.CustomImage))
                            imagesList.Add(img.CustomImage, img.CustomImage);

                    });
                });
                ImageLibrary?.Call("ImportImageList", Title, imagesList, 0UL, true);

            }

            ImageDictionary.ToList().ForEach(img => { ImageLibrary?.Call("AddImage", img.Value, img.Key); });
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(basePlayer);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerTest);
            }
        }



        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("HKits/KitList", KitLists);
            Interface.Oxide.DataFileSystem.WriteObject("HKits/CooldownPlayer", CooldownData);
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerTest);
            }
        }



        void OnPlayerConnected(BasePlayer player)
        {
            if (!CooldownData.ContainsKey(player.userID))
            {
                CooldownData.Add(player.userID, new List<KitsCooldown>());
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (OPENGUI.Contains(player.userID))
                OPENGUI.Remove(player.userID);
        }

        #region GiveItem

        private List<KitItem> GetItemPlayer(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemAddToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }

            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemAddToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }

            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemAddToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }

            return kititems;
        }

        private KitItem ItemAddToKit(Item item, string container)
        {
            KitItem kitem = new KitItem();
            kitem.Amount = item.amount;
            kitem.Container = container;
            kitem.SkinID = item.skin;
            kitem.Blueprint = item.blueprintTarget;
            kitem.ShortName = item.info.shortname;
            kitem.Condition = item.condition;
            kitem.Weapon = null;
            kitem.Content = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitem.Weapon = new Weapon();
                    kitem.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    kitem.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }

            if (item.contents != null)
            {
                kitem.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    kitem.Content.Add(new ItemContent()
                        {
                            Amount = cont.amount,
                            Condition = cont.condition,
                            ShortName = cont.info.shortname
                        }
                    );
                }
            }

            return kitem;
        }
        
        
        
        public List<String> AutoKit = new List<String>()
        {
            "autokit1",
            "autokit2",
            "autokit3"
        };
        void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var value in KitLists.Select(p => p.KitList))
            {
                foreach (var key in value)
                {
                    foreach (String kitName in AutoKit)
                    {
                        if (key.Name == kitName && permission.UserHasPermission(player.UserIDString, key.Permission))
                        {
                            player.inventory.Strip();
                            GiveItems(player, key);
                        }
                    }
                }
            }
        }


        private void GiveItems(BasePlayer player, Kit kit)
        {
            foreach (var kitem in kit.Items)
            {
                GiveItem(player,
                    BuildItem(kitem.ShortName, kitem.Amount, kitem.SkinID, kitem.Condition, kitem.Blueprint,
                        kitem.Weapon, kitem.Content),
                    kitem.Container == "belt" ? player.inventory.containerBelt :
                    kitem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }

        private void GiveItem(BasePlayer player, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            var iventory = player.inventory;
            var moved = item.MoveToContainer(cont) || item.MoveToContainer(iventory.containerMain);
            if (!moved)
            {
                if (cont == iventory.containerBelt) moved = item.MoveToContainer(iventory.containerWear);
                if (cont == iventory.containerWear) moved = item.MoveToContainer(iventory.containerBelt);
            }

            if (!moved) item.Drop(player.GetCenter(), player.GetDropVelocity());
        }

        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, int blueprintTarget,
            Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount, SkinID);
            item.condition = Condition;
            if (blueprintTarget != 0)
            {
                item.blueprintTarget = blueprintTarget;
            }

            if (weapon != null)
            {
                var getheld = item.GetHeldEntity() as BaseProjectile;
                if (getheld != null)
                {
                    getheld.primaryMagazine.contents = weapon.ammoAmount;
                    getheld.primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
                }
            }

            if (Content != null)
            {
                foreach (var cont in Content)
                {
                    Item conts = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    conts.condition = cont.Condition;
                    conts.MoveToContainer(item.contents);
                }
            }

            return item;
        }

        #endregion



        [ChatCommand("kit")]
        void KitFunc(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                if (OPENGUI.Contains(player.userID))
                    return;

                OpenKitMenu(player);
                OPENGUI.Add(player.userID);
                return;
            }

            if (args.Length > 0)
            {
                if (args[0] == "create")
                {
                    if (HasPermission(player.UserIDString, permAllowed))
                    {
                        if (args.Length < 2)
                        {
                            player.ChatMessage("Ошибка: /kit create <NAME>");
                            return;
                        }

                        CreateCategory(player, args[1]);
                    }
                }

                if (args[0] == "add")
                {
                    if (!HasPermission(player.UserIDString, permAllowed))
                    {
                        return;
                    }

                    if (args.Length < 3)
                    {
                        player.ChatMessage("Ошибка: /kit add <NAME> <CATEGORY>");
                        return;
                    }

                    AddKits(player, args[1], args[2], "kits.default");
                }
            }
        }


        void CreateCategory(BasePlayer player, string category)
        {
            if (KitLists.FirstOrDefault(p => p.DisplayName == category) == null)
            {
                string Image =
                    "https://media.discordapp.net/attachments/1061898344269627392/1107331810075095060/EbpKAtY.png";
                KitLists.Add(new CategoryKit
                {
                    DisplayName = category,
                    Image = Image,
                    KitList = new List<Kit>()
                });
                player.ChatMessage($"Вы успешно создали категорию с названием - {category}");
                ImageLibrary?.Call("AddImage", Image, Image);
            }
            else
            {
                player.ChatMessage($"Категория {category} уже существует!");
            }
        }

        [ConsoleCommand("give.kit")]
        void GivToKit(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (!args.HasArgs())
            {
                player.ChatMessage("Произошла ошибка #1 при выдаче! Отпишитесь администрации!");
                return;
            }

            GiveKitCategory(player, args.Args[0], args.Args[1]);
        }

        public string LayerNotif = "UI_KitsNotif";

        void NotifUIGive(BasePlayer player, string nameImage)
        {
            CuiHelper.DestroyUi(player, LayerNotif);
            var container = new CuiElementContainer();
            var Panel = container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.8171875 0.9055555", AnchorMax = "0.9822917 0.9694445" },
                CursorEnabled = false,
            }, "Overlay", LayerNotif);


            container.Add(new CuiElement
            {
                FadeOut = 0.3f,
                Parent = LayerNotif,
                Components =
                {
                    new CuiRawImageComponent
                        { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", nameImage) },
                    new CuiRectTransformComponent
                        { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.AddUi(player, container);
            timer.Once(5, () =>
            {
                if (player != null)
                {
                    CuiHelper.DestroyUi(player, LayerNotif);
                }
            });
        }

        object GiveKit(BasePlayer player, string nameKit)
        {
            var find = KitLists.Find(p => p.KitList.Find(x => x.Name == nameKit) != null);
            if (find != null)
            {
                var kit = find.KitList.Find(p => p.Name == nameKit);
                if (kit == null) return false;
                int beltcount = kit.Items.Where(i => i.Container == "belt").Count();
                int wearcount = kit.Items.Where(i => i.Container == "wear").Count();
                int maincount = kit.Items.Where(i => i.Container == "main").Count();
                int totalcount = beltcount + wearcount + maincount;
                if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) <
                    beltcount ||
                    (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) <
                    wearcount ||
                    (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) <
                    maincount)
                    if (totalcount > (player.inventory.containerMain.capacity -
                                      player.inventory.containerMain.itemList.Count))
                    {
                        return false;
                    }

                GiveItems(player, kit);
                return true;
            }

            return false;
        }


        void GiveKitCategory(BasePlayer player, string category, string kitname)
        {
            var findCategoryKit = KitLists.FirstOrDefault(p => p.DisplayName.ToLower() == category.ToLower());
            if (findCategoryKit == null)
            {
                player.ChatMessage("Произошла ошибка #2 при выдаче! Отпишитесь администрации!");
                return;
            }

            var find = findCategoryKit.KitList.FirstOrDefault(p => p.Name.ToLower() == kitname.ToLower());
            if (find != null)
            {
                var cooldown = CooldownData[player.userID].FirstOrDefault(p => p.Number == find.UniversalNumber);
                if (cooldown != null)
                {
                    var time = cooldown.CoolDown - CurrentTime();
                    if (time > 0)
                    {
                        player.ChatMessage(
                            $"<color=#ff0000><b>[TIMERUST] </b></color><color=#efedee>Подожди</color><color=#4cfa00> {TimeExtensions.FormatShortTime(TimeSpan.FromSeconds(time))}</color><color=#efedee>и возмёшь свой кит</color>");
                        return;
                    }

                    if (time <= 0)
                    {
                        CooldownData[player.userID].Remove(cooldown);
                    }

                    int beltcount = find.Items.Where(i => i.Container == "belt").Count();
                    int wearcount = find.Items.Where(i => i.Container == "wear").Count();
                    int maincount = find.Items.Where(i => i.Container == "main").Count();
                    int totalcount = beltcount + wearcount + maincount;
                    if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) <
                        beltcount ||
                        (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) <
                        wearcount ||
                        (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) <
                        maincount)
                        if (totalcount > (player.inventory.containerMain.capacity -
                                          player.inventory.containerMain.itemList.Count))
                        {
                            NotifUIGive(player, "netmesta");
                            return;
                        }

                    GiveItems(player, find);
                    CooldownData[player.userID].Add(new KitsCooldown
                    {
                        Number = find.UniversalNumber,
                        CoolDown = CurrentTime() + find.Cooldown
                    });

                    Interface.Oxide.DataFileSystem.WriteObject("HKits/CooldownPlayer", CooldownData);

                    NotifUIGive(player, "kitgive");
                    EffectNetwork.Send(new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0,
                            Vector3.up, Vector3.zero)
                        {
                            scale = UnityEngine.Random.Range(0f, 1f)
                        }
                    );
                }
                else
                {
                    int beltcount = find.Items.Where(i => i.Container == "belt").Count();
                    int wearcount = find.Items.Where(i => i.Container == "wear").Count();
                    int maincount = find.Items.Where(i => i.Container == "main").Count();
                    int totalcount = beltcount + wearcount + maincount;
                    if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) <
                        beltcount ||
                        (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) <
                        wearcount ||
                        (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) <
                        maincount)
                        if (totalcount > (player.inventory.containerMain.capacity -
                                          player.inventory.containerMain.itemList.Count))
                        {
                            if (player.SecondsSinceAttacked > 15)
                            {
                                NotifUIGive(player, "netmesta");
                                player.lastAttackedTime = UnityEngine.Time.time;
                            }

                            return;
                        }

                    GiveItems(player, find);
                    CooldownData[player.userID].Add(new KitsCooldown
                    {
                        Number = find.UniversalNumber,
                        CoolDown = CurrentTime() + find.Cooldown
                    });
                    NotifUIGive(player, "kitgive");
                    EffectNetwork.Send(new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0,
                            Vector3.up, Vector3.zero)
                        {
                            scale = UnityEngine.Random.Range(0f, 1f)
                        }
                    );
                }
            }
        }

        public string GetImage(string shortname) => (string)ImageLibrary.Call("GetImage", shortname);
        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{time.Days} д. ";
                if (time.Hours != 0) result += $"{time.Hours} ч. ";
                if (time.Minutes != 0) result += $"{time.Minutes} м. ";
                if (time.Seconds != 0) result += $"{time.Seconds} с. ";
                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;
                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
                if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
                return $"{units} {form3}";
            }
        }

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        static double CurrentTime()
        {
            return DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }



        void AddKits(BasePlayer player, string name, string category, string permissions)
        {
            var find = KitLists.FirstOrDefault(p => p.DisplayName == category);
            if (find == null)
            {
                player.ChatMessage($"Категория {category} не найдена!");
                return;
            }

            if (!permission.PermissionExists(permissions, this))
            {
                permission.RegisterPermission(permissions, this);
            }

            find.KitList.Add(new Kit
            {
                Name = name,
                DisplayName = name,
                DisplayNamePermission = "DIAMOND",
                Cooldown = 600,
                Hide = false,
                Permission = permissions,
                CustomImage =
                    "https://media.discordapp.net/attachments/1061898344269627392/1107331810075095060/EbpKAtY.png",
                Items = GetItemPlayer(player),
                UniversalNumber = UnityEngine.Random.Range(0000, 9999)
            });
            player.ChatMessage($"В категорию {category} был добавлен кит с названием {name}");
        }


        List<Kit> GetKitPlayer(BasePlayer player, List<Kit> kitsList)
        {
            return kitsList.Where(p => !p.Hide && permission.UserHasPermission(player.UserIDString, p.Permission))
                .ToList();
        }


        [ConsoleCommand("close.kit")]
        void CloseKit(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (OPENGUI.Contains(player.userID))
            {
                CuiHelper.DestroyUi(player, Layer);
                OPENGUI.Remove(player.userID);
            }
        }


        public string LayerTest = "UI_LayerTesting";

        [ConsoleCommand("kits.open")]
        void OpenKitCategory(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (!args.HasArgs()) return;
            var find = KitLists.FirstOrDefault(p => p.DisplayName == args.Args[0]);
            if (find != null)
            {
                OpenCategoryKit(player, find);
            }
        }

        [ConsoleCommand("back.kits")]
        void BackKitCategory(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            OpenKitMenu(player);
        }

        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}ч {0:00}м {1:00}с" : "{0:00}м {1:00} с",
                timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }


        void OpenCategoryKit(BasePlayer player, CategoryKit kit)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            var Panel = container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                CursorEnabled = true,
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Command = "back.kits" }
            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".CloseBack",
                Components =
                {
                    new CuiRawImageComponent
                        { Png = (string)ImageLibrary?.Call("GetImage", "back_kits") },
                    new CuiRectTransformComponent
                        { AnchorMin = "0.4796878 0.2351852", AnchorMax = "0.5208334 0.3092591" },
                }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Command = "back.kits" },
                Text = { Text = "" }
            }, Layer + ".CloseBack");


            var list = GetKitPlayer(player, kit.KitList);
            var page = list.Count;
            var height = 25f;
            var width = 165f;
            var margin = 15f;
            var switchs = -(width * page + (page - 1) * margin) / 2f;

            foreach (var check in list.Select((i, t) => new { A = i, B = t }))
            {
                container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin =
                                $"0.5 0.65",
                            AnchorMax =
                                $"0.5 0.65",
                            OffsetMin =
                                $"{switchs} -212",
                            OffsetMax =
                                $"{switchs + width} -3"
                        },
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = $""
                        },
                        Text =
                        {
                            Text = $"", Align = TextAnchor.LowerRight, Font = "robotocondensed-bold.ttf", FontSize = 15
                        }
                    }, Layer, Layer + $".{check.B}.ListItemKitCategory");
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.ImgList",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", "osnova_kits") },
                        new CuiRectTransformComponent
                            { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.ImgListNamePermission",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", "namekits") },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.266127 0.9460317", AnchorMax = "0.7217703 1.053968" }
                    }
                });
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.NamePermission",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{check.A.DisplayNamePermission}", Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", Color = "0.30 0.98 0.00 1.00", FontSize = 12,
                        },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.266127 0.9460317", AnchorMax = "0.7217703 1.053968" }
                    }
                });

                //container.Add(new CuiElement
                //{
                //    FadeOut = 0.3f,
                //    Parent = Layer + $".{check.B}.ListItemKitCategory",
                //    Components =
                //    {
                //        new CuiTextComponent
                //        {
                //            Text = "Подробнее 👁", Align = TextAnchor.MiddleCenter,
                //            Font = "robotocondensed-regular.ttf", Color = "0 0 0 1.00", FontSize = 12,
                //        },
                //        new CuiRectTransformComponent
                //            {AnchorMin = "0.266127 0.9460317", AnchorMax = "0.7217703 1.053968"}
                //    }
                //});

                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.ImgKitCategory",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", check.A.CustomImage) },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.2580646 0.4603175", AnchorMax = "0.7379035 0.8412699" }
                    }
                });
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.TxtNameKit",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{check.A.DisplayName}", Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", Color = "0.972549 0.9764706 1 1", FontSize = 12,
                        },
                        new CuiRectTransformComponent
                            { AnchorMin = "0 0.3142858", AnchorMax = "1 0.3777778" }
                    }
                });

                string color = null;
                string text = null;
                string times = null;
                string image = null;
                var cooldown = CooldownData[player.userID].FirstOrDefault(p => p.Number == check.A.UniversalNumber);
                if (cooldown != null)
                {
                    double time = cooldown.CoolDown - CurrentTime();
                    if (time > 0)
                    {
                        image = "kitcooldown";
                        color = "0.4745098 0.4862745 0.5607843 1";
                        text = "Недоступно";
                        times = $"{GetFormatTime(TimeSpan.FromSeconds(time))}";
                    }
                    else
                    {
                        if (!permission.UserHasPermission(player.UserIDString, check.A.Permission))
                        {
                            image = "nedostupno";
                            color = "0.4745098 0.4862745 0.5607843 1";
                            text = "Недоступно";
                        }
                        else
                        {
                            image = "kitgivebutton";
                            color = "0.3921569 0.7490196 0.2705882 1";
                            text = "Доступно";
                        }
                    }
                }
                else
                {
                    if (!permission.UserHasPermission(player.UserIDString, check.A.Permission))
                    {
                        image = "nedostupno";
                        color = "0.4745098 0.4862745 0.5607843 1";
                        text = "Недоступно";
                    }
                    else
                    {
                        image = "kitgivebutton";
                        color = "0.3921569 0.7490196 0.2705882 1";
                        text = "Доступно";
                    }
                }



                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.TxtDostup",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = text, Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", Color = color, FontSize = 10,
                        },
                        new CuiRectTransformComponent
                            { AnchorMin = "0 0.2476192", AnchorMax = "1 0.3111112" }
                    }
                });
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.ImgListButtonImage",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", image) },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.05 0.05079359", AnchorMax = "0.7 0.2" }
                    }
                });





                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.prosmotr",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", "prosmotr") },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.72 0.05079359", AnchorMax = "0.95 0.2" }
                    }
                });

                container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Color = "0 0 0 0", Command = $"kit.drawkitinfo {check.A.Name} " },
                        Text = { Text = "" }
                    }, Layer + $".{check.B}.prosmotr");

                if (!string.IsNullOrEmpty(times))
                {
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItemKitCategory",
                        Name = Layer + $".{check.B}.TxtCoolDown",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"{times} м", Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-regular.ttf", Color = "0.4745098 0.4862745 0.5607843 1",
                                FontSize = 10,
                            },
                            new CuiRectTransformComponent
                                { AnchorMin = "0.3 0.09841274", AnchorMax = "0.5 0.1619046" }
                        }       
                    });
                }
                else
                {
                    container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                            Button = { Color = "0 0 0 0", Command = $"give.kit {kit.DisplayName} {check.A.Name}" },
                            Text = { Text = "" }
                        }, Layer + $".{check.B}.ImgListButtonImage");
                }

                switchs += width + margin;
            }

            CuiHelper.AddUi(player, container);
        }



        [ConsoleCommand("kit.drawkitinfo")]
        void cmdDrawKitInfo([CanBeNull] ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || player.Connection == null) return;

            ViewInventoryKits(player, args.Args[0]);

        }
        
        private void ViewInventoryKits(BasePlayer player, string kit)
        {
            //CuiHelper.DestroyUi(player, Layer);
            
            var find = KitLists.Find(p => p.KitList.Find(x => x.Name == kit) != null);
            
            var kita = find.KitList.Find(p => p.Name == kit);
            
            var container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                Image         = {Color     = "0.09 0.09 0.09 0.5", Material  = "assets/content/ui/uibackgroundblur.mat"}
            }, Layer, ".ViewInventory");
            
            container.Add(new CuiElement
            {
                Parent = ".ViewInventory",
                Components =
                {
                    new CuiImageComponent {  Color = "0 0 0 0.6", Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = $"0.3213542 0.8472222", AnchorMax = $"0.6177092 0.875" }
                }
            });
            
            container.Add(new CuiLabel
                {
                    Text          = {Text      = $"{kita.DisplayName}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = $"0.3213542 0.8472222", AnchorMax = $"0.6177092 0.875"},
                }, ".ViewInventory");
            
            
            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = $"0.6208333 0.8472222", AnchorMax = $"0.6776041 0.875"
                },
                Button        =
                {
                    Color     = "0 0 0 0.6", Material = "assets/icons/greyout.mat", Close = ".ViewInventory"
                },
                Text          =
                {
                    Text      = "НАЗАД", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.86 0.08 0.24 0.8"
                }
            }, ".ViewInventory");
            
            var findGDE = KitLists.Find(p => p.KitList.Find(x => x.Name == kit) != null);
            
            var kitGDE = find.KitList.Find(p => p.Name == kit);
            
            var allMain = kitGDE.Items.FindAll(p => p.Container == "main");


            for (int i = 0; i < 24; i++)
            {

                container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin =
                                $"{0.3213542 + i * 0.0599 - Math.Floor((double)i / 6) * 6 * 0.0599} {0.7388889 - Math.Floor((double)i / 6) * 0.110}",
                            AnchorMax =
                                $"{0.378125 + i * 0.0599 - Math.Floor((double)i / 6) * 6 * 0.0599} {0.8416677 - Math.Floor((double)i / 6) * 0.110}",
                        },
                        Image = { Color = "0.09 0.09 0.09 0.8" },
                    }, ".ViewInventory", ".ViewInventory" + $"{i}.Main");
                
                if (allMain.Count <= i) continue;
                    
                var element = allMain[i];
                
                
                container.Add(new CuiElement
                {
                    Parent = ".ViewInventory" + $"{i}.Main",
                    Components =
                    {
                        new CuiImageComponent {ItemId = ItemManager.FindItemDefinition(element.ShortName).itemid, SkinId = element.SkinID},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5"}
                    }
                });
                
                container.Add(new CuiLabel
                    {
                        Text          = {Text      = $"x{element.Amount}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleRight},
                        RectTransform = {AnchorMin = $"0 0.01086909", AnchorMax = $"0.9239309 0.2934731" },
                    }, ".ViewInventory" + $"{i}.Main");
            }

            var kitGDEWear = find.KitList.Find(p => p.Name == kit);

            var allWear = kitGDEWear.Items.FindAll(p => p.Container == "wear");


            for (int i = 0; i < 7; i++)
            {
                container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = $"{0.2916672 + i * 0.0599 - Math.Floor((double)i / 7) * 7 * 0.0599} 0.2981547",
                            AnchorMax = $"{0.348438 + i * 0.0599 - Math.Floor((double)i / 7) * 7 * 0.0599} 0.4009368",
                        },
                        Image = { Color = "0.09 0.09 0.09 0.8" },
                    }, ".ViewInventory", ".ViewInventory" + $"{i}.Wear");
                
                if (allWear.Count <= i) continue;
                
                var element = allWear[i];
                
                container.Add(new CuiElement
                {
                    Parent = ".ViewInventory" + $"{i}.Wear",
                    Components =
                    {
                        new CuiImageComponent {ItemId = ItemManager.FindItemDefinition(element.ShortName).itemid, SkinId = element.SkinID},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5"}
                    }
                });
                
                container.Add(new CuiLabel
                    {
                        Text          = {Text      = $"x{element.Amount}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleRight},
                        RectTransform = {AnchorMin = $"0 0.01086909", AnchorMax = $"0.9239309 0.2934731" },
                    }, ".ViewInventory" + $"{i}.Wear");
            }
            
            var kitGDEBelt = find.KitList.Find(p => p.Name == kit);

            
            var allBelt = kitGDEBelt.Items.FindAll(p => p.Container == "belt");
            
            for (int i = 0; i < 6; i++)
            {
                container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = $"{0.3213542 + i * 0.0599 - Math.Floor((double)i / 7) * 7 * 0.0599} 0.1879692",
                            AnchorMax = $"{0.378125 + i * 0.0599 - Math.Floor((double)i / 7) * 7 * 0.0599} 0.2907513",
                        },
                        Image = { Color = "0.09 0.09 0.09 0.8" },
                    }, ".ViewInventory", ".ViewInventory" + $"{i}.Belt");
                
                if (allBelt.Count <= i) continue;
                
                var element = allBelt[i];
                
                container.Add(new CuiElement
                {
                    Parent = ".ViewInventory" + $"{i}.Belt",
                    Components =
                    {
                        new CuiImageComponent {ItemId = ItemManager.FindItemDefinition(element.ShortName).itemid, SkinId = element.SkinID},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5"}
                    }
                });
                
                container.Add(new CuiLabel
                    {
                        Text          = {Text      = $"x{element.Amount}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleRight},
                        RectTransform = {AnchorMin = $"0 0.01086909", AnchorMax = $"0.9239309 0.2934731" },
                    }, ".ViewInventory" + $"{i}.Belt");
            }


            CuiHelper.AddUi(player, container);
        }

        #region UI
            List<CategoryKit> GetCategory(BasePlayer player)
            {
                List<CategoryKit> categoryKits = new List<CategoryKit>();
                foreach (var value in KitLists)
                {
                    foreach (var kit in value.KitList)
                    {
                        if (permission.UserHasPermission(player.UserIDString, kit.Permission) &&
                            !categoryKits.Contains(value))
                        {
                            categoryKits.Add(value);
                        }
                    }
                }

                return categoryKits;
            }


            void OpenKitMenu(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Layer);
                var container = new CuiElementContainer();
                var Panel = container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    CursorEnabled = true,
                }, "Overlay", Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = "close.kit" }
                }, Layer);

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".Close",
                    Components =
                    {
                        new CuiRawImageComponent
                            { Png = (string)ImageLibrary?.Call("GetImage", "close_kits") },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.4796878 0.2351852", AnchorMax = "0.5208334 0.3092591" },
                    }
                });



                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = "close.kit" },
                    Text = { Text = "" }
                }, Layer + ".Close");
                var category = GetCategory(player);
                var page = category.Count;
                var height = 25f;
                var width = 165f;
                var margin = 15f;
                var switchs = -(width * page + (page - 1) * margin) / 2f;
                foreach (var check in category.Select((i, t) => new { A = i, B = t }))
                {
                    container.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin =
                                    $"0.5 0.65",
                                AnchorMax =
                                    $"0.5 0.65",
                                OffsetMin =
                                    $"{switchs} -212",
                                OffsetMax =
                                    $"{switchs + width} -3"
                            },
                            Button =
                            {
                                Color = "0 0 0 0",
                                Command = $""
                            },
                            Text =
                            {
                                Text = $"", Align = TextAnchor.LowerRight, Font = "robotocondensed-bold.ttf",
                                FontSize = 15
                            }
                        }, Layer, Layer + $".{check.B}.ListItem");
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItem",
                        Name = Layer + $".{check.B}.ImgList",
                        Components =
                        {
                            new CuiRawImageComponent
                                { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", "osnova_kits") },
                            new CuiRectTransformComponent
                                { AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItem",
                        Name = Layer + $".{check.B}.ImgList",
                        Components =
                        {
                            new CuiRawImageComponent
                                { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", check.A.Image) },
                            new CuiRectTransformComponent
                                { AnchorMin = "0.2580646 0.4603175", AnchorMax = "0.7379035 0.8412699" }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItem",
                        Name = Layer + $".{check.B}.TxtNameCategory",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"{check.A.DisplayName}", Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-regular.ttf", Color = "0.972549 0.9764706 1 1", FontSize = 12,
                            },
                            new CuiRectTransformComponent
                                { AnchorMin = "0 0.3142858", AnchorMax = "1 0.3777778" }
                        }
                    });
                    List<Kit> listKit = GetKitPlayer(player, check.A.KitList);
                    string color = listKit.Count > 0
                        ? "0.3921569 0.7490196 0.2705882 1"
                        : "0.4745098 0.4862745 0.5607843 1";
                    string text = listKit.Count > 0 ? "Есть доступные" : "Нет доступных";
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItem",
                        Name = Layer + $".{check.B}.TxtDostup",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = text, Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-regular.ttf", Color = color, FontSize = 10,
                            },
                            new CuiRectTransformComponent
                                { AnchorMin = "0 0.2476192", AnchorMax = "1 0.3111112" }
                        }
                    });
                    if (listKit.Count > 0)
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".{check.B}.ListItem",
                            Name = Layer + $".Perexod.{check.B}",
                            Components =
                            {
                                new CuiRawImageComponent
                                    { Png = (string)ImageLibrary?.Call("GetImage", "perexodyes") },
                                new CuiRectTransformComponent
                                    { AnchorMin = "0.125 0.05079359", AnchorMax = "0.8790323 0.2031745" },
                            }
                        });
                        container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                                Button = { Color = "0 0 0 0", Command = $"kits.open {check.A.DisplayName}" },
                                Text = { Text = "" }
                            }, Layer + $".Perexod.{check.B}");
                    }
                    else
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".{check.B}.ListItem",
                            Name = Layer + $".Perexod.{check.B}",
                            Components =
                            {
                                new CuiRawImageComponent
                                    { Png = (string)ImageLibrary?.Call("GetImage", "perexodno") },
                                new CuiRectTransformComponent
                                    { AnchorMin = "0.125 0.05079359", AnchorMax = "0.8790323 0.2031745" },
                            }
                        });
                    }

                    switchs += width + margin;
                }

                CuiHelper.AddUi(player, container);
            }





            #endregion

        }
    }

// --- End of file: Kitss.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SimpleMapKeeper.cs ---
// --- Original Local Path: SimpleMapKeeper.cs ---

using Oxide.Core;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{

    [Info("SimpleMapKeeper", "CARNY666", "1.1.0", ResourceId = 1579)]
    class SimpleMapKeeper : RustPlugin
    {
        private Dictionary<BasePlayer, Item> mapStorage = new Dictionary<BasePlayer, Item>();

        #region localization/messages
        private void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {                
                {"mapSaved", "You have just saved your current map."},
                {"mapAutoSaved", "Your map will be automatically saved."},
                {"noMapInBelt", "You must have a map in your belt to save it."},
                {"mapRestored", "Your map has just been restored."},
                {"mapNotRestored", "Map was not restored."},
                {"informMapSave", "Your map is automatically saved, so long as it is/was equipped on your belt."}
            };
            lang.RegisterMessages(messages, this);
        }

        private string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);
        #endregion

        #region events
        private void Init()
        {
            LoadDefaultMessages();
            timer.Repeat(10, 0, () => SaveAllPlayerMaps());
            //PrintToChat($"SimpleMapKeeper {Version.ToString()} initialized.."); ~ Removed as per suggestion by Wulf. 
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!playerAlreadyHasMap(player))
                if (restoreMap(player))
                    PrintToChat(player, GetMessage("mapRestored", player.UserIDString));
        }

        private void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container.playerOwner != null)
                if (playerAlreadyHasMap(container.playerOwner))
                    if (saveMap(container.playerOwner))
                        if (item.info.displayName.english == "Paper Map")
                            PrintToChat(container.playerOwner, GetMessage("mapSaved", container.playerOwner.UserIDString));
        }

        private void Loaded()
        {
            LoadDefaultMessages();
        }
        #endregion

        [ChatCommand("simplemap")]
        private void simplemap(BasePlayer player, string command, string[] args)
        {
            if (args.Length > 0)
            {
                if (args[0] == "save")
                {
                    if (saveMap(player))
                        PrintToChat(player, GetMessage("mapSaved", player.UserIDString));
                    else
                        PrintToChat(player, GetMessage("noMapInBelt", player.UserIDString));
                }

                if (args[0] == "restore")
                {
                    if (restoreMap(player))
                        PrintToChat(player, GetMessage("mapRestored", player.UserIDString));
                    else
                        PrintToChat(player, GetMessage("mapNotRestored", player.UserIDString));
                }
            }
            PrintToChat(player, GetMessage("informMapSave", player.UserIDString));
        }

        /// <summary>
        /// Iterates through all active players, tests for a map, removes the existsing reference and saves new reference. 
        /// Called from the timer.
        /// </summary>
        private void SaveAllPlayerMaps()
        {
            foreach(BasePlayer b in BasePlayer.activePlayerList)
            {
                try {
                    if (!playerAlreadyHasMap(b)) break;

                    var map = b.inventory.containerBelt.itemList.Where(x => x.info.displayName.english == "Paper Map").First();
                    if (map != null)
                    {
                        if (mapStorage.ContainsKey(b))
                            mapStorage.Remove(b);
                        else
                            PrintToChat(b, GetMessage("mapAutoSaved", b.UserIDString));

                        saveMap(b);                            
                    }
                } catch(System.Exception e)
                {
                    PrintToConsole($"SaveAllPlayerMaps Error: SAVING {b.displayName} {e.Message}");
                }
            }
        }

        /// <summary>
        /// Tests to see is passed BasePlayer's containerBelt contains a map.
        /// </summary>
        /// <param name="player">BasePlayer of whom to save map.</param>
        /// <returns>True if BasePlayer's container.</returns>
        private bool playerAlreadyHasMap(BasePlayer player)
        {
            try {
                if (player.inventory.containerBelt.itemList.Where(x => x.info.displayName.english == "Paper Map").Count() > 0)
                    return true;    
                return false;  // no map to save
            } catch (System.Exception e)
            {
                PrintToConsole($"playerAlreadyHasMap error: {e.Message}");
                return false;
            }
        }

        /// <summary>
        /// Saves a reference to the passed BasePlayer's equipped map into dictionary object.
        /// </summary>
        /// <param name="player">BasePlayer of whom to save map.</param>
        /// <returns>True if success.</returns>
        private bool saveMap(BasePlayer player)
        {
            // test that player has map equipped
            if (player.inventory.containerBelt.itemList.Where(x => x.info.displayName.english == "Paper Map").Count() == 0) return false;
            
            // get the players first equipped map
            var map = player.inventory.containerBelt.itemList.Where(x => x.info.displayName.english == "Paper Map").First();

            // better not be null..
            if (map == null) return false;  // no map to save

            // if a maps been saved, remove it
            if (mapStorage.ContainsKey(player))
                mapStorage.Remove(player);

            // add the map
            mapStorage.Add(player, map);

            return mapStorage.ContainsKey(player);
        }

        /// <summary>
        /// Restores reference to BasePlayer's saved map in containerBelt.
        /// </summary>
        /// <param name="player">BasePlayer of whom to save map.</param>
        /// <returns>True if success.</returns>
        private bool restoreMap(BasePlayer player)
        {
            if (!mapStorage.ContainsKey(player)) return false;

            if (mapStorage[player] == null) return false;
            mapStorage[player].MoveToContainer(player.inventory.containerBelt);
            return true;
        }
    }
}

// --- End of file: SimpleMapKeeper.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MinicopterSeating.cs ---
// --- Original Local Path: MinicopterSeating.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Minicopter Seating", "Bazz3l", "1.1.6")]
    [Description("Spawn extra seats on each side of the minicopter.")]
    public class MinicopterSeating : CovalencePlugin
    {
        #region Fields

        private readonly GameObjectRef _gameObjectRef = new GameObjectRef { guid = "dc329880dec7ab343bc454fd969d5709" };
        private readonly Vector3 _seat1 = new Vector3(0.6f, 0.2f, -0.3f);
        private readonly Vector3 _seat2 = new Vector3(-0.6f, 0.2f, -0.3f);

        #endregion

        #region Oxide

        private void OnEntitySpawned(BaseVehicle mini)
        {
            if (mini.mountPoints.Count < 3 && mini.ShortPrefabName == "minicopter.entity")
                SetupSeating(mini);
        }

        #endregion

        #region Core

        private void SetupSeating(BaseVehicle vehicle)
        {
            vehicle.mountPoints.Add(CreateMount(vehicle.mountPoints, _seat1));
            //vehicle.mountPoints.Add(CreateMount(vehicle.mountPoints, _seat2));
        }

        private BaseVehicle.MountPointInfo CreateMount(List<BaseVehicle.MountPointInfo> mountPoints, Vector3 position)
        {
            return new BaseVehicle.MountPointInfo
            {
                pos = position,
                rot = mountPoints[1].rot,
                prefab = _gameObjectRef,
                mountable = mountPoints[1].mountable,
            };
        }

        #endregion
    }
}

// --- End of file: MinicopterSeating.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CodelockNerf.cs ---
// --- Original Local Path: CodelockNerf.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("CodeLockNerf", "Kyrah Abattoir", "0.1", ResourceId = 1873)]
    [Description("If you die, your character can forget your door codes, better keep that notepad ready.")]
    class CodelockNerf : RustPlugin
    {
        #region CONFIGURATION

        int _cfgMaxUniqueCodes;//How many unique CODES can the player always remember (-1) to disable.
        int _cfgCodeForgetRate;//Percentage of chance to forget a CODE from 0% to 100%

        int _cfgMaxUniqueLocks;//How many unique DOORS can the player always remember (-1) to disable.
        int _cfgLockForgetRate;//Percentage of chance to forget a LOCK from 0% to 100%

        //If true, outputs the door/codes forgotten stats in the server console.
        //Useful for admins.
        bool _cfgOutputstats;

        protected override void LoadDefaultConfig()
        {
            Config["MaxUniqueCodes"] = _cfgMaxUniqueCodes = GetConfig("MaxUniqueCodes", -1);
            Config["CodeForgetChance"] = _cfgCodeForgetRate = GetConfig("CodeForgetChance", 100);

            Config["MaxUniqueLocks"] = _cfgMaxUniqueLocks = GetConfig("MaxUniqueLocks", 0);
            Config["LockForgetChance"] = _cfgLockForgetRate = GetConfig("LockForgetChance", 100);

            Config["OutputStats"] = _cfgOutputstats = GetConfig("OutputStats", true);
        }

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"MsgDied", "{0} died:"},
                {"MsgForgetCode", "forgot {0}/{1} code(s)"},
                {"MsgForgetLock", "forgot {0}/{1} lock(s)"},
            }, this);
        }
        #endregion

        bool _isLoaded = false;




        List<CodeLock> _codelocks;
        readonly FieldInfo _whitelistField = typeof(CodeLock).GetField("whitelistPlayers", (BindingFlags.Instance | BindingFlags.NonPublic));
        readonly FieldInfo _codeField = typeof(CodeLock).GetField("code", (BindingFlags.Instance | BindingFlags.NonPublic));

        //Get all the codelocks on server start/plugin reload.
        void OnServerInitialized()
        {
            _cfgCodeForgetRate = Mathx.Clamp(_cfgCodeForgetRate, 0, 100);
            _cfgLockForgetRate = Mathx.Clamp(_cfgLockForgetRate, 0, 100);
            _codelocks = UnityEngine.Object.FindObjectsOfType<CodeLock>().ToList();
            _isLoaded = true;
        }

        void Loaded()
        {
            LoadDefaultConfig();
            LoadDefaultMessages();
        }

        //Adds newly spawned codelocks.
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!_isLoaded)
                return;
            if (!(entity is CodeLock))
                return;
            CodeLock lck = entity as CodeLock;
            if (!_codelocks.Contains(lck))
                _codelocks.Add(lck);
        }

        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            if (!(entity is BasePlayer))
                return;
            BasePlayer player = (BasePlayer)entity;

            //clear codelocks that are gone
            _codelocks.RemoveAll(o => o == null);

            List<CodeLock> known_locks = new List<CodeLock>();
            List<string> known_codes = new List<string>();

            //populate our accounting lists.
            foreach (var codelock in _codelocks)
            {
                if (codelock == null)
                    continue;

                var whitelist = (List<ulong>)_whitelistField.GetValue(codelock);
                var code = (string)_codeField.GetValue(codelock);

                if (whitelist.Contains(player.userID))
                {
                    known_locks.Add(codelock);
                    if (code != null && !known_codes.Contains(code))
                        known_codes.Add(code);
                }
            }

            //shuffle the lists
            var r = new System.Random();
            known_codes.Shuffle((uint)r.Next());
            known_locks.Shuffle((uint)r.Next());

            var locks = known_locks.Count;
            var forgotten_locks = 0;
            var codes = known_codes.Count;
            var forgotten_codes = 0;

            //we know too many codes, time to forget some.
            if ((_cfgMaxUniqueCodes >= 0 && known_codes.Count > _cfgMaxUniqueCodes))
            {
                //1. remove codes randomly.
                var i = known_codes.Count;
                while (i-- > 0)
                {
                    if (known_codes.Count <= _cfgMaxUniqueCodes)
                        break;

                    if (r.Next(1, 100) <= _cfgCodeForgetRate)
                    {
                        known_codes.RemoveAt(i);
                        forgotten_codes++;
                    }
                }

                //2. we remove all doors that match the forgotten codes.
                i = known_locks.Count;
                while (i-- > 0)
                {
                    CodeLock codelock = known_locks[i];
                    if (!known_codes.Contains((string)_codeField.GetValue(codelock)))
                    {
                        var whitelist = (List<ulong>)_whitelistField.GetValue(codelock);
                        whitelist.Remove(player.userID);
                        known_locks.RemoveAt(i);
                        forgotten_locks++;
                    }
                }
            }

            //we know too many doors, time to forget some.
            if ((_cfgMaxUniqueLocks >= 0 && known_locks.Count > _cfgMaxUniqueLocks))
            {
                var i = known_locks.Count;
                while (i-- > 0)
                {
                    if (known_locks.Count <= _cfgMaxUniqueLocks)
                        break;
                    CodeLock codelock = known_locks[i];
                    if (r.Next(1, 100) <= _cfgLockForgetRate)
                    {
                        var whitelist = (List<ulong>)_whitelistField.GetValue(codelock);
                        whitelist.Remove(player.userID);
                        known_locks.RemoveAt(i);
                        forgotten_locks++;
                    }
                }
            }

            if (!_cfgOutputstats)
                return;

            //Display stats.

            if (forgotten_locks == 0 && forgotten_codes == 0)
                return;

            string message = string.Format(GetMessage("MsgDied"),player.displayName);
            if (forgotten_codes > 0)
                message += " "+string.Format(GetMessage("MsgForgetCode"),forgotten_codes,codes);
            if (forgotten_locks > 0)
                message += " "+string.Format(GetMessage("MsgForgetLock"),forgotten_locks,locks);
            Puts(message+".");
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);
    }
}

// --- End of file: CodelockNerf.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQMarker.cs ---
// --- Original Local Path: IQMarker.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("IQMarker", "Mercury", "0.0.5")]
    [Description("\u041c\u0430\u0440\u043a\u0435\u0440\u044b \u0434\u043b\u044f \u0432\u0430\u0448\u0438\u0445 \u043b\u044e\u0431\u0438\u043c\u0447\u0438\u043a\u043e\u0432")]
    class IQMarker : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin ImageLibrary, Friends;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public void SendImage(BasePlayer player, string imageName, ulong imageId = 0) => ImageLibrary?.Call("SendImage", player, imageName, imageId);
        public bool HasImage(string imageName) => (bool)ImageLibrary?.Call("HasImage", imageName);
        public bool IsFriends(ulong TargetID, ulong PlayerID)
        {
            if (Friends == null) return false;
            if ((bool)Friends.Call("HasFriend", PlayerID, TargetID)) return true;
            else return false;
        }
        public void LoadedImage()
        {
            var Icon = config.MarkesSettings.IconSetting.IconList;
            for (int i = 0; i < Icon.Count; i++)
            {
                if (!HasImage($"ICON_{Icon[i].PNG}_{i}"))
                    AddImage(Icon[i].PNG, $"ICON_{Icon[i].PNG}_{i}");
            }
        }
        public void CachedImage(BasePlayer player)
        {
            var Icon = config.MarkesSettings.IconSetting.IconList;
            for (int i = 0; i < Icon.Count; i++)
                SendImage(player, $"ICON_{Icon[i].PNG}_{i}");
        }
        #endregion

        #region Vars
        public static string PermissionUseMarker = "iqmarker.use";
        public static string PermissionUseColorList = "iqmarker.usecolorlist";
        public static string PermissionUseCustomColor = "iqmarker.usecustomcolor";
        public static string PermissionUseSizer = "iqmarker.usesize";
        public void RegisteredPermissions()
        {
            var ColorList = config.AccessSettings.ColorListMarker;
            var Markers = config.MarkesSettings;
            var HealtBar = Markers.HealthBarSetting;
            var DamageText = Markers.DamageTextSetting;
            var Icon = Markers.IconSetting;

            Register(PermissionUseMarker);
            Register(PermissionUseColorList);
            Register(PermissionUseCustomColor);
            Register(PermissionUseSizer);
            Register(HealtBar.PermissionsHealthBar);
            Register(HealtBar.PermissionsHealtBarDamageText);
            Register(HealtBar.PermissionsHealtBarWounded);
            Register(DamageText.PermissionsDamageText);
            Register(DamageText.PermissionsDamageTextWounded);
            Register(Icon.PermissionsIcon);
            Register(Icon.PermissionsIconWounded);
            Register(Icon.PermissionsIconDamageText);

            for (int i = 0; i < Icon.IconList.Count; i++)
                Register(Icon.IconList[i].Permissions);

            for (int i = 0; i < ColorList.Count; i++)
                Register(ColorList[i].Permissions);
        }
        public void ReturnSettingsMore(BasePlayer player)
        {
            if (!DataInformation.ContainsKey(player.userID)) return;
            var Data = DataInformation[player.userID];
            var HealthBar = Data.HealthBarMore;
            var DamageText = Data.DamageTextMore;
            var Icon = Data.IconMore;

            var Markers = config.MarkesSettings;
            var HealtBarCfg = Markers.HealthBarSetting;
            var DamageTextCfg = Markers.DamageTextSetting;
            var IconCfg = Markers.IconSetting;

            if (HealthBar.TurnDamageText)
                if (!permission.UserHasPermission(player.UserIDString, HealtBarCfg.PermissionsHealtBarDamageText))
                    HealthBar.TurnDamageText = false;

            if (HealthBar.TurnWounded)
                if (!permission.UserHasPermission(player.UserIDString, HealtBarCfg.PermissionsHealtBarWounded))
                    HealthBar.TurnWounded = false;

            if (DamageText.TurnWounded)
                if (!permission.UserHasPermission(player.UserIDString, DamageTextCfg.PermissionsDamageTextWounded))
                    DamageText.TurnWounded = false;

            if (Icon.TurnDamageText)
                if (!permission.UserHasPermission(player.UserIDString, IconCfg.PermissionsIconDamageText))
                    Icon.TurnDamageText = false;

            if (Icon.TurnWounded)
                if (!permission.UserHasPermission(player.UserIDString, IconCfg.PermissionsIconWounded))
                    Icon.TurnWounded = false;
        }
        public void Register(string Permissions)
        {
            if (!IsNullOrWhiteSpace(Permissions))
                if (!permission.PermissionExists(Permissions, this))
                    permission.RegisterPermission(Permissions, this);
        }
        #endregion

        public static bool IsNullOrWhiteSpace(string value)
        {
            if (value == null)
            {
                return true;
            }
            for (int i = 0; i < value.Length; i++)
            {
                if (!char.IsWhiteSpace(value[i]))
                {
                    return false;
                }
            }
            return true;
        }

        #region Configuration 
        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043f\u043b\u0430\u0433\u0438\u043d\u0430")]
            public AccessSetting AccessSettings = new AccessSetting();
            [JsonProperty("\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430 \u043f\u043b\u0430\u0433\u0438\u043d\u0430")]
            public SettingsInterface SettingsInterfaces = new SettingsInterface();
            [JsonProperty("\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043c\u0430\u0440\u043a\u0435\u0440\u043e\u0432")]
            public MarkersSetting MarkesSettings = new MarkersSetting();
            [JsonProperty("\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439(\u0411\u0443\u0434\u044c\u0442\u0435 \u0432\u043d\u0438\u043c\u0430\u0442\u0435\u043b\u044c\u043d\u044b,\u044d\u0442\u0438 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0434\u0430\u044e\u0442\u0441\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0432\u043d\u0435 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u043f\u0440\u0430\u0432,\u0435\u0441\u043b\u0438 \u0438\u0433\u0440\u043e\u043a \u0438\u0445 \u0432\u044b\u043a\u043b\u044e\u0447\u0438\u0442 \u0438 \u0443 \u043d\u0435\u0433\u043e \u043d\u0435 \u0431\u0443\u0434\u0435\u0442 \u043f\u0440\u0430\u0432, \u043e\u043d\u0438 \u0435\u043c\u0443 \u043f\u043e\u0442\u0440\u0435\u0431\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u043e\u0433\u043e \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f)")]
            public UserSettings UserSetting = new UserSettings();
            internal class AccessSetting
            {
                [JsonProperty("true - \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0443 \u043c\u0430\u0440\u043a\u0435\u0440\u043e\u0432/false - \u043e\u0442\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0443")]
                public bool UseSettingsMarker;
                [JsonProperty("\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0445 \u0446\u0432\u0435\u0442\u043e\u0432 \u0434\u043b\u044f \u043c\u0430\u0440\u043a\u0435\u0440\u0430")]
                public List<ColorList> ColorListMarker = new List<ColorList>();
                internal class ColorList
                {
                    [JsonProperty("\u041f\u0440\u0430\u0432\u0430 \u0434\u043e\u0441\u0442\u0443\u043f\u0430 \u0434\u043b\u044f \u044d\u0442\u043e\u0433\u043e \u0446\u0432\u0435\u0442\u0430")]
                    public string Permissions;
                    [JsonProperty("HEX \u0446\u0432\u0435\u0442")]
                    public string HexColor;
                }
            }
            internal class UserSettings
            {
                [JsonProperty("\u0412\u043a\u043b\u044e\u0447\u0435\u043d \u043b\u0438 \u043c\u0430\u0440\u043a\u0435\u0440 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0438\u0433\u0440\u043e\u043a\u043e\u0432?(true - \u0434\u0430/false - \u043d\u0435\u0442)")]
                public bool DefaultTurnOnMarker;
                [JsonProperty("\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0446\u0432\u0435\u0442 \u043c\u0430\u0440\u043a\u0435\u0440\u0430 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0438\u0433\u0440\u043e\u043a\u043e\u0432(HEX)")]
                public string DefaultHexMarker;
                [JsonProperty("\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0432\u0438\u0434 \u043c\u0430\u0440\u043a\u0435\u0440\u0430 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0438\u0433\u0440\u043a\u043e\u043e\u0432 (0 - \u0422\u0435\u043a\u0441\u0442 \u0441 \u0434\u0430\u043c\u0430\u0433\u043e\u043c | 1 - \u041f\u043e\u043b\u043e\u0441\u0430 \u0425\u041f | 2 - \u0418\u043a\u043e\u043d\u043a\u0430)")]
                public MarkerType DefaultMarkerType;
                [JsonProperty("\u0421\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0440\u043a\u0435\u0440\u0430 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0438\u0433\u0440\u043a\u043e\u043e\u0432 (0 - \u041c\u0430\u043b\u0435\u043d\u044c\u043a\u0438\u0439 | 1 - \u0421\u0440\u0435\u0434\u043d\u0438\u0439 | 2 - \u0411\u043e\u043b\u044c\u0448\u043e\u0439)")]
                public TypeSize DefaultMarkerSize;

                [JsonProperty("\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043f\u043e\u043b\u043e\u0441\u044b \u0425\u041f \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0438\u0433\u0440\u043a\u043e\u0432")]
                public HealthBar DefaultHealthBar = new HealthBar();
                [JsonProperty("\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0442\u0435\u043a\u0441\u0442\u0430 \u0441 \u0443\u0440\u043e\u043d\u043e\u043c \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0438\u0433\u0440\u043a\u043e\u0432")]
                public DamageText DefaultDamageText = new DamageText();
                [JsonProperty("\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0438\u043a\u043e\u043d\u043a\u0438 \u0434\u043b\u044f \u043d\u043e\u0432\u044b\u0445 \u0438\u0433\u0440\u043a\u043e\u0432")]
                public Icon DefaultIcon = new Icon();
                internal class HealthBar
                {
                    [JsonProperty("\u0412\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0442\u0435\u043a\u0441\u0442\u0430 \u0441 \u0434\u0430\u043c\u0430\u0433\u043e\u043c(true - \u0434\u0430/false - \u043d\u0435\u0442)")]
                    public bool TurnDamageText;
                    [JsonProperty("\u0412\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0438\u043a\u043e\u043d\u043a\u0438 \u043f\u0430\u0434\u0435\u043d\u0438\u044f(true - \u0434\u0430/false - \u043d\u0435\u0442)")]
                    public bool TurnWounded;
                }
                internal class DamageText
                {
                    [JsonProperty("\u0412\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0442\u0435\u043a\u0441\u0442\u0430 \u0441 \u0434\u0430\u043c\u0430\u0433\u043e\u043c(true - \u0434\u0430 /false - \u043d\u0435\u0442)")]
                    public bool TurnWounded;
                }
                internal class Icon
                {
                    [JsonProperty("\u0412\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0442\u0435\u043a\u0441\u0442\u0430 \u0441 \u0434\u0430\u043c\u0430\u0433\u043e\u043c(true - \u0434\u0430 / false - \u043d\u0435\u0442)")]
                    public bool TurnDamageText;
                    [JsonProperty("\u0412\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043e\u0442\u043e\u0431\u0440\