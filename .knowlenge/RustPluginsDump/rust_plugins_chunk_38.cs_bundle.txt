249/effects/eject_beltlink.prefab",
            "assets/prefabs/weapons/m249/effects/eject_rifle_shell.prefab",
            "assets/prefabs/weapons/m249/effects/place_bullets.prefab",
            "assets/prefabs/weapons/m249/effects/reload_smoke.prefab",
            "assets/prefabs/weapons/m249/effects/topcover_close.prefab",
            "assets/prefabs/weapons/m249/effects/topcover_open.prefab",
            "assets/prefabs/weapons/m249/effects/w_drop_magazine.prefab",
            "assets/prefabs/weapons/m249/effects/w_eject_rifle_shell.prefab",
            "assets/prefabs/weapons/m39 emr/effects/attack.prefab",
            "assets/prefabs/weapons/m39 emr/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/m39 emr/effects/attack_shake.prefab",
            "assets/prefabs/weapons/m39 emr/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/m39 emr/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/m39 emr/effects/bolt_action.prefab",
            "assets/prefabs/weapons/m39 emr/effects/clip_in.prefab",
            "assets/prefabs/weapons/m39 emr/effects/clip_out.prefab",
            "assets/prefabs/weapons/m39 emr/effects/clip_slap.prefab",
            "assets/prefabs/weapons/m39 emr/effects/deploy.prefab",
            "assets/prefabs/weapons/m39 emr/effects/deploy_grab_forearm.prefab",
            "assets/prefabs/weapons/m39 emr/effects/dryfire.prefab",
            "assets/prefabs/weapons/m39 emr/effects/eject_rifle_shell.prefab",
            "assets/prefabs/weapons/m39 emr/effects/reload_start.prefab",
            "assets/prefabs/weapons/m39 emr/effects/w_drop_magazine.prefab",
            "assets/prefabs/weapons/m39 emr/effects/w_eject_rifle_shell.prefab",
            "assets/prefabs/weapons/m92/effects/attack.prefab",
            "assets/prefabs/weapons/m92/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/m92/effects/attack_shake.prefab",
            "assets/prefabs/weapons/m92/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/m92/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/m92/effects/clipin.prefab",
            "assets/prefabs/weapons/m92/effects/clipout.prefab",
            "assets/prefabs/weapons/m92/effects/deploy.prefab",
            "assets/prefabs/weapons/m92/effects/dryfire.prefab",
            "assets/prefabs/weapons/m92/effects/eject_pistol_shell.prefab",
            "assets/prefabs/weapons/m92/effects/pfx_ejectshell_smoke.prefab",
            "assets/prefabs/weapons/m92/effects/safety.prefab",
            "assets/prefabs/weapons/m92/effects/slideopen.prefab",
            "assets/prefabs/weapons/m92/effects/slideshut.prefab",
            "assets/prefabs/weapons/m92/effects/w_drop_mag.prefab",
            "assets/prefabs/weapons/m92/effects/w_eject_pistol_shell.prefab",
            "assets/prefabs/weapons/mace/effects/attack-1.prefab",
            "assets/prefabs/weapons/mace/effects/attack-2.prefab",
            "assets/prefabs/weapons/mace/effects/deploy.prefab",
            "assets/prefabs/weapons/mace/effects/hit.prefab",
            "assets/prefabs/weapons/mace/effects/throw.prefab",
            "assets/prefabs/weapons/machete/effects/attack-1.prefab",
            "assets/prefabs/weapons/machete/effects/attack-2.prefab",
            "assets/prefabs/weapons/machete/effects/attack-3.prefab",
            "assets/prefabs/weapons/machete/effects/deploy.prefab",
            "assets/prefabs/weapons/machete/effects/hit-muted.prefab",
            "assets/prefabs/weapons/machete/effects/hit-soft.prefab",
            "assets/prefabs/weapons/machete/effects/hit.prefab",
            "assets/prefabs/weapons/machete/effects/swing_thirdperson.prefab",
            "assets/prefabs/weapons/machete/effects/throw.prefab",
            "assets/prefabs/weapons/mp5/effects/attack.prefab",
            "assets/prefabs/weapons/mp5/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/mp5/effects/attack_shake.prefab",
            "assets/prefabs/weapons/mp5/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/mp5/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/mp5/effects/bolt_back.prefab",
            "assets/prefabs/weapons/mp5/effects/bolt_shut.prefab",
            "assets/prefabs/weapons/mp5/effects/bolt_slap.prefab",
            "assets/prefabs/weapons/mp5/effects/clip_in.prefab",
            "assets/prefabs/weapons/mp5/effects/clip_out.prefab",
            "assets/prefabs/weapons/mp5/effects/deploy.prefab",
            "assets/prefabs/weapons/mp5/effects/dryfire.prefab",
            "assets/prefabs/weapons/mp5/effects/eject_shell.prefab",
            "assets/prefabs/weapons/mp5/effects/fire_select.prefab",
            "assets/prefabs/weapons/mp5/effects/muzzleflash_flamelet.prefab",
            "assets/prefabs/weapons/mp5/effects/w_drop_magazine.prefab",
            "assets/prefabs/weapons/mp5/effects/w_eject_pistol_shell.prefab",
            "assets/prefabs/weapons/nailgun/effects/attack.prefab",
            "assets/prefabs/weapons/nailgun/effects/attack_shake.prefab",
            "assets/prefabs/weapons/nailgun/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/nailgun/effects/clip_in.prefab",
            "assets/prefabs/weapons/nailgun/effects/clip_out.prefab",
            "assets/prefabs/weapons/nailgun/effects/deploy.prefab",
            "assets/prefabs/weapons/pickaxe/effects/attack.prefab",
            "assets/prefabs/weapons/pickaxe/effects/deploy.prefab",
            "assets/prefabs/weapons/pickaxe/effects/strike-muted.prefab",
            "assets/prefabs/weapons/pickaxe/effects/strike-soft.prefab",
            "assets/prefabs/weapons/pickaxe/effects/strike.prefab",
            "assets/prefabs/weapons/pickaxe/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/pickaxe/effects/throw.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/attack.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/attack_shake.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/close_pipe.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/deploy.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/dryfire.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/holster.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/insert_shell.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/pfx_open_barrel_smoke.prefab",
            "assets/prefabs/weapons/pipe shotgun/effects/reload_start.prefab",
            "assets/prefabs/weapons/python/effects/attack.prefab",
            "assets/prefabs/weapons/python/effects/attack_shake.prefab",
            "assets/prefabs/weapons/python/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/python/effects/close_cylinder.prefab",
            "assets/prefabs/weapons/python/effects/deploy.prefab",
            "assets/prefabs/weapons/python/effects/dryfire.prefab",
            "assets/prefabs/weapons/python/effects/eject_shells.prefab",
            "assets/prefabs/weapons/python/effects/insert_shells.prefab",
            "assets/prefabs/weapons/python/effects/open_cylinder.prefab",
            "assets/prefabs/weapons/python/effects/pfx_open_cylinder_smoke.prefab",
            "assets/prefabs/weapons/python/effects/w_eject_pistol_shells.prefab",
            "assets/prefabs/weapons/revolver/effects/attack.prefab",
            "assets/prefabs/weapons/revolver/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/revolver/effects/attack_shake.prefab",
            "assets/prefabs/weapons/revolver/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/revolver/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/revolver/effects/deploy.prefab",
            "assets/prefabs/weapons/revolver/effects/dryfire.prefab",
            "assets/prefabs/weapons/revolver/effects/eject_shells.prefab",
            "assets/prefabs/weapons/revolver/effects/insert_shells.prefab",
            "assets/prefabs/weapons/revolver/effects/open_cylinder.prefab",
            "assets/prefabs/weapons/revolver/effects/prime_striker.prefab",
            "assets/prefabs/weapons/revolver/effects/shut_cylinder.prefab",
            "assets/prefabs/weapons/revolver/effects/w_eject_pistol_shells.prefab",
            "assets/prefabs/weapons/rock/effects/attack.prefab",
            "assets/prefabs/weapons/rock/effects/deploy.prefab",
            "assets/prefabs/weapons/rock/effects/strike.prefab",
            "assets/prefabs/weapons/rock/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/rock/effects/throw.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/attack.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/deploy.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/dryfire.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/fire.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/grab_handle.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/holster.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/pfx_close_hatch_smoke.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/pfx_fire_rocket_smokeout.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/pfx_open_hatch_smokeout.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/pfx_rocket_insert_smoke.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/pfx_rocket_insert_sparks.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/reload_begin.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/reload_close_hatch.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/reload_end.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/reload_insert_rocket.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/reload_open_hatch.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/rocket_explosion.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/rocket_explosion_incendiary.prefab",
            "assets/prefabs/weapons/rocketlauncher/effects/rocket_launch_fx.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/attack1.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/attack2.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/deploy.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/holster.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/strike-muted.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/strike-soft.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/strike.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/tap.prefab",
            "assets/prefabs/weapons/salvaged_axe/effects/throw.prefab",
            "assets/prefabs/weapons/salvaged_hammer/effects/attack1.prefab",
            "assets/prefabs/weapons/salvaged_hammer/effects/attack2.prefab",
            "assets/prefabs/weapons/salvaged_hammer/effects/deploy.prefab",
            "assets/prefabs/weapons/salvaged_hammer/effects/holster.prefab",
            "assets/prefabs/weapons/salvaged_hammer/effects/strike.prefab",
            "assets/prefabs/weapons/salvaged_hammer/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/salvaged_hammer/effects/throw.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/attack.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/deploy.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/holster.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/strike-muted.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/strike-soft.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/strike.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/tap.prefab",
            "assets/prefabs/weapons/salvaged_icepick/effects/throw.prefab",
            "assets/prefabs/weapons/satchelcharge/effects/deploy.prefab",
            "assets/prefabs/weapons/satchelcharge/effects/satchel-charge-explosion.prefab",
            "assets/prefabs/weapons/satchelcharge/effects/throw.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/attack.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/attack_pumpaction.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/attack_shake.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/deploy.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/deploy2.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/dryfire.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/flipover.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/insert_shell.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/pump_forward.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/reload_start.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/shell_smoke.prefab",
            "assets/prefabs/weapons/sawnoff_shotgun/effects/w_eject_shotgun_shell.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/attack.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/attack_shake.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/deploy.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/dryfire.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/eject_clip.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/eject_pistol_shell.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/grab_clip.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/insert_clip.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/slide_back.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/slide_shut.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/w_drop_mag.prefab",
            "assets/prefabs/weapons/semi auto pistol/effects/w_eject_pistol_shell.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/attack.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/attack_shake.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/bolt_back.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/bolt_forward.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/clip_in.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/clip_out.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/clip_slap.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/deploy.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/deploy_grab_forearm.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/dryfire.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/eject_rifle_shell.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/w_drop_magazine.prefab",
            "assets/prefabs/weapons/semi auto rifle/effects/w_eject_rifle_shell.prefab",
            "assets/prefabs/weapons/smg/effects/attack.prefab",
            "assets/prefabs/weapons/smg/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/smg/effects/attack_shake.prefab",
            "assets/prefabs/weapons/smg/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/smg/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/smg/effects/bolt_back.prefab",
            "assets/prefabs/weapons/smg/effects/bolt_shut.prefab",
            "assets/prefabs/weapons/smg/effects/clip_in.prefab",
            "assets/prefabs/weapons/smg/effects/clip_out.prefab",
            "assets/prefabs/weapons/smg/effects/deploy.prefab",
            "assets/prefabs/weapons/smg/effects/dryfire.prefab",
            "assets/prefabs/weapons/smg/effects/eject_shell.prefab",
            "assets/prefabs/weapons/smg/effects/reload_start.prefab",
            "assets/prefabs/weapons/smg/effects/w_drop_magazine.prefab",
            "assets/prefabs/weapons/smg/effects/w_eject_pistol_shell.prefab",
            "assets/prefabs/weapons/spas12/effects/attack.prefab",
            "assets/prefabs/weapons/spas12/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/spas12/effects/attack_shake.prefab",
            "assets/prefabs/weapons/spas12/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/spas12/effects/deploy.prefab",
            "assets/prefabs/weapons/spas12/effects/dryfire.prefab",
            "assets/prefabs/weapons/spas12/effects/eject_shell.prefab",
            "assets/prefabs/weapons/spas12/effects/insert_shell.prefab",
            "assets/prefabs/weapons/spas12/effects/insert_shell_breach.prefab",
            "assets/prefabs/weapons/spas12/effects/pump_back.prefab",
            "assets/prefabs/weapons/spas12/effects/pump_forward.prefab",
            "assets/prefabs/weapons/spas12/effects/w_eject_shotgun_shell.prefab",
            "assets/prefabs/weapons/stone hatchet/effects/attack_shake.prefab",
            "assets/prefabs/weapons/stone hatchet/effects/deploy.prefab",
            "assets/prefabs/weapons/stone hatchet/effects/strike-muted.prefab",
            "assets/prefabs/weapons/stone hatchet/effects/strike-soft.prefab",
            "assets/prefabs/weapons/stone hatchet/effects/strike.prefab",
            "assets/prefabs/weapons/stone hatchet/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/stone hatchet/effects/swing.prefab",
            "assets/prefabs/weapons/stone hatchet/effects/throw.prefab",
            "assets/prefabs/weapons/stone pickaxe/effects/attack.prefab",
            "assets/prefabs/weapons/stone pickaxe/effects/deploy.prefab",
            "assets/prefabs/weapons/stone pickaxe/effects/strike-muted.prefab",
            "assets/prefabs/weapons/stone pickaxe/effects/strike-soft.prefab",
            "assets/prefabs/weapons/stone pickaxe/effects/strike.prefab",
            "assets/prefabs/weapons/stone pickaxe/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/stone pickaxe/effects/swing.prefab",
            "assets/prefabs/weapons/stone pickaxe/effects/throw.prefab",
            "assets/prefabs/weapons/stone spear/effects/2hand_deploy.prefab",
            "assets/prefabs/weapons/stone spear/effects/attack.prefab",
            "assets/prefabs/weapons/stone spear/effects/deploy.prefab",
            "assets/prefabs/weapons/stone spear/effects/holster.prefab",
            "assets/prefabs/weapons/stone spear/effects/pull_out.prefab",
            "assets/prefabs/weapons/stone spear/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/stone spear/effects/strike_stone-muted.prefab",
            "assets/prefabs/weapons/stone spear/effects/strike_stone-soft.prefab",
            "assets/prefabs/weapons/stone spear/effects/strike_stone.prefab",
            "assets/prefabs/weapons/stone spear/effects/throw.prefab",
            "assets/prefabs/weapons/sword big/effects/attack-1.prefab",
            "assets/prefabs/weapons/sword big/effects/attack-2.prefab",
            "assets/prefabs/weapons/sword big/effects/attack-3.prefab",
            "assets/prefabs/weapons/sword big/effects/deploy.prefab",
            "assets/prefabs/weapons/sword big/effects/hit-muted.prefab",
            "assets/prefabs/weapons/sword big/effects/hit-soft.prefab",
            "assets/prefabs/weapons/sword big/effects/hit.prefab",
            "assets/prefabs/weapons/sword big/effects/throw.prefab",
            "assets/prefabs/weapons/sword/effects/attack-1.prefab",
            "assets/prefabs/weapons/sword/effects/attack-2.prefab",
            "assets/prefabs/weapons/sword/effects/attack-3.prefab",
            "assets/prefabs/weapons/sword/effects/deploy.prefab",
            "assets/prefabs/weapons/sword/effects/hit-muted.prefab",
            "assets/prefabs/weapons/sword/effects/hit-soft.prefab",
            "assets/prefabs/weapons/sword/effects/hit.prefab",
            "assets/prefabs/weapons/sword/effects/throw.prefab",
            "assets/prefabs/weapons/thompson/effects/attack.prefab",
            "assets/prefabs/weapons/thompson/effects/attack_muzzlebrake.prefab",
            "assets/prefabs/weapons/thompson/effects/attack_shake.prefab",
            "assets/prefabs/weapons/thompson/effects/attack_shake_ads.prefab",
            "assets/prefabs/weapons/thompson/effects/attack_silenced.prefab",
            "assets/prefabs/weapons/thompson/effects/bolt_action.prefab",
            "assets/prefabs/weapons/thompson/effects/deploy.prefab",
            "assets/prefabs/weapons/thompson/effects/dryfire.prefab",
            "assets/prefabs/weapons/thompson/effects/eject_pistol_shell.prefab",
            "assets/prefabs/weapons/thompson/effects/holster.prefab",
            "assets/prefabs/weapons/thompson/effects/idle_finger_taps.prefab",
            "assets/prefabs/weapons/thompson/effects/insert_clip.prefab",
            "assets/prefabs/weapons/thompson/effects/reload_begin.prefab",
            "assets/prefabs/weapons/thompson/effects/remove_clip.prefab",
            "assets/prefabs/weapons/thompson/effects/safety_off.prefab",
            "assets/prefabs/weapons/thompson/effects/w_drop_magazine.prefab",
            "assets/prefabs/weapons/thompson/effects/w_eject_pistol_shell.prefab",
            "assets/prefabs/weapons/toolgun/effects/attack.prefab",
            "assets/prefabs/weapons/toolgun/effects/lineeffect.prefab",
            "assets/prefabs/weapons/toolgun/effects/lineeffect_realistic.prefab",
            "assets/prefabs/weapons/toolgun/effects/repairerror.prefab",
            "assets/prefabs/weapons/toolgun/effects/ringeffect.prefab",
            "assets/prefabs/weapons/toolgun/effects/ringeffect_realistic.prefab",
            "assets/prefabs/weapons/torch/effects/attack.prefab",
            "assets/prefabs/weapons/torch/effects/attack_lit.prefab",
            "assets/prefabs/weapons/torch/effects/deploy.prefab",
            "assets/prefabs/weapons/torch/effects/extinguish.prefab",
            "assets/prefabs/weapons/torch/effects/ignite.prefab",
            "assets/prefabs/weapons/torch/effects/strike.prefab",
            "assets/prefabs/weapons/torch/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/torch/effects/torch_loop.prefab",
            "assets/prefabs/weapons/waterbucket/effects/deploy.prefab",
            "assets/prefabs/weapons/waterbucket/effects/fillbucket_fromcontainer.prefab",
            "assets/prefabs/weapons/waterbucket/effects/fillbucket_fromworld.prefab",
            "assets/prefabs/weapons/waterbucket/effects/waterbucket_splash.prefab",
            "assets/prefabs/weapons/waterbucket/effects/waterimpact_explosion.prefab",
            "assets/prefabs/weapons/waterbucket/effects/waterthrow.prefab",
            "assets/prefabs/weapons/waterbucket/effects/waterthrow3p.prefab",
            "assets/prefabs/weapons/wooden spear/effects/2hand_deploy.prefab",
            "assets/prefabs/weapons/wooden spear/effects/attack.prefab",
            "assets/prefabs/weapons/wooden spear/effects/deploy.prefab",
            "assets/prefabs/weapons/wooden spear/effects/holster.prefab",
            "assets/prefabs/weapons/wooden spear/effects/pull_out.prefab",
            "assets/prefabs/weapons/wooden spear/effects/strike_screenshake.prefab",
            "assets/prefabs/weapons/wooden spear/effects/strike_wood-muted.prefab",
            "assets/prefabs/weapons/wooden spear/effects/strike_wood-soft.prefab",
            "assets/prefabs/weapons/wooden spear/effects/strike_wood.prefab",
            "assets/prefabs/weapons/wooden spear/effects/throw.prefab",
            "assets/rust.ai/nextai/effects/dusttrail.prefab",
            "assets/standard assets/third party/camelotvfx_adv_water_fx/prefabs/splash_v3.prefab",
            "assets/standard assets/third party/detailed_pyro_fx/prefabs/4096/smoke_04.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion1.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion10.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion11.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion12.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion13.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion2.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_1.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_10.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_11.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_12.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_13.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_2.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_3.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_4.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_5.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_6.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_7.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_8.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion3d_9.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion4.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion5.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion6.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion7.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion8.prefab",
            "assets/third party/kriptofx/explosions/prefabs/mobile/mobileexplosion9.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion1.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion10.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion11.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion12.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion13.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion2.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_1.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_10.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_11.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_12.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_13.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_2.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_3.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_4.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_5.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_6.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_7.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_8.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion3d_9.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion4.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion5.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion6.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion7.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion8.prefab",
            "assets/third party/kriptofx/explosions/prefabs/pc/explosion9.prefab",
        };

        #endregion

        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            PrintWarning("" +
                "\n===================== Автор : Mercury" +
                "\n===================== Моя группа с разработкой плагинов - https://vk.com/mercurydev" +
                "\n===================== Мой ВК - https://vk.com/mir_inc" +
                $"\n===================== Иконок - {IconsRust.Count}" +
                $"\n===================== Материалов - {Materials.Count}" +
                $"\n===================== Шрифтов - {Fonts.Count}" +
                $"\n===================== Эффектов - {EffectRustList.Count}");
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (!HexTakePlayer.ContainsKey(player.userID))
                HexTakePlayer.Add(player.userID, "#FFFFFFFF");
        }
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, PARENT_UI);
                CuiHelper.DestroyUi(player, PARENT_UI_HEX_SETTINGS);
                DestroyedLayer(player);
            }
        }
        #endregion

        #region Func Command

        [ConsoleCommand("utilites")] 
        void MercuryUtilitesCommands(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            string Key = arg.Args[0].ToLower();
            switch (Key)
            {
                case "icons":
                    {
                        string Hex = HexTakePlayer[player.userID];
                        int Page = Convert.ToInt32(arg.Args[1]);
                        UI_IconsLoaded(player, 0, Hex);
                        break;
                    }
                case "materials":
                    {
                        string Hex = HexTakePlayer[player.userID];
                        int Page = Convert.ToInt32(arg.Args[1]);
                        UI_MaterialLoaded(player, Page, Hex);
                        break;
                    }
                case "iconstwo":
                    {
                        string Hex = HexTakePlayer[player.userID];
                        int Page = Convert.ToInt32(arg.Args[1]);
                        UI_IconsLoadedMaterial(player, 0, Hex);
                        break;
                    }
                case "fonts":
                    {
                        string Hex = HexTakePlayer[player.userID];
                        int Page = Convert.ToInt32(arg.Args[1]);
                        UI_FontsLoaded(player, 0, Hex);
                        break;
                    }         
                case "effect":
                    {
                        int Page = Convert.ToInt32(arg.Args[1]);
                        UI_EffectLoaded(player, 0);
                        break;
                    }
                case "page_icons":
                    {
                        string PageAction = arg.Args[1];
                        int Page = Convert.ToInt32(arg.Args[2]);
                        switch (PageAction)
                        {
                            case "next":
                                {
                                    string Hex = HexTakePlayer[player.userID];

                                    UI_IconsLoaded(player, Page + 1, Hex);
                                    break;
                                }
                            case "back":
                                {
                                    string Hex = HexTakePlayer[player.userID];

                                    UI_IconsLoaded(player, Page - 1, Hex);
                                    break;
                                }
                        }
                        break;
                    }
                case "page_icons_two":
                    {
                        string PageAction = arg.Args[1];
                        int Page = Convert.ToInt32(arg.Args[2]);
                        switch (PageAction)
                        {
                            case "next":
                                {
                                    string Hex = HexTakePlayer[player.userID];

                                    UI_IconsLoadedMaterial(player, Page + 1, Hex);
                                    break;
                                }
                            case "back":
                                {
                                    string Hex = HexTakePlayer[player.userID];

                                    UI_IconsLoadedMaterial(player, Page - 1, Hex);
                                    break;
                                }
                        }
                        break;
                    }
                case "page_materials":
                    {
                        string PageAction = arg.Args[1];
                        int Page = Convert.ToInt32(arg.Args[2]);
                        switch (PageAction)
                        {
                            case "next":
                                {
                                    string Hex = HexTakePlayer[player.userID];

                                    UI_MaterialLoaded(player, Page + 1, Hex);
                                    break;
                                }
                            case "back":
                                {
                                    string Hex = HexTakePlayer[player.userID];

                                    UI_MaterialLoaded(player, Page - 1, Hex);
                                    break;
                                }
                        }
                        break;
                    }
                case "page_effect":
                    {
                        string PageAction = arg.Args[1];
                        int Page = Convert.ToInt32(arg.Args[2]);
                        switch (PageAction)
                        {
                            case "next":
                                {
                                    UI_EffectLoaded(player, Page + 1);
                                    break;
                                }
                            case "back":
                                {
                                    UI_EffectLoaded(player, Page - 1);
                                    break;
                                }
                        }
                        break;
                    }
                case "show_hex": 
                    {
                        UI_HexSettingsMenu(player);
                        break;
                    }
                case "set_hex": 
                    {
                        string Hex = arg.Args[1];
                        HexTakePlayer[player.userID] = Hex;
                        CuiHelper.DestroyUi(player, PARENT_UI_HEX_SETTINGS);
                        PrintToChat($"Успешно установлен цвет {Hex}");
                        PrintToConsole($"Успешно установлен цвет {Hex}");
                        Puts($"Успешно установлен цвет {Hex}");
                        break;
                    }
                case "save_element": 
                    {
                        string Path = arg.Args[1];
                        PrintWarning(Path);
                        PrintToConsole(Path);
                        PrintToChat(Path);
                        break;
                    }
                case "sound_play":
                    {
                        string Path = arg.Args[1];
                        string Title = arg.Args[2];
                        int Page = Convert.ToInt32(arg.Args[3]);
                        CuiHelper.DestroyUi(player, PARENT_UI);
                        UI_Plaeer(player, Title,Path, Page);
                        break;
                    }
            }
        }

        [ChatCommand("ut")]
        void ChatCommandUtilites(BasePlayer player)
        {
            UI_PanelReportsPlayer(player);
        }

        [ConsoleCommand("ut")]
        void ConsoleCommandUtilMer(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            UI_PanelReportsPlayer(player);

        }

        #endregion

        #region UI
        public static string PARENT_UI = "MERCURY_PANEL_UI";
        public static string PARENT_UI_BUTTON = "MERCURY_PARENT_UI_BUTTON";

        public static string PARENT_UI_ELEMENT = "MERCURY_PARENT_UI_ELEMENT";
        public static string PARENT_UI_ELEMENT_ICONS = "PARENT_UI_ELEMENT_ICONS";
        public static string PARENT_UI_ELEMENT_ICONSTWO = "PARENT_UI_ELEMENT_ICONSTWO";

        public static string PARENT_UI_ELEMENT_MATERIAL = "PARENT_UI_ELEMENT_MATERIAL";

        public static string PARENT_UI_ELEMENT_FONTS = "PARENT_UI_ELEMENT_FONTS";

        public static string PARENT_UI_ELEMENT_EFFECT = "PARENT_UI_ELEMENT_EFFECT";
        public static string PARENT_UI_ELEMENT_EFFECT_PLAYER = "PARENT_UI_ELEMENT_EFFECT_PLAYER";

        public static string PARENT_UI_HEX_SETTINGS = "PARENT_UI_HEX_SETTINGS";

        #region MainPanel
        void UI_PanelReportsPlayer(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1"},
                Image = { Color = HexToRustFormat("#21211AF2"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  "Overlay",PARENT_UI);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8407407", AnchorMax = "1 0.9268518" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI, PARENT_UI_BUTTON);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.9305556", AnchorMax = "1 1" },
                Text = { Text = $"<b><size=30>MERCURY UTILITES</size></b>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI);

            #region BTNS
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.1671875 1" },
                Button = { Command = $"utilites icons {0}", Color = HexToRustFormat("#3E482EFF") },
                Text = { Text = "<b><size=20>ИКОНКИ ИЗ ИГРЫ</size></b>", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_BUTTON);
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1718755 0", AnchorMax = "0.3390611 1" },
                Button = { Command = $"utilites materials {0}", Color = HexToRustFormat("#3E482EFF") },
                Text = { Text = "<b><size=20>МАТЕРИАЛЫ ИЗ ИГРЫ</size></b>", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_BUTTON);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3442709 0", AnchorMax = "0.5114543 1" },
                Button = { Command = $"utilites iconstwo {0}", Color = HexToRustFormat("#3E482EFF") },
                Text = { Text = "<b><size=20>ИКОНКИ ИЗ ИГРЫ С МАТЕРИАЛОМ</size></b>", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_BUTTON);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5156225 0", AnchorMax = "0.6828059 1" },
                Button = { Command = $"utilites fonts {0}", Color = HexToRustFormat("#3E482EFF") },
                Text = { Text = "<b><size=20>ШРИФТЫ</size></b>", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_BUTTON);  

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.6890574 0", AnchorMax = "0.8562407 1" },
                Button = { Command = $"utilites effect {0}", Color = HexToRustFormat("#3E482EFF") },
                Text = { Text = "<b><size=20>ЭФФЕКТЫ</size></b>", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_BUTTON);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.8" },
                Text = { Text = $"<b>Автор : Mercury\n\nМоя группа с разработкой плагинов - https://vk.com/mercurydev \n\nМой ВК - https://vk.com/mir_inc </b>", Font = "robotocondensed-bold.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter }
            },  PARENT_UI, "WELCOME_TITLE");
            #endregion

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.8314815" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI, PARENT_UI_ELEMENT);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.004687482 0.01113585", AnchorMax = "0.15 0.06347439" },
                Button = { Close = PARENT_UI, Color = HexToRustFormat("#B4371EFF") },
                Text = { Text = "<b><size=16>ЗАКРЫТЬ</size></b>", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_ELEMENT);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1583337 0.01113585", AnchorMax = "0.303645 0.06347439" },
                Button = { Command = "utilites show_hex", Color = HexToRustFormat("#3E482EFF") },
                Text = { Text = "<b><size=16>СМЕНИТЬ ЦВЕТ</size></b>", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_ELEMENT);


            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Icons
        
        void UI_IconsLoaded(BasePlayer player, int Page = 0, string Hex = "#FFFFFFFF")
        {
            CuiElementContainer container = new CuiElementContainer();
            DestroyedLayer(player);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.07683742", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_ELEMENT, PARENT_UI_ELEMENT_ICONS);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5015628 0.004454346", AnchorMax = "0.5312498 0.06681515" },
                Text = { Text = $"<size=30>{Page}</size>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_ELEMENT, "PAGE_TITLE");

            if ((IconsRust.Count - (Page * 199)) > 199)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5385414 0.004454346", AnchorMax = "0.5682284 0.07015589" },
                    Button = { Command = $"utilites page_icons next {Page}", Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20>></size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_ELEMENT, "PAGE_NEXT");
            }

            if (Page > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4677091 0.004454346", AnchorMax = "0.4973962 0.07015589" },
                    Button = { Command = $"utilites page_icons back {Page}", Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20><</size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_ELEMENT, "PAGE_BACK");
            }

            int i = 0, x = 0, y = 0;
            foreach (var Sprite in IconsRust.Skip(Page * 199))
            {
                container.Add(new CuiElement
                {
                    Name = $"ICON_{i}",
                    Parent = PARENT_UI_ELEMENT_ICONS,
                    Components =
                    {
                        new CuiRawImageComponent {  Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = $"{0.004687482 + (x * 0.05)} {0.9071308 - (y * 0.1)}", AnchorMax = $"{0.04218748 + (x * 0.05)} {0.9936692 - (y * 0.1)}" },
                        new CuiOutlineComponent { Color = HexToRustFormat("#3E482EFF") ,Distance = "0.2 -0.2" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = $"ICON_{i}",
                    Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Hex), Sprite = Sprite },
                        new CuiRectTransformComponent { AnchorMin = $"0.05555556 0.05555553", AnchorMax = $"0.9444445 0.9444441" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"utilites save_element {Sprite}", Color = "0 0 0 0" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                },  $"ICON_{i}");

                i++;
                x++;
                if(x == 20)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 10) break;
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Icons#2

        void UI_IconsLoadedMaterial(BasePlayer player, int Page = 0, string Hex = "#FFFFFFFF")
        {
            CuiElementContainer container = new CuiElementContainer();
            DestroyedLayer(player);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.07683742", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_ELEMENT, PARENT_UI_ELEMENT_ICONSTWO);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5015628 0.004454346", AnchorMax = "0.5312498 0.06681515" },
                Text = { Text = $"<size=30>{Page}</size>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_ELEMENT, "PAGE_TITLE");

            if ((IconsRust.Count - (Page * 199)) > 199)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5385414 0.004454346", AnchorMax = "0.5682284 0.07015589" },
                    Button = { Command = $"utilites page_icons_two next {Page}", Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20>></size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_ELEMENT, "PAGE_NEXT");
            }

            if (Page > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4677091 0.004454346", AnchorMax = "0.4973962 0.07015589" },
                    Button = { Command = $"utilites page_icons_two back {Page}", Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20><</size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_ELEMENT, "PAGE_BACK");
            }

            int i = 0, x = 0, y = 0;
            foreach (var Sprite in IconsRust.Skip(Page * 199))
            {
                container.Add(new CuiElement
                {
                    Name = $"ICON_{i}",
                    Parent = PARENT_UI_ELEMENT_ICONSTWO,
                    Components =
                    {
                        new CuiRawImageComponent {  Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = $"{0.004687482 + (x * 0.05)} {0.9071308 - (y * 0.1)}", AnchorMax = $"{0.04218748 + (x * 0.05)} {0.9936692 - (y * 0.1)}" },
                        new CuiOutlineComponent { Color = HexToRustFormat("#3E482EFF") ,Distance = "0.2 -0.2" }
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = $"ICON_{i}",
                    Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Hex), Sprite = Sprite, Material = Sprite },
                        new CuiRectTransformComponent { AnchorMin = $"0.05555556 0.05555553", AnchorMax = $"0.9444445 0.9444441" }
                    }
                });

                string Out = $"В данном случае используйте материал и спрайт для элемента одновременно :\n {Sprite}";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"utilites save_element {Out}", Color = "0 0 0 0" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                }, $"ICON_{i}");

                i++;
                x++;
                if (x == 20)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 10) break;
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Materials
        void UI_MaterialLoaded(BasePlayer player, int Page = 0, string Hex = "#FFFFFFFF")
        {
            CuiElementContainer container = new CuiElementContainer();
            DestroyedLayer(player);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.07683742", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_ELEMENT, PARENT_UI_ELEMENT_MATERIAL);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5015628 0.004454346", AnchorMax = "0.5312498 0.06681515" },
                Text = { Text = $"<size=30>{Page}</size>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_ELEMENT, "PAGE_TITLE");

            if ((Materials.Count - (Page * 45)) > 45)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5385414 0.004454346", AnchorMax = "0.5682284 0.07015589" },
                    Button = { Command = $"utilites page_materials next {Page}", Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20>></size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_ELEMENT, "PAGE_NEXT");
            }

            if (Page > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4677091 0.004454346", AnchorMax = "0.4973962 0.07015589" },
                    Button = { Command = $"utilites page_materials back {Page}", Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20><</size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_ELEMENT, "PAGE_BACK");
            }

            int i = 0, x = 0, y = 0;
            foreach (var Material in Materials.Skip(Page * 45))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.004166649 + (x * 0.206)} {0.9083153 - (y * 0.1)}", AnchorMax = $"{0.1666667 + (x * 0.206)} {0.9951669 - (y * 0.1)}" },
                    Image = { Color = HexToRustFormat(Hex), Material = Material }
                }, PARENT_UI_ELEMENT_MATERIAL, $"MATERIAL_{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"utilites save_element {Material}", Color = "0 0 0 0" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                }, $"MATERIAL_{i}");

                i++;
                x++;
                if (x == 5)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 10) break;
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Fonts
        void UI_FontsLoaded(BasePlayer player, int Page = 0, string Hex = "#FFFFFFFF")
        {
            CuiElementContainer container = new CuiElementContainer();
            DestroyedLayer(player);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.07683742", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_ELEMENT, PARENT_UI_ELEMENT_FONTS);


            int i = 0, x = 0, y = 0;
            foreach (var FontUse in Fonts)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.004166649 + (x * 0.254)} {0.9083153 - (y * 0.1)}", AnchorMax = $"{0.2291667 + (x * 0.254)} {0.9951669 - (y * 0.1)}" },
                    Image = { Color = HexToRustFormat("#3E482EFF") }
                }, PARENT_UI_ELEMENT_FONTS, $"FONT_{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"utilites save_element {FontUse}", Color = "0 0 0 0" },
                    Text = { Text = "Пример текста 12345", Font = FontUse.Replace("assets/content/ui/fonts/",""), Color = HexToRustFormat(Hex), FontSize = 18, Align = TextAnchor.MiddleCenter }
                }, $"FONT_{i}");

                i++;
                x++;
                if (x == 4)
                {
                    x = 0;
                    y++;
                }
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Effects 
        void UI_EffectLoaded(BasePlayer player, int Page = 0)
        {
            CuiElementContainer container = new CuiElementContainer();
            DestroyedLayer(player);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.07683742", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_ELEMENT, PARENT_UI_ELEMENT_EFFECT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5015628 0.004454346", AnchorMax = "0.5312498 0.06681515" },
                Text = { Text = $"<size=30>{Page}</size>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_ELEMENT, "PAGE_TITLE");

            if ((EffectRustList.Count - (Page * 50)) > 50)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5385414 0.004454346", AnchorMax = "0.5682284 0.07015589" },
                    Button = { Command = $"utilites page_effect next {Page}", Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20>></size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_ELEMENT, "PAGE_NEXT");
            }

            if (Page > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4677091 0.004454346", AnchorMax = "0.4973962 0.07015589" },
                    Button = { Command = $"utilites page_effect back {Page}", Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=20><</size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_ELEMENT, "PAGE_BACK");
            }

            int i = Page * 50, x = 0, y = 0;
            foreach (var Effect in EffectRustList.Skip(Page * 50))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.004166649 + (x * 0.204)} {0.9083153 - (y * 0.1)}", AnchorMax = $"{0.1765625 + (x * 0.204)} {0.9951669 - (y * 0.1)}" },
                    Image = { Color = HexToRustFormat("#3E482EFF") }
                }, PARENT_UI_ELEMENT_EFFECT, $"EFFECT_{i}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.7522659 1" },
                    Text = { Text = $"<size=18><b>ЭФФЕКТ #{i}</b></size>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                },  $"EFFECT_{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"utilites save_element {Effect}", Color = "0 0 0 0" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                }, $"EFFECT_{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.7824773 0.06555558", AnchorMax = "0.9788519 0.9167581" },
                    Button = { Command = $"utilites sound_play {Effect} <size=25><b>ЭФФЕКТ#{i}</b></size> {Page}", Color = HexToRustFormat("#06C4FFFF"), Sprite = "assets/icons/voice.png" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                }, $"EFFECT_{i}");

                i++;
                x++;
                if (x == 5)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 10) break;
            }

            CuiHelper.AddUi(player, container);
        }

        #region UI Pleer

        void UI_Plaeer(BasePlayer player, string Title, string Path, int Page = 0)
        {
            CuiElementContainer container = new CuiElementContainer();
            DestroyedLayer(player);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.6907408", AnchorMax = "0.1859375 0.7444444" },
                Image = { Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  "Overlay", PARENT_UI_ELEMENT_EFFECT_PLAYER);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.7754629 1" },
                Text = { Text = $"<size=20><b>{Title}</b></size>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_ELEMENT_EFFECT_PLAYER);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.8055555 0.06555558", AnchorMax = "0.9742223 0.9167581" },
                Image = { Color = HexToRustFormat("#04C4FFFF"), Sprite = "assets/icons/voice.png" }
            }, PARENT_UI_ELEMENT_EFFECT_PLAYER);

            RunEffect(player, Path);
            timer.Once(2f, () => {
                UI_PanelReportsPlayer(player);
                UI_EffectLoaded(player, Page);
            });

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #endregion

        #region HexSettings
        void UI_HexSettingsMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_HEX_SETTINGS);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.2744792 0.06666666", AnchorMax = "0.725 0.8268518" },
                Image = { Color = HexToRustFormat("#54514DFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  "Overlay", PARENT_UI_HEX_SETTINGS);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.9159561", AnchorMax = "1 1" },
                Text = { Text = $"<b><size=20>ВЫБЕРИТЕ ЦВЕТ ДЛЯ ПРЕДПРОСМОТРА</size></b>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  PARENT_UI_HEX_SETTINGS);

            int x = 0, y = 0;
            for (int i = 0; i < HexList.Count; i++)
            {
                string Hex = HexList[i];

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.02312142 + (x * 0.5)} {0.8343483 - (y * 0.1)}", AnchorMax = $"{0.4913295 + (x * 0.5)} {0.9001219 - (y * 0.1)}" },
                    Button = { Command = $"utilites set_hex {Hex}", Close = PARENT_UI_HEX_SETTINGS, Color = HexToRustFormat(Hex) },
                    Text = { Text = $"<b><size=16>{Hex}</size></b>", Align = TextAnchor.MiddleCenter }
                },  PARENT_UI_HEX_SETTINGS, $"BTN_HEX_{i}");

                x++;
                if(x == 2)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 8) break;
            }

            string CustomHex = "";
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02658963 0.08404718", AnchorMax = "0.9815028 0.1327649" },
                Text = { Text = $"<b><size=20>ВВЕДИТЕ СОБСТВЕННЫЙ HEX</size></b>", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_HEX_SETTINGS);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.02312142 0.01340157", AnchorMax = "0.9780346 0.07917558" },
                Image = { Color = HexToRustFormat("#3E482EFF"), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, PARENT_UI_HEX_SETTINGS, PARENT_UI_HEX_SETTINGS + ".Input");

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_HEX_SETTINGS + ".Input",
                Name = PARENT_UI_HEX_SETTINGS + ".Input.Current",
                Components =
                {
                    new CuiInputFieldComponent { Text = CustomHex, FontSize = 18,Command = $"utilites set_hex {CustomHex}", Align = TextAnchor.MiddleCenter, CharsLimit = 10},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        void RunEffect(BasePlayer player, string Path)
        {
            Effect effect = new Effect(Path, player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, player.Connection);
        }

        void DestroyedLayer(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PARENT_UI_ELEMENT_ICONS);
            CuiHelper.DestroyUi(player, PARENT_UI_ELEMENT_ICONSTWO);
            CuiHelper.DestroyUi(player, PARENT_UI_ELEMENT_MATERIAL);
            CuiHelper.DestroyUi(player, PARENT_UI_ELEMENT_EFFECT);
            CuiHelper.DestroyUi(player, PARENT_UI_ELEMENT_FONTS);
            CuiHelper.DestroyUi(player, PARENT_UI_ELEMENT_EFFECT_PLAYER);
            CuiHelper.DestroyUi(player, "WORK_PANEL");
            CuiHelper.DestroyUi(player, "PAGE_TITLE");
            CuiHelper.DestroyUi(player, "PAGE_NEXT");
            CuiHelper.DestroyUi(player, "WELCOME_TITLE");
            CuiHelper.DestroyUi(player, "PAGE_BACK");
        }

        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion
    }
}


// --- End of file: MercuryUtilites.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Vanish.cs ---
// --- Original Local Path: Vanish.cs ---

﻿
using System.Collections.Generic;
using System.Linq;
using Network;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Vanish", "GrazyCat", "0.7.1")]
    [Description("Ваниш как у москвы , и даже круче ! ")]
    public class Vanish : RustPlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {


            [JsonProperty(PropertyName = "Включить звуковой эффект ? (true/false)")]
            public bool PlaySoundEffect;

            [JsonProperty(PropertyName = "Показать индикатор невдимости ? (true/false)")]
            public bool ShowGuiIcon;

            [JsonProperty(PropertyName = "Включить видимость для админов ? (true/false)")]
            public bool VisibleToAdmin;

            [JsonProperty(PropertyName = "Выключить режим призрака  ? (true/false)")]
            public bool Ghost;


            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    PlaySoundEffect = true,
                    ShowGuiIcon = true,
                    VisibleToAdmin = true,
                    Ghost = false
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.PlaySoundEffect == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Не найден конфиг... Создам новый ! ");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Localization

        private new void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantDamageBuilds"] = "<size=15><color=red>Вы не можете повредить обьекты в инвизе!</color></size>",
                ["CantHurtAnimals"] = "<size=15><color=red>Вы не можете убивать животных в инвизе!</color></size>",
                ["CantHurtPlayers"] = "<size=15><color=red>Вы не можете нанести урон по игрока!</color></size>",
                ["VanishCommand"] = "vanish",
                ["NotAllowed"] = "<size=15><color=red>Что то пошло не так !</color></size>",
                ["PlayersOnly"] = "<size=15><color=red>Команда '{0}' может использоваться только игроком!</color></size>",
                ["VanishDisabled"] = "<size=15>Вы <color=red>ВЫКЛЮЧИЛИ</color> инвиз !</size>",
                ["VanishEnabled"] = "<size=15>Вы <color=green>ВКЛЮЧИЛИ</color> инвиз !</size>",
                ["NotAllowedPerm"] = "<size=15><color=red>Что то пошло не так !</color></size>",
                ["LootBlock"] = "<size=15><color=RED>Лутание в инвизе не возможно!</color></size>",
                ["AuthBlock"] = "<size=15><color=RED>Авторизация в инвизе не возможна!</color></size>",
                ["ClAuthBlock"] = "<size=15><color=RED>Очистка в инвизе не возможна!</color></size>",
                ["UpBlock"] = "<size=15><color=RED>Апгрейд  в инвизе не возможен!</color></size>",
                ["DevAuthBlock"] = "<size=15><color=RED>Деавторизация в инвизе не возможна!</color></size>",
                ["RemoveBlock"] = "<size=15><color=RED>Авторизация в инвизе не возможна!</color></size>",
                ["BuildBlock"] = "<size=15><color=RED>Строительство в инвизе не возможно!</color></size>",
                ["PickUpBlock"] = "<size=15><color=RED>Забарть предмет в инвизе не возможно!</color></size>",
                ["GatherBlock"] = "<size=15><color=RED>Добыча  в инвизе не возможна!</color></size>",
                ["DropBlock"] = "<size=15><color=RED>Выкинуть предмет в инвизе не возможно!</color></size>"
            }, this);
        }

        #endregion

        #region Initialization

        private const string defaultEffect = "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab";
        private const string permGhostOff = "vanish.GhostOff";
        private const string permUse = "vanish.use";


        private void Init()
        {
            permission.RegisterPermission(permGhostOff, this);
            permission.RegisterPermission(permUse, this);


            AddCommandAliases("VanishCommand", "VanishChatCmd");



            Unsubscribe();
        }

        private void Subscribe()
        {
            Subscribe(nameof(CanNetworkTo));
            Subscribe(nameof(CanBeTargeted));
            Subscribe(nameof(CanBradleyApcTarget));
            Subscribe(nameof(OnNpcPlayerTarget));
            Subscribe(nameof(OnNpcTarget));
            Subscribe(nameof(OnEntityTakeDamage));
            Subscribe(nameof(OnPlayerSleepEnded));
            Subscribe(nameof(OnPlayerLand));
        }

        private void Unsubscribe()
        {
            Unsubscribe(nameof(CanNetworkTo));
            Unsubscribe(nameof(CanBeTargeted));
            Unsubscribe(nameof(CanBradleyApcTarget));
            Unsubscribe(nameof(OnNpcPlayerTarget));
            Unsubscribe(nameof(OnNpcTarget));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnPlayerLand));
        }

        #endregion

        #region Data Storage

        private class OnlinePlayer
        {
            public BasePlayer Player;
            public bool IsInvisible;
        }

        [OnlinePlayers]
        private Hash<BasePlayer, OnlinePlayer> onlinePlayers = new Hash<BasePlayer, OnlinePlayer>();

        #endregion

        #region Commands

        private void VanishChatCmd(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
            {
                player.Reply(Lang("PlayersOnly", player.Id, command));
                return;
            }

            if (!player.HasPermission(permUse))
            {
                Message(basePlayer, Lang("NotAllowedPerm", player.Id, permUse));
                return;
            }

            if (config.PlaySoundEffect) Effect.server.Run(defaultEffect, basePlayer.transform.position);
            if (IsInvisible(basePlayer)) Reappear(basePlayer);
            else Disappear(basePlayer);
        }

        // Запрет лутания 
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return;
			
            if (IsInvisible(player))
            {
                StopLooting(player);
                return;
            }
        }

        private void StopLooting(BasePlayer player)
        {
            NextTick(player.EndLooting);
            Message(player, "LootBlock");
        }

        //Запрет добычи ресов
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {

            BasePlayer player = entity.ToPlayer();
			
            if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return;
			
            if (IsInvisible(player))
            {
                item.amount = 0;
                Message(player, "GatherBlock");
                return;
            }
        }

        void OnItemDropped(BasePlayer player, Item item)
        {
            Message(player, "DropBlock");
            return;
        }

        #endregion

        #region Vanishing Act

        private void Disappear(BasePlayer basePlayer)
        {
            var connections = new List<Connection>();
            foreach (var target in BasePlayer.activePlayerList)
            {
                if (basePlayer == target || !target.IsConnected) continue;
                if (config.VisibleToAdmin && target.IPlayer.IsAdmin) continue;
                connections.Add(target.net.connection);
            }

            var held = basePlayer.GetHeldEntity();
            if (held != null)
            {
                held.SetHeld(false);
                held.UpdateVisiblity_Invis();
                held.SendNetworkUpdate();
            }

            if (Net.sv.write.Start())
            {
                Net.sv.write.PacketID(Network.Message.Type.EntityDestroy);
                Net.sv.write.EntityID(basePlayer.net.ID);
                Net.sv.write.UInt8((byte)BaseNetworkable.DestroyMode.None);
                Net.sv.write.Send(new SendInfo(connections));
            }

            basePlayer.UpdatePlayerCollider(false);

            if (config.ShowGuiIcon) VanishGui(basePlayer);
            onlinePlayers[basePlayer].IsInvisible = true;
            Message(basePlayer, "VanishEnabled");


            Subscribe();

            BaseEntity.Query.Server.RemovePlayer(basePlayer);

        }

        // Скрыть от игрока
        private object CanNetworkTo(BaseNetworkable entity, BasePlayer target)
        {
            var basePlayer = entity as BasePlayer ?? (entity as HeldEntity)?.GetOwnerPlayer();
            if (basePlayer == null || target == null || basePlayer == target) return null;
            if (config.VisibleToAdmin && target.IPlayer.IsAdmin) return null;
            if (IsInvisible(basePlayer)) return false;
            return null;
        }

        // Скрыть от верта и турелей
        private object CanBeTargeted(BaseCombatEntity entity)
        {
            var basePlayer = entity as BasePlayer;
            if (basePlayer != null && IsInvisible(basePlayer)) return false;

            return null;
        }

        // Скрыть от верта и турелей танка
        private object CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
        {
            var basePlayer = entity as BasePlayer;
            if (basePlayer != null && IsInvisible(basePlayer)) return false;

            return null;
        }

        // Скрыть от верта и турелей танка
        private object CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer basePlayer)
        {
            if (IsInvisible(basePlayer)) return false;

            return null;
        }

        // Скрыть от животных
        private object OnNpcPlayerTarget(NPCPlayerApex npc, BaseEntity entity)
        {
            var basePlayer = entity as BasePlayer;
            if (basePlayer != null && IsInvisible(basePlayer)) return 0f;

            return null;
        }

        // Скрыть от животных
        private object OnNpcTarget(BaseNpc npc, BaseEntity entity)
        {
            var basePlayer = entity as BasePlayer;
            if (basePlayer != null && IsInvisible(basePlayer)) return 0f;

            return null;
        }
        // Скрыть слиперов
        private void OnPlayerSleepEnded(BasePlayer basePlayer)
        {
            if (IsInvisible(basePlayer))
            {
                Disappear(basePlayer);
            }
        }
		// Скрыть слиперов
        private object OnPlayerLand(BasePlayer player, float num)
        {
            if (IsInvisible(player))
            {
                return false;
            }
            return null;
        }
		// Запрет блокировки
        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {

            return null;
        }
        //Запрет на постройку
        private object CanBuild(Planner plan, Construction prefab)
        {
            var player = plan.GetOwnerPlayer();
            if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;
            if (config.Ghost)
            {
                return null;
            }

            if (IsInvisible(player))
            {
                Message(player, "BuildBlock");
                return false;
            }
            return null;
        }
        // Запрет на авторизацию
        private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;

            if (config.Ghost)
            {
                return null;
            }

            if (IsInvisible(player))
            {
                Message(player, "AuthBlock");
                return false;
            }
            return null;
        }

        // Запрет на очистку авторизации
        private object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;
			
            if (config.Ghost)
            {
                return null;
            }

            if (IsInvisible(player))
            {
                Message(player, "ClAuthBlock");
                return false;
            }
            return null;
        }
        //Запрет на деавторизацию из шакафа 
        private object OnCupboardDeauthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;

            if (config.Ghost)
            {
                return null;
            }

            if (IsInvisible(player))
            {
                Message(player, "DevAuthBlock");
                return false;
            }
            return null;
        }
        //Запрет на апгрейд 
        private object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;
			
            if (config.Ghost)
            {
                return null;
            }

            if (IsInvisible(player))
            {
                Message(player, "UpBlock");
                return false;
            }
            return null;
        }

        // Запрет на удаление 
        private object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;
			
            if (config.Ghost)
            {
                return null;
            }

            if (IsInvisible(player))
            {
                Message(player, "RemoveBlock");
                return false;
            }
            return null;
        }

        //Запрет на авторизацию в турели
        private object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;
			
            if (config.Ghost)
            {
                return null;
            }
			
            if (IsInvisible(player))
            {
                Message(player, "AuthBlock");
                return false;
            }
            return null;
        }

        // Запрет на подьем вещей
        private object OnItemPickup(Item item, BasePlayer player)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;
			
            if (config.Ghost)
            {
                return null;
            }
			
            if (IsInvisible(player))
            {
                return false;
            }
            return null;
        }
        //Заперт на выброс предмета 
        private object OnItemAction(Item item, string action, BasePlayer player)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;
			
            if (config.Ghost)
            {
                return null;
            }
            
            if (IsInvisible(player))
            {
                OnItemDropped(player, item);
                return false;
            }
            return null;
        }

        // Запрет на подьем предметов
        private object CanPickupEntity(BaseCombatEntity entity, BasePlayer player)
        {
			if (permission.UserHasPermission(player.UserIDString, permGhostOff)) return null;
			
            if (config.Ghost)
            {
                return null;
            }
            
            if (IsInvisible(player))
            {
                Message(player, "PickUpBlock");
                return false;
            }
            return null;
        }

        // Запрет на испольвание таблички
        // void CanUpdateSign(BasePlayer player, Signage sign)
        // {	
        // if (config.Ghost) 
        // {	
        // return null;
        // }
        // // if (player.HasPermission(permGhostoff)) return null;
        // if (IsInvisible(player))
        // {
        // return true;
        // }
        // return null;
        // }

        #endregion

        #region Reappearing Act

        private void Reappear(BasePlayer basePlayer)
        {
            onlinePlayers[basePlayer].IsInvisible = false;
            basePlayer.SendNetworkUpdate();

            var held = basePlayer.GetHeldEntity();
            if (held != null)
            {
                held.UpdateVisibility_Hand();
                held.SendNetworkUpdate();
            }

            basePlayer.UpdatePlayerCollider(true);

            string gui;
            if (guiInfo.TryGetValue(basePlayer.userID, out gui)) CuiHelper.DestroyUi(basePlayer, gui);

            BaseEntity.Query.Server.AddPlayer(basePlayer);

            Message(basePlayer, "VanishDisabled");
            if (onlinePlayers.Values.Count(p => p.IsInvisible) <= 0) Unsubscribe(nameof(CanNetworkTo));
        }

        #endregion

        #region GUI Indicator

        private Dictionary<ulong, string> guiInfo = new Dictionary<ulong, string>();

        private void VanishGui(BasePlayer basePlayer)
        {
            string gui;
            if (guiInfo.TryGetValue(basePlayer.userID, out gui)) CuiHelper.DestroyUi(basePlayer, gui);

            var elements = new CuiElementContainer();
            guiInfo[basePlayer.userID] = CuiHelper.GetGuid();

            elements.Add(new CuiElement
            {
                Name = guiInfo[basePlayer.userID],
                Components =
                {
                    new CuiRawImageComponent { Color = "1 1 1 1", Url = "https://i.imgur.com/DjlwRwN.png" },
                    new CuiRectTransformComponent { AnchorMin = "0.168 0.018",  AnchorMax = "0.24 0.13" }
                }
            });

            CuiHelper.AddUi(basePlayer, elements);
        }

        #endregion

        #region Damage Blocking

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
			if (entity == null|| info == null) return null;
            var initiator = info?.InitiatorPlayer;
            if (initiator == null) return null;
            var basePlayer = (info?.Initiator as BasePlayer) ?? entity as BasePlayer;
            if (basePlayer == null || !basePlayer.IsConnected || !onlinePlayers[basePlayer].IsInvisible) return null;
            if (permission.UserHasPermission(initiator.UserIDString, permGhostOff)) return null;
            if (entity is BaseNpc)
            {
                Message(basePlayer, "CantHurtAnimals");
                return true;
            }

            // Блок строений
            if (!(entity is BasePlayer))
            {
                Message(basePlayer, "CantDamageBuilds");
                return true;
            }

            // Блок игроков
            if (info?.Initiator is BasePlayer)
            {
                Message(basePlayer, "CantHurtPlayers");
                return true;
            }

            return null;
        }

        #endregion


        #region Weapon Blocking

        private void OnPlayerTick(BasePlayer basePlayer)
        {
            if (!onlinePlayers[basePlayer].IsInvisible) return;

            var held = basePlayer.GetHeldEntity();
        }

        #endregion

        #region Cleanup

        private void Unload()
        {
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                string gui;
                if (guiInfo.TryGetValue(basePlayer.userID, out gui)) CuiHelper.DestroyUi(basePlayer, gui);
            }
        }

        #endregion

        #region Helpers

        private void AddCommandAliases(string key, string command)
        {
            foreach (var language in lang.GetLanguages(this))
            {
                var messages = lang.GetMessages(language, this);
                foreach (var message in messages.Where(m => m.Key.Equals(key))) AddCovalenceCommand(message.Value, command);
            }
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        private void Message(BasePlayer player, string key, params object[] args) =>
            Player.Message(player, Lang(key, player.UserIDString), null);

        private bool IsInvisible(BasePlayer player) => onlinePlayers[player]?.IsInvisible ?? false;

        #endregion
    }
}


// --- End of file: Vanish.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Clean.cs ---
// --- Original Local Path: Clean.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Obj = UnityEngine.Object;


namespace Oxide.Plugins
{
    [Info("Clean", "Frizen", "1.0.0")]

    public class Clean : CovalencePlugin
    {

   
        void OnServerInitialized()
        {
			DoClean();
            InvokeHandler.Instance.InvokeRepeating(DoClean, 60f, 60f);
        }

   
        void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(DoClean);
        }


        void DoClean()
        { 
                foreach (PlayerCorpse corpse_a in Obj.FindObjectsOfType<PlayerCorpse>())
                    corpse_a?.Kill();
                foreach (LootableCorpse corpse_b in Obj.FindObjectsOfType<LootableCorpse>())
                    corpse_b?.Kill();
                foreach (WorldItem witems in Obj.FindObjectsOfType<WorldItem>())
                    witems?.Kill();
                foreach (ModularCar car in Obj.FindObjectsOfType<ModularCar>())
                car?.Kill();
                GC.Collect();
       
        }
    }
}


// --- End of file: Clean.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Friends.cs ---
// --- Original Local Path: Friends.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using ProtoBuf;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Friends", "ServerRust.ru", "1.1.12", ResourceId = 686)]
    public class Friends : CovalencePlugin
    {
        #region Configuration and Stored Data
        private ConfigData configData;
        public Timer mytimer;
        private Dictionary<ulong, PlayerData> FriendsData;
        private readonly Dictionary<ulong, HashSet<ulong>> ReverseData = new Dictionary<ulong, HashSet<ulong>>();
        private static readonly DateTime Epoch = new DateTime(1970, 1, 1);
        private Dictionary<string, double> userCooldowns = new Dictionary<string, double>();

        private class ConfigData
        {
            [JsonProperty("Максимально друзей")]
            public int MaxFriends { get; set; }
            [JsonProperty("Задержка на добавление в друзья (КД)")]
            public double FriendCooldown { get; set; }
            [JsonProperty("Включить настройку авторизации друзей в замках для игрока")]
            public bool ShareCodeLocks { get; set; }
            [JsonProperty("Включить настройку авторизации друзей в турреляъ для игрока")]
            public bool ShareAutoTurrets { get; set; }
            [JsonProperty("Время кэширования")]
            public int CacheTime { get; set; }
        }

        private class PlayerData
        {
            public bool TurrentAuthorization = false;
            public bool AttackFriend = false;
            public bool CodeAuthorization = false;
            public string Name { get; set; } = string.Empty;
            public HashSet<ulong> Friends { get; set; } = new HashSet<ulong>();
            public Dictionary<ulong, int> Cached { get; set; } = new Dictionary<ulong, int>();
            public bool IsCached(ulong userId)
            {
                int time;
                if (!Cached.TryGetValue(userId, out time)) return false;
                if (time >= (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds) return true;
                Cached.Remove(userId);
                return false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                MaxFriends = 5,
                FriendCooldown = 30.0,
                ShareCodeLocks = false,
                ShareAutoTurrets = false,
                CacheTime = 0 //60 * 60 * 24
            };
            Config.WriteObject(config, true);
        }



        #endregion

        #region Localization
        private Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
                {"AlreadyOnList", "{0} уже находится в списке Ваших друзей."},
                {"Disconnected", "Игрока нет в сети"},
                {"CantAddSelf", "Вы не можете добавить себя в друзья."},
                {"FriendAdded", "{0} стал Вашим другом."},
                {"FriendRemoved", "{0} удален из Вашего списка друзей."},
                {"FriendlistFull", "Список Ваших друзей переполнен"},
                {"List", "Список Ваших друзей: {0}:\n{1}"},
                {"MultiplePlayers", "Было найдено несколько игроков, пожалуйста, уточните: {0}"},
                {"NoFriends", "У Вас нет друзей =(."},
                {"NotOnFriendlist", "{0} не найден в вашем списке друзей."},
                {"PlayerNotFound", "Игрок '{0}' не найден."},
                {"Syntax", "<color=blue><size=17>Friends</size><size=15> by Rustplugin.ru</size></color>\n\n<color=blue> Команды:</color>\n<color=blue>/friend add (+)</color> - что бы добавить нового друга\n<color=blue>/friend remove(-) </color>- что бы удалить друга\n<color=blue>/friend list</color>- Список ваших друзей\n<color=blue>/friend accept </color>- Принять заявку в друзья.\n<color=blue>/friend ff </color>- Включение/Отключение урона по вашим друзьям."},
                {"AlreadyPending", "На ваш предыдущий запрос дружбы игрок еще не ответил, ожидайте его ответа!"},
                {"PendingBusy", "У игрока уже есть запрос от другого игрока, ожидайте пока игрок игрок не ответит другому"},
                {"PendingSuccessSend", "Запрос успешно отправлен, ожидайте пока он приймет его."},
                {"PendingNotFound", "К вам нет запросов в друзья"},
                {"Pending", "{0} отправил вам запрос в друзья, чтобы принять введите в чат <color=blue>/friend accept</color>"},
                {"Cooldown", "Извините, но нельзя так часто использовать команду <color=blue>/friend {1}</color>, подождите {0:00}"},
                {"Codelock", "Вы <color={1}>{0}</color> автоматическую авторизацию друзей в Ваших дверях"},
                {"Turrets", "Вы <color={1}>{0}</color> автоматическую авторизацию друзей в Ваших туррелях"},
                {"CodeLocks", "\n<color=blue>/friend codelock</color> - Включить/Отключить авторизацию ваших друзей в ваших дверях" },
                {"Turret", "\n<color=blue>/friend turret</color> - Включить/Отключить авторизацию ваших друзей в ваших туррелях" },
                {"Attack", "Внимание {0} Ваш друг,вы неможете его ранить. Включение/Отключение урона по друзьям /friend ff" },
                {"Attacks", "Вы <color={1}>{0}</color> урон по Вашим друзьям"},
        };

        #endregion

        #region Initialization
        private void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            configData = Config.ReadObject<ConfigData>();
            try
            {
                FriendsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>(nameof(Friends));
            }
            catch
            {
                FriendsData = new Dictionary<ulong, PlayerData>();
            }

            foreach (var data in FriendsData)
                foreach (var friend in data.Value.Friends)
                    AddFriendReverse(data.Key, friend);
        }

        void OnServerSave()
        {
            SaveFriends();
        }

        void Unload()
        {
            SaveFriends();
        }
        #endregion

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity targ)
        {
            if (!configData.ShareAutoTurrets || !(targ is BasePlayer) || turret.OwnerID <= 0) return null;
            var player = (BasePlayer)targ;
            if (turret.IsAuthed(player) || !HasFriend(turret.OwnerID, player.userID)) return null;
            if (FriendsData.ContainsKey(turret.OwnerID))
                if (FriendsData[turret.OwnerID].TurrentAuthorization)
                {
                    turret.authorizedPlayers.Add(new PlayerNameID
                    {
                        userid = player.userID,
                        username = player.displayName
                    });
                    turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    return false;
                }
            return null;
        }

        object CanUseLockedEntity(BasePlayer player, BaseLock @lock)
        {
            if (!configData.ShareCodeLocks || !(@lock is CodeLock) || @lock.GetParentEntity().OwnerID <= 0) return null;
            if (@lock.GetParentEntity().OwnerID == player.userID) return null;
            if (HasFriend(@lock.GetParentEntity().OwnerID, player.userID))
            {
                if (FriendsData.ContainsKey(@lock.GetParentEntity().OwnerID))
                    if (FriendsData[@lock.GetParentEntity().OwnerID].CodeAuthorization) return true;
            }
            return null;
        }

        public Dictionary<BasePlayer, int> CooldownList = new Dictionary<BasePlayer, int>();

        void OnEntityTakeDamage(BaseCombatEntity vic, HitInfo info)
        {
            try
            {
                if (vic != null && vic is BasePlayer && info?.Initiator != null && info.Initiator is BasePlayer && vic != info.Initiator)
                {
                    BasePlayer vitim = vic as BasePlayer;
                    if (vitim == null) return;
                    BasePlayer iniciator = info.Initiator as BasePlayer;
                    if (iniciator == null) return;
                    if (HasFriend(iniciator.userID, vitim.userID))
                    {
                        if (!FriendsData[iniciator.userID].AttackFriend)
                        {
                            info.damageTypes?.ScaleAll(0f);
                            if (CooldownList.ContainsKey(iniciator) && CooldownList[iniciator] < GrabCurrentTime())
                            {
                                CooldownList[iniciator] = (int)GrabCurrentTime() + 30;
                                iniciator.ChatMessage(string.Format(Messages["Attack"], vitim.displayName));
                            }
                            if (!CooldownList.ContainsKey(iniciator))
                            {
                                CooldownList[iniciator] = (int)GrabCurrentTime() + 30;
                                iniciator.ChatMessage(string.Format(Messages["Attack"], vitim.displayName));
                            }
                        }
                    }
                }
            }
            catch (NullReferenceException)
            {
            }
        }

        private void SaveFriends()
        {
            if (FriendsData != null ) Interface.Oxide.DataFileSystem.WriteObject("Friends", FriendsData);
        }

        #region Add/Remove Friends

        private bool AddFriend(ulong playerId, ulong friendId)
        {
            var playerData = GetPlayerData(playerId);
            if (playerData.Friends.Count >= configData.MaxFriends || !playerData.Friends.Add(friendId)) return false;
            var playerData2 = GetPlayerData(friendId);
            if (playerData2.Friends.Count >= configData.MaxFriends || !playerData2.Friends.Add(playerId)) return false;
            AddFriendReverse(playerId, friendId);
            AddFriendReverse(friendId, playerId);
            Interface.Oxide.CallHook("OnFriendAdded", playerId.ToString(), friendId.ToString());
            return true;
        }

        private bool AddFriendS(string playerS, string friendS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(friendS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var friendId = Convert.ToUInt64(friendS);
            return AddFriend(playerId, friendId);
        }

        private bool RemoveFriend(ulong playerId, ulong friendId)
        {
            var playerData = GetPlayerData(playerId);
            if (!playerData.Friends.Remove(friendId)) return false;
            if (!GetPlayerData(friendId).Friends.Remove(playerId)) return false;
            HashSet<ulong> friends;
            var reply = 596;
            if (reply == 0) { };
            if (ReverseData.TryGetValue(friendId, out friends))
                friends.Remove(playerId);
            if (ReverseData.TryGetValue(playerId, out friends))
                friends.Remove(friendId);
            if (configData.CacheTime > 0)
                playerData.Cached[friendId] = (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds + configData.CacheTime;

            if (configData.ShareAutoTurrets)
            {
                var turrets = UnityEngine.Object.FindObjectsOfType<AutoTurret>();
                foreach (var turret in turrets)
                {
                    if (turret.OwnerID != playerId) continue;
                    turret.authorizedPlayers.RemoveAll(a => a.userid == friendId);
                }
            }
            if (configData.ShareCodeLocks)
            {
                var codeLocks = UnityEngine.Object.FindObjectsOfType<CodeLock>();
                foreach (var codeLock in codeLocks)
                {
                    var entity = codeLock.GetParentEntity();
                    if (entity == null || entity.OwnerID != playerId) continue;
                    var whitelistPlayers = (List<ulong>)codeLock.whitelistPlayers;
                    whitelistPlayers.RemoveAll(a => a == friendId);
                }
            }
            Interface.Oxide.CallHook("OnFriendRemoved", playerId.ToString(), friendId.ToString());
            return true;
        }

        private bool RemoveFriendS(string playerS, string friendS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(friendS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var friendId = Convert.ToUInt64(friendS);
            return RemoveFriend(playerId, friendId);
        }

        #endregion

        #region Friend Checks

        private bool HasFriend(ulong playerId, ulong friendId) => GetPlayerData(playerId).Friends.Contains(friendId);

        private bool HasFriendS(string playerS, string friendS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(friendS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var friendId = Convert.ToUInt64(friendS);
            return HasFriend(playerId, friendId);
        }

        private bool HadFriend(ulong playerId, ulong friendId)
        {
            var playerData = GetPlayerData(playerId);
            return playerData.Friends.Contains(friendId) || playerData.IsCached(friendId);
        }

        private bool HadFriendS(string playerS, string friendS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(friendS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var friendId = Convert.ToUInt64(friendS);
            return HadFriend(playerId, friendId);
        }

        private bool AreFriends(ulong playerId, ulong friendId)
        {
            return GetPlayerData(playerId).Friends.Contains(friendId) && GetPlayerData(friendId).Friends.Contains(playerId);
        }

        private bool AreFriendsS(string playerS, string friendS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(friendS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var friendId = Convert.ToUInt64(friendS);
            return AreFriends(playerId, friendId);
        }

        private bool WereFriends(ulong playerId, ulong friendId)
        {
            var playerData = GetPlayerData(playerId);
            var friendData = GetPlayerData(friendId);
            return (playerData.Friends.Contains(friendId) || playerData.IsCached(friendId)) && (friendData.Friends.Contains(playerId) || friendData.IsCached(playerId));
        }

        private bool WereFriendsS(string playerS, string friendS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(friendS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var friendId = Convert.ToUInt64(friendS);
            return WereFriends(playerId, friendId);
        }

        private bool IsFriend(ulong playerId, ulong friendId)
        {
            return GetPlayerData(friendId).Friends.Contains(playerId);
        }

        private bool IsFriendS(string playerS, string friendS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(friendS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var friendId = Convert.ToUInt64(friendS);
            return IsFriend(playerId, friendId);
        }

        private bool WasFriend(ulong playerId, ulong friendId)
        {
            var playerData = GetPlayerData(friendId);
            return playerData.Friends.Contains(playerId) || playerData.IsCached(playerId);
        }

        private bool WasFriendS(string playerS, string friendS)
        {
            if (string.IsNullOrEmpty(playerS) || string.IsNullOrEmpty(friendS)) return false;
            var playerId = Convert.ToUInt64(playerS);
            var friendId = Convert.ToUInt64(friendS);
            return WasFriend(playerId, friendId);
        }

        #endregion

        #region Friend Lists

        private ulong[] GetFriends(ulong playerId) => GetPlayerData(playerId).Friends.ToArray();

        private string[] GetFriendsS(string playerS)
        {
            var playerId = Convert.ToUInt64(playerS);
            return GetPlayerData(playerId).Friends.ToList().ConvertAll(f => f.ToString()).ToArray();
        }

        private string[] GetFriendList(ulong playerId)
        {
            var playerData = GetPlayerData(playerId);
            var players = new List<string>();
            foreach (var friend in playerData.Friends)
                players.Add(GetPlayerData(friend).Name);
            return players.ToArray();
        }

        private string[] GetFriendListS(string playerS) => GetFriendList(Convert.ToUInt64(playerS));

        private ulong[] IsFriendOf(ulong playerId)
        {
            HashSet<ulong> friends;
            return ReverseData.TryGetValue(playerId, out friends) ? friends.ToArray() : new ulong[0];
        }

        private string[] IsFriendOfS(string playerS)
        {
            var playerId = Convert.ToUInt64(playerS);
            var friends = IsFriendOf(playerId);
            return friends.ToList().ConvertAll(f => f.ToString()).ToArray();
        }

        #endregion

        private PlayerData GetPlayerData(ulong playerId)
        {
            var player = players.FindPlayerById(playerId.ToString());
            PlayerData playerData;
            if (!FriendsData.TryGetValue(playerId, out playerData))
                FriendsData[playerId] = playerData = new PlayerData();
            if (player != null) playerData.Name = player.Name;
            return playerData;
        }

        private double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            var days = dateDifference.Days;
            var hours = dateDifference.Hours;
            hours += (days * 24);
            var mins = dateDifference.Minutes;
            var secs = dateDifference.Seconds;
            return string.Format("{0:00}:{1:00}:{2:00}", hours, mins, secs);
        }

        #region Commands
        private Dictionary<ulong, ulong> pendings = new Dictionary<ulong, ulong>();

        [Command("friend")]
        private void FriendCommand(IPlayer player, string command, string[] args)
        {
            if (player.Id == "server_console")
            {
                player.Reply($"Command '{command}' can only be used by players", command);
                return;
            }

            if (args == null || args.Length <= 0 || args.Length == 1 && args[0].ToLower() != "accept" && args[0].ToLower() != "ff" && args[0].ToLower() != "codelock" && args[0].ToLower() != "turret" && !args[0].Equals("list", StringComparison.OrdinalIgnoreCase))
            {
                Reply(player, "Syntax");
                return;
            }
            double time = GrabCurrentTime();

            switch (args[0].ToLower())
            {
                case "list":
                    var friendList = GetFriendListS(player.Id);
                    if (friendList.Length > 0)
                        Reply(player, "List", $"{friendList.Length}/{configData.MaxFriends}", string.Join(", ", friendList));
                    else
                        Reply(player, "NoFriends");
                    return;

                case "add":
                case "+":
                    double nextUseTime = !userCooldowns.ContainsKey(player.Id) ? 0 : userCooldowns[player.Id];
                    if (nextUseTime > time)
                    {
                        Reply(player, "Cooldown", FormatTime(nextUseTime - time), "add");
                        return;
                    }
                    var foundPlayers = players.FindPlayers(args[1]).ToArray();

                    if (foundPlayers.Length > 1)
                    {
                        Reply(player, "MultiplePlayers", string.Join(", ", foundPlayers.Select(p => p.Name).ToArray()));
                        return;
                    }

                    var friendPlayer = foundPlayers.Length == 1 ? foundPlayers[0] : null;
                    if (friendPlayer == null)
                    {
                        Reply(player, "PlayerNotFound", args[1]);
                        return;
                    }
                    if (player == friendPlayer)
                    {
                        Reply(player, "CantAddSelf");
                        return;
                    }
                    var playerData = GetPlayerData(Convert.ToUInt64(player.Id));
                    if (playerData.Friends.Count >= configData.MaxFriends)
                    {
                        Reply(player, "FriendlistFull");
                        return;
                    }

                    if (playerData.Friends.Contains(Convert.ToUInt64(friendPlayer.Id)))
                    {
                        Reply(player, "AlreadyOnList", friendPlayer.Name);
                        return;
                    }
                    if (pendings.ContainsKey(Convert.ToUInt64(friendPlayer.Id)))
                    {
                        if (pendings[Convert.ToUInt64(friendPlayer.Id)] == Convert.ToUInt64(player.Id))
                        {
                            Reply(player, "AlreadyPending");
                            return;
                        }
                        Reply(player, "PendingBusy");
                        return;
                    }
                    if (!friendPlayer.IsConnected)
                    {
                        Reply(player, "Disconnected");
                        return;
                    }
                    PendingAdd(player, friendPlayer);
                    mytimer = timer.Once(60f, () =>
                    {
                        ulong sender;
                        if (pendings.TryGetValue(Convert.ToUInt64(friendPlayer.Id), out sender) && sender == Convert.ToUInt64(player.Id))
                        {
                            pendings.Remove(Convert.ToUInt64(friendPlayer.Id));
                        }
                    });
                    Reply(player, "PendingSuccessSend");
                    if (friendPlayer.IsConnected)
                    {
                        Reply(friendPlayer, "Pending", player.Name);
                    }
                    if (!userCooldowns.ContainsKey(player.Id))
                        userCooldowns.Add(player.Id, time + configData.FriendCooldown);
                    else
                        userCooldowns[player.Id] = time + configData.FriendCooldown;
                    return;
                case "accept":
                    double nextUseTime2 = !userCooldowns.ContainsKey(player.Id) ? 0 : userCooldowns[player.Id];
                    if (nextUseTime2 > time)
                    {
                        Reply(player, "Cooldown", FormatTime(nextUseTime2 - time), "add");
                        return;
                    }
                    ulong sensder;
                    if (pendings.TryGetValue(Convert.ToUInt64(player.Id), out sensder))
                    {

                        AddFriendS(player.Id, sensder.ToString());
                        Reply(player, "FriendAdded", GetPlayerData(Convert.ToUInt64(sensder)).Name);
                        var p = players.FindPlayerById(sensder.ToString());
                        Reply(p, "FriendAdded", player.Name);
                        pendings.Remove(Convert.ToUInt64(player.Id));

                        if (!userCooldowns.ContainsKey(player.Id))
                            userCooldowns.Add(player.Id, time + configData.FriendCooldown);
                        else
                            userCooldowns[player.Id] = time + configData.FriendCooldown;

                    }
                    else
                    {
                        Reply(player, "PendingNotFound");
                    }
                    return;
                case "remove":
                case "-":
                    var friend = FindFriend(args[1]);
                    if (friend <= 0)
                    {
                        Reply(player, "NotOnFriendlist", args[1]);
                        return;
                    }

                    var removed = RemoveFriendS(player.Id, friend.ToString());
                    Reply(player, removed ? "FriendRemoved" : "NotOnFriendlist", args[1]);
                    return;

                case "codelock":
                    if (!configData.ShareCodeLocks) return;
                    var playerSetting = GetPlayerData(Convert.ToUInt64(player.Id));
                    if (!playerSetting.CodeAuthorization)
                    {
                        playerSetting.CodeAuthorization = true;
                        Reply(player, "Codelock", "включили", "green");
                    }
                    else
                    {
                        playerSetting.CodeAuthorization = false;
                        Reply(player, "Codelock", "отключили", "red");
                    }
                    return;
                case "turret":
                    if (!configData.ShareAutoTurrets) return;
                    var playerSetting1 = GetPlayerData(Convert.ToUInt64(player.Id));
                    if (!playerSetting1.TurrentAuthorization)
                    {
                        playerSetting1.TurrentAuthorization = true;
                        Reply(player, "Turrets", "включили", "green");
                    }
                    else
                    {
                        playerSetting1.TurrentAuthorization = false;
                        Reply(player, "Turrets", "отключили", "red");
                    }
                    return;
                case "ff":
                    var playerSetting2 = GetPlayerData(Convert.ToUInt64(player.Id));
                    if (!playerSetting2.AttackFriend)
                    {
                        playerSetting2.AttackFriend = true;
                        Reply(player, "Attacks", "включили", "green");
                    }
                    else
                    {
                        playerSetting2.AttackFriend = false;
                        Reply(player, "Attacks", "отключили", "red");
                    }
                    return;
            }
        }

        private void PendingAdd(IPlayer sender, IPlayer target)
        {
            pendings[Convert.ToUInt64(target.Id)] = Convert.ToUInt64(sender.Id);
            
        }
        #endregion

        private void Reply(IPlayer player, string langKey, params object[] args)
        {
            if (langKey == "Syntax")
            {
                if (configData.ShareCodeLocks && configData.ShareAutoTurrets)
                {
                    player.Reply(string.Format(Messages["Syntax"] + Messages["CodeLocks"] + Messages["Turret"], args));
                    return;
                }

                if (configData.ShareCodeLocks)
                {
                    player.Reply(string.Format(Messages["Syntax"] + Messages["CodeLocks"], args));
                    return;
                }
                if (configData.ShareAutoTurrets)
                {
                    player.Reply(string.Format(Messages["Syntax"] + Messages["Turret"], args));
                    return;
                }
            }
            player.Reply(string.Format(Messages[langKey], args));
        }

        private void SendHelpText(object obj)
        {
            var player = players.FindPlayerByObj(obj);
            if (player != null) Reply(player, "HelpText");
        }

        private void AddFriendReverse(ulong playerId, ulong friendId)
        {
            HashSet<ulong> friends;
            if (!ReverseData.TryGetValue(friendId, out friends))
                ReverseData[friendId] = friends = new HashSet<ulong>();
            friends.Add(playerId);
        }

        private ulong FindFriend(string friend)
        {
            if (string.IsNullOrEmpty(friend)) return 0;
            foreach (var playerData in FriendsData)
            {
                if (playerData.Key.ToString().Equals(friend) || playerData.Value.Name.IndexOf(friend, StringComparison.OrdinalIgnoreCase) >= 0)
                    return playerData.Key;
            }
            return 0;
        }
    }
}  
                                                                                 
                

// --- End of file: Friends.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LootScaling.cs ---
// --- Original Local Path: LootScaling.cs ---

using UnityEngine;
using Oxide.Core.Plugins;
using System.Collections;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Loot Scaling", "Kyrah Abattoir", "0.1", ResourceId = 1874)]
    [Description("Scale loot spawn rate/density by player count.")]
    class LootScaling : RustPlugin
    {
        //Existing spawn categories as of 08/26/2015
        //------------------------------------
        //animals loot
        //ores
        //roadside
        //collectable-food-mushroom
        //collectable-resource-stone
        //collectable-resource-hemp
        //field-tundra
        //forest-temperate
        //forest-tundra
        //forest-arctic 
        //forest-arid
        //forest-tundra-commons
        //forest-tundra-rares
        //beachside-deadtrees
        //beachside-palms
        //plant-pumpkin
        //plant-corn beachside-trees

        //you can put here which of the spawn categories you wish to enable player count scaling on.
        //Rust will then adjust item density based on the percentage of players online from 10% rate/density to 100% rate/density
        List<string> cfgPopulationScaling = new List<string>(new string[] {
            "loot",
            "roadside"
        });

        //NOTE the minimum spawn rate/density are two arbitrary values in the engine from 0.1 to 1.0 (10%/100%)
        //you can override them by passing new values to the server with:
        //
        //spawn.min_rate
        //spawn.max_rate
        //spawn.min_density
        //spawn.max_density
        //
        //I have NOT tested changing these, but setting min_rate/density to 0 is probably NOT a good idea so don't do it!

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            foreach (SpawnPopulation s in SingletonComponent<SpawnHandler>.Instance.SpawnPopulations)
            {
                if (cfgPopulationScaling.Contains(s.name))
                {
                    //Well since FacePunch already implemented it all for us, we should probably use it.
                    s.ScaleWithServerPopulation = true;
                    Puts($"Enabled loot scaling for: {s.name}");
                }
            }
        }
    }
}

// --- End of file: LootScaling.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoCleanup-1.0.0.cs ---
// --- Original Local Path: AutoCleanup-1.0.0.cs ---

using System.Collections.Generic;
using System.Collections;
using System.Linq;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("AutoCleanup", "mvrb", "1.0.0")]
    class AutoCleanup : RustPlugin
    {
        bool Changed = false;

        bool logToConsole, broadcastToChat, cleanOnLoad;
        float timerIntervalInSeconds, decayPercentage;
        string commandPermission, excludePermission, cleanupChatCommand, cleanupConsoleCommand;

        List<object> entityList;

        List<object> GetDefaultEntityList()
        {
            return new List<object>()
            {
                "assets/prefabs/building/gates.external.high/gates.external.high.stone/gates.external.high.stone.prefab",
                "assets/prefabs/building/gates.external.high/gates.external.high.wood/gates.external.high.wood.prefab",
                "assets/prefabs/building/wall.external.high.stone/wall.external.high.stone.prefab",
                "assets/prefabs/building/wall.external.high.wood/wall.external.high.wood.prefab",

                "assets/prefabs/deployable/barricades/barricade.concrete.prefab",
                "assets/prefabs/deployable/barricades/barricade.metal.prefab",
                "assets/prefabs/deployable/barricades/barricade.sandbags.prefab",
                "assets/prefabs/deployable/barricades/barricade.stone.prefab",
                "assets/prefabs/deployable/barricades/barricade.wood.prefab",
                "assets/prefabs/deployable/barricades/barricade.woodwire.prefab"
            };
        }

        void Init()
        {
            LoadVariables();
            LoadDefaultMessages();
            RegisterPermissions();

            cmd.AddChatCommand(cleanupChatCommand, this, "cmdCleanupChatCommand");
            cmd.AddConsoleCommand(cleanupConsoleCommand, this, "cmdCleanupConsoleCommand");

            if (cleanOnLoad) CleanUp();

            timer.Every(timerIntervalInSeconds, () => { CleanUp(); });
        }

        void cmdCleanupChatCommand(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, commandPermission))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }

            CleanUp();
        }

        void cmdCleanupConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg?.Connection != null && !permission.UserHasPermission(arg?.Player()?.userID.ToString(), commandPermission)) return;

            CleanUp();
        }

        void CleanUp()
        {
            if (broadcastToChat)
                PrintToChat(Lang("", null));
            if (logToConsole)
                PrintWarning(Lang("", null));

            int reduced = 0;
            int destroyed = 0;

            foreach (var entity in BaseNetworkable.serverEntities.Where(e => (e as BaseEntity).OwnerID != 0 && !permission.UserHasPermission((e as BaseEntity).OwnerID.ToString(), excludePermission) && entityList.Contains((e as BaseEntity).name)).ToList())
            {
                var entityRadius = Physics.OverlapSphere(entity.transform.position, 0.5f, LayerMask.GetMask("Trigger"));
                int cupboards = 0;

                foreach (var cupboard in entityRadius.Where(x => x.GetComponentInParent<BuildingPrivlidge>() != null)) cupboards++;

                if (cupboards == 0)
                {
                    var ent = ((BaseCombatEntity)entity);

                    if (ent.health - (ent.MaxHealth() * (decayPercentage / 100)) <= 0)
                    {
                        entity?.KillMessage();
                        destroyed++;
                    }
                    else
                    {
                        ent.health -= (ent.MaxHealth() * (decayPercentage / 100));

                        ent.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        reduced++;
                    }
                }
            }

            if (broadcastToChat)
            {
                PrintToChat(Lang("", null, reduced, decayPercentage));
                PrintToChat(Lang("<size=20><color=#b7d092>Запущена оптимизация карты</color></size>\nНайдено обьектов: {0}, идет обработка...", null, destroyed));
            }

            if (logToConsole)
            {
                PrintWarning(Lang("EntitiesReducedHealth", null, reduced, decayPercentage));
                PrintWarning(Lang("EntitiesDestroyed", null, destroyed));
            }
        }

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LocatingEntities"] = "Locating all External Walls/Gates & Barricades outside Cupboard Range...",
                ["EntitiesReducedHealth"] = "Reduced the health of {0} External Walls/Gates & Barricades by {1}%.",
                ["EntitiesDestroyed"] = "Destroyed {0} External Walls/Gates & Barricades.",
                ["NoPermission"] = "You do not have permission to use this command."
            }, this);
        }

        void RegisterPermissions()
		{
			permission.RegisterPermission(excludePermission, this);
			permission.RegisterPermission(commandPermission, this);
		}

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            timerIntervalInSeconds = Convert.ToSingle(GetConfig("Settings", "Timer Interval (Seconds)", 3600f));
            decayPercentage = Convert.ToSingle(GetConfig("Settings", "Reduce health by (Percentage)", 10.0f));

            logToConsole = Convert.ToBoolean(GetConfig("Settings", "Log Messages to Console", true));
            broadcastToChat = Convert.ToBoolean(GetConfig("Settings", "Broadcast Messages to Chat", true));
            cleanOnLoad = Convert.ToBoolean(GetConfig("Settings", "Clean up when plugin is loaded", false));


            entityList = (List<object>)GetConfig("Settings", "List of entities", GetDefaultEntityList());

            excludePermission = Convert.ToString(GetConfig("Permissions", "ExcludePermission", "autocleanup.exclude"));
            commandPermission = Convert.ToString(GetConfig("Permissions", "CommandPermission", "autocleanup.cleanup"));
			
			
            cleanupChatCommand = Convert.ToString(GetConfig("Commands", "CleanupChatCommand", "cleanup"));
            cleanupConsoleCommand = Convert.ToString(GetConfig("Commands", "CleanupConsoleCommand", "autocleanup.cleanup"));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
                Changed = true;
            }

            return value;
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: AutoCleanup-1.0.0.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AdminLogger.cs ---
// --- Original Local Path: AdminLogger.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Facepunch.Extend;
using CompanionServer.Handlers;
using System.Collections;
using UnityEngine.Networking;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Admin Logger", "AK", "2.4.1")]
    [Description("Logs admin commands usage in a file and console.")]
    internal class AdminLogger : CovalencePlugin
    {
        [PluginReference] private Plugin Vanish, AdminRadar, NightVision, ConvertStatus, InventoryViewer, PlayerAdministration, Freeze, Backpacks;

        #region Vars

        private Dictionary<ulong, bool> noclipState = new Dictionary<ulong, bool>();
        private Dictionary<ulong, bool> godmodeState = new Dictionary<ulong, bool>();
        private Dictionary<ulong, bool> spectateState = new Dictionary<ulong, bool>();
        private HashSet<BasePlayer> adminList = new HashSet<BasePlayer>();

        #endregion Vars

        #region Config       

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Log to console (true/false)")]
            public bool LogToConsole { get; set; }

            [JsonProperty(PropertyName = "Update frequency (s)")]
            public float UpdateFreq { get; set; }

            [JsonProperty(PropertyName = "Log filename")]
            public string LogFileName { get; set; }

            [JsonProperty(PropertyName = "Enable Discord Messages (true/false)")]
            public bool DiscordLog { get; set; }

            [JsonProperty(PropertyName = "Discord Messages webhook")]
            public string DiscordWebhook { get; set; }

            [JsonProperty(PropertyName = "Exclude List")]
            public List<string> ExcludeList { get; set; }

            [JsonProperty(PropertyName = "Default admin commands")]
            public DefaultCommandsOptions DefaultCommands { get; set; }

            [JsonProperty(PropertyName = "Admin plugins")]
            public PluginsCommandsOptions PluginsCommands { get; set; }

            public class DefaultCommandsOptions
            {
                [JsonProperty(PropertyName = "Admin connections logging (true/false)")]
                public bool ConnectionLog { get; set; }

                [JsonProperty(PropertyName = "Noclip logging (true/false)")]
                public bool NoclipLog { get; set; }

                [JsonProperty(PropertyName = "GodMode logging (true/false)")]
                public bool GodmodeLog { get; set; }

                [JsonProperty(PropertyName = "Spectate logging (true/false)")]
                public bool SpectateLog { get; set; }

                [JsonProperty(PropertyName = "Kill player logging (true/false)")]
                public bool KillPlayerLog { get; set; }

                [JsonProperty(PropertyName = "Admin events logging (true/false)")]
                public bool EventsAllLog { get; set; }

                [JsonProperty(PropertyName = "Admin event commands")]
                public EventsLoggingOptions EventsLogging { get; set; }

                [JsonProperty(PropertyName = "Kick logging (true/false)")]
                public bool KickAllLog { get; set; }

                [JsonProperty(PropertyName = "Kick commands")]
                public KickLoggingOptions KickLogging { get; set; }

                [JsonProperty(PropertyName = "Ban logging (true/false)")]
                public bool BanAllLog { get; set; }

                [JsonProperty(PropertyName = "Ban commands")]
                public BanLoggingOptions BanLogging { get; set; }

                [JsonProperty(PropertyName = "Mute logging (true/false)")]
                public bool MuteAllLog { get; set; }

                [JsonProperty(PropertyName = "Mute commands")]
                public MuteLoggingOptions MuteLogging { get; set; }

                [JsonProperty(PropertyName = "Entity logging (true/false)")]
                public bool EntAllLog { get; set; }

                [JsonProperty(PropertyName = "Entity commands")]
                public EntityLoggingOptions EntityLogging { get; set; }

                [JsonProperty(PropertyName = "Teleport logging (true/false)")]
                public bool TeleportAllLog { get; set; }

                [JsonProperty(PropertyName = "Teleport commands")]
                public TeleportLoggingOptions TeleportLogging { get; set; }

                [JsonProperty(PropertyName = "Give items logging (true/false)")]
                public bool GiveAllLog { get; set; }

                [JsonProperty(PropertyName = "Give commands")]
                public GiveLoggingOptions GiveLogging { get; set; }

                [JsonProperty(PropertyName = "Spawn logging (true/false)")]
                public bool SpawnAllLog { get; set; }

                [JsonProperty(PropertyName = "Spawn commands")]
                public SpawnLoggingOptions SpawnLogging { get; set; }
            }

            public class PluginsCommandsOptions
            {
                [JsonProperty(PropertyName = "Vanish logging (true/false)")]
                public bool VanishLog { get; set; }

                [JsonProperty(PropertyName = "Admin Radar logging (true/false)")]
                public bool RadarLog { get; set; }

                [JsonProperty(PropertyName = "Night Vision logging (true/false)")]
                public bool NightLog { get; set; }

                [JsonProperty(PropertyName = "Convert Status logging (true/false)")]
                public bool ConvertLog { get; set; }

                [JsonProperty(PropertyName = "Inventory Viewer logging (true/false)")]
                public bool InventoryViewerLog { get; set; }

                [JsonProperty(PropertyName = "Backpacks logging (true/false)")]
                public bool BackpacksLog { get; set; }

                [JsonProperty(PropertyName = "Freeze logging (true/false)")]
                public bool FreezeAllLog { get; set; }

                [JsonProperty(PropertyName = "Freeze commands")]
                public FreezeLoggingOptions FreezeLogging { get; set; }

                [JsonProperty(PropertyName = "Player Administration logging (true/false)")]
                public bool PlayerAdministrationAllLog { get; set; }

                [JsonProperty(PropertyName = "Player Administration commands")]
                public PlayerAdministrationLoggingOptions PlayerAdministrationLogging { get; set; }
            }

            public class EventsLoggingOptions
            {
                [JsonProperty(PropertyName = "[Attack Heli] heli.call")]
                public bool HeliCallLog { get; set; }

                [JsonProperty(PropertyName = "[Attack Heli] heli.calltome")]
                public bool HeliCallToMeLog { get; set; }

                [JsonProperty(PropertyName = "[Attack Heli] drop")]
                public bool HeliDropLog { get; set; }

                [JsonProperty(PropertyName = "[Airdrop] supply.call")]
                public bool AirdropRandomLog { get; set; }

                [JsonProperty(PropertyName = "[Airdrop] supply.drop")]
                public bool AirdropPosLog { get; set; }
            }

            public class KickLoggingOptions
            {
                [JsonProperty(PropertyName = "kick")]
                public bool KickLog { get; set; }

                [JsonProperty(PropertyName = "kickall")]
                public bool KickEveryoneLog { get; set; }
            }

            public class BanLoggingOptions
            {
                [JsonProperty(PropertyName = "ban")]
                public bool BanLog { get; set; }

                [JsonProperty(PropertyName = "unban")]
                public bool UnbanLog { get; set; }
            }

            public class MuteLoggingOptions
            {
                [JsonProperty(PropertyName = "mute")]
                public bool MuteLog { get; set; }

                [JsonProperty(PropertyName = "unmute")]
                public bool UnmuteLog { get; set; }
            }

            public class EntityLoggingOptions
            {
                [JsonProperty(PropertyName = "ent kill")]
                public bool EntKillLog { get; set; }

                [JsonProperty(PropertyName = "ent who")]
                public bool EntWhoLog { get; set; }

                [JsonProperty(PropertyName = "ent lock")]
                public bool EntLockLog { get; set; }

                [JsonProperty(PropertyName = "ent unlock")]
                public bool EntUnlockLog { get; set; }

                [JsonProperty(PropertyName = "ent auth")]
                public bool EntAuthLog { get; set; }
            }

            public class TeleportLoggingOptions
            {
                [JsonProperty(PropertyName = "teleport")]
                public bool TeleportLog { get; set; }

                [JsonProperty(PropertyName = "teleportpos")]
                public bool TeleportPosLog { get; set; }

                [JsonProperty(PropertyName = "teleport2me")]
                public bool TeleportToMeLog { get; set; }
            }

            public class GiveLoggingOptions
            {
                [JsonProperty(PropertyName = "give")]
                public bool GiveLog { get; set; }

                [JsonProperty(PropertyName = "giveid")]
                public bool GiveIdLog { get; set; }

                [JsonProperty(PropertyName = "givearm")]
                public bool GiveArmLog { get; set; }

                [JsonProperty(PropertyName = "giveto")]
                public bool GiveToLog { get; set; }

                [JsonProperty(PropertyName = "giveall")]
                public bool GiveAllLog { get; set; }
            }

            public class SpawnLoggingOptions
            {
                [JsonProperty(PropertyName = "spawn")]
                public bool SpawnLog { get; set; }

                [JsonProperty(PropertyName = "spawnat")]
                public bool SpawnAtLog { get; set; }

                [JsonProperty(PropertyName = "spawnhere")]
                public bool SpawnHereLog { get; set; }

                [JsonProperty(PropertyName = "spawnitem")]
                public bool SpawnItemLog { get; set; }
            }

            public class FreezeLoggingOptions
            {
                [JsonProperty(PropertyName = "freeze")]
                public bool FreezeLog { get; set; }

                [JsonProperty(PropertyName = "unfreeze")]
                public bool UnfreezeLog { get; set; }

                [JsonProperty(PropertyName = "freezeall")]
                public bool AllFreezeLog { get; set; }

                [JsonProperty(PropertyName = "unfreezeall")]
                public bool AllUnfreezeLog { get; set; }
            }

            public class PlayerAdministrationLoggingOptions
            {

                [JsonProperty(PropertyName = "OpenPadminCmd")]
                public bool OpenPadminCmdLog { get; set; }

                [JsonProperty(PropertyName = "ClosePadminCmd")]
                public bool ClosePadminCmdLog { get; set; }

                [JsonProperty(PropertyName = "BanUserCmd")]
                public bool BanUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnbanUserCmd")]
                public bool UnbanUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "KickUserCmd")]
                public bool KickUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "MuteUserCmd")]
                public bool MuteUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnmuteUserCmd")]
                public bool UnmuteUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "FreezeCmd")]
                public bool FreezeCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnreezeCmd")]
                public bool UnreezeCmdLog { get; set; }

                [JsonProperty(PropertyName = "BackpackViewCmd")]
                public bool BackpackViewCmdLog { get; set; }

                [JsonProperty(PropertyName = "InventoryViewCmd")]
                public bool InventoryViewCmdLog { get; set; }

                [JsonProperty(PropertyName = "ClearUserInventoryCmd")]
                public bool ClearUserInventoryCmdLog { get; set; }

                [JsonProperty(PropertyName = "ResetUserBPCmd")]
                public bool ResetUserBPCmdLog { get; set; }

                [JsonProperty(PropertyName = "ResetUserMetabolismCmd")]
                public bool ResetUserMetabolismCmdLog { get; set; }

                [JsonProperty(PropertyName = "RecoverUserMetabolismCmd")]
                public bool RecoverUserMetabolismLog { get; set; }

                [JsonProperty(PropertyName = "TeleportToUserCmd")]
                public bool TeleportToUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "TeleportUserCmd")]
                public bool TeleportUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "SpectateUserCmd")]
                public bool SpectateUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "PermsCmd")]
                public bool PermsCmdLog { get; set; }

                [JsonProperty(PropertyName = "HurtUserCmd")]
                public bool HurtUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "KillUserCmd")]
                public bool KillUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "HealUserCmd")]
                public bool HealUserCmdLog { get; set; }

            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                LogToConsole = true,
                UpdateFreq = 5f,
                LogFileName = "adminlog",
                DiscordLog = true,
                DiscordWebhook = "",
                ExcludeList = new List<string>(){
                    "76561197960279927",
                    "76561197960287930"
                },

                DefaultCommands = new ConfigData.DefaultCommandsOptions
                {
                    ConnectionLog = true,
                    NoclipLog = true,
                    GodmodeLog = true,
                    SpectateLog = true,
                    KillPlayerLog = true,   
                    
                    EventsAllLog = true,
                    EventsLogging = new ConfigData.EventsLoggingOptions
                    {
                        HeliCallLog = true,
                        HeliCallToMeLog = true,
                        HeliDropLog = true,
                        AirdropRandomLog = true,
                        AirdropPosLog = true
                    },

                    KickAllLog = true,
                    KickLogging = new ConfigData.KickLoggingOptions
                    {
                        KickLog = true,
                        KickEveryoneLog = true
                    },

                    BanAllLog = true,
                    BanLogging = new ConfigData.BanLoggingOptions
                    {
                        BanLog = true,                       
                        UnbanLog = true
                    },

                    MuteAllLog = true,
                    MuteLogging = new ConfigData.MuteLoggingOptions
                    {
                        MuteLog = true,
                        UnmuteLog = true
                    },

                    EntAllLog = true,
                    EntityLogging = new ConfigData.EntityLoggingOptions
                    {
                        EntKillLog = true,
                        EntWhoLog = true,
                        EntLockLog = true,
                        EntUnlockLog = true,
                        EntAuthLog = true
                    },

                    TeleportAllLog = true,
                    TeleportLogging = new ConfigData.TeleportLoggingOptions
                    {
                        TeleportLog = true,
                        TeleportPosLog = true,
                        TeleportToMeLog = true

                    },

                    GiveAllLog = true,
                    GiveLogging = new ConfigData.GiveLoggingOptions
                    {
                        GiveLog = true,
                        GiveIdLog = true,
                        GiveArmLog = true,
                        GiveToLog = true,
                        GiveAllLog = true
                    },

                    SpawnAllLog = true,
                    SpawnLogging = new ConfigData.SpawnLoggingOptions
                    {
                        SpawnLog = true,
                        SpawnAtLog = true,
                        SpawnHereLog = true,
                        SpawnItemLog = true
                    }
                },

                PluginsCommands = new ConfigData.PluginsCommandsOptions
                {
                    VanishLog = true,
                    RadarLog = true,
                    NightLog = true,
                    ConvertLog = true,
                    InventoryViewerLog = true,
                    BackpacksLog = true,

                    FreezeAllLog = true,
                    FreezeLogging = new ConfigData.FreezeLoggingOptions
                    {
                        FreezeLog = true,
                        UnfreezeLog = true,
                        AllFreezeLog = true,
                        AllUnfreezeLog = true                       
                    },

                    PlayerAdministrationAllLog = true,
                    PlayerAdministrationLogging = new ConfigData.PlayerAdministrationLoggingOptions
                    {
                        OpenPadminCmdLog = true,
                        ClosePadminCmdLog = true,
                        BanUserCmdLog = true,
                        UnbanUserCmdLog = true,
                        KickUserCmdLog = true,
                        MuteUserCmdLog = true,
                        UnmuteUserCmdLog = true,
                        FreezeCmdLog = true,
                        UnreezeCmdLog = true,
                        BackpackViewCmdLog = true,
                        InventoryViewCmdLog = true,
                        ClearUserInventoryCmdLog = true,
                        ResetUserBPCmdLog = true,
                        ResetUserMetabolismCmdLog = true,
                        RecoverUserMetabolismLog = true,
                        TeleportToUserCmdLog = true,
                        TeleportUserCmdLog = true,
                        SpectateUserCmdLog = true,
                        PermsCmdLog = true,
                        HurtUserCmdLog = true,
                        KillUserCmdLog = true,
                        HealUserCmdLog = true
                    }
                }           
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        #endregion Config

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminConnected"] = "{0} [{1}] connected.",
                ["AdminDisconnected"] = "{0} [{1}] disconnected.",
                ["NoclipEnabled"] = "{0} [{1}] enabled Noclip.",
                ["NoclipDisabled"] = "{0} [{1}] disabled Noclip.",
                ["GodmodeEnabled"] = "{0} [{1}] enabled Godmode.",
                ["GodmodeDisabled"] = "{0} [{1}] disabled Godmode.",
                ["SpectateEnabled"] = "{0} [{1}] enabled Spectate mode.",
                ["SpectateDisabled"] = "{0} [{1}] disabled Spectate mode.",
                ["SpectatePlayer"] = "{0} [{1}] started spectating player {2} [{3}].",
                ["KillPlayer"] = "{0} [{1}] killed {2} [{3}].",
                ["KickPlayer"] = "{0} [{1}] kicked {2} [{3}]. Reason: No reason.",
                ["KickPlayerReason"] = "{0} [{1}] kicked {2} [{3}]. Reason: {4}.",
                ["KickAllPlayers"] = "{0} [{1}] kicked all players.",
                ["BanPlayer"] = "{0} [{1}] banned {2} [{3}]. Reason: No reason.",
                ["BanPlayerReason"] = "{0} [{1}] banned {2} [{3}]. Reason: {4}.",
                ["UnbanPlayer"] = "{0} [{1}] unbanned {2} [{3}].",
                ["MutePlayer"] = "{0} [{1}] muted {2} [{3}].",
                ["UnmutePlayer"] = "{0} [{1}] unmuted {2} [{3}].",
                ["VanishEnabled"] = "{0} [{1}] enabled Vanish.",
                ["VanishDisabled"] = "{0} [{1}] disabled Vanish.",
                ["RadarEnabled"] = "{0} [{1}] enabled AdminRadar.",
                ["RadarDisabled"] = "{0} [{1}] disabled AdminRadar.",
                ["NightVisionEnabled"] = "{0} [{1}] enabled NightVision.",
                ["NightVisionDisabled"] = "{0} [{1}] disabled NightVision.",
                ["ConvertStatusEnabled"] = "{0} [{1}] converted into admin status.",
                ["ConvertStatusDisabled"] = "{0} [{1}] converted out of admin status.",
                ["InventoryView"] = "{0} [{1}] used Inventory Viewer on {2} [{3}].",
                ["TeleportSelfToPlayer"] = "{0} [{1}] teleported to {2} [{3}].",
                ["TeleportPlayerToPlayer"] = "{0} [{1}] teleported {2} [{3}] to {4} [{5}].",
                ["TeleportToSelf"] = "{0} [{1}] teleported {2} [{3}] to self.",
                ["TeleportPosition"] = "{0} [{1}] teleported to coordinates {2}.",
                ["GiveSelf"] = "{0} [{1}] gave themselves {2} x {3}.",
                ["GiveSelfArm"] = "{0} [{1}] added 1 x {2} to their belt.",
                ["GiveTo"] = "{0} [{1}] gave {2} [{3}] {4} x {5}.",
                ["GiveAll"] = "{0} [{1}] gave everyone {2} x {3}.",
                ["EntKillPrefab"] = "{0} [{1}] used *kill* on ent: {2} at position {3}.",
                ["EntKillBaseEntity"] = "{0} [{1}] used *kill* on {2} owned by {3} [{4}] at position {5}.",
                ["EntWhoBaseEntity"] = "{0} [{1}] used *who* on {2} owned by {3} [{4}] at position {5}.",
                ["EntLockBaseEntity"] = "{0} [{1}] used *lock* on {2} owned by {3} [{4}] at position {5}.",
                ["EntUnlockBaseEntity"] = "{0} [{1}] used *unlock* on {2} owned by {3} [{4}] at position {5}.",
                ["EntAuthBaseEntity"] = "{0} [{1}] used *auth* on {2} owned by {3} [{4}] at position {5}.",
                ["Spawn"] = "{0} [{1}] spawned {2} at {3}.",
                ["HeliCall"] = "{0} [{1}] called in Attack Helicopter.",
                ["HeliCallToMe"] = "{0} [{1}] called in Attack Helicopter to themselves at position {2}.",
                ["HeliCallDrop"] = "{0} [{1}] spawned Attack Helicopter at their position {2}.",
                ["AirdropCall"] = "{0} [{1}] called in a Supply Drop.",
                ["AirdropCallPos"] = "{0} [{1}] called in a Supply Drop to position (0, 0, 0).",
                ["PadminOpen"] = "{0} [{1}] opened Padmin Menu.",
                ["PadminClose"] = "{0} [{1}] closed Padmin Menu.",
                ["PadminBan"] = "{0} [{1}] banned {2} [{3}] using Padmin. Reason: Administrative decision.",
                ["PadminUnban"] = "{0} [{1}] unbanned {2} [{3}] using Padmin.",
                ["PadminKick"] = "{0} [{1}] kicked {2} [{3}] using Padmin. Reason: Administrative decision.",
                ["PadminMute"] = "{0} [{1}] muted {2} [{3}] using Padmin.",
                ["PadminUnmute"] = "{0} [{1}] unmuted {2} [{3}] using Padmin.",
                ["PadminFreeze"] = "{0} [{1}] Froze player {2} [{3}] using Padmin.",
                ["PadminUnfreeze"] = "{0} [{1}] Unfroze player {2} [{3}] using Padmin.",
                ["PadminBackpackView"] = "{0} [{1}] viewed Backpack of player {2} [{3}] using Padmin.",
                ["PadminInventoryView"] = "{0} [{1}] viewed Inventory of player {2} [{3}] using Padmin.",
                ["PadminClearInventory"] = "{0} [{1}] cleared the inventory of player {2} [{3}] using Padmin.",
                ["PadminResetBP"] = "{0} [{1}] reset the blueprints of player {2} [{3}] using Padmin.",
                ["PadminResetMetabolism"] = "{0} [{1}] reset the metabolism of player {2} [{3}] using Padmin.",
                ["PadminRecoverMetabolism"] = "{0} [{1}] recovered the metabolism of player {2} [{3}] using Padmin.",
                ["PadminTeleportToPlayer"] = "{0} [{1}] teleported to {2} [{3}] using Padmin.",
                ["PadminTeleportPlayer"] = "{0} [{1}] teleported {2} [{3}] to themselves using Padmin.",
                ["PadminSpectate"] = "{0} [{1}] started spectating player {2} [{3}] using Padmin.",
                ["PadminPerms"] = "{0} [{1}] opened the permissions manager for player {2} [{3}] using Padmin.",
                ["PadminHurt"] = "{0} [{1}] hurt player {2} [{3}] for {4} points using Padmin.",
                ["PadminKill"] = "{0} [{1}] killed player {2} [{3}] using Padmin.",
                ["PadminHeal"] = "{0} [{1}] healed player {2} [{3}] for {4} points using Padmin.",
                ["BackpacksView"] = "{0} [{1}] viewed Backpack of player {2} [{3}].",
                ["FreezePlayer"] = "{0} [{1}] Froze player {2} [{3}].",
                ["UnfreezePlayer"] = "{0} [{1}] Unfroze player {2} [{3}].",
                ["FreezeAllPlayers"] = "{0} [{1}] Froze all players.",
                ["UnfreezeAllPlayers"] = "{0} [{1}] Unfroze all players.",

            }, this);
        }

        #endregion Localization

        #region Oxide Hooks

        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
            InvokeHandler.Instance.InvokeRepeating(HandlePlayers, 5f, configData.UpdateFreq);
        }

        void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(HandlePlayers);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }


            if (player.IsAdmin || (configData.PluginsCommands.ConvertLog && ConvertStatus && player.IPlayer.HasPermission("convertstatus.use")))
            {
                if (configData.DefaultCommands.ConnectionLog)
                {
                    Log(configData.LogFileName, "AdminConnected", player.displayName, player.UserIDString);
                }

                adminList.Add(player);
                noclipState[player.userID] = false;
                spectateState[player.userID] = false;
                if (player.IsGod())
                {
                    godmodeState[player.userID] = true;
                }
                else
                {
                    godmodeState[player.userID] = false;
                }
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            if (player.IsAdmin || (configData.PluginsCommands.ConvertLog && ConvertStatus && player.IPlayer.HasPermission("convertstatus.use")))
            {
                if (configData.DefaultCommands.ConnectionLog)
                {
                    Log(configData.LogFileName, "AdminDisconnected", player.displayName, player.UserIDString);
                }

                adminList.Remove(player);
            }
        }

        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsConnectionAdmin) return;
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            if (fullCommand == "chat.say") return;
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            switch (command)
            {
                case "killplayer":
                    if (configData.DefaultCommands.KillPlayerLog)
                    {
                        KillPlayerLogging(arg);
                    }
                    break;
                case "kick":
                case "kickall":
                    if (configData.DefaultCommands.KickAllLog)
                    {
                        KickLogging(arg);
                    }
                    break;
                case "ban":
                case "unban":
                    if (configData.DefaultCommands.BanAllLog)
                    {
                        BanLogging(arg);
                    }
                    break;
                case "mute": 
                case "unmute":
                    if (configData.DefaultCommands.MuteAllLog)
                    {
                        MuteLogging(arg);
                    }
                    break;
                case "teleport":
                case "teleportpos":
                case "teleport2me":
                    if (configData.DefaultCommands.TeleportAllLog)
                    {
                        TeleportLogging(arg);
                    }
                    break;
                case "spectate":
                    if (configData.DefaultCommands.SpectateLog)
                    {
                        SpectateLogging(arg);
                    }
                    break;
                case "giveid":
                case "give":
                case "givearm":
                case "giveto":
                case "giveall":
                    if (configData.DefaultCommands.GiveAllLog)
                    {
                        GiveItemLogging(arg);
                    }
                    break;
                case "spawn":
                case "spawnat":
                case "spawnhere":
                case "spawnitem":
                    if (configData.DefaultCommands.SpawnAllLog)
                    {
                        SpawnLogging(arg);
                    }
                    break;
                case "entid":
                    if (configData.DefaultCommands.EntAllLog)
                    {
                        EntityLogging(arg);
                    }
                    break;
                case "vanish":
                    if (configData.PluginsCommands.VanishLog && Vanish != null && Vanish.IsLoaded && player.IPlayer.HasPermission("vanish.allow"))
                    {
                        VanishLogging(player);
                    }
                    break;
                case "freeze":
                case "unfreeze":
                case "freezeall":
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeAllLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("freeze.use"))
                    {
                        FreezeLogging(arg);
                    }
                    break;
            }

            switch (fullCommand)
            {
                case "heli.call":
                case "heli.calltome":
                case "global.drop":
                case "drop":
                case "supply.call":
                case "supply.drop":
                    if (configData.DefaultCommands.EventsAllLog)
                    {
                        EventsLogging(arg);
                    }
                    break;
                case "playeradministration.closeui":
                case "playeradministration.kickuser":
                case "playeradministration.banuser":
                case "playeradministration.unbanuser":
                case "playeradministration.perms":
                case "playeradministration.muteuser":
                case "playeradministration.unmuteuser":
                case "playeradministration.tptouser":
                case "playeradministration.tpuser":
                case "playeradministration.viewbackpack":
                case "playeradministration.viewinventory":
                case "playeradministration.freeze":
                case "playeradministration.unfreeze":
                case "playeradministration.clearuserinventory":
                case "playeradministration.resetuserblueprints":
                case "playeradministration.resetusermetabolism":
                case "playeradministration.recoverusermetabolism":
                case "playeradministration.spectateuser":
                case "playeradministration.hurtuser":
                case "playeradministration.killuser":
                case "playeradministration.healuser":
                    if (configData.PluginsCommands.PlayerAdministrationAllLog && PlayerAdministration != null && PlayerAdministration.IsLoaded)
                    {
                        PadminLogging(arg);
                    }
                    break;
            }
        }

        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            switch (command)
            {
                case "vanish":
                    if (configData.PluginsCommands.VanishLog && Vanish != null && Vanish.IsLoaded && player.IPlayer.HasPermission("vanish.allow"))
                    {
                        VanishLogging(player);
                    }
                    break;
                case "radar":
                    if (configData.PluginsCommands.RadarLog && AdminRadar != null && AdminRadar.IsLoaded && player.IPlayer.HasPermission("adminradar.allowed"))
                    {
                        AdminRadarLogging(player);
                    }
                    break;
                case "nightvision":
                case "nv":
                    if (configData.PluginsCommands.NightLog && NightVision != null && NightVision.IsLoaded && player.IPlayer.HasPermission("nightvision.allowed"))
                    {
                        NightVisionLogging(player);
                    }
                    break;
                case "convert":
                    if (configData.PluginsCommands.ConvertLog && ConvertStatus != null && ConvertStatus.IsLoaded && player.IPlayer.HasPermission("convertstatus.use"))
                    {
                        ConvertStatusLogging(player);
                    }
                    break;
                case "freeze":
                case "unfreeze":
                case "freezeall":
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeAllLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("freeze.use"))
                    {
                        FreezeLogging(player, command, args);
                    }
                    break;
                case "viewinventory":
                case "viewinv":
                    if (configData.PluginsCommands.InventoryViewerLog && InventoryViewer != null && InventoryViewer.IsLoaded && player.IPlayer.HasPermission("inventoryviewer.allowed"))
                    {
                        InventoryViewerLogging(player, args);
                    }
                    break;
                case "viewbackpack":
                    if (configData.PluginsCommands.BackpacksLog && Backpacks != null && Backpacks.IsLoaded && player.IPlayer.HasPermission("backpacks.admin"))
                    {
                        BackpacksLogging(player, args);
                    }
                    break;
                case "padmin":
                    if (configData.PluginsCommands.PlayerAdministrationAllLog && PlayerAdministration != null && PlayerAdministration.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.show"))
                    {
                        PadminLogging(player);                       
                    }
                    break;
            }
        }

        void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            if (configData.DefaultCommands.SpectateLog)
            {
                Log(configData.LogFileName, "SpectateDisabled", player.displayName, player.UserIDString);
            }
        }

        #endregion Oxide Hooks

        #region Default Commands

        #region Noclip & Godmode

        private void ClientSideCommandDetection(BasePlayer player)
        {
            if (configData.DefaultCommands.NoclipLog)
            {
                if (player.IsFlying && !noclipState[player.userID])
                {
                    Log(configData.LogFileName, "NoclipEnabled", player.displayName, player.UserIDString);
                    noclipState[player.userID] = true;
                }

                if (!player.IsFlying && noclipState[player.userID])
                {
                    Log(configData.LogFileName, "NoclipDisabled", player.displayName, player.UserIDString);
                    noclipState[player.userID] = false;
                }
            }

            if (configData.DefaultCommands.GodmodeLog)
            {
                if (player.IsGod() && godmodeState[player.userID])
                {
                    Log(configData.LogFileName, "GodmodeEnabled", player.displayName, player.UserIDString);
                    godmodeState[player.userID] = false;
                }

                if (!player.IsGod() && !godmodeState[player.userID])
                {
                    Log(configData.LogFileName, "GodmodeDisabled", player.displayName, player.UserIDString);
                    godmodeState[player.userID] = true;
                }
            }
        }

        #endregion Noclip & Godmode

        #region Events

        private void EventsLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;
            ulong playerUserId = arg.Connection.userid;
            var player = BasePlayer.FindByID(playerUserId);

            if (player == null)
            {
                return;
            }

            switch (fullCommand)
            {
                case "heli.call":
                    if (configData.DefaultCommands.EventsLogging.HeliCallLog)
                    {
                        Log(configData.LogFileName, "HeliCall", player.displayName, player.UserIDString);
                    }
                    break;
                case "heli.calltome":
                    if (configData.DefaultCommands.EventsLogging.HeliCallToMeLog)
                    {
                        var position = player.transform.position;
                        Log(configData.LogFileName, "HeliCallToMe", player.displayName, player.UserIDString, position);
                    }
                    break;
                case "global.drop":
                    if (configData.DefaultCommands.EventsLogging.HeliDropLog)
                    {
                        var position = player.transform.position;
                        Log(configData.LogFileName, "HeliCallDrop", player.displayName, player.UserIDString, position);
                    }
                    break;
                case "supply.call":
                    if (configData.DefaultCommands.EventsLogging.AirdropRandomLog)
                    {
                        Log(configData.LogFileName, "AirdropCall", player.displayName, player.UserIDString);
                    }
                    break;
                case "supply.drop":
                    if (configData.DefaultCommands.EventsLogging.AirdropPosLog)
                    {
                        Log(configData.LogFileName, "AirdropCallPos", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        #endregion Events

        #region Kill Player

        private void KillPlayerLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);

            if (player1 == null) return;

            Log(configData.LogFileName, "KillPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Kill Player

        #region Kick

        private void KickLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (configData.DefaultCommands.KickLogging.KickEveryoneLog && command == "kickall")
            {
                Log(configData.LogFileName, "KickAllPlayers", player.displayName, player.UserIDString);
            }

            if (configData.DefaultCommands.KickLogging.KickLog && command == "kick")
            {
                if (arg.Args == null || arg.Args.Length == 0) return;

                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;

                if (arg.Args.Length == 2)
                {
                    string reason = arg.Args[1];
                    Log(configData.LogFileName, "KickPlayerReason", player.displayName, player.UserIDString, player1.Name, player1.Id, reason);
                }
                else
                {
                    Log(configData.LogFileName, "KickPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }
            }
        }

        #endregion Kick

        #region Ban

        private void BanLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
            if (player1 == null) return;

            if (configData.DefaultCommands.BanLogging.BanLog && command == "ban")
            {
                if (arg.Args.Length == 2)
                {
                    string reason = arg.Args[1];
                    Log(configData.LogFileName, "BanPlayerReason", player.displayName, player.UserIDString, player1.Name, player1.Id, reason);
                }
                else
                {
                    Log(configData.LogFileName, "BanPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }
            }

            if (configData.DefaultCommands.BanLogging.UnbanLog && command == "unban")
            {
                Log(configData.LogFileName, "UnbanPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Ban

        #region Mute

        private void MuteLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
            if (player1 == null) return;

            if (configData.DefaultCommands.MuteLogging.MuteLog && command == "mute")
            {
                Log(configData.LogFileName, "MutePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }

            if (configData.DefaultCommands.MuteLogging.UnmuteLog && command == "unmute")
            {
                Log(configData.LogFileName, "UnmutePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Mute

        #region Spectate

        private void SpectateLogging(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                Log(configData.LogFileName, "SpectateEnabled", player.displayName, player.UserIDString);
            }

            if (arg.Args.Length == 1)
            {
                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;
                Log(configData.LogFileName, "SpectatePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Spectate

        #region Teleport

        private void TeleportLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (configData.DefaultCommands.TeleportLogging.TeleportLog && command == "teleport")
            {
                if (arg.Args.Length == 1)
                {
                    var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                    if (player1 == null) return;
                    Log(configData.LogFileName, "TeleportSelfToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }

                if (arg.Args.Length == 2)
                {
                    var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                    if (player1 == null) return;
                    var player2 = covalence.Players.FindPlayer(arg.Args[1]);
                    if (player1 == null) return;
                    Log(configData.LogFileName, "TeleportPlayerToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id, player2.Name, player2.Id);
                }
            }

            if (configData.DefaultCommands.TeleportLogging.TeleportPosLog && command == "teleportpos")
            {
                Log(configData.LogFileName, "TeleportPosition", player.displayName, player.UserIDString, arg.FullString);
            }

            if (configData.DefaultCommands.TeleportLogging.TeleportToMeLog && command == "teleport2me")
            {
                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;
                Log(configData.LogFileName, "TeleportToSelf", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Teleport

        #region Give

        private void GiveItemLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;
            if (ItemManager.FindItemDefinition(arg.Args[0].ToInt()) == null) return;
        
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "giveid":
                    if (configData.DefaultCommands.GiveLogging.GiveIdLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, "1", itemShortName);
                        }

                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, amount, itemShortName);
                        }

                        if (arg.Args.Length == 3)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            var amount = arg.Args[2];
                            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                            if (player1 == null) return;
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, amount, itemShortName);
                        }
                    }
                    break;
                case "give":
                    if (configData.DefaultCommands.GiveLogging.GiveLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, "1", itemShortName);
                        }
                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, amount, itemShortName);
                        }
                    }
                    break;
                case "givearm":
                    if (configData.DefaultCommands.GiveLogging.GiveArmLog)
                    {
                        var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                        Log(configData.LogFileName, "GiveSelfArm", player.displayName, player.UserIDString, itemShortName);
                    }
                    break;
                case "giveto":
                    if (configData.DefaultCommands.GiveLogging.GiveToLog)
                    {
                        var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                        if (player1 == null) return;

                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, "1", itemShortName);
                        }

                        if (arg.Args.Length == 3)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            var amount = arg.Args[2];
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, amount, itemShortName);
                        }
                    }
                    break;
                case "giveall":
                    if (configData.DefaultCommands.GiveLogging.GiveAllLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveAll", player.displayName, player.UserIDString, "1", itemShortName);
                        }
                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveAll", player.displayName, player.UserIDString, amount, itemShortName);
                        }
                    }
                    break;
            }           
        }

        #endregion Give

        #region Spawn

        private void SpawnLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "spawn":
                    if (configData.DefaultCommands.SpawnLogging.SpawnLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnat":
                    if (configData.DefaultCommands.SpawnLogging.SpawnAtLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnhere":
                    if (configData.DefaultCommands.SpawnLogging.SpawnHereLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnitem":
                    if (configData.DefaultCommands.SpawnLogging.SpawnItemLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
            }
        }

        #endregion Spawn

        #region Ent

        private void EntityLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(Convert.ToUInt64(arg.Args[1])));
            if (entity == null) return;

            if (command != "entid") return;

            switch (arg.Args[0])
            {
                case "kill":
                    if (configData.DefaultCommands.EntityLogging.EntKillLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());

                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntKillBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                            else
                            {
                                Log(configData.LogFileName, "EntKillPrefab", player.displayName, player.UserIDString, entity.ShortPrefabName, player.transform.position);
                            }

                        }
                        else
                        {
                            Log(configData.LogFileName, "EntKillPrefab", player.displayName, player.UserIDString, entity.ShortPrefabName, player.transform.position);
                        }
                    }
                    break;
                case "who":
                    if (configData.DefaultCommands.EntityLogging.EntWhoLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntWhoBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "lock":
                    if (configData.DefaultCommands.EntityLogging.EntLockLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntLockBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "unlock":
                    if (configData.DefaultCommands.EntityLogging.EntUnlockLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntUnlockBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "auth":
                    if (configData.DefaultCommands.EntityLogging.EntAuthLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            Log(configData.LogFileName, "EntAuthBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);

                        }
                    }
                    break;
            }           
        }

        #endregion Ent

        #endregion Default Commands

        #region Plugins Commands

        #region Vanish

        private void VanishLogging(BasePlayer player)
        {         
            if (Vanish.Call<bool>("IsInvisible", player))
            {
                Log(configData.LogFileName, "VanishDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "VanishEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion Vanish

        #region AdminRadar

        private void AdminRadarLogging(BasePlayer player)
        {
            if (AdminRadar.Call<bool>("IsRadar", player.UserIDString))
            {
                Log(configData.LogFileName, "RadarDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "RadarEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion AdminRadar

        #region NightVision

        private void NightVisionLogging(BasePlayer player)
        {
            if (NightVision.Call<bool>("IsPlayerTimeLocked", player))
            {
                Log(configData.LogFileName, "NightVisionDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "NightVisionEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion NightVision

        #region ConvertStatus

        private void ConvertStatusLogging(BasePlayer player)
        {
            if (player.IsAdmin)
            {
                Log(configData.LogFileName, "ConvertStatusDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "ConvertStatusEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion ConvertStatus

        #region Freeze

        private void FreezeLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "freeze":
                    if (configData.PluginsCommands.FreezeLogging.FreezeLog)
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "FreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "unfreeze":
                    if (configData.PluginsCommands.FreezeLogging.UnfreezeLog)
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "UnfreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "freezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "FreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "UnfreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        private void FreezeLogging(BasePlayer player, string command, string[] args)
        {
            switch (command)
            {
                case "freeze":
                    if (configData.PluginsCommands.FreezeLogging.FreezeLog)
                    {
                        if (args == null || args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "FreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "unfreeze":
                    if (configData.PluginsCommands.FreezeLogging.UnfreezeLog)
                    {
                        if (args == null || args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "UnfreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "freezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "FreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "UnfreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        #endregion Freeze

        #region InventoryViewer

        private void InventoryViewerLogging(BasePlayer player, string[] args)
        {
            if (args == null || args.Length == 0) return;
            var player1 = covalence.Players.FindPlayerById(args[0]);
            if (player1 == null) return;
            Log(configData.LogFileName, "InventoryView", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Backpacks

        #region Backpacks

        private void BackpacksLogging(BasePlayer player, string[] args)
        {
            if (args == null || args.Length == 0) return;
            var player1 = covalence.Players.FindPlayerById(args[0]);
            if (player1 == null) return;
            Log(configData.LogFileName, "BackpacksView", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Backpacks

        #region Padmin

        private void PadminLogging(BasePlayer player)
        {
            if (!configData.PluginsCommands.PlayerAdministrationLogging.OpenPadminCmdLog) return;
            Log(configData.LogFileName, "PadminOpen", player.displayName, player.UserIDString);
        }

        private void PadminLogging(ConsoleSystem.Arg arg)
        {
            string fullCommand = arg.cmd.FullName;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (fullCommand)
            {
                case "playeradministration.closeui":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ClosePadminCmdLog && player.IPlayer.HasPermission("playeradministration.access.show"))
                    {
                        Log(configData.LogFileName, "PadminClose", player.displayName, player.UserIDString);
                    }
                    break;
                case "playeradministration.kickuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.KickUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.kick"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminKick", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.banuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.BanUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.ban"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminBan", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unbanuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnbanUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.ban"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnban", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.muteuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.MuteUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.mute"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminMute", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unmuteuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnmuteUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.mute"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnmute", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.freeze":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.FreezeCmdLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.allowfreeze"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminFreeze", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unfreeze":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnreezeCmdLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.allowfreeze"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnfreeze", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.viewbackpack":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.BackpackViewCmdLog && Backpacks != null && Backpacks.IsLoaded && player.IPlayer.HasPermission("backpacks.admin"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminBackpackView", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.viewinventory":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.InventoryViewCmdLog && InventoryViewer != null && InventoryViewer.IsLoaded && player.IPlayer.HasPermission("inventoryviewer.allowed"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminInventoryView", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.clearuserinventory":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ClearUserInventoryCmdLog && player.IPlayer.HasPermission("playeradministration.access.clearinventory"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminClearInventory", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.resetuserblueprints":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ResetUserBPCmdLog && player.IPlayer.HasPermission("playeradministration.access.resetblueprint"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminResetBP", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.resetusermetabolism":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ResetUserMetabolismCmdLog && player.IPlayer.HasPermission("playeradministration.access.resetmetabolism"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminResetMetabolism", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.recoverusermetabolism":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.RecoverUserMetabolismLog && player.IPlayer.HasPermission("playeradministration.access.recovermetabolism"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminRecoverMetabolism", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.tptouser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.TeleportToUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.teleport"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminTeleportToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.tpuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.TeleportUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.teleport"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminTeleportPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.spectateuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.SpectateUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.spectate"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminSpectate", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.perms":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.PermsCmdLog && player.IPlayer.HasPermission("playeradministration.access.perms"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminPerms", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.hurtuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.HurtUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.hurt"))
                    {
                        if (arg.Args == null || arg.Args.Length < 2) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminHurt", player.displayName, player.UserIDString, player1.Name, player1.Id, arg.Args[1]);
                    }
                    break;
                case "playeradministration.killuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.KillUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.kill"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminKill", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.healuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.HealUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.heal"))
                    {
                        if (arg.Args == null || arg.Args.Length < 2) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminHeal", player.displayName, player.UserIDString, player1.Name, player1.Id, arg.Args[1]);
                    }
                    break;

            }
        }

        #endregion Padmin

        #endregion Plugins Commands

        #region Helpers

        private void HandlePlayers()
        {
            foreach (var player in adminList)
            {
                ClientSideCommandDetection(player);
            }
        }

        private void Log(string filename, string key, params object[] args)
        {
            if (configData.LogToConsole)
            {
                Puts($"[{DateTime.Now}] {Lang(key, null, args)}");
            }

            if (configData.DiscordLog)
            {
                DiscordPost($"[{DateTime.Now}] {Lang(key, null, args)}");
            }           

            LogToFile(filename, $"[{DateTime.Now}] {Lang(key, null, args)}", this);
        }

        private string Lang(string key, string id = null, params object[] args)
        {           
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void DiscordPost(string message)
        {
            var payload = new
            {
                content = message
            };

            var form = new WWWForm();
            form.AddField("payload_json", JsonConvert.SerializeObject(payload));

            InvokeHandler.Instance.StartCoroutine(HandleUpload(configData.DiscordWebhook, form));
        }

        private IEnumerator HandleUpload(string url, WWWForm data)
        {
            var www = UnityWebRequest.Post(url, data);
            yield return www.SendWebRequest();

            if (www.isNetworkError || www.isHttpError)
            {
                Puts($"Failed to post Discord webhook message: {www.error}");
            }
        }

        #endregion Helpers

    }
}

// --- End of file: AdminLogger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AirdropPrecision.cs ---
// --- Original Local Path: AirdropPrecision.cs ---

using UnityEngine;
using System.Reflection;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Airdrop Precision", "k1lly0u", "0.1.1", ResourceId = 2074)]
    class AirdropPrecision : RustPlugin
    {
        #region Fields
        private FieldInfo dropPosition;

        List<Vector3> thrownSignals;
        #endregion

        #region Oxide Hooks        
        void OnServerInitialized()
        {
            dropPosition = typeof(CargoPlane).GetField("dropPosition", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            thrownSignals = new List<Vector3>();
        }
        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (entity is SupplySignal)
            {
                timer.Once(3f, () =>
                {
                    if (entity.transform.position != null)
                    {
                        thrownSignals.Add(entity.GetEstimatedWorldPosition());
                    }
                });
            }
        }
        void OnEntitySpawned(BaseEntity entity)
        {
            if (entity is CargoPlane)
            {
                var plane = entity.GetComponent<CargoPlane>();
                var location = (Vector3)dropPosition.GetValue(plane);
                if (location != null)
                {
                    for (int i = 0; i < thrownSignals.Count; i++)
                    {
                        if (Vector2.Distance(new Vector2(thrownSignals[i].x, thrownSignals[i].z), new Vector2(location.x, location.z)) < 30)
                        {
                            plane.UpdateDropPosition(thrownSignals[i]);
                            thrownSignals.Remove(thrownSignals[i]);
                            break;
                        }
                    }
                }
            }            
        }       
        #endregion
    }
}



// --- End of file: AirdropPrecision.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SQLStats.cs ---
// --- Original Local Path: SQLStats.cs ---

// Reference: Oxide.Ext.MySql
using System.Collections.Generic;
using Oxide.Core;
using System;
using System.Net;
using System.Text;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins {

    [Info("SQLStats", "Visagalis", "1.0.2")]
    [Description("Logs various statistics about ingame stuff to MySQL.")]
    public class SQLStats : RustPlugin {

        private Dictionary<BasePlayer, Int32> loginTime = new Dictionary<BasePlayer, int>();
        private readonly Ext.MySql.Libraries.MySql _mySql = Interface.GetMod().GetLibrary<Ext.MySql.Libraries.MySql>();
        private Ext.MySql.Connection _mySqlConnection = null;
        private Dictionary<string, object> dbConnection = null;
        protected override void LoadDefaultConfig() { }
        private T checkCfg<T>(string conf, T def)
        {
            if (Config[conf] != null)
            {
                return (T)Config[conf];
             }
            else
            {
                Config[conf] = def;
                return def;
            }
        }

        void Unloaded()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerDisconnected(player);
            }
            timer.Once(5, () =>
            {
                _mySql.CloseDb(_mySqlConnection);
                _mySqlConnection = null;
            });
        }

        void Loaded() {
            dbConnection = checkCfg<Dictionary<string, object>>("dbConnection", new Dictionary<string, object>{
                {"Host", "127.0.0.1"},
                {"Port", 3306},
                {"Username", "rustUS"},
                {"Password", "rustPW" },
                {"Database", "rustDB"}
            });
			SaveConfig();
            StartConnection();

            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerInit(player);
            }
        }

        private void StartConnection()
        {
            if (_mySqlConnection == null)
            {
                Puts("Opening connection.");
                _mySqlConnection = _mySql.OpenDb(dbConnection["Host"].ToString(), Convert.ToInt32(dbConnection["Port"]), dbConnection["Database"].ToString(), dbConnection["Username"].ToString(), dbConnection["Password"].ToString(), this);
                Puts("Connection opened.");
            }
        }

        public void executeQuery(string query, params object[] data) {
            var sql = Ext.MySql.Sql.Builder.Append(query, data);
            _mySql.Insert(sql, _mySqlConnection);
        }

        private string getDate() {
            return DateTime.Now.ToString("yyyy-MM-dd");
        }

        private string getDateTime()
        {
            return DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
        }

        string UppercaseFirst(string s) {
            if(string.IsNullOrEmpty(s)) {
                return string.Empty;
            }
            char[] a = s.ToCharArray();
            a[0] = char.ToUpper(a[0]);
            return new string(a);
        }

        static string EncodeNonAsciiCharacters(string value)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char c in value)
            {
                if (c > 127)
                {
                    // This character is too big for ASCII
                    string encodedValue = "";
                    sb.Append(encodedValue);
                }
                else {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }


        /**
         ** Events
         **/

        void OnPlayerInit(BasePlayer player)
        {
            if (!player.IsConnected())
                return;

            string properName = EncodeNonAsciiCharacters(player.displayName);

            executeQuery(
                "INSERT INTO stats_player (id, name, ip, online) VALUES (@0, @1, @2, 1) ON DUPLICATE KEY UPDATE name = @1, ip = @2, online = 1",
                player.userID, properName, player.net.connection.ipaddress);
            if(loginTime.ContainsKey(player))
                OnPlayerDisconnected(player);

            loginTime.Add(player, (Int32) (DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds);
        }

        void OnPlayerDisconnected(BasePlayer player) {
            if(loginTime.ContainsKey(player)) {
                executeQuery("UPDATE stats_player SET online_seconds = online_seconds + @0, online = 0 WHERE id = @1", (Int32)(DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds - loginTime[player], player.userID);
                loginTime.Remove(player);
            }
        }
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item) {
            if(entity is BasePlayer) {
                executeQuery("INSERT INTO stats_player_gather_resource (player, resource, count, date) VALUES (@0, @1, @2, @3)" +
                        "ON DUPLICATE KEY UPDATE count = count + " + item.amount, ((BasePlayer)entity).userID, item.info.displayName.english, item.amount, getDate());
            }
        }
        
        void OnCollectiblePickup(Item item, BasePlayer player) {
            executeQuery("INSERT INTO stats_player_gather_resource (player, resource, count, date) VALUES (@0, @1, @2, @3)" +
                        "ON DUPLICATE KEY UPDATE count = count + " + item.amount, player.userID, item.info.displayName.english, item.amount, getDate());
        }
        
        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemProjectile, ProtoBuf.ProjectileShoot projectiles)
        {
            string bullet = "Unknown", weapon = (player.GetActiveItem() != null ? player.GetActiveItem().info.displayName.english : "Unknown");
            try
            {
                bullet = projectile.primaryMagazine.ammoType.displayName.english;
            }
            catch (Exception ex)
            {
                Puts("Problem getting bullet! " + ex.StackTrace);
                if(projectile == null)
                    Puts("!!!WRONG!!! projectile is NULL!");
                else if(projectile.primaryMagazine == null)
                    Puts("!!!WRONG!!! projectile.primaryMagazine is NULL!");
                else if(projectile.primaryMagazine.ammoType == null)
                    Puts("!!!WRONG!!! projectile.primaryMagazine.ammoType is NULL!");
            }
            executeQuery("INSERT INTO stats_player_fire_bullet (player, bullet, weapon, date) VALUES (@0, @1, @2, @3)" +
                        "ON DUPLICATE KEY UPDATE count = count + 1", player.userID, bullet, weapon, getDate());
        }
        
        void OnRocketLaunched(BasePlayer player, BaseEntity entity) {
            string rocketName = "Unknown Rocket";
            string prefab = entity.LookupShortPrefabName().ToLower();
            if (prefab.StartsWith("rocket_basic"))
                rocketName = "Rocket";
            else if (prefab.StartsWith("rocket_fire"))
                rocketName = "Incendiary Rocket";
            else if(prefab.StartsWith("rocket_hv"))
                rocketName = "High Velocity Rocket";
            executeQuery("INSERT INTO stats_player_fire_bullet (player, bullet, weapon, date) VALUES (@0, @1, @2, @3)" +
                        "ON DUPLICATE KEY UPDATE count = count + 1", player.userID, rocketName, player.GetActiveItem().info.displayName.english, getDate());
        }

        void OnExplosiveThrown(BasePlayer player, BaseEntity entity) {
            executeQuery("INSERT INTO stats_player_fire_bullet (player, bullet, weapon, date) VALUES (@0, @1, @2, @3)" +
                        "ON DUPLICATE KEY UPDATE count = count + 1", player.userID, player.GetActiveItem().info.displayName.english, player.GetActiveItem().info.displayName.english, getDate());
        }

        void OnItemCraftFinished(ItemCraftTask task, Item item) {
            executeQuery("INSERT INTO stats_player_craft_item (player, item, date, count) VALUES (@0, @1, @2, @3)"+
                "ON DUPLICATE KEY UPDATE count = count + " + item.amount, task.owner.userID, item.info.displayName.english, getDate(), item.amount);
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity.lastAttacker != null && entity.lastAttacker is BasePlayer)
            {
                if (entity is BuildingBlock)
                {
                    BasePlayer attacker = ((BasePlayer) entity.lastAttacker);
                    string weapon = "Unknown";
                    try
                    {
                        weapon = attacker.GetActiveItem().info.displayName.english;
                    }
                    catch{}
                    try
                    {
                        executeQuery(
                            "INSERT INTO stats_player_destroy_building (player, building, date, tier, weapon) VALUES (@0, @1, @2, @3, @4)",
                            ((BasePlayer) entity.lastAttacker).userID,
                            ((BuildingBlock) entity).blockDefinition.info.name.english, getDateTime(),
                            ((BuildingBlock) entity).currentGrade.gradeBase.name.ToUpper() + " (" +
                            ((BuildingBlock) entity).MaxHealth() + ")", weapon);
                    }
                    catch (Exception ex)
                    {
                        throw new Exception("Line 194. " + ex.Message);
                    }
                }
                else if (entity is BaseNPC)
                {
                    try
                    {
                        string weapon = "Unknown";
                        try
                        {
                            weapon = ((BasePlayer)entity.lastAttacker).GetActiveItem().info.displayName.english;
                        }
                        catch { }
                        string distance = "-1";
                        if (hitInfo != null)
                            distance = GetDistance(entity, hitInfo.Initiator) ?? "0";
                        else
                        {
                            weapon += "(BLEED TO DEATH)";
                            distance = GetDistance(entity, (BasePlayer) entity.lastAttacker) ?? "0";
                        }

                        executeQuery(
                            "INSERT INTO stats_player_animal_kill (player, animal, date, weapon, distance) VALUES (@0, @1, @2, @3, @4)",
                            ((BasePlayer) entity.lastAttacker).userID,
                            GetFormattedAnimal(entity.LookupShortPrefabName()), getDateTime(), weapon, distance);
                    }
                    catch (Exception ex)
                    {
                        Puts("!!!!WRONG!!!! 210!!!");
                        throw new Exception("Line 210. " + ex.Message);
                    }
                }
                else if (entity is BasePlayer && entity != entity.lastAttacker)
                {
                    try
                    {
                        string weapon = "Unknown";
                        try
                        {
                            weapon = ((BasePlayer)entity.lastAttacker).GetActiveItem().info.displayName.english;
                        }
                        catch { }
                        string distance = "-1";
                        if (hitInfo != null)
                            distance = GetDistance(entity, hitInfo.Initiator) ?? "0";
                        else
                        {
                            weapon += "(BLEED TO DEATH)";
                            distance = GetDistance(entity, (BasePlayer) entity.lastAttacker) ?? "0";
                        }

                        executeQuery(
                            "INSERT INTO stats_player_kill (killer, victim, weapon, date, bodypart, distance) VALUES (@0, @1, @2, @3, @4, @5)",
                            ((BasePlayer) entity.lastAttacker).userID, ((BasePlayer) entity).userID,
                            weapon, getDateTime(),
                            formatBodyPartName(hitInfo), distance);
                    }
                    catch (Exception ex)
                    {
                        Puts("!!!!WRONG!!!! 227!!!");
                        if (entity && entity.lastAttacker == null)
                            Puts("Entity was attacked by NULL!");
                        if(hitInfo == null)
                            Puts("hitInfo is NULL!");
                        throw new Exception("Line 227. " + ex.StackTrace);
                    }
                }
            }

            try
            {
                if (entity is BasePlayer)
                {
                    string cause = entity.lastDamage.ToString().ToUpper();
                    executeQuery("INSERT INTO stats_player_death (player, cause, date) VALUES (@0, @1, @2)" +
                                 "ON DUPLICATE KEY UPDATE count = count + 1", ((BasePlayer) entity).userID, cause,
                        getDate());
                }
            }
            catch (Exception ex)
            {
                Puts("!!!!WRONG!!!!245!!!");
                throw new Exception("Line 245" + ex.Message);
            }
        }

        string GetDistance(BaseCombatEntity victim, BaseEntity attacker)
        {
            string distance = Convert.ToInt32(Vector3.Distance(victim.transform.position, attacker.transform.position)).ToString();
            return distance;
        }

        string GetFormattedAnimal(string animal)
        {
            animal = animal.Replace(".prefab", "").ToUpper();
            return animal;
        }

		// Borrowed this part from LaserHyrdra's Death Notes <3
        string formatBodyPartName(HitInfo hitInfo)
        {
            string bodypart = "Unknown";
            bodypart = StringPool.Get(Convert.ToUInt32(hitInfo?.HitBone)) ?? "Unknown";
            if ((bool)string.IsNullOrEmpty(bodypart)) bodypart = "Unknown";
            for (int i = 0; i < 10; i++)
            {
                bodypart = bodypart.Replace(i.ToString(), "");
            }

            bodypart = bodypart.Replace(".prefab", "");
            bodypart = bodypart.Replace("L", "");
            bodypart = bodypart.Replace("R", "");
            bodypart = bodypart.Replace("_", "");
            bodypart = bodypart.Replace(".", "");
            bodypart = bodypart.Replace("right", "");
            bodypart = bodypart.Replace("left", "");
            bodypart = bodypart.Replace("tranform", "");
            bodypart = bodypart.Replace("lowerjaweff", "jaw");
            bodypart = bodypart.Replace("rarmpolevector", "arm");
            bodypart = bodypart.Replace("connection", "");
            bodypart = bodypart.Replace("uppertight", "tight");
            bodypart = bodypart.Replace("fatjiggle", "");
            bodypart = bodypart.Replace("fatend", "");
            bodypart = bodypart.Replace("seff", "");
            bodypart = bodypart.ToUpper();
            return bodypart;
        }

        void OnEntityBuilt(Planner planner, GameObject component) {
            string name = planner.GetOwnerItemDefinition().displayName.english;
            var placedObject = component.ToBaseEntity();
            if (placedObject is BuildingBlock) {
                name = ((BuildingBlock)placedObject).blockDefinition.info.name.english;
                executeQuery("INSERT INTO stats_player_place_building (player, building, date) VALUES (@0, @1, @2)" +
                        "ON DUPLICATE KEY UPDATE count = count + 1", planner.ownerPlayer.userID, name, getDate());
            }else if (planner.isTypeDeployable)
            {
                executeQuery("INSERT INTO stats_player_place_deployable (player, deployable, date) VALUES (@0, @1, @2)" +
                        "ON DUPLICATE KEY UPDATE count = count + 1", planner.ownerPlayer.userID, name, getDate());
            }
            
        }
    }

}

// --- End of file: SQLStats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Corpsedel.cs ---
// --- Original Local Path: Corpsedel.cs ---

using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Corpsedel", "Toshik", "1.0.1")]
    public class Corpsedel : RustPlugin
    {
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;

            if (entity.ShortPrefabName == "player_corpse_new" || entity.ShortPrefabName == "scientist_corpse" || entity.ShortPrefabName == "player_corpse")
            {
                var damageable = entity.GetComponent<BaseCombatEntity>();
                if (damageable != null)
                {
                    Timer damageTimer = null;
                    damageTimer = timer.Repeat(1f, 0, () =>
                    {
                        if (damageable.IsDestroyed || damageable == null) damageTimer.Destroy();
                        else damageable.Hurt(300000f);
                    });
                }
            }
        }
    }
}


// --- End of file: Corpsedel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoCodeLock.cs ---
// --- Original Local Path: AutoCodeLock.cs ---

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using ProtoBuf;
namespace Oxide.Plugins
{
    [Info("AutoCodeLock", "FuJiCuRa", "2.2.12", ResourceId = 15)]
    [Description("CodeLock & Door automation tools")]
    class AutoCodeLock : RustPlugin
    {
        [PluginReference] Plugin NoEscape;
        bool Changed = false;
        bool Initialized = false;
        static AutoCodeLock ACL;
        StoredData playerPrefs = new StoredData();
        List<ulong> usedConsoleInput = new List<ulong>();
        DateTime Epoch = new DateTime(1970, 1, 1);
        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        class StoredData
        {
            public Dictionary<ulong,
            PlayerInfo> PlayerInfo = new Dictionary<ulong,
            PlayerInfo>();
            public Int32 saveStamp = 0;
            public string lastStorage = string.Empty;
            public StoredData() { }
        }
        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        class PlayerInfo
        {
            public bool AL = ACL.autoLock;
            public bool DLD = ACL.deployDoor;
            public bool DLB = ACL.deployBox;
            public bool DLL = ACL.deployLocker;
            public bool DLC = ACL.deployCupboard;
            public string PC;
            public string GC;
            public bool EGC = ACL.enableGuestCode;
            public bool DDC = ACL.deployDoorCloser;
            public float DCD = ACL.defaultCloseDelay;
            public float LHD = ACL.defaultHatchDelay;
            public PlayerInfo() { }
        }
        bool useProtostorageUserdata;
        bool autoUpdateChangedDelays;
        string codelockCommand;
        bool notifyAuthCodeLock;
        string permissionDeployDoor;
        string permissionDeployBox;
        string permissionDeployLocker;
        string permissionDeployCupboard;
        string permissionAutoLock;
        string permissionNoLockNeed;
        string permissionDoorCloser;
        string permissionAll;
        string pluginPrefix;
        string prefixColor;
        string prefixFormat;
        string colorTextMsg;
        string colorCmdUsage;
        string colorON;
        string colorOFF;
        bool adminAutoRights;
        bool autoLock;
        bool deployDoor;
        bool deployBox;
        bool deployLocker;
        bool deployCupboard;
        bool enableGuestCode;
        bool deployDoorCloser;
        float doorCloserMinDelay;
        float doorCloserMaxDelay;
        float defaultCloseDelay;
        float ladderHatchMinDelay;
        float ladderHatchMaxDelay;
        float defaultHatchDelay;
        bool checkPlayerForRaidBlocked;
        bool checkPlayerForCombatBlocked;
        bool denyCloserPickupByPlayer;
        bool denyCloserPickupByAdmin;
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string,
            object>;
            if (data == null)
            {
                data = new Dictionary<string,
                object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        void LoadVariables()
        { 
            codelockCommand = Convert.ToString(GetConfig("Command", "codelockCommand", "codelock"));
            notifyAuthCodeLock = Convert.ToBoolean(GetConfig("Options", "notifyAuthCodeLock", true));
            autoUpdateChangedDelays = Convert.ToBoolean(GetConfig("Options", "autoUpdateChangedDelays", false));
            doorCloserMinDelay = Convert.ToSingle(GetConfig("Options", "doorCloserMinDelay", 2.0f));
            doorCloserMaxDelay = Convert.ToSingle(GetConfig("Options", "doorCloserMaxDelay", 15.0f));
            ladderHatchMinDelay = Convert.ToSingle(GetConfig("Options", "ladderHatchMinDelay", 3.0f));
            ladderHatchMaxDelay = Convert.ToSingle(GetConfig("Options", "ladderHatchMaxDelay", 15.0f));
            checkPlayerForRaidBlocked = Convert.ToBoolean(GetConfig("Options", "checkPlayerForRaidBlocked", true));
            checkPlayerForCombatBlocked = Convert.ToBoolean(GetConfig("Options", "checkPlayerForCombatBlocked", false));
            denyCloserPickupByPlayer = Convert.ToBoolean(GetConfig("Options", "denyCloserPickupByPlayer", true));
            denyCloserPickupByAdmin = Convert.ToBoolean(GetConfig("Options", "denyCloserPickupByAdmin", false));
            permissionDeployDoor = Convert.ToString(GetConfig("Permissions", "permissionDeployDoor", "autocodelock.deploydoor"));
            permissionDeployBox = Convert.ToString(GetConfig("Permissions", "permissionDeployBox", "autocodelock.deploybox"));
            permissionDeployLocker = Convert.ToString(GetConfig("Permissions", "permissionDeployLocker", "autocodelock.deploylocker"));
            permissionDeployCupboard = Convert.ToString(GetConfig("Permissions", "permissionDeployCupboard", "autocodelock.deploycup"));
            permissionAutoLock = Convert.ToString(GetConfig("Permissions", "permissionAutoLock", "autocodelock.autolock"));
            permissionNoLockNeed = Convert.ToString(GetConfig("Permissions", "permissionNoLockNeed", "autocodelock.nolockneed"));
            permissionDoorCloser = Convert.ToString(GetConfig("Permissions", "permissionDoorCloser", "autocodelock.doorcloser"));
            permissionAll = Convert.ToString(GetConfig("Permissions", "permissionAll", "autocodelock.all"));
            adminAutoRights = Convert.ToBoolean(GetConfig("Permissions", "adminAutoRights", true));
            pluginPrefix = Convert.ToString(GetConfig("Formatting", "pluginPrefix", "AutoCodeLock"));
            prefixColor = Convert.ToString(GetConfig("Formatting", "prefixColor", "#ffa500"));
            prefixFormat = Convert.ToString(GetConfig("Formatting", "prefixFormat", "<color={0}>{1}</color>: "));
            colorTextMsg = Convert.ToString(GetConfig("Formatting", "colorTextMsg", "#ffffff"));
            colorCmdUsage = Convert.ToString(GetConfig("Formatting", "colorCmdUsage", "#ffff00"));
            colorON = Convert.ToString(GetConfig("Formatting", "colorON", "#008000"));
            colorOFF = Convert.ToString(GetConfig("Formatting", "colorOFF", "#c0c0c0"));
            autoLock = Convert.ToBoolean(GetConfig("PlayerDefaults", "AutoLock", false));
            deployDoor = Convert.ToBoolean(GetConfig("PlayerDefaults", "DeployDoor", false));
            deployBox = Convert.ToBoolean(GetConfig("PlayerDefaults", "DeployBox", false));
            deployLocker = Convert.ToBoolean(GetConfig("PlayerDefaults", "DeployLocker", false));
            deployCupboard = Convert.ToBoolean(GetConfig("PlayerDefaults", "DeployCupboard", false));
            enableGuestCode = Convert.ToBoolean(GetConfig("PlayerDefaults", "UseGuestCode", false));
            deployDoorCloser = Convert.ToBoolean(GetConfig("PlayerDefaults", "DeployDoorCloser", false));
            defaultCloseDelay = Convert.ToSingle(GetConfig("PlayerDefaults", "DefaultCloseDelay", 3.0f));
            defaultHatchDelay = Convert.ToSingle(GetConfig("PlayerDefaults", "DefaultHatchdelay", 5.0f));
            useProtostorageUserdata = Convert.ToBoolean(GetConfig("Storage", "useProtostorageUserdata", false));
            var configRemoval = false;
            if ((Config.Get("Options") as Dictionary<string, object>).ContainsKey("closerPickupReplaceItem"))
            {
                (Config.Get("Options") as Dictionary<string, object>).Remove("closerPickupReplaceItem");
                configRemoval = true;
            }
            if (!Changed && !configRemoval) return;
            SaveConfig();
            Changed = false;
        }
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                {
                    "AutoLockEnabled",
                    "CodeLock automation (secure and lock) enabled"
                },
                {
                    "AutoLockDisabled",
                    "CodeLock automation disabled"
                },
                {
                    "DeployLockDoorEnabled",
                    "Doors will include codelocks on deploy"
                },
                {
                    "DeployLockDoorDisabled",
                    "Doors will not include codelocks on deploy"
                },
                {
                    "DeployDoorCloserEnabled",
                    "Doors will include doorclosers on deploy"
                },
                {
                    "DeployDoorCloserDisabled",
                    "Doors will not include doorclosers on deploy"
                },
                {
                    "DeployLockBoxEnabled",
                    "Boxes will include codelocks on deploy"
                },
                {
                    "DeployLockBoxDisabled",
                    "Boxes will not include codelocks on deploy"
                },
                {
                    "DeployLockLockerEnabled",
                    "Locker will include codelocks on deploy"
                },
                {
                    "DeployLockLockerDisabled",
                    "Locker will not include codelocks on deploy"
                },
                {
                    "DeployLockCupEnabled",
                    "Cupboards will include codelocks on deploy"
                },
                {
                    "DeployLockCupDisabled",
                    "Cupboards will not include codelocks on deploy"
                },
                {
                    "UseGuestCodeEnabled",
                    "Guest PIN will be set with codelocks"
                },
                {
                    "UseGuestCodeDisabled",
                    "Guest PIN gets not set with codelocks"
                },
                {
                    "CodeAuth",
                    "CodeLock secured and locked with '{0}'"
                },
                {
                    "CodeAuthBoth",
                    "CodeLock secured and locked with '{0}', guest set to '{1}'"
                },
                {
                    "NoAccess",
                    "You are not granted for this feature"
                },
                {
                    "NotLocked",
                    "Codelock not locked. You are not the object owner"
                },
                {
                    "NotLockedByBlock",
                    "Codelock not auto-locked. You are currently raidblocked"
                },
                {
                    "NotLockedByMsg",
                    "Codelock not auto-locked for reason: "
                },
                {
                    "NotSupported",
                    "The specific function '{0}' is not available"
                },
                {
                    "UpdatePin",
                    "Updates all doors with the current PIN"
                },
                {
                    "UpdateGuestPin",
                    "Updates all doors with the current guest PIN"
                },
                {
                    "UpdateCloseDelay",
                    "Updates all doorclosers with the current close & hatch delays"
                },
                {
                    "CommandUsage",
                    "Command usage:"
                },
                {
                    "CommandToggle",
                    "All switches toggle their setting (on<>off)"
                },
                {
                    "CommandAutolock",
                    "Autolock feature:"
                },
                {
                    "CommandDoorCloser",
                    "Doorcloser feature:"
                },
                {
                    "CommandCloseDelay",
                    "Your current close delay:"
                },
                {
                    "CommandHatchDelay",
                    "Your current hatch delay:"
                },
                {
                    "CommandPinCode",
                    "Your current PIN:"
                },
                {
                    "CommandGuestCode",
                    "Your current guest PIN:"
                },
                {
                    "CommandGuest",
                    "Guest PIN feature:"
                },
                {
                    "CommandPinCodeSetTo",
                    "Your PIN was successful set to:"
                },
                {
                    "CommandGuestCodeSetTo",
                    "Your guest PIN was succesful set to:"
                },
                {
                    "CommandCloseDelaySetTo",
                    "Your close delay was successful set to: {0}s"
                },
                {
                    "CommandHatchDelaySetTo",
                    "Your hatch delay was successful set to: {0}s"
                },
                {
                    "CommandPinCodeHelp",
                    "Set your PIN with <color={0}>/{1} pin|p <1234></color> (4-Digits)"
                },
                {
                    "CommandGuestCodeHelp",
                    "Set your guest PIN with <color={0}>/{1} guestpin | gp 1234</color> (4-Digits)"
                },
                {
                    "CommandCloseDelayHelp",
                    "Set your delay with <color={0}>/{1} closedelay | cd x</color> ({2}-{3}s)"
                },
                {
                    "CommandHatchDelayHelp",
                    "Set your delay with <color={0}>/{1} hatchdelay | hd x</color> ({2}-{3}s)"
                },
                {
                    "CommandDeployDoor",
                    "Deploy with Door:"
                },
                {
                    "CommandDeployBox",
                    "Deploy with Box:"
                },
                {
                    "CommandDeployLocker",
                    "Deploy with Locker:"
                },
                {
                    "CommandDeployCupboard",
                    "Deploy with Cupboard:"
                },
                {
                    "StreamerMode",
                    "<color=#ffa500>NOTE</color>: Active <color=#ffff00>streamermode</color> does cloak the PINs"
                },
                {
                    "UpdatedDoors",
                    "Updated '{0}' doors with your current setting"
                },
            },
            this);
        }
        void Init()
        {
            LoadVariables();
            LoadDefaultMessages();
            cmd.AddChatCommand(codelockCommand, this, "CodeLockCommand");
            cmd.AddConsoleCommand(codelockCommand, this, "cCodeLockCommand");
        }
        void Loaded()
        {
            ACL = this;
        }
        void LoadPlayerData()
        {
            StoredData protoStorage = new StoredData();
            if (ProtoStorage.Exists(new string[] { this.Title })) protoStorage = ProtoStorage.Load<StoredData>(new string[] { this.Title }) ?? new StoredData();
            StoredData jsonStorage = new StoredData();
            if (Interface.GetMod().DataFileSystem.ExistsDatafile(this.Title)) jsonStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
            bool lastwasProto = (protoStorage.lastStorage == "proto" && protoStorage.saveStamp > jsonStorage.saveStamp);
            if (useProtostorageUserdata)
            {
                if (lastwasProto)
                {
                    playerPrefs = ProtoStorage.Load<StoredData>(new string[] { this.Title }) ?? new StoredData();
                    return;
                }
                else
                {
                    if (Interface.GetMod().DataFileSystem.ExistsDatafile(this.Title)) playerPrefs = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
                }
            }
            else
            {
                if (!lastwasProto)
                {
                    playerPrefs = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
                    return;
                }
                else
                {
                    if (ProtoStorage.Exists(new string[] { this.Title })) playerPrefs = ProtoStorage.Load<StoredData>(new string[] { this.Title }) ?? new StoredData();
                }
            }
        }
        void OnServerInitialized()
        {
            if (!permission.PermissionExists(permissionDeployDoor)) permission.RegisterPermission(permissionDeployDoor, this);
            if (!permission.PermissionExists(permissionAutoLock)) permission.RegisterPermission(permissionAutoLock, this);
            if (!permission.PermissionExists(permissionDeployBox)) permission.RegisterPermission(permissionDeployBox, this);
            if (!permission.PermissionExists(permissionDeployLocker)) permission.RegisterPermission(permissionDeployLocker, this);
            if (!permission.PermissionExists(permissionDeployCupboard)) permission.RegisterPermission(permissionDeployCupboard, this);
            if (!permission.PermissionExists(permissionAll)) permission.RegisterPermission(permissionAll, this);
            if (!permission.PermissionExists(permissionNoLockNeed)) permission.RegisterPermission(permissionNoLockNeed, this);
            if (!permission.PermissionExists(permissionDoorCloser)) permission.RegisterPermission(permissionDoorCloser, this);

            LoadPlayerData();

            foreach (var player in BasePlayer.activePlayerList) 
                SetPlayer(player);

            foreach (var player in BasePlayer.sleepingPlayerList) 
                SetPlayer(player);

            _refreshAllDoorCloserDelays = ServerMgr.Instance.StartCoroutine(RefreshAllDoorCloserDelays());

            Initialized = true;
        }
        void SetPlayer(BasePlayer player)
        {
            if (player == null) return;
            PlayerInfo p = null;
            if (!playerPrefs.PlayerInfo.TryGetValue(player.userID, out p))
            {
                var info = new PlayerInfo();
                info.AL = autoLock;
                info.DLD = deployDoor;
                info.DLB = deployBox;
                info.DLL = deployLocker;
                info.DLC = deployCupboard;
                info.PC = Convert.ToString(UnityEngine.Random.Range(1, 9999)).PadLeft(4, '0');
                info.GC = Convert.ToString(UnityEngine.Random.Range(1, 9999)).PadLeft(4, '0');
                info.EGC = enableGuestCode;
                info.DDC = deployDoorCloser;
                info.DCD = defaultCloseDelay;
                info.LHD = defaultHatchDelay;
                playerPrefs.PlayerInfo.Add(player.userID, info);
                return;
            }
            return;
        }
        void OnPlayerConnected(BasePlayer player) => SetPlayer(player);

        Coroutine _updateCloserDelays;
        Coroutine _updateDoorCodes;
        Coroutine _updateGuestCodes;
        Coroutine _refreshDoorClosers;
        Coroutine _refreshAllDoorCloserDelays;

        void Unload()
        {
            SaveData();
            if (Interface.Oxide.IsShuttingDown) return;
            if (_updateCloserDelays != null) ServerMgr.Instance.StopCoroutine(_updateCloserDelays);
            if (_updateDoorCodes != null) ServerMgr.Instance.StopCoroutine(_updateDoorCodes);
            if (_updateGuestCodes != null) ServerMgr.Instance.StopCoroutine(_updateGuestCodes);
            if (_refreshDoorClosers != null) ServerMgr.Instance.StopCoroutine(_refreshDoorClosers);
            if (_refreshAllDoorCloserDelays != null) ServerMgr.Instance.StopCoroutine(_refreshAllDoorCloserDelays);
        }
        void OnServerSave() => SaveData();
        void SaveData()
        {
            if (!Initialized) return;
            playerPrefs.saveStamp = (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
            playerPrefs.lastStorage = useProtostorageUserdata ? "proto" : "json";
            if (useProtostorageUserdata) ProtoStorage.Save<StoredData>(playerPrefs, new string[] {
                this.Title
            });
            else Interface.Oxide.DataFileSystem.WriteObject(this.Title, playerPrefs);
        }
        void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            if (!Initialized || deployer == null || entity == null || entity.OwnerID == 0uL || deployer.GetDeployable().slot != BaseEntity.Slot.Lock || !(entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)) return;
            var owner = deployer.GetOwnerPlayer();
            if (PlayerHasPerm(owner.UserIDString, permissionAutoLock, owner.IsAdmin) && playerPrefs.PlayerInfo[owner.userID].AL)
            {
                if (owner.userID != entity.OwnerID && !(owner.IsAdmin && adminAutoRights))
                {
                    PrintToChat(owner, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NotLocked", this, owner.UserIDString) + "</color>");
                    return;
                }
                var externalPlugins = Interface.CallHook("CanAutoLock", owner);
                if (externalPlugins != null && !(owner.IsAdmin && adminAutoRights))
                {
                    PrintToChat(owner, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NotLockedByMsg", this, owner.UserIDString) + $"{(externalPlugins is string ? (string)externalPlugins : string.Empty)}</color>");
                    return;
                }
                if (checkPlayerForRaidBlocked && NoEscape)
                {
                    bool isBlocked = (bool)NoEscape?.CallHook("IsRaidBlocked", owner);
                    if (isBlocked && !(owner.IsAdmin && adminAutoRights))
                    {
                        PrintToChat(owner, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NotLockedByBlock", this, owner.UserIDString) + "</color>");
                        return;
                    }
                }
                if (checkPlayerForCombatBlocked && NoEscape)
                {
                    bool isBlocked = (bool)NoEscape?.CallHook("IsCombatBlocked", owner);
                    if (isBlocked && !(owner.IsAdmin && adminAutoRights))
                    {
                        PrintToChat(owner, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NotLockedByBlock", this, owner.UserIDString) + "</color>");
                        return;
                    }
                }
                CodeLockPrepare(deployer, entity, owner);
            }
        }
        void CodeLockPrepare(Deployer deployer, BaseEntity entity, BasePlayer owner)
        {
            var codelock = entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock;
            codelock.code = GetOrSetPin(owner.userID);
            codelock.hasCode = true;
            codelock.whitelistPlayers.Add(owner.userID);
            if (playerPrefs.PlayerInfo[owner.userID].EGC)
            {
                codelock.guestCode = GetOrSetGuest(owner.userID);
                codelock.hasGuestCode = true;
            } (codelock as BaseEntity).SetFlag(BaseEntity.Flags.Locked, true, false);
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", entity.transform.position);
            if (notifyAuthCodeLock)
            {
                var code = codelock.code;
                var guestCode = codelock.guestCode;
                if (owner.net.connection.info.GetBool("global.streamermode"))
                {
                    code = "****";
                    guestCode = "****";
                }
                if (playerPrefs.PlayerInfo[owner.userID].EGC) PrintToChat(owner, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("CodeAuthBoth", this, owner.UserIDString), code, guestCode + "</color>");
                else PrintToChat(owner, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("CodeAuth", this, owner.UserIDString), code + "</color>");
            }
        }
        string GetOrSetPin(ulong userID)
        {
            if (playerPrefs.PlayerInfo[userID].PC != string.Empty) return playerPrefs.PlayerInfo[userID].PC;
            var newCode = Convert.ToString(UnityEngine.Random.Range(1, 9999)).PadLeft(4, '0');
            playerPrefs.PlayerInfo[userID].PC = newCode;
            return newCode;
        }
        string GetOrSetGuest(ulong userID)
        {
            if (playerPrefs.PlayerInfo[userID].GC != string.Empty) return playerPrefs.PlayerInfo[userID].GC;
            var newCode = Convert.ToString(UnityEngine.Random.Range(1, 9999)).PadLeft(4, '0');
            playerPrefs.PlayerInfo[userID].GC = newCode;
            return newCode;
        }
        WaitForEndOfFrame waitF = new WaitForEndOfFrame();

        IEnumerator RefreshAllDoorCloserDelays()
        {
            var allDoorClosers = BaseNetworkable.serverEntities.Where(p => p is DoorCloser);

            Debug.Log($"found {allDoorClosers.Count()} door closers");
            foreach(BaseNetworkable networkable in allDoorClosers)
            {
                DoorCloser doorCloser = networkable as DoorCloser;
                if (doorCloser == null)                
                    continue;
                
                BaseEntity parent = doorCloser.GetParentEntity();

                PlayerInfo playerInfo;
                if (playerPrefs.PlayerInfo.TryGetValue(parent.OwnerID, out playerInfo))
                {                    
                    if (parent.ShortPrefabName == "floor.ladder.hatch" || parent.ShortPrefabName == "floor.triangle.ladder.hatch")
                        doorCloser.delay = playerInfo.LHD;
                    else doorCloser.delay = playerInfo.DCD;

                    doorCloser.SendNetworkUpdate();

                    yield return waitF;
                }
            }
        }

        IEnumerator RefreshDoorClosers(ConsoleSystem.Arg arg)
        {
            var playerObjects = BaseNetworkable.serverEntities.Where(p => p is DoorCloser);// BaseNetworkable.serverEntities.Where(p =>  p != null && p.GetComponent<BaseEntity>() != null).Cast<BaseEntity>().Where(k =>  k.HasSlot(BaseEntity.Slot.UpperModifier) && k.GetSlot(BaseEntity.Slot.UpperModifier) == null && (k.OwnerID > 0uL)).GroupBy(c =>  c.OwnerID).ToDictionary(c =>  c.Key, c =>  c);
            yield return waitF;

            int counter = 0;
            foreach (var networkable in playerObjects)
            {
                DoorCloser doorCloser = networkable as DoorCloser;
                if (doorCloser == null)
                    continue;

                BaseEntity parent = doorCloser.GetParentEntity();

                if (!PlayerHasPerm(parent.OwnerID.ToString(), permissionDoorCloser, Player.IsAdmin(parent.OwnerID))) 
                    continue;

                if (!playerPrefs.PlayerInfo.ContainsKey(parent.OwnerID)) playerPrefs.PlayerInfo.Add(parent.OwnerID, new PlayerInfo());
                yield return waitF;

                CloserPlacing(parent.OwnerID, parent);
                counter++;
                yield return waitF;
            }
            if (arg != null) SendReply(arg, $"Refeshed '{counter}' doors with new placed DoorClosers");
            yield return null;
        }
        [ConsoleCommand("acl.refreshclosers")]
        void refreshClosers(ConsoleSystem.Arg arg)
        {
            if (!Initialized) return;
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
             
            _refreshDoorClosers = ServerMgr.Instance.StartCoroutine(RefreshDoorClosers(arg));
        }
        IEnumerator UpdateCloserDelays(BasePlayer player)
        {
            var playerObjects = BaseNetworkable.serverEntities.Where(p => p is DoorCloser);// p != null && p.GetComponent<BaseEntity>() != null).Cast<BaseEntity>().Where(k =>  k.GetSlot(BaseEntity.Slot.UpperModifier) != null && (k.OwnerID == player.userID)).ToList();
            int counter = 0;
            foreach (var networkable in playerObjects)
            {
                DoorCloser doorCloser = networkable as DoorCloser;
                if (doorCloser == null)
                    continue;

                BaseEntity parent = doorCloser.GetParentEntity();
                if (parent == null || parent.OwnerID != player.userID)
                    continue;

                if (parent.ShortPrefabName == "floor.ladder.hatch" || parent.ShortPrefabName == "floor.triangle.ladder.hatch")
                    doorCloser.delay = playerPrefs.PlayerInfo[player.userID].LHD;
                else doorCloser.delay = playerPrefs.PlayerInfo[player.userID].DCD;

                doorCloser.SendNetworkUpdate();
                counter++;
                yield return waitF;
            }
            PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("UpdatedDoors", this, player.UserIDString), counter) + "</color>");
            yield return null;
        }
        IEnumerator UpdateDoorCodes(BasePlayer player)
        {
            var playerObjects = BaseNetworkable.serverEntities.Where(p => p is CodeLock);//BaseNetworkable.serverEntities.Where(p =>  p != null && p.GetComponent<BaseEntity>() != null).Cast<BaseEntity>().Where(k =>  k.GetSlot(BaseEntity.Slot.Lock) != null && (k.OwnerID == player.userID)).ToList();
            int counter = 0;
            foreach (var networkable in playerObjects)
            {
                CodeLock codelock = networkable as CodeLock;
                if (codelock == null) 
                    continue;

                BaseEntity parent = codelock.GetParentEntity();
                if (parent == null || parent.OwnerID != player.userID)
                    continue;

                codelock.code = GetOrSetPin(player.userID);
                codelock.hasCode = true;
                codelock.SendNetworkUpdate();
                counter++;
                yield return waitF;
            }
            PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("UpdatedDoors", this, player.UserIDString), counter) + "</color>");
            yield return null;
        }
        IEnumerator UpdateGuestCodes(BasePlayer player)
        {
            var playerObjects = BaseNetworkable.serverEntities.Where(p => p is CodeLock);//BaseNetworkable.serverEntities.Where(p =>  p != null && p.GetComponent<BaseEntity>() != null).Cast<BaseEntity>().Where(k =>  k.GetSlot(BaseEntity.Slot.Lock) != null && (k.OwnerID == player.userID)).ToList();
            int counter = 0;
            foreach (var networkable in playerObjects)
            {
                CodeLock codelock = networkable as CodeLock;
                if (codelock == null)
                    continue;

                BaseEntity parent = codelock.GetParentEntity();
                if (parent == null || parent.OwnerID != player.userID)
                    continue;

                codelock.guestCode = GetOrSetPin(player.userID);
                codelock.hasGuestCode = true;
                codelock.SendNetworkUpdate();
                counter++;
                yield return waitF;
            }
            PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("UpdatedDoors", this, player.UserIDString), counter) + "</color>");
            yield return null;
        }
        void LockPlacing(BasePlayer player, BaseEntity entity)
        {
            var externalPlugins = Interface.CallHook("CanAutoLock", player);
            if (externalPlugins != null && !(player.IsAdmin && adminAutoRights))
            {
                PrintToChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NotLockedByMsg", this, player.UserIDString) + $"{(externalPlugins is string ? (string)externalPlugins : string.Empty)}</color>");
                return;
            }
            if (checkPlayerForRaidBlocked && NoEscape)
            {
                bool isBlocked = (bool)NoEscape?.CallHook("IsRaidBlocked", player);
                if (isBlocked && !(player.IsAdmin && adminAutoRights))
                {
                    PrintToChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NotLockedByBlock", this, player.UserIDString) + "</color>");
                    return;
                }
            }
            if (checkPlayerForCombatBlocked && NoEscape)
            {
                bool isBlocked = (bool)NoEscape?.CallHook("IsCombatBlocked", player);
                if (isBlocked && !(player.IsAdmin && adminAutoRights))
                {
                    PrintToChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NotLockedByBlock", this, player.UserIDString) + "</color>");
                    return;
                }
            }
            if (PlayerHasPerm(player.UserIDString, permissionNoLockNeed, player.IsAdmin))
            {
                var codelock = (CodeLock)GameManager.server.CreateEntity("assets/prefabs/locks/keypad/lock.code.prefab", new Vector3(), new Quaternion(), true);
                if (codelock == null) return;
                codelock.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.Lock));
                codelock.Spawn();
                entity.SetSlot(BaseEntity.Slot.Lock, codelock);
                if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin) && playerPrefs.PlayerInfo[player.userID].AL)
                {
                    codelock.code = GetOrSetPin(player.userID);
                    codelock.hasCode = true;
                    codelock.whitelistPlayers.Add(player.userID);
                    if (playerPrefs.PlayerInfo[player.userID].EGC)
                    {
                        codelock.guestCode = GetOrSetGuest(player.userID);
                        codelock.hasGuestCode = true;
                    }
                    codelock.SetFlag(BaseEntity.Flags.Locked, true, false);
                    Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab", entity.transform.position);
                    if (notifyAuthCodeLock)
                    {
                        var code = codelock.code;
                        var guestCode = codelock.guestCode;
                        if (player.net.connection.info.GetBool("global.streamermode"))
                        {
                            code = "****";
                            guestCode = "****";
                        }
                        if (playerPrefs.PlayerInfo[player.userID].EGC) PrintToChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("CodeAuthBoth", this, player.UserIDString), code, guestCode + "</color>");
                        else PrintToChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("CodeAuth", this, player.UserIDString), code + "</color>");
                    }
                }
                return;
            }
            else
            {
                Item codelock = player.inventory.FindItemID(1159991980);
                if (codelock == null) return;
                var deploy = codelock.GetHeldEntity() as Deployer;
                deploy.DoDeploy_Slot(deploy.GetDeployable(), player.eyes.HeadRay(), entity.net.ID);
            }
        }
        void CloserPlacing(ulong userID, BaseEntity entity)
        {
            DoorCloser doorcloser = GameManager.server.CreateEntity(StringPool.Get(1831641807), new Vector3(), new Quaternion(), true) as DoorCloser;
            if (doorcloser == null) return;
            doorcloser.gameObject.Identity();
            if (entity.ShortPrefabName == "floor.ladder.hatch" || entity.ShortPrefabName == "floor.triangle.ladder.hatch")
                doorcloser.delay = playerPrefs.PlayerInfo[userID].LHD;
            else doorcloser.delay = playerPrefs.PlayerInfo[userID].DCD;
            doorcloser.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.UpperModifier));
            doorcloser.OnDeployed(entity, null);
            if (entity.ShortPrefabName == "floor.ladder.hatch")
                doorcloser.transform.localPosition = new Vector3(0.7f, 0f, 0f);
            else if (entity.ShortPrefabName == "floor.triangle.ladder.hatch")
                doorcloser.transform.localPosition = new Vector3(-0.8f, 0f, 0f);
            else if (entity.ShortPrefabName.StartsWith("door.double.hinged")) doorcloser.transform.localPosition = new Vector3(0f, 2.3f, 0f);
            else if (entity.ShortPrefabName == "wall.frame.garagedoor") doorcloser.transform.localPosition = new Vector3(0f, 2.85f, 0f);
            doorcloser.Spawn();
            entity.SetSlot(BaseEntity.Slot.UpperModifier, doorcloser);
        }
        void OnEntityBuilt(Planner planner, GameObject obj)
        {
            if (!Initialized || planner == null || planner.GetOwnerPlayer() == null) return;
            BaseEntity entity = obj.ToBaseEntity();
            if (entity == null || entity.OwnerID == 0uL) return;
            BasePlayer player = planner.GetOwnerPlayer();
            if (player == null || !playerPrefs.PlayerInfo.ContainsKey(player.userID)) return;
            if (entity is Door)
            {
                if ((entity as Door).canTakeLock && PlayerHasPerm(player.UserIDString, permissionDeployDoor, player.IsAdmin) && playerPrefs.PlayerInfo[player.userID].DLD) LockPlacing(player, entity);
                if (((entity as Door).canTakeCloser || entity.HasSlot(BaseEntity.Slot.UpperModifier)) && PlayerHasPerm(player.UserIDString, permissionDoorCloser, player.IsAdmin) && playerPrefs.PlayerInfo[player.userID].DDC) CloserPlacing(player.userID, entity);
                return;
            }
            else if (entity is BoxStorage && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (PlayerHasPerm(player.UserIDString, permissionDeployBox, player.IsAdmin) && playerPrefs.PlayerInfo[player.userID].DLB) LockPlacing(player, entity);
                return;
            }
            else if (entity is Locker && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (PlayerHasPerm(player.UserIDString, permissionDeployLocker, player.IsAdmin) && playerPrefs.PlayerInfo[player.userID].DLL) LockPlacing(player, entity);
                return;
            }
            else if (entity is BuildingPrivlidge && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (PlayerHasPerm(player.UserIDString, permissionDeployCupboard, player.IsAdmin) && playerPrefs.PlayerInfo[player.userID].DLC) LockPlacing(player, entity);
                return;
            }
        }
        object CanPickupEntity(BasePlayer player, DoorCloser closer)
        {
            if ((denyCloserPickupByPlayer && !player.IsAdmin) || (denyCloserPickupByAdmin && player.IsAdmin)) return true;
            return null;
        }
        Boolean PlayerHasPerm(string UserIDString, string permissionName, bool isAdmin = false)
        {
            if (permission.UserHasPermission(UserIDString, permissionName) || permission.UserHasPermission(UserIDString, permissionAll)) return true;
            if (isAdmin && adminAutoRights) return true;
            return false;
        }
        Boolean PlayerHasUpdatePerm(string UserIDString, bool isAdmin = false)
        {
            if (permission.UserHasPermission(UserIDString, permissionAutoLock) || permission.UserHasPermission(UserIDString, permissionDoorCloser) || permission.UserHasPermission(UserIDString, permissionAll)) return true;
            if (isAdmin && adminAutoRights) return true;
            return false;
        }
        void cCodeLockCommand(ConsoleSystem.Arg arg)
        {
            if (Initialized && arg != null && arg.Connection != null && arg.Connection.player != null)
            {
                usedConsoleInput.Add(arg.Connection.userid);
                if (arg.Args != null) CodeLockCommand((BasePlayer)arg.Connection.player, codelockCommand, arg.Args);
                else CodeLockCommand((BasePlayer)arg.Connection.player, codelockCommand, new string[] { });
            }
        }
        void CodeLockCommand(BasePlayer player, string command, string[] args)
        {
            if (!Initialized) return;
            if (!player.IsAdmin || (player.IsAdmin && !adminAutoRights))
            {
                if (!permission.UserHasPermission(player.UserIDString, permissionAutoLock) && !permission.UserHasPermission(player.UserIDString, permissionDeployDoor) && !permission.UserHasPermission(player.UserIDString, permissionDeployBox) && !permission.UserHasPermission(player.UserIDString, permissionDeployLocker) && !permission.UserHasPermission(player.UserIDString, permissionDeployCupboard) && !permission.UserHasPermission(player.UserIDString, permissionDoorCloser) && !permission.UserHasPermission(player.UserIDString, permissionAll))
                {
                    PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NoAccess", this, player.UserIDString) + "</color>");
                    return;
                }
            }
            if (args.Length == 0)
            {
                var sb = new StringBuilder();
                if (!usedConsoleInput.Contains(player.userID)) sb.AppendLine($"<size=16><color={prefixColor}>{pluginPrefix}</color></size>");
                sb.AppendLine(lang.GetMessage("CommandUsage", this, player.UserIDString) + $"<color={colorCmdUsage}>/{codelockCommand} <option></color>" + (PlayerHasUpdatePerm(player.UserIDString, player.IsAdmin) ? $" | <color={colorCmdUsage}>/{codelockCommand} update | u</color>": ""));
                sb.AppendLine(lang.GetMessage("CommandToggle", this, player.UserIDString));
                if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin))
                {
                    sb.AppendLine(lang.GetMessage("StreamerMode", this, player.UserIDString));
                    sb.AppendLine($"<color={colorCmdUsage}>auto | a</color> - " + lang.GetMessage("CommandAutolock", this, player.UserIDString) + " " + (playerPrefs.PlayerInfo[player.userID].AL ? $"<color={colorON}>ON</color>": $"<color={colorOFF}>OFF</color>"));
                    sb.AppendLine($"<color={colorCmdUsage}>pin | p</color> - " + lang.GetMessage("CommandPinCode", this, player.UserIDString) + $" <color={colorCmdUsage}>{(player.net.connection.info.GetBool("global.streamermode ") ? " * ***" : GetOrSetPin(player.userID))}</color>");
                    sb.AppendLine($"<color={colorCmdUsage}>guest | g</color> - " + lang.GetMessage("CommandGuest", this, player.UserIDString) + " " + (playerPrefs.PlayerInfo[player.userID].EGC ? $"<color={colorON}>ON</color>": $"<color={colorOFF}>OFF</color>"));
                    if (playerPrefs.PlayerInfo[player.userID].EGC) sb.AppendLine($"<color={colorCmdUsage}>guestpin | gp</color> - " + lang.GetMessage("CommandGuestCode", this, player.UserIDString) + $" <color={colorCmdUsage}>{(player.net.connection.info.GetBool("global.streamermode") ? " * ***" : GetOrSetGuest(player.userID))}</color>");
                }
                if (PlayerHasPerm(player.UserIDString, permissionDoorCloser, player.IsAdmin))
                {
                    sb.AppendLine($"<color={colorCmdUsage}>doorcloser | dc</color> - " + lang.GetMessage("CommandDoorCloser", this, player.UserIDString) + " " + (playerPrefs.PlayerInfo[player.userID].DDC ? $"<color={colorON}>ON</color>": $"<color={colorOFF}>OFF</color>"));
                    sb.AppendLine($"<color={colorCmdUsage}>closedelay | cd</color> - " + lang.GetMessage("CommandCloseDelay", this, player.UserIDString) + $" <color={colorCmdUsage}>{playerPrefs.PlayerInfo[player.userID].DCD}s</color>");
                    sb.AppendLine($"<color={colorCmdUsage}>hatchdelay | hd</color> - " + lang.GetMessage("CommandHatchDelay", this, player.UserIDString) + $" <color={colorCmdUsage}>{playerPrefs.PlayerInfo[player.userID].LHD}s</color>");
                }
                if (PlayerHasPerm(player.UserIDString, permissionDeployDoor, player.IsAdmin)) sb.AppendLine($"<color={colorCmdUsage}>door | d</color> - " + lang.GetMessage("CommandDeployDoor", this, player.UserIDString) + " " + (playerPrefs.PlayerInfo[player.userID].DLD ? $"<color={colorON}>ON</color>": $"<color={colorOFF}>OFF</color>"));
                if (PlayerHasPerm(player.UserIDString, permissionDeployBox, player.IsAdmin)) sb.AppendLine($"<color={colorCmdUsage}>box | b</color> - " + lang.GetMessage("CommandDeployBox", this, player.UserIDString) + " " + (playerPrefs.PlayerInfo[player.userID].DLB ? $"<color={colorON}>ON</color>": $"<color={colorOFF}>OFF</color>"));
                if (PlayerHasPerm(player.UserIDString, permissionDeployLocker, player.IsAdmin)) sb.AppendLine($"<color={colorCmdUsage}>locker | l</color> - " + lang.GetMessage("CommandDeployLocker", this, player.UserIDString) + " " + (playerPrefs.PlayerInfo[player.userID].DLL ? $"<color={colorON}>ON</color>": $"<color={colorOFF}>OFF</color>"));
                if (PlayerHasPerm(player.UserIDString, permissionDeployCupboard, player.IsAdmin)) sb.AppendLine($"<color={colorCmdUsage}>cup | c</color> - " + lang.GetMessage("CommandDeployCupboard", this, player.UserIDString) + " " + (playerPrefs.PlayerInfo[player.userID].DLC ? $"<color={colorON}>ON</color>": $"<color={colorOFF}>OFF</color>"));
                string openText = $"<color={colorTextMsg}>";
                string closeText = "</color>";
                string[] parts = sb.ToString().Split(new char[] {
                    '\n'
                },
                StringSplitOptions.RemoveEmptyEntries);
                sb = new StringBuilder();
                foreach (var part in parts)
                {
                    if ((sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length) > 1050)
                    {
                        PrintChat(player, openText + sb.ToString().TrimEnd() + closeText, usedConsoleInput.Contains(player.userID) ? true : false);
                        sb.Clear();
                    }
                    sb.AppendLine(part);
                }
                PrintChat(player, openText + sb.ToString().TrimEnd() + closeText);
                return;
            }
            switch (args[0].ToLower())
            {
                case "auto":
                case "a":
                    if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin))
                    {
                        playerPrefs.PlayerInfo[player.userID].AL = !playerPrefs.PlayerInfo[player.userID].AL;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + (playerPrefs.PlayerInfo[player.userID].AL ? lang.GetMessage("AutoLockEnabled", this, player.UserIDString) : lang.GetMessage("AutoLockDisabled", this, player.UserIDString)) + "</color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "door":
                case "d":
                    if (PlayerHasPerm(player.UserIDString, permissionDeployDoor, player.IsAdmin))
                    {
                        playerPrefs.PlayerInfo[player.userID].DLD = !playerPrefs.PlayerInfo[player.userID].DLD;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + (playerPrefs.PlayerInfo[player.userID].DLD ? lang.GetMessage("DeployLockDoorEnabled", this, player.UserIDString) : lang.GetMessage("DeployLockDoorDisabled", this, player.UserIDString)) + "</color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "doorcloser":
                case "dc":
                    if (PlayerHasPerm(player.UserIDString, permissionDoorCloser, player.IsAdmin))
                    {
                        playerPrefs.PlayerInfo[player.userID].DDC = !playerPrefs.PlayerInfo[player.userID].DDC;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + (playerPrefs.PlayerInfo[player.userID].DDC ? lang.GetMessage("DeployDoorCloserEnabled", this, player.UserIDString) : lang.GetMessage("DeployDoorCloserDisabled", this, player.UserIDString)) + "</color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "closedelay":
                case "cd":
                    if (PlayerHasPerm(player.UserIDString, permissionDoorCloser, player.IsAdmin))
                    {
                        float delay;
                        if (args.Length != 2 || float.TryParse(args[1], out delay) == false)
                        {
                            PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + string.Format(lang.GetMessage("CommandCloseDelayHelp", this, player.UserIDString), colorCmdUsage, codelockCommand, doorCloserMinDelay, doorCloserMaxDelay));
                            return;
                        }
                        if (delay < doorCloserMinDelay) delay = doorCloserMinDelay;
                        if (delay > doorCloserMaxDelay) delay = doorCloserMaxDelay;
                        playerPrefs.PlayerInfo[player.userID].DCD = delay;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("CommandCloseDelaySetTo", this, player.UserIDString), delay) + "</color>");
                        if (autoUpdateChangedDelays)
                        {
                            _updateCloserDelays = ServerMgr.Instance.StartCoroutine(UpdateCloserDelays(player));
                        }
                    }
                    else goto
              case "noaccess";
                    break;
                case "hatchdelay":
                case "hd":
                    if (PlayerHasPerm(player.UserIDString, permissionDoorCloser, player.IsAdmin))
                    {
                        float delay;
                        if (args.Length != 2 || float.TryParse(args[1], out delay) == false)
                        {
                            PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + string.Format(lang.GetMessage("CommandHatchDelayHelp", this, player.UserIDString), colorCmdUsage, codelockCommand, ladderHatchMinDelay, ladderHatchMaxDelay));
                            return;
                        }
                        if (delay < ladderHatchMinDelay) delay = ladderHatchMinDelay;
                        if (delay > ladderHatchMaxDelay) delay = ladderHatchMaxDelay;
                        playerPrefs.PlayerInfo[player.userID].LHD = delay;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("CommandHatchDelaySetTo", this, player.UserIDString), delay) + "</color>");
                        if (autoUpdateChangedDelays)
                        {
                            _updateCloserDelays = ServerMgr.Instance.StartCoroutine(UpdateCloserDelays(player));
                        }
                    }
                    else goto
              case "noaccess";
                    break;
                case "box":
                case "b":
                    if (PlayerHasPerm(player.UserIDString, permissionDeployBox, player.IsAdmin))
                    {
                        playerPrefs.PlayerInfo[player.userID].DLB = !playerPrefs.PlayerInfo[player.userID].DLB;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + (playerPrefs.PlayerInfo[player.userID].DLB ? lang.GetMessage("DeployLockBoxEnabled", this, player.UserIDString) : lang.GetMessage("DeployLockBoxDisabled", this, player.UserIDString)) + "</color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "locker":
                case "l":
                    if (PlayerHasPerm(player.UserIDString, permissionDeployLocker, player.IsAdmin))
                    {
                        playerPrefs.PlayerInfo[player.userID].DLL = !playerPrefs.PlayerInfo[player.userID].DLL;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + (playerPrefs.PlayerInfo[player.userID].DLL ? lang.GetMessage("DeployLockLockerEnabled", this, player.UserIDString) : lang.GetMessage("DeployLockLockerDisabled", this, player.UserIDString)) + "</color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "cup":
                case "c":
                    if (PlayerHasPerm(player.UserIDString, permissionDeployCupboard, player.IsAdmin))
                    {
                        playerPrefs.PlayerInfo[player.userID].DLC = !playerPrefs.PlayerInfo[player.userID].DLC;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + (playerPrefs.PlayerInfo[player.userID].DLC ? lang.GetMessage("DeployLockCupEnabled", this, player.UserIDString) : lang.GetMessage("DeployLockCupDisabled", this, player.UserIDString)) + "</color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "pin":
                case "p":
                    if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin))
                    {
                        int pinChk;
                        if (args.Length != 2 || int.TryParse(args[1], out pinChk) == false || args[1].Length != 4 || args[1].Length < 4)
                        {
                            PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + string.Format(lang.GetMessage("CommandPinCodeHelp", this, player.UserIDString), colorCmdUsage, codelockCommand));
                            return;
                        }
                        playerPrefs.PlayerInfo[player.userID].PC = args[1].ToString().PadLeft(4, '0');
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("CommandPinCodeSetTo", this, player.UserIDString)) + $" <color={colorCmdUsage}>{args[1]}</color></color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "guest":
                case "g":
                    if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin))
                    {
                        playerPrefs.PlayerInfo[player.userID].EGC = !playerPrefs.PlayerInfo[player.userID].EGC;
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + (playerPrefs.PlayerInfo[player.userID].EGC ? lang.GetMessage("UseGuestCodeEnabled", this, player.UserIDString) : lang.GetMessage("UseGuestCodeDisabled", this, player.UserIDString)) + "</color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "guestpin":
                case "gp":
                    if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin))
                    {
                        int guestChk;
                        if (args.Length != 2 || int.TryParse(args[1], out guestChk) == false || args[1].Length != 4 || args[1].Length < 4)
                        {
                            PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + string.Format(lang.GetMessage("CommandGuestCodeHelp", this, player.UserIDString), colorCmdUsage, codelockCommand));
                            return;
                        }
                        playerPrefs.PlayerInfo[player.userID].GC = args[1].ToString().PadLeft(4, '0');
                        PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("CommandGuestCodeSetTo", this, player.UserIDString)) + $" <color={colorCmdUsage}>{args[1]}</color></color>");
                    }
                    else goto
              case "noaccess";
                    break;
                case "update":
                case "u":
                    if (args.Length != 2)
                    {
                        var sbhelp = new StringBuilder();
                        sbhelp.AppendLine(lang.GetMessage("CommandUsage", this, player.UserIDString) + $"<color={colorCmdUsage}>/{codelockCommand} update | u <option></color>");
                        if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin))
                        {
                            sbhelp.AppendLine($"<color={colorCmdUsage}>pin | p</color> - " + lang.GetMessage("UpdatePin", this, player.UserIDString));
                            sbhelp.AppendLine($"<color={colorCmdUsage}>guestpin | gp</color> - " + lang.GetMessage("UpdateGuestPin", this, player.UserIDString));
                        }
                        if (PlayerHasPerm(player.UserIDString, permissionDoorCloser, player.IsAdmin)) sbhelp.AppendLine($"<color={colorCmdUsage}>closedelay | cd</color> - " + lang.GetMessage("UpdateCloseDelay", this, player.UserIDString));
                        PrintChat(player, $"<color={colorTextMsg}>" + sbhelp.ToString() + "</color>");
                    }
                    else if (args.Length >= 2)
                    {
                        switch (args[1])
                        {
                            case "closedelay":
                            case "cd":
                                if (PlayerHasPerm(player.UserIDString, permissionDoorCloser, player.IsAdmin))
                                {                                     
                                    _updateCloserDelays = ServerMgr.Instance.StartCoroutine(UpdateCloserDelays(player));
                                }
                                else goto
                          case "noaccess";
                                break;
                            case "pin":
                            case "p":
                                if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin))
                                {
                                    _updateDoorCodes = ServerMgr.Instance.StartCoroutine(UpdateDoorCodes(player));
                                }
                                else goto
                          case "noaccess";
                                break;
                            case "guestpin":
                            case "gp":
                                if (PlayerHasPerm(player.UserIDString, permissionAutoLock, player.IsAdmin))
                                {
                                    _updateGuestCodes = ServerMgr.Instance.StartCoroutine(UpdateGuestCodes(player));
                                }
                                else goto
                          case "noaccess";
                                break;
                            case "noaccess":
                                PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NoAccess", this, player.UserIDString) + "</color>");
                                break;
                            default:
                                PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("NotSupported", this, player.UserIDString), args[0]) + "</color>");
                                break;
                        }
                    }
                    break;
                case "noaccess":
                    PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + lang.GetMessage("NoAccess", this, player.UserIDString) + "</color>");
                    break;
                default:
                    PrintChat(player, string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("NotSupported", this, player.UserIDString), args[0]) + "</color>");
                    break;
            }
        }
        void PrintChat(BasePlayer player, string message, bool keepConsole = false)
        {
            if (usedConsoleInput.Contains(player.userID)) player.ConsoleMessage(message);
            else player.ChatMessage(message);
            if (!keepConsole) usedConsoleInput.Remove(player.userID);
        }
    }
}

// --- End of file: AutoCodeLock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BackupExt.cs ---
// --- Original Local Path: BackupExt.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using ProtoBuf;
using Network;

namespace Oxide.Plugins
{
    [Info("BackupExt", "Fujikura", "0.1.0")]
    class BackupExt : RustPlugin
    {
		bool Changed;
		bool _backup;
		bool _startup;
		string [] backupFolders;

		bool backupOnStartup;
		int numberOfBackups;
		bool backupBroadcast;
		int backupDelay;
		bool useBroadcastDelay;
		string prefix;
		string prefixColor;
		bool useTimer;
		int timerInterval;
	
		object GetConfig(string menu, string datavalue, object defaultValue)
		{
			var data = Config[menu] as Dictionary<string, object>;
			if (data == null)
			{
				data = new Dictionary<string, object>();
				Config[menu] = data;
				Changed = true;
			}
			object value;
			if (!data.TryGetValue(datavalue, out value))
			{
				value = defaultValue;
				data[datavalue] = value;
				Changed = true;
			}
			return value;
		}

		void LoadVariables()
		{
			backupOnStartup = Convert.ToBoolean(GetConfig("Settings", "backupOnStartup", false));
			numberOfBackups = Convert.ToInt32(GetConfig("Settings", "numberOfBackups", 4));
			backupBroadcast = Convert.ToBoolean(GetConfig("Notification", "backupBroadcast", false));
			backupDelay = Convert.ToInt32(GetConfig("Notification", "backupDelay", 5));
			useBroadcastDelay = Convert.ToBoolean(GetConfig("Notification", "useBroadcastDelay", true));
			prefix = Convert.ToString(GetConfig("Notification", "prefix", "BACKUP"));
			prefixColor = Convert.ToString(GetConfig("Notification", "prefixColor", "orange"));
			useTimer = Convert.ToBoolean(GetConfig("Timer", "useTimer", false));
			timerInterval = Convert.ToInt32(GetConfig("Timer", "timerInterval", 3600));

			if (!Changed) return;
			SaveConfig();
			Changed = false;
		}
		
		void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			                      {
									{"backupfinish", "Backup process finished."},
									{"backupannounce", "Starting server backup in {0} seconds."},
									{"backuprunning", "Running server backup."},
									{"backupautomatic", "Running automated server backup every {0} seconds."},									
			                      },this);
		}

		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadVariables();
		}
		
		void Loaded()
		{
			if (_startup) return;
			LoadVariables();
			LoadDefaultMessages();
			backupFolders = BackupFolders();
			_startup = true;
		}
		
		void OnTerrainInitialized()
        {
			if (_startup) Loaded();
			if (backupOnStartup && !_backup)
			{
				_backup = true;
				BackupCreate();
			}
        }
		
		void OnServerInitialized()
        {
			if (useTimer)
			{
				timer.Every(timerInterval, () => ccmdExtBackup(new ConsoleSystem.Arg(null)));
				Puts(string.Format(lang.GetMessage("backupautomatic", this), timerInterval));
			}
        }		

		void BackupCreate(bool manual = false)
		{
			DirectoryEx.Backup(BackupFolders());
			DirectoryEx.CopyAll(ConVar.Server.rootFolder, backupFolders[0]);
			if (!manual)
				Puts(lang.GetMessage("backupfinish", this));
		}

		[ConsoleCommand("extbackup")]
		void ccmdExtBackup(ConsoleSystem.Arg arg)
		{
			if(arg.connection != null && arg.connection.authLevel < 2) return;
			if (backupBroadcast)
			{
				if (useBroadcastDelay)
				{
					SendReply(arg, string.Format(lang.GetMessage("backupannounce", this, arg.connection != null ? arg.connection.userid.ToString() : null ), backupDelay));
					BroadcastChat(string.Format(lang.GetMessage("backupannounce", this), backupDelay));
					timer.Once(backupDelay, () => BackupRun(arg));
				}
				else
				{
					BackupRun(arg);
				}
			}
			else
				BackupRun(arg);
		}
		
		void BackupRun(ConsoleSystem.Arg arg)
		{
				if (backupBroadcast)
					BroadcastChat(lang.GetMessage("backuprunning", this));
				SendReply(arg, lang.GetMessage("backuprunning", this, arg.connection != null ? arg.connection.userid.ToString() : null ));
				BackupCreate(true);
				SendReply(arg, lang.GetMessage("backupfinish", this, arg.connection != null ? arg.connection.userid.ToString() : null ));
				if (backupBroadcast)
					BroadcastChat(lang.GetMessage("backupfinish", this));
		}
		
		string [] BackupFolders()
		{
			string [] dp = new string[numberOfBackups];
			for (int i = 0; i < numberOfBackups; i++)
			{
				dp[i] = $"backup/{i}/{ConVar.Server.identity}";
			}
			return dp;
		}
		
		void BroadcastChat(string msg = null) => PrintToChat(msg == null ? prefix : "<color=" + prefixColor + ">" + prefix + "</color>: " + msg);
	}
}

// --- End of file: BackupExt.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Kits4.cs ---
// --- Original Local Path: Kits4.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Kits", "OMHOMHOM", 0.1)]

    class Kits: RustPlugin
    {
        #region Fields

        private string Layer = "UI.Kits";
        private string LayerBlur = "UI.Kits.Blur";
        private string LayerBlurKitsInfo = "UI.Kits.Blur";
        

        #endregion 

        #region Hooks
        
        object OnPlayerRespawned(BasePlayer player)
        { 
            player.inventory.Strip();
 
            foreach (var kitItem in _config.spawnKit)
            {
                var item = ItemManager.CreateByName(kitItem.shortname, kitItem.amount, kitItem.skinID);

                if (kitItem.place == "Одежда")
                {
                    item.MoveToContainer(player.inventory.containerWear);
                    
                    continue; 
                }

                if (kitItem.place == "Панель")
                {
                    item.MoveToContainer(player.inventory.containerBelt);
                    continue;
                }

                item.MoveToContainer(player.inventory.containerMain);
            }
            
            return null;
        }

        void Loaded()
        {
            LoadData();
			AddImage("https://static.moscow.ovh/images/games/rust//plugins/ultimate_ui/exit.png", "Kits_img_exit");
        }

        void OnServerInitialized()
        {
            timer.Every(310f, SaveData);
            
            foreach (var kit in _config.kits)
            {
                if (string.IsNullOrEmpty(kit.privilege)) continue;
                
                permission.RegisterPermission(kit.privilege, this);
            }
                        
            SaveConfig();
        }

        private KitsInfo GetKitsInfo(BasePlayer player)
        {
            KitsInfo result;
            if (!storedData.players.TryGetValue(player.userID, out result))
            {
                result = storedData.players[player.userID] = new KitsInfo();
            }

            return result;
        }

        private KitData GetKitData(KitsInfo kitsInfo, KitInfo kitInfo)
        {
            KitData result;
            if (!kitsInfo.kits.TryGetValue(kitInfo.kitName, out result))
            {
                result = kitsInfo.kits[kitInfo.kitName] = new KitData()
                {
                    amount = kitInfo.maxUse,
                    cooldown = 0
                };
            }

            return result;
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerBlur);
            }
            
            SaveData();
        }

        #endregion

        #region Commands
        
        [ChatCommand("createkit")]
        private void CreateKit(BasePlayer player, string command, string[] args)
        {
            if (player.Connection.authLevel < 2) return;
            
            if (_config.kits.Exists(x => x.kitName == args[0]))
            {
                SendReply(player, "Название уже кита уже существует!");
                return;
            }

            _config.kits.Add(new KitInfo()
            {
                kitName = args[0],
                cooldownKit = 0,
                items = GetPlayerItems(player),
                maxUse = -1,
                privilege = ""
            });
            
            permission.RegisterPermission($"kits.default", this); 
            SendReply(player, $"Создали кит с именем {args[0]}");
            SaveConfig();
        }

        [ConsoleCommand("UI_KITS")]
        private void cmdConsoleHandler(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();

            if (!arg.HasArgs(1)) return;

            var cmd = arg.GetString(0);

            var kits = GetKitsForPlayer(player);
            var kitsInfo = GetKitsInfo(player);
            
            switch (cmd)
            {
                case "prev":
                {
                    player.SendConsoleCommand("UI_KITS showavailablekits");
                    break;
                }
                case "close":
                {
                    CuiHelper.DestroyUi(player, Layer);
                    CuiHelper.DestroyUi(player, LayerBlur);
                    break;
                }
                case "showinfokit":
                {
                    var targetNameKit = arg.GetString(1);
                    if (arg.HasArgs(3)) targetNameKit += $" {arg.GetString(2)}";
                    var kitInfo = _config.kits.FirstOrDefault(x => x.kitName.Equals(targetNameKit));
                    if (kitInfo == null) return;

                    CuiHelper.DestroyUi(player, Layer);

                    var container = new CuiElementContainer();
                    
                    container.Add(new CuiPanel
                    {
                        CursorEnabled = true,
                        Image =
                    {
                        FadeIn = 0.2f,
                        Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                        Color = "0 0 0 1"
                    }
                    }, "Overlay", Layer);
                    container.Add(new CuiPanel
                    {
                    Image =
                    {
                        FadeIn = 0.2f,
                        Color = "0.2 0.2 0.17 0.7",
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    }
                    }, Layer);
                    
                    container.Add(new CuiLabel
                    {
                        Text = { Text = targetNameKit.ToUpper(), Align = TextAnchor.UpperCenter, FontSize = 40, Font = "robotocondensed-bold.ttf" },
                        RectTransform = { AnchorMin = "0.3 1", AnchorMax = "0.7 1", OffsetMin = "0 -155", OffsetMax = "0 -91.6" }
                    }, Layer);
                    container.Add(new CuiLabel
                    {
                        Text = { Text = "Данный набор содержит следующие предметы:", Align = TextAnchor.UpperCenter, FontSize = 18, Font = "robotocondensed-regular.ttf" },
                        RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -155", OffsetMax = "0 -133" }
                    }, Layer);

                    container.Add(new CuiElement
                    {
                        Parent = Layer,
                        Components =
                        {
                            GetImageComponent("https://static.moscow.ovh/images/games/rust//plugins/ultimate_ui/exit.png", "Kits_img_exit"),
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-73.9 20", OffsetMax = "-28.6 80"},
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = Layer,
                        Components =
                        {
                            new CuiImageComponent {Color = "0.33 0.87 0.59 0.6"},
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 25.2"}
                        }
                    });
                    container.Add(new CuiButton
                    {
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_KITS prev",
                            Close = Layer
                        },
                        Text = { Text = "Вернуться назад", Align = TextAnchor.UpperCenter, FontSize = 18 },
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 49.2" },
                    }, Layer);
                    container.Add(new CuiButton
                    {
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_KITS prev",
                            Close = Layer
                        },
                        Text = { Text = "" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }, Layer);

                    var itemSize = 103.3f;
                    var itemSep = 6.6f;
                    var num = Mathf.Min(6, kitInfo.items.Count);
                    var posX = -(itemSize * num + itemSep * (num - 1)) / 2f;
                    var posY = 0f;
                    
                    for (var i = 0; i < kitInfo.items.Count;)
                    {
                        var item = kitInfo.items[i];
                        container.Add(new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0.5 0.65", AnchorMax = "0.5 0.65", OffsetMin = $"{posX} {posY - itemSize}", OffsetMax = $"{posX + itemSize} {posY}"
                            },
                            Image = { Color = "0 0 0 0.6" }
                        }, Layer, Layer + $".Item{i}");
                        
                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".Item{i}",
                            Components =
                            {
                                GetItemImageComponent(item.shortname),
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                            }
                        });

                        if (item.amount > 1)
                        {
                            container.Add(new CuiLabel()
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-3 -3" },
                                Text = { Text = $"x{item.amount}", Font = "RobotoCondensed-Bold.ttf", Align = TextAnchor.LowerRight, FontSize = 14 }
                            }, Layer + $".Item{i}");
                        }

                        if (++i % 6 == 0)
                        {
                            posY -= itemSize + itemSep;
                            num = Mathf.Min(6, kitInfo.items.Count - i);
                            posX = -(itemSize * num + itemSep * (num - 1)) / 2f;
                        }
                        else posX += itemSize + itemSep;
                    }
                    CuiHelper.AddUi(player, container);

                    break;
                }
                case "showavailablekits":
                {
                    CuiHelper.DestroyUi(player, Layer);

                    var container = new CuiElementContainer();

                    container.Add(new CuiPanel
                    {
                        CursorEnabled = true,
                        Image =
                        {
                            FadeIn = 0.2f,
                            Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                            Color = "0 0 0 1"
                        }
                    }, "Overlay", Layer);
                    container.Add(new CuiPanel
                    {
                        Image =
                        {
                            FadeIn = 0.2f,
                            Color = "0.2 0.2 0.17 0.7",
                            Material = "assets/content/ui/uibackgroundblur.mat"
                        }
                    }, Layer);

                    container.Add(new CuiLabel
                    {
                        Text = { Text = "НАБОРЫ", Align = TextAnchor.UpperCenter, FontSize = 40, Font = "robotocondensed-bold.ttf" },
                        RectTransform = { AnchorMin = "0.3 1", AnchorMax = "0.7 1", OffsetMin = "0 -155", OffsetMax = "0 -91.6" }
                    }, Layer);
                    container.Add(new CuiLabel
                    {
                        Text = { Text = "Вы можете забрать наборы", Align = TextAnchor.UpperCenter, FontSize = 18, Font = "robotocondensed-regular.ttf" },
                        RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -155", OffsetMax = "0 -133" }
                    }, Layer);

                    container.Add(new CuiElement
                    {
                        Parent = Layer,
                        Components =
                        {
                            GetImageComponent("https://static.moscow.ovh/images/games/rust//plugins/ultimate_ui/exit.png", "Kits_img_exit"),
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-73.9 20", OffsetMax = "-28.6 80"},
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = Layer,
                        Components =
                        {
                            new CuiImageComponent {Color = "0.33 0.87 0.59 0.6"},
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 25.2"}
                        }
                    });
                    container.Add(new CuiButton
                    {
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_KITS close",
                            Close = Layer
                        },
                        Text = { Text = "Покинуть страницу", Align = TextAnchor.UpperCenter, FontSize = 18 },
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 49.2" },
                    }, Layer);
                    container.Add(new CuiButton
                    {
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_KITS close",
                            Close = Layer
                        },
                        Text = { Text = "" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }, Layer);

                        var kitSizeX = 183.3f;
                    var kitSizeY = 46.6f;
                    var kitSepX = 13.3f;
                    var kitSepY = 24f;
                    var num = Mathf.Min(5, kits.Count);
                    var posX = -(kitSizeX * num + kitSepX * (num - 1)) / 2f;
                    var posY = 0f;
                    
                    for (var i = 0; i < kits.Count;)
                    {
                        var kit = kits.ElementAt(i);
                        var dataPlayer = GetKitData(kitsInfo, kit);
                        var time = dataPlayer.cooldown - TimeHelper.GetTimeStamp();

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.5 0.65", AnchorMax = "0.5 0.65", OffsetMin = $"{posX} {posY - kitSizeY}", OffsetMax = $"{posX + kitSizeX} {posY}"},
                            Text =
                            {
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 18,
                                Text = kit.kitName
                            },
                            Button =
                            {
                                Color = "0 0 0 0.6",
                                Command = $"UI_KITS givekit {kit.kitName} {i}"
                            }
                        }, Layer, Layer + $".Kits{i}");
                        
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-16 -16", OffsetMax = "0 0" },
                            Text =
                            {
                                Text = "?",
                                FontSize = 12,
                                Align = TextAnchor.MiddleCenter
                            },
                            Button =
                            {
                                Color = "0 0 0 0.6",
                                Command = $"UI_KITS showinfokit {kit.kitName}"
                            }
                        }, Layer + $".Kits{i}");

                        if (time < 0)
                        {
                            container.Add(new CuiPanel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 4.6" },
                                Image = { Color = "0.33 0.87 0.59 0.6" }
                            }, Layer + $".Kits{i}", Layer + $".Kits{i}.Status");
                        }
                        else
                        {
                            container.Add(new CuiLabel
                            {
                                Text =
                                {
                                    Align = TextAnchor.LowerCenter,
                                    FontSize = 13,
                                    Font = "RobotoCondensed-Regular.ttf",
                                    Text = TimeHelper.FormatTime(TimeSpan.FromSeconds(time), 2)
                                },
                                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 2", OffsetMax = $"0 {kitSepY}" }
                            }, Layer + $".Kits{i}", Layer + $".Kits{i}.Status.Text");
                                container.Add(new CuiPanel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 4.6" },
                                Image = { Color = "0.87 0.33 0.33 0.5" }
                            }, Layer + $".Kits{i}", Layer + $".Kits{i}.Status");
                        }
                        if (++i % 5 == 0)
                        {
                            posY -= kitSizeY + kitSepY;
                            num = Mathf.Min(5, kits.Count - i);
                            posX = -(kitSizeX * num + kitSepX * (num - 1)) / 2f;
                        }
                        else posX += kitSizeX + kitSepX;
                    }

                    CuiHelper.AddUi(player, container);

                    break;
                }
                case "givekit":
                {
                    var nameKit = arg.GetString(1, "text");

                    int idKit;

                    if (arg.HasArgs(4))
                    {
                        idKit = arg.GetInt(3);
                        nameKit += " " + arg.GetString(2);
                    }
                    else idKit = arg.GetInt(2);

                    var kitInfo1 = _config.kits.Find(kit => kit.kitName == nameKit);
                    if (kitInfo1 == null) return;

                    var playerData = GetKitData(kitsInfo, kitInfo1);

                    var kitData = _config.kits.First(x => x.kitName == nameKit);
                    if (playerData != null)
                    {
                        if (playerData.cooldown > TimeHelper.GetTimeStamp()) return;

                        if (playerData.amount != -1)
                        {
                            if (playerData.amount == 0) return;
                        }

                        GiveItems(player, kitData);
                        playerData.cooldown = TimeHelper.GetTimeStamp() + kitData.cooldownKit;

                        CuiHelper.DestroyUi(player, Layer + $".Kits{idKit}.Status.Text");
                        CuiHelper.DestroyUi(player, Layer + $".Kits{idKit}.Status");
                        CuiHelper.DestroyUi(player, Layer + "Status");

                        var container = new CuiElementContainer();

                        container.Add(new CuiLabel
                        {
                            Text =
                        {
                            Align = TextAnchor.LowerCenter,
                            FontSize = 13,
                            Font = "RobotoCondensed-Regular.ttf",
                            Text = TimeHelper.FormatTime(TimeSpan.FromSeconds(playerData.cooldown - TimeHelper.GetTimeStamp()))
                        },
                            RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 2", OffsetMax = $"0 24" }
                        }, Layer + $".Kits{idKit}", Layer + $".Kits{idKit}.Status.Text");
                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 4.6" },
                            Image = { Color = "0.87 0.33 0.33 0.5" }
                        }, Layer + $".Kits{idKit}", Layer + $".Kits{idKit}.Status");

                        container.Add(new CuiLabel
                        {
                            Text = { Text = "Кит успешно выдан и отправлен к вам в инвентарь", Align = TextAnchor.LowerCenter, FontSize = 18, Font = "robotocondensed-bold.ttf" },
                            RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-250 104", OffsetMax = "250 130" }
                        }, Layer, Layer + "Status");
                        CuiHelper.AddUi(player, container);

                        CuiHelper.AddUi(player, container);

                        if (kitData.maxUse != -1) playerData.amount -= 1;
                    }

                    break;
                }
            }
        }

        [ChatCommand("kit")] 
        void KitOpen(BasePlayer player, string command, string[] args)
        { 
            var ret = Interface.Call("CanRedeemKit", player) as string;
             
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            
            player.SendConsoleCommand("UI_KITS showavailablekits");
        }
        
        [ChatCommand("kits")] 
        void KitsOpen(BasePlayer player, string command, string[] args)
        {
            var ret = Interface.Call("CanRedeemKit", player) as string;
            
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            
            player.SendConsoleCommand("UI_KITS showavailablekits");
        }

        #endregion
        
        #region Methods
        
        private List<KitInfo> GetKitsForPlayer(BasePlayer player)
        {
            var kitsInfo = GetKitsInfo(player);
            return _config.kits.Where(kit => (string.IsNullOrEmpty(kit.privilege) || permission.UserHasPermission(player.UserIDString, kit.privilege)) && GetKitData(kitsInfo, kit).amount != 0).ToList(); 
        }
         
        private void GiveItems(BasePlayer player, KitInfo kit)
        {
            foreach(var kitItem in kit.items)
            {             
                GiveItem(player,BuildItem(kitItem.shortname,kitItem.amount,kitItem.skinID,kitItem.Condition,kitItem.Weapon,kitItem.Content), kitItem.place == "Панель" ? player.inventory.containerBelt : kitItem.place == "Одежда" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }
        
        private void GiveItem(BasePlayer player, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            
            player.GiveItem(item);
        }
        
        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;
            if(weapon != null)
            {
                ((BaseProjectile) item.GetHeldEntity()).primaryMagazine.contents = weapon.ammoAmount;
                ((BaseProjectile) item.GetHeldEntity()).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
            }
            if(Content != null)
            {
                foreach(var cont in Content)
                {
                    Item newCont = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    newCont.condition = cont.Condition;
                    newCont.MoveToContainer(item.contents);
                }
            }
            return item;
        }
        
        private List<ItemInfo> GetPlayerItems(BasePlayer player)
        {
            List<ItemInfo> kititems = new List<ItemInfo>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "Одежда");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "Рюкзак");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "Панель");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }
        
        private ItemInfo ItemToKit(Item item, string container)
        {
            ItemInfo itemInfo = new ItemInfo();

            itemInfo.amount = item.amount;
            itemInfo.place = container;
            itemInfo.shortname = item.info.shortname;
            itemInfo.Condition = item.condition;
            itemInfo.skinID = item.skin;
            itemInfo.Weapon = null;
            itemInfo.Content = null;
            
            if(item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if(weapon != null)
                {
                    itemInfo.Weapon = new Weapon();
                    itemInfo.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    itemInfo.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }
            
            if(item.contents != null)
            {
                itemInfo.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    itemInfo.Content.Add(new ItemContent()
                    {
                        Amount = cont.amount,
                        Condition = cont.condition,
                        ShortName = cont.info.shortname
                    });
                }
            }

            return itemInfo;
        }
        
        private static string HexToRGB(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }
 
            var str = hex.Trim('#');
 
            if (str.Length == 6)
                str += "FF";
 
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
 
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
 
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion 

        #region Config

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration()
            {
                spawnKit = new List<ItemInfo>()
                {
                    new ItemInfo()
                    {
                        amount = 1,
                        shortname = "rock",
                        Content = null,
                        place = "Панель",
                    }
                }
            };
        }
        
        public Configuration _config;

        public class Configuration
        {
            [JsonProperty("Набор на респавне")] public List<ItemInfo> spawnKit = new List<ItemInfo>();
            [JsonProperty("Наборы")] public List<KitInfo> kits = new List<KitInfo>();
        }
        
        #endregion

        #region Class

        public class KitInfo
        {
            [JsonProperty("Название")] public string kitName = "";
            [JsonProperty("Максимум использований")] public int maxUse = 0;
            [JsonProperty("Кулдаун")] public double cooldownKit = 0;
            [JsonProperty("Привилегия")] public string privilege = "";
            [JsonProperty("Предметы")] public List<ItemInfo> items = new List<ItemInfo>();
        }
        
        public class ItemInfo
        {
            [JsonProperty("Позиция")] public int position = 0;
            [JsonProperty("Shortname")] public string shortname = "";
            [JsonProperty("Количество")] public int amount = 0;
            [JsonProperty("Место")] public string place = "Рюкзак";
            [JsonProperty("Скин")] public ulong skinID = 0U;
            [JsonProperty("Контейнер")] public List<ItemContent> Content { get; set; }
            [JsonProperty("Прочность")] public float Condition { get; set; }
            [JsonProperty("Оружие")] public Weapon Weapon { get; set; }
        }
        
        public class Weapon
        {
            public string ammoType { get; set; }
            public int ammoAmount { get; set; }
        }
        public class ItemContent
        {
            public string ShortName { get; set; }
            public float Condition { get; set; }
            public int Amount { get; set; }
        }

        #endregion
        
        #region Data

        class StoredData
        {
            public Dictionary<ulong, KitsInfo> players = new Dictionary<ulong, KitsInfo>();
        }

        class KitsInfo
        {
            public Dictionary<string, KitData> kits = new Dictionary<string, KitData>();
        }

        class KitData
        {
            [JsonProperty("a")]
            public int amount = 0;
            
            [JsonProperty("cd")]
            public double cooldown = 0;
        }
        
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Temporary/Kits/kits", storedData);
        }

        void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("Temporary/Kits/kits");
            }
            catch (Exception ex)
            {
                PrintError($"Failed to load data: {ex}");
            }
            
            if (storedData == null)
                storedData = new StoredData();
        }

        StoredData storedData;
        
        #endregion

        #region Helper

        private static class TimeHelper
        {
            public static string FormatTime(TimeSpan time, int maxSubstr = 5, string language = "ru")
            {
                string result = string.Empty;
                switch (language)
                {
                    case "ru":
                        int i = 0;
                        if (time.Days != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Days, "д", "д", "д")}";
                            i++;
                        }

                        if (time.Hours != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Hours, "ч", "ч", "ч")}";
                            i++;
                        }

                        if (time.Minutes != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Minutes, "м", "м", "м")}";
                            i++;
                        }

                        
                        
                        if (time.Days == 0)
                        {
                            if (time.Seconds != 0 && i < maxSubstr)
                            {
                                if (!string.IsNullOrEmpty(result))
                                    result += " ";

                                result += $"{Format(time.Seconds, "с", "с", "с")}";
                                i++;
                            }
                        }

                        break;
                    case "en":
                        result = string.Format("{0}{1}{2}{3}",
                            time.Duration().Days > 0
                                ? $"{time.Days:0} day{(time.Days == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Hours > 0
                                ? $"{time.Hours:0} hour{(time.Hours == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Minutes > 0
                                ? $"{time.Minutes:0} minute{(time.Minutes == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Seconds > 0
                                ? $"{time.Seconds:0} second{(time.Seconds == 1 ? String.Empty : "s")}"
                                : string.Empty);

                        if (result.EndsWith(", ")) result = result.Substring(0, result.Length - 2);

                        if (string.IsNullOrEmpty(result)) result = "0 seconds";
                        break;
                }

                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units}{form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units}{form2}";

                return $"{units}{form3}";
            }

            private static DateTime Epoch = new DateTime(1970, 1, 1);

            public static double GetTimeStamp()
            {
                return DateTime.Now.Subtract(Epoch).TotalSeconds;
            }
        }

        #endregion
		
		
		public CuiRawImageComponent GetAvatarImageComponent(ulong user_id, string color = "1.0 1.0 1.0 1.0"){
			
			if (plugins.Find("ImageLoader")) return plugins.Find("ImageLoader").Call("BuildAvatarImageComponent",user_id) as CuiRawImageComponent;
			if (plugins.Find("ImageLibrary")) {
				return new CuiRawImageComponent { Png = (string)plugins.Find("ImageLibrary").Call("GetImage", user_id.ToString()), Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga" };
			}
			return new CuiRawImageComponent {Url = "https://image.flaticon.com/icons/png/512/37/37943.png", Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
		}
		public CuiRawImageComponent GetImageComponent(string url, string shortName="", string color = "1.0 1.0 1.0 1.0"){
			
			if (plugins.Find("ImageLoader")) return plugins.Find("ImageLoader").Call("BuildImageComponent",url) as CuiRawImageComponent;
			if (plugins.Find("ImageLibrary")) {
				if (!string.IsNullOrEmpty(shortName)) url = shortName;
				//Puts($"{url}: "+ (string)plugins.Find("ImageLibrary").Call("GetImage", url));
				return new CuiRawImageComponent { Png = (string)plugins.Find("ImageLibrary").Call("GetImage", url), Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
			}
			return new CuiRawImageComponent {Url = url, Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
		}
		public CuiRawImageComponent GetItemImageComponent(string shortName){
			string itemUrl = shortName;
			if (plugins.Find("ImageLoader")) {itemUrl = $"https://static.moscow.ovh/images/games/rust/icons/{shortName}.png";}
            return GetImageComponent(itemUrl, shortName);
		}
		public bool AddImage(string url,string shortName=""){
			if (plugins.Find("ImageLoader")){				
				plugins.Find("ImageLoader").Call("CheckCachedOrCache", url);
				return true;
			}else
			if (plugins.Find("ImageLibrary")){
				if (string.IsNullOrEmpty(shortName)) shortName=url;
				plugins.Find("ImageLibrary").Call("AddImage", url, shortName);
				//Puts($"Add Image {shortName}");
				return true;
			}	
			return false;		
		}
		
    }
}

// --- End of file: Kits4.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HomeRecycler.cs ---
// --- Original Local Path: HomeRecycler.cs ---

using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("HomeRecycler", "wazzzup", "1.3.2")]
    [Description("Allows to have Recycler at home")]
    class HomeRecycler : RustPlugin
    {
        [PluginReference]
        Plugin Friends;

        Dictionary<uint, ulong> startedRecyclers = new Dictionary<uint, ulong>();
        public Dictionary<int, KeyValuePair<string, int>> itemsNeededToCraft = new Dictionary<int, KeyValuePair<string, int>>();
        public static HomeRecycler Instance;

        private ItemBlueprint bp;

        private class RecyclerEntity : MonoBehaviour
        {
            private DestroyOnGroundMissing desGround;
            private GroundWatch groundWatch;
            public ulong OwnerID;

            void Awake()
            {
                OwnerID = GetComponent<BaseEntity>().OwnerID;
                desGround = GetComponent<DestroyOnGroundMissing>();
                if (!desGround) gameObject.AddComponent<DestroyOnGroundMissing>();
                groundWatch = GetComponent<GroundWatch>();
                if (!groundWatch) gameObject.AddComponent<GroundWatch>();
            }
        }

        PluginData pluginData;
        class PluginData
        {
            public Dictionary<ulong, double> userCooldowns = new Dictionary<ulong, double>();
            public Dictionary<ulong, int> userSpawned = new Dictionary<ulong, int>();
            public Dictionary<ulong, double> userCooldownsCraft = new Dictionary<ulong, double>();
            public Dictionary<ulong, int> userCrafted = new Dictionary<ulong, int>();
        }

        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, pluginData);
        }

        ConfigData configData;
        class ConfigData
        {
            public string chatCommand = "rec";
            public string craftCommand = "craftrecycler";
            public bool restrictUseByCupboard = true;
            public bool adminSpawnsPublicRecycler = true;
            public bool useSpawning = false;
            public bool useCrafting = false;
            public bool useSpawnCooldown = true;
            public bool useCraftCooldown = true;
            public bool useSpawnLimit = false;
            public bool useCraftLimit = false;
            public bool allowDeployOnGround = false;
            public bool allowPickupByHammerHit = true;
            public bool pickupOnlyOwnerFriends = true;
            public bool spawnInLoot = false;
            public Rates DefaultRates = new Rates();
            public Dictionary<string, int> itemsNeededToCraft = new Dictionary<string, int>()
            {
                { "scrap", 750 },
                { "gears", 25 },
                { "metalspring", 25 },
            };
            public Dictionary<string, Rates> PermissionsRates = new Dictionary<string, Rates>();
            public List<Loot> Loot = new List<Loot>();
        }

        public class Loot
        {
            public string containerName;
            public int probability = 0;
        }

        class Rates
        {
            public int Priority = 1;
            public float spawnCooldown = 86400f;
            public float craftCooldown = 86400f;
            public int craftLimit = 1;
            public int spawnLimit = 1;
            public float Ratio = 0.5f;
            public float RatioScrap = 1f;
            public float Speed = 5f;
            public float percentOfMaxStackToTake = 0.1f;
        }

        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData()
            {
                PermissionsRates = new Dictionary<string, Rates>()
                {
                    {  "viptest", new Rates() },
                    {  "viptest2", new Rates(){ Priority =2, Ratio = 0.7f, Speed =3f } }
                }
            };
            SaveConfig(configData);
            PrintWarning("New configuration file created.");
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"Title", "Recycler:" },
                {"badCommand", "you can get recycler in kit home" },
                {"buldingBlocked", "you need building privilege" },
                {"cooldown", "Сooldown, wait {0} seconds" },
                {"cooldown craft", "Сooldown, wait {0} seconds" },
                {"recycler crafted", "You have crafted a recycler" },
                {"recycler got", "You have got a recycler" },
                {"cannot craft", "Sorry, you can't craft a recycler" },
                {"not enough ingredient", "You should have {0} x{1}" },
                {"inventory full", "You should have space in inventory" },
                {"limit", "You have reached the limit of {0} recyclers" },
                {"place on construction", "You can't place it on ground" },
                {"cant pick", "You can pickup only your own or friend recycler" },
            }, this, "en");
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"Title", "Переработчик:" },
                {"badCommand", "ты можешь получить его в kit home" },
                {"buldingBlocked", "нужна авторизация в шкафу" },
                {"cooldown", "Подождите еще {0} секунд" },
                {"cooldown craft", "Подождите еще {0} секунд" },
                {"recycler crafted", "Ты скрафтил переработчик" },
                {"recycler got", "Ты получил переработчик" },
                {"cannot craft", "Ты не можешь крафтить переработчик" },
                {"not enough ingredient", "Тебе нужно {0} x{1}" },
                {"inventory full", "Нет места в инвентаре" },
                {"limit", "Достигнут лимит в {0} переработчика" },
                {"place on construction", "Нельзя ставить на землю" },
                {"cant pick", "Ты можешь поднять только свой переработчик или друга" },
            }, this, "ru");
        }
        void Init()
        {
            Instance = this;
            configData = Config.ReadObject<ConfigData>();
            configData.PermissionsRates = configData.PermissionsRates.OrderBy(i => -i.Value.Priority).ToDictionary(x => x.Key, x => x.Value);
            SaveConfig(configData);
            Unsubscribe(nameof(OnLootSpawn));
            if (!configData.allowPickupByHammerHit) Unsubscribe(nameof(OnHammerHit));
            try
            {
                pluginData = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(this.Title);
            }
            catch
            {
                pluginData = new PluginData();
            }
            foreach (var perm in configData.PermissionsRates)
            {
                permission.RegisterPermission("homerecycler." + perm.Key, this);
            }
            permission.RegisterPermission("homerecycler.canget", this);
            permission.RegisterPermission("homerecycler.cancraft", this);
            permission.RegisterPermission("homerecycler.ignorecooldown", this);
            permission.RegisterPermission("homerecycler.ignorecraftcooldown", this);

            if (configData.useSpawning)
            {
                cmd.AddChatCommand(configData.chatCommand, this, "cmdRec");
            }
            if (configData.useCrafting) {
                if (configData.itemsNeededToCraft.Count < 1)
                {
                    PrintWarning("no items set to craft, check config");
                }
                else
                {
                    cmd.AddChatCommand(configData.craftCommand, this, "cmdCraft");
                }
            }
        }
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        void OnNewSave()
        {
            pluginData = new PluginData();
            SaveData();
        }

        void OnServerInitialized()
        {
            var allobjects = UnityEngine.Object.FindObjectsOfType<Recycler>();
            foreach(var r in allobjects)
            {
                if (r.OwnerID!=0 && r.gameObject.GetComponent<RecyclerEntity>()==null)
                    r.gameObject.AddComponent<RecyclerEntity>();
            }
            var ingredients = new List<ItemAmount>();
            foreach (var i in configData.itemsNeededToCraft)
            {
                var def = ItemManager.FindItemDefinition(i.Key);
                if (def == null)
                {
                    PrintWarning($"cannot find item {i.Key} for crafting, check config");
                    continue;
                }
                itemsNeededToCraft.Add(def.itemid, i);
            }
            if (configData.spawnInLoot)
            {
                Subscribe(nameof(OnLootSpawn));
                foreach (var container in UnityEngine.Object.FindObjectsOfType<LootContainer>())
                {
                    if (configData.Loot.FirstOrDefault(c => c.containerName == container.ShortPrefabName) == null)
                    {
                        configData.Loot.Add(new Loot() { containerName = container.ShortPrefabName });
                    }
                    container.SpawnLoot();
                }
            }
            SaveConfig(configData);
        }

        void OnLootSpawn(LootContainer container)
        {
            timer.In(1f, () =>
            {
                if (container == null) return;
                Loot cont = configData.Loot.FirstOrDefault(c => c.containerName == container.ShortPrefabName);
                if (cont == null || cont.probability < 1) return;
                int current = UnityEngine.Random.Range(0, 100);
                if (current <= cont.probability)
                {
                    container.inventorySlots = container.inventory.itemList.Count() + 5;
                    container.inventory.capacity = container.inventory.itemList.Count() + 5;
                    container.SendNetworkUpdateImmediate();
                    GiveRecycler(container.inventory);
                    //PlaceComponent(container, cont.itemid, cont.skinid, cont.name, cont.minCount, cont.maxCount);
                }
            });
        }

        void Unload()
        {
            var allobjects = UnityEngine.Object.FindObjectsOfType<RecyclerEntity>();
            foreach (var r in allobjects)
            {
                GameObject.Destroy(r);
            }
        }

        object CanStackItem(Item item, Item anotherItem)
        {
            if (item.info.itemid == 833533164 && item.skin == 1321253094)
                return false;
            return null;
        }

        float GetCraftLimit(BasePlayer player)
        {
            foreach (var perm in configData.PermissionsRates)
            {
                if (permission.UserHasPermission(player.UserIDString, "homerecycler." + perm.Key))
                {
                    return perm.Value.craftLimit;
                }
            }
            return configData.DefaultRates.craftLimit;
        }

        float GetSpawnLimit(BasePlayer player)
        {
            foreach (var perm in configData.PermissionsRates)
            {
                if (permission.UserHasPermission(player.UserIDString, "homerecycler." + perm.Key))
                {
                    return perm.Value.spawnLimit;
                }
            }
            return configData.DefaultRates.spawnLimit;
        }

        float GetCraftCooldown(BasePlayer player)
        {
            foreach (var perm in configData.PermissionsRates)
            {
                if (permission.UserHasPermission(player.UserIDString, "homerecycler." + perm.Key))
                {
                    return perm.Value.craftCooldown;
                }
            }
            return configData.DefaultRates.craftCooldown;
        }

        float GetSpawnCooldown(BasePlayer player)
        {
            foreach (var perm in configData.PermissionsRates)
            {
                if (permission.UserHasPermission(player.UserIDString, "homerecycler." + perm.Key))
                {
                    return perm.Value.spawnCooldown;
                }
            }
            return configData.DefaultRates.spawnCooldown;
        }

        void cmdRec(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "homerecycler.canget"))
            {
                SendMsg(player, "badCommand");
                return;
            }
            if (configData.useSpawnCooldown)
            {
                if (!permission.UserHasPermission(player.UserIDString, "homerecycler.ignorecooldown"))
                {
                    double time = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
                    float spawnCooldown = GetSpawnCooldown(player);
                    if (!pluginData.userCooldowns.ContainsKey(player.userID))
                        pluginData.userCooldowns.Add(player.userID, time + spawnCooldown);
                    else
                    {
                        double nextUseTime = pluginData.userCooldowns[player.userID];
                        if (nextUseTime > time)
                        {
                            SendMsg(player, "cooldown", true, new string[] { ((int)(nextUseTime - time)).ToString() });
                            return;
                        }
                        else pluginData.userCooldowns[player.userID] = time + spawnCooldown;
                    }
                    SaveData();
                }
            }
            if (configData.useSpawnLimit)
            {
                if (!pluginData.userSpawned.ContainsKey(player.userID))
                    pluginData.userSpawned.Add(player.userID, 0);
                float spawnLimit = GetSpawnLimit(player);
                if (pluginData.userSpawned[player.userID]>=spawnLimit)
                {
                    SendMsg(player, "limit", true, new string[] { spawnLimit.ToString() });
                    return;
                }
                pluginData.userSpawned[player.userID]++;
                SaveData();
            }
            if (GiveRecycler(player))
            {
                SendMsg(player, "recycler got");
            }
            else
            {
                SendMsg(player, "inventory full");
            }
        }

        void cmdCraft(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "homerecycler.cancraft"))
            {
                SendMsg(player, "cannot craft");
                return;
            }
            string mess = "";
            bool enough = true;
            foreach(var item in itemsNeededToCraft)
            {
                var haveCount = player.inventory.GetAmount(item.Key);
                if (haveCount >= item.Value.Value) continue;
                mess += String.Format(msg("not enough ingredient", player)+"\n", item.Value.Key, item.Value.Value);
                enough = false;
            }
            if (!enough)
            {
                SendReply(player, mess);
                return;
            }

            if (configData.useCraftCooldown)
            {
                if (!permission.UserHasPermission(player.UserIDString, "homerecycler.ignorecraftcooldown"))
                {
                    double time = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
                    float craftCooldown = GetCraftCooldown(player);
                    if (!pluginData.userCooldownsCraft.ContainsKey(player.userID))
                        pluginData.userCooldownsCraft.Add(player.userID, time + craftCooldown);
                    else
                    {
                        double nextUseTime = pluginData.userCooldownsCraft[player.userID];
                        if (nextUseTime > time)
                        {
                            SendMsg(player, "cooldown craft", true, new string[] { ((int)(nextUseTime - time)).ToString() });
                            return;
                        }
                        else pluginData.userCooldownsCraft[player.userID] = time + craftCooldown;
                    }
                    SaveData();
                }
            }
            if (configData.useCraftLimit)
            {
                if (!pluginData.userCrafted.ContainsKey(player.userID))
                    pluginData.userCrafted.Add(player.userID, 0);
                float craftLimit = GetCraftLimit(player);
                if (pluginData.userCrafted[player.userID] >= craftLimit)
                {
                    SendMsg(player, "limit", true, new string[] { craftLimit.ToString() });
                    return;
                }
                pluginData.userCrafted[player.userID]++;
                SaveData();
            }
            foreach (var item in itemsNeededToCraft)
            {
                player.inventory.Take(null, item.Key, item.Value.Value);
            }
            if (GiveRecycler(player))
            {
                SendMsg(player, "recycler crafted");
            }
            else
            {
                SendMsg(player, "inventory full");
            }            
        }

        private string msg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player?.UserIDString);
        private void SendMsg(BasePlayer player, string langkey, bool title = true, params string[] args)
        {
            string message = $"<color=white>{String.Format(msg(langkey, player), args)}</color>";
            if (title) message = $"<color=orange>{msg("Title", player)}</color> " + message;
            SendReply(player, message);
        }

        [ConsoleCommand("giverecycler")]
        void cmdGiveRecycler(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player() ?? null;
            if (player?.net.connection.authLevel < 2) return;
            if (arg.Args == null || arg.Args.Length<1)
            {
                SendReply(arg, "bad syntax");
                return;
            }
            BasePlayer targetPlayer = BasePlayer.Find(arg.Args[0]);
            if (targetPlayer == null)
            {
                SendReply(arg, "error player not found for give");
                return;
            }
            if (GiveRecycler(targetPlayer))
            {
                SendReply(targetPlayer, msg("recycler got",targetPlayer));
            }
            else
            {
                SendReply(targetPlayer, msg("inventory full", targetPlayer));
            }
        }

        bool GiveRecycler(ItemContainer container)
        {
            var item = ItemManager.CreateByItemID(833533164, 1, 1321253094);
            item.name = "Recycler";
            return item.MoveToContainer(container,-1, false);
        }

        bool GiveRecycler(BasePlayer player)
        {
            var item = ItemManager.CreateByItemID(833533164, 1, 1321253094);
            item.name = "Recycler";
            if (!player.inventory.GiveItem(item))
            {
                item.Drop(player.inventory.containerMain.dropPosition, player.inventory.containerMain.dropVelocity, new Quaternion());
                return false;
            }
            return true;
        }

        bool Check(BaseEntity entity)
        {
            GroundWatch component = entity.gameObject.GetComponent<GroundWatch>();
            List<Collider> list = Facepunch.Pool.GetList<Collider>();
            Vis.Colliders<Collider>(entity.transform.TransformPoint(component.groundPosition), component.radius, list, component.layers, QueryTriggerInteraction.Collide);
            foreach (Collider collider in list)
            {
                if (!(collider.transform.root == entity.gameObject.transform.root))
                {
                    BaseEntity baseEntity = collider.gameObject.ToBaseEntity();
                    if ((!(bool)(baseEntity) || !baseEntity.IsDestroyed && !baseEntity.isClient) && baseEntity is BuildingBlock)
                    {
                        Facepunch.Pool.FreeList<Collider>(ref list);
                        return true;
                    }
                }
            }
            Facepunch.Pool.FreeList<Collider>(ref list);
            return false;
        }


        void OnEntityBuilt(Planner plan, GameObject obj)
        {
            var entity = obj.GetComponent<BaseEntity>();
            if (entity != null && entity.ShortPrefabName == "box.wooden.large" && entity.skinID == 1321253094L)
            {
                BasePlayer player = plan.GetOwnerPlayer();
                if (!configData.allowDeployOnGround && player.net.connection.authLevel < 2)
                {
                    if (!Check(entity))
                    {
                        GiveRecycler(player);
                        SendMsg(player, "place on construction");
                        entity.Kill();
                        return;
                    }
                }
                Recycler recycler = GameManager.server.CreateEntity("assets/bundled/prefabs/static/recycler_static.prefab", entity.transform.position, entity.transform.rotation) as Recycler;
                if (configData.adminSpawnsPublicRecycler && player.net.connection.authLevel == 2) recycler.OwnerID = 0;
                else recycler.OwnerID = player.userID;
                recycler.Spawn();
                entity.Kill();
                recycler.gameObject.AddComponent<RecyclerEntity>();
            }
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || info.HitEntity == null)
                return;
            RecyclerEntity rec = info.HitEntity.GetComponent<RecyclerEntity>();
            if (rec != null && rec.OwnerID != 0)
            {
                if ((player.IsBuildingBlocked() || player.GetBuildingPrivilege() == null) && !player.IsBuildingAuthed())
                {
                    SendMsg(player, "buldingBlocked");
                    return;
                }
                if (configData.pickupOnlyOwnerFriends && !(rec.OwnerID==player.userID || (bool)(Friends?.Call("AreFriends", rec.OwnerID, player.userID) ?? false)))
                {
                    SendMsg(player, "cant pick");
                    return;
                }
                if (GiveRecycler(player))
                {
                    SendMsg(player, "recycler got");
                }
                else
                {
                    SendMsg(player, "inventory full");
                }
                Recycler rec2 = rec.gameObject.GetComponent<Recycler>();
                if (rec2.inventory.itemList.Count > 0)
                {
                    rec2.inventory.Drop("assets/prefabs/misc/item drop/item_drop.prefab", rec2.transform.position + new Vector3(0f, 1f, 0f), rec2.transform.rotation);
                }
                info.HitEntity.Kill();
            }
        }

        void OnRecyclerToggle(Recycler recycler, BasePlayer player)
        {
            if (recycler.IsOn() || recycler.OwnerID == 0) return;
            if (configData.restrictUseByCupboard && recycler.OwnerID!=0 && (player.IsBuildingBlocked() || player.GetBuildingPrivilege() == null) && !player.IsBuildingAuthed())
            {
                NextTick(() =>
                {
                    SendMsg(player, "buldingBlocked");
                    recycler.StopRecycling();
                });
                return;
            }
            startedRecyclers[recycler.net.ID] = player.userID;
            NextTick(() =>
            {
                foreach (var perm in configData.PermissionsRates)
                {
                    if (permission.UserHasPermission(player.UserIDString, "homerecycler."+perm.Key))
                    {
                        recycler.CancelInvoke(new Action(recycler.RecycleThink));
                        recycler.InvokeRepeating(new Action(recycler.RecycleThink), perm.Value.Speed, perm.Value.Speed);
                        return;
                    }
                }
                if (configData.DefaultRates.Speed!=5f)
                {
                    recycler.CancelInvoke(new Action(recycler.RecycleThink));
                    recycler.InvokeRepeating(new Action(recycler.RecycleThink), configData.DefaultRates.Speed, configData.DefaultRates.Speed);
                }
            });
        }

        object OnRecycleItem(Recycler recycler, Item item)
        {
            if (recycler.OwnerID == 0) return null;
            if (item.info.Blueprint == null)
            {
                return false;
            }
            bool flag = false;
            float num = configData.DefaultRates.Ratio;
            float percentToTake = configData.DefaultRates.percentOfMaxStackToTake;
            if (startedRecyclers.ContainsKey(recycler.net.ID))
            {
                foreach (var perm in configData.PermissionsRates)
                {
                    if (permission.UserHasPermission(startedRecyclers[recycler.net.ID].ToString(), "homerecycler." + perm.Key))
                    {
                        num = perm.Value.Ratio;
                        percentToTake = perm.Value.percentOfMaxStackToTake;
                        break;
                    }
                }
            }
            //PrintWarning($"ratio is {num}");

            if (item.hasCondition)
            {
                num = Mathf.Clamp01(num * Mathf.Clamp(item.conditionNormalized * item.maxConditionNormalized, 0.1f, 1f));
                //PrintWarning($"corrected ratio is {num}");
            }
            int num2 = 1;
            if (item.amount > 1)
            {
                num2 = Mathf.CeilToInt(Mathf.Min((float)item.amount, (float)item.info.stackable * percentToTake));
            }
            //PrintWarning($"amount is {num2}");
            if (item.info.Blueprint.scrapFromRecycle > 0)
            {
                float ratioScrap = configData.DefaultRates.RatioScrap;
                if (startedRecyclers.ContainsKey(recycler.net.ID)) {
                    foreach (var perm in configData.PermissionsRates)
                    {
                        if (permission.UserHasPermission(startedRecyclers[recycler.net.ID].ToString(), "homerecycler." + perm.Key))
                        {
                            ratioScrap = perm.Value.RatioScrap;
                            break;
                        }
                    }
                }
                Item newItem = ItemManager.CreateByName("scrap", (int)(item.info.Blueprint.scrapFromRecycle * num2 * ratioScrap), 0uL);
                recycler.MoveItemToOutput(newItem);
            }
            item.UseItem(num2);
            foreach (ItemAmount ingredient in item.info.Blueprint.ingredients)
            {
                if (!(ingredient.itemDef.shortname == "scrap"))
                {
                    float num3 = ingredient.amount / (float)item.info.Blueprint.amountToCreate;
                    int num4 = 0;
                    if (num3 <= 1f)
                    {
                        for (int j = 0; j < num2; j++)
                        {
                            if (UnityEngine.Random.Range(0f, 1f) <= num)
                            {
                                num4++;
                            }
                        }
                    }
                    else
                    {
                        num4 = Mathf.CeilToInt(Mathf.Clamp(num3 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount) * (float)num2);
                    }
                    if (num4 > 0)
                    {
                        int num5 = Mathf.CeilToInt((float)num4 / (float)ingredient.itemDef.stackable);
                        for (int k = 0; k < num5; k++)
                        {
                            int num6 = (num4 <= ingredient.itemDef.stackable) ? num4 : ingredient.itemDef.stackable;
                            //PrintWarning($"num6 = {num6}");
                            Item newItem2 = ItemManager.Create(ingredient.itemDef, num6, 0uL);
                            if (!recycler.MoveItemToOutput(newItem2))
                            {
                                flag = true;
                            }
                            num4 -= num6;
                            if (num4 <= 0)
                            {
                                break;
                            }
                        }
                    }
                }
            }
            if (flag) recycler.StopRecycling();
            return false;
        }

    }
}

// --- End of file: HomeRecycler.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Replenish.cs ---
// --- Original Local Path: Replenish.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins {
    [Info("Replenish", "Skrallex", "1.3.1", ResourceId = 1956)]
    [Description("Easily replenish chests")]
    class Replenish : RustPlugin {
    	List<ReplenishableContainer> containers = new List<ReplenishableContainer>();
        List<ReplenishPlayer> playersUsing = new List<ReplenishPlayer>();
        Dictionary<string, string> allowableContainers = new Dictionary<string, string>();

        StoredData data;
        bool RequireAllSlotsEmpty;
        int DefaultTimerLength;
        bool UsePermissionsOnly;

        const string adminPerm = "replenish.admin";
        const string canEdit = "replenish.edit";
        const string canTest = "replenish.test";
        const string canList = "replenish.list";

        void Loaded() {
        	// Load previously saved replenishing containers.
            data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("ReplenishData");
            if(data.containers != null)
                containers = data.containers;

            // Add permissions.
            permission.RegisterPermission(adminPerm, this);
            permission.RegisterPermission(canEdit, this);
            permission.RegisterPermission(canList, this);
            permission.RegisterPermission(canTest, this);

            // Load config and localisations.
            LoadDefaultMessages();
            LoadConfig();
        }

        void Unload() {
            // Save replenishing containers.
            if(containers != null)
                data.containers = containers;
            Interface.Oxide.DataFileSystem.WriteObject("ReplenishData", data);
        }

        void OnServerSave() {
            // Save replenishing containers.
            if(containers != null)
                data.containers = containers;
            Interface.Oxide.DataFileSystem.WriteObject("ReplenishData", data);
        }

        protected override void LoadDefaultConfig() {
            Puts("Generating Default Config File");
            Config.Clear();
            Config["RequireAllSlotsEmpty"] = false;
            Config["DefaultTimerLength"] = 30;
            Config["UsePermissionsOnly"] = false;
            SaveConfig();
        }

        void LoadConfig() {
            RequireAllSlotsEmpty = (bool)Config["RequireAllSlotsEmpty"] == null ? false : (bool)Config["RequireAllSlotsEmpty"];
            DefaultTimerLength = (int)Config["DefaultTimerLength"] == null ? 30 : (int)Config["DefaultTimerLength"];
            UsePermissionsOnly = (bool)Config["UsePermissionsOnly"] == null ? false : (bool)Config["UsePermissionsOnly"];
        }

        void LoadDefaultMessages() {
            lang.RegisterMessages(new Dictionary<string, string> {
                {"Prefix", "<color=orange>Replenish</color>"},
                {"NoPermission", "You do not have permission to use this command."},

                {"AddSyntax", "Invalid command syntax. Try <color=cyan>/replenish_add</color> <color=red>{Optional: TimeInSeconds}</color>"},

                {"AlreadyReplenishing", "That container is already set to be replenished. Removing it first."},
                {"NotReplenishing", "That container is not set to replenish."},
                {"BoxAdded", "{0} with uid {1} has been added as a replenishable container with timer {2}s."},
                {"BoxRemoved", "{0} with uid {1} will no longer be replenishing."},
                {"BoxTested", "This {0} with uid {1} is set to replenish every {2}s."},
                {"AddSingle", "Hit the container you want to replenish with a Hammer."},
                {"AddMulti", "Hit the containers you want to replenish with a Hammer. Type /replenish_stop to stop."},
                {"RemoveSingle", "Hit the container you want to remove from replenishing with a Hammer." },
                {"RemoveMulti", "Hit the containers you want to remove from replenishing with a Hammer. Type /replenish_stop to stop."},
                {"TestSingle", "Hit the container you want to test if it is replenishing with a Hammer."},
                {"TestMulti", "Hit the containers you want to test if they are replenishing with a Hammer. Type /replenish_stop to stop."},
                {"NotUsing", "You are not currently using any Replenish commands."},
                {"StoppedUsing", "You have stopped using Replenish commands."},

                {"ListHeading", "The following containers have been set to replenish:{0}"},
                {"ListEmpty", "No containers have been set to replenish. Use /replenish_add to add some." },
                {"ListEntry", "\n\t->{0} ({1}) at x:{2} y:{3} z:{4} ({5}m away)." },
                {"Stop", "You have stopped adding/removing/testing replenishable containers!"},
                {"InvalidTimer", "Invalid timer length. Using default value of {0}s instead"},
                {"HelpText", "Invalid Usage. Valid Commands: \n><color=red>replenish_add</color>: Add a new replenishing container." +
                    "\n><color=red>replenish_addm</color>: Add multiple new replenishing containers." +
                    "\n><color=red>replenish_remove</color>: Remove a replenishing container." +
                    "\n><color=red>replenish_removem</color>: Remove multiple replenishing containers." +
                    "\n><color=red>replenish_test</color>: Test if a container is replenishing." +
                    "\n><color=red>replenish_testm</color>: Test if multiple containers are replenishing." +
                    "\n><color=red>replenish_list</color>: Lists all replenishing containers and their locations." +
                    "\n><color=red>replenish_stop</color>: Stop adding/removing/testing multiple containers." },

                {"smallwoodbox", "Small Wooden Box"},
                {"largewoodbox", "Large Wooden Box"},
                {"smallstash", "Small Stash"},
                {"furnace", "Furnace"},
                {"largefurnace", "Large Furnace"},
                {"lantern", "Lantern"},
                {"campfire", "Camp Fire"},
                {"watercatcher", "Water Barrel"},
                {"researchtable", "Research Table"},
                {"repairbench", "Repair Bench"},
                {"smallrefinery", "Refinery"},
                {"autoturret", "Auto Turret"},
                {"generic", "Generic Container"}
            }, this);
        }

        void OnHammerHit(BasePlayer player, HitInfo info) {
        	if(!IsPlayerEditing(player)) {
        		return;
        	}

        	StorageContainer container = info.HitEntity.GetComponent<StorageContainer>();
        	if(container == null)
        		return;
        	ReplenishPlayer rPlayer = GetReplenishPlayer(player);

            string type = container.panelName;
            Puts(type + "");

        	if(rPlayer.adding) {
        		CreateReplenishableContainer(player, rPlayer, container, info, type);
        	}

        	if(rPlayer.removing) {
        		RemoveReplenishableContainer(player, container);
        	}

        	if(rPlayer.testing) {
        		TestReplenishableContainer(player, container);
        	}

        	if(!rPlayer.multi) {
        		playersUsing.Remove(rPlayer);
        	}
        }

        void OnItemRemovedFromContainer(ItemContainer container, Item item) {
        	if(GetReplenishableContainer(container) == null)
        		return;
        	ReplenishableContainer repl = GetReplenishableContainer(container);

        	if(RequireAllSlotsEmpty && container.itemList.Count > 0)
        		return;

        	timer.Once((float)repl.timer, () => {
        		repl.Replenish(container);
        		});
        }

        void CreateReplenishableContainer(BasePlayer player, ReplenishPlayer rPlayer, StorageContainer container, HitInfo info, string type) {
        	if(GetReplenishableContainer(container.inventory) != null) {
        		containers.Remove(GetReplenishableContainer(container.inventory));
        		ReplyPlayer(player, "AlreadyReplenishing");
        	}

        	ReplenishableContainer repl = new ReplenishableContainer(container.inventory.uid, rPlayer.timer);
        	repl.type = Lang(type);
        	repl.SaveItems(container.inventory);
        	var worldPos = info.HitEntity.GetEstimatedWorldPosition();
        	repl.pos = new Pos(worldPos.x, worldPos.y, worldPos.z);
        	containers.Add(repl);
        	ReplyFormatted(player, String.Format(Lang("BoxAdded"), repl.type, repl.uid, repl.timer));
        }

        void RemoveReplenishableContainer(BasePlayer player, StorageContainer container) {
        	if(GetReplenishableContainer(container.inventory) == null) {
        		ReplyPlayer(player, "NotReplenishing");
        		return;
        	}
        	ReplenishableContainer repl = GetReplenishableContainer(container.inventory);
        	containers.Remove(repl);
        	ReplyFormatted(player, String.Format(Lang("BoxRemoved"), repl.type, repl.uid));
        }

        void TestReplenishableContainer(BasePlayer player, StorageContainer container) {
        	if(GetReplenishableContainer(container.inventory) == null) {
        		ReplyPlayer(player, "NotReplenishing");
        		return;
        	}
        	ReplenishableContainer repl = GetReplenishableContainer(container.inventory);
        	ReplyFormatted(player, String.Format(Lang("BoxTested"), repl.type, repl.uid, repl.timer));
        }

        [ChatCommand("replenish")]
        void chatCmdReplenish(BasePlayer player, string cmd, string[] args) {
        	ReplyPlayer(player, "HelpText");
        	return;
        }

        [ChatCommand("replenish_add")]
        void chatCmdReplenishAdd(BasePlayer player, string cmd, string[] args) {
        	int timer = DefaultTimerLength;
        	if(!IsAllowed(player, canEdit)) {
        		ReplyPlayer(player, "NoPermission");
        		return;
        	}
        	if(args.Length > 1) {
        		ReplyPlayer(player, "AddSyntax");
        		return;
        	}
        	if(args.Length == 1) {
        		if(!Int32.TryParse(args[0], out timer)) {
        			ReplyPlayer(player, "InvalidTimer");
        			return;
        		}
        	}
        	Add(player, timer, false);
        }

        [ChatCommand("replenish_addm")]
        void chatCmdReplenishAddm(BasePlayer player, string cmd, string[] args) {
        	int timer = DefaultTimerLength;
        	if(!IsAllowed(player, canEdit)) {
        		ReplyPlayer(player, "NoPermission");
        		return;
        	}
        	if(args.Length > 1) {
        		ReplyPlayer(player, "AddSyntax");
        		return;
        	}
        	if(args.Length == 1) {
        		if(!Int32.TryParse(args[0], out timer)) {
        			ReplyPlayer(player, "InvalidTimer");
        			return;
        		}
        	}
        	Add(player, timer, true);
        }

        void Add(BasePlayer player, int timer, bool multi) {
        	ReplenishPlayer rPlayer;
        	if(IsPlayerEditing(player)) {
        		rPlayer = GetReplenishPlayer(player);
        		rPlayer.StopUsing();
        	}
        	else {
        		rPlayer = new ReplenishPlayer(player);
        		playersUsing.Add(rPlayer);
        	}

        	if(multi) {
        		ReplyPlayer(player, "AddMulti");
        		rPlayer.multi = true;
        	}
        	else {
        		ReplyPlayer(player, "AddSingle");
        	}
        	rPlayer.adding = true;
        	rPlayer.timer = timer;
        }

		[ChatCommand("replenish_remove")]
		void chatCmdReplenishRemove(BasePlayer player, string cmd, string[] args) {
			if(!IsAllowed(player, canEdit)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
            if(args.Length == 1) {
                RemoveByID(player, args[0]);
                return;
            }
			Remove(player, false);
		}

		[ChatCommand("replenish_removem")]
		void chatCmdReplenishRemovem(BasePlayer player, string cmd, string[] args) {
			if(!IsAllowed(player, canEdit)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
			Remove(player, true);
		}

		void Remove(BasePlayer player, bool multi) {
			ReplenishPlayer rPlayer;
			if(IsPlayerEditing(player)) {
				rPlayer = GetReplenishPlayer(player);
				rPlayer.StopUsing();
			}
			else {
				rPlayer = new ReplenishPlayer(player);
				playersUsing.Add(rPlayer);
			}

			if(multi) {
				ReplyPlayer(player, "RemoveMulti");
				rPlayer.multi = true;
			}
			else {
				ReplyPlayer(player, "RemoveSingle");
			}
			rPlayer.removing = true;
		}

        void RemoveByID(BasePlayer player, string id) {
            foreach(ReplenishableContainer container in containers) {
                if(container.uid.ToString() == id) {
                    ReplyFormatted(player, String.Format(Lang("BoxRemoved"), container.type, container.uid));
                    containers.Remove(container);
                    return;
                }
            }
            ReplyPlayer(player, "NotReplenishing");
        }

		[ChatCommand("replenish_test")]
		void chatCmdReplenishTest(BasePlayer player, string cmd, string[] args) {
			if(!IsAllowed(player, canTest)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
			Test(player, false);
		}

		[ChatCommand("replenish_testm")]
		void chatCmdReplenishTestm(BasePlayer player, string cmd, string[] args) {
			if(!IsAllowed(player, canTest)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
			Test(player, true);
		}

		void Test(BasePlayer player, bool multi) {
			ReplenishPlayer rPlayer;
			if(IsPlayerEditing(player)) {
				rPlayer = GetReplenishPlayer(player);
				rPlayer.StopUsing();
			}
			else {
				rPlayer = new ReplenishPlayer(player);
				playersUsing.Add(rPlayer);
			}

			if(multi) {
				ReplyPlayer(player, "TestMulti");
				rPlayer.multi = true;
			}
			else {
				ReplyPlayer(player, "TestSingle");
			}
			rPlayer.testing = true;
		}

		[ChatCommand("replenish_list")]
		void chatCmdReplenishList(BasePlayer player, string cmd, string[] args) {
			if(!IsAllowed(player, canList)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
			List(player);
		}

		void List(BasePlayer player) {
			if(containers.Count < 1) {
				ReplyPlayer(player, "ListEmpty");
				return;
			}
			string reply = "";
			foreach(ReplenishableContainer container in containers) {
				Pos playerPos = new Pos(player.transform.position);
				double distance = Math.Sqrt(((playerPos.x - container.pos.x) * (playerPos.x - container.pos.x) + (playerPos.y - container.pos.y) * (playerPos.y - container.pos.y) + (playerPos.z - container.pos.z) * (playerPos.z - container.pos.z)));
				reply += String.Format(Lang("ListEntry"), container.type, container.uid, Math.Round(container.pos.x, 0), Math.Round(container.pos.y, 0), Math.Round(container.pos.z, 0), Math.Round(distance, 1));
			}
			ReplyFormatted(player, reply);
		}

		[ChatCommand("replenish_stop")]
		void chatCmdReplenishStop(BasePlayer player, string cmd, string[] args) {
			if(!IsAllowed(player, canEdit)) {
				ReplyPlayer(player, "NoPermission");
				return;
			}
			Stop(player);
			ReplyPlayer(player, "StoppedUsing");
		}

		void Stop(BasePlayer player) {
			if(!IsPlayerEditing(player)) {
				ReplyPlayer(player, "NotUsing");
				return;
			}
			ReplenishPlayer rPlayer = GetReplenishPlayer(player);

			playersUsing.Remove(rPlayer);
		}

        bool IsPlayerEditing(BasePlayer player) {
        	foreach(ReplenishPlayer rPlayer in playersUsing) {
        		if(rPlayer.player == player) {
        			return true;
        		}
        	}
        	return false;
        }

        bool IsPlayerAdding(BasePlayer player) {
        	foreach(ReplenishPlayer rPlayer in playersUsing) {
        		if(rPlayer.player == player) {
        			if(rPlayer.adding) {
        				return true;
        			}
        		}
        	}
        	return false;
        }

        bool IsPlayerRemoving(BasePlayer player) {
        	foreach(ReplenishPlayer rPlayer in playersUsing) {
        		if(rPlayer.player == player) {
        			if(rPlayer.removing) {
        				return true;
        			}
        		}
        	}
        	return false;
        }

        bool IsPlayerTesting(BasePlayer player) {
        	foreach(ReplenishPlayer rPlayer in playersUsing) {
        		if(rPlayer.player == player) {
        			if(rPlayer.testing) {
        				return true;
        			}
        		}
        	}
        	return false;
        }

        bool IsPlayerMulti(BasePlayer player) {
        	foreach(ReplenishPlayer rPlayer in playersUsing) {
        		if(rPlayer.player == player) {
        			if(rPlayer.multi) {
        				return true;
        			}
        		}
        	}
        	return false;
        }

        void ReplyPlayer(BasePlayer player, string langKey) {
    		SendReply(player, Lang("Prefix") + ": " + Lang(langKey));
    	}

        void ReplyFormatted(BasePlayer player, string msg) {
    		SendReply(player, Lang("Prefix") + ": " + msg);
    	}

        ReplenishPlayer GetReplenishPlayer(BasePlayer player) {
        	foreach(ReplenishPlayer rPlayer in playersUsing) {
        		if(rPlayer.player = player) {
        			return rPlayer;
        		}
        	}
        	return null;
        }

        ReplenishableContainer GetReplenishableContainer(ItemContainer container) {
        	foreach(ReplenishableContainer repl in containers) {
        		if(repl.uid == container.uid) {
        			return repl;
        		}
        	}
        	return null;
        }

        string Lang(string key) {
    		return lang.GetMessage(key, this, null);
    	}

        bool IsAllowed(BasePlayer player, string perm) {
    		if(player.IsAdmin() && !UsePermissionsOnly) return true;
    		if(permission.UserHasPermission(player.UserIDString, adminPerm)) return true;
    		if(permission.UserHasPermission(player.UserIDString, perm)) return true;
    		return false;
    	}

        public class ReplenishPlayer {
        	public BasePlayer player;
        	public int timer = 30;
        	public bool adding = false;
        	public bool removing = false;
        	public bool testing = false;
        	public bool multi = false;

        	public ReplenishPlayer(BasePlayer player) {
        		this.player = player;
        	}

        	public ReplenishPlayer() {}

        	public void StopUsing() {
        		this.timer = 30;
        		this.adding = false;
        		this.removing = false;
        		this.testing = false;
        		this.multi = false;
        	}
        }

        public class ReplenishableContainer {
        	public uint uid;
        	public string type = "";
        	public int timer;
        	public Pos pos = new Pos(0.0f, 0.0f, 0.0f);
        	public List<ContainerItem> items = new List<ContainerItem>();

        	public ReplenishableContainer(uint uid, int timer) {
        		this.uid = uid;
        		this.timer = timer;
        	}

        	public ReplenishableContainer() {}

        	public void SaveItems(ItemContainer container) {
        		items.Clear();
        		items.AddRange(GetItems(container));
        	}

        	public void Replenish(ItemContainer container) {
        		container.itemList = new List<Item>();
        		foreach (ContainerItem contItem in items) {
                    Item item = ItemManager.CreateByItemID(contItem.itemId, contItem.amount, contItem.skin);
                    var weapon = item.GetHeldEntity() as BaseProjectile;
                    if (weapon != null)
                        weapon.primaryMagazine.contents = contItem.ammo;
                    item.MoveToContainer(container);
                    if (contItem.contents == null)
                        continue;
                    foreach (ContainerItem contItem1 in contItem.contents) {
                        Item item1 = ItemManager.CreateByItemID(contItem1.itemId, contItem1.amount);
                        if (item1 == null)
                            continue;
                        item1.condition = contItem1.condition;
                        item1.MoveToContainer(item.contents);
                    }
                }
        	}

        	private IEnumerable<ContainerItem> GetItems(ItemContainer container) {
                return container.itemList.Select(item => new ContainerItem {
                    itemId = item.info.itemid,
                    amount = item.amount,
                    ammo = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.contents ?? 0,
                    skin = item.skin,
                    condition = item.condition,
                    contents = item.contents?.itemList.Select(item1 => new ContainerItem {
                        itemId = item1.info.itemid,
                        amount = item1.amount,
                        condition = item1.condition
                    }).ToArray()
                });
            }
        }

        public class ContainerItem {
	    	public int itemId, amount, ammo;
            public ulong skin;
	    	public float condition;
	    	public ContainerItem[] contents;
        }

        public class StoredData {
        	public List<ReplenishableContainer> containers = new List<ReplenishableContainer>();
        }

        [System.Serializable]
        public class Pos {
        	public float x, y, z;

        	public Pos(float x, float y, float z) {
        		this.x = x;
        		this.y = y;
        		this.z = z;
        	}

        	public Pos(Vector3 vec3) {
        		this.x = vec3.x;
        		this.y = vec3.y;
        		this.z = vec3.z;
        	}

        	public Pos() {}
        }
    }

}


// --- End of file: Replenish.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HelpGUI.cs ---
// --- Original Local Path: HelpGUI.cs ---

﻿using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System;
using System.Reflection;
using Oxide.Core;
using System.Linq;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins 
{ 
	[Info("Help GUI", "reyzi", "1.0")]
	[Description("Плагин отображает экран помощи")] 
	class HelpGUI : RustPlugin
	{ 
		private bool Changed;
		private string text;
		private string backroundimageurl;
		
		void Loaded()  
		{
			permission.RegisterPermission("helpgui.use", this);
			data = Interface.GetMod().DataFileSystem.ReadObject<Data>("HelpGUIdata");
			LoadVariables();
		}
		
		object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;  
        } 
		
		void LoadVariables() 
		{
			text = Convert.ToString(GetConfig("Messages", "HELP_MESSAGE", new List<string>{
				"<color=lime> - - - - - - - - - -Помощь - - - - - - - - - -</color>\n<color=lime>/tpr</color> <color=purple>- Телепортироваться к игроку</color>\n<color=lime>/pm</color> <color=purple>- Написать сообщение игроку</color>\n<color=lime>/home</color> <color=purple>- Посмотреть команды плагина /home</color>\n<color=lime>/clan</color> <color=purple>- Посмотреть информацию о кланах</color>\n<color=lime>/kit</color> <color=purple>- Посмотреть все доступные киты для игроков</color>\n<color=lime>/remove</color> <color=purple>- Удаление ваших построек</color>\n<color=lime>/friend</color> <color=purple>- Посмотреть как добавить в друзья</color>\n<color=lime>/ad</color> <color=purple>- Авто-Закрытие дверей</color>\n<color=lime>/rec</color> <color=purple>- Переработчик</color>\n<color=lime>/sil</color> <color=purple>- Загрузить фото на табличку</color>\n<color=lime>/trade</color> <color=purple>- Обмен с игроком ресурсами</color>\n\n\n\n\n\n<size=12>Хуган и базука 2 петуха</size>"
			}));
			
			if (Changed)
			{
				SaveConfig();
				Changed = false;
			
			}	
		}
		
		protected override void LoadDefaultConfig()
		{
			Puts("Создание нового файла конфигурации!");
			Config.Clear();
			LoadVariables();
		}


		

		class Data
		{
			public List<string> Players = new List<string>{};
		}


		Data data;

		void Unloaded()
		{
			foreach (BasePlayer current in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(current, "HelpGUI");
			}
		}
		
		
		void UseUI(BasePlayer player, string msg)
		{ 
			var elements = new CuiElementContainer();

			var mainName = elements.Add(new CuiPanel
			{
				Image =
				{
					Color = "0.1 0.1 0.1 0.9"
				},
				RectTransform =
				{
					AnchorMin = "0.343 0.237",
					AnchorMax = "0.641 0.832"
				},
				CursorEnabled = true
			}, "Overlay", "HelpGUI"); 			 
			var Agree = new CuiButton
            {
                Button =
                {
                    Close = mainName,
                    Color = "0.48 0.48 0.48 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.949 0.949",
					AnchorMax = "1 1"
                },
                Text =
                {
                    Text = "X",
                    FontSize = 17,
                    Align = TextAnchor.MiddleCenter
                }
            };
			elements.Add(new CuiLabel
			{
				Text =
                {
					Text = msg, 
                    FontSize = 17,
                    Align = TextAnchor.MiddleCenter
                },
                RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                }
			}, mainName);
			elements.Add(Agree, mainName);
			CuiHelper.AddUi(player, elements);
		}
	
		[ChatCommand("help")]
		void cmdRule(BasePlayer player, string cmd, string[] args)
		{
			string msg = "";
			foreach(var help in Config["Messages", "HELP_MESSAGE"] as List<object>)
			msg = msg + help.ToString() + "\n";
			UseUI(player, msg.ToString());
		}

		void DisplayUI(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(1, () => DisplayUI(player));
            }
            else 
			{
				string steamId = Convert.ToString(player.userID);
				{			
					if(data.Players.Contains(steamId)) return;
					string msg = "";
					foreach(var help in Config["Messages", "HELP_MESSAGE"] as List<object>)
					msg = msg + help.ToString() + "\n";
					UseUI(player, msg.ToString());
					data.Players.Add(steamId);	
					Interface.GetMod().DataFileSystem.WriteObject("HelpGUIdata", data);
				}
            }
        }
		
		
		void OnPlayerInit(BasePlayer player)		
		{
			DisplayUI(player);		
		}
	}
}

// --- End of file: HelpGUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RatesController.cs ---
// --- Original Local Path: RatesController.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RatesController", "", "2.1.3")] 
    [Description("Rate and Time controller - can change rates based on current game time")]

    class RatesController : RustPlugin
    {   
        private bool isDay;

        private string PickUpDayString = "Рейт поднимаемых ресурсов днём";
        private string PickUpNightString = "Рейт поднимаемых ресурсов ночью";
        private string GatherDayString = "Рейт добываемых ресурсов днём";
        private string GatherNightString = "Рейт добываемых ресурсов ночью";
        private string QuerryDayString = "Рейт добываемых ресурсов в карьере днём";
        private string QuerryNightString = "Рейт добываемых ресурсов в карьере ночью";
        private string LootDayString = "Рейт лута днём(если включен)";
        private string LootNightString = "Рейт лута ночью(если включен)";
        private string SmeltDayString = "Скорость работы печей днём";
        private string SmeltNightString = "Скорость работы печей ночью";

        private string DefaultRatesCfg = "Общие рейты ресурсов";
        private string CustomRatesCfg = "Изменение рейтов для игроков с привилегиями";
        private string DefaultPickupRatesCfg = "Стандартные рейты поднимаемых ресурсов";
        private string DefaultGatherRatesCfg = "Стандартные рейты добываемых ресурсов";
        private string DefaultSmeltRatesCfg = "Стандартное время переработки ресурсов (в секундах)";
        private string DefaultQuerryRatesCfg = "Стандартные рейты добываемых ресурсов в карьере";
        private string PrefixCfg = "Префикс в чате";
        private string PrefixColorCfg = "Цвет префикса в чате";
        private string UseLootMultyplierCfg = "Использовать умножение лута(выключите для совместимости с контроллерами лута)";
        private string DayStartCfg = "Час начала дня(игровое время)";
        private string DayLenghtCfg = "Длина дня(в минутах)";
        private string NightStartCfg = "Час начала ночи(игровое время)";
        private string NightLenghtCfg = "Длина ночи(в минутах)";
        private string WarnChatCfg = "Выводить сообщения в чат о начале дня или ночи";
        private string CoalRateDayCfg = "Рейт угля при сжигании дерева днём";
        private string CoalRateNightCfg = "Рейт угля при сжигании дерева ночью";
        private string CoalChanceDayCfg = "Шанс производства угля днём";
        private string CoalChanceNightCfg = "Шанс производства угля ночью";
        private string BlacklistedLootCfg = "Список лута, на который не действуют множители";
        private string MoreHQMCfg = "Добавить металл высокого качества во все рудные жилы";

        private List<string> AvaliableMods;
        private Dictionary<string, float> SmeltBackup = new Dictionary<string, float>();
        //Откат обновления ящиков
        Dictionary<int, DateTime> CratesCD = new Dictionary<int, DateTime>();
        //Список рудных жил и их бонусов
        Dictionary<BaseEntity, Dictionary<string, float>> DefaultFinishBonuses = new Dictionary<BaseEntity, Dictionary<string, float>>();

        private double CoalRate = 1f;
        private int CoalChance = 25;
        private double SmeltRate = 1f;
        private double GatherRate = 1f;
        private double PickupRate = 1f;
        private double QuerryRate = 1f;
        private double LootRate = 1f;

        #region config setup

        private string Prefix = "[Rates controller]";//Префикс плагина в чате
        private bool UseLootMultyplier = true; //Использовать множители лута
        private string PrefixColor = "#ff0000";//Цвет префикса
        private float DayStart = 6f;//Час, когда начинается день
        private float NightStart = 18f;//Час, когда начинается ночь
        private uint DayLenght = 30u;//Длинна дня
        private uint NightLenght = 30u;//Длинна ночи
        private bool WarnChat = true;//Выводить ли в чат оповещения о смене дня\ночи и рейтов.
        private bool MoreHQM = false; //Добавить ли во все рудные жилы мвк?

        //Стандартные рейты, для игроков без привелегий
        private Dictionary<string, double> DefaultRates = new Dictionary<string, double>();
        //Рейты для игроков с привелегиями
        private Dictionary<string, Dictionary<string, double>> CustomRates = new Dictionary<string, Dictionary<string, double>>();

        private double CoalRateDay = 1f;
        private double CoalRateNight = 1f;
        private int CoalChanceDay = 25;
        private int CoalChanceNight = 25;
        private Dictionary<string, double> DefaultSmeltRates = new Dictionary<string, double>();
        private Dictionary<string, double> DefaultGatherRates = new Dictionary<string, double>();
        private Dictionary<string, double> DefaultPickupRates = new Dictionary<string, double>();
        private Dictionary<string, double> DefaultQuerryRates = new Dictionary<string, double>();
        private List<string> BlacklistedLoot = new List<string>();
        
        #endregion

        #region Loading config

        //Загрузка стандартного конфиг-файла. Вызывается ТОЛЬКО в случае отсутствия файла PluginName.json в папке config
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru.\n Если вы приобрели плагин в другом месте - вы теряете все гарантии.");
        }

        void LoadConfigValues()
        {
            AvaliableMods = new List<string>()
            {
                GatherDayString,
                GatherNightString,
                PickUpDayString,
                PickUpNightString,
                QuerryDayString,
                QuerryNightString,
                LootDayString,
                LootNightString,
                SmeltDayString,
                SmeltNightString
            };
            Dictionary<string, object> defaultRates = CreatePerms(AvaliableMods, 1f);
            Dictionary<string, object> customRates = new Dictionary<string, object>()
            {
                ["ratescontroller.premium"] = CreatePerms(AvaliableMods, 3f),
                ["ratescontroller.vip"] = CreatePerms(AvaliableMods, 2f)
            };
            Dictionary<string, object> defaultGatherRates = new Dictionary<string, object>()
            {
                { "Animal Fat", 1.0},
                {"Bear Meat", 1.0},
                {"Bone Fragments", 1.0},
                {"Cloth", 1.0},
                {"High Quality Metal Ore", 1.0},
                {"Human Skull", 0.1},
                {"Leather", 1.0},
                {"Metal Ore", 1.0},
                {"Pork", 1.0},
                {"Raw Chicken Breast", 1.0},
                {"Raw Human Meat", 1.0},
                {"Raw Wolf Meat", 1.0},
                {"Stones", 1.0},
                {"Sulfur Ore", 1.0},
                {"Wolf Skull", 1.0},
                {"Wood", 1.0}
            };
            Dictionary<string, object> defaultPickupRates = new Dictionary<string, object>()
            {
                {"Metal Ore", 1.0},
                {"Stones", 1.0},
                {"Sulfur Ore", 1.0},
                {"Wood", 1.0},
                {"Hemp Seed", 1.0},
                {"Corn Seed", 1.0},
                {"Pumpkin Seed", 1.0},
                {"Cloth", 1.0},
                {"Pumpkin", 1.0},
                {"Corn", 1.0},
                {"Wolf Skull", 1.0}
            };
            Dictionary<string, object> defaultQuerryRates = new Dictionary<string, object>()
            {
                {"High Quality Metal Ore", 1.0},
                {"Metal Fragments", 1.0},
                {"Metal Ore", 1.0},
                {"Stones", 1.0},
                {"Sulfur Ore", 1.0}
            };
            List<object> blacklistedLoot = new List<object>()
            {
                "Rotten Apple",
                "Spoiled Wolf Meat",
                "Spoiled Chicken",
                "Spoiled Human Meat"
            };
            Dictionary<string, object> defaultSmeltRates = new Dictionary<string, object>();
            //var itemDefinitions = ItemManager.itemList;
            var itemDefinitions = ItemManager.GetItemDefinitions();
            foreach (var item in itemDefinitions)
            {
                // Записываем стандартные рейты готовки
                var cookable = item.GetComponent<ItemModCookable>();
                if (cookable != null)
                {
                    defaultSmeltRates.Add(item.displayName.english, cookable.cookTime);
                    SmeltBackup.Add(item.displayName.english, cookable.cookTime);
                }
            }
            GetConfig(BlacklistedLootCfg, ref blacklistedLoot);
            GetConfig(DefaultRatesCfg, ref defaultRates);
            GetConfig(CustomRatesCfg, ref customRates);
            GetConfig(DefaultPickupRatesCfg, ref defaultPickupRates);
            GetConfig(DefaultGatherRatesCfg, ref defaultGatherRates);
            GetConfig(DefaultSmeltRatesCfg, ref defaultSmeltRates);
            GetConfig(DefaultQuerryRatesCfg, ref defaultQuerryRates);
            GetConfig(PrefixCfg, ref Prefix);
            GetConfig(PrefixColorCfg, ref PrefixColor);
            GetConfig(UseLootMultyplierCfg, ref UseLootMultyplier);
            GetConfig(DayStartCfg, ref DayStart);
            GetConfig(DayLenghtCfg, ref DayLenght);
            GetConfig(NightStartCfg, ref NightStart);
            GetConfig(NightLenghtCfg, ref NightLenght);
            GetConfig(WarnChatCfg, ref WarnChat);
            GetConfig(CoalRateDayCfg, ref CoalRateDay);
            GetConfig(CoalRateNightCfg, ref CoalRateNight);
            GetConfig(CoalChanceDayCfg, ref CoalChanceDay);
            GetConfig(CoalChanceNightCfg, ref CoalChanceNight);
            GetConfig(MoreHQMCfg, ref MoreHQM);
            SaveConfig();

            BlacklistedLoot = blacklistedLoot.Select(x => x.ToString()).ToList();

            foreach (var item in defaultRates)
            {
                double mod;
                if(!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default rates for {item.Key} is incorrect and will not work untill it will be resolved.");
                    continue;
                }
                DefaultRates.Add(item.Key, mod);
            }
            
            foreach (var item in customRates)
            {
                Dictionary<string, object> perms = (Dictionary<string, object>)item.Value;
                Dictionary<string, double> Perms = new Dictionary<string, double>();
                foreach(var p in perms)
                {
                    double mod;
                    if(!double.TryParse(p.Value.ToString(), out mod))
                    {
                        PrintWarning($"Custom rates for {item.Key} - {p.Key} is incorrect and will not work untill it will be resolved.");
                        continue;
                    }
                    Perms.Add(p.Key, mod);
                }
                CustomRates.Add(item.Key, Perms);
            }
            
            foreach (var item in defaultGatherRates)
            {
                double mod;
                if(!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default gather rates for {item.Key} is incorrect and will not work untill it will be resolved.");
                    continue;
                }
                DefaultGatherRates.Add(item.Key, mod);
            }
            
            foreach (var item in defaultPickupRates)
            {
                double mod;
                if(!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default pickup rates for {item.Key} is incorrect and will not work untill it will be resolved.");
                    continue;
                }
                DefaultPickupRates.Add(item.Key, mod);
            }
            
            foreach (var item in defaultQuerryRates)
            {
                double mod;
                if(!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default querry rates for {item.Key} is incorrect and will not work untill it will be resolved.");
                    continue;
                }
                DefaultQuerryRates.Add(item.Key, mod);
            }
            
            foreach (var item in defaultSmeltRates)
            {
                double mod;
                if(!double.TryParse(item.Value.ToString(), out mod))
                {
                    PrintWarning($"Default smelt rates for {item.Key} is incorrect and will not work untill it will be resolved.");
                    continue;
                }
                DefaultSmeltRates.Add(item.Key, mod);
            }

        }
        #endregion

        #region localization
        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LootRate"] = "Loot from lootboxes x{rates}\n",
                ["CoalRate"] = "Coal producing rates is x{rates}\n",
                ["No Permission"] = "You don't have permission to use this command.",
                ["Day Starts"] = "The Day is starting!\n",
                ["Night Starts"] = "The Night is starting!\n",
                ["PickupRates"] = "Pickup rates was changed to x{rates}\n",
                ["GatherRates"] = "Gather rates was changed to x{rates}\n",
                ["QuerryRates"] = "Quarry gathering rate was changed to x{rates}\n",
                ["Smelt Rate"] = "Smelt Rate was changed to x{rates}\n",
                ["PersonalRates"] = "Your personal rates:\n",
                ["PickUpRatesPers"] = "Your personal Pickup rates is x{rates}\n",
                ["GatherRatesPers"] = "Your personal Gather rates is x{rates}\n",
                ["QueryPers"] = "Your personal Query rates is x{rates}\n",
                ["SmeltPers"] = "Your personal Smelt rates is x{rates}\n",
                ["LootPers"] = "Your personal Loot rates is x{rates}"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LootRate"] = "Рейты лута x{rates}\n",
                ["CoalRate"] = "Рейты производства угля x{rates}\n",
                ["No Permission"] = "Недостаточно прав на выполнение данной команды.",
                ["Day Starts"] = "Начинается день!\n",
                ["Night Starts"] = "Начинается ночь!\n",
                ["PickupRates"] = "Рейты подбираемых предметов x{rates}\n",
                ["GatherRates"] = "Рейты добычи изменены на x{rates}\n",
                ["QuerryRates"] = "Рейты добычи ресурсов в карьерах изменены на x{rates}\n",
                ["Smelt Rate"] = "Скорость работы печей x{rates}\n",
                ["PersonalRates"] = "Ваши личные рейты:\n",
                ["PickUpRatesPers"] = "Рейты подбираемых предметов x{rates}\n",
                ["GatherRatesPers"] = "Рейты добычи x{rates}\n",
                ["QueryPers"] = "Рейты работы карьера x{rates}\n",
                ["SmeltPers"] = "Рейты переплавки x{rates}\n",
                ["LootPers"] = "Рейты лута x{rates}"
            }, this, "ru");
        }
        #endregion

        #region initializing
        void OnServerInitialized()
        {
            //Загружаем конфиг из файла
            LoadConfigValues();
            
            //Подгружаем данные локализации
            LoadMessages();
            if (!UseLootMultyplier)
            {
                Unsubscribe("OnEntityTakeDamage");
                Unsubscribe("OnLootEntity");
            }
            //Инициализируем управление временем - получаем компоненту времени
            timer.Once(3, GetTimeComponent);

            foreach (var perm in CustomRates.Keys)
            {
                permission.RegisterPermission($"{perm}".ToLower(), this);
                //PrintWarning($"{Title}.{perm}".ToLower());
            }
            var curtime = covalence.Server.Time;
            //Если при старте на сервере день - ставим в false, дабы вызывалось событие OnDayStart()
            isDay = (DayStart <= curtime.Hour && curtime.Hour < NightStart) ? false : true;

            UpdateFurnaces();
        }

        //Вызывается при выгрузке плагина
        void Unload()
        {
            //Очищаем привящку к ивнту
            if(timeComponent != null)
                timeComponent.OnHour -= OnHour;
            //Восстанавливаем стандартное время переплавки
            foreach (var item in ItemManager.GetItemDefinitions())
            {
                if (!SmeltBackup.ContainsKey(item.displayName.english)) continue;
                var cookable = item.GetComponent<ItemModCookable>();
                if (cookable != null)
                {
                    cookable.cookTime = SmeltBackup[item.displayName.english];
                }
            }
        }

        #endregion

        #region Time managment

        //Переменная, для хранения компоненты времени
        private TOD_Time timeComponent = null;

        //Заморожено ли время.
        private bool Frozen = false;

        #region main
        //Колличество попыток определения компоненты
        private uint componentSearchAttempts = 0;

        //Инициализация управления временем
        private void GetTimeComponent()
        {
            //Если Instance == 0,
            if (TOD_Sky.Instance == null)
            {
                //Увеличиваем номер попытки
                ++componentSearchAttempts;
                if (this.componentSearchAttempts < 50)
                {
                    PrintWarning("Restarting timer for GetTimeComponent(). Attempt " + componentSearchAttempts.ToString() + "/10.");
                    timer.Once(3, GetTimeComponent);
                }
                else
                {
                    RaiseError("Could not find required component after 50 attempts. Plugin will not work without it.\nTry to reload it ant if this won't fix the issue contact the developer - https://vk.com/vlad_00003");
                }

                return;
            }

            if (TOD_Sky.Instance != null && componentSearchAttempts >= 0)
            {
                Puts("Found TOD_Time component after attempt " + componentSearchAttempts.ToString() + ".");
            }

            //Записываем компаненту времени
            timeComponent = TOD_Sky.Instance.Components.Time;

            if (timeComponent == null)
            {
                RaiseError("Could not fetch time component. Plugin will not work without it.");
                return;
            }

            //Добавляем ивент к событию
            timeComponent.OnHour += OnHour;

            //Вызываем функцию, дабы узнать текущее время суток.
            OnHour();

        }

        //Идёт ли прогресс времени, данные хватаем из игры
        //Ибо костылями - мир полнится....
        private bool ProgressTime
        {
            get
            {
                return timeComponent.ProgressTime;
            }
            set
            {
                timeComponent.ProgressTime = value;
            }
        }

        //Обработчик события OnHour
        private void OnHour()
        {
            if (DayStart <= CurrentHour && CurrentHour < NightStart)
            {
                if (!isDay)
                {
                    //Устанавливаем время суток на День
                    isDay = true;
                    //Вызываем процедуру обновления длинны суток
                    UpdateDayLenght(DayLenght, false);
                    Interface.Oxide.CallHook("OnDayStart");
                }
            }
            else
            {
                if (isDay)
                {
                    //Устанавливаем время суток на ночь
                    isDay = false;
                    //Вызываем процедуру обновления длинны суток
                    UpdateDayLenght(NightLenght, true);
                    Interface.Oxide.CallHook("OnNightStart");
                }
            }
        }

        //Функция, обновляющяя длительность суток в зависимости от времени суток в игре.
        void UpdateDayLenght(uint Lenght, bool night)
        {
            float dif = NightStart - DayStart;
            if (night)
            {
                dif = (24 - dif);
            }
            float part = 24.0f / dif;
            float newLenght = part * Lenght;
            if (newLenght == 0) newLenght = 0.1f;
            timeComponent.DayLengthInMinutes = newLenght;
        }

        #endregion

        #region Helpers

        //Возвращает текущий час
        public float CurrentHour
        {
            get
            {
                return TOD_Sky.Instance.Cycle.Hour;
            }
        }

        #endregion

        #endregion

        #region Rate controller
        //Бочки с лутом
        //void ClearContainer(LootContainer container)
        //{
        //    while (container.inventory.itemList.Count > 0)
        //    {
        //        var item = container.inventory.itemList[0];
        //        item.RemoveFromContainer();
        //        item.Remove(0f);
        //    }
        //}
        //private void OnEntitySpawned(BaseNetworkable entity)
        //{
        //    if (!UseLootMultyplier) { return; }
        //    if (entity is SupplyDrop) { return; }
        //    if (entity is LockedByEntCrate) { return; }
        //    if (entity is Stocking) { return; }
        //    if (entity is LootContainer)
        //    {
        //        var lootbox = entity as LootContainer;

        //        ClearContainer(lootbox);
        //        lootbox.PopulateLoot();

        //        foreach (Item lootitem in lootbox.inventory.itemList.ToList())
        //        {
        //            if (lootitem.info.stackable > 1)
        //            {
        //                if (BlacklistedLoot.Contains(lootitem.info.displayName.english) || BlacklistedLoot.Contains(lootitem.info.shortname)) continue;
        //                lootitem.amount = (int)(lootitem.amount * LootRate);
        //            }
        //        }
        //    }
        //}
        //private void UpdateLoot()
        //{
        //    foreach (var container in UnityEngine.Object.FindObjectsOfType<LootContainer>())
        //    {
        //        if (container is SupplyDrop) { continue; }
        //        if (container is LockedByEntCrate) { continue; }
        //        if (container is Stocking) { continue; }
        //        ClearContainer(container);
        //        container.PopulateLoot();
        //        foreach (Item lootitem in container.inventory.itemList.ToList())
        //        {
        //            if (lootitem.info.stackable > 1)
        //            {
        //                if (BlacklistedLoot.Contains(lootitem.info.displayName.english) || BlacklistedLoot.Contains(lootitem.info.shortname)) continue;
        //                lootitem.amount = (int)(lootitem.amount * LootRate);
        //            }
        //        }
        //    }
        //}
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            var lootcont = entity as LootContainer;
            if (lootcont is SupplyDrop) return;
            var player = info.InitiatorPlayer;
            if (player == null) return;

            if (!lootcont) return;
            if (lootcont.OwnerID == player.userID) return;
            lootcont.OwnerID = player.userID;

            lootcont.SpawnLoot();

            double rate;
            if (isDay)
            {
                rate = GetUserRates(player.UserIDString, LootDayString);
            }
            else
            {
                rate = GetUserRates(player.UserIDString, LootNightString);
            }

            foreach (var lootitem in lootcont.inventory.itemList)
            {
                if (lootitem.info.stackable > 1)
                {
                    if (BlacklistedLoot.Contains(lootitem.info.displayName.english) || BlacklistedLoot.Contains(lootitem.info.shortname)) continue;
                    var new_amount = (int)(lootitem.amount * rate);
                    lootitem.amount = new_amount > 1 ? new_amount : 1;
                }
            }
        }
        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (entity is SupplyDrop)  return; 
            if (entity is LockedByEntCrate)  return; 
            if (entity is Stocking)  return; 

            var lootcont = entity as LootContainer;
            if (!lootcont) return;
            if (lootcont.OwnerID == player.userID) return;
            var instanceID = lootcont.GetInstanceID();
            DateTime cd;
            if(!CratesCD.TryGetValue(instanceID, out cd))
            {
                cd = DateTime.Now;
                CratesCD.Add(instanceID, cd);
            }
            if(cd.Subtract(DateTime.Now).TotalSeconds > 0)
            {
                return;
            }
            CratesCD[instanceID] = DateTime.Now.AddMinutes(2);
            lootcont.OwnerID = player.userID;
            lootcont.SpawnLoot();

            double rate;
            if (isDay)
            {
                rate = GetUserRates(player.UserIDString, LootDayString);
            }else
            {
                rate = GetUserRates(player.UserIDString, LootNightString);
            }

            foreach (var lootitem in lootcont.inventory.itemList)
            {
                if (lootitem.info.stackable > 1)
                {
                    if (BlacklistedLoot.Contains(lootitem.info.displayName.english) || BlacklistedLoot.Contains(lootitem.info.shortname)) continue;
                    var new_amount = (int)(lootitem.amount * rate);
                    lootitem.amount = new_amount > 1 ? new_amount : 1;
                }
            }
        }
        private void UpdateFurnaces()
        {
            var baseOvens = Resources.FindObjectsOfTypeAll<BaseOven>().Where(c => c.isActiveAndEnabled).Cast<BaseEntity>().ToList();
            foreach (var oven in baseOvens)
            {
                if (oven.HasFlag(BaseEntity.Flags.On))
                {
                    double ovenMultiplier;
                    if (isDay)
                    {
                        ovenMultiplier = GetUserRates(oven.OwnerID.ToString(), SmeltDayString);
                    }else
                    {
                        ovenMultiplier = GetUserRates(oven.OwnerID.ToString(), SmeltNightString);
                    }
                    if (ovenMultiplier > 10f) ovenMultiplier = 10f;
                    if (ovenMultiplier < 0.1f) ovenMultiplier = 0.1f;
                    InvokeHandler.CancelInvoke(oven.GetComponent<MonoBehaviour>(), new Action((oven as BaseOven).Cook));
                    (oven as BaseOven).inventory.temperature = CookingTemperature((oven as BaseOven).temperature);
                    (oven as BaseOven).UpdateAttachmentTemperature();
                    InvokeHandler.InvokeRepeating(oven.GetComponent<MonoBehaviour>(), new Action((oven as BaseOven).Cook), (float)(0.5f / ovenMultiplier), (float)(0.5f / ovenMultiplier));

                }
            }
        }
        float CookingTemperature(BaseOven.TemperatureType temperature)
        {
            switch (temperature)
            {
                case BaseOven.TemperatureType.Warming:
                    return 50f;
                case BaseOven.TemperatureType.Cooking:
                    return 200f;
                case BaseOven.TemperatureType.Smelting:
                    return 1000f;
                case BaseOven.TemperatureType.Fractioning:
                    return 1500f;
                default:
                    return 15f;
            }
        }
        object OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (!oven.HasFlag(BaseEntity.Flags.On))
            {
                double ovenMultiplier;
                if (isDay)
                {
                    ovenMultiplier = GetUserRates(oven.OwnerID.ToString(), SmeltDayString);
                }
                else
                {
                    ovenMultiplier = GetUserRates(oven.OwnerID.ToString(), SmeltNightString);
                }
                if (ovenMultiplier > 10f) ovenMultiplier = 10f;
                if (ovenMultiplier < 0.1f) ovenMultiplier = 0.1f;
                StartCooking(oven, oven.GetComponent<BaseEntity>(), ovenMultiplier);
                return false;
            }
            return null;
        }
        void StartCooking(BaseOven oven, BaseEntity entity, double ovenMultiplier)
        {
            if (FindBurnable(oven) == null)
                return;
            oven.inventory.temperature = CookingTemperature(oven.temperature);
            oven.UpdateAttachmentTemperature();
            InvokeHandler.CancelInvoke(entity.GetComponent<MonoBehaviour>(), new Action(oven.Cook));
            InvokeHandler.InvokeRepeating(entity.GetComponent<MonoBehaviour>(), new Action(oven.Cook), (float)(0.5f / ovenMultiplier), (float)(0.5f / ovenMultiplier));
            entity.SetFlag(BaseEntity.Flags.On, true, false);
        }
        Item FindBurnable(BaseOven oven)
        {
            if (oven.inventory == null)
                return null;
            foreach (Item current in oven.inventory.itemList)
            {
                ItemModBurnable component = current.info.GetComponent<ItemModBurnable>();
                if (component && (oven.fuelType == null || current.info == oven.fuelType))
                    return current;
            }
            return null;
        }

        private void OnDayStart()
        {
            CoalRate = CoalRateDay;
            CoalChance = CoalChanceDay;
            SmeltRate = DefaultRates[SmeltDayString];
            GatherRate = DefaultRates[GatherDayString];
            PickupRate = DefaultRates[PickUpDayString];
            QuerryRate = DefaultRates[QuerryDayString];
            LootRate = DefaultRates[LootDayString];
            //Обновляем скорость переплавки
            //UpdateSmeltTime();
            UpdateFurnaces();

            //Оповещаем игоков о смене времени суток
            if (WarnChat)
            {
                RatesToChat();
            }
        }
        private void OnNightStart()
        {
            CoalRate = CoalRateNight;
            CoalChance = CoalChanceNight;
            SmeltRate = DefaultRates[SmeltNightString];
            GatherRate = DefaultRates[GatherNightString];
            PickupRate = DefaultRates[PickUpNightString];
            QuerryRate = DefaultRates[QuerryNightString];
            LootRate = DefaultRates[LootNightString];
            //Обновляем скорость переплавки
            //UpdateSmeltTime();
            UpdateFurnaces();

            //Оповещаем игоков о смене времени суток
            if (WarnChat)
            {
                RatesToChat();
            }
        }
        private void RatesToChat()
        {
            string Message = string.Empty;
            Message = isDay ? GetMsg("Day Starts") : GetMsg("Night Starts");
            Message += GetMsg("GatherRates").Replace("{rates}", GatherRate.ToString());
            Message += GetMsg("PickupRates").Replace("{rates}", PickupRate.ToString());
            Message += GetMsg("QuerryRates").Replace("{rates}", QuerryRate.ToString());
            Message += GetMsg("Smelt Rate").Replace("{rates}", SmeltRate.ToString());
            Message += GetMsg("CoalRate").Replace("{rates}", CoalRate.ToString());
            if (UseLootMultyplier)
                Message += GetMsg("LootRate").Replace("{rates}", LootRate.ToString());
            SendToChat(Message);
        }


        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            double mod = 1f;
            if (DefaultPickupRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultPickupRates[item.info.displayName.english];
            }
            int new_amount;
            if (isDay)
            {
                new_amount = (int)(item.amount * GetUserRates(player.UserIDString, PickUpDayString) * mod);
                item.amount = new_amount > 1 ? new_amount : 1;
                return;
            }
            new_amount = (int)(item.amount * GetUserRates(player.UserIDString, PickUpNightString) * mod);
            item.amount = new_amount > 1 ? new_amount : 1;
        }
        void OnCropGather(PlantEntity plant, Item item, BasePlayer player)
        {
            double mod = 1f;
            if (DefaultPickupRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultPickupRates[item.info.displayName.english];
            }
            int new_amount;
            if (isDay)
            {
                new_amount = (int)(item.amount * GetUserRates(player.UserIDString, PickUpDayString) * mod);
                item.amount = new_amount > 1 ? new_amount : 1;
                return;
            }
            new_amount = (int)(item.amount * GetUserRates(player.UserIDString, PickUpNightString) * mod);
            item.amount = new_amount > 1 ? new_amount : 1;
        }
        void OnEntityKill(BaseNetworkable entity)
        {
            var lootcont = entity as LootContainer;
            if (lootcont)
            {
                var instanceid = lootcont.GetInstanceID();
                if (CratesCD.ContainsKey(instanceid))
                {
                    CratesCD.Remove(instanceid);
                }
            }
            BaseEntity dispenser = entity as BaseEntity;
            if (DefaultFinishBonuses.ContainsKey(dispenser))
            {
                DefaultFinishBonuses.Remove(dispenser);
            }
        }
        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!entity.ToPlayer()) return;
            double mod = 1f;
            if (DefaultGatherRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultGatherRates[item.info.displayName.english];
            }
            int new_amount;
            double rate;
            if (isDay)
            {
                rate = GetUserRates(entity.ToPlayer().UserIDString, GatherDayString);
            }
            else
            {
                rate = GetUserRates(entity.ToPlayer().UserIDString, GatherNightString);
            }
            new_amount = (int)(item.amount * rate * mod);
            item.amount = new_amount > 1 ? new_amount : 1;

            BaseEntity dispenserEnt = dispenser.GetComponent<BaseEntity>();
            if (MoreHQM && dispenser.gatherType == ResourceDispenser.GatherType.Ore)
            {
                bool HaveHQM = dispenser.finishBonus.Any(x => x.itemDef.displayName.english == "High Quality Metal Ore");
                if (!HaveHQM)
                {
                    dispenser.finishBonus.Add(new ItemAmount(ItemManager.FindItemDefinition(2133577942), 2f));
                }
            }
            if (!DefaultFinishBonuses.ContainsKey(dispenserEnt))
            {
                DefaultFinishBonuses[dispenserEnt] = dispenser.finishBonus.Select(p => new KeyValuePair<string, float>(p.itemDef.displayName.english, p.amount)).ToDictionary(x => x.Key, x => x.Value);
            }
            foreach (var bonus in dispenser.finishBonus)
            {
                if (DefaultFinishBonuses[dispenserEnt].ContainsKey(bonus.itemDef.displayName.english))
                {
                    float default_bonus = DefaultFinishBonuses[dispenserEnt][bonus.itemDef.displayName.english];
                    double bonus_mode = 1f;
                    if (DefaultGatherRates.ContainsKey(bonus.itemDef.displayName.english))
                    {
                        bonus_mode = DefaultGatherRates[bonus.itemDef.displayName.english];
                    }
                    int new_bonus_amount = (int)(default_bonus * rate * bonus_mode);
                    bonus.amount = new_bonus_amount > 1 ? new_bonus_amount : 1;
                }
            }
        }
        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            double mod = 1f;
            if (DefaultQuerryRates.ContainsKey(item.info.displayName.english))
            {
                mod = DefaultQuerryRates[item.info.displayName.english];
            }
            int new_amount;
            if (isDay)
            {
                new_amount = (int)(item.amount * GetUserRates(quarry.OwnerID, QuerryDayString) * mod);
                item.amount = new_amount > 1 ? new_amount : 1;
                return;
            }
            new_amount = (int)(item.amount * GetUserRates(quarry.OwnerID, QuerryNightString) * mod);
            item.amount = new_amount > 1 ? new_amount : 1;
        }
        void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
        {
            if (oven == null) return;
            burnable.byproductAmount = (int)Math.Ceiling(CoalRate);
            burnable.byproductChance = (100 - CoalChance) / 100f;
        }
        //void UpdateSmeltTime()
        //{
        //    var itemDefinitions = ItemManager.GetItemDefinitions();
        //    foreach (var item in itemDefinitions)
        //    {
        //        var cookable = item.GetComponent<ItemModCookable>();
        //        if (cookable != null)
        //        {
        //            if (DefaultSmeltRates.ContainsKey(item.displayName.english))
        //            {
        //                cookable.cookTime = (float)(DefaultSmeltRates[item.displayName.english] / SmeltRate);
        //            }else
        //            {
        //                DefaultSmeltRates.Add(item.displayName.english, cookable.cookTime);
        //                cookable.cookTime = (float)(DefaultSmeltRates[item.displayName.english] / SmeltRate);
        //            }
        //        }
        //    }
        //}
        #endregion

        #region Сonsole commands
        [ConsoleCommand("env.freeze")]
        void TimeFreeze(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (Frozen)
            {
                //Puts("The time is already frozen!");
                arg.ReplyWith("The time is already frozen!");
                return;
            }
            Frozen = true;
            ProgressTime = false;
            //Puts("The time was frozen.");
            arg.ReplyWith("The time was frozen.");
        }

        [ConsoleCommand("env.unfreeze")]
        void TimeUnFreeze(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (!Frozen)
            {
                arg.ReplyWith("The time is not frozen!");
                return;
            }
            Frozen = false;
            ProgressTime = true;
            arg.ReplyWith("The time was unfrozen.");
        }

        [ConsoleCommand("rates.show")]
        void ShowRates(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null)
            {
                arg.ReplyWith("Usage rates.show steamid [type]");
                return;
            }
            var target = covalence.Players.FindPlayer(arg.Args[0]);
            if (target == null)
            {
                arg.ReplyWith("User not found or multiply user mathces");
                return;
            }
            if (arg.Args.Length >= 2)
            {
                arg.ReplyWith(GetUserRates(target.Id, arg.Args[1]).ToString());
                return;
            }
            string reply = $"User '{target.Name}' current rates:\n";
            foreach (var p in AvaliableMods)
            {
                reply += p + ": " + GetUserRates(target.Id, p).ToString() + " \n";
            }
            arg.ReplyWith(reply);
        }
        #endregion

        #region Chat commands
        [ChatCommand("rates")]
        private void ShowRatesChat(BasePlayer player, string command, string[] args)
        {
            string reply = GetMsg("PersonalRates", player.UserIDString);
            if (isDay)
            {
                reply += GetMsg("GatherRatesPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, GatherDayString).ToString());
                reply += GetMsg("PickUpRatesPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, PickUpDayString).ToString());
                reply += GetMsg("QueryPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, QuerryDayString).ToString());
                reply += GetMsg("SmeltPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, SmeltDayString).ToString());
                reply += GetMsg("LootPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, LootDayString).ToString());
                SendToChat(player, reply);
                return;
            }
            reply += GetMsg("GatherRatesPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, GatherNightString).ToString());
            reply += GetMsg("PickUpRatesPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, PickUpNightString).ToString());
            reply += GetMsg("QueryPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, QuerryNightString).ToString());
            reply += GetMsg("SmeltPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, SmeltNightString).ToString());
            reply += GetMsg("LootPers", player.UserIDString).Replace("{rates}", GetUserRates(player.UserIDString, LootNightString).ToString());
            SendToChat(player, reply);
        }
        #endregion

        #region Helpers
        private void GetConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null)
            {
                var = (T)Convert.ChangeType(Config[Key], typeof(T));
            }
            Config[Key] = var;
        }

        //Функция, отправляющая сообщение в чат конкретному пользователю, добавляет префикс
        private void SendToChat(BasePlayer Player, string Message)
        {
            PrintToChat(Player, "<color=" + PrefixColor + ">" + Prefix + "</color> " + Message);
        }

        //Перезгрузка функции отправки собщения в чат - отправляет сообщение всем пользователям
        private void SendToChat(string Message)
        {
            PrintToChat("<color=" + PrefixColor + ">" + Prefix + "</color> " + Message);
        }

        //Функция получения строки из языкового файла
        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());
        double GetUserRates(string steamId, string RateType)
        {
            /*
             * Из списка кастомных привелегий выбираем только те, на которые у игрока есть привелегия.
             * выбираем только сами привелегии, без названий. Только содерживое
             * Из них выбираем те, где есть нужный нам тип рейтов. И выбираем только нужные нам типы рейтов.
             */
            var playergroups = CustomRates.Where(i => permission.UserHasPermission(steamId, i.Key)).Select(i => i.Value).
                Where(i => i.ContainsKey(RateType)).Select(i => i[RateType]);
            return playergroups.Count() > 0 ? playergroups.Aggregate((i1, i2) => i1 > i2 ? i1 : i2) : DefaultRates[RateType];
        }
        //Перегрузка функции. Ибо мне так будет проще)
        double GetUserRates(ulong steamId, string RateType) => GetUserRates(steamId.ToString(), RateType);

        Dictionary<string, object> CreatePerms(List<string> mods, double rate)
        {
            return mods.ToDictionary(x => x, x => (object)rate);
        }


        #endregion
    }
}

// --- End of file: RatesController.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ScientistLoot.cs ---
// --- Original Local Path: ScientistLoot.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("ScientistLoot", "SkiTles", "1.0")]
    class ScientistLoot : RustPlugin
    {
        //Данный плагин принадлежит группе vk.com/vkbotrust
        //Данный плагин предоставляется в существующей форме,
        //"как есть", без каких бы то ни было явных или
        //подразумеваемых гарантий, разработчик не несет
        //ответственность в случае его неправильного использования.

        #region Vars
        private bool Initialized = false;
        class NPCItem
        {
            public string shortname;
            public int minamount;
            public int maxamount;
            public bool bp;
            public int rarity;
        }
        #endregion

        #region Config
        private static ConfigFile config;
        private class ConfigFile
        {
            [JsonProperty(PropertyName = "Минимальное количество предметов")]
            public int minamount { get; set; }

            [JsonProperty(PropertyName = "Максимальное количество предметов")]
            public int maxamount { get; set; }

            [JsonProperty(PropertyName = "Сохранять шанс на выпадение оружия?")]
            public bool weaponsave { get; set; }

            [JsonProperty(PropertyName = "Список лута")]
            public List<NPCItem> npcitemlist { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    minamount = 1,
                    maxamount = 6,
                    weaponsave = true,
                    npcitemlist = new List<NPCItem>()
                    {
                        new NPCItem() { shortname = "syringe.medical", minamount = 1, maxamount = 2, bp = false, rarity = 1 },
                        new NPCItem() { shortname = "flare", minamount = 2, maxamount = 5, bp = false, rarity = 1 },
                        new NPCItem() { shortname = "keycard_green", minamount = 1, maxamount = 1, bp = false, rarity = 1 },
                        new NPCItem() { shortname = "semibody", minamount = 1, maxamount = 3, bp = false, rarity = 1 },
                        new NPCItem() { shortname = "pickaxe", minamount = 1, maxamount = 1, bp = false, rarity = 1 },
                        new NPCItem() { shortname = "scrap", minamount = 8, maxamount = 33, bp = false, rarity = 1 },
                        new NPCItem() { shortname = "grenade.f1", minamount = 2, maxamount = 3, bp = false, rarity = 2 },
                        new NPCItem() { shortname = "smgbody", minamount = 1, maxamount = 1, bp = false, rarity = 2 },
                        new NPCItem() { shortname = "ammo.shotgun.fire", minamount = 4, maxamount = 7, bp = false, rarity = 2 },
                        new NPCItem() { shortname = "syringe.medical", minamount = 1, maxamount = 1, bp = true, rarity = 2 },
                        new NPCItem() { shortname = "techparts", minamount = 1, maxamount = 1, bp = false, rarity = 2 },
                        new NPCItem() { shortname = "weapon.mod.flashlight", minamount = 1, maxamount = 1, bp = false, rarity = 2 },
                        new NPCItem() { shortname = "hazmatsuit", minamount = 1, maxamount = 1, bp = false, rarity = 2 },
                        new NPCItem() { shortname = "ammo.pistol", minamount = 30, maxamount = 60, bp = false, rarity = 2 },
                        new NPCItem() { shortname = "explosives", minamount = 1, maxamount = 1, bp = false, rarity = 3 },
                        new NPCItem() { shortname = "riflebody", minamount = 1, maxamount = 1, bp = false, rarity = 3 },
                        new NPCItem() { shortname = "weapon.mod.holosight", minamount = 1, maxamount = 1, bp = false, rarity = 3 },
                        new NPCItem() { shortname = "ammo.shotgun", minamount = 8, maxamount = 11, bp = false, rarity = 3 }
                    }
                };
            }
        }
        protected override void LoadDefaultConfig()
        {
            config = ConfigFile.DefaultConfig();
            PrintWarning("Создан новый файл конфигурации. Поддержи разработчика! Вступи в группу vk.com/vkbotrust");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<ConfigFile>();
                if (config == null)
                    Regenerate();
            }
            catch { Regenerate(); }
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        private void Regenerate()
        {
            PrintWarning($"Конфигурационный файл 'oxide/config/{Name}.json' поврежден, создается новый...");
            LoadDefaultConfig();
        }
        #endregion

        #region OxideHooks
        private void OnServerInitialized()
        {
            Initialized = true;
        }
        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!Initialized) return;
            if (entity.ShortPrefabName.Contains("scientist_corpse"))
            {
                var npccorpse = entity as LootableCorpse;
                if (npccorpse == null) return;
                NextTick(() => { ChangeLoot(npccorpse); });
            }
        }
        #endregion

        #region Main
        private void ChangeLoot(LootableCorpse npccorpse)
        {
            var minv = npccorpse.containers[0];
            if (config.weaponsave)
            {
                foreach (var item in minv.itemList)
                {
                    if (item.info.shortname != "smg.mp5" && item.info.shortname != "pistol.m92" && item.info.shortname != "shotgun.spas12") { item.RemoveFromWorld(); item.Remove(); }
                }
            }
            else { minv.Clear(); }
            int amount = Random.Range(config.minamount, config.maxamount);
            List<int> Choices = new List<int>();
            for (int i = 0; i < amount; i++)
            {
                var choice1 = Random.Range(1, 100);
                int rare = 1;
                if (choice1 >= 97) rare = 3;
                if (choice1 >= 85 && choice1 < 97) rare = 2;
                int test = Random.Range(config.npcitemlist.Count);
                if (rare == config.npcitemlist.ElementAt(test).rarity)
                {
                    if (!Choices.Contains(test))
                    {
                        Choices.Add(test);
                        var itemdef = config.npcitemlist.ElementAt(test);
                        string shortname = itemdef.shortname;
                        if (itemdef.bp) shortname = "blueprintbase";
                        int itemamount = 1;
                        if (!itemdef.bp) itemamount = Random.Range(itemdef.minamount, itemdef.maxamount);
                        Item newitem = ItemManager.CreateByName(shortname, itemamount);
                        if (itemdef.bp) newitem.blueprintTarget = ItemManager.CreateByName(itemdef.shortname).info.itemid;
                        newitem.MoveToContainer(minv);
                    }
                    else
                    { amount++; }
                }
                else
                { amount++; }
            }
        }
        #endregion
    }
}

// --- End of file: ScientistLoot.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TownWars.cs ---
// --- Original Local Path: TownWars.cs ---

﻿using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Rust;
using System.Linq;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using Oxide.Core;
using System.Globalization;
using Newtonsoft.Json.Linq;


namespace Oxide.Plugins
{
    [Info("TownWars", "Qbis", "1.0.4")]
    public class TownWars : RustPlugin
    {
        #region [Vars]
        [PluginReference] Plugin ImageLibrary, Clans;

        private List<GameObject> townObjects = new List<GameObject>();
        private Dictionary<string, List<inventoryData>> inventorysCache = new Dictionary<string, List<inventoryData>>();
        private static TownWars plugin;

        public class townsData
        {
            public string OwnerID;
            public string OwnerName;
            public int lastReward;
            public int lastCapture;
        }

        public class inventoryData
        {
            public string shortName;
            public ulong skinID;
            public int amount;
            public string customName;
            public int itemID;
            public string command;
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                if(Version == new VersionNumber(1, 0, 1))
                {
                    foreach (var rewards in config.towns)
                        foreach (var reward in rewards.Value.rewards)
                            reward.command = "";

                    config.settings.minPlayers = 0;
                }
                config.PluginVersion = Version;
                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Общие настройки")]
            public Settings settings;

            [JsonProperty("Настройки маркеров")]
            public MarkersSettings marker;

            [JsonProperty("Настройки РТ")]
            public Dictionary<string, TownSettings> towns;

            [JsonProperty("Настройки UI")]
            public UiSettings ui;

            [JsonProperty("Версия конфига")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    settings = new Settings()
                    {
                        typeTeam = "Clans",
                        addRewardSettings = 1800,
                        allCanTakeReward = false,
                        allCanStartCapt = false,
                        clearInventoryAfterWipe = true,
                        delayCapture = 14400,
                        durCapture = 1800,
                        addSphere = true,
                        minPlayers = 0
                    },
                    marker = new MarkersSettings()
                    {
                        markerRadius = 0.5f,
                        markerAlpha = 0.4f,
                        addMarkerWithLast = true,
                        markerColorCanCapture = "#10c916",
                        markerColorCantCapture = "#ffb700",
                        markerColorCapture = "#ed0707"
                    },
                    towns = new Dictionary<string, TownSettings>()
                    {
                        ["assets/bundled/prefabs/autospawn/monument/large/trainyard_1.prefab"] = new TownSettings()
                        {
                            name = "Железнодорожное Депо",
                            capDist = 85,
                            rewards = new List<Reward>()
                            {
                                new Reward()
                                {
                                    shortName = "stones",
                                    amount = 10000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "sulfur",
                                    amount = 5000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = ""
                                },
                                new Reward()
                                {
                                    shortName = "rifle.ak",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "techparts",
                                    amount = 10,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "lmg.m249",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "weapon.mod.8x.scope",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "glue",
                                    amount = 10,
                                    skinID = 2409891781,
                                    customName = "Баксы",
                                    imageUrl = "https://imgur.com/jBaVKHu.png",
                                    command = ""
                                }
                            }

                        },
                        ["assets/bundled/prefabs/autospawn/monument/large/excavator_1.prefab"] = new TownSettings()
                        {
                            name = "Большой Екскаватор",
                            capDist = 85,
                            rewards = new List<Reward>()
                            {
                                new Reward()
                                {
                                    shortName = "stones",
                                    amount = 10000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "sulfur",
                                    amount = 5000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = ""
                                },
                                new Reward()
                                {
                                    shortName = "rifle.ak",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "techparts",
                                    amount = 10,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "lmg.m249",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "weapon.mod.8x.scope",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "glue",
                                    amount = 10,
                                    skinID = 2409891781,
                                    customName = "Баксы",
                                    imageUrl = "https://imgur.com/jBaVKHu.png",
                                    command = ""
                                }
                            }

                        },
                        ["assets/bundled/prefabs/autospawn/monument/xlarge/launch_site_1.prefab"] = new TownSettings()
                        {
                            name = "Космодром",
                            capDist = 100,
                            rewards = new List<Reward>()
                            {
                                new Reward()
                                {
                                    shortName = "stones",
                                    amount = 10000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "sulfur",
                                    amount = 5000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "rifle.ak",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "glue",
                                    amount = 10,
                                    skinID = 2409891781,
                                    customName = "Баксы",
                                    imageUrl = "https://imgur.com/jBaVKHu.png",
                                    command = ""
                                }
                            }

                        },
                        ["assets/bundled/prefabs/autospawn/monument/xlarge/military_tunnel_1.prefab"] = new TownSettings()
                        {
                            name = "Военный тунель",
                            capDist = 50,
                            rewards = new List<Reward>()
                            {
                                new Reward()
                                {
                                    shortName = "stones",
                                    amount = 10000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "sulfur",
                                    amount = 5000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "rifle.ak",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "glue",
                                    amount = 10,
                                    skinID = 2409891781,
                                    customName = "Баксы",
                                    imageUrl = "https://imgur.com/jBaVKHu.png",
                                    command = ""
                                }
                            }

                        },
                        ["assets/bundled/prefabs/autospawn/monument/large/powerplant_1.prefab"] = new TownSettings()
                        {
                            name = "Электростанция",
                            capDist = 85,
                            rewards = new List<Reward>()
                            {
                                new Reward()
                                {
                                    shortName = "stones",
                                    amount = 10000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "sulfur",
                                    amount = 5000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "rifle.ak",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "glue",
                                    amount = 10,
                                    skinID = 2409891781,
                                    customName = "Баксы",
                                    imageUrl = "https://imgur.com/jBaVKHu.png",
                                    command = ""
                                }
                            }

                        },
                        ["assets/bundled/prefabs/autospawn/monument/large/water_treatment_plant_1.prefab"] = new TownSettings()
                        {
                            name = "Водонапорка",
                            capDist = 85,
                            rewards = new List<Reward>()
                            {
                                new Reward()
                                {
                                    shortName = "stones",
                                    amount = 10000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "sulfur",
                                    amount = 5000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "rifle.ak",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "glue",
                                    amount = 10,
                                    skinID = 2409891781,
                                    customName = "Баксы",
                                    imageUrl = "https://imgur.com/jBaVKHu.png",
                                    command = ""
                                }
                            }

                        },
                        ["assets/bundled/prefabs/autospawn/monument/small/sphere_tank.prefab"] = new TownSettings()
                        {
                            name = "Сфера",
                            capDist = 40,
                            rewards = new List<Reward>()
                            {
                                new Reward()
                                {
                                    shortName = "stones",
                                    amount = 10000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "sulfur",
                                    amount = 5000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "rifle.ak",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "glue",
                                    amount = 10,
                                    skinID = 2409891781,
                                    customName = "Баксы",
                                    imageUrl = "https://imgur.com/jBaVKHu.png",
                                    command = ""
                                }
                            }

                        },
                        ["assets/bundled/prefabs/autospawn/monument/small/satellite_dish.prefab"] = new TownSettings()
                        {
                            name = "Спутниковая тарелка",
                            capDist = 40,
                            rewards = new List<Reward>()
                            {
                                new Reward()
                                {
                                    shortName = "stones",
                                    amount = 10000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "sulfur",
                                    amount = 5000,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "rifle.ak",
                                    amount = 1,
                                    skinID = 0,
                                    customName = "",
                                    imageUrl = "",
                                    command = ""
                                },
                                new Reward()
                                {
                                    shortName = "glue",
                                    amount = 10,
                                    skinID = 2409891781,
                                    customName = "Баксы",
                                    imageUrl = "https://imgur.com/jBaVKHu.png",
                                    command = ""
                                }
                            }

                        }
                    },
                    ui = new UiSettings()
                    {
                        colorBG = "0 0 0 0.3",
                        colorLines = "0.75 0.60 0.20 1.00",
                        colorButtonCapture = "0.00 0.17 0.33 1",
                        colorButtonInventory = "0.00 0.17 0.33 1"
                    },
                    PluginVersion = new VersionNumber()

                };
            }
        }

        public class Settings
        {
            [JsonProperty("Тип работы плагина Team - обычные команды(зеленка), Solo - для соло захвата, Clans - поддержка кланов ClanReborn(Chaos), ClansUI(RP), Clans(Umod)")]
            public string typeTeam;

            [JsonProperty("Переодичность выдачи наград в секундах")]
            public int addRewardSettings;

            [JsonProperty("Предметы из инвентаря может забрать только глава клана")]
            public bool allCanTakeReward;

            [JsonProperty("Начать захват может только лидер клана или группы")]
            public bool allCanStartCapt;

            [JsonProperty("Удалять ли инвентарь предметов после вайпа")]
            public bool clearInventoryAfterWipe;

            [JsonProperty("Откат до следующего захвата в секундах")]
            public int delayCapture;

            [JsonProperty("Сколько секунд длится захват")]
            public int durCapture;

            [JsonProperty("Добавлять ли видимые сферы, для обозначения границ захвата")]
            public bool addSphere;

            [JsonProperty("Минимум игроков на сервере для начала захвата (0 - выкл)")]
            public int minPlayers;
        }

        public class MarkersSettings
        {
            [JsonProperty("Радиус маркера")]
            public float markerRadius;

            [JsonProperty("Прозрачность маркера")]
            public float markerAlpha;

            [JsonProperty("Цвет маркера когда РТ можно захватить")]
            public string markerColorCanCapture;

            [JsonProperty("Цвет маркера когда РТ захватывают")]
            public string markerColorCapture;

            [JsonProperty("Цвет маркера когда РТ нельзя захваить")]
            public string markerColorCantCapture;

            [JsonProperty("Добавлять ли название на карту маркер с именем, кто последний захватил РТ")]
            public bool addMarkerWithLast;
        }

        public class TownSettings
        {
            [JsonProperty("Название РТ")]
            public string name;

            [JsonProperty("На каком расстояние от центра РТ начислять очки захвата")]
            public int capDist;

            [JsonProperty("Список наград")]
            public List<Reward> rewards;
        }

        public class UiSettings
        {
            [JsonProperty("Цвет фона")]
            public string colorBG;

            [JsonProperty("Цвет обводки")]
            public string colorLines;

            [JsonProperty("Цвет кнопки 'Начать захват'")]
            public string colorButtonCapture;

            [JsonProperty("Цвет кнопки 'Инвентарь'")]
            public string colorButtonInventory;
        }

        public class Reward
        {
            [JsonProperty("Shortname предмета")]
            public string shortName;

            [JsonProperty("Количество предмета")]
            public int amount;

            [JsonProperty("Скин айди предмета")]
            public ulong skinID;

            [JsonProperty("Имя предмета (если кастом)")]
            public string customName;

            [JsonProperty("Ссылка на картинку (если кастом)")]
            public string imageUrl;

            [JsonProperty("Команда для выполнения %STEAMID% (для загрузки картинки придумайте любой номер SkinID и ShortName)")]
            public string command;
        }
        #endregion

        #region [Localization⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠]
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Solo"] = "player",
                ["Team"] = "player's team",
                ["Clans"] = "clan",
                ["CanCapt"] = "{1} under control <color=#B33A00>{0}</color> \n\n <color=#626262> To capture /tw </color>",
                ["CantCapt"] = "{4} under control <color=#B33A00>{0}</color>\nCapturing is possible in <color=#626262>{1}h. {2}m. {3}s.</color>",
                ["Capt"] = "Capturing {6} \nMost points for <color=#B33A00>{0}</color> - <color=#006A00> {1} </color>\nYour team has <color=#004000>{2}</color>\n\nTo end of capture <color=#626262> {3}h. {4}m. {5}sec. </color>",
                ["vendCapt"] = "Идет захват",
                ["StartCapt"] = "<size=20>Started capturing <color=#B33A00>{0}</color></size>",
                ["StopCapt"] = "<size=20><color=#B33A00>{0}</color> captured <color=#B33A00>{1}</color></size>",
                ["UI_Inventory"] = "<color=#DADADA>Inventory</color>",
                ["UI_Return"] = "<color=#DADADA>Return</color>",
                ["UI_Capture"] = "<color=#DADADA>Starting capture {0}</color",
                ["UI_TownName"] = "Name",
                ["UI_OwnerName"] = "Owner",
                ["UI_Status"] = "Status",
                ["UI_Capturing"] = "<color=#ed0707>Capture is underway</color>",
                ["UI_CantCapture"] = "<color=#ffb700>Was recently captured</color>",
                ["UI_CanCapture"] = "<color=#10c916>You can capture</color>",
                ["UI_Solo"] = "Player",
                ["UI_Team"] = "Player's team",
                ["UI_Clans"] = "Clan",
                ["UI_InventoryEmpty"] = "Your inventory is empty, grab the RT first",
                ["UI_NeedClan"] = "To start capturing, you need to create a clan",
                ["UI_OnlyOwner"] = "Only the clan head can do it",
                ["UI_Reward"] = "Reward from {0}",
                ["UI_LimitPlayers"] = "Capture cannot be started when there are less than {0} players on the server"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Solo"] = "игрока",
                ["Team"] = "команды игрока",
                ["Clans"] = "клана",
                ["CanCapt"] = "{1} под контролем <color=#B33A00>{0}</color>\n\n<color=#626262>Для захвата /tw</color>",
                ["CantCapt"] = "{4} под контролем <color=#B33A00>{0}</color>\nЗахват возможен через <color=#626262>{1}ч. {2}м. {3}с.</color>",
                ["Capt"] = "Идет захват\nБольше всего очков у <color=#B33A00>{0}</color> - <color=#006A00>{1}</color>\nУ вашей команды <color=#004000>{2}</color>\n\nДо конца захвата <color=#626262>{3}ч. {4}м. {5}с.</color>",
                ["vendCapt"] = "Идет захват",
                ["StartCapt"] = "<size=20>Начался захват <color=#B33A00>{0}</color></size>",
                ["StopCapt"] = "<size=20><color=#B33A00>{0}</color> захватил(и) <color=#B33A00>{1}</color></size>",
                ["UI_Inventory"] = "<color=#DADADA>Инвентарь</color>",
                ["UI_Return"] = "<color=#DADADA>Вернуться</color>",
                ["UI_Capture"] = "<color=#DADADA>Начать захват {0}</color>",
                ["UI_TownName"] = "Название",
                ["UI_OwnerName"] = "Владелец",
                ["UI_Status"] = "Состояние",
                ["UI_Capturing"] = "<color=#ed0707>Идет захват</color>",
                ["UI_CantCapture"] = "<color=#ffb700>Был недавно захвачен</color>",
                ["UI_CanCapture"] = "<color=#10c916>Можно захватить</color>",
                ["UI_Solo"] = "Игрок",
                ["UI_Team"] = "Команда игрока",
                ["UI_Clans"] = "Клан",
                ["UI_InventoryEmpty"] = "Ваш инвентарь пуст, сначала захватите РТ",
                ["UI_NeedClan"] = "Для начала захвата нужно создать клан",
                ["UI_OnlyOwner"] = "Только глава клана может сделать это",
                ["UI_Reward"] = "Награды с {0}",
                ["UI_LimitPlayers"] = "Нельзя начать захват, когда на сервере игроков меньше {0}"
            }, this, "ru");
        }
        string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player?.UserIDString);
        string GetMsg(string key) => lang.GetMessage(key, this);
        #endregion

        #region [Oxide]
        private void OnServerInitialized()
        {
            LoadTownsData();

            foreach (var towns in config.towns)
                foreach (var reward in towns.Value.rewards)
                    if (!String.IsNullOrEmpty(reward.imageUrl))
                        ImageLibrary?.Call("AddImage", reward.imageUrl, reward.shortName +  reward.skinID);

            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }


        private void Init()
        {
            plugin = this;
        }

        private void Unload()
        {
            SaveInventorys();
            SaveTownsData();
            foreach (var go in townObjects)
            {
                UnityEngine.Object.Destroy(go);
            }
        }

        private void OnNewSave()
        {
            if (config.settings.clearInventoryAfterWipe)
            {
                wipeInventorys();
                PrintWarning("Inventorys data are cleared!");
            }

            clearTownsData();
            PrintWarning("Towns data are cleared!");
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }

            var clan = GetPlayerClan(player);
            if (String.IsNullOrEmpty(clan))
                return;

            if (!inventorysCache.ContainsKey(clan))
                AddInventoryToCache(clan);

        }

        private object OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null) return null;

            CheckPlayerInZone(player);
            return null;
        }

        #endregion

        #region [Func]
        private void CheckPlayerInZone(BasePlayer player)
        {
            foreach(var obj in townObjects)
            {
                var capt = obj.GetComponent<Capture>();
                if (capt == null)
                    continue;

                if (capt.removePlayerFromZone(player))
                    return;
            }
        }

        private void BroadCastToStartCapture(string rt)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!player.IsConnected)
                    continue;

                player.ChatMessage(String.Format(GetMsg("StartCapt", player), rt));
            }
        }

        private void BroadCastToStopCapture(string owner, string rt)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!player.IsConnected)
                    continue;

                player.ChatMessage(String.Format(GetMsg("StopCapt", player), owner, rt));
            }
        }

        private string GetPlayerClan(BasePlayer player)
        {
            switch (config.settings.typeTeam)
            {
                case "Solo": return player.UserIDString;
                case "Team":
                    {
                        if (player.currentTeam == 0UL)
                            return null;

                        return player.currentTeam.ToString();
                    }
                case "Clans":
                    {
                        var clanName = Clans?.Call<string>("GetClanOf", player.userID);
                        return clanName ?? null;
                    }

                default:
                    return null;
            }
        }

        private string GetPlayerClanName(BasePlayer player)
        {
            switch (config.settings.typeTeam)
            {
                case "Solo":
                case "Team":
                    return player.displayName;


                case "Clans":
                    {
                        var clanName = Clans?.Call<string>("GetClanOf", player.userID);
                        return clanName ?? null;
                    }

                default:
                    return null;
            }
        }

        private bool isPlayerOwner(BasePlayer player)
        {
            switch (config.settings.typeTeam)
            {
                case "Solo": return true;
                case "Team":
                    {
                        if (player.currentTeam == 0UL)
                            return false;

                        return player.Team.teamLeader == player.userID ? true : false;
                    }
                case "Clans":
                    {
                        var clanName = Clans?.Call<string>("GetClanOf", player.userID);
                        if (clanName == null)
                            return false;

                        var clan = Clans?.Call<JObject>("GetClan", clanName);
                        var ownerID = clan.GetValue("owner").ToString();
                        if (ownerID == player.UserIDString)
                            return true;

                        return false;
                    }

                default:
                    return false;
            }
        }

        private void AddReward(string id, string town)
        {
            if (!config.towns.ContainsKey(town))
            {
                PrintError($"{town} not in config!");
                return;
            }

            var townRewards = config.towns[town].rewards;
            var reward = townRewards[UnityEngine.Random.Range(0, townRewards.Count)];
            var item = new inventoryData() { shortName = reward.shortName, amount = reward.amount, customName = reward.customName, skinID = reward.skinID, itemID = UnityEngine.Random.Range(1000, 9999) };

            if (!inventorysCache.ContainsKey(id))
                inventorysCache.Add(id, new List<inventoryData>() { item });
            else
                inventorysCache[id].Add(item);

            SaveInventoryItem(id);
        }

        private string isPlayerInZoneAndCapt(BasePlayer player)
        {
            foreach (var obj in townObjects)
            {
                var capt = obj.GetComponent<Capture>();
                if (capt == null)
                    continue;

                if (capt.isPlayerInZone(player))
                {
                    if (capt.isCapture)
                        return capt.monumentName;
                }
            }

            return null;
        }
        #endregion
    
        #region [UI]
        private void CreateTownWarsMainMenu(BasePlayer player, int page = 0)
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement { Parent = "Overlay", Name = "CaptMain", Components = { new CuiImageComponent { Color = "0 0 0 0", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }, new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }, new CuiNeedsCursorComponent() } });
            UI.CreateButton(ref container, "CaptMain", "0 0 0 0.7", "", 0, "0 0", "1 1", "UI_CLOSE_CAPT");
            UI.CreatePanel(ref container, "CaptMask", "CaptMain", "0 0 0 0.9", "0 0", "1 1");
            UI.CreatePanelBlur(ref container, "CaptPanel", "CaptMask", config.ui.colorBG, "0.05 0.18", "0.95 0.95");
            UI.CreateOutLines(ref container, "CaptPanel", config.ui.colorLines);
            UI.CreatePanel(ref container, "CaptPanelTowns", "CaptPanel", "0 0 0 0", "0.01475696 0.1197691", "0.9869792 0.9869792");

            UI.CreatePanelBlur(ref container, "Header", "CaptPanelTowns", "0 0 0 0.4", "0.009821426 0.9006174", "0.9900553 0.9900553");
            UI.CreateOutLines(ref container, "Header", config.ui.colorLines);

            UI.CreateTextOutLine(ref container, "Header", GetMsg("UI_TownName", player), "1 1 1 0.8", $"0.05 0", $"0.37 1", TextAnchor.MiddleLeft, 22);
            UI.CreateTextOutLine(ref container, "Header", GetMsg("UI_OwnerName", player), "1 1 1 0.8", $"0.38 0", $"0.70 1", TextAnchor.MiddleLeft, 22);
            UI.CreateTextOutLine(ref container, "Header", GetMsg("UI_Status", player), "1 1 1 0.8", $"0.71 0", $"0.95 1", TextAnchor.MiddleLeft, 22);

            Capture nearCapt = null;
            int i = 0;

            foreach (var obj in townObjects.Skip(page * 8))
            {
                var capt = obj.GetComponent<Capture>();
                if (capt == null)
                    continue;

                i++;

                UI.CreatePanelBlur(ref container, "town" + i, "CaptPanelTowns", "0 0 0 0.4", $"0.009821426 {0.9006174 - i * 0.1}", $"0.9900553 {0.9900553 - i * 0.1}");
                UI.CreateOutLines(ref container, "town" + i, config.ui.colorLines);

                UI.CreateTextOutLine(ref container, "town" + i, capt.Name, "1 1 1 0.7", $"0.05 0", $"0.37 1", TextAnchor.MiddleLeft, 18);
                UI.CreateTextOutLine(ref container, "town" + i, GetMsg("UI_" + config.settings.typeTeam, player) + " " + capt.OwnerName, "1 1 1 0.7", $"0.38 0", $"0.70 1", TextAnchor.MiddleLeft, 16);
                UI.CreateTextOutLine(ref container, "town" + i, GetMsg(capt.GetStatus(), player), "1 1 1 0.7", $"0.71 0", $"0.95 1", TextAnchor.MiddleLeft, 16);

                UI.CreateButton(ref container, "town" + i, "0 0 0 0.5", "?", 16, $"0.95 0.3", $"0.99 0.8", $"UI_SHOW_CAPTURE_ITEMS {capt.id}", TextAnchor.MiddleCenter, "items");
                UI.CreateOutLines(ref container, "items", config.ui.colorLines);


                if (Vector3.Distance(player.transform.position, obj.transform.position) <= capt.distance)
                    nearCapt = capt;
            }

            if (page > 0)
            {
                UI.CreateButton(ref container, "CaptPanelTowns", "0 0 0 0.5", "<", 16, "0.009821426 0.01663953", "0.06874999 0.08943777", $"UI_CHANGE_MAIN_PAGE {page - 1}", TextAnchor.MiddleCenter, "btn_prev");
                UI.CreateOutLines(ref container, "btn_prev", config.ui.colorLines);
            }

            if ((page + 1) * 8 < townObjects.Count())
            {
                UI.CreateButton(ref container, "CaptPanelTowns", "0 0 0 0.5", ">", 16, "0.93 0.01663953", "0.9900553 0.08943777", $"UI_CHANGE_MAIN_PAGE {page + 1}", TextAnchor.MiddleCenter, "btn_next");
                UI.CreateOutLines(ref container, "btn_next", config.ui.colorLines);
            }

            if (nearCapt != null)
            {
                UI.CreateButton(ref container, "CaptMask", config.ui.colorButtonCapture, String.Format(GetMsg("UI_Capture", player), nearCapt.Name), 16, "0.76 0.1363637", "0.9850931 0.2239058", $"UI_START_CAPT {nearCapt.id}", TextAnchor.MiddleCenter, "btn_capt");
                UI.CreateOutLines(ref container, "btn_capt", config.ui.colorLines);
            }

            UI.CreateButton(ref container, "CaptMask", config.ui.colorButtonInventory, GetMsg("UI_Inventory", player), 24, "0.009937823 0.1363637", "0.2472049 0.2239058", "UI_CHANGE_INV_PAGE 0", TextAnchor.MiddleCenter, "btn_inv");
            UI.CreateOutLines(ref container, "btn_inv", config.ui.colorLines);


            UI.CreateButton(ref container, "CaptMask", config.ui.colorButtonInventory, "✘", 24, "0.9383681 0.9314575", "0.96875 0.9783549", "UI_CLOSE_CAPT", TextAnchor.MiddleCenter, "btn_close");
            UI.CreateOutLines(ref container, "btn_close", config.ui.colorLines);


            CuiHelper.DestroyUi(player, "CaptMain");
            CuiHelper.AddUi(player, container);
        }

        private void CreateTownWarsInventory(BasePlayer player, int page = 0)
        {
            var clanName = GetPlayerClan(player);
            if (clanName == null || !inventorysCache.ContainsKey(GetPlayerClan(player)))
            {
                player.ChatMessage(GetMsg("UI_InventoryEmpty", player));
                return;
            }

            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement { Parent = "Overlay", Name = "CaptMain", Components = { new CuiImageComponent { Color = "0 0 0 0", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }, new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }, new CuiNeedsCursorComponent() } });
            UI.CreateButton(ref container, "CaptMain", "0 0 0 0.8", "", 0, "0 0", "1 1", "UI_CLOSE_CAPT");
            UI.CreatePanel(ref container, "CaptMask", "CaptMain", "0 0 0 0", "0.1554688 0.1319444", "0.784375 0.9569445");
            UI.CreatePanelBlur(ref container, "CaptPanel", "CaptMask", config.ui.colorBG, "0.05 0.18", "0.95 0.95");
            UI.CreateOutLines(ref container, "CaptPanel", config.ui.colorLines);
            UI.CreatePanel(ref container, "CaptPanelTowns", "CaptPanel", "0 0 0 0", "0.01475696 0.1197691", "0.9869792 0.9869792");

            UI.CreatePanelBlur(ref container, "Header", "CaptPanelTowns", "0 0 0 0.4", "0.009821426 0.9006174", "0.9900553 0.9900553");
            UI.CreateOutLines(ref container, "Header", config.ui.colorLines);

            UI.CreateTextOutLine(ref container, "Header", GetMsg("UI_Inventory", player), "1 1 1 1", $"0 0", $"1 1", TextAnchor.MiddleCenter, 28);


            int i = 0;
            int j = 0;


            foreach (var item in inventorysCache[clanName].Skip(page * 30))
            {
                var id = item.itemID.ToString();

                UI.CreatePanelBlur(ref container, id, "CaptPanelTowns", $"0 0 0 0.5", $"{0.24 + i * 0.085} {0.7163889 - j * 0.147}", $"{0.32 + i * 0.085} {0.8561111 - j * 0.147}");
                if(String.IsNullOrEmpty(item.customName))
                    CreateImage(ref container, "img", id, "1 1 1 1", item.shortName, "0 0", $"1 1");
                else
                    CreateImage(ref container, "img", id, "1 1 1 1", item.shortName + item.skinID.ToString(), "0 0", $"1 1");

                UI.CreateTextOutLine(ref container, id, "  <size=12>x</size><color=white>" + item.amount + "</color>", $"1 1 1 1", $"0.01 0.01", $"0.95 0.99", TextAnchor.LowerRight, 14);
                UI.CreateOutLines(ref container, id, "0.87 0.44 0.00 0.8");


                UI.CreateButton(ref container, id, "0 0 0 0", "", 16, "0 0", "1 1", $"UI_INV_PAGE_GET_ITEM {item.itemID}", TextAnchor.MiddleCenter, id + "btn");
                i++;
                if (i == 6)
                {

                    i = 0;
                    j++;
                }

                if (j == 5)
                    break;

            }

            if (page > 0)
            {
                UI.CreateButton(ref container, "CaptPanelTowns", "0 0 0 0.5", "<", 16, "0.009821426 0.01663953", "0.06874999 0.08943777", $"UI_CHANGE_INV_PAGE {page - 1}", TextAnchor.MiddleCenter, "btn_prev");
                UI.CreateOutLines(ref container, "btn_prev", config.ui.colorLines);
            }

            if ((page + 1 ) * 30 < inventorysCache[clanName].Count())
            {
                UI.CreateButton(ref container, "CaptPanelTowns", "0 0 0 0.5", ">", 16, "0.93 0.01663953", "0.9900553 0.08943777", $"UI_CHANGE_INV_PAGE {page + 1}", TextAnchor.MiddleCenter, "btn_next");
                UI.CreateOutLines(ref container, "btn_next", config.ui.colorLines);
            }

            UI.CreateButton(ref container, "CaptMask", config.ui.colorButtonInventory, GetMsg("UI_Return", player), 24, "0.009937823 0.1363637", "0.2472049 0.2239058", "UI_RETURN_MAIN", TextAnchor.MiddleCenter, "btn_inv");
            UI.CreateOutLines(ref container, "btn_inv", config.ui.colorLines);

            CuiHelper.DestroyUi(player, "CaptMain");
            CuiHelper.AddUi(player, container);
        }

        private void CreateTownItems(BasePlayer player, int id, int page = 0)
        {
            List<Reward> rewards = new List<Reward>();
            string header = "";

            foreach (var obj in townObjects.Skip(page * 8))
            {
                var capt = obj.GetComponent<Capture>();
                if (capt == null)
                    continue;

                if(capt.id == id)
                {
                    if(config.towns.ContainsKey(capt.monumentName))
                    {
                        header = String.Format(GetMsg("UI_Reward", player), capt.Name);
                        rewards = config.towns[capt.monumentName].rewards;
                    }
                }
            }

            if (rewards.Count <= 0)
                return;

            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement { Parent = "Overlay", Name = "CaptMain", Components = { new CuiImageComponent { Color = "0 0 0 0", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }, new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }, new CuiNeedsCursorComponent() } });
            UI.CreateButton(ref container, "CaptMain", "0 0 0 0.8", "", 0, "0 0", "1 1", "UI_CLOSE_CAPT");
            UI.CreatePanel(ref container, "CaptMask", "CaptMain", "0 0 0 0", "0.1554688 0.1319444", "0.784375 0.9569445");
            UI.CreatePanelBlur(ref container, "CaptPanel", "CaptMask", config.ui.colorBG, "0.05 0.18", "0.95 0.95");
            UI.CreateOutLines(ref container, "CaptPanel", config.ui.colorLines);
            UI.CreatePanel(ref container, "CaptPanelTowns", "CaptPanel", "0 0 0 0", "0.01475696 0.1197691", "0.9869792 0.9869792");

            UI.CreatePanelBlur(ref container, "Header", "CaptPanelTowns", "0 0 0 0.4", "0.009821426 0.9006174", "0.9900553 0.9900553");
            UI.CreateOutLines(ref container, "Header", config.ui.colorLines);

            UI.CreateTextOutLine(ref container, "Header", header, "1 1 1 1", $"0 0", $"1 1", TextAnchor.MiddleCenter, 28);


            int i = 0;
            int j = 0;


            foreach (var item in rewards.Skip(page * 30))
            {
                UI.CreatePanelBlur(ref container, "item" + i + j, "CaptPanelTowns", $"0 0 0 0.5", $"{0.24 + i * 0.085} {0.7163889 - j * 0.147}", $"{0.32 + i * 0.085} {0.8561111 - j * 0.147}");
                if (String.IsNullOrEmpty(item.customName))
                    CreateImage(ref container, "img", "item" + i + j, "1 1 1 1", item.shortName, "0 0", $"1 1");
                else
                    CreateImage(ref container, "img", "item" + i + j, "1 1 1 1", item.shortName + item.skinID.ToString(), "0 0", $"1 1");

                UI.CreateTextOutLine(ref container, "item" + i + j, "  <size=12>x</size><color=white>" + item.amount + "</color>", $"1 1 1 1", $"0.01 0.01", $"0.95 0.99", TextAnchor.LowerRight, 14);
                UI.CreateOutLines(ref container, "item" + i + j, "0.87 0.44 0.00 0.8");

                 i++;
                if (i == 6)
                {

                    i = 0;
                    j++;
                }

                if (j == 5)
                    break;

            }

            if (page > 0)
            {
                UI.CreateButton(ref container, "CaptPanelTowns", "0 0 0 0.5", "<", 16, "0.009821426 0.01663953", "0.06874999 0.08943777", $"UI_CHANGE_INV_PAGE {page - 1}", TextAnchor.MiddleCenter, "btn_prev");
                UI.CreateOutLines(ref container, "btn_prev", config.ui.colorLines);
            }

            if ((page + 1) * 30 < rewards.Count())
            {
                UI.CreateButton(ref container, "CaptPanelTowns", "0 0 0 0.5", ">", 16, "0.93 0.01663953", "0.9900553 0.08943777", $"UI_CHANGE_INV_PAGE {page + 1}", TextAnchor.MiddleCenter, "btn_next");
                UI.CreateOutLines(ref container, "btn_next", config.ui.colorLines);
            }

            UI.CreateButton(ref container, "CaptMask", config.ui.colorButtonInventory, GetMsg("UI_Return", player), 24, "0.009937823 0.1363637", "0.2472049 0.2239058", "UI_RETURN_MAIN", TextAnchor.MiddleCenter, "btn_inv");
            UI.CreateOutLines(ref container, "btn_inv", config.ui.colorLines);

            CuiHelper.DestroyUi(player, "CaptMain");
            CuiHelper.AddUi(player, container);
        }


        [ConsoleCommand("UI_CLOSE_CAPT")]
        private void cmd_UI_CLOSE_CAPT(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            CuiHelper.DestroyUi(player, "CaptMain");
        }

        [ConsoleCommand("UI_RETURN_MAIN")]
        private void cmd_UI_RETURN_MAIN(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            CreateTownWarsMainMenu(player);
        }

        [ConsoleCommand("UI_SHOW_CAPTURE_ITEMS")]
        private void cmd_UI_SHOW_CAPTURE_ITEMS(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            CreateTownItems(player, Convert.ToInt32(arg.Args[0]));
        }

        [ConsoleCommand("UI_START_CAPT")]
        private void cmd_UI_START_CAPT(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            if (arg.Args.Length <= 0) return;

            if(BasePlayer.activePlayerList.Count < config.settings.minPlayers)
            {
                player.ChatMessage(String.Format(GetMsg("UI_LimitPlayers", player), config.settings.minPlayers));
                return;
            }

            int id = Convert.ToInt32(arg.Args[0]);
            var clanName = GetPlayerClan(player);
            if(clanName == null)
            {
                player.ChatMessage(GetMsg("UI_NeedClan", player));
                return;
            }

            if (!isPlayerOwner(player) && !config.settings.allCanStartCapt)
            {
                player.ChatMessage(GetMsg("UI_OnlyOwner", player));
                return;
            }

            foreach (var obj in townObjects)
            {
                var capt = obj.GetComponent<Capture>();
                if (capt == null)
                    continue;

                if (capt.id == id && capt.GetStatus() == "UI_CanCapture" )
                    capt.StartCapture(player);
            }

            CuiHelper.DestroyUi(player, "CaptMain");
        }

        [ConsoleCommand("UI_CHANGE_MAIN_PAGE")]
        private void cmd_UI_CHANGE_MAIN_PAGE(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            if (arg.Args.Length <= 0) return;

            CreateTownWarsMainMenu(player, Convert.ToInt32(arg.Args[0]));
        }

        [ConsoleCommand("UI_CHANGE_INV_PAGE")]
        private void cmd_UI_CHANGE_INV_PAGE(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            if (arg.Args.Length <= 0) return;

            CreateTownWarsInventory(player, Convert.ToInt32(arg.Args[0]));
        }

        [ConsoleCommand("UI_INV_PAGE_GET_ITEM")]
        private void cmd_UI_INV_PAGE_GET_ITEM(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            if (arg.Args.Length <= 0) return;


            
            var clanName = GetPlayerClan(player);
            if (clanName == null)
                return;

            if (!isPlayerOwner(player) && !config.settings.allCanTakeReward)
            {
                player.ChatMessage(GetMsg("UI_OnlyOwner", player));
                return;
            }

            var id = Convert.ToInt32(arg.Args[0]);
            var item = inventorysCache[clanName].FirstOrDefault(i => i.itemID == id);

            if (item == null)
                return;


            if (!String.IsNullOrEmpty(item.command)) rust.RunServerCommand(item.command.Replace("%STEAMID%", player.UserIDString));
            else
            {
                var reward = ItemManager.CreateByName(item.shortName, item.amount, item.skinID);
                if (!String.IsNullOrEmpty(item.customName)) reward.name = item.customName;
                inventorysCache[clanName].Remove(item);
                player.GiveItem(reward);
            }

            CuiElementContainer container = new CuiElementContainer();

            UI.CreatePanelBlur(ref container, "greenPanel", arg.Args[0], $"0.00 0.58 0.00 0.8", $"0 0", $"1 1", 0f, 0.5f);
            UI.CreateTextOutLine(ref container, arg.Args[0], "✔", $"1 1 1 0.8", $"0.01 0.01", $"0.95 0.99", TextAnchor.MiddleCenter, 28, "123", 0.5f);

            CuiHelper.DestroyUi(player, arg.Args[0] + "btn");
            CuiHelper.AddUi(player, container);
        }

        #region [UI generator]
        public class UI
        {
            public static void CreateOutLines(ref CuiElementContainer container, string parent, string color)
            {
                //CreatePanel(ref container, "Line", parent, color, "0 0", "0.001 1");
                //CreatePanel(ref container, "Line", parent, color, "0 0", "1 0.001");
                //CreatePanel(ref container, "Line", parent, color, "0.999 0", "1 1");
                //CreatePanel(ref container, "Line", parent, color, "0 0.999", "1 1");
            }

            public static void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter, string name = "button", float FadeIn = 0f)
            {

                container.Add(new CuiButton
                {

                    Button = { Color = color, Command = command, FadeIn = FadeIn },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }

                },
                panel, name);
            }

            public static void CreatePanel(ref CuiElementContainer container, string name, string parent, string color, string aMin, string aMax, float Fadeout = 0f, float Fadein = 0f)
            {

                container.Add(new CuiElement
                {
                    Name = name,
                    Parent = parent,
                    Components =
        {
            new CuiImageComponent { Color = color, FadeIn = Fadein },
            new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax}
        },
                    FadeOut = Fadeout
                });
            }

            public static void CreatePanelBlur(ref CuiElementContainer container, string name, string parent, string color, string aMin, string aMax, float Fadeout = 0f, float Fadein = 0f)
            {
                container.Add(new CuiPanel()
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Image = { Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", FadeIn = Fadein },
                    FadeOut = Fadeout
                }, parent, name);
            }

            public static void CreateText(ref CuiElementContainer container, string parent, string text, string color, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleLeft, int size = 14, string name = "name", float Fadein = 0f)
            {
                container.Add(new CuiElement
                {
                    Parent = parent,
                    Name = name,
                    Components =
        {
            new CuiTextComponent(){ Color = color, Text = text, FontSize = size, Align = align, FadeIn = Fadein },
            new CuiRectTransformComponent{ AnchorMin =  aMin ,AnchorMax = aMax }
        }
                });
            }

            public static void CreateTextOutLine(ref CuiElementContainer container, string parent, string text, string color, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleLeft, int size = 14, string name = "name", float Fadein = 0f)
            {
                container.Add(new CuiElement
                {
                    Parent = parent,
                    Name = name,
                    Components =
        {
            new CuiTextComponent(){ Color = color, Text = text, FontSize = size, Align = align, FadeIn = Fadein },
            new CuiRectTransformComponent{ AnchorMin =  aMin ,AnchorMax = aMax },
            new CuiOutlineComponent{ Color = "0 0 0 1" }
        }
                });
            }
        }

        public void CreateImage(ref CuiElementContainer container, string name, string panel, string color, string image, string aMin, string aMax, float Fadeout = 0f, float Fadein = 0f, ulong skin = 0)
        {
            container.Add(new CuiElement
            {
                Name = name,
                Parent = panel,
                Components =
        {
            new CuiRawImageComponent { Color = color, Png = (string)ImageLibrary.Call("GetImage", image, skin), FadeIn = Fadein },
            new CuiRectTransformComponent { AnchorMin = aMin, AnchorMax = aMax },

        },
                FadeOut = Fadeout
            });
        }
        #endregion
        #endregion

        #region [Data]
        private void SaveTownsData()
        {
            Dictionary<string, townsData> data = new Dictionary<string, townsData>();
            foreach (var obj in townObjects)
            {
                var capture = obj.GetComponent<Capture>();
                if (capture == null)
                    continue;


                data.Add(capture.monumentName, new townsData() { OwnerID = capture.OwnerId, OwnerName = capture.OwnerName, lastCapture = capture.lastCapture, lastReward = capture.lastReward });
            }

            Interface.Oxide.DataFileSystem.WriteObject($"TownWars/townsData/data", data);
        }

        private void LoadTownsData()
        {
            Dictionary<string, townsData> data = new Dictionary<string, townsData>();
            data = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, townsData>>($"TownWars/townsData/data");

            var monuments = UnityEngine.Object.FindObjectsOfType<MonumentInfo>();
            foreach (var mon in monuments)
            {
                if (!config.towns.ContainsKey(mon.name))
                    continue;

                if (!data.ContainsKey(mon.name))
                {
                    data.Add(mon.name, new townsData() { OwnerName = "-", OwnerID = "0", lastCapture = Facepunch.Math.Epoch.Current - config.settings.delayCapture, lastReward = Facepunch.Math.Epoch.Current });
                }

                var go = new GameObject();
                go.transform.position = mon.transform.position;
                townObjects.Add(go);
                var capt = go.AddComponent<Capture>();
                var cfg = config.towns[mon.name];
                var town = data[mon.name];

                capt.Initialize(mon.name, cfg.name, cfg.capDist, town.OwnerID, town.OwnerName, town.lastReward, town.lastCapture);
            }
        }

        private void clearTownsData(bool load = false)
        {
            Dictionary<string, townsData> data = new Dictionary<string, townsData>();
            Interface.Oxide.DataFileSystem.WriteObject($"TownWars/townsData/data", data);

            if (load)
                LoadTownsData();
        }

        private void AddInventoryToCache(string id)
        {
            if (inventorysCache.ContainsKey(id))
                return;

            List<inventoryData> data;
            var exist = Interface.GetMod().DataFileSystem.ExistsDatafile($"TownWars/invData/inventory_{id}");
            if (!exist)
                return;

            data = Interface.GetMod().DataFileSystem.ReadObject<List<inventoryData>>($"TownWars/invData/inventory_{id}");

            inventorysCache.Add(id, data);
        }

        private void SaveInventoryItem(string id)
        {
            if (!inventorysCache.ContainsKey(id))
                return;

            Interface.Oxide.DataFileSystem.WriteObject($"TownWars/invData/inventory_{id}", inventorysCache[id]);
        }


        private void SaveInventorys()
        {
            foreach (var inv in inventorysCache)
            {
                Interface.Oxide.DataFileSystem.WriteObject($"TownWars/invData/inventory_{inv.Key}", inv.Value);
            }
        }

        private void clearInventory(string id)
        {
            if (inventorysCache.ContainsKey(id))
                inventorysCache[id].Clear();

            Interface.Oxide.DataFileSystem.WriteObject($"TownWars/invData/inventory_{id}", new List<inventoryData>());
        }

        private void wipeInventorys()
        {
            foreach (var file in Interface.Oxide.DataFileSystem.GetFiles("TownWars/invData/"))
            {
                var newFile = file.Remove(file.IndexOf('.'));
                Interface.Oxide.DataFileSystem.WriteObject(newFile, new List<inventoryData>());
            }
        }
        #endregion

        #region [Comp]
        public class Capture : MonoBehaviour
        {
            public string monumentName;
            public string Name;
            public float distance;
            public string OwnerId;
            public string OwnerName;
            public int lastReward;
            public int lastCapture;
            public bool isCapture;
            public int id;
            private int timerSec;

            private List<BasePlayer> players;
            private Dictionary<string, teamInfo> capTeams;
            private SphereCollider sphereCollider;
            private BaseEntity[] spheres;
            private MapMarkerGenericRadius mapMarker;
            private VendingMachineMapMarker vendingMarker;


            public void DestroyComp() => OnDestroy();
            private void OnDestroy()
            {
                RemoveMarker();
                RemoveCaptureSphere();
                Destroy(this);
            }

            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
            }

            public void Initialize(string monName, string townName, int capDist, string oId, string oName, int reward, int capt)
            {
                monumentName = monName;
                Name = townName;
                distance = capDist;
                capTeams = new Dictionary<string, teamInfo>();
                spheres = new BaseEntity[3];
                players = new List<BasePlayer>();
                OwnerId = oId;
                OwnerName = oName;
                lastCapture = capt;
                lastReward = reward;
                id = UnityEngine.Random.Range(1000, 9999);

                if (Facepunch.Math.Epoch.Current - lastCapture < plugin.config.settings.delayCapture)
                    CreateMarker(plugin.config.marker.markerColorCantCapture);
                else
                    CreateMarker(plugin.config.marker.markerColorCanCapture);

                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = capDist;

                InvokeRepeating("Timer", 1f, 1);
            }

            private void OnTriggerEnter(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target != null && !players.Contains(target) && target.IsConnected && target.IsAlive())
                    players.Add(target);
            }

            private void OnTriggerExit(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target != null && players.Contains(target))
                    players.Remove(target);
            }

            private void Timer()
            {
                foreach (var player in players)
                {
                    if (player == null || !player.IsConnected || !player.IsAlive())
                        continue;

                    var clan = plugin.GetPlayerClan(player);
                    if (String.IsNullOrEmpty(clan))
                        continue;

                    if (isCapture)
                    {
                        if (!capTeams.ContainsKey(clan))
                        {
                            capTeams.Add(clan, new teamInfo() { id = clan, name = plugin.GetPlayerClanName(player), points = 0 });
                        }

                        capTeams[clan].points++;
                    }
                    DrawInfo(player);
                }

                if (isCapture)
                {
                    timerSec++;

                    if (timerSec >= plugin.config.settings.durCapture)
                        StopCapture();
                }
                else if (OwnerId != "0")
                {
                    if (Facepunch.Math.Epoch.Current - lastReward >= plugin.config.settings.addRewardSettings)
                    {
                        plugin.AddReward(OwnerId, monumentName);
                        lastReward = Facepunch.Math.Epoch.Current;
                    }
                }

                if (Facepunch.Math.Epoch.Current - lastCapture == plugin.config.settings.delayCapture)
                    mapMarker.color1 = ConvertToColor(plugin.config.marker.markerColorCanCapture);

                UpdateMarker();
            }

            private void DrawInfo(BasePlayer player)
            {
                string text = "<size=20>";
                string owner = "";

                if (!isCapture)
                    owner = plugin.GetMsg(plugin.config.settings.typeTeam, player) + " " + OwnerName;


                if (isCapture)
                {
                    var team = capTeams.OrderByDescending(p => p.Value.points).FirstOrDefault().Value;
                    if (team == null)
                        return;

                    owner = plugin.GetMsg(plugin.config.settings.typeTeam, player) + " " + team.name;

                    var clan = plugin.GetPlayerClan(player);
                    if (String.IsNullOrEmpty(clan))
                        return;

                    var myPoints = capTeams[clan].points;
                    var captTime = TimeSpan.FromSeconds(plugin.config.settings.durCapture - timerSec);

                    text += String.Format(plugin.GetMsg("Capt", player), owner, team.points, myPoints, captTime.Hours, captTime.Minutes, captTime.Seconds);
                }
                else if (Facepunch.Math.Epoch.Current - lastCapture <= plugin.config.settings.delayCapture)
                {
                    var time = TimeSpan.FromSeconds(lastCapture + plugin.config.settings.delayCapture - Facepunch.Math.Epoch.Current);
                    text += String.Format(plugin.GetMsg("CantCapt", player), owner, time.Hours, time.Minutes, time.Seconds, Name);
                }
                else
                {
                    text += String.Format(plugin.GetMsg("CanCapt", player), owner, Name);
                }

                text += "</size>";

                SetPlayerFlag(player, BasePlayer.PlayerFlags.IsAdmin, true);
                player.SendConsoleCommand("ddraw.text", 1.01f, Color.white, transform.position + new Vector3(0, 50f, 0), text);
                SetPlayerFlag(player, BasePlayer.PlayerFlags.IsAdmin, false);
            }

            public void StartCapture(BasePlayer player)
            {
                isCapture = true;
                timerSec = 0;
                capTeams.Clear();
                if (plugin.config.settings.addSphere)
                    CreateCaptureSphere();

                var clan = plugin.GetPlayerClan(player);
                if (String.IsNullOrEmpty(clan))
                    return;

                var info = new teamInfo()
                {
                    id = clan,
                    name = plugin.GetPlayerClanName(player),
                    points = 0
                };


                capTeams.Add(clan, info);

                mapMarker.color1 = ConvertToColor(plugin.config.marker.markerColorCapture);
                vendingMarker.markerShopName = plugin.GetMsg("vendCapt");
                vendingMarker.SendNetworkUpdate();

                plugin.BroadCastToStartCapture(Name);
            }

            private void StopCapture()
            {

                isCapture = false;
                timerSec = 0;
                lastCapture = Facepunch.Math.Epoch.Current;
                lastReward = Facepunch.Math.Epoch.Current;

                var team = capTeams.OrderByDescending(p => p.Value.points).FirstOrDefault().Value;
                if (team == null)
                {
                    OwnerId = "0";
                    OwnerName = "-";
                    return;
                }

                OwnerName = team.name;
                OwnerId = team.id;

                plugin.SaveTownsData();

                RemoveCaptureSphere();
                mapMarker.color1 = ConvertToColor(plugin.config.marker.markerColorCantCapture);
                vendingMarker.markerShopName = OwnerName;
                vendingMarker.SendNetworkUpdate();


                plugin.BroadCastToStopCapture(OwnerName, Name);
            }

            private void UpdateMarker()
            {
                mapMarker.SendUpdate();
            }

            private void RemoveMarker()
            {
                if (mapMarker != null && !mapMarker.IsDestroyed) mapMarker.Kill();
                if (vendingMarker != null && !vendingMarker.IsDestroyed) vendingMarker.Kill();
            }

            private void CreateMarker(string color)
            {
                RemoveMarker();

                mapMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", transform.position).GetComponent<MapMarkerGenericRadius>();
                vendingMarker = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", transform.position).GetComponent<VendingMachineMapMarker>();

                mapMarker.radius = plugin.config.marker.markerRadius;
                mapMarker.color1 = ConvertToColor(color);
                var c = ConvertToColor(color);
                mapMarker.alpha = plugin.config.marker.markerAlpha;
                mapMarker.enabled = true;
                mapMarker.OwnerID = 0;
                mapMarker.Spawn();
                mapMarker.SendUpdate();

                vendingMarker.markerShopName = OwnerName;
                vendingMarker.OwnerID = 0;
                vendingMarker.Spawn();
                vendingMarker.enabled = false;
            }

            private void CreateCaptureSphere()
            {
                RemoveCaptureSphere();

                for (int i = 0; i < 3; i++)
                {
                    BaseEntity ent = new BaseEntity();
                    string strPrefab = "assets/prefabs/visualization/sphere.prefab";

                    spheres[i] = GameManager.server.CreateEntity(strPrefab, transform.position, new Quaternion(), true);
                    SphereEntity ball = spheres[i].GetComponent<SphereEntity>();
                    ball.currentRadius = 1f;
                    ball.lerpRadius = 2.0f * distance;
                    ball.lerpSpeed = 100f;
                    spheres[i].SetParent(ent);
                    spheres[i].Spawn();
                }

            }

            private void RemoveCaptureSphere()
            {
                for (int i = 0; i < 3; i++)
                    if (spheres[i] != null)
                        spheres[i].Kill(BaseNetworkable.DestroyMode.None);
            }

            private void SetPlayerFlag(BasePlayer player, BasePlayer.PlayerFlags f, bool b)
            {
                if (plugin.permission.UserHasGroup(player.UserIDString, "admin")) return;

                if (b)
                {
                    if (player.HasPlayerFlag(f)) return;
                    player.playerFlags |= f;
                }
                else
                {
                    if (!player.HasPlayerFlag(f)) return;
                    player.playerFlags &= ~f;
                }
                player.SendNetworkUpdateImmediate(false);
            }

            private Color ConvertToColor(string color)
            {
                if (color.StartsWith("#")) color = color.Substring(1);
                int red = int.Parse(color.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(color.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(color.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return new Color((float)red / 255, (float)green / 255, (float)blue / 255);
            }

            public bool isPlayerInZone(BasePlayer player) => players.Contains(player);

            public bool removePlayerFromZone(BasePlayer player)
            {
                if (players.Contains(player))
                {
                    players.Remove(player);
                    return true;
                }
                return false;
            }

            public string GetStatus()
            {
                if (Facepunch.Math.Epoch.Current - lastCapture < plugin.config.settings.delayCapture)
                    return "UI_CantCapture";
                else if (isCapture)
                    return "UI_Capturing";
                else
                    return "UI_CanCapture";
            }

            public class teamInfo
            {
                public string id;
                public string name;
                public int points;
            }
        }
        #endregion

        #region [Command]
        [ChatCommand("tw")]
        private void command_TownWars(BasePlayer player, string c, string[] a) => CreateTownWarsMainMenu(player);
        #endregion
    }
}

// --- End of file: TownWars.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SmartHomes.cs ---
// --- Original Local Path: SmartHomes.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using System.Reflection;
using Facepunch;
using System;

namespace Oxide.Plugins
{
    [Info("SmartHomes", "k1lly0u & DylanSMR", "0.1.3", ResourceId = 2051)]
    class SmartHomes : RustPlugin
    {
        // / ////// / //   
        // / Fields / //
        // / ////// / //    
        static MethodInfo updatelayer;

        List<ulong> setupUI = new List<ulong>();
        List<ulong> barUI = new List<ulong>();
        List<ulong> isEditing = new List<ulong>();
        Dictionary<ulong, newData> newD = new Dictionary<ulong, newData>();
        class newData
        {
            public uint entKey;
            public string entName;
            public bool entStatus;
            public string entType;
            public Vector3 entLocation;

            public newData(){ }
        }

        // / ////// / //   
        // / OxideH / //
        // / ////// / //    
        void Loaded()
        {
            homeData = Interface.GetMod().DataFileSystem.ReadObject<HomeData>(this.Title);
            lang.RegisterMessages(messages, this);
        }
        void Unload()
        {
            foreach(var player in BasePlayer.activePlayerList){
            CuiHelper.DestroyUi(player, PublicSideBar);
            CuiHelper.DestroyUi(player, PublicSetupName);
            CuiHelper.DestroyUi(player, PublicObjectSetup);
            CuiHelper.DestroyUi(player, PublicControlSetup);
            CuiHelper.DestroyUi(player, PublicControlSetupTurret);
            CuiHelper.DestroyUi(player, PublicControlSetupDoor);
            CuiHelper.DestroyUi(player, PublicControlSetupLight);
            barUI.Remove(player.userID);
            setupUI.Remove(player.userID);}
            SaveData();
        }
        void OnServerSave()
        {
            SaveData();
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (Homes.Find(player) == null){
                var info = new Homes()
                {
                    locx = 0.0f,
                    locy = 0.0f,
                    locz = 0.0f,
                    playerID = player.userID
                };
                homeData.homeD.Add(player.userID, info);
                SaveData();  
            }        
        }
        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(this.Title, homeData);
        void OnServerInitialized()
        {
            updatelayer = typeof(BuildingBlock).GetMethod("UpdateLayer", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            LoadVariables();
        }   
        // / ////// / //   
        // / data s / //
        // / ////// / // 

        static HomeData homeData;

        class HomeData
        {
            public Dictionary<ulong, Homes> homeD = new Dictionary<ulong, Homes>();
        }

        class Homes
        {
            public float locx;
            public float locy;
            public float locz;

            public ulong playerID;

            public Dictionary<string, TurretData> tData = new Dictionary<string, TurretData>();
            public Dictionary<string, LightData> lData = new Dictionary<string, LightData>();
            public Dictionary<string, DoorData> dData = new Dictionary<string, DoorData>();

            public List<float> objectX = new List<float>();
            public Homes(){}
            internal static Homes Find(BasePlayer player)
            {
                return homeData.homeD.Values.ToList().Find((d) => d.playerID == player.userID);
            }
        }       
        public class TurretData
        {   
            public float locx;
            public float locy;
            public float locz;
            public uint key;
            public bool status;
            public string name;
            public TurretData(){}
        }
        public class LightData
        {
            public float locx;
            public float locy;
            public float locz;
            public uint key;
            public bool status;
            public string name;
            public LightData(){}
        }
        public class DoorData
        {
            public float locx;
            public float locy;
            public float locz;
            public uint key;
            public bool status;
            public string name;
            public DoorData(){}
        }

        // / ////// / //   
        // / Config / //
        // / ////// / //       
        private ConfigData configData;
        class Options
        {
            public float ActivationDistance { get; set; }
        }
        class ConfigData
        {
            public Options Options { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Options = new Options
                {
                    ActivationDistance = 30
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        // / ////// / //   
        // / GUIMai / //
        // / ////// / //    

        [ConsoleCommand("CloseCUIMain")]
        private void destroyUI(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            CuiHelper.DestroyUi(player, PublicSideBar);
            CuiHelper.DestroyUi(player, PublicSetupName);
            CuiHelper.DestroyUi(player, PublicObjectSetup);
            CuiHelper.DestroyUi(player, PublicControlSetup);
            CuiHelper.DestroyUi(player, PublicControlSetupTurret);
            CuiHelper.DestroyUi(player, PublicControlSetupDoor);
            CuiHelper.DestroyUi(player, PublicControlSetupLight);
            barUI.Remove(player.userID);
            setupUI.Remove(player.userID);
        }

        void destroyUIN(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;          
            CuiHelper.DestroyUi(player, PublicSetupName);
            CuiHelper.DestroyUi(player, PublicObjectSetup);
            CuiHelper.DestroyUi(player, PublicControlSetup);
            CuiHelper.DestroyUi(player, PublicControlSetupTurret);
            CuiHelper.DestroyUi(player, PublicControlSetupDoor);
            CuiHelper.DestroyUi(player, PublicControlSetupLight);
            barUI.Remove(player.userID);
            setupUI.Remove(player.userID);  
        }

        [ChatCommand("rem")]
        void openUI(BasePlayer player)
        {
            barUI.Add(player.userID);
            RemoteBar(player);
        }   

        // / ////// / //   
        // / GUI Co / //
        // / ////// / //    

        [ConsoleCommand("CUI_ControlMenu")]
        void ControlMenu(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);

            var element = UI.CreateElementContainer(PublicControlSetup, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicControlSetup, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicControlSetup, UIColors["header"], lang.GetMessage("CtrlMenu", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicControlSetup, UIColors["dark"], lang.GetMessage("SelectMenu", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicControlSetup, UIColors["dark"], "0.14 0.05", "0.38 0.15", true);
            UI.CreateButton(ref element, PublicControlSetup, UIColors["buttongreen"], lang.GetMessage("OpenTurret", this, player.UserIDString), 20, "0.15 0.06", "0.37 0.14", $"CUI_ControlOpen Turret");
            UI.CreatePanel(ref element, PublicControlSetup, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicControlSetup, UIColors["buttongreen"], lang.GetMessage("OpenLight", this, player.UserIDString), 20, "0.40 0.06", "0.62 0.14", $"CUI_ControlOpen Light");
            UI.CreatePanel(ref element, PublicControlSetup, UIColors["dark"], "0.64 0.05", "0.88 0.15", true);
            UI.CreateButton(ref element, PublicControlSetup, UIColors["buttongreen"], lang.GetMessage("OpenDoor", this, player.UserIDString), 20, "0.65 0.06", "0.87 0.14", $"CUI_ControlOpen Door");
            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_ControlOpen")]
        void ControlOpen(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;  
            switch(arg.Args[0])
            {
                case "Turret":
                    destroyUIN(arg);
                    player.SendConsoleCommand("CUI_OpenTurret");
                break;
                case "Light":
                    destroyUIN(arg);
                    player.SendConsoleCommand("CUI_OpenLight");
                break;
                case "Door":
                    destroyUIN(arg);
                    player.SendConsoleCommand("CUI_OpenDoor");
                break;
            }
        } 

        [ConsoleCommand("CUI_ChangeElement")]
        private void ChangeElement(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            var panelName = arg.GetString(0);
            switch (panelName)
            {
                case "listpage":
                    {
                        if(arg.GetString(1) == "turret"){
                            var pageNumber = arg.GetString(2);
                            ControlTurret(arg, int.Parse(pageNumber));
                        }
                        if(arg.GetString(1) == "light"){
                            var pageNumber = arg.GetString(2);
                            ControlLight(arg, int.Parse(pageNumber));
                        }
                        if(arg.GetString(1) == "door"){
                            var pageNumber = arg.GetString(2);
                            ControlDoor(arg, int.Parse(pageNumber));
                        }
                    }
                    return;
            }
        }

        [ConsoleCommand("CUI_OpenTurret")]
        void ControlTurret(ConsoleSystem.Arg arg, int page = 0)
        {
            destroyUIN(arg);
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;   

            var i = homeData.homeD[player.userID].tData.Count;
            var element = UI.CreateElementContainer(PublicControlSetupTurret, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicControlSetupTurret, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicControlSetupTurret, UIColors["header"], lang.GetMessage("TList", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            if(i >= 18){ 
                var maxpages = (i - 1) / 18 + 1;
                if (page < maxpages - 1){
                    UI.CreatePanel(ref element, PublicControlSetupTurret, UIColors["dark"], "0.64 0.05", "0.88 0.15", true); 
                    UI.CreateButton(ref element, PublicControlSetupTurret, UIColors["buttongreen"], lang.GetMessage("Next", this, player.UserIDString), 20, "0.65 0.06", "0.87 0.14", $"CUI_ChangeElement listpage turret {page + 1}"); 
                }
                if(page > 0){
                    UI.CreatePanel(ref element, PublicControlSetupTurret, UIColors["dark"], "0.14 0.05", "0.38 0.15", true);
                    UI.CreateButton(ref element, PublicControlSetupTurret, UIColors["buttongreen"], lang.GetMessage("Back", this, player.UserIDString), 20, "0.15 0.06", "0.37 0.14", $"CUI_ChangeElement listpage turret {page - 1}");
                }
            }

            int maxentries = (18 * (page + 1));
            if (maxentries > i)
                maxentries = i;

            int rewardcount = 18 * page;

            var k = 0;
            var entries = homeData.homeD[player.userID].tData;

            List <string> questNames = new List<string>();
            foreach (var entry in homeData.homeD[player.userID].tData)
                questNames.Add(entry.Key);

            for (int n = rewardcount; n < maxentries; n++)
            {                
                CreateTurretButton(ref element, PublicControlSetupTurret, entries[questNames[n]], player, k); k++;
            }
            CuiHelper.AddUi(player, element);
        } 

        private void CreateTurretButton(ref CuiElementContainer container, string panelName, TurretData data, BasePlayer player, int num)
        {

            string name = homeData.homeD[player.userID].tData[data.name].name;
            var status = "<color='#818884'>Disabled</color>";
            if(homeData.homeD[player.userID].tData[name].status) status = "<color='#818884'>Enabled</color>";
            else status = "<color='#818884'>Disabled</color>";
            var color = "";
            if(homeData.homeD[player.userID].tData[data.name].status) color = "0.06 0.47 0.39 1.0";
            else color = "0.91 0.0 0.0 1.0";
            string cmd = $"CUI_ToggleTurret {homeData.homeD[player.userID].tData[data.name].name}";
            var pos = CalcButtonPos(num);
            UI.CreatePanel(ref container, panelName, UIColors["dark"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", true);
            UI.CreateButton(ref container, panelName, color, $"<color='#818884'>{name}</color>\n{status}", 13, $"{pos[0] + 0.01} {pos[1] + 0.01}", $"{pos[2] - 0.01} {pos[3] - 0.01}", cmd);
        }

        [ConsoleCommand("CUI_ToggleTurret")]
        void toggle(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            var name = arg.Args[0];
            if (player == null)
                return;   
            if(homeData.homeD[player.userID].tData[name].status)
            {
                var newLocation = new Vector3(homeData.homeD[player.userID].tData[name].locx, homeData.homeD[player.userID].tData[name].locy, homeData.homeD[player.userID].tData[name].locz);
                homeData.homeD[player.userID].tData[name].status = false;
                    List<BaseEntity> turretnear= new List<BaseEntity>();
                    Vis.Entities(newLocation, 0.2f, turretnear);
                var i = 0;
                foreach(var turret in turretnear)
                {
                    if(turret.ToString().Contains("turret")){
                        if (turret is AutoTurret) turret.GetComponent<AutoTurret>().target = null;
                        i++;
                        turret.SetFlag(BaseEntity.Flags.On, false);
                        turret.SendNetworkUpdateImmediate();
                    }else{}
                }
                if(i == 0)
                {
                    homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].tData[name].locx);
                    homeData.homeD[player.userID].tData.Remove(name);
                    SaveData();
                    SendReply(player, lang.GetMessage("LostObject", this, player.UserIDString).Replace("0", name).Replace("1", "World"));
                }
            }
            else
            {
                var newLocation = new Vector3(homeData.homeD[player.userID].tData[name].locx, homeData.homeD[player.userID].tData[name].locy, homeData.homeD[player.userID].tData[name].locz);
                homeData.homeD[player.userID].tData[name].status = true;
                    List<BaseEntity> turretnear= new List<BaseEntity>();
                    Vis.Entities(newLocation, 0.2f, turretnear);
                var i = 0;
                foreach(var turret in turretnear)
                {
                    if(turret.ToString().Contains("turret")){
                        if (turret is AutoTurret) turret.GetComponent<AutoTurret>().target = null;
                        i++;
                        turret.SetFlag(BaseEntity.Flags.On, true);
                        turret.SendNetworkUpdateImmediate();
                    }else{}
                }
                if(i == 0)
                {
                    homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].tData[name].locx);
                    homeData.homeD[player.userID].tData.Remove(name);
                    SaveData();
                    SendReply(player, lang.GetMessage("LostObject", this, player.UserIDString).Replace("0", name).Replace("1", "World"));
                }       
            }
            ControlTurret(arg);
            SaveData();
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if(entity is BasePlayer) return;
            if(entity.OwnerID == null) return;
            if(entity.ToString().Contains("autoturret"))
            {
                foreach(var entry in homeData.homeD[entity.OwnerID].tData)
                {
                    if(homeData.homeD[entity.OwnerID].tData[entry.Key] == null) return;
                    if(homeData.homeD[entity.OwnerID].tData[entry.Key].locx == entity.transform.position.x)
                    {
                        var namen = homeData.homeD[entity.OwnerID].tData[entry.Key].name;
                        homeData.homeD[entity.OwnerID].objectX.Remove(entity.transform.position.x);
                        homeData.homeD[entity.OwnerID].tData.Remove(homeData.homeD[entity.OwnerID].tData[entry.Key].name);
                        SaveData();
                        SendReply(BasePlayer.FindByID(entity.OwnerID), lang.GetMessage("LostObject", this, BasePlayer.FindByID(entity.OwnerID).UserIDString).Replace("0", namen).Replace("1", info.Initiator.ToPlayer().displayName));
                        return;
                    }
                    else continue;
                }
            }
            else if(entity.ToString().Contains("hinged"))
            {
                foreach(var entry2 in homeData.homeD[entity.OwnerID].dData)
                {
                    if(homeData.homeD[entity.OwnerID].dData[entry2.Key] == null) return;
                    if(homeData.homeD[entity.OwnerID].dData[entry2.Key].locx == entity.transform.position.x)
                    {
                        var namenew = homeData.homeD[entity.OwnerID].dData[entry2.Key].name;
                        homeData.homeD[entity.OwnerID].objectX.Remove(entity.transform.position.x);
                        homeData.homeD[entity.OwnerID].dData.Remove(homeData.homeD[entity.OwnerID].dData[entry2.Key].name);
                        SaveData();
                        SendReply(BasePlayer.FindByID(entity.OwnerID), lang.GetMessage("LostObject", this, BasePlayer.FindByID(entity.OwnerID).UserIDString).Replace("0", namenew).Replace("1", info.Initiator.ToPlayer().displayName));
                        return;
                    }
                    else continue;
                }
            }
            else if(entity.ToString().Contains("lantern") || entity.ToString().Contains("ceilinglight"))
            {
                foreach(var entry3 in homeData.homeD[entity.OwnerID].lData)
                {
                    if(homeData.homeD[entity.OwnerID].lData[entry3.Key] == null) return;
                    if(homeData.homeD[entity.OwnerID].lData[entry3.Key].locx == entity.transform.position.x)
                    {
                        var namenew = homeData.homeD[entity.OwnerID].lData[entry3.Key].name;
                        homeData.homeD[entity.OwnerID].objectX.Remove(entity.transform.position.x);
                        homeData.homeD[entity.OwnerID].lData.Remove(homeData.homeD[entity.OwnerID].lData[entry3.Key].name);
                        SaveData();
                        SendReply(BasePlayer.FindByID(entity.OwnerID), lang.GetMessage("LostObject", this, BasePlayer.FindByID(entity.OwnerID).UserIDString).Replace("0", namenew).Replace("1", info.Initiator.ToPlayer().displayName));
                        return;
                    }
                    else continue;
                }
            }
            else return;
        }

        // / ////// / //   
        // / Light / //
        // / ////// / //   

        [ConsoleCommand("CUI_OpenLight")]
        void ControlLight(ConsoleSystem.Arg arg, int page = 0)
        {
            destroyUIN(arg);
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;   

            var i = homeData.homeD[player.userID].lData.Count;
            var element = UI.CreateElementContainer(PublicControlSetupLight, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicControlSetupLight, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicControlSetupLight, UIColors["header"], lang.GetMessage("LList", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            if(i >= 18){ 
                var maxpages = (i - 1) / 18 + 1;
                if (page < maxpages - 1){
                    UI.CreatePanel(ref element, PublicControlSetupLight, UIColors["dark"], "0.64 0.05", "0.88 0.15", true); 
                    UI.CreateButton(ref element, PublicControlSetupLight, UIColors["buttongreen"], lang.GetMessage("Next", this, player.UserIDString), 20, "0.65 0.06", "0.87 0.14", $"CUI_ChangeElement listpage light {page + 1}"); 
                }
                if(page > 0){
                    UI.CreatePanel(ref element, PublicControlSetupLight, UIColors["dark"], "0.14 0.05", "0.38 0.15", true);
                    UI.CreateButton(ref element, PublicControlSetupLight, UIColors["buttongreen"], lang.GetMessage("Back", this, player.UserIDString), 20, "0.15 0.06", "0.37 0.14", $"CUI_ChangeElement listpage light {page - 1}");
                }
            }

            int maxentries = (18 * (page + 1));
            if (maxentries > i)
                maxentries = i;

            int rewardcount = 18 * page;

            var k = 0;
            var entries2 = homeData.homeD[player.userID].lData;

            List <string> questNames = new List<string>();
            foreach (var entry in homeData.homeD[player.userID].lData)
                questNames.Add(entry.Key);

            for (int n = rewardcount; n < maxentries; n++)
            {                
                CreateLightButton(ref element, PublicControlSetupLight, entries2[questNames[n]], player, k); k++;
            }
            CuiHelper.AddUi(player, element);
        } 

        private void CreateLightButton(ref CuiElementContainer container, string panelName, LightData light, BasePlayer player, int num)
        {
            string name = light.name;
            var status = "<color='#818884'>Disabled</color>";
            if(homeData.homeD[player.userID].lData[name].status) status = "<color='#818884'>Enabled</color>";
            else status = "<color='#818884'>Disabled</color>";
            var color = "";
            if(homeData.homeD[player.userID].lData[light.name].status) color = "0.06 0.47 0.39 1.0";
            else color = "0.91 0.0 0.0 1.0";
            string cmd = $"CUI_ToggleLight {homeData.homeD[player.userID].lData[light.name].name}";
            var pos = CalcButtonPos(num);
            UI.CreatePanel(ref container, panelName, UIColors["dark"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", true);
            UI.CreateButton(ref container, panelName, color, $"<color='#818884'>{name}</color>\n{status}", 13, $"{pos[0] + 0.01} {pos[1] + 0.01}", $"{pos[2] - 0.01} {pos[3] - 0.01}", cmd);          
        }

        [ConsoleCommand("CUI_ToggleLight")]
        void toggleLight(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            var name = arg.Args[0];
            if (player == null)
                return;   
            if(homeData.homeD[player.userID].lData[name].status)
            {
                var newLocation = new Vector3(homeData.homeD[player.userID].lData[name].locx, homeData.homeD[player.userID].lData[name].locy, homeData.homeD[player.userID].lData[name].locz);
                homeData.homeD[player.userID].lData[name].status = false;
                    List<BaseEntity> lightnear = new List<BaseEntity>();
                    Vis.Entities(newLocation, 0.2f, lightnear);
                var i = 0;
                foreach(var light in lightnear)
                {
                    if(light.ToString().Contains("lantern") || light.ToString().Contains("ceilinglight")){
                        i++;
                        light.SetFlag(BaseEntity.Flags.On, false);
                        light.SendNetworkUpdateImmediate();}
                    else{}
                }
                if(i == 0)
                {
                    homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].lData[name].locx);
                    homeData.homeD[player.userID].lData.Remove(name);
                    SaveData();
                    SendReply(player, lang.GetMessage("LostObject", this, player.UserIDString).Replace("0", name).Replace("1", "World"));
                }  
            }
            else
            {
                var newLocation = new Vector3(homeData.homeD[player.userID].lData[name].locx, homeData.homeD[player.userID].lData[name].locy, homeData.homeD[player.userID].lData[name].locz);
                homeData.homeD[player.userID].lData[name].status = true;
                    List<BaseEntity> lightnear = new List<BaseEntity>();
                    Vis.Entities(newLocation, 0.2f, lightnear);
                var i = 0;
                foreach(var light in lightnear)
                {
                    if(light.ToString().Contains("lantern") || light.ToString().Contains("ceilinglight")){
                        i++;
                        light.SetFlag(BaseEntity.Flags.On, true);
                        light.SendNetworkUpdateImmediate();}
                    else{}
                }
                if(i == 0)
                {
                    homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].lData[name].locx);
                    homeData.homeD[player.userID].lData.Remove(name);
                    SaveData();
                    SendReply(player, lang.GetMessage("LostObject", this, player.UserIDString).Replace("0", name).Replace("1", "World"));
                }
            }
            ControlLight(arg);
            SaveData();
        }

        // / ////// / //   
        // / Doors / //
        // / ////// / //   

        [ConsoleCommand("CUI_OpenDoor")]
        void ControlDoor(ConsoleSystem.Arg arg, int page = 0)
        {
            destroyUIN(arg);
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;   

            var i = homeData.homeD[player.userID].dData.Count;
            var element = UI.CreateElementContainer(PublicControlSetupDoor, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicControlSetupDoor, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicControlSetupDoor, UIColors["header"], lang.GetMessage("LList", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            if(i >= 18){ 
                var maxpages = (i - 1) / 18 + 1;
                if (page < maxpages - 1){
                    UI.CreatePanel(ref element, PublicControlSetupDoor, UIColors["dark"], "0.64 0.05", "0.88 0.15", true); 
                    UI.CreateButton(ref element, PublicControlSetupDoor, UIColors["buttongreen"], lang.GetMessage("Next", this, player.UserIDString), 20, "0.65 0.06", "0.87 0.14", $"CUI_ChangeElement listpage door{page + 1}"); 
                }
                if(page > 0){
                    UI.CreatePanel(ref element, PublicControlSetupDoor, UIColors["dark"], "0.14 0.05", "0.38 0.15", true);
                    UI.CreateButton(ref element, PublicControlSetupDoor, UIColors["buttongreen"], lang.GetMessage("Back", this, player.UserIDString), 20, "0.15 0.06", "0.37 0.14", $"CUI_ChangeElement listpage door {page - 1}");
                }
            }

            int maxentries = (18 * (page + 1));
            if (maxentries > i)
                maxentries = i;

            int rewardcount = 18 * page;

            var k = 0;
            var entries3 = homeData.homeD[player.userID].dData;

            List <string> questNames = new List<string>();
            foreach (var entry in homeData.homeD[player.userID].dData)
                questNames.Add(entry.Key);

            for (int n = rewardcount; n < maxentries; n++)
            {                
                CreateDoorButton(ref element, PublicControlSetupDoor, entries3[questNames[n]], player, k); k++;
            }
            CuiHelper.AddUi(player, element);
        } 

        private void CreateDoorButton(ref CuiElementContainer container, string panelName, DoorData door, BasePlayer player, int num)
        {
            string name = door.name;
            var status = "<color='#818884'>Disabled</color>";
            if(homeData.homeD[player.userID].dData[name].status) status = "<color='#818884'>Enabled</color>";
            else status = "<color='#818884'>Disabled</color>";
            var color = "";
            if(homeData.homeD[player.userID].dData[door.name].status) color = "0.06 0.47 0.39 1.0";
            else color = "0.91 0.0 0.0 1.0";
            string cmd = $"CUI_ToggleDoor {homeData.homeD[player.userID].dData[door.name].name}";
            var pos = CalcButtonPos(num);
            UI.CreatePanel(ref container, panelName, UIColors["dark"], $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", true);
            UI.CreateButton(ref container, panelName, color, $"<color='#818884'>{name}</color>\n{status}", 13, $"{pos[0] + 0.01} {pos[1] + 0.01}", $"{pos[2] - 0.01} {pos[3] - 0.01}", cmd);
        }

        [ConsoleCommand("CUI_ToggleDoor")]
        void toggleDoor(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            var name = arg.Args[0];
            if (player == null)
                return;   
            if(homeData.homeD[player.userID].dData[name].status)
            {
                var newLocation = new Vector3(homeData.homeD[player.userID].dData[name].locx, homeData.homeD[player.userID].dData[name].locy, homeData.homeD[player.userID].dData[name].locz);
                homeData.homeD[player.userID].dData[name].status = false;
                    List<BaseEntity> doornear = new List<BaseEntity>();
                    Vis.Entities(newLocation, 1.0f, doornear);
                var i = 0;
                foreach(var door in doornear)
                {
                    if (door.ToString().Contains("hinged")){
                    i++;
                    door.SetFlag(BaseEntity.Flags.Open, false);
                    door.SendNetworkUpdateImmediate();}
                    else{}
                }
                if(i == 0)
                {
                    homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].dData[name].locx);
                    homeData.homeD[player.userID].dData.Remove(name);
                    SaveData();
                    SendReply(player, lang.GetMessage("LostObject", this, player.UserIDString).Replace("0", name).Replace("1", "World"));
                }
            }
            else
            {
                var newLocation = new Vector3(homeData.homeD[player.userID].dData[name].locx, homeData.homeD[player.userID].dData[name].locy, homeData.homeD[player.userID].dData[name].locz);
                homeData.homeD[player.userID].dData[name].status = true;
                    List<BaseEntity> doornear = new List<BaseEntity>();
                    Vis.Entities(newLocation, 1.0f, doornear);
                var i = 0;
                foreach(var door in doornear)
                {
                    if (door.ToString().Contains("hinged")){
                    i++;
                    door.SetFlag(BaseEntity.Flags.Open, true);
                    door.SendNetworkUpdateImmediate();}
                    else{}
                }
                if(i == 0)
                {
                    homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].dData[name].locx);
                    homeData.homeD[player.userID].dData.Remove(name);
                    SaveData();
                    SendReply(player, lang.GetMessage("LostObject", this, player.UserIDString).Replace("0", name).Replace("1", "World"));
                }
            }
            ControlDoor(arg);
            SaveData();
        }

        // / ////// / //   
        // / calcbt / //
        // / ////// / //   

        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.8f);
            Vector2 dimensions = new Vector2(0.125f, 0.125f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.03f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.03f + dimensions.x) * (number - 6);
                offsetY = (-0.05f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.03f + dimensions.x) * (number - 12);
                offsetY = (-0.05f - dimensions.y) * 2;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        // / ////// / //   
        // / GUIOth / //
        // / ////// / //    

        [ConsoleCommand("CUI_Homes")]
        void SetUP(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (!player.CanBuild()){
                SendReply(player, lang.GetMessage("BuildingAuth", this, player.UserIDString));
                return;
            }
            if(setupUI.Contains(player.userID)){
                destroyUIN(arg);
                setupUI.Remove(player.userID);}
            setupUI.Add(player.userID);

            var element = UI.CreateElementContainer(PublicSetupName, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicSetupName, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicSetupName, UIColors["header"], lang.GetMessage("SHomes", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicSetupName, UIColors["dark"], lang.GetMessage("WalkThrough", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicSetupName, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicSetupName, UIColors["buttongreen"], lang.GetMessage("BeginProcess", this, player.UserIDString), 20, "0.40 0.06", "0.62 0.14", $"CUI_Homesetup2");
            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_HomesNew")]
        void SetUPB(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (!player.CanBuild()){
                SendReply(player, lang.GetMessage("BuildingAuth", this, player.UserIDString).Replace("0", configData.Options.ActivationDistance.ToString()));
                return;
            }
            var i = 0;
            List<BaseEntity> nearby = new List<BaseEntity>();
            Vis.Entities(player.transform.position, configData.Options.ActivationDistance, nearby);
            foreach(BaseEntity entity in nearby)
            {
                if (entity is BuildingPrivlidge)
                { 
                    List<string> authedPlayers = new List<string>();
                    var tc = entity.GetComponent<BuildingPrivlidge>();       
                    if (tc != null)
                    {
                        if(tc.IsAuthed(player)) break;
                        else
                        {
                            SendReply(player, lang.GetMessage("BuildingAuth", this, player.UserIDString).Replace("0", configData.Options.ActivationDistance.ToString()));
                            return;       
                        }
                    }
                }
            }
            if(setupUI.Contains(player.userID)){
                destroyUIN(arg);
                setupUI.Remove(player.userID);}
            setupUI.Add(player.userID);

            var element = UI.CreateElementContainer(PublicSetupName, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicSetupName, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicSetupName, UIColors["header"], lang.GetMessage("SHomes", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicSetupName, UIColors["dark"], lang.GetMessage("WalkThroughNew", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicSetupName, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicSetupName, UIColors["buttongreen"], lang.GetMessage("BeginProcessNew", this, player.UserIDString), 20, "0.40 0.06", "0.62 0.14", $"CUI_HomeNew2");
            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_HomeNew2")]
        void SetUP2B(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);

            var element = UI.CreateElementContainer(PublicSetupName, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicSetupName, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicSetupName, UIColors["header"], lang.GetMessage("SHomes", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicSetupName, UIColors["dark"], lang.GetMessage("StandWhereNew", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicSetupName, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicSetupName, UIColors["buttongreen"], lang.GetMessage("NextRe", this, player.UserIDString), 20, "0.40 0.06", "0.62 0.14", $"CUI_HomeNew3");
            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_Homesetup2")]
        void SetUP2(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);

            var element = UI.CreateElementContainer(PublicSetupName, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicSetupName, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicSetupName, UIColors["header"], lang.GetMessage("SHomes", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicSetupName, UIColors["dark"], lang.GetMessage("StandWhere", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicSetupName, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicSetupName, UIColors["buttongreen"], lang.GetMessage("NextNext", this, player.UserIDString), 20, "0.40 0.06", "0.62 0.14", $"CUI_Homesetup3");
            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_HomeNew3")]
        void SetUP3B(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);
            Homes playerData = Homes.Find(player);
            playerData.locx = player.transform.position.x;
            playerData.locy = player.transform.position.y;
            playerData.locz = player.transform.position.z;

            playerData.tData.Clear();
            playerData.dData.Clear();
            playerData.lData.Clear();
            playerData.objectX.Clear();

            SaveData();

            var element = UI.CreateElementContainer(PublicSetupName, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicSetupName, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicSetupName, UIColors["header"], lang.GetMessage("SHomes", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicSetupName, UIColors["dark"], lang.GetMessage("SmartHomeNew", this, player.UserIDString).Replace("0", configData.Options.ActivationDistance.ToString()), 20, "0 .9", "1 1");

            CuiHelper.DestroyUi(player, PublicSideBar);
            barUI.Remove(player.userID);
            barUI.Add(player.userID);
            RemoteBar(player);

            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_Homesetup3")]
        void SetUP3(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);
            Homes playerData = Homes.Find(player);
            playerData.locx = player.transform.position.x;
            playerData.locy = player.transform.position.y;
            playerData.locz = player.transform.position.z;
            SaveData();

            var element = UI.CreateElementContainer(PublicSetupName, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicSetupName, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicSetupName, UIColors["header"], "Smart Homes", 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            CuiHelper.DestroyUi(player, PublicSideBar);
            barUI.Remove(player.userID);
            barUI.Add(player.userID);
            RemoteBar(player);

            UI.CreateLabel(ref element, PublicSetupName, UIColors["dark"], lang.GetMessage("SmartHome", this, player.UserIDString).Replace("0", configData.Options.ActivationDistance.ToString()), 20, "0 .9", "1 1");
            CuiHelper.AddUi(player, element);    
        } 
        [ConsoleCommand("CUI_ObjectSetup")]
        void ObjectSetup(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            if (!player.CanBuild()){
                SendReply(player, lang.GetMessage("BuildingAuth", this, player.UserIDString));
                return;
            }
                destroyUIN(arg);

            var element = UI.CreateElementContainer(PublicObjectSetup, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicObjectSetup, UIColors["header"], lang.GetMessage("ObjConfig", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicObjectSetup, UIColors["dark"], lang.GetMessage("InstructAdd", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], $"0.14 0.05", $"0.38 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], "<color='#818884'>Add</color>", 20, "0.15 0.06", "0.37 0.14", $"CUI_ObjectSetup2");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], $"0.64 0.05", $"0.88 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], "<color='#818884'>Remove</color>", 20, "0.65 0.06", "0.87 0.14", $"CUI_ObjectRemove1");
            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_ObjectRemove1")]
        void ObjectRemove(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);

            var element = UI.CreateElementContainer(PublicObjectSetup, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicObjectSetup, UIColors["header"], lang.GetMessage("ObjConfig", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicObjectSetup, UIColors["dark"], lang.GetMessage("OnceNear", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], "0.14 0.05", "0.38 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], "Remove Turret", 20, "0.15 0.06", "0.37 0.14", $"CUI_ObjectRemove2 Turret");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], "Remove Light", 20, "0.40 0.06", "0.62 0.14", $"CUI_ObjectRemove2 Light");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], "0.64 0.05", "0.88 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], "Remove Door", 20, "0.65 0.06", "0.87 0.14", $"CUI_ObjectRemove2 Door");
            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_ObjectRemove2")]
        void ObjectRemove2(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);
            switch(arg.Args[0])
            {
                case "Turret":
                    if(homeData.homeD[player.userID].tData.Count == 0)
                    {
                        SendReply(player, "You have no turrets.");
                        return;
                    }
                    List<BaseEntity> turretnear = new List<BaseEntity>();
                    Vis.Entities(player.transform.position, 1.5f, turretnear);
                    var locationT = new Vector3();
                    foreach(var turret in turretnear)
                    {
                        if (turret.ToString().Contains("auto"))
                        {
                            locationT = turret.transform.position;
                            break;
                        }
                    }
                    if(locationT == new Vector3())
                    {
                        SendReply(player, lang.GetMessage("NoTurretInRange", this, player.UserIDString));
                        return;
                    }
                    var i = 0;
                    var ent2 = "";
                    foreach(var entry in homeData.homeD[player.userID].tData)
                    {
                        if(homeData.homeD[player.userID].tData[entry.Key].locx == locationT.x)
                        {
                            i++;
                            player.SendConsoleCommand("CUI_ObjectRemove3");
                            SendReply(player, lang.GetMessage("DeletedTurret", this, player.UserIDString).Replace("0", entry.Key));
                            homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].tData[entry.Key].locx);
                            ent2 = entry.Key;
                            CuiHelper.DestroyUi(player, PublicSideBar);
                            CuiHelper.DestroyUi(player, PublicSetupName);
                            CuiHelper.DestroyUi(player, PublicObjectSetup);
                            isEditing.Remove(player.userID);
                            barUI.Remove(player.userID);
                            setupUI.Remove(player.userID);
                            openUI(player);
                        }
                    }
                    if(i == 0)
                    {
                        SendReply(player, lang.GetMessage("NoTurretInRange", this, player.UserIDString));
                        return;              
                    }
                    if(i != 0)
                    {
                        homeData.homeD[player.userID].tData.Remove(homeData.homeD[player.userID].tData[ent2].name);
                        SaveData();
                    }
                break;
                case "Light":       
                    if(homeData.homeD[player.userID].lData.Count == 0)
                    {
                        SendReply(player, "You have no lights.");
                        return;
                    }
                    List<BaseEntity> lightnear = new List<BaseEntity>();
                    Vis.Entities(player.transform.position, 1.5f, lightnear);
                    var locationL = new Vector3();
                    foreach(var light in lightnear)
                    {
                        if (light.ToString().Contains("lantern") || light.ToString().Contains("ceilinglight"))
                        {
                            locationL = light.transform.position;
                            break;
                        }
                    }
                    if(locationL == new Vector3())
                    {
                        SendReply(player, lang.GetMessage("NoLightInRange", this, player.UserIDString));
                        return;
                    }
                    var n = 0;
                    var ent4 = "";
                    foreach(var entry2 in homeData.homeD[player.userID].lData)
                    {
                        if(homeData.homeD[player.userID].lData[entry2.Key].locx == locationL.x)
                        {
                            n++;
                            player.SendConsoleCommand("CUI_ObjectRemove3");
                            SendReply(player, lang.GetMessage("DeletedLight", this, player.UserIDString).Replace("0", entry2.Key));
                            homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].lData[entry2.Key].locx);
                            ent4 = entry2.Key;
                            CuiHelper.DestroyUi(player, PublicSideBar);
                            CuiHelper.DestroyUi(player, PublicSetupName);
                            CuiHelper.DestroyUi(player, PublicObjectSetup);
                            isEditing.Remove(player.userID);
                            barUI.Remove(player.userID);
                            setupUI.Remove(player.userID);
                            openUI(player);
                        }
                    }
                    if(n == 0)
                    {
                        SendReply(player, lang.GetMessage("NoLightInRange", this, player.UserIDString));
                        return;              
                    }
                    if(n != 0)
                    {
                        homeData.homeD[player.userID].lData.Remove(homeData.homeD[player.userID].lData[ent4].name);
                        SaveData();
                    }
                break;
                case "Door":         
                    if(homeData.homeD[player.userID].dData.Count == 0)
                    {
                        SendReply(player, "You have no doors.");
                        return;
                    }
                    List<BaseEntity> doornear = new List<BaseEntity>();
                    Vis.Entities(player.transform.position, 1.5f, doornear);
                    var locationD = new Vector3();
                    foreach(var door in doornear)
                    {
                        if (door.ToString().Contains("hinged"))
                        {
                            locationD = door.transform.position;
                            break;
                        }
                    }
                    if(locationD == new Vector3())
                    {
                        SendReply(player, lang.GetMessage("NoDoorInRange", this, player.UserIDString));
                        return;
                    }
                    var k = 0;
                    var ent3 = "";
                    foreach(var entry1 in homeData.homeD[player.userID].dData)
                    {
                        if(homeData.homeD[player.userID].dData[entry1.Key].locx == locationD.x)
                        {
                            k++;
                            player.SendConsoleCommand("CUI_ObjectRemove3");
                            SendReply(player, lang.GetMessage("DeletedDoor", this, player.UserIDString).Replace("0", entry1.Key));
                            homeData.homeD[player.userID].objectX.Remove(homeData.homeD[player.userID].dData[entry1.Key].locx);
                            ent3 = entry1.Key;
                            CuiHelper.DestroyUi(player, PublicSideBar);
                            CuiHelper.DestroyUi(player, PublicSetupName);
                            CuiHelper.DestroyUi(player, PublicObjectSetup);
                            isEditing.Remove(player.userID);
                            barUI.Remove(player.userID);
                            setupUI.Remove(player.userID);
                            openUI(player);
                        }
                    }
                    if(k == 0)
                    {
                        SendReply(player, lang.GetMessage("NoTurretInRange", this, player.UserIDString));
                        return;              
                    }
                    if(k != 0)
                    {
                        homeData.homeD[player.userID].dData.Remove(homeData.homeD[player.userID].dData[ent3].name);
                        SaveData();
                    }
                break;
            }
        } 

        [ConsoleCommand("CUI_ObjectSetup2")]
        void ObjectSetup2(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);

            var element = UI.CreateElementContainer(PublicObjectSetup, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicObjectSetup, UIColors["header"], lang.GetMessage("ObjConfig", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicObjectSetup, UIColors["dark"], lang.GetMessage("OnceNear", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], "0.14 0.05", "0.38 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], lang.GetMessage("AddTurret", this, player.UserIDString), 20, "0.15 0.06", "0.37 0.14", $"CUI_ObjectSetup3 Turret");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], lang.GetMessage("AddLight", this, player.UserIDString), 20, "0.40 0.06", "0.62 0.14", $"CUI_ObjectSetup3 Light");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], "0.64 0.05", "0.88 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], lang.GetMessage("AddDoor", this, player.UserIDString), 20, "0.65 0.06", "0.87 0.14", $"CUI_ObjectSetup3 Door");
            CuiHelper.AddUi(player, element);    
        } 

        List<T> FindEntities<T>(Vector3 position, float distance) where T : BaseEntity
        {
            var list = Pool.GetList<T>();
            Vis.Entities(position, distance, list, LayerMask.GetMask("Construction", "Construction Trigger", "Trigger", "Deployed"));
            return list;
        }

        [ConsoleCommand("CUI_ObjectSetup3")]
        void ObjectSetup3(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);
            switch(arg.Args[0])
            {
                case "Turret":
                    if(homeData.homeD[player.userID].tData.Count >= 19)
                    {
                        SendReply(player, lang.GetMessage("You may only have 18 of each object.", this, player.UserIDString));
                        return;
                    }
                    List<BaseEntity> turretnear = new List<BaseEntity>();
                    Vis.Entities(player.transform.position, 1.5f, turretnear);
                    var newKeyT = (uint)(5);
                    var locationT = new Vector3();
                    foreach(var turret in turretnear)
                    {
                        if (turret.ToString().Contains("auto"))
                        {
                            newKeyT = turret.net.ID;
                            locationT = turret.transform.position;
                            break;
                        }
                    }
                    if(locationT == new Vector3())
                    {
                        SendReply(player, lang.GetMessage("NoTurretInRange", this, player.UserIDString));
                        return;
                    }
                    if(homeData.homeD[player.userID].objectX.Contains(locationT.x))
                    {
                        SendReply(player, lang.GetMessage("AlreadyAddedTurret", this, player.UserIDString));
                        return;
                    }  
                    isEditing.Add(player.userID);
                    var tinfo = new newData()
                    {
                        entKey = newKeyT,
                        entName = "",
                        entStatus = false,
                        entType = "Turret",
                        entLocation = locationT,
                    };
                    newD.Add(player.userID, tinfo);
                break;
                case "Light":
                    if(homeData.homeD[player.userID].lData.Count >= 18)
                    {
                        SendReply(player, lang.GetMessage("You may only have 18 of each object.", this, player.UserIDString));
                    }             
                    var newKeyL = (uint)(5);
                    var locationL = new Vector3();
                    List<BaseEntity> nearby = new List<BaseEntity>();
                    Vis.Entities(player.transform.position, 4.5f, nearby);
                    foreach (var lantern in nearby)
                    {
                        if (lantern.ToString().Contains("lantern") || lantern.ToString().Contains("ceilinglight"))
                        {
                            newKeyL = lantern.net.ID;
                            locationL = lantern.transform.position;
                            break;
                        }
                    }
                    if(locationL == new Vector3())
                    {
                        SendReply(player, lang.GetMessage("NoLightInRange", this, player.UserIDString));
                        return;
                    }
                    if(homeData.homeD[player.userID].objectX.Contains(locationL.x))
                    {
                        SendReply(player, lang.GetMessage("AlreadyAddedLight", this, player.UserIDString));
                        return;
                    }      
                    isEditing.Add(player.userID);
                    var linfo = new newData()
                    {
                        entKey = newKeyL,
                        entType = "Light",
                        entName = "",
                        entStatus = false,
                        entLocation = locationL,
                    };
                    newD.Add(player.userID, linfo);
                break;
                case "Door":
                    if(homeData.homeD[player.userID].dData.Count >= 18)
                    {
                        SendReply(player, lang.GetMessage("You may only have 18 of each object.", this, player.UserIDString));
                        return;
                    }           
                    var newKeyD = (uint)(5);
                    var locationD = new Vector3();
                    List<BaseEntity> nearby2 = new List<BaseEntity>();
                    Vis.Entities(player.transform.position, 1.5f, nearby2);
                    foreach (var door in nearby2)
                    {
                        if (door.ToString().Contains("hinged"))
                        {
                            newKeyD = door.net.ID;
                            locationD = door.transform.position;
                            break;
                        }
                    }
                    if(locationD == new Vector3())
                    {
                        SendReply(player, lang.GetMessage("NoDoorInRange", this, player.UserIDString));
                        return;
                    }
                    if(homeData.homeD[player.userID].objectX.Contains(locationD.x))
                    {
                        SendReply(player, lang.GetMessage("AlreadyAddedDoor", this, player.UserIDString));
                        return;
                    }
                    isEditing.Add(player.userID);
                    var Dinfo = new newData()
                    {
                        entKey = newKeyD,
                        entType = "Door",
                        entName = "",
                        entStatus = false,
                        entLocation = locationD,
                    };
                    newD.Add(player.userID, Dinfo);
                break;
            }

            var element = UI.CreateElementContainer(PublicSetupName, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicSetupName, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicSetupName, UIColors["header"], lang.GetMessage("ObjConfig", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicSetupName, UIColors["dark"], lang.GetMessage("NameObje", this), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicSetupName, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicSetupName, UIColors["buttongreen"], lang.GetMessage("Exit", this, player.UserIDString), 20, "0.40 0.06", "0.62 0.14", $"CloseCUIMain");
            CuiHelper.AddUi(player, element);    
        } 

        [ConsoleCommand("CUI_ObjectSetup4")]
        void ObjectSetup4(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
                destroyUIN(arg);

            var element = UI.CreateElementContainer(PublicObjectSetup, UIColors["dark"], "0.21 0.1", "0.9 0.9", true);
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["light"], "0.01 0.02", "0.99 0.98", true);
            UI.CreateLabel(ref element, PublicObjectSetup, UIColors["header"], lang.GetMessage("ObjConfig", this, player.UserIDString), 100, "0.01 0.01", "0.99 0.99", TextAnchor.MiddleCenter);

            UI.CreateLabel(ref element, PublicObjectSetup, UIColors["dark"], lang.GetMessage("Completed", this, player.UserIDString), 20, "0 .9", "1 1");
            UI.CreatePanel(ref element, PublicObjectSetup, UIColors["dark"], "0.39 0.05", "0.63 0.15", true);
            UI.CreateButton(ref element, PublicObjectSetup, UIColors["buttongreen"], lang.GetMessage("Save", this, player.UserIDString), 20, "0.40 0.06", "0.62 0.14", $"CUI_SaveNewObject");
            CuiHelper.AddUi(player, element);    
        }        

        [ConsoleCommand("CUI_SaveNewObject")]
        void ObjectSetup5(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            SaveData();
            CuiHelper.DestroyUi(player, PublicSideBar);
            CuiHelper.DestroyUi(player, PublicSetupName);
            CuiHelper.DestroyUi(player, PublicObjectSetup);
            isEditing.Remove(player.userID);
            barUI.Remove(player.userID);
            setupUI.Remove(player.userID);
            openUI(player);
        }        

        void OnPlayerChat(ConsoleSystem.Arg arg)
        {
            try{
                var player = arg.connection.player as BasePlayer;
                if (player == null)
                    return;
                    if(isEditing.Contains(player.userID))
                    {
                        if (Homes.Find(player) == null)
                            OnPlayerInit(player);
                            Homes playerData = Homes.Find(player);
                            newD[player.userID].entName = arg.Args[0];

                            switch(newD[player.userID].entType)
                            {
                                case "Turret":
                                   foreach(var entry in homeData.homeD[player.userID].tData){
                                        if(entry.Key.ToString() == arg.Args[0]){
                                            isEditing.Remove(player.userID);
                                            newD.Remove(player.userID);
                                            SendReply(player, lang.GetMessage("AlreadyName", this, player.UserIDString).Replace("0", arg.Args[0]));
                                            return;
                                        }
                                    }
                                    var infoT = new TurretData()
                                    {
                                        locx = newD[player.userID].entLocation.x,
                                        locy = newD[player.userID].entLocation.y,
                                        locz = newD[player.userID].entLocation.z,
                                        key = newD[player.userID].entKey,
                                        status = newD[player.userID].entStatus,
                                        name = newD[player.userID].entName,
                                    };
                                    homeData.homeD[player.userID].objectX.Add(newD[player.userID].entLocation.x);
                                    playerData.tData.Add(newD[player.userID].entName, infoT);
                                    player.SendConsoleCommand("CUI_ObjectSetup4");
                                    newD.Remove(player.userID);
                                break;
                                case "Light":
                                   foreach(var entry in homeData.homeD[player.userID].lData){
                                        if(entry.Key.ToString() == arg.Args[0]){
                                            isEditing.Remove(player.userID);
                                            newD.Remove(player.userID);
                                            SendReply(player, lang.GetMessage("AlreadyName", this, player.UserIDString).Replace("0", arg.Args[0]));
                                            return;
                                        }
                                    }
                                    var infoL = new LightData()
                                    {
                                        locx = newD[player.userID].entLocation.x,
                                        locy = newD[player.userID].entLocation.y,
                                        locz = newD[player.userID].entLocation.z,
                                        key = newD[player.userID].entKey,
                                        status = newD[player.userID].entStatus,
                                        name = newD[player.userID].entName,

                                    };
                                    homeData.homeD[player.userID].objectX.Add(newD[player.userID].entLocation.x);
                                    playerData.lData.Add(newD[player.userID].entName, infoL);
                                    player.SendConsoleCommand("CUI_ObjectSetup4");
                                    newD.Remove(player.userID);
                                break;
                                case "Door":
                                    foreach(var entry in homeData.homeD[player.userID].dData){
                                        if(entry.Key.ToString() == arg.Args[0]){
                                            isEditing.Remove(player.userID);
                                            newD.Remove(player.userID);
                                            SendReply(player, lang.GetMessage("AlreadyName", this, player.UserIDString).Replace("0", arg.Args[0]));
                                            return;
                                        }
                                    }
                                    var infoD = new DoorData()
                                    {
                                        locx = newD[player.userID].entLocation.x,
                                        locy = newD[player.userID].entLocation.y,
                                        locz = newD[player.userID].entLocation.z,
                                        key = newD[player.userID].entKey,
                                        status = newD[player.userID].entStatus,
                                        name = newD[player.userID].entName,

                                    };
                                    homeData.homeD[player.userID].objectX.Add(newD[player.userID].entLocation.x);
                                    playerData.dData.Add(newD[player.userID].entName, infoD);
                                    player.SendConsoleCommand("CUI_ObjectSetup4");
                                    newD.Remove(player.userID);
                                break;
                            }
                    }  
            }
            catch(System.Exception)
            {
                return;
            }
        }


        // / ////// / //   
        // / OtherC / //
        // / ////// / //    

        [ConsoleCommand("CUI_RemoteBar")]
        void RemoteBar(BasePlayer player)
        {
            if (Homes.Find(player) == null)
                    OnPlayerInit(player);
            Homes playerData = Homes.Find(player);
            var location = new Vector3(playerData.locx, playerData.locy, playerData.locz);
            var element = UI.CreateElementContainer(PublicSideBar, UIColors["dark"], "0.1 0.1", "0.205 0.5", true);
            UI.CreatePanel(ref element, PublicSideBar, UIColors["light"], "0.05 0.03", "0.95 0.97", true);
            UI.CreateButton(ref element, PublicSideBar, UIColors["blue"], lang.GetMessage("HomeMenu", this, player.UserIDString), 20, "0.1 0.86", "0.9 0.96", $"");

            if(playerData.locx == 0.0f){
            UI.CreateButton(ref element, PublicSideBar, UIColors["green"], lang.GetMessage("HomeSetup", this, player.UserIDString), 16, "0.1 0.73", "0.9 0.83", "CUI_Homes");
            } else { UI.CreateButton(ref element, PublicSideBar, UIColors["green"], lang.GetMessage("HomeSetup", this, player.UserIDString), 16, "0.1 0.73", "0.9 0.83", "CUI_HomesNew"); }

            List<BaseEntity> nearby = new List<BaseEntity>();
            Vis.Entities(location, configData.Options.ActivationDistance, nearby);
            var dotrue = false;
            foreach(var ent in nearby)
            {
                if(ent is BasePlayer)
                {
                    BasePlayer newplayer = ent.ToPlayer();
                    if(newplayer != player) break;
                    else
                    {
                        dotrue = true;
                        break;
                    }
                }
                else dotrue = false;
            }
            if(dotrue) UI.CreateButton(ref element, PublicSideBar, UIColors["orange"], lang.GetMessage("ObjectSet", this, player.UserIDString), 16, "0.1 0.59", "0.9 0.69", "CUI_ObjectSetup");
            else UI.CreateButton(ref element, PublicSideBar, UIColors["orange"], lang.GetMessage("ObjectSet", this, player.UserIDString), 16, "0.1 0.59", "0.9 0.69", "");
            UI.CreateButton(ref element, PublicSideBar, UIColors["lightblue"], lang.GetMessage("CtrlMenu", this, player.UserIDString), 16, "0.1 0.45", "0.9 0.55", "CUI_ControlMenu");
            UI.CreateButton(ref element, PublicSideBar, UIColors["buttonred"], lang.GetMessage("Close", this, player.UserIDString), 16, "0.1 0.04", "0.9 0.14", "CloseCUIMain");
            CuiHelper.AddUi(player, element);
        }

        // / ////// / //   
        // / CUIMai / //
        // / ////// / //    

        static string PublicSetupName = "PublicSetupName";
        static string PublicSideBar = "PublicSideBar";
        static string PublicObjectSetup = "PublicObjectSetup";
        static string PublicControlSetup = "PublicControlSetup";
        static string PublicControlSetupTurret = "PublicControlSetupTurret";
        static string PublicControlSetupLight = "PublicControlSetupLight";
        static string PublicControlSetupDoor = "PublicControlSetupDoor";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "0 0 0 0.6" },
            {"light", ".85 .85 .85 1.0" },
            {"grey1", "0.6 0.6 0.6 1.0" },
            {"brown", "0.3 0.16 0.0 1.0" },
            {"yellow", "0.9 0.9 0.0 1.0" },
            {"orange", "1.0 0.65 0.0 1.0" },
            {"blue", "0.2 0.6 1.0 1.0" },
            {"red", "1.0 0.1 0.1 1.0" },
            {"green", "0.28 0.82 0.28 1.0" },
            {"grey", "0.85 0.85 0.85 1.0" },
            {"lightblue", "0.6 0.86 1.0 1.0" },
            {"buttonbg", "0.2 0.2 0.2 0.7" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" }
        }; 

        // / ////// / //   
        // / Langua / //
        // / ////// / // 

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"SelectMenu", "<color='#818884'>Select a menu you wish to open. With these menu's you can edit any registered objects.</color>"},
            {"OpenTurret", "<color='#818884'>Open Turret Menu</color>"},
            {"OpenLight", "<color='#818884'>Open Light Menu</color>"},
            {"OpenDoor", "<color='#818884'>Open Door Menu</color>"},
            {"TList", "<color='#818884'>Turret List</color>"},
            {"LList", "<color='#818884'>Lights List</color>"},
            {"DList", "<color='#818884'>Door List</color>"},
            {"SHomes", "<color='#818884'>Smart Homes</color>"},
            {"WalkThrough", "<color='#818884'>Smart Home will walk you through how to setup your home!</color>"},
            {"BeginProcess", "<color='#818884'>Begin Processing Home</color>"},
            {"WalkThroughNew", "<color='#818884'>Smart Home will walk you through how to setup your new home!</color>"},
            {"BeginProcessNew", "<color='#818884'>Begin Reprocessing Home!</color>"},
            {"StandWhereNew", "<color='#818884'>Go ahead and stand where you wish your new home to be and hit next(Suggestion is in middle of base)(WARNING-THIS WILL REMOVE ALL OBJECT DATA!!!!)!</color>"},
            {"NextRe", "<color='#818884'>Begin Next Reprocessing Stage</color>"},
            {"StandWhere", "<color='#818884'>Go ahead and stand where you wish your home to be and hit next(Suggestion is in middle of base)!</color>"},
            {"NextNext", "<color='#818884'>Next Processing Stage</color>"},
            {"SmartHomeNew", "<color='#818884'>Smart Home has just finished your new home! You may now add objects within 0m!</color>"},
            {"SmartHome", "<color='#818884'>Smart Home has just finished your home! You may now add objects within 0m!</color>"},
            {"ObjConfig", "<color='#818884'>Object Configuration</color>"},
            {"InstructAdd", "<color='#818884'>Follow the instructions to add/remove a object. Press Remove or Add to start!</color>"},
            {"OnceNear", "<color='#818884'>One near the correct object. Click the appropriate selection below!</color>"},
            {"AddTurret", "<color='#818884'>Add Turret</color>"},
            {"AddLight", "<color='#818884'>Add Light</color>"},
            {"AddDoor", "<color='#818884'>Add Door</color>"},
            {"NameObje", "<color='#818884'>You must now name your object. Type your new name in chat(without any command)!</color>"},
            {"Exit", "<color='#818884'>Exit</color>"},
            {"Completed", "<color='#818884'>You have completed the process and created a new object! Click Save New Object to finish!</color>"},
            {"CompletedRemove", "<color='#818884'>You have completed the process and removed a object! Click Save New Object to finish!</color>"},
            {"Save", "<color='#818884'>Save New Object</color>"},
            {"HomeMenu", "<color='#818884'>*Home Menu*</color>"},
            {"HomeSetup", "<color='#818884'>Home Setup</color>"},
            {"ObjectSet", "<color='#818884'>Object Setup</color>"},
            {"Close", "<color='#818884'>Close</color>"},
            {"AlreadyName", "There is already a object with the name of 0!"},
            {"BuildingAuth", "You must have all cupboard access within 0m."},
            {"LostObject", "You have lost your object: 0 to player/object 1."},
            {"DeletedTurret", "You have deleted the turret with the name of 0."},
            {"DeletedLight", "You have deleted the light with the name of 0."},
            {"DeletedDoor", "You have deleted the door with the name of 0."},
            {"NoDoorInRange", "There is no door within 1m of you!"},
            {"NoLightInRange", "There is no light within 5m of you!"},
            {"NoTurretInRange", "There is no turret within 1m of you!"},
            {"AlreadyAddedDoor", "You have already added this door!"},
            {"AlreadyAddedTurret", "You have already added this turret!"},
            {"AlreadyAddedLight", "You have already added this light!"},
            {"CtrlMenu", "<color='#818884'>Control Menu</color>"},
            {"Next", "Next"},
            {"Back", "Back"},
        };
    }
}

// --- End of file: SmartHomes.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQMenu.cs ---
// --- Original Local Path: IQMenu.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQMenu", "Mercury", "0.0.1")]
    [Description("Ясно клоун")]
    class IQMenu : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin ImageLibrary;
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);

        #endregion

        #region Vars
        public List<ulong> PlayerOpenMenu = new List<ulong>();
        #endregion

        #region Configuration 
        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройка меню")] public List<MenuClass> MenuSettings = new List<MenuClass>();
            [JsonProperty("Иконка для главного меню")] public string UrlMenu;
            [JsonProperty("Название сервера для главного меню")] public string ServerName;
            [JsonProperty("Название кнопки главного меню")] public string ButtonName;
            [JsonProperty("Настройка броадкаста")] public List<string> BroadCastList = new List<string>();

            internal class MenuClass
            {
                [JsonProperty("Иконка для кнопки")] public string URLIco;
                [JsonProperty("Название для кнопки")] public string DisplayName;
                [JsonProperty("Команда для кнопки")] public string Command;
            }

            public static Configuration GetNewConfiguration() 
            {
                return new Configuration
                {
                    ServerName = "<b><size=26>СУПЕР <color=#85C84F>СЕРВЕР</color> | MAX 3</size></b>",
                    ButtonName = "<b><size=18>МЕНЮ</size></b>",
                    UrlMenu = "https://i.imgur.com/chc6Jfs.png",
                    MenuSettings = new List<MenuClass>
                    {
                        new MenuClass
                        {
                            DisplayName = "Магазин",
                            URLIco = "https://i.imgur.com/Us7eiTz.png",
                            Command = "UI_GameStoresRUST"
                        },
                        new MenuClass
                        {
                            DisplayName = "Ваша кастом кнопка",
                            URLIco = "https://i.imgur.com/QaueVCY.png",
                            Command = "chat.say /craft",
                        },
                        new MenuClass
                        {
                            DisplayName = "Еще одна кнопка",
                            URLIco = "https://i.imgur.com/zfM6hpw.png",
                            Command = "chat.say /report",
                        },
                    },
                    BroadCastList = new List<string>
                    {
                        "<b>Тестовое оповещение - <color=#3B85F5FF>Цвет</color></b>",
                        "<b>Тестовое оповещение - <color=#3B85F5FF>Цвет</color></b>",
                        "<b>Тестовое оповещение - <color=#3B85F5FF>Цвет</color></b>",
                        "<b>Тестовое оповещение - <color=#3B85F5FF>Цвет</color></b>",
                        "<b>Тестовое оповещение - <color=#3B85F5FF>Цвет</color></b>",
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения #57 конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Interface

        public static string MENU_PARENT = "MENU_PARENT_LAYER";
        public static string DROP_MENU_PANEL = "DROP_MENU_LAYER";
        public static string BROADCAST_PARENT = "BROADCAST_PARENT_LAYER";

        void InterfaceMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MENU_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -60", OffsetMax = "300 0" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", MENU_PARENT);

            container.Add(new CuiElement
            {
                Parent = MENU_PARENT,
                Components =
                        {
                        new CuiRawImageComponent { Png = GetImage(config.ButtonName),  Color = HexToRustFormat("#FFFFFF8B") },
                        new CuiRectTransformComponent{  AnchorMin = $"0.2 0.06484989", AnchorMax = $"0.2888888 0.4727611" },
                        }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02 0.4787878", AnchorMax = "1 1" },
                Text = { Text = config.ServerName, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleLeft, Color = HexToRustFormat("#FFFFFF8B") }
            }, MENU_PARENT);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.2022 0.5515152" },
                Button = { Command = $"pmenu open", Color = "0 0 0 0" },
                Text = { Text = config.ButtonName, Color = HexToRustFormat("#FFFFFF8B"), Align = TextAnchor.MiddleCenter }
            },  MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.242223 0", AnchorMax = "0.5311611 0.5515152" },
                Text = { Text = $"<b><size=14>Онлайн</size></b>\n<b><size=12>{BasePlayer.activePlayerList.Count}/{ConVar.Server.maxplayers}</size></b>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFF8B") }
            }, MENU_PARENT, "ONLINE_TEXT");

            CuiHelper.AddUi(player, container);
        }

        void UpdateOnlineLabel()
        {
            timer.Every(30f, () =>
             {
                 for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                 {
                     var player = BasePlayer.activePlayerList[i];
                     CuiHelper.DestroyUi(player, "ONLINE_TEXT");
                     CuiElementContainer container = new CuiElementContainer();
                     container.Add(new CuiLabel
                     {
                         RectTransform = { AnchorMin = "0.242223 0", AnchorMax = "0.5311111 0.5515152" },
                         Text = { Text = $"<b><size=14>Онлайн</size></b>\n<b><size=12>{BasePlayer.activePlayerList.Count}/{ConVar.Server.maxplayers}</size></b>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFF8B") }
                     }, MENU_PARENT, "ONLINE_TEXT");
                     CuiHelper.AddUi(player, container);
                 }
             });
        }

        void BroadCast()
        {
            timer.Every(120f, () =>
            {
                for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, BROADCAST_PARENT);
                    CuiElementContainer container = new CuiElementContainer();
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0 0", OffsetMax = "300 20" },
                        Text = { Text = $"{config.BroadCastList[UnityEngine.Random.Range(0, config.BroadCastList.Count)]}", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFF8B") }
                    }, "Overlay", BROADCAST_PARENT);
                    CuiHelper.AddUi(player, container);
                }
            });
        }

        void DropListMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, DROP_MENU_PANEL);

            container.Add(new CuiPanel
            {
                FadeOut = 0.1f,
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"0 -600", OffsetMax = "300 -60" },
                Image = { FadeIn = 0.1f, Color = "0 0 0 0" }
            }, MENU_PARENT, DROP_MENU_PANEL);


            for (int i = 0; i < config.MenuSettings.Count; i++)
            {
                var cfg = config.MenuSettings[i];

                container.Add(new CuiElement
                {
                    Parent = DROP_MENU_PANEL,
                    Components =
                        {
                        new CuiRawImageComponent { Png = GetImage(cfg.DisplayName),  Color = HexToRustFormat("#FFFFFF8B") },
                        new CuiRectTransformComponent{  AnchorMin = $"0.02 {0.95 - (i * 0.06)}", AnchorMax = $"0.11 {0.995 - (i * 0.06)}" },
                        }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.15 {0.95 - (i * 0.06)}", AnchorMax = $"1 {0.99 - (i * 0.06)}" },
                    Button = { Command = $"{cfg.Command}", Color = "0 0 0 0" },
                    Text = { Text = cfg.DisplayName, Color = HexToRustFormat("#FFFFFFFF"), Align = TextAnchor.MiddleLeft }
                }, DROP_MENU_PANEL);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Hooks
        private void OnServerInitialized()
        {
            LoadImage();
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++) 
            { 
                var player = BasePlayer.activePlayerList[i];
                InterfaceMenu(player);
            }
            BroadCast();
            UpdateOnlineLabel();
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() =>
                {
                    OnPlayerInit(player);
                    return;
                });
            }
            InterfaceMenu(player);
        }

        void Unload()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var player = BasePlayer.activePlayerList[i];
                CuiHelper.DestroyUi(player, BROADCAST_PARENT);
                CuiHelper.DestroyUi(player, DROP_MENU_PANEL);
                CuiHelper.DestroyUi(player, MENU_PARENT);
            }
        }

        #endregion

        #region Command

        [ConsoleCommand("pmenu")]
        void PerMentCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            switch (arg.Args[0])
            {
                case "open":
                    {
                        if (IsOpenMenu(player))
                        {
                            CuiHelper.DestroyUi(player, DROP_MENU_PANEL);
                            PlayerOpenMenu.Remove(player.userID);
                        }
                        else
                        {
                            DropListMenu(player);
                            PlayerOpenMenu.Add(player.userID);
                        }
                        break;
                    }
            }
        }

        #endregion

        #region Metods

        void LoadImage()
        {
            AddImage(config.UrlMenu, config.ButtonName);
            for (int i = 0; i < config.MenuSettings.Count; i++)
                AddImage(config.MenuSettings[i].URLIco, config.MenuSettings[i].DisplayName);
        }

        bool IsOpenMenu(BasePlayer player)
        {
            if (PlayerOpenMenu.Contains(player.userID)) return true;
            else return false;
        }

        #endregion

        #region Utilites

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            UnityEngine.Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion
    }
}


// --- End of file: IQMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XPDeathReducer.cs ---
// --- Original Local Path: XPDeathReducer.cs ---


using System.Collections.Generic;
using Oxide.Core.Plugins;
using Rust.Xp;

namespace Oxide.Plugins
{
    [Info("XP Death Reducer", "k1lly0u", "0.1.2", ResourceId = 2007)]
    class XPDeathReducer : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin Clans;
        [PluginReference]
        Plugin Friends;
        [PluginReference]
        Plugin EventManager;

        #endregion

        #region Oxide Hooks  
        void Loaded() => lang.RegisterMessages(Messages, this);      
        void OnServerInitialized() => LoadVariables();
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                var attacker = info?.InitiatorPlayer;
                var victim = entity.ToPlayer();
                if (victim != null)
                {
                    if (attacker != null)
                    {
                        if (configData.Exemptions.FriendsExempt && IsFriend(attacker.userID, entity.ToPlayer().userID)) return;
                        if (configData.Exemptions.ClansExempt && IsClanmate(attacker.userID, entity.ToPlayer().userID)) return;
                    }
                    if (configData.Exemptions.AdminExempt && victim.IsAdmin()) return;
                    if (IsPlaying(victim)) return;
                    DeductPlayerXP(victim, attacker);
                }
            }
            catch { }
        }
        #endregion

        #region Functions
        private void DeductPlayerXP(BasePlayer victim, BasePlayer attacker)
        {
            var totalXP = victim.xp.SpentXp + victim.xp.UnspentXp;            
            var unspent = victim.xp.UnspentXp;
            var spent = victim.xp.SpentXp;
            float amount = 0;     

            if (configData.Deductions.UsePercentageDeduction)
                amount = (totalXP / 100) * configData.Deductions.XPDeductionPercentage;
            else amount = configData.Deductions.XPDeductionStatic;

            if (victim.xp.UnspentXp > 1)
            {
                victim.xp.Reset();
                victim.xp.Add(Definitions.Cheat, totalXP - amount);
                victim.xp.SpendXp((int)spent, null);
                var deathmessage = MSG("lossMessage", attacker.UserIDString)
                        .Replace("{color}", configData.Messaging.MSG_Color)
                        .Replace("{amount}", $"</color>{configData.Messaging.MSG_MainColor}{(int)amount}</color>{configData.Messaging.MSG_Color}")
                        .Replace("{endcolor}", "</color>");
                MessagePlayer(victim, deathmessage);
            }

            if (attacker != null && configData.Options.GiveDeductedXPToKiller)
            {
                attacker.xp.Add(Definitions.Cheat, amount);
                var killmessage = MSG("gainMessage", attacker.UserIDString)
                    .Replace("{color}", configData.Messaging.MSG_Color)
                    .Replace("{amount}", $"</color>{configData.Messaging.MSG_MainColor}{(int)amount}</color>{configData.Messaging.MSG_Color}")
                    .Replace("{victimname}", $"</color>{configData.Messaging.MSG_MainColor}{victim.displayName}</color>");
                MessagePlayer(attacker, killmessage);
            }
        }
        private void MessagePlayer(BasePlayer player, string message)
        {
            if (player.IsSleeping() || player.IsDead())
            {
                timer.Once(3, () => MessagePlayer(player, message));
                return;
            }
            else SendReply(player, message);
        }
        #endregion

        #region External Calls
        private bool IsClanmate(ulong playerId, ulong friendId)
        {
            object playerTag = Clans?.Call("GetClanOf", playerId);
            object friendTag = Clans?.Call("GetClanOf", friendId);
            if (playerTag is string && friendTag is string)
                if (playerTag == friendTag) return true;
            return false;
        }
        private bool IsFriend(ulong playerId, ulong friendId)
        {
            bool isFriend = (bool)Friends?.Call("IsFriend", playerId, friendId);
            return isFriend;
        }
        private bool IsPlaying(BasePlayer player)
        {
            if (EventManager)
            {
                object isPlaying = EventManager?.Call("isPlaying", new object[] { player });
                if (isPlaying is bool)
                {
                    if ((bool)isPlaying) return true;
                }                
            }
            return false;
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class Exempt
        {
            public bool AdminExempt;
            public bool FriendsExempt;
            public bool ClansExempt;
        }
        class Deductions
        {
            public bool UsePercentageDeduction;
            public float XPDeductionPercentage;
            public float XPDeductionStatic;
        }
        class Options
        {
            public bool GiveDeductedXPToKiller;
        }
        class Messaging
        {
            public string MSG_MainColor;
            public string MSG_Color;
        }
        class ConfigData
        {
            public Exempt Exemptions { get; set; }
            public Deductions Deductions { get; set; }
            public Options Options { get; set; }
            public Messaging Messaging { get; set; }
        }
        
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Deductions = new Deductions
                {
                    UsePercentageDeduction = true,
                    XPDeductionPercentage = 5,
                    XPDeductionStatic = 50
                },
                Exemptions = new Exempt
                {
                    AdminExempt = false,
                    ClansExempt = false,
                    FriendsExempt = false,
                },
                Options = new Options
                {
                    GiveDeductedXPToKiller = false,
                },
                Messaging = new Messaging
                {
                    MSG_MainColor = "<color=orange>",
                    MSG_Color = "<color=#939393>"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messaging
        private string MSG(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"lossMessage", "{color}Your have lost {amount} XP for dieing{endcolor}" },
            {"gainMessage", "{color}Your have gained {amount} XP for killing {victimname}" }           
        };
        #endregion
    }
}


// --- End of file: XPDeathReducer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PrefabSniffer.cs ---
// --- Original Local Path: PrefabSniffer.cs ---

using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using Facepunch;

namespace Oxide.Plugins
{
	[Info("PrefabSniffer", "Ayrin", "1.1.1", ResourceId = 1938)]
	class PrefabSniffer : RustPlugin
	{
		private static List<string> resourcesList;

        private string argmsg = "Usage: prefabs build/fx";

		[ConsoleCommand("prefabs")]
		void cmdSniffPrefabs(ConsoleSystem.Arg arg)
		{
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, argmsg);
                return;
            }


            resourcesList = new List<string>();
            var argname = "default";
            var filesraw = GameManifest.Get().pooledStrings;
            var filesField = typeof(FileSystem_AssetBundles).GetField("files", BindingFlags.Instance | BindingFlags.NonPublic);
            var files = (Dictionary<string, AssetBundle>)filesField.GetValue(FileSystem.iface);
            
            switch (arg.Args[0].ToLower())
            {
                case "build":
                    foreach (var str in files.Keys)
                    {
                        if ((str.StartsWith("assets/content/")
                        	|| str.StartsWith("assets/bundled/")
                        	|| str.StartsWith("assets/prefabs/")) && str.EndsWith(".prefab"))
                        {
                            if (str.Contains(".worldmodel.")
                            	|| str.Contains("/fx/")
                            	|| str.Contains("/effects/")
                            	|| str.Contains("/build/skins/")
                            	|| str.Contains("/_unimplemented/")
                            	|| str.Contains("/ui/")
                            	|| str.Contains("/sound/")
                            	|| str.Contains("/world/")
                            	|| str.Contains("/env/")
                            	|| str.Contains("/clothing/")
                            	|| str.Contains("/skins/")
                            	|| str.Contains("/decor/")
                            	|| str.Contains("/monument/")
                            	|| str.Contains("/crystals/")
                            	|| str.Contains("/projectiles/")
                            	|| str.Contains("/meat_")
                            	|| str.EndsWith(".skin.prefab")
                            	|| str.EndsWith(".viewmodel.prefab")
                            	|| str.EndsWith("_test.prefab")
                            	|| str.EndsWith("_collision.prefab")
                            	|| str.EndsWith("_ragdoll.prefab")
                            	|| str.EndsWith("_skin.prefab")
                            	|| str.Contains("/clutter/")) continue;
                            
                            var gmobj = GameManager.server.FindPrefab(str);
                            if (gmobj?.GetComponent<BaseEntity>() != null)
                                resourcesList.Add(str);
                        }
                    }
                    argname = "Build";
                    Puts("Check your ~/oxide/logs folder");
                    break;
                case "fx":
                    foreach (var str in filesraw)
                    {
                        if ((str.str.StartsWith("assets/content/")
                        	|| str.str.StartsWith("assets/bundled/")
                        	|| str.str.StartsWith("assets/prefabs/")) && str.str.EndsWith(".prefab"))
                        {
                            if (!str.str.Contains("/fx/")) continue;

                            resourcesList.Add(str.str.ToString());
                        }
                    }
                    argname = "FX";
                    Puts("Check your ~/oxide/logs folder");
                    break;
                case "all":
                	foreach (var str in filesraw)
                	{
                		resourcesList.Add(str.str.ToString());
                	}
                	argname = "ALL";
                	Puts("Check your ~/oxide/logs folder");
                	break;
                default:
                    SendReply(arg, argmsg);
                    break;
            }
            
            var now = DateTime.Now.ToString("dd-MM-yyyy");
            for (int i = 0; i < resourcesList.Count - 1; i++)
            {
                ConVar.Server.Log("oxide/logs/Prefabs" + argname + "_" + now + ".txt", string.Format("{0} - {1}", i, resourcesList[i]));
            }
		}
	}
}

// --- End of file: PrefabSniffer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Deekay.cs ---
// --- Original Local Path: Deekay.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using UnityEngine;
using Facepunch;
using System;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Deekay", "k1lly0u", "0.2.27")]
    class Deekay : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin ZoneManager;

        private static Deekay ins;

        private Hash<uint, DecayManager> dkEntities = new Hash<uint, DecayManager>();
        private bool isInitialized;
        #endregion

        #region Oxide Hooks        
        private void OnServerInitialized()
        {
            ins = this;
            InitializeConfigData();
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!isInitialized || entity == null)
                return;

            string prefabName = entity.ShortPrefabName;
            if (prefabName.Contains("autospawn") || prefabName.Contains("npc") || prefabName.Contains("static"))
                return;

            if (entity is BaseCombatEntity)
            {
                if (entity is BuildingPrivlidge)
                    return;

                ConfigData.DecayData decayData = null;
                if (entity is BuildingBlock)
                {
                    if (configData.Buildings.ContainsKey(prefabName))
                        configData.Buildings[prefabName].TryGetValue((entity as BuildingBlock).grade, out decayData);
                }
                else
                {
                    if (configData.Entities.ContainsKey(prefabName))
                        configData.Entities.TryGetValue(prefabName, out decayData);
                }
                if (decayData != null && decayData.IsEnabled)
                {
                    if (!dkEntities.ContainsKey(entity.net.ID))
                        dkEntities.Add(entity.net.ID, new DecayManager(entity as BaseCombatEntity, decayData));
                }
            }
        }
       
        private void OnDoorOpened(Door door, BasePlayer player)
        {
            if (!configData.MonitorActivity || door == null)
                return;           

            DecayTouch(door.transform.position);
        }

        private void OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (!configData.MonitorActivity || entity == null)
                return;

            DecayTouch(entity.transform.position);
        }

        private void OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (entity == null || entity.IsDestroyed || !entity.IsValid()) return;

            ConfigData.DecayData decayData = null;
            string prefabName = entity.ShortPrefabName;

            if (configData.Buildings.ContainsKey(prefabName))
            {
                if (configData.Buildings[prefabName].TryGetValue(grade, out decayData))
                {
                    if (!decayData.IsEnabled)
                    {
                        if (dkEntities.ContainsKey(entity.net.ID))
                        {
                            dkEntities[entity.net.ID].CancelInvokes();
                            dkEntities.Remove(entity.net.ID);
                        }
                        return;
                    }
                    if (dkEntities.ContainsKey(entity.net.ID))
                    {
                        dkEntities[entity.net.ID].CancelInvokes();
                        dkEntities[entity.net.ID] = new DecayManager(entity, decayData);
                    }
                    else dkEntities.Add(entity.net.ID, new DecayManager(entity, decayData));
                }
            }
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null)
                return;

            if (entity is BuildingPrivlidge)
            {
                BuildingManager.Building building = (entity as BuildingPrivlidge).GetBuilding();
                if (building != null)
                {
                    if (building.HasBuildingPrivileges())
                        return;

                    if (building.HasBuildingBlocks())
                    {
                        foreach (BuildingBlock block in building.buildingBlocks)
                        {
                            DecayManager manager;
                            if (dkEntities.TryGetValue(block.net.ID, out manager))
                                manager.ResetDecayOnDestroy();
                        }
                    }
                    if (building.HasDecayEntities())
                    {
                        foreach (DecayEntity decayEntity in building.decayEntities)
                        {
                            DecayManager manager;
                            if (dkEntities.TryGetValue(decayEntity.net.ID, out manager))
                                manager.ResetDecayOnDestroy();
                        }
                    }
                }
            }
            else
            {
                if (entity?.net?.ID == null)
                    return;

                if (dkEntities.ContainsKey(entity.net.ID))
                {
                    dkEntities[entity.net.ID].CancelInvokes();
                    dkEntities.Remove(entity.net.ID);
                }
            }                
        }

        private void Unload()
        {
            foreach(var entity in dkEntities)            
                entity.Value.CancelInvokes();            
            dkEntities.Clear();

            ins = null;
        }
        #endregion

        #region Functions        
        private void InitializeConfigData()
        {
            bool hasChanged = false;
            foreach (Construction construction in GetAllPrefabs<Construction>())
            {
                if (construction?.deployable == null && !string.IsNullOrEmpty(construction.hierachyName))
                {
                    if (construction.hierachyName.Contains("survey_crater"))
                        continue;

                    string hierachyName = construction.hierachyName.Replace("PrefabPreProcess - Server/", "");

                    if (!configData.Buildings.ContainsKey(hierachyName))
                    {
                        configData.Buildings.Add(hierachyName, new Dictionary<BuildingGrade.Enum, ConfigData.DecayData>
                            {
                                { BuildingGrade.Enum.Metal, configData.DefaultDecay },
                                { BuildingGrade.Enum.Stone, configData.DefaultDecay },
                                { BuildingGrade.Enum.TopTier, configData.DefaultDecay },
                                { BuildingGrade.Enum.Twigs, configData.DefaultDecay },
                                { BuildingGrade.Enum.Wood, configData.DefaultDecay }
                            });
                        hasChanged = true;
                    }
                }
            }
           
            foreach (ItemDefinition item in ItemManager.GetItemDefinitions())
            {
                ItemModDeployable deployable = item?.GetComponent<ItemModDeployable>();
                if (deployable == null)
                    continue;

                string fileName = deployable.entityPrefab.resourcePath;
                fileName = fileName.Substring(fileName.LastIndexOf("/") + 1);
                fileName = fileName.Substring(0, fileName.LastIndexOf("."));

                if (!configData.Entities.ContainsKey(fileName))
                {
                    configData.Entities.Add(fileName, configData.DefaultDecay);
                    hasChanged = true;
                }
            }

            if (hasChanged)
                SaveConfig();

            isInitialized = true;
            FindAllEntities();
        }

        private T[] GetAllPrefabs<T>()
        {
            
            Dictionary<uint, PrefabAttribute.AttributeCollection> prefabs = PrefabAttribute.server.prefabs;
            if (prefabs == null)
                return new T[0];

            List<T> results = new List<T>();
            foreach (PrefabAttribute.AttributeCollection prefab in prefabs.Values)
            {
                T[] arrayCache = prefab.Find<T>();
                if (arrayCache == null || !arrayCache.Any())
                    continue;

                results.AddRange(arrayCache);
            }

            return results.ToArray();
        }

        private void FindAllEntities()
        {
            PrintWarning("Finding all deekay-able entities");
            
            IEnumerable<BaseCombatEntity> entities = UnityEngine.Object.FindObjectsOfType<BaseCombatEntity>().Distinct();
            if (entities != null)
            {
                foreach (BaseCombatEntity entity in entities)
                {
                    if (entity == null || entity.IsDestroyed || !entity.IsValid())
                        continue;

                    if (entity is BuildingPrivlidge)
                        continue;

                    string prefabName = entity.ShortPrefabName;
                    if (string.IsNullOrEmpty(prefabName)) continue;

                    ConfigData.DecayData decayData;
                    if (!configData.Entities.TryGetValue(prefabName, out decayData))
                    {
                        if (!configData.Buildings.ContainsKey(prefabName))
                            continue;

                        BuildingGrade.Enum? grade = (entity as BuildingBlock)?.grade;
                        if (grade == null)
                            continue;

                        if (!configData.Buildings[prefabName].TryGetValue(grade.Value, out decayData))
                            continue;                        
                    }

                    if (decayData != null && decayData.IsEnabled && !dkEntities.ContainsKey(entity.net.ID))
                        dkEntities.Add(entity.net.ID, new DecayManager(entity, decayData));
                }
            }
            PrintWarning($"Initializing {dkEntities.Count} decay managers");
        }

        private void DecayTouch(Vector3 position)
        {
            List<BaseCombatEntity> list = Pool.GetList<BaseCombatEntity>();
            Vis.Entities<BaseCombatEntity>(position, configData.ActivityRadius, list, 2097408, QueryTriggerInteraction.Collide);
            for (int i = 0; i < list.Count; i++)
            {
                BaseCombatEntity entity = list[i];
                if (entity == null || entity.IsDestroyed || !entity.IsValid())
                    continue;

                DecayManager manager;
                if (dkEntities.TryGetValue(entity.net.ID, out manager))                
                    manager.ResetDecay();  
            }
            Pool.FreeList<BaseCombatEntity>(ref list);
        }        
        #endregion

        #region Decay Manager 
        private class DecayManager
        {
            public BaseCombatEntity Entity { get; private set; }

            private ConfigData.DecayData decayData;
            private bool isInPrivs = false;
            private bool isConstruction = false;
            private float decayRate;

            public DecayManager() { }
            public DecayManager(BaseCombatEntity entity, ConfigData.DecayData decayData)
            {
                this.Entity = entity;               
                this.decayData = decayData;
                isConstruction = entity is BuildingBlock;
                BeginDecay();
            }

            public void BeginDecay()
            {
                decayRate = IsInPrivilege(false) ? decayData.InsidePrivilege.DecayRate : decayData.OutsidePrivilege.DecayRate;

                if (decayRate == 0)
                    Entity.Invoke(BeginDecay, 300);
                else Entity.Invoke(SetInitialTimer, UnityEngine.Random.Range(1, 600));                
            }

            private void SetInitialTimer()
            {
                Entity.InvokeRepeating(RunDecay, decayRate, decayRate);
            }            

            private void RunDecay() => DealDamage();

            public bool DealDamage()
            {
                if (Entity == null || !Entity.IsValid())
                    return false;

                if (Entity.IsDestroyed)
                {
                    CancelInvokes();
                    ins.dkEntities.Remove(Entity.net.ID);
                    return false;
                }

                if (ins.configData.ZoneManager && ins.ZoneManager)
                {
                    object success = ins.ZoneManager.Call("EntityHasFlag", Entity, "nodecay");
                    if (success is bool && (bool)success)
                        return true;
                }               
                
                float decayAmount = IsInPrivilege(true) ? decayData.InsidePrivilege.DamageRate : decayData.OutsidePrivilege.DamageRate;
                if (decayAmount == 0)                
                    return false;

                if (isInPrivs && decayData.InsidePrivilege.UseUpkeep)
                {
                    if (Entity.GetBuildingPrivilege()?.GetProtectedMinutes() > 0)
                        return true;
                }

                float amount = Entity.MaxHealth() * (decayAmount / 100);
                if (Entity.health <= amount)
                {
                    CancelInvokes();
                    ins.dkEntities.Remove(Entity.net.ID);
                    Entity.Die();
                    return true;                   
                }
                else Entity.Hurt(amount, Rust.DamageType.Decay);

                return true;
            }            

            public bool IsInPrivilege(bool reset)
            {
                bool foundTC = false;

                if (isConstruction && ((Entity as BuildingBlock)?.GetBuilding()?.HasBuildingPrivileges() ?? false))
                    foundTC = true;
                else
                {
                    OBB obb = Entity.WorldSpaceBounds();
                    List<BuildingBlock> list = Pool.GetList<BuildingBlock>();
                    Vis.Entities<BuildingBlock>(obb.position, 16f + obb.extents.magnitude, list, 2097152, QueryTriggerInteraction.Collide);
                    for (int i = 0; i < list.Count; i++)
                    {
                        BuildingBlock item = list[i];

                        if (obb.Distance(item.WorldSpaceBounds()) <= 16f)
                        {
                            BuildingManager.Building building = item.GetBuilding();
                            if (building != null && building.HasBuildingPrivileges())
                            {
                                foundTC = true;
                                break;
                            }
                        }
                    }
                    Pool.FreeList<BuildingBlock>(ref list);
                }

                if (foundTC && !isInPrivs)
                {
                    isInPrivs = true;
                    if (reset)
                        ResetDecay();
                }
                else if (!foundTC && isInPrivs)
                {
                    isInPrivs = false;
                    if (reset)
                        ResetDecay();
                }
                return foundTC;
            } 

            public void ResetDecayOnDestroy()
            {
                decayRate = decayData.OutsidePrivilege.DecayRate;
                ResetDecay(true);
            }
            
            public void ResetDecay(bool addRandom = false)
            {
                if (Entity.IsInvoking(RunDecay))
                {
                    Entity.CancelInvoke(RunDecay);
                    Entity.InvokeRepeating(RunDecay, decayRate + (addRandom ? UnityEngine.Random.Range(1, 600) : 0), decayRate);
                }
            }

            public void CancelInvokes()
            {
                Entity.CancelInvoke(SetInitialTimer);
                Entity.CancelInvoke(BeginDecay);
                Entity.CancelInvoke(RunDecay);
            }

            public void UpdateDecayRates(ConfigData.DecayData decayData)
            {
                this.decayData = decayData;
                BeginDecay();
            }
        }
        #endregion        
       
        #region Commands
        [ConsoleCommand("dk.reset")]
        private void ccmdDKReset(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            configData.Buildings.Clear();
            configData.Entities.Clear();
            InitializeConfigData();
            SendReply(arg, "The config has been reset");
        }

        [ConsoleCommand("dk.rundecay")]
        private void ccmdDKRun(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            int decayCount = 0;
                      
            for (int i = dkEntities.Count - 1; i >= 0; i--)
            {
                var entry = dkEntities.ElementAt(i);
                if (entry.Value.DealDamage())
                {
                    entry.Value.ResetDecay();
                    ++decayCount;
                }
            }
            
            SendReply(arg, $"{decayCount} entities have been dealt decay damage!");
        }

        [ConsoleCommand("dk.setall")]
        private void ccmdDKSet(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.Args == null || arg.Args.Length != 4)
            {
                SendReply(arg, "dk.setall <twigs/wood/stone/metal/toptier> <inside/outside> <damage amount (0 - 100 : percent of maximum health)> <decay timer (seconds)> - Set damage and time for all building blocks of the specified tier");
                return;
            }

            object grade = ParseType<BuildingGrade.Enum>(arg.Args[0]);
            if (grade == null)
            {
                SendReply(arg, $"The value \"{arg.Args[0]}\" is not a valid building grade. Valid types are: {Enum.GetNames(typeof(BuildingGrade.Enum)).ToSentence()}");
                return;
            }

            object inside = arg.Args[1].ToLower() == "inside" ? true : arg.Args[1].ToLower() == "outside" ? false : false;
            if (inside == null)
            {
                SendReply(arg, $"You must specify whether these values are \"inside\" or \"outside\" of privilege");
                return;
            }

            float damageRate = 0;
            if (!float.TryParse(arg.Args[2], out damageRate))
            {
                SendReply(arg, $"You must specify a numerical damage rate. {arg.Args[2]} is invalid");
                return;
            }            

            float decayTime = 0;
            if (!float.TryParse(arg.Args[3], out decayTime))
            {
                SendReply(arg, $"You must specify a numerical decay time. {arg.Args[3]} is invalid");
                return;
            }

            for (int i = configData.Buildings.Count - 1; i >= 0; i--)
            {
                var entry = configData.Buildings.ElementAt(i);
                ConfigData.DecayData.Rates rates = (bool)inside ? entry.Value[(BuildingGrade.Enum)grade].InsidePrivilege : entry.Value[(BuildingGrade.Enum)grade].OutsidePrivilege;
                rates.DamageRate = damageRate;
                rates.DecayRate = decayTime;
            }            
            
            SaveConfig();

            foreach (DecayManager decayManager in dkEntities.Values.Where(x => x.Entity is BuildingBlock && (x.Entity as BuildingBlock).grade == (BuildingGrade.Enum)grade))
            {
                if (decayManager.Entity == null || !decayManager.Entity.IsValid() || !configData.Buildings.ContainsKey(decayManager.Entity.ShortPrefabName)) continue;

                ConfigData.DecayData decayData;
                if (!configData.Buildings[decayManager.Entity.ShortPrefabName].TryGetValue((decayManager.Entity as BuildingBlock).grade, out decayData)) continue;

                timer.In(UnityEngine.Random.Range(0.1f, 10f), () => decayManager.UpdateDecayRates(decayData));
            }

            SendReply(arg, $"All building blocks of the grade \"{(BuildingGrade.Enum)grade}\" that are {((bool)inside ? "inside privilege" : "outside privilege")} now have a damage rate of {damageRate}% with a decay time of {decayTime} seconds");
        }

        private object ParseType<T>(string type)
        {
            try
            {
                return (T)Enum.Parse(typeof(T), type, true);
            }
            catch
            {                
                return null;
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Activity - Player activity will reset nearby decay timers")]
            public bool MonitorActivity { get; set; }
            [JsonProperty(PropertyName = "Activity - Radius of effect")]
            public float ActivityRadius { get; set; }
            [JsonProperty(PropertyName = "Decay - 1. Default decay settings for all entities when plugin first loads")]
            public DecayData DefaultDecay { get; set; }
            [JsonProperty(PropertyName = "Decay - 2. Decay settings for building blocks")]
            public Dictionary<string, Dictionary<BuildingGrade.Enum, DecayData>> Buildings { get; set; }
            [JsonProperty(PropertyName = "Decay - 3. Decay settings for all other entities")]
            public Dictionary<string, DecayData> Entities { get; set; }
            [JsonProperty(PropertyName = "ZoneManager - Ignore decay-able entities inside of 'nodecay' zones")]
            public bool ZoneManager { get; set; }

            public class DecayData
            {
                [JsonProperty(PropertyName = "Inside of privilege")]
                public InternalRates InsidePrivilege { get; set; }
                [JsonProperty(PropertyName = "Outside of privilege")]
                public Rates OutsidePrivilege { get; set; }
                [JsonProperty(PropertyName = "Decay is enabled for this entity")]
                public bool IsEnabled { get; set; }

                public class Rates
                {
                    [JsonProperty(PropertyName = "Damage per decay tick (% of max health)")]
                    public float DamageRate { get; set; }
                    [JsonProperty(PropertyName = "Time between decay passes")]
                    public float DecayRate { get; set; }
                }

                public class InternalRates : Rates
                {
                    [JsonProperty(PropertyName = "Use upkeep to handle decay when the TC has resources")]
                    public bool UseUpkeep { get; set; }
                }
            }
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);            
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ActivityRadius = 40f,
                DefaultDecay = new ConfigData.DecayData
                {
                    InsidePrivilege = new ConfigData.DecayData.InternalRates
                    {
                        DamageRate = 5f,
                        DecayRate = 3600,
                        UseUpkeep = false
                    },
                    OutsidePrivilege = new ConfigData.DecayData.Rates
                    {
                        DamageRate = 20f,
                        DecayRate = 3600
                    },
                    IsEnabled = true
                },
                MonitorActivity = true,
                Buildings = new Dictionary<string, Dictionary<BuildingGrade.Enum, ConfigData.DecayData>>(),
                Entities = new Dictionary<string, ConfigData.DecayData>(),
                Version = Version,
                ZoneManager = true
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 2, 20))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }       
        #endregion               
    }
}


// --- End of file: Deekay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DynamicCupShare.cs ---
// --- Original Local Path: DynamicCupShare.cs ---

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using ProtoBuf;
using Facepunch;
using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("DynamicCupShare", "FuJiCuRa", "2.7.2", ResourceId = 20)]
    [Description("Dynamic sharing of cupboards/doors/boxes/lockers/turrets/quarries")]
    internal class DynamicCupShare : RustPlugin
    {
        [PluginReference]
        private Plugin Clans, Friends;

        private static DynamicCupShare Instance { get; set; }

        private bool Changed = false;
        private bool Initialized = false;
        private bool clansEnabled = false;
        private bool friendsEnabled = false;
        private bool friendsAPIEnabled = false;
        private bool pluginDisabled = false;
        private List<ulong> usdCnslInpt = new List<ulong>();
        private Hash<ulong, bool> adminAccessEnabled = new Hash<ulong, bool>();
        private Hash<ulong, List<uint>> adminCupboards = new Hash<ulong, List<uint>>();
        private Hash<ulong, List<uint>> adminTurrets = new Hash<ulong, List<uint>>();
        private StoredData playerPrefs = new StoredData();
        private Dictionary<string, List<uint>> playerCupboards = new Dictionary<string, List<uint>>();
        private Dictionary<string, List<uint>> playerTurrets = new Dictionary<string, List<uint>>();
        private List<object> pseudoAdminPerms = new List<object>();
        private List<string> pseudoPerms = new List<string>();

        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        private class StoredData
        {
            public Dictionary<ulong, PlayerInfo> PlayerInfo = new Dictionary<ulong, PlayerInfo>();
            public int saveStamp = 0;
            public string lastStorage = string.Empty;

            public StoredData()
            {
            }
        }

        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        internal class PlayerInfo
        {
            public bool CS;
            public bool DS;
            public bool BS;
            public bool TS;
            public bool LS;
            public bool QS;
            public bool AA;
            public bool CCS;
            public bool CDS;
            public bool CBS;
            public bool CLS;
            public bool CQS;
            public bool CTS;
            [JsonIgnore] [ProtoIgnore] public bool CanAutoAuth;
            [JsonIgnore] [ProtoIgnore] public bool HasClanShare;
            [JsonIgnore] [ProtoIgnore] public bool HasFriendShare;
            [JsonIgnore] [ProtoIgnore] public BuildingPrivilegeHandler BPH;

            public PlayerInfo()
            {
                BPH = null;
            }
        }

        private int UnixTimeStampUTC()
        {
            int unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (int)zuluTime.Subtract(unixEpoch).TotalSeconds;
            return unixTimeStamp;
        }

        private string shareCommand;
        private bool useFriendsApi;
        private bool useClans;
        private bool useProtostorageUserdata;
        private bool blockCupClearClanMembers;
        private bool blockCupAccessNotSameClan;
        private bool blockCupClearFriends;
        private bool allowLaddersIntoBlocked;
        private bool allowTwigIntoBlocked;
        private bool notifyPlayersBeingBlocked;
        private bool allowIcebergBuilding;
        private bool allowIcesheetBuilding;
        private bool allowIcelakeBuilding;
        private string permGetClanShares;
        private bool usePermGetClanShares;
        private string permGetFriendShares;
        private bool usePermGetFriendShares;
        private string permAutoAuth;
        private bool usePermAutoAuth;
        private bool clanTurretShareOverride;
        private bool includeFlameTurrets;
        private bool includeGunTraps;
        private bool includeSamSites;
        private bool samSiteShootEmptyVehicles;
        private bool enableCupSharing;
        private bool enableDoorSharing;
        private bool enableBoxSharing;
        private bool enableLockerSharing;
        private bool enableTurretSharing;
        private bool enableAutoAuth;
        private bool enableQuarrySharing;
        private bool enableQuarrySwitchCheck;
        private bool notifyAuthCupboard;
        private bool notifyAuthTurret;
        private bool CupShare;
        private bool DoorShare;
        private bool TurretShare;
        private bool BoxShare;
        private bool LockerShare;
        private bool QuarryShare;
        private bool AutoAuth;
        private bool ClanCupShare;
        private bool ClanDoorShare;
        private bool ClanBoxShare;
        private bool ClanLockerShare;
        private bool ClanTurretShare;
        private bool ClanQuarryShare;
        private bool toggleCupShare;
        private bool toggleDoorShare;
        private bool toggleTurretShare;
        private bool toggleBoxShare;
        private bool toggleLockerShare;
        private bool toggleQuarryShare;
        private bool toggleAutoAuth;
        private bool toggleClanCupShare;
        private bool toggleClanDoorShare;
        private bool toggleClanBoxShare;
        private bool toggleClanLockerShare;
        private bool toggleClanQuarryShare;
        private bool toggleClanTurretShare;
        private bool adminsRemainCupAuthed;
        private bool adminsRemainTurretAuthed;
        private bool enableAdminmodeAtLogin;
        private int cupboardAuthMaxUsers;
        private string pluginPrefix;
        private string prefixColor;
        private string prefixFormat;
        private string colorTextMsg;
        private string colorCmdUsage;
        private string colorON;
        private string colorOFF;

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string, object> data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        private void LoadVariables()
        {
            shareCommand = Convert.ToString(GetConfig("Command", "shareCommand", "share"));
            useFriendsApi = Convert.ToBoolean(GetConfig("Options", "useFriendsApi", true));
            useClans = Convert.ToBoolean(GetConfig("Options", "useClans", true));
            pseudoAdminPerms = (List<object>)GetConfig("Options", "pseudoAdminPerms",
                new List<object> { "fauxadmin.allowed", "fakeadmin.allow" });
            useProtostorageUserdata = Convert.ToBoolean(GetConfig("Storage", "useProtostorageUserdata", false));
            permGetClanShares =
                Convert.ToString(GetConfig("Permission", "permGetClanShares", "dynamiccupshare.getclanshares"));
            usePermGetClanShares = Convert.ToBoolean(GetConfig("Permission", "usePermGetClanShares", false));
            permGetFriendShares =
                Convert.ToString(GetConfig("Permission", "permGetFriendShares", "dynamiccupshare.getfriendshares"));
            usePermGetFriendShares = Convert.ToBoolean(GetConfig("Permission", "usePermGetFriendShares", false));
            permAutoAuth = Convert.ToString(GetConfig("Permission", "permGetShares", "dynamiccupshare.autoauth"));
            usePermAutoAuth = Convert.ToBoolean(GetConfig("Permission", "usePermAutoAuth", false));
            clanTurretShareOverride = Convert.ToBoolean(GetConfig("Security", "clanTurretShareOverride", false));
            blockCupClearClanMembers = Convert.ToBoolean(GetConfig("Security", "blockCupClearClanMembers", true));
            blockCupAccessNotSameClan = Convert.ToBoolean(GetConfig("Security", "blockCupAccessNotSameClan", false));
            blockCupClearFriends = Convert.ToBoolean(GetConfig("Security", "blockCupClearFriends", true));
            allowLaddersIntoBlocked = Convert.ToBoolean(GetConfig("Blocker", "allowLaddersIntoBlocked", true));
            allowTwigIntoBlocked = Convert.ToBoolean(GetConfig("Blocker", "allowTwigIntoBlocked", false));
            notifyPlayersBeingBlocked = Convert.ToBoolean(GetConfig("Blocker", "notifyPlayersBeingBlocked", true));
            allowIcebergBuilding = Convert.ToBoolean(GetConfig("Blocker", "allowIcebergBuilding", false));
            allowIcesheetBuilding = Convert.ToBoolean(GetConfig("Blocker", "allowIcesheetBuilding", true));
            allowIcelakeBuilding = Convert.ToBoolean(GetConfig("Blocker", "allowIcelakeBuilding", true));
            notifyAuthCupboard = Convert.ToBoolean(GetConfig("Notification", "notifyAuthCupboard", true));
            notifyAuthTurret = Convert.ToBoolean(GetConfig("Notification", "notifyAuthTurret", true));
            CupShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "CupShare", false));
            DoorShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "DoorShare", false));
            TurretShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "TurretShare", false));
            BoxShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "BoxShare", false));
            LockerShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "LockerShare", false));
            QuarryShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "QuarryShare", false));
            AutoAuth = Convert.ToBoolean(GetConfig("PlayerDefaults", "AutoAuth", true));
            ClanCupShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "ClanCupShare", true));
            ClanDoorShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "ClanDoorShare", true));
            ClanBoxShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "ClanBoxShare", true));
            ClanLockerShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "ClanLockerShare", true));
            ClanQuarryShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "ClanQuarryShare", true));
            ClanTurretShare = Convert.ToBoolean(GetConfig("PlayerDefaults", "ClanTurretShare", true));
            toggleCupShare = Convert.ToBoolean(GetConfig("PlayerToggles", "CupShare", true));
            toggleDoorShare = Convert.ToBoolean(GetConfig("PlayerToggles", "DoorShare", true));
            toggleTurretShare = Convert.ToBoolean(GetConfig("PlayerToggles", "TurretShare", true));
            toggleBoxShare = Convert.ToBoolean(GetConfig("PlayerToggles", "BoxShare", true));
            toggleLockerShare = Convert.ToBoolean(GetConfig("PlayerToggles", "LockerShare", true));
            toggleQuarryShare = Convert.ToBoolean(GetConfig("PlayerToggles", "QuarryShare", true));
            toggleAutoAuth = Convert.ToBoolean(GetConfig("PlayerToggles", "AutoAuth", true));
            toggleClanCupShare = Convert.ToBoolean(GetConfig("PlayerToggles", "ClanCupShare", true));
            toggleClanDoorShare = Convert.ToBoolean(GetConfig("PlayerToggles", "ClanDoorShare", true));
            toggleClanBoxShare = Convert.ToBoolean(GetConfig("PlayerToggles", "ClanBoxShare", true));
            toggleClanLockerShare = Convert.ToBoolean(GetConfig("PlayerToggles", "ClanLockerShare", true));
            toggleClanQuarryShare = Convert.ToBoolean(GetConfig("PlayerToggles", "ClanQuarryShare", true));
            toggleClanTurretShare = Convert.ToBoolean(GetConfig("PlayerToggles", "ClanTurretShare", true));
            enableCupSharing = Convert.ToBoolean(GetConfig("Functions", "enableCupSharing", true));
            enableDoorSharing = Convert.ToBoolean(GetConfig("Functions", "enableDoorSharing", true));
            enableBoxSharing = Convert.ToBoolean(GetConfig("Functions", "enableBoxSharing", true));
            enableLockerSharing = Convert.ToBoolean(GetConfig("Functions", "enableLockerSharing", true));
            enableQuarrySharing = Convert.ToBoolean(GetConfig("Functions", "enableQuarrySharing", false));
            enableQuarrySwitchCheck = Convert.ToBoolean(GetConfig("Functions", "enableQuarrySwitchCheck", false));
            enableTurretSharing = Convert.ToBoolean(GetConfig("Functions", "enableTurretSharing", true));
            enableAutoAuth = Convert.ToBoolean(GetConfig("Functions", "enableAutoAuth", true));
            includeFlameTurrets = Convert.ToBoolean(GetConfig("Functions", "includeFlameTurrets", true));
            includeGunTraps = Convert.ToBoolean(GetConfig("Functions", "includeGunTraps", true));
            includeSamSites = Convert.ToBoolean(GetConfig("Functions", "includeSamSites", true));
            cupboardAuthMaxUsers = Convert.ToInt32(GetConfig("Functions", "cupboardAuthMaxUsers (0 is disabled)", 0));
            samSiteShootEmptyVehicles = Convert.ToBoolean(GetConfig("Functions", "samSiteShootEmptyVehicles", false));
            adminsRemainCupAuthed = Convert.ToBoolean(GetConfig("Adminmode", "adminsRemainCupAuthed", false));
            adminsRemainTurretAuthed = Convert.ToBoolean(GetConfig("Adminmode", "adminsRemainTurretAuthed", false));
            enableAdminmodeAtLogin = Convert.ToBoolean(GetConfig("Adminmode", "enableAdminmodeAtLogin", false));
            pluginPrefix = Convert.ToString(GetConfig("Formatting", "pluginPrefix", "DynaShare"));
            prefixColor = Convert.ToString(GetConfig("Formatting", "prefixColor", "#ffa500"));
            prefixFormat = Convert.ToString(GetConfig("Formatting", "prefixFormat", "<color={0}>{1}</color>: "));
            colorTextMsg = Convert.ToString(GetConfig("Formatting", "colorTextMsg", "#ffffff"));
            colorCmdUsage = Convert.ToString(GetConfig("Formatting", "colorCmdUsage", "#ffff00"));
            colorON = Convert.ToString(GetConfig("Formatting", "colorON", "#008000"));
            colorOFF = Convert.ToString(GetConfig("Formatting", "colorOFF", "#c0c0c0"));
            bool configremoval = false;
            if ((Config.Get("Security") as Dictionary<string, object>).ContainsKey("blockCupAuthClanMembers"))
            {
                (Config.Get("Security") as Dictionary<string, object>).Remove("blockCupAuthClanMembers");
                (Config.Get("Security") as Dictionary<string, object>).Remove("blockCupAuthFriends");
                configremoval = true;
            }

            if ((Config.Get("Functions") as Dictionary<string, object>).ContainsKey("addAdminsToCupboards"))
            {
                (Config.Get("Functions") as Dictionary<string, object>).Remove("addAdminsToCupboards");
                configremoval = true;
            }

            if ((Config.Get("Options") as Dictionary<string, object>).ContainsKey("pluginDelayOnFreshStart"))
            {
                (Config.Get("Options") as Dictionary<string, object>).Remove("pluginDelayOnFreshStart");
                configremoval = true;
            }

            if ((Config.Get("Blocker") as Dictionary<string, object>).ContainsKey("excludeAdminsFromBlocking"))
            {
                (Config.Get("Blocker") as Dictionary<string, object>).Remove("excludeAdminsFromBlocking");
                configremoval = true;
            }

            if (Config.Get("Blocking") != null)
            {
                Config.Remove("Blocking");
                configremoval = true;
            }

            if ((Config.Get("Options") as Dictionary<string, object>).ContainsKey("useFriendsIO"))
            {
                (Config.Get("Options") as Dictionary<string, object>).Remove("useFriendsIO");
                configremoval = true;
            }

            if (!Changed && !configremoval) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"ShareEnabled", "Cupboard sharing for friends enabled"},
                    {"ShareDisabled", "Cupboard sharing for friends disabled"},
                    {"CodesEnabled", "Door sharing for friends enabled"},
                    {"CodesDisabled", "Door sharing for friends disabled"},
                    {"BoxesEnabled", "Box sharing for friends enabled"},
                    {"BoxesDisabled", "Box sharing for friends disabled"},
                    {"LockersEnabled", "Locker sharing for friends enabled"},
                    {"LockersDisabled", "Locker sharing for friends disabled"},
                    {"QuarriesEnabled", "Quarry sharing for friends enabled"},
                    {"QuarriesDisabled", "Quarry sharing for friends disabled"},
                    {"TurretEnabled", "Turret sharing for friends enabled"},
                    {"TurretDisabled", "Turret sharing for friends disabled"},
                    {"ClanShareEnabled", "Cupboard sharing for clan enabled"},
                    {"ClanShareDisabled", "Cupboard sharing for clan disabled"},
                    {"ClanCodesEnabled", "Door sharing for clan enabled"},
                    {"ClanCodesDisabled", "Door sharing for clan disabled"},
                    {"ClanBoxesEnabled", "Box sharing for clan enabled"},
                    {"ClanBoxesDisabled", "Box sharing for clan disabled"},
                    {"ClanLockersEnabled", "Locker sharing for clan enabled"},
                    {"ClanLockersDisabled", "Locker sharing for clan disabled"},
                    {"ClanQuarriesEnabled", "Quarry sharing for clan enabled"},
                    {"ClanQuarriesDisabled", "Quarry sharing for clan disabled"},
                    {"ClanTurretEnabled", "Turret sharing for clan enabled"},
                    {"ClanTurretDisabled", "Turret sharing for clan disabled"},
                    {"AdminAccessEnabled", "Admin access mode enabled"},
                    {"AdminAccessDisabled", "Admin access mode disabled"},
                    {"AutoAuthEnabled", "Cupboard automatic authorization enabled"},
                    {"AutoAuthDisabled", "Cupboard automatic authorization disabled"},
                    {"CupAuth", "Cupboard authorized"}, {"TurretAuth", "Turret authorized"},
                    {"NoAccess", "You are not granted for this feature"},
                    {"NotEnabled", "The specific function '{0}' is currently not active"},
                    {"SwitchBlocked", "The admin blocked the '{0}' switch"},
                    {"SharedAll", "Enabled all available sharing functions"},
                    {"NotSupported", "The specific function '{0}' is not available"},
                    {"NotFound", "The player '{0}' was not found."}, {"NeedArgs", "Please define a target playername."},
                    {"CupAuthDisabledOwner", "Authorization denied. '{0}' has cup sharing deactivated"},
                    {"CupAuthDisabledSelf", "Authorization denied. You need to activate cup sharing"},
                    {"CupAuthClearBlocked", "Clear authorized list denied"},
                    {"CupAuthNotSameClanBlocked", "Authorization denied"},
                    {"CupAuthMaxUsers", "This cupboard already has the maximum amount of authorized players ({0})"},
                    {"BlockBuildIntoBlocked", "You can't build or place into blocked area!"},
                    {"BlockBuildOnIceBergs", "You can't build or place on icebergs"},
                    {"BlockBuildOnIceSheets", "You can't build or place on icesheets"},
                    {"BlockBuildOnIceLakes", "You can't build or place on icelakes"},
                    {"DoorClanNotShared", "Clan member '{0}' has door sharing deactivated"},
                    {"DoorClanNotSharedSelf", "Your clan door sharing is deactivated"},
                    {"BoxClanNotShared", "Clan member '{0}' has box sharing deactivated"},
                    {"BoxClanNotSharedSelf", "Your clan box sharing is deactivated"},
                    {"LockerClanNotShared", "Clan member '{0}' has locker sharing deactivated"},
                    {"LockerClanNotSharedSelf", "Your clan locker sharing is deactivated"},
                    {"CupClanNotShared", "Authorization denied. Clan member '{0}' has cup sharing deactivated"},
                    {"QuarryNoLootAccess", "You are not allowed access this storage."},
                    {"QuarryNoStartStop", "You are not allowed use this machine."},
                    {"AccessRights", "You can access these shares:"},
                    {"CommandPlgDisabled", "Plugin disabled! Please contact your server admin"},
                    {"CommandUsage", "Command usage:"},
                    {"CommandToggle", "All switches toggle their setting (on<>off)"},
                    {"CommandFriendCup", "Friends Cupboard:"}, {"CommandFriendDoor", "Friends Door:"},
                    {"CommandFriendBox", "Friends Box:"}, {"CommandFriendLocker", "Friends Locker:"},
                    {"CommandFriendQuarry", "Friends Quarry:"}, {"CommandFriendTurret", "Friends Turret:"},
                    {"CommandAutoAuth", "Cup/Turret authorization:"}, {"CommandClanCup", "Clan Cupboard:"},
                    {"CommandClanDoor", "Clan Door:"}, {"CommandClanBox", "Clan Box:"},
                    {"CommandClanLocker", "Clan Locker:"}, {"CommandClanQuarry", "Clan Quarry:"},
                    {"CommandClanTurret", "Clan Members not targeted by Turrets:"},
                    {"CommandClanTurretM", "Clan Turret:"}, {"CommandAdminAccess", "Admin access status"},
                    {"HelpCups", "Get the description for sharing of cupboards"},
                    {"HelpDoors", "Get the description for sharing of doors"},
                    {"HelpBoxes", "Get the description for sharing of boxes"},
                    {"HelpLockers", "Get the description for sharing of lockers"},
                    {"HelpQuarries", "Get the description for sharing of quarries"},
                    {"HelpTurrets", "Get the description for sharing of turrets"},
                    {"HelpAutoAuth", "Get the description for automatic authorization"},
                    {"HelpNotAvailable", "This help topics does'nt exist"},
                    {
                        "DescriptionCups",
                        "By enabling cup sharing for friends/members, then those players get build rights in every cupboard range, which you own and where yourself are authed. It does not share in case you are not selfauthed."
                    },
                    {
                        "DescriptionDoors",
                        "By enabling door sharing for friends/members, then those players can open each of your locked doors; Without any direct lock access."
                    },
                    {
                        "DescriptionBoxes",
                        "By enabling box sharing for friends/members, then those players can open each of your locked boxes; Without any direct lock access."
                    },
                    {
                        "DescriptionLockers",
                        "By enabling locker sharing for friends/members, then those players can open each of your lockers; Without any direct lock access."
                    },
                    {
                        "DescriptionQuarries",
                        "By enabling quarry sharing for friends/members, then those players can open each of your fuelstorages and hopperoutputs; Other players will be blocked."
                    },
                    {
                        "DescriptionTurrets",
                        "By enabling turret sharing for friends/members, then those players will not be targeted by your turrets/traps."
                    },
                    {
                        "DescriptionAutoAuth",
                        "By enabling automatic authorization for cups and turrets, you can skip the selfauth steps after placement by this automation."
                    },
                }, this);
        }

        private void Init()
        {
            StateDisabled();
            ClansDisabled();
            LoadVariables();
            LoadDefaultMessages();
            cmd.AddChatCommand(shareCommand, this, "ShareCommand");
            cmd.AddConsoleCommand(shareCommand, this, "cShareCommand");
            permission.RegisterPermission(permGetClanShares, this);
            permission.RegisterPermission(permGetFriendShares, this);
            permission.RegisterPermission(permAutoAuth, this);
            List<string> filter = RustExtension.Filter.ToList();
            filter.Add("Calling hook CanBeTargeted resulted in a conflict");
            RustExtension.Filter = filter.ToArray();
            LdPlyrDt();
        }

        private void LdPlyrDt()
        {
            StoredData protoStorage = new StoredData();
            if (ProtoStorage.Exists(new string[] { Title }))
                protoStorage = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();

            StoredData jsonStorage = new StoredData();
            if (Interface.GetMod().DataFileSystem.ExistsDatafile(Title))
                jsonStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);

            bool lastwasProto = protoStorage.lastStorage == "proto" && protoStorage.saveStamp > jsonStorage.saveStamp;
            if (useProtostorageUserdata)
            {
                if (lastwasProto)
                {
                    playerPrefs = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();
                    return;
                }
                else
                {
                    if (Interface.GetMod().DataFileSystem.ExistsDatafile(Title))
                        playerPrefs = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                }
            }
            else
            {
                if (!lastwasProto)
                {
                    playerPrefs = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title);
                    return;
                }
                else
                {
                    if (ProtoStorage.Exists(new string[] { Title }))
                        playerPrefs = ProtoStorage.Load<StoredData>(new string[] { Title }) ?? new StoredData();
                }
            }
        }

        private void SaveData()
        {
            if (pluginDisabled)
                return;

            playerPrefs.saveStamp = UnixTimeStampUTC();
            playerPrefs.lastStorage = useProtostorageUserdata ? "proto" : "json";

            if (useProtostorageUserdata)
                ProtoStorage.Save<StoredData>(playerPrefs, new string[] { Title });
            else Interface.Oxide.DataFileSystem.WriteObject(Title, playerPrefs);
        }

        private void Loaded()
        {
            Instance = this;
        }

        private void OnServerInitialized()
        {
            if (Initialized)
                return;

            foreach (string pseudoPerm in pseudoAdminPerms.ConvertAll(obj => Convert.ToString(obj)).ToList())
            {
                if (permission.PermissionExists(pseudoPerm))
                    pseudoPerms.Add(pseudoPerm.ToLower());
            }
            Initialize();
        }

        private void Initialize()
        {
            if (Clans && useClans)
            {
                clansEnabled = true;
                Puts("Plugin 'Clans' found - Clan support activated");
                ClansEnabled();
            }

            if (!Clans && useClans) PrintWarning("Plugin 'Clans' not found - Clan support not active");
            if (useFriendsApi)
                if (Friends && useFriendsApi && !friendsEnabled)
                {
                    friendsEnabled = true;
                    friendsAPIEnabled = true;
                    Puts("Plugin Friends found - Friends support activated");
                }

            if (useFriendsApi && !friendsEnabled) PrintWarning("No Friend Plugin found - Friend support not active");
            if (!clansEnabled && !friendsEnabled)
            {
                PrintWarning("No supported requirements found - Plugin unload!");
                Interface.Oxide.UnloadPlugin(Title);
                return;
            }

            adminAccessEnabled = new Hash<ulong, bool>();
            adminCupboards = new Hash<ulong, List<uint>>();
            adminTurrets = new Hash<ulong, List<uint>>();
            playerCupboards = new Dictionary<string, List<uint>>();
            playerTurrets = new Dictionary<string, List<uint>>();

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
                SetPlayer(player);

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList.ToList())
                SetPlayer(player);

            List<BaseEntity> plyrObjcts = BaseNetworkable.serverEntities.Where(p => (p is BuildingPrivlidge || p is AutoTurret || p is GunTrap || p is FlameTurret || p is BaseLock)).Cast<BaseEntity>().ToList();
            foreach (BaseEntity plyrObjct in plyrObjcts)
            {
                if (plyrObjct is CodeLock && plyrObjct.GetParentEntity() && !playerPrefs.PlayerInfo.ContainsKey(plyrObjct.GetParentEntity().OwnerID))
                {
                    AddPlayerData(plyrObjct.GetParentEntity().OwnerID);
                    continue;
                }

                if (plyrObjct is CodeLock || plyrObjct.OwnerID == 0uL) continue;
                string owner = plyrObjct.OwnerID.ToString();
                if (plyrObjct is BuildingPrivlidge)
                {
                    List<uint> player;
                    if (!playerCupboards.TryGetValue(owner, out player)) playerCupboards.Add(owner, new List<uint>());
                    playerCupboards[owner].Add(plyrObjct.net.ID);
                    if (!playerPrefs.PlayerInfo.ContainsKey(plyrObjct.OwnerID)) AddPlayerData(plyrObjct.OwnerID);
                }
                else if (plyrObjct is AutoTurret)
                {
                    List<uint> player;
                    if (!playerTurrets.TryGetValue(owner, out player)) playerTurrets.Add(owner, new List<uint>());
                    playerTurrets[owner].Add(plyrObjct.net.ID);
                    if (!playerPrefs.PlayerInfo.ContainsKey(plyrObjct.OwnerID)) AddPlayerData(plyrObjct.OwnerID);
                }
                else if (!playerPrefs.PlayerInfo.ContainsKey(plyrObjct.OwnerID))
                {
                    AddPlayerData(plyrObjct.OwnerID);
                }
            }

            if (enableQuarrySharing && enableQuarrySwitchCheck)
            {
                foreach (MiningQuarry quarry in BaseNetworkable.serverEntities.Where(p => p is MiningQuarry && (p as BaseEntity).OwnerID != 0uL).Cast<MiningQuarry>().ToList())
                    quarry.engineSwitchPrefab.instance.gameObject.transform.GetOrAddComponent<QuarryHandler>();
            }
            StateEnabled();
            Initialized = true;
        }

        private bool GetAdmin(BasePlayer player)
        {
            return player.IsAdmin || IsPsdAdmn(player.UserIDString);
        }

        private bool AccessOn(ulong id)
        {
            bool obj;
            return adminAccessEnabled.TryGetValue(id, out obj) && (bool)obj == true;
        }

        private PlayerInfo SetPlayer(BasePlayer player)
        {
            if (player == null || player.userID < 76561197960265729uL)
                return null;

            if (GetAdmin(player))
            {
                adminAccessEnabled[player.userID] = enableAdminmodeAtLogin;
                adminCupboards[player.userID] = new List<uint>();
                adminTurrets[player.userID] = new List<uint>();
            }

            List<uint> entries;

            if (!playerCupboards.TryGetValue(player.UserIDString, out entries))
                playerCupboards.Add(player.UserIDString, new List<uint>());

            if (!playerTurrets.TryGetValue(player.UserIDString, out entries))
                playerTurrets.Add(player.UserIDString, new List<uint>());

            PlayerInfo p;
            if (!playerPrefs.PlayerInfo.TryGetValue(player.userID, out p))
            {
                PlayerInfo info = new PlayerInfo();
                info.CS = CupShare;
                info.DS = DoorShare;
                info.TS = TurretShare;
                info.BS = BoxShare;
                info.LS = LockerShare;
                info.QS = QuarryShare;
                info.AA = AutoAuth;
                info.CCS = ClanCupShare;
                info.CDS = ClanDoorShare;
                info.CBS = ClanBoxShare;
                info.CLS = ClanLockerShare;
                info.CQS = ClanQuarryShare;
                info.CTS = ClanTurretShare;
                info.HasClanShare = !usePermGetClanShares || usePermGetClanShares && permission.UserHasPermission(player.UserIDString, permGetClanShares);
                info.HasFriendShare = !usePermGetFriendShares || usePermGetFriendShares && permission.UserHasPermission(player.UserIDString, permGetFriendShares);
                info.CanAutoAuth = !usePermAutoAuth || usePermAutoAuth && permission.UserHasPermission(player.UserIDString, permAutoAuth);
                playerPrefs.PlayerInfo.Add(player.userID, info);
                return info;
            }
            else
            {
                p.HasClanShare = !usePermGetClanShares || usePermGetClanShares && permission.UserHasPermission(player.UserIDString, permGetClanShares);
                p.HasFriendShare = !usePermGetFriendShares || usePermGetFriendShares && permission.UserHasPermission(player.UserIDString, permGetFriendShares);
                p.CanAutoAuth = !usePermAutoAuth || usePermAutoAuth && permission.UserHasPermission(player.UserIDString, permAutoAuth);
            }

            return p;
        }

        private bool IsPsdAdmn(string id)
        {
            foreach (string perm in pseudoPerms)
                if (permission.UserHasPermission(id, perm))
                    return true;
            return false;
        }

        private void OnUserPermissionGranted(string id, string perm)
        {
            if (pseudoPerms.Contains(perm.ToLower()))
            {
                adminAccessEnabled[Convert.ToUInt64(id)] = enableAdminmodeAtLogin;
                adminCupboards[Convert.ToUInt64(id)] = new List<uint>();
                adminTurrets[Convert.ToUInt64(id)] = new List<uint>();
            }
        }

        private PlayerInfo AddPlayerData(ulong userID)
        {
            PlayerInfo info = new PlayerInfo();
            info.CS = CupShare;
            info.DS = DoorShare;
            info.TS = TurretShare;
            info.BS = BoxShare;
            info.LS = LockerShare;
            info.QS = QuarryShare;
            info.AA = AutoAuth;
            info.CCS = ClanCupShare;
            info.CDS = ClanDoorShare;
            info.CBS = ClanBoxShare;
            info.CLS = ClanLockerShare;
            info.CQS = ClanQuarryShare;
            info.CTS = ClanTurretShare;
            info.HasClanShare = !usePermGetClanShares || usePermGetClanShares &&
                            permission.UserHasPermission(userID.ToString(), permGetClanShares);
            info.HasFriendShare = !usePermGetFriendShares || usePermGetFriendShares &&
                             permission.UserHasPermission(userID.ToString(), permGetFriendShares);
            info.CanAutoAuth = !usePermAutoAuth ||
                           usePermAutoAuth && permission.UserHasPermission(userID.ToString(), permAutoAuth);
            playerPrefs.PlayerInfo.Add(userID, info);
            return info;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!GetAdmin(player)) return;
            adminAccessEnabled.Remove(player.userID);
            List<uint> cups;
            if (adminCupboards.TryGetValue(player.userID, out cups))
            {
                foreach (uint cup in cups)
                {
                    BuildingPrivlidge ent = (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(cup);
                    if (ent)
                    {
                        ent.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == player.userID);
                        ent.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    }
                }

                adminCupboards.Remove(player.userID);
            }

            List<uint> turrets;
            if (adminTurrets.TryGetValue(player.userID, out turrets))
            {
                foreach (uint turret in turrets)
                {
                    AutoTurret ent = (AutoTurret)BaseNetworkable.serverEntities.Find(turret);
                    if (ent)
                    {
                        ent.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == player.userID);
                        ent.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    }
                }

                adminTurrets.Remove(player.userID);
            }
        }

        private void Unload()
        {
            SaveData();
            bool isOn = !Interface.Oxide.IsShuttingDown;
            foreach (KeyValuePair<ulong, List<uint>> admin in adminCupboards.ToList())
                foreach (uint cup in adminCupboards[admin.Key].ToList())
                {
                    BuildingPrivlidge p = (BuildingPrivlidge)BaseNetworkable.serverEntities.Find(cup);
                    if (p)
                    {
                        p.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == admin.Key);
                        if (isOn) p.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    }
                }

            foreach (KeyValuePair<ulong, List<uint>> admin in adminTurrets.ToList())
                foreach (uint turret in adminTurrets[admin.Key].ToList())
                {
                    AutoTurret t = (AutoTurret)BaseNetworkable.serverEntities.Find(turret);
                    if (t)
                    {
                        t.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == admin.Key);
                        if (isOn) t.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    }
                }

            if (!isOn) return;
            List<BuildingPrivilegeHandler> bphandlers = UnityEngine.Object.FindObjectsOfType<BuildingPrivilegeHandler>().ToList();
            if (bphandlers.Count > 0)
                foreach (BuildingPrivilegeHandler handler in bphandlers)
                    UnityEngine.Object.Destroy(handler);
            List<QuarryHandler> qhandlers = UnityEngine.Object.FindObjectsOfType<QuarryHandler>().ToList();
            if (qhandlers.Count > 0)
                foreach (QuarryHandler handler in qhandlers)
                    UnityEngine.Object.Destroy(handler);
            List<string> filter = RustExtension.Filter.ToList();
            filter.Remove("Calling hook CanBeTargeted resulted in a conflict");
            RustExtension.Filter = filter.ToArray();
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void OnPluginUnloaded(Plugin name)
        {
            if (!Initialized || name.Name == Title) return;
            if (name.Name == "Clans" && useClans && clansEnabled)
            {
                clansEnabled = false;
                Puts("Clans support disabled");
                ClansDisabled();
            }

            if (name.Name == "Friends" && useFriendsApi && friendsAPIEnabled)
            {
                friendsAPIEnabled = false;
                friendsEnabled = false;
                Puts("Friends support disabled");
            }

            if (!clansEnabled && !friendsEnabled && !pluginDisabled)
            {
                pluginDisabled = true;
                PrintWarning("Sharing functions disabled - Plugin paused!");
                StateDisabled();
            }
        }

        private void OnPluginLoaded(Plugin name)
        {
            if (!Initialized || name.Name == Title) return;
            if (name.Name == "Clans" && useClans && !clansEnabled)
            {
                clansEnabled = true;
                Puts("Clans support enabled");
                ClansEnabled();
            }

            if (name.Name == "Friends" && useFriendsApi && !friendsAPIEnabled)
            {
                friendsAPIEnabled = true;
                friendsEnabled = true;
                Puts("Friends support enabled");
            }

            if ((clansEnabled || friendsEnabled) && pluginDisabled)
            {
                pluginDisabled = false;
                Puts("Sharing functions re-enabled - Plugin unpaused!");
                StateEnabled();
            }
        }

        private object CanBuild(Planner plan, Construction prefab, Construction.Target target)
        {
            if (plan == null || prefab == null ||
                allowLaddersIntoBlocked && prefab.hierachyName.Contains("ladder.wooden.wall") ||
                allowTwigIntoBlocked && prefab.hierachyName.Contains("floor")) return null;
            BasePlayer player = plan.GetOwnerPlayer();
            Construction.Placement placement = new Construction.Placement();
            if (target.socket != null)
            {
                List<Socket_Base> list = Pool.GetList<Socket_Base>();
                prefab.FindMaleSockets(target, list);
                foreach (Socket_Base current in list)
                    if (!(target.entity != null) || !(target.socket != null) ||
                        !target.entity.IsOccupied(target.socket))
                    {
                        placement = current.DoPlacement(target);
                        if (placement != null) break;
                    }

                Pool.FreeList<Socket_Base>(ref list);
                if (placement == null) return null;
            }
            else
            {
                placement.position = target.position;
                placement.rotation = Quaternion.Euler(target.rotation);
                if (placement.rotation == Quaternion.identity)
                    placement.rotation = Quaternion.Euler(0, plan.GetOwnerPlayer().transform.rotation.y, 0);
            }

            RaycastHit hit = default(RaycastHit);
            if ((!allowIcebergBuilding || !allowIcesheetBuilding || !allowIcelakeBuilding) &&
                Physics.Raycast(placement.position, Vector3.down, out hit, placement.position.y, 65536))
            {
                if (!allowIcebergBuilding && hit.collider.name.ToLower().StartsWith("iceberg"))
                {
                    if (notifyPlayersBeingBlocked)
                        PrintToChat(player,
                            $"<color={colorTextMsg}>" +
                            string.Format(lang.GetMessage("BlockBuildOnIceBergs", this, player.UserIDString)) +
                            $"</color>");
                    return false;
                }

                if (!allowIcelakeBuilding && hit.collider.name.ToLower().StartsWith("ice_lake"))
                {
                    if (notifyPlayersBeingBlocked)
                        PrintToChat(player,
                            $"<color={colorTextMsg}>" +
                            string.Format(lang.GetMessage("BlockBuildOnIceLakes", this, player.UserIDString)) +
                            $"</color>");
                    return false;
                }

                if (!allowIcesheetBuilding && hit.collider.name.ToLower().StartsWith("ice_sheet"))
                {
                    if (notifyPlayersBeingBlocked)
                        PrintToChat(player,
                            $"<color={colorTextMsg}>" +
                            string.Format(lang.GetMessage("BlockBuildOnIceSheets", this, player.UserIDString)) +
                            $"</color>");
                    return false;
                }
            }

            if (!allowLaddersIntoBlocked || !allowTwigIntoBlocked)
            {
                BuildingPrivlidge cup = player.GetBuildingPrivilege(new OBB(placement.position, placement.rotation, prefab.bounds));
                if (cup == null)
                    return null;

                if (!cup.IsAuthed(player))
                {
                    if (notifyPlayersBeingBlocked)
                        PrintToChat(player, $"<color={colorTextMsg}>" + string.Format(lang.GetMessage("BlockBuildIntoBlocked", this, player.UserIDString)) + $"</color>");
                    return false;
                }
            }

            return null;
        }

        private void OnFriendAdded(string playerId, string friendId, bool isCup = true, bool isTurret = true)
        {
            if (playerId == null || playerId == string.Empty || friendId == null || friendId == string.Empty)
                return;

            ServerMgr.Instance.StartCoroutine(CoFrndAddd(playerId, friendId, isCup, isTurret));
        }

        private IEnumerator CoFrndAddd(string playerId, string friendId, bool isCup, bool isTurret)
        {
            ulong friendID = Convert.ToUInt64(friendId);

            IPlayer friend = covalence.Players.FindPlayerById(friendId);
            if (friend == null)
                yield break;

            List<uint> playercups;
            if (isCup && playerCupboards.TryGetValue(playerId, out playercups))
            {
                foreach (uint cup in playercups.ToList())
                {
                    BuildingPrivlidge priv = BaseNetworkable.serverEntities.Find(cup) as BuildingPrivlidge;
                    if (priv)
                    {
                        if (priv.AnyAuthed() &&
                            priv.authorizedPlayers.Any((PlayerNameID x) => x.userid == priv.OwnerID) &&
                            !priv.authorizedPlayers.Any((PlayerNameID x) => x.userid == friendID))
                        {
                            priv.authorizedPlayers.Add(new PlayerNameID { userid = friendID, username = friend.Name });
                            priv.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        }
                    }
                    else
                    {
                        playerCupboards[playerId].Remove(cup);
                    }

                    yield return wait;
                }
            }

            List<uint> playerturr;
            if (isTurret && playerTurrets.TryGetValue(playerId, out playerturr))
            {
                foreach (uint turr in playerturr.ToList())
                {
                    AutoTurret turret = BaseNetworkable.serverEntities.Find(turr) as AutoTurret;
                    if (turret)
                    {
                        if (turret.AnyAuthed() &&
                            turret.authorizedPlayers.Any((PlayerNameID x) => x.userid == turret.OwnerID) &&
                            !turret.authorizedPlayers.Any((PlayerNameID x) => x.userid == friendID))
                        {
                            turret.authorizedPlayers.Add(new PlayerNameID { userid = friendID, username = friend.Name });
                            turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        }
                    }
                    else
                    {
                        playerTurrets[playerId].Remove(turr);
                    }

                    yield return wait;
                }
            }
            yield return null;
        }

        private void OnFriendRemoved(string playerId, string friendId, bool isCup = true, bool isTurret = true)
        {
            if (playerId == null || playerId == string.Empty || friendId == null || friendId == string.Empty)
                return;

            ServerMgr.Instance.StartCoroutine(CoFrndRmvd(playerId, friendId, isCup, isTurret));
        }

        private IEnumerator CoFrndRmvd(string playerId, string friendId, bool isCup, bool isTurret)
        {
            ulong playerID = Convert.ToUInt64(playerId);
            ulong friendID = Convert.ToUInt64(friendId);
            bool areSameClan = false;

            if (clansEnabled && SameClan(playerID, friendID))
                areSameClan = true;

            IPlayer friend = covalence.Players.FindPlayerById(friendId);
            if (friend == null) yield break;
            List<uint> playercups;
            if (isCup && playerCupboards.TryGetValue(playerId, out playercups))
            {
                foreach (uint cup in playercups)
                {
                    if (areSameClan && playerPrefs.PlayerInfo[playerID].CCS)
                        continue;

                    BuildingPrivlidge priv = BaseNetworkable.serverEntities.Find(cup) as BuildingPrivlidge;
                    if (priv)
                    {
                        if (priv.AnyAuthed() && priv.authorizedPlayers.Any((PlayerNameID x) => x.userid == friendID))
                        {
                            priv.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == friendID);
                            priv.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        }
                    }
                    else
                    {
                        playerCupboards[playerId].Remove(cup);
                    }

                    yield return wait;
                }
            }

            List<uint> playerturr;
            if (isTurret && playerTurrets.TryGetValue(playerId, out playerturr))
            {
                foreach (uint turr in playerturr)
                {
                    if (areSameClan && (playerPrefs.PlayerInfo[playerID].CTS || clanTurretShareOverride))
                        continue;

                    AutoTurret turret = BaseNetworkable.serverEntities.Find(turr) as AutoTurret;
                    if (turret)
                    {
                        if (turret.AnyAuthed() && turret.authorizedPlayers.Any((PlayerNameID x) => x.userid == friendID))
                        {
                            turret.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == friendID);
                            turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        }
                    }
                    else
                    {
                        playerTurrets[playerId].Remove(turr);
                    }

                    yield return wait;
                }
            }
        }

        private WaitForEndOfFrame wait = new WaitForEndOfFrame();

        private IEnumerator ClnMmbrChng(string memberId, List<ulong> clanMembers, bool wasAdded, bool isCup = true, bool isTurret = true)
        {
            if (isCup)
            {
                List<uint> playercups;
                foreach (ulong clanMember in clanMembers)
                {
                    if (playerCupboards.TryGetValue(clanMember.ToString(), out playercups))
                    {
                        foreach (uint cup in playercups.ToList())
                        {
                            BuildingPrivlidge priv = BaseNetworkable.serverEntities.Find(cup) as BuildingPrivlidge;
                            if (priv)
                            {
                                foreach (ulong clanMember2 in clanMembers)
                                {
                                    if (priv.OwnerID != clanMember2)
                                    {
                                        if (wasAdded)
                                        {
                                            if (!playerPrefs.PlayerInfo[clanMember2].CCS || !playerPrefs.PlayerInfo[clanMember2].HasClanShare)
                                                continue;

                                            if (priv.AnyAuthed() && priv.authorizedPlayers.Any((PlayerNameID x) => x.userid == priv.OwnerID) && !priv.authorizedPlayers.Any((PlayerNameID x) => x.userid == clanMember2))
                                            {
                                                IPlayer iplayer = covalence.Players.FindPlayerById(clanMember2.ToString());
                                                if (iplayer != null)
                                                    priv.authorizedPlayers.Add(new PlayerNameID { userid = clanMember2, username = iplayer.Name });
                                            }
                                        }
                                        else
                                        {
                                            if (friendsEnabled && playerPrefs.PlayerInfo[priv.OwnerID].CS && HasFriend(priv.OwnerID, clanMember2))
                                                continue;
                                            if (priv.AnyAuthed() && priv.authorizedPlayers.Any((PlayerNameID x) => x.userid == clanMember2))
                                            {
                                                IPlayer iplayer = covalence.Players.FindPlayerById(clanMember2.ToString());
                                                if (iplayer != null)
                                                    priv.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == clanMember2);
                                            }
                                        }

                                        yield return wait;
                                    }
                                }

                                priv.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                                yield return wait;
                            }
                            else
                            {
                                playerCupboards[clanMember.ToString()].Remove(cup);
                            }

                            yield return wait;
                        }
                    }
                }
            }

            if (isTurret)
            {
                List<uint> playerturr;
                foreach (ulong clanMember in clanMembers)
                {
                    if (playerTurrets.TryGetValue(clanMember.ToString(), out playerturr))
                    {
                        foreach (uint turr in playerturr.ToList())
                        {
                            AutoTurret turret = BaseNetworkable.serverEntities.Find(turr) as AutoTurret;
                            if (turret)
                            {
                                foreach (ulong clanMember2 in clanMembers)
                                {
                                    if (turret.OwnerID != clanMember2)
                                    {
                                        if (wasAdded)
                                        {
                                            if (!playerPrefs.PlayerInfo[clanMember2].CTS || !playerPrefs.PlayerInfo[clanMember2].HasClanShare)
                                                continue;

                                            if (turret.AnyAuthed() && turret.authorizedPlayers.Any((PlayerNameID x) => x.userid == turret.OwnerID) && !turret.authorizedPlayers.Any((PlayerNameID x) => x.userid == clanMember2))
                                            {
                                                IPlayer iplayer = covalence.Players.FindPlayerById(clanMember2.ToString());
                                                if (iplayer != null)
                                                    turret.authorizedPlayers.Add(new PlayerNameID { userid = clanMember2, username = iplayer.Name });
                                            }
                                        }
                                        else
                                        {
                                            if (friendsEnabled && playerPrefs.PlayerInfo[turret.OwnerID].TS && HasFriend(turret.OwnerID, clanMember2))
                                                continue;

                                            if (turret.AnyAuthed() && turret.authorizedPlayers.Any((PlayerNameID x) => x.userid == clanMember2))
                                            {
                                                IPlayer iplayer = covalence.Players.FindPlayerById(clanMember2.ToString());
                                                if (iplayer != null)
                                                    turret.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == clanMember2);
                                            }
                                        }

                                        yield return wait;
                                    }
                                }

                                turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                                yield return wait;
                            }
                            else
                            {
                                playerTurrets[clanMember.ToString()].Remove(turr);
                            }

                            yield return wait;
                        }
                    }
                }
            }

            yield return null;
        }

        private void OnClanMemberJoined(string playerId, List<string> clanMembersCall)
        {
            List<string> clanMembers = new List<string>(clanMembersCall);

            if (!clanMembers.Contains(playerId))
                clanMembers.Add(playerId);

            List<ulong> members = clanMembers.ConvertAll(obj => Convert.ToUInt64(obj));
            PlayerInfo pInfo;
            foreach (ulong member in members)
            {
                if (!playerPrefs.PlayerInfo.TryGetValue(member, out pInfo))
                    AddPlayerData(member);
            }
            ServerMgr.Instance.StartCoroutine(ClnMmbrChng(playerId, members, true));
        }

        private void OnClanMemberGone(string playerId, List<string> clanMembersCall)
        {
            List<string> clanMembers = new List<string>(clanMembersCall);

            if (!clanMembers.Contains(playerId))
                clanMembers.Add(playerId);

            List<ulong> members = clanMembers.ConvertAll(obj => Convert.ToUInt64(obj));
            PlayerInfo pInfo;
            foreach (ulong member in members)
            {
                if (!playerPrefs.PlayerInfo.TryGetValue(member, out pInfo))
                    AddPlayerData(member);
            }
            ServerMgr.Instance.StartCoroutine(ClnMmbrChng(playerId, members, false));
        }

        private void OnClanDisbanded(List<string> clanMembersCall)
        {
            List<string> clanMembers = new List<string>(clanMembersCall);
            List<ulong> members = clanMembers.ConvertAll(obj => Convert.ToUInt64(obj));
            PlayerInfo pInfo;
            foreach (ulong member in members)
            {
                if (!playerPrefs.PlayerInfo.TryGetValue(member, out pInfo))
                    AddPlayerData(member);
            }

            foreach (string clanMember in clanMembers.ToList())
                ServerMgr.Instance.StartCoroutine(ClnMmbrChng(clanMember, members.ToList(), false));
        }

        private void CpSttsFrnd(BasePlayer player, bool IsOn)
        {
            object obj = Friends.Call("GetFriendsS", player.UserIDString);

            if (obj == null || obj as string[] == null || (obj as string[]).Length == 0)
                return;

            List<string> friendIds = (obj as string[]).ToList();
            if (friendIds == null || friendIds.Count == 0) return;
            if (IsOn)
            {
                foreach (string friendId in friendIds)
                    OnFriendAdded(player.UserIDString, friendId, true, false);
            }
            else
            {
                foreach (string friendId in friendIds)
                    OnFriendRemoved(player.UserIDString, friendId, true, false);
            }
        }

        private void TrrtSttsFrnd(BasePlayer player, bool IsOn)
        {
            object obj = Friends.Call("GetFriendsS", player.UserIDString);
            if (obj == null || obj as string[] == null || (obj as string[]).Length == 0) return;
            List<string> friendIds = (obj as string[]).ToList();
            if (friendIds == null || friendIds.Count == 0) return;
            if (IsOn)
                foreach (string friendId in friendIds)
                    OnFriendAdded(player.UserIDString, friendId, false, true);
            else
                foreach (string friendId in friendIds)
                    OnFriendRemoved(player.UserIDString, friendId, false, true);
        }

        private void CpSttsCln(BasePlayer player, bool IsOn)
        {
            string tag = Clans?.Call("GetClanOf", player.userID) as string;
            if (tag == null || tag == string.Empty) return;
            JObject Clan = Clans?.Call("GetClan", tag) as JObject;
            if (Clan == null) return;
            List<ulong> members = Clan["members"].ToObject<List<string>>().ConvertAll(obj => Convert.ToUInt64(obj));
            PlayerInfo pInfo;
            foreach (ulong member in members)
                if (!playerPrefs.PlayerInfo.TryGetValue(member, out pInfo))
                    AddPlayerData(member);
            if (IsOn) ServerMgr.Instance.StartCoroutine(ClnMmbrChng(player.UserIDString, members, true, true, false));
            else ServerMgr.Instance.StartCoroutine(ClnMmbrChng(player.UserIDString, members, false, true, false));
        }

        private void TrrtSttsCln(BasePlayer player, bool IsOn)
        {
            string tag = Clans?.Call("GetClanOf", player.userID) as string;
            if (tag == null || tag == string.Empty) return;
            JObject Clan = Clans?.Call("GetClan", tag) as JObject;
            if (Clan == null) return;
            List<ulong> members = Clan["members"].ToObject<List<string>>().ConvertAll(obj => Convert.ToUInt64(obj));
            PlayerInfo pInfo;
            foreach (ulong member in members)
            {
                pInfo = null;
                if (!playerPrefs.PlayerInfo.TryGetValue(member, out pInfo)) AddPlayerData(member);
            }

            if (IsOn) ServerMgr.Instance.StartCoroutine(ClnMmbrChng(player.UserIDString, members, true, false, true));
            else ServerMgr.Instance.StartCoroutine(ClnMmbrChng(player.UserIDString, members, false, false, true));
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null || (entity as BaseEntity)?.OwnerID == 0uL) return;
            if (entity is BuildingPrivlidge)
            {
                List<uint> player = null;
                string owner = (entity as BaseEntity).OwnerID.ToString();
                if (!playerCupboards.TryGetValue(owner, out player)) return;
                playerCupboards[owner].Remove(entity.net.ID);
            }
            else if (entity is AutoTurret)
            {
                List<uint> player = null;
                string owner = (entity as BaseEntity).OwnerID.ToString();
                if (!playerTurrets.TryGetValue(owner, out player)) return;
                playerTurrets[owner].Remove(entity.net.ID);
            }
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
        {
            if (entity == null || !turret.IsValid() || turret is NPCAutoTurret || turret.OwnerID == 0uL)
                return null;

            BasePlayer player = entity as BasePlayer;
            if (player != null && player.IsConnected && !player.IsDead())
            {
                ulong userID = player.userID;
                string displayName = player.displayName;
                try
                {
                    if (AccessOn(userID))
                    {
                        if (adminTurrets[userID] == null)
                            adminTurrets[userID] = new List<uint>();

                        adminTurrets[userID].Add(turret.net.ID);

                        turret.authorizedPlayers.Add(new PlayerNameID { userid = userID, username = displayName });
                        turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                        return true;
                    }
                }
                catch
                {
                }

                if (!turret.AnyAuthed() || !turret.authorizedPlayers.Any((PlayerNameID x) => x.userid == turret.OwnerID))
                    return null;

                PlayerInfo playerInfo;
                if (playerPrefs.PlayerInfo.TryGetValue(userID, out playerInfo))
                {
                    if (playerInfo.BPH != null && playerInfo.BPH.SameTurret(turret.net.ID))
                    {
                        object result = playerInfo.BPH.LastResult();
                        return result;
                    }

                    PlayerInfo otherInfo;
                    if (playerPrefs.PlayerInfo.TryGetValue(turret.OwnerID, out otherInfo))
                    {
                        if (clansEnabled && (clanTurretShareOverride || otherInfo.CTS) && SameClan(turret.OwnerID, userID) && (usePermGetClanShares && permission.UserHasPermission(userID.ToString(), permGetClanShares) || !usePermGetClanShares || clanTurretShareOverride))
                        {
                            turret.authorizedPlayers.Add(new PlayerNameID { userid = userID, username = displayName });
                            turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            return true;
                        }

                        if (friendsEnabled && otherInfo.TS && HasFriend(turret.OwnerID, userID) && (usePermGetFriendShares && permission.UserHasPermission(userID.ToString(), permGetFriendShares) || !usePermGetFriendShares))
                        {
                            turret.authorizedPlayers.Add(new PlayerNameID { userid = userID, username = displayName });
                            turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                            return true;
                        }
                        if (playerInfo.BPH != null)
                            playerInfo.BPH.SetTurret(turret.net.ID, null);
                    }
                }
            }

            return null;
        }

        private object CanBeTargeted(BasePlayer player, FlameTurret turret)
        {
            if (!includeFlameTurrets || player == null || !turret.IsValid() || turret.OwnerID == 0uL)
                return null;

            if (player.userID == turret.OwnerID || AccessOn(player.userID))
                return false;

            return CanBeTurretTarget(player.userID, turret.net.ID, turret.OwnerID);
        }

        private object CanBeTargeted(BasePlayer player, GunTrap turret)
        {
            if (!includeGunTraps || player == null || !turret.IsValid() || turret.OwnerID == 0uL)
                return null;

            if (player.userID == turret.OwnerID || AccessOn(player.userID))
                return false;

            return CanBeTurretTarget(player.userID, turret.net.ID, turret.OwnerID);
        }

        private object CanBeTurretTarget(ulong userID, uint netID, ulong OwnerID)
        {
            PlayerInfo oInfo;
            if (playerPrefs.PlayerInfo.TryGetValue(OwnerID, out oInfo))
            {
                PlayerInfo pInfo;
                if (playerPrefs.PlayerInfo.TryGetValue(userID, out pInfo))
                {
                    if (pInfo.BPH != null && pInfo.BPH.SameTurret(netID))
                    {
                        object result = pInfo.BPH.LastResult();
                        return result;
                    }

                    if (clansEnabled && (clanTurretShareOverride || oInfo.CTS) && SameClan(OwnerID, userID) && pInfo.HasClanShare && (pInfo.CTS || clanTurretShareOverride) || friendsEnabled && oInfo.TS && HasFriend(OwnerID, userID) && pInfo.HasFriendShare)
                    {
                        pInfo.BPH.SetTurret(netID, false);
                        return false;
                    }

                    if (pInfo.BPH != null)
                        pInfo.BPH.SetTurret(netID, null);
                }
            }

            return null;
        }

        private object OnSamSiteTarget(SamSite sam, BaseCombatEntity target)
        {
            if (!includeSamSites || sam.OwnerID == 0)
                return null;

            BaseVehicle baseVehicle = target as BaseVehicle;
            if (baseVehicle != null)
            {
                if (!samSiteShootEmptyVehicles && !HasOccupants(baseVehicle))
                {
                    sam.CancelInvoke(sam.WeaponTick);
                    return false;
                }

                for (int i = 0; i < baseVehicle.mountPoints?.Length; i++)
                {
                    BasePlayer player = baseVehicle.mountPoints[i].mountable?.GetMounted();
                    if (player != null)
                    {
                        if (player.userID == sam.OwnerID || AccessOn(player.userID))
                        {
                            sam.CancelInvoke(sam.WeaponTick);
                            return false;
                        }

                        if (SamVerificationInternal(sam.OwnerID, player.userID, () => sam.CancelInvoke(sam.WeaponTick)))
                        {
                            return false;
                        }
                    }
                }
                return null;
            }

            HotAirBalloon hotAirBalloon = target as HotAirBalloon;
            if (hotAirBalloon != null)
            {
                if (!samSiteShootEmptyVehicles && hotAirBalloon.children?.Count == 0)
                {
                    sam.CancelInvoke(sam.WeaponTick);
                    return false;
                }

                for (int i = 0; i < hotAirBalloon.children?.Count; i++)
                {
                    BasePlayer player = hotAirBalloon.children[i] as BasePlayer;
                    if (player != null)
                    {
                        if (player.userID == sam.OwnerID || AccessOn(player.userID))
                        {
                            sam.CancelInvoke(sam.WeaponTick);
                            return false;
                        }

                        if (SamVerificationInternal(sam.OwnerID, player.userID, () => sam.CancelInvoke(sam.WeaponTick)))
                            return false;
                    }
                }
            }
            return null;
        }

        private bool HasOccupants(BaseVehicle baseVehicle)
        {
            for (int i = 0; i < baseVehicle?.mountPoints?.Length; i++)
            {
                if (baseVehicle.mountPoints[i].mountable.IsMounted())
                    return true;
            }
            return false;
        }

        private bool SamVerificationInternal(ulong ownerId, ulong playerId, Action action)
        {
            PlayerInfo oInfo;
            if (playerPrefs.PlayerInfo.TryGetValue(ownerId, out oInfo))
            {
                PlayerInfo pInfo;
                if (playerPrefs.PlayerInfo.TryGetValue(playerId, out pInfo))
                {
                    if (clansEnabled && (clanTurretShareOverride || oInfo.CTS) && SameClan(ownerId, playerId) && pInfo.HasClanShare && (pInfo.CTS || clanTurretShareOverride) || friendsEnabled && oInfo.TS && HasFriend(ownerId, playerId) && pInfo.HasFriendShare)
                    {
                        action?.Invoke();
                        return true;
                    }
                }
            }
            return false;
        }
        private void OnEntityBuilt(Planner planner, GameObject obj)
        {
            if (planner == null) return;
            BasePlayer player = planner.GetOwnerPlayer();
            if (player == null) return;
            BaseEntity entity = obj.ToBaseEntity();
            if (entity == null || entity.net == null || entity.OwnerID == 0uL) return;
            if (entity is MiningQuarry && enableQuarrySharing && enableQuarrySwitchCheck)
            {
                (entity as MiningQuarry).engineSwitchPrefab.instance.gameObject.transform.GetOrAddComponent<QuarryHandler>();
                return;
            }

            PlayerInfo pInfo;
            if (!playerPrefs.PlayerInfo.TryGetValue(player.userID, out pInfo)) pInfo = SetPlayer(player);
            if (!pInfo.AA || !pInfo.CanAutoAuth) return;
            if (entity is BuildingPrivlidge)
            {
                (entity as BuildingPrivlidge).authorizedPlayers.Add(new PlayerNameID
                    {userid = player.userID, username = player.displayName});
                entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                if (notifyAuthCupboard)
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("CupAuth", this, player.UserIDString)) + $"</color>");
                playerCupboards[player.UserIDString].Add(entity.net.ID);
                if (enableCupSharing)
                {
                    if (clansEnabled && pInfo.CCS) CpSttsCln(player, true);
                    if (friendsEnabled && pInfo.CS) CpSttsFrnd(player, true);
                }
            }
            else if (entity is AutoTurret)
            {
                (entity as AutoTurret).authorizedPlayers.Add(new PlayerNameID
                    {userid = player.userID, username = player.displayName});
                entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                if (notifyAuthTurret)
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("TurretAuth", this, player.UserIDString)) + $"</color>");
                playerTurrets[player.UserIDString].Add(entity.net.ID);
                if (enableTurretSharing)
                {
                    if (clansEnabled && (pInfo.CTS || clanTurretShareOverride)) TrrtSttsCln(player, true);
                    if (friendsEnabled && pInfo.TS) TrrtSttsFrnd(player, true);
                }
            }
        }

        private object OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege == null || player == null || privilege.OwnerID == player.userID ||
                GetAdmin(player) && AccessOn(player.userID) || !privilege.AnyAuthed() ||
                !privilege.authorizedPlayers.Any((PlayerNameID x) => x.userid == privilege.OwnerID)) return null;
            if (clansEnabled && blockCupClearClanMembers && SameClan(privilege.OwnerID, player.userID))
            {
                PrintToChat(player,
                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                    string.Format(lang.GetMessage("CupAuthClearBlocked", this, player.UserIDString)) + $"</color>");
                return true;
            }

            if (clansEnabled && blockCupAccessNotSameClan && !SameClan(privilege.OwnerID, player.userID))
            {
                PrintToChat(player,
                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                    string.Format(lang.GetMessage("CupAuthClearBlocked", this, player.UserIDString)) + $"</color>");
                return true;
            }

            if (friendsEnabled && blockCupClearFriends && HasFriend(privilege.OwnerID, player.userID))
            {
                PrintToChat(player,
                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                    string.Format(lang.GetMessage("CupAuthClearBlocked", this, player.UserIDString)) + $"</color>");
                return true;
            }

            return null;
        }

        private object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
        {
            if (privilege == null || player == null)
                return null;

            if (cupboardAuthMaxUsers > 0 && privilege.authorizedPlayers.Count >= cupboardAuthMaxUsers)
            {
                PrintToChat(player,
                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                    string.Format(lang.GetMessage("CupAuthMaxUsers", this, player.UserIDString), cupboardAuthMaxUsers) + $"</color>");
                return false;
            }

            if (privilege.OwnerID == player.userID || !privilege.AnyAuthed() || !privilege.authorizedPlayers.Any((PlayerNameID x) => x.userid == privilege.OwnerID))
                return null;

            if (GetAdmin(player) && AccessOn(player.userID)) return null;
            
            bool sameClan = false;
            if (clansEnabled) sameClan = SameClan(privilege.OwnerID, player.userID);
            if (clansEnabled && blockCupAccessNotSameClan && !sameClan)
            {
                PrintToChat(player,
                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                    string.Format(lang.GetMessage("CupAuthNotSameClanBlocked", this, player.UserIDString)) +
                    $"</color>");
                return false;
            }

            if (clansEnabled && sameClan)
            {
                if (!playerPrefs.PlayerInfo[privilege.OwnerID].CCS)
                {
                    IPlayer oPlayer = covalence.Players.FindPlayerById(privilege.OwnerID.ToString());
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("CupAuthDisabledOwner", this, player.UserIDString),
                            oPlayer != null ? oPlayer.Name : "The owner") + $"</color>");
                    return false;
                }

                if (!playerPrefs.PlayerInfo[player.userID].CCS)
                {
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("CupAuthDisabledSelf", this, player.UserIDString)) + $"</color>");
                    return false;
                }
            }

            if (friendsEnabled && HasFriend(privilege.OwnerID, player.userID) &&
                !playerPrefs.PlayerInfo[privilege.OwnerID].CS && !sameClan)
            {
                IPlayer oPlayer = covalence.Players.FindPlayerById(privilege.OwnerID.ToString());
                PrintToChat(player,
                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                    string.Format(lang.GetMessage("CupAuthDisabledOwner", this, player.UserIDString),
                        oPlayer != null ? oPlayer.Name : "The owner") + $"</color>");
                return false;
            }

            return null;
        }

        private void CheckCupboardAccess(BasePlayer player, BuildingPrivlidge cup)
        {
            if (GetAdmin(player) && AccessOn(player.userID))
            {
                adminCupboards[player.userID].Add(cup.net.ID);
                cup.authorizedPlayers.Add(new PlayerNameID {userid = player.userID, username = player.displayName});
                cup.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                return;
            }

            if (!cup.AnyAuthed() || !cup.authorizedPlayers.Any((PlayerNameID x) => x.userid == cup.OwnerID)) return;
            PlayerInfo pInfo;
            if (!playerPrefs.PlayerInfo.TryGetValue(cup.OwnerID, out pInfo)) pInfo = AddPlayerData(cup.OwnerID);
            if (clansEnabled && pInfo.CCS && SameClan(cup.OwnerID, player.userID) &&
                playerPrefs.PlayerInfo[player.userID].CCS && playerPrefs.PlayerInfo[player.userID].HasClanShare || friendsEnabled &&
                pInfo.CS && HasFriend(cup.OwnerID, player.userID) && playerPrefs.PlayerInfo[player.userID].HasFriendShare)
            {
                cup.authorizedPlayers.Add(new PlayerNameID {userid = player.userID, username = player.displayName});
                cup.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }
        }

        private void OnLootEntity(BasePlayer looter, BaseEntity entity)
        {
            if (looter == null || entity == null || !(entity is ResourceExtractorFuelStorage)) return;
            MiningQuarry quarry = entity.GetComponentInParent<MiningQuarry>();
            if (quarry == null || quarry.OwnerID == 0uL || quarry.OwnerID == looter.userID ||
                GetAdmin(looter) && AccessOn(looter.userID)) return;
            PlayerInfo pInfo;
            if (!playerPrefs.PlayerInfo.TryGetValue(quarry.OwnerID, out pInfo)) pInfo = AddPlayerData(quarry.OwnerID);
            if (clansEnabled && pInfo.CQS && SameClan(quarry.OwnerID, looter.userID) &&
                playerPrefs.PlayerInfo[looter.userID].CQS && playerPrefs.PlayerInfo[looter.userID].HasClanShare || friendsEnabled &&
                pInfo.QS && HasFriend(quarry.OwnerID, looter.userID) &&
                playerPrefs.PlayerInfo[looter.userID].HasFriendShare) return;
            NextTick(() =>
            {
                if (looter == null) return;
                looter.ClientRPCPlayer(null, looter, "OnDied");
                PrintToChat(looter,
                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                    string.Format(lang.GetMessage("QuarryNoLootAccess", this, looter.UserIDString)) + $"</color>");
            });
        }

        internal class QuarryHandler : FacepunchBehaviour
        {
            private EngineSwitch engine;
            private MiningQuarry quarry;
            private ItemContainer fuelStorage;
            private bool isOn;

            private void Awake()
            {
                engine = GetComponent<EngineSwitch>();
                quarry = engine.GetComponentInParent<MiningQuarry>();
                isOn = engine.HasFlag(BaseEntity.Flags.On);
                fuelStorage = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory;

                quarry.InvokeRandomized(DoUpdate, 2f, 2f, 0.5f);
            }

            private void OnDestroy()
            {
                quarry?.CancelInvoke(DoUpdate);
            }

            private bool FuelCheck()
            {
                Item item = fuelStorage?.FindItemsByItemName("lowgradefuel");

                if (item != null && item.amount >= 1)
                    return true;

                return false;
            }

            private void DoUpdate()
            {
                if (engine.HasFlag(BaseEntity.Flags.On) != isOn)
                {
                    if (!FuelCheck())
                    {
                        isOn = engine.HasFlag(BaseEntity.Flags.On);
                        return;
                    }

                    List<BasePlayer> list = Pool.GetList<BasePlayer>();
                    Vis.Entities<BasePlayer>(engine.transform.position, 4f, list, 131072, QueryTriggerInteraction.Collide);

                    foreach (BasePlayer player in list.Where(d => engine.Distance(d.eyes.position) < 3f).OrderBy(p => engine.Distance(p.eyes.position)).ToList())
                    {
                        if (Instance.CheckForCQS(quarry.OwnerID, player) || player.userID == quarry.OwnerID || Instance.GetAdmin(player) && Instance.AccessOn(player.userID))
                        {
                            isOn = !isOn;
                            return;
                        }
                    }

                    quarry.SetFlag(BaseEntity.Flags.On, isOn, false);
                    engine.SetFlag(BaseEntity.Flags.On, isOn, false);

                    quarry.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    engine.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                    Pool.FreeList(ref list);
                }
            }
        }

        private bool CheckForCQS(ulong ownerID, BasePlayer player)
        {
            if (clansEnabled && playerPrefs.PlayerInfo[ownerID].CQS && SameClan(ownerID, player.userID) &&
                playerPrefs.PlayerInfo[player.userID].CQS && playerPrefs.PlayerInfo[player.userID].HasClanShare || friendsEnabled &&
                playerPrefs.PlayerInfo[ownerID].QS && HasFriend(ownerID, player.userID) &&
                playerPrefs.PlayerInfo[player.userID].HasFriendShare) return true;
            return false;
        }

        private object CanUseLockedEntity(BasePlayer player, KeyLock code)
        {
            if (player == null || code == null || !code.IsLocked()) return null;
            if (GetAdmin(player) && AccessOn(player.userID)) return true;
            return null;
        }

        private object CanUseLockedEntity(BasePlayer player, CodeLock code)
        {
            if (player == null || code == null || !code.IsLocked()) return null;
            object result = UseLock(player, code);
            if (result is bool)
            {
                if ((bool) result)
                    Effect.server.Run(code.effectUnlocked.resourcePath, code, 0u, Vector3.zero, Vector3.forward, null,
                        false);
                else
                    Effect.server.Run(code.effectDenied.resourcePath, code, 0u, Vector3.zero, Vector3.forward, null,
                        false);
            }

            return result;
        }

        private object CanUnlock(CodeLock code, BasePlayer player)
        {
            if (player == null || code == null) return null;
            if (InAdmMode(player))
            {
                Effect.server.Run(code.effectUnlocked.resourcePath, code, 0u, Vector3.zero, Vector3.forward, null,
                    false);
                code.SetFlag(BaseEntity.Flags.Locked, false, false);
                code.SendNetworkUpdate();
                return true;
            }

            return null;
        }

        private object CanLock(CodeLock code, BasePlayer player)
        {
            if (player == null || code == null) return null;
            if (InAdmMode(player))
            {
                Effect.server.Run(code.effectLocked.resourcePath, code, 0u, Vector3.zero, Vector3.forward, null, false);
                code.SetFlag(BaseEntity.Flags.Locked, true, false);
                code.SendNetworkUpdate();
                return true;
            }

            return null;
        }

        private bool InAdmMode(BasePlayer player)
        {
            bool enabled;
            return adminAccessEnabled.TryGetValue(player.userID, out enabled) && enabled;
        }

        private object UseLock(BasePlayer player, CodeLock code)
        {
            if (InAdmMode(player)) return true;
            BaseEntity parent = code.GetParentEntity();
            if (parent == null || parent.OwnerID == 0uL) return null;
            ulong owner = parent.OwnerID;
            if (code.whitelistPlayers.Contains(player.userID) || code.guestPlayers.Contains(player.userID)) return true;
            if (code.whitelistPlayers.Count == 0 || !code.whitelistPlayers.Contains(owner)) return null;
            bool hasClanShare = playerPrefs.PlayerInfo[player.userID].HasClanShare;
            bool hasFriendShare = playerPrefs.PlayerInfo[player.userID].HasFriendShare;
            PlayerInfo oInfo;
            if (!playerPrefs.PlayerInfo.TryGetValue(owner, out oInfo)) oInfo = AddPlayerData(owner);
            if (clansEnabled && parent is Door && enableDoorSharing && playerPrefs.PlayerInfo[owner].CDS &&
                SameClan(owner, player.userID) && playerPrefs.PlayerInfo[player.userID].CDS && hasClanShare)
            {
                return true;
            }
            else if (clansEnabled && parent is BuildingPrivlidge && enableCupSharing && playerPrefs.PlayerInfo[owner].CCS &&
                     SameClan(owner, player.userID) && playerPrefs.PlayerInfo[player.userID].CCS && hasClanShare)
            {
                return true;
            }
            else if (clansEnabled &&
                     (parent is BoxStorage && enableBoxSharing && playerPrefs.PlayerInfo[owner].CBS ||
                      parent is Locker && enableLockerSharing && playerPrefs.PlayerInfo[owner].CBS) &&
                     SameClan(owner, player.userID) && playerPrefs.PlayerInfo[player.userID].CBS && hasClanShare)
            {
                return true;
            }
            else if (friendsEnabled && parent is Door && enableDoorSharing && playerPrefs.PlayerInfo[owner].DS &&
                     HasFriend(owner, player.userID) && hasFriendShare)
            {
                return true;
            }
            else if (friendsEnabled && parent is BuildingPrivlidge && enableCupSharing && playerPrefs.PlayerInfo[owner].CS &&
                     HasFriend(owner, player.userID) && hasFriendShare)
            {
                return true;
            }
            else if (friendsEnabled &&
                     (parent is BoxStorage && enableBoxSharing && playerPrefs.PlayerInfo[owner].BS ||
                      parent is Locker && enableLockerSharing && playerPrefs.PlayerInfo[owner].LS) &&
                     HasFriend(owner, player.userID) && hasFriendShare)
            {
                return true;
            }
            else if (clansEnabled && parent is Door && enableDoorSharing && SameClan(owner, player.userID) && hasClanShare)
            {
                if (parent.IsOpen()) return true;
                if (!playerPrefs.PlayerInfo[owner].CDS)
                {
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("DoorClanNotShared", this, player.UserIDString),
                            rust.FindPlayerById(owner)?.displayName ?? string.Empty) + $"</color>");
                    return false;
                }

                if (!playerPrefs.PlayerInfo[player.userID].CDS)
                {
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("DoorClanNotSharedSelf", this, player.UserIDString)) +
                        $"</color>");
                    return false;
                }
            }
            else if (clansEnabled && parent is BoxStorage && enableBoxSharing && SameClan(owner, player.userID) &&
                     hasClanShare)
            {
                if (!playerPrefs.PlayerInfo[owner].CBS)
                {
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("BoxClanNotShared", this, player.UserIDString),
                            rust.FindPlayerById(owner)?.displayName ?? string.Empty) + $"</color>");
                    return false;
                }

                if (!playerPrefs.PlayerInfo[player.userID].CBS)
                {
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("BoxClanNotSharedSelf", this, player.UserIDString)) +
                        $"</color>");
                    return false;
                }
            }
            else if (clansEnabled && parent is Locker && enableLockerSharing && SameClan(owner, player.userID) &&
                     hasClanShare)
            {
                if (parent.IsOpen()) return true;
                if (!playerPrefs.PlayerInfo[owner].CLS)
                {
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("LockerClanNotShared", this, player.UserIDString),
                            rust.FindPlayerById(owner)?.displayName ?? string.Empty) + $"</color>");
                    return false;
                }

                if (!playerPrefs.PlayerInfo[player.userID].CLS)
                {
                    PrintToChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("LockerClanNotSharedSelf", this, player.UserIDString)) +
                        $"</color>");
                    return false;
                }
            }

            return null;
        }

        [ConsoleCommand("dynashare.resetdata")]
        private void dataReset(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            SendReply(arg, $"Resetting {playerPrefs.PlayerInfo.Count} entries in userdata");
            foreach (KeyValuePair<ulong, PlayerInfo> info in playerPrefs.PlayerInfo)
            {
                info.Value.CS = CupShare;
                info.Value.DS = DoorShare;
                info.Value.TS = TurretShare;
                info.Value.BS = BoxShare;
                info.Value.LS = LockerShare;
                info.Value.AA = AutoAuth;
                info.Value.CCS = ClanCupShare;
                info.Value.CDS = ClanDoorShare;
                info.Value.CBS = ClanBoxShare;
                info.Value.CLS = ClanLockerShare;
                info.Value.CTS = ClanTurretShare;
            }

            SendReply(arg, "Saving userdata");
            SaveData();
        }

        private void cShareCommand(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Connection != null && arg.Connection.player != null)
            {
                usdCnslInpt.Add(arg.Connection.userid);
                if (arg.Args != null) ShareCommand((BasePlayer) arg.Connection.player, shareCommand, arg.Args);
                else ShareCommand((BasePlayer) arg.Connection.player, shareCommand, new string[] { });
            }
        }

        private void ShareCommand(BasePlayer player, string command, string[] args)
        {
            ulong userID = player.userID;
            string UserIDString = player.UserIDString;
            if (pluginDisabled)
            {
                PrintChat(player,
                    string.Format(prefixFormat, prefixColor, pluginPrefix) +
                    $"<color={colorTextMsg}>Plugin out of service!</color>");
                return;
            }

            bool hasClan = false;
            if (clansEnabled && Clans?.Call("GetClanOf", player) != null) hasClan = true;
            PlayerInfo pInfo;
            if (!playerPrefs.PlayerInfo.TryGetValue(userID, out pInfo)) pInfo = SetPlayer(player);
            if (args.Length == 0)
            {
                StringBuilder sb = new StringBuilder();
                if (!usdCnslInpt.Contains(userID))
                    sb.AppendLine($"<size=16><color={prefixColor}>{pluginPrefix}</color></size>");
                sb.AppendLine(lang.GetMessage("CommandUsage", this, UserIDString) +
                              $"<color={colorCmdUsage}>/{shareCommand} option | all</color> OR <color={colorCmdUsage}>/{shareCommand} help | h</color>");
                if (usePermGetClanShares && clansEnabled || usePermGetFriendShares && friendsEnabled)
                {
                    string hasAccessTo;
                    if (pInfo.HasClanShare && pInfo.HasFriendShare)
                        hasAccessTo = $" <color={colorON}>Clan</color> | <color={colorON}>Friends</color>";
                    else if (pInfo.HasClanShare && !pInfo.HasFriendShare) hasAccessTo = $" <color={colorON}>Clan</color>";
                    else if (!pInfo.HasClanShare && pInfo.HasFriendShare) hasAccessTo = $" <color={colorON}>Friends</color>";
                    else hasAccessTo = $" <color={colorOFF}>None</color>";
                    sb.AppendLine(lang.GetMessage("AccessRights", this, UserIDString) + hasAccessTo);
                }
                else
                {
                    sb.AppendLine(lang.GetMessage("CommandToggle", this, UserIDString));
                }

                if (friendsEnabled)
                {
                    if (enableCupSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>cup | c</color> - " +
                                      lang.GetMessage("CommandFriendCup", this, UserIDString) + " " +
                                      (pInfo.CS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableDoorSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>door | d</color> - " +
                                      lang.GetMessage("CommandFriendDoor", this, UserIDString) + " " +
                                      (pInfo.DS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableBoxSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>box | b</color> - " +
                                      lang.GetMessage("CommandFriendBox", this, UserIDString) + " " +
                                      (pInfo.BS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableLockerSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>locker | l</color> - " +
                                      lang.GetMessage("CommandFriendLocker", this, UserIDString) + " " +
                                      (pInfo.LS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableQuarrySharing)
                        sb.AppendLine($"<color={colorCmdUsage}>quarry | q</color> - " +
                                      lang.GetMessage("CommandFriendQuarry", this, UserIDString) + " " +
                                      (pInfo.QS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableTurretSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>turret | t</color> - " +
                                      lang.GetMessage("CommandFriendTurret", this, player.UserIDString) + " " +
                                      (pInfo.TS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                }

                if (usePermAutoAuth && permission.UserHasPermission(UserIDString, permAutoAuth) || !usePermAutoAuth)
                    sb.AppendLine($"<color={colorCmdUsage}>autoauth | a</color> - " +
                                  lang.GetMessage("CommandAutoAuth", this, UserIDString) + " " +
                                  (playerPrefs.PlayerInfo[userID].AA
                                      ? $"<color={colorON}>ON</color>"
                                      : $"<color={colorOFF}>OFF</color>"));
                if (hasClan)
                {
                    if (enableCupSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>clancup | cc</color> - " +
                                      lang.GetMessage("CommandClanCup", this, UserIDString) + " " +
                                      (pInfo.CCS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableDoorSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>clandoor | cd</color> - " +
                                      lang.GetMessage("CommandClanDoor", this, UserIDString) + " " +
                                      (pInfo.CDS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableBoxSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>clanbox | cb</color> - " +
                                      lang.GetMessage("CommandClanBox", this, UserIDString) + " " +
                                      (pInfo.CBS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableLockerSharing)
                        sb.AppendLine($"<color={colorCmdUsage}>clanlocker | cl</color> - " +
                                      lang.GetMessage("CommandClanLocker", this, UserIDString) + " " +
                                      (pInfo.CLS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (enableQuarrySharing)
                        sb.AppendLine($"<color={colorCmdUsage}>clanquarry | cq</color> - " +
                                      lang.GetMessage("CommandClanQuarry", this, UserIDString) + " " +
                                      (pInfo.CQS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                    if (clanTurretShareOverride)
                        sb.AppendLine(lang.GetMessage("CommandClanTurret", this, UserIDString) + " " +
                                      (clanTurretShareOverride
                                          ? $"<color={colorON}>ON</color>"
                                          : $"<color={colorOFF}>OFF</color>"));
                    else
                        sb.AppendLine($"<color={colorCmdUsage}>clanturret | ct</color> - " +
                                      lang.GetMessage("CommandClanTurretM", this, UserIDString) + " " +
                                      (pInfo.CTS ? $"<color={colorON}>ON</color>" : $"<color={colorOFF}>OFF</color>"));
                }

                if (GetAdmin(player))
                    sb.AppendLine($"<color={prefixColor}>" + lang.GetMessage("CommandAdminAccess", this, UserIDString) +
                                  "</color>" + $" (<color={colorCmdUsage}>admin | adm</color>): " +
                                  (adminAccessEnabled[player.userID] == true
                                      ? $"<color={colorON}>ON</color>"
                                      : $"<color={colorOFF}>OFF</color>"));
                string openText = $"<color={colorTextMsg}>";
                string closeText = "</color>";
                string[] parts = sb.ToString().Split(new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries);
                sb = new StringBuilder();
                foreach (string part in parts)
                {
                    if (sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length > 1100)
                    {
                        PrintChat(player, openText + sb.ToString().TrimEnd() + closeText,
                            usdCnslInpt.Contains(player.userID) ? true : false);
                        sb.Clear();
                    }

                    sb.AppendLine(part);
                }

                PrintChat(player, openText + sb.ToString().TrimEnd() + closeText);
                return;
            }

            switch (args[0])
            {
                case "cup":
                case "c":
                    if (!friendsEnabled || !enableCupSharing) goto case "disabled";
                    if (!toggleCupShare) goto case "blocked";
                    pInfo.CS = !pInfo.CS;
                    CpSttsFrnd(player, pInfo.CS);
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.CS
                            ? lang.GetMessage("ShareEnabled", this, UserIDString)
                            : lang.GetMessage("ShareDisabled", this, UserIDString)) + "</color>");
                    break;
                case "door":
                case "d":
                    if (!friendsEnabled || !enableDoorSharing) goto case "disabled";
                    if (!toggleDoorShare) goto case "blocked";
                    pInfo.DS = !pInfo.DS;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.DS
                            ? lang.GetMessage("CodesEnabled", this, UserIDString)
                            : lang.GetMessage("CodesDisabled", this, UserIDString)) + "</color>");
                    break;
                case "box":
                case "b":
                    if (!friendsEnabled || !enableBoxSharing) goto case "disabled";
                    if (!toggleBoxShare) goto case "blocked";
                    pInfo.BS = !pInfo.BS;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.BS
                            ? lang.GetMessage("BoxesEnabled", this, UserIDString)
                            : lang.GetMessage("BoxesDisabled", this, UserIDString)) + "</color>");
                    break;
                case "locker":
                case "l":
                    if (!friendsEnabled || !enableLockerSharing) goto case "disabled";
                    if (!toggleLockerShare) goto case "blocked";
                    pInfo.LS = !pInfo.LS;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.LS
                            ? lang.GetMessage("LockersEnabled", this, UserIDString)
                            : lang.GetMessage("LockersDisabled", this, UserIDString)) + "</color>");
                    break;
                case "quarry":
                case "q":
                    if (!friendsEnabled || !enableQuarrySharing) goto case "disabled";
                    if (!toggleQuarryShare) goto case "blocked";
                    pInfo.QS = !pInfo.QS;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (playerPrefs.PlayerInfo[userID].QS
                            ? lang.GetMessage("QuarriesEnabled", this, UserIDString)
                            : lang.GetMessage("QuarriesDisabled", this, UserIDString)) + "</color>");
                    break;
                case "turret":
                case "t":
                    if (!friendsEnabled || !enableTurretSharing) goto case "disabled";
                    if (!toggleTurretShare) goto case "blocked";
                    pInfo.TS = !pInfo.TS;
                    TrrtSttsFrnd(player, pInfo.TS);
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.TS
                            ? lang.GetMessage("TurretEnabled", this, UserIDString)
                            : lang.GetMessage("TurretDisabled", this, UserIDString)) + "</color>");
                    break;
                case "autoauth":
                case "a":
                    if (usePermAutoAuth && !permission.UserHasPermission(UserIDString, permAutoAuth))
                        goto case "disabled";
                    if (!toggleAutoAuth) goto case "blocked";
                    pInfo.AA = !pInfo.AA;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.AA
                            ? lang.GetMessage("AutoAuthEnabled", this, UserIDString)
                            : lang.GetMessage("AutoAuthDisabled", this, UserIDString)) + "</color>");
                    break;
                case "clancup":
                case "cc":
                    if (!hasClan || !enableCupSharing) goto case "disabled";
                    if (!toggleClanCupShare) goto case "blocked";
                    pInfo.CCS = !pInfo.CCS;
                    CpSttsCln(player, pInfo.CCS);
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.CCS
                            ? lang.GetMessage("ClanShareEnabled", this, UserIDString)
                            : lang.GetMessage("ClanShareDisabled", this, UserIDString)) + "</color>");
                    break;
                case "clandoor":
                case "cd":
                    if (!hasClan || !enableDoorSharing) goto case "disabled";
                    if (!toggleClanDoorShare) goto case "blocked";
                    pInfo.CDS = !pInfo.CDS;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.CDS
                            ? lang.GetMessage("ClanCodesEnabled", this, UserIDString)
                            : lang.GetMessage("ClanCodesDisabled", this, UserIDString)) + "</color>");
                    break;
                case "clanbox":
                case "cb":
                    if (!hasClan || !enableBoxSharing) goto case "disabled";
                    if (!toggleClanBoxShare) goto case "blocked";
                    pInfo.CBS = !pInfo.CBS;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.CBS
                            ? lang.GetMessage("ClanBoxesEnabled", this, UserIDString)
                            : lang.GetMessage("ClanBoxesDisabled", this, UserIDString)) + "</color>");
                    break;
                case "clanlocker":
                case "cl":
                    if (!hasClan || !enableLockerSharing) goto case "disabled";
                    if (!toggleClanLockerShare) goto case "blocked";
                    pInfo.CLS = !pInfo.CLS;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.CLS
                            ? lang.GetMessage("ClanLockersEnabled", this, UserIDString)
                            : lang.GetMessage("ClanLockersDisabled", this, UserIDString)) + "</color>");
                    break;
                case "clanquarry":
                case "cq":
                    if (!hasClan || !enableQuarrySharing) goto case "disabled";
                    if (!toggleClanQuarryShare) goto case "blocked";
                    pInfo.CQS = !pInfo.CQS;
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.CQS
                            ? lang.GetMessage("ClanQuarriesEnabled", this, UserIDString)
                            : lang.GetMessage("ClanQuarriesDisabled", this, UserIDString)) + "</color>");
                    break;
                case "clanturret":
                case "ct":
                    if (!hasClan || clanTurretShareOverride || !enableTurretSharing) goto case "disabled";
                    if (!toggleClanTurretShare) goto case "blocked";
                    pInfo.CTS = !pInfo.CTS;
                    TrrtSttsCln(player, pInfo.CTS);
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        (pInfo.CTS
                            ? lang.GetMessage("ClanTurretEnabled", this, UserIDString)
                            : lang.GetMessage("ClanTurretDisabled", this, UserIDString)) + "</color>");
                    break;
                case "disabled":
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("NotEnabled", this, UserIDString), args[0]) + $"</color>");
                    break;
                case "blocked":
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("SwitchBlocked", this, UserIDString), args[0]) + $"</color>");
                    break;
                case "all":
                    if (friendsEnabled)
                    {
                        if (enableCupSharing && toggleCupShare && !pInfo.CS)
                        {
                            pInfo.CS = true;
                            CpSttsFrnd(player, true);
                        }

                        if (enableDoorSharing && toggleDoorShare) pInfo.DS = true;
                        if (enableBoxSharing && toggleBoxShare) pInfo.BS = true;
                        if (enableLockerSharing && toggleLockerShare) pInfo.LS = true;
                        if (enableTurretSharing && toggleTurretShare && !pInfo.TS)
                        {
                            pInfo.TS = true;
                            TrrtSttsFrnd(player, true);
                        }
                    }

                    if (usePermAutoAuth && !permission.UserHasPermission(UserIDString, permAutoAuth) ||
                        !usePermAutoAuth)
                        if (toggleAutoAuth)
                            pInfo.AA = true;
                    if (hasClan)
                    {
                        if (enableCupSharing && toggleClanCupShare && !pInfo.CCS)
                        {
                            pInfo.CCS = true;
                            CpSttsCln(player, true);
                        }

                        if (enableDoorSharing && toggleClanDoorShare) pInfo.CDS = true;
                        if (enableBoxSharing && toggleClanBoxShare) pInfo.CBS = true;
                        if (enableLockerSharing && toggleClanLockerShare) pInfo.CLS = true;
                        if (enableTurretSharing && !clanTurretShareOverride && toggleClanTurretShare && !pInfo.CTS)
                        {
                            pInfo.CTS = true;
                            TrrtSttsCln(player, true);
                        }
                    }

                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("SharedAll", this, UserIDString)) + $"</color>");
                    break;
                case "admin":
                case "adm":
                    if (!GetAdmin(player)) goto default;
                    adminAccessEnabled[player.userID] = !adminAccessEnabled[player.userID];
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        ((bool) adminAccessEnabled[player.userID]
                            ? lang.GetMessage("AdminAccessEnabled", this, UserIDString)
                            : lang.GetMessage("AdminAccessDisabled", this, UserIDString)) + "</color>");
                    if (!adminAccessEnabled[player.userID])
                    {
                        if (!adminsRemainCupAuthed)
                            foreach (uint cup in adminCupboards[player.userID].ToList())
                            {
                                BuildingPrivlidge p = (BuildingPrivlidge) BaseNetworkable.serverEntities.Find(cup);
                                if (p)
                                {
                                    p.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == player.userID);
                                    p.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                                }

                                adminCupboards[player.userID].Remove(cup);
                            }

                        if (!adminsRemainTurretAuthed)
                            foreach (uint turret in adminTurrets[player.userID].ToList())
                            {
                                AutoTurret t = (AutoTurret) BaseNetworkable.serverEntities.Find(turret);
                                if (t)
                                {
                                    t.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == player.userID);
                                    t.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                                }

                                adminTurrets[player.userID].Remove(turret);
                            }
                    }

                    break;
                case "help":
                case "h":
                    if (args.Length != 2)
                    {
                        StringBuilder sbhelp = new StringBuilder();
                        if (!usdCnslInpt.Contains(player.userID))
                            sbhelp.AppendLine($"<size=16><color={prefixColor}>{pluginPrefix}</color></size>");
                        sbhelp.AppendLine(lang.GetMessage("CommandUsage", this, UserIDString) +
                                          $"<color={colorCmdUsage}>/{shareCommand} help option</color>");
                        if (enableCupSharing)
                            sbhelp.AppendLine($"<color={colorCmdUsage}>cups | c</color> - " +
                                              lang.GetMessage("HelpCups", this, UserIDString));
                        if (enableDoorSharing)
                            sbhelp.AppendLine($"<color={colorCmdUsage}>doors | d</color> - " +
                                              lang.GetMessage("HelpDoors", this, UserIDString));
                        if (enableBoxSharing)
                            sbhelp.AppendLine($"<color={colorCmdUsage}>boxes | b</color> - " +
                                              lang.GetMessage("HelpBoxes", this, UserIDString));
                        if (enableLockerSharing)
                            sbhelp.AppendLine($"<color={colorCmdUsage}>lockers | l</color> - " +
                                              lang.GetMessage("HelpLockers", this, UserIDString));
                        if (enableQuarrySharing)
                            sbhelp.AppendLine($"<color={colorCmdUsage}>quarries | q</color> - " +
                                              lang.GetMessage("HelpQuarries", this, UserIDString));
                        if (enableTurretSharing)
                            sbhelp.AppendLine($"<color={colorCmdUsage}>turrets | t</color> - " +
                                              lang.GetMessage("HelpTurrets", this, UserIDString));
                        if (enableAutoAuth)
                            sbhelp.AppendLine($"<color={colorCmdUsage}>autoauth | a</color> - " +
                                              lang.GetMessage("HelpAutoAuth", this, UserIDString));
                        PrintChat(player, $"<color={colorTextMsg}>" + sbhelp.ToString() + "</color>");
                    }
                    else if (args.Length >= 2)
                    {
                        switch (args[1])
                        {
                            case "cups":
                            case "c":
                                PrintChat(player,
                                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                                    lang.GetMessage("DescriptionCups", this, UserIDString) + "</color>");
                                break;
                            case "doors":
                            case "d":
                                PrintChat(player,
                                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                                    lang.GetMessage("DescriptionDoors", this, UserIDString) + "</color>");
                                break;
                            case "boxes":
                            case "b":
                                PrintChat(player,
                                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                                    lang.GetMessage("DescriptionBoxes", this, UserIDString) + "</color>");
                                break;
                            case "lockers":
                            case "l":
                                PrintChat(player,
                                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                                    lang.GetMessage("DescriptionLockers", this, UserIDString) + "</color>");
                                break;
                            case "quarries":
                            case "q":
                                PrintChat(player,
                                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                                    lang.GetMessage("DescriptionQuarries", this, UserIDString) + "</color>");
                                break;
                            case "turrets":
                            case "t":
                                PrintChat(player,
                                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                                    lang.GetMessage("DescriptionTurrets", this, UserIDString) + "</color>");
                                break;
                            case "autoauth":
                            case "a":
                                PrintChat(player,
                                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                                    lang.GetMessage("DescriptionAutoAuth", this, UserIDString) + "</color>");
                                break;
                            default:
                                PrintChat(player,
                                    string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                                    lang.GetMessage("HelpNotAvailable", this, UserIDString) + "</color>");
                                break;
                        }
                    }

                    break;
                default:
                    PrintChat(player,
                        string.Format(prefixFormat, prefixColor, pluginPrefix) + $"<color={colorTextMsg}>" +
                        string.Format(lang.GetMessage("NotSupported", this, UserIDString), args[0]) + $"</color>");
                    break;
            }

            pInfo.BPH?.Reset();
        }

        private void PrintChat(BasePlayer player, string message, bool keepConsole = false)
        {
            if (usdCnslInpt.Contains(player.userID)) player.ConsoleMessage(message);
            else player.ChatMessage(message);
            if (!keepConsole) usdCnslInpt.Remove(player.userID);
        }

        internal class BuildingPrivilegeHandler : FacepunchBehaviour
        {
            private BasePlayer player;
            private ulong userID;
            private BuildingPrivlidge lastPrivilege;
            private uint lastTurretID;
            private object lastTurretResult;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                userID = player.userID;
                Instance.playerPrefs.PlayerInfo[userID].BPH = this;

                if (Instance.enableCupSharing)
                    InvokeRandomized(Repeater, 1f, 1.5f, 0.15f);

                lastTurretResult = null;
                lastTurretID = 0u;
            }

            public void Reset()
            {
                lastPrivilege = null;
                lastTurretID = 0u;
                lastTurretResult = null;
            }

            public bool SameTurret(uint currentID)
            {
                if (currentID == lastTurretID)
                    return true;
                return false;
            }

            public object LastResult()
            {
                return lastTurretResult;
            }

            public void SetTurret(uint currentID, object flag)
            {
                lastTurretID = currentID;
                lastTurretResult = flag;
            }

            private void Repeater()
            {
                if (player == null || !player.IsConnected || player.IsDead())
                {
                    DoDestroy();
                    return;
                }

                if (player.IsSleeping() || player.IsSpectating() || player.IsReceivingSnapshot || Instance.pluginDisabled)
                    return;

                BuildingPrivlidge buildingPrivilege = player.GetBuildingPrivilege();

                if (buildingPrivilege == null || lastPrivilege != null && lastPrivilege == buildingPrivilege)
                    return;

                if (!buildingPrivilege.IsAuthed(player))
                    Instance.CheckCupboardAccess(player, buildingPrivilege);

                lastPrivilege = buildingPrivilege;
            }

            public void DoDestroy()
            {
                CancelInvoke(Repeater);
                Instance.playerPrefs.PlayerInfo[userID].BPH = null;
                Destroy(this);
            }

            private void OnDestroy()
            {
                if (IsInvoking(Repeater))
                    CancelInvoke(Repeater);

                Instance.playerPrefs.PlayerInfo[userID].BPH = null;
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (player != null && (enableCupSharing || enableTurretSharing))
                playerPrefs.PlayerInfo[player.userID].BPH = player.transform.GetOrAddComponent<BuildingPrivilegeHandler>();
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player != null)
            {
                SetPlayer(player);
                if ((enableCupSharing || enableTurretSharing) && player.IsConnected && !player.IsDead())
                    playerPrefs.PlayerInfo[player.userID].BPH = player.transform.GetOrAddComponent<BuildingPrivilegeHandler>();
            }
        }

        private bool HasFriend(ulong owner = 0uL, ulong friend = 0uL)
        {
            if (owner < 76561197960265729uL || friend < 76561197960265729uL) return false;
            if (friendsAPIEnabled)
                return Friends != null && Friends.Call("HasFriend", owner, friend) != null &&
                       (bool) Friends.Call("HasFriend", owner, friend);
            return false;
        }

        private bool HasFriendS(string owner, string friend)
        {
            if (friendsAPIEnabled)
                return Friends != null && Friends.Call("HasFriendS", owner, friend) != null &&
                       (bool) Friends.CallHook("HasFriendS", owner, friend);
            return false;
        }

        private bool SameClan(ulong owner, ulong member)
        {
            object o = Clans.Call("GetClanOf", owner);
            object m = Clans.Call("GetClanOf", member);
            if (o != null && m != null && (string) o == (string) m) return true;
            return false;
        }

        private bool SameClanS(string owner, string member)
        {
            object o = Clans.Call("GetClanOf", owner);
            object m = Clans.Call("GetClanOf", member);
            if (o != null && m != null && (string) o == (string) m) return true;
            return false;
        }

        private void StateDisabled()
        {
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnTurretTarget));
            Unsubscribe(nameof(CanBeTargeted));
            Unsubscribe(nameof(OnEntityBuilt));
            Unsubscribe(nameof(OnCupboardClearList));
            Unsubscribe(nameof(OnCupboardAuthorize));
            Unsubscribe(nameof(OnLootEntity));
            Unsubscribe(nameof(CanUseLockedEntity));
            Unsubscribe(nameof(CanUnlock));
            Unsubscribe(nameof(CanLock));
        }

        private void StateEnabled()
        {
            Subscribe(nameof(OnEntityKill));
            if (enableTurretSharing) Subscribe(nameof(OnTurretTarget));
            if (enableTurretSharing) Subscribe(nameof(CanBeTargeted));
            if (enableAutoAuth) Subscribe(nameof(OnEntityBuilt));
            if (enableCupSharing) Subscribe(nameof(OnCupboardClearList));
            if (enableCupSharing) Subscribe(nameof(OnCupboardAuthorize));
            if (enableQuarrySharing) Subscribe(nameof(OnLootEntity));
            Subscribe(nameof(CanUseLockedEntity));
            Subscribe(nameof(CanUnlock));
            Subscribe(nameof(CanLock));
        }

        private void ClansDisabled()
        {
            Unsubscribe(nameof(OnClanMemberJoined));
            Unsubscribe(nameof(OnClanMemberGone));
            Unsubscribe(nameof(OnClanDisbanded));
        }

        private void ClansEnabled()
        {
            Subscribe(nameof(OnClanMemberJoined));
            Subscribe(nameof(OnClanMemberGone));
            Subscribe(nameof(OnClanDisbanded));
        }
    }
}

// --- End of file: DynamicCupShare.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ScrapVendingExchange.cs ---
// --- Original Local Path: ScrapVendingExchange.cs ---

﻿using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("Scrap Vending Exchange", "Sempai#3239", "1.0.5")]
    [Description("Vending Exchange, exchange scrap for custom currency via any npc vending machine.")]
    public class ScrapVendingExchange : RustPlugin
    {
        #region Fields
        
        private const string PERM_USE = "scrapvendingexchange.use";

        private const string GRANTED_PREFAB = "assets/prefabs/deployable/research table/effects/research-success.prefab";
        private const string DENIED_PREFAB = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";

        private Effect _effectInstance = new Effect();
        private PluginConfig _config;

        #endregion

        #region Config

        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }

                if (_config.ToDictionary().Keys
                    .SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys)) return;

                PrintWarning("Config has been updated.");

                SaveConfig();
            }
            catch
            {
                PrintWarning("Default config loaded.");

                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private class PluginConfig
        {
            [JsonProperty("Item to sell item id")]
            public int SellItemId;
            
            [JsonProperty("Item to sell skin id")]
            public ulong SellSkinId;
            
            [JsonProperty("Min amount to be exchanged")]
            public int MinAmount;

            [JsonProperty("Max amount to be exchanged")]
            public int MaxAmount;

            [JsonProperty("Exchange rate (default payout 80% percent)")]
            public double ExchangeRate;

            [JsonProperty("Deposit command (default Economics arguments {userid} {amount})")]
            public string DepositCommand;

            [JsonProperty("Allowed Machines (allowed prefab names, leave empty for all)")]
            public string[] AllowedMachines = {};

            [JsonProperty("Scrap Ui Position (sets position of the scrap vending ui)")]
            public string[] ScrapUiPosition = { "0.68 0.85", "0.87 0.998" };

            [JsonProperty("Popup Ui Position (sets position of the popup vending ui)")]
            public string[] PopupUiPosition = { "0.085 0.945", "0.905 1" };

            public string ToJson()
                => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary()
                => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    SellItemId = -932201673,
                    SellSkinId = 0UL,
                    MinAmount = 0,
                    MaxAmount = 1000,
                    ExchangeRate = 80.00,
                    DepositCommand = "deposit {userid} {amount}",
                    ScrapUiPosition = new []{ "0.68 0.85", "0.87 0.998" },
                    PopupUiPosition = new []{ "0.085 0.945", "0.905 1" },
                    AllowedMachines = {}
                };
            }
        }

        #endregion
        
        #region Lang

        private const string MESSAGE_INVALID = "MessageInvalid";
        private const string MESSAGE_ENOUGH = "MessageEnough";
        private const string MESSAGE_TITLE = "MessageTitle";
        private const string MESSAGE_AMOUNT = "MessageAmount";
        private const string MESSAGE_EXCHANGED = "MessageExchanged";
        private const string BUTTON_EXCHANGE = "ButtonExchange";
        private const string BUTTON_CLEAR = "ButtonClear";
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {MESSAGE_INVALID, "Please provide a valid amount of scrap to exchange."},
                {MESSAGE_ENOUGH, "You do not have enough scrap for this exchange."},
                {MESSAGE_EXCHANGED, "You successfully exchanged scrap for currency ${0}."},
                {MESSAGE_AMOUNT, "Scrap {0} = ${1}"},
                {MESSAGE_TITLE, "SCRAP EXCHANGE"},
                {BUTTON_EXCHANGE, "EXCHANGE"},
                {BUTTON_CLEAR, "CLEAR"}
            }, this);
        }

        private string GetMessage(string key, string userid = null, params object[] args)
            => string.Format(lang.GetMessage(key, this, userid), args);

        #endregion

        #region Oxide

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PERM_USE, this);
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, EXCHANGE_NAME);
            }

            _effectInstance = null;
        }

        private void OnVendingShopOpened(NPCVendingMachine machine, BasePlayer player)
        {
            if (!HasPermission(player))
                return;

            if (!IsAllowedMachine(machine.PrefabName))
                return;

            CreateUI(player, 0, true);
        }

        private void OnLootEntityEnd(BasePlayer player, NPCVendingMachine machine)
        {
            RemoveUI(player);
        }

        #endregion

        #region CUI

        private const string MAIN_FONT_COLOR = "0.7 0.7 0.7 0.25";
        private const string GREEN_BUTTON_COLOR = "0.337 0.424 0.196 0.4";
        private const string GREEN_BUTTON_FONT_COLOR = "0.607 0.705 0.431";
        private const string GRAY_BUTTON_COLOR = "0.75 0.75 0.75 0.3";
        private const string GRAY_BUTTON_FONT_COLOR = "0.75 0.75 0.75 1";

        private const string INPUT_FONT_COLOR = "1 1 1 0.9";
        private const string INPUT_COLOR = "0 0 0 0.58";

        private const string POPUP_FONT_COLOR = "0 0 0 0.89";
        private const string POPUP_ERROR_COLOR = "0.631 0.282 0.22 0.98";
        private const string POPUP_SUCCESS_COLOR = "0.337 0.424 0.196 0.98";

        private const string EXCHANGE_NAME = "ExchangeUI";
        private const string EXCHANGE_POPUP_NAME = "ExchangeUIPopup";
        private const string EXCHANGE_HEADER_NAME = "ExchangeUIHeader";
        private const string EXCHANGE_CONTENT_NAME = "ExchangeUIContent";

        private void CreateUI(BasePlayer player, int amount = 0, bool isFirst = false)
        {
            CuiElementContainer container = new CuiElementContainer();

            #region First Pass

            if (isFirst)
            {
                CuiHelper.DestroyUi(player, EXCHANGE_NAME);

                container.Add(UiHelpers.Panel("0 0 0 0",
                    _config.ScrapUiPosition[0],
                    _config.ScrapUiPosition[1]), "Hud.Menu", EXCHANGE_NAME);

                container.Add(UiHelpers.Panel(GRAY_BUTTON_COLOR,
                    "0 0.775",
                    "1 1"), EXCHANGE_NAME, EXCHANGE_HEADER_NAME);

                container.Add(UiHelpers.Label(GRAY_BUTTON_FONT_COLOR,
                    "0.051 0",
                    "1 0.95",
                    GetMessage(MESSAGE_TITLE, player.UserIDString)), EXCHANGE_HEADER_NAME);
            }

            #endregion

            #region Content

            CuiHelper.DestroyUi(player, EXCHANGE_CONTENT_NAME);

            container.Add(UiHelpers.Panel("0.65 0.65 0.65 0.25",
                "0 0",
                "1 0.74"), EXCHANGE_NAME, EXCHANGE_CONTENT_NAME);

            #endregion

            #region Buttons

            container.Add(UiHelpers.Button(GREEN_BUTTON_COLOR, GREEN_BUTTON_FONT_COLOR,
                "0.02 0.42",
                "0.47 0.9",
                GetMessage(BUTTON_EXCHANGE, player.UserIDString),
                $"vendingscrapexchange.scrap {amount}"), EXCHANGE_CONTENT_NAME);

            container.Add(UiHelpers.Button(GRAY_BUTTON_COLOR, GRAY_BUTTON_FONT_COLOR,
                "0.49 0.42",
                "0.975 0.9",
                GetMessage(BUTTON_CLEAR, player.UserIDString),
                "vendingscrapexchange.set 0"), EXCHANGE_CONTENT_NAME);

            #endregion

            #region Amount

            container.Add(UiHelpers.Button(GRAY_BUTTON_COLOR, GRAY_BUTTON_FONT_COLOR,
                    "0.02 0.05",
                    "0.07 0.35",
                    "◀",
                    $"vendingscrapexchange.set {Mathf.Clamp(amount - 1, _config.MinAmount, _config.MaxAmount)}"),
                EXCHANGE_CONTENT_NAME);

            container.Add(UiHelpers.Panel(INPUT_COLOR,
                "0.08 0.05",
                "0.92 0.35"), EXCHANGE_CONTENT_NAME);

            container.Add(UiHelpers.Label(MAIN_FONT_COLOR,
                "0.08 0.05",
                "0.92 0.35",
                GetMessage(MESSAGE_AMOUNT, player.UserIDString, amount,
                    (amount / (double) 100 * _config.ExchangeRate))), EXCHANGE_CONTENT_NAME);

            container.Add(UiHelpers.Input(INPUT_FONT_COLOR,
                "0.07 0.05",
                "0.92 0.35",
                "vendingscrapexchange.set", EXCHANGE_CONTENT_NAME));

            container.Add(UiHelpers.Button(GRAY_BUTTON_COLOR, GRAY_BUTTON_FONT_COLOR,
                    "0.92 0.05",
                    "0.975 0.35",
                    "▶",
                    $"vendingscrapexchange.set {Mathf.Clamp(amount + 1, _config.MinAmount, _config.MaxAmount)}"),
                EXCHANGE_CONTENT_NAME);

            #endregion

            CuiHelper.AddUi(player, container);
        }

        private void RemoveUI(BasePlayer player) => CuiHelper.DestroyUi(player, EXCHANGE_NAME);

        private class UiHelpers
        {
            public static CuiPanel Panel(string panelColor, string anchorMin, string anchorMax)
            {
                return new CuiPanel
                {
                    Image = new CuiImageComponent {Color = panelColor},
                    RectTransform = {AnchorMin = anchorMin, AnchorMax = anchorMax}
                };
            }

            public static CuiLabel Label(string textColor, string anchorMin, string anchorMax, string text,
                TextAnchor textAnchor = TextAnchor.MiddleCenter)
            {
                return new CuiLabel
                {
                    RectTransform = {AnchorMin = anchorMin, AnchorMax = anchorMax},
                    Text = {Text = text, Align = textAnchor, Color = textColor, FontSize = 11}
                };
            }

            public static CuiElement Input(string textColor, string anchorMin, string anchorMax, string command,
                string parent, TextAnchor textAnchor = TextAnchor.MiddleCenter)
            {
                return new CuiElement
                {
                    Parent = parent,
                    FadeOut = 1f,
                    Components =
                    {
                        new CuiInputFieldComponent
                            {FontSize = 12, Align = textAnchor, Color = textColor, Command = command,},
                        new CuiRectTransformComponent {AnchorMin = anchorMin, AnchorMax = anchorMax},
                    }
                };
            }

            public static CuiButton Button(string color, string textColor, string anchorMin, string anchorMax,
                string text, string command, TextAnchor textAnchor = TextAnchor.MiddleCenter)
            {
                return new CuiButton
                {
                    RectTransform = {AnchorMin = anchorMin, AnchorMax = anchorMax},
                    Button = {Command = command, Color = color},
                    Text = {Align = textAnchor, Color = textColor, Text = text, FontSize = 11}
                };
            }

            public static void Popup(BasePlayer player, string message, string panelColor, string textColor, string anchorMin, string anchorMax)
            {
                CuiElementContainer container = new CuiElementContainer
                {
                    {Panel(panelColor, anchorMin, anchorMax), "Overlay", EXCHANGE_POPUP_NAME},
                    {Label(textColor, "0 0", "1 1", message), EXCHANGE_POPUP_NAME}
                };

                CuiHelper.DestroyUi(player, EXCHANGE_POPUP_NAME);
                CuiHelper.AddUi(player, container);

                player.Invoke(() => CuiHelper.DestroyUi(player, EXCHANGE_POPUP_NAME), 2f);
            }
        }

        #endregion
        
        #region Currency Command

        private void CurrencyCommand(BasePlayer player, double amount)
        {
            ConsoleSystem.Run(ConsoleSystem.Option.Server,
                _config.DepositCommand
                    .Replace("{userid}", player.UserIDString)
                    .Replace("{amount}", amount.ToString(CultureInfo.InvariantCulture)));
        }

        #endregion

        #region Inventory Methods | Needed To Check For Skinned Scrap

        private bool HasAmount(BasePlayer player, int amount)
            => GetAmount(player.inventory, _config.SellItemId, _config.SellSkinId) >= amount;

        private void TakeAmount(BasePlayer player, int amount)
            => TakeAmount(player.inventory, _config.SellItemId, _config.SellSkinId, amount);

        private int GetAmount(PlayerInventory inventory, int itemid, ulong skinID = 0UL)
        {
            if (itemid == 0)
                return 0;

            int num = 0;

            if (inventory.containerMain != null)
                num += GetAmount(inventory.containerMain, itemid, skinID, true);

            if (inventory.containerBelt != null)
                num += GetAmount(inventory.containerBelt, itemid, skinID, true);

            return num;
        }

        private int GetAmount(ItemContainer container, int itemid, ulong skinID = 0UL, bool usable = false)
        {
            int num = 0;

            foreach (Item obj in container.itemList)
            {
                if (obj.info.itemid == itemid && obj.skin == skinID && (!usable || !obj.IsBusy()))
                    num += obj.amount;
            }

            return num;
        }

        private int TakeAmount(PlayerInventory inventory, int itemid, ulong skinID, int amount)
        {
            int num1 = 0;

            if (inventory.containerMain != null)
            {
                int num2 = TakeAmount(inventory.containerMain, itemid, amount, skinID);
                num1 += num2;
                amount -= num2;
            }

            if (amount <= 0)
                return num1;

            if (inventory.containerBelt != null)
            {
                int num2 = TakeAmount(inventory.containerBelt, itemid, amount, skinID);
                num1 += num2;
            }

            return num1;
        }

        private int TakeAmount(ItemContainer container, int itemid, int amount, ulong skinID)
        {
            int num1 = 0;

            if (amount == 0) 
                return num1;

            List<Item> list = Facepunch.Pool.GetList<Item>();

            foreach (Item obj in container.itemList)
            {
                if (obj.info.itemid != itemid || obj.skin != skinID) continue;

                int num2 = amount - num1;

                if (num2 <= 0) continue;

                if (obj.amount > num2)
                {
                    obj.MarkDirty();
                    obj.amount -= num2;
                    num1 += num2;
                    Item byItemId = ItemManager.CreateByItemID(itemid);
                    byItemId.amount = num2;
                    byItemId.CollectedForCrafting(container.playerOwner);
                    break;
                }

                if (obj.amount <= num2)
                {
                    num1 += obj.amount;

                    list.Add(obj);
                }

                if (num1 == amount)
                    break;
            }

            list.ForEach(obj =>
            {
                if (obj == null) return;
                
                obj.RemoveFromContainer();
                obj.Remove();
            });
            
            ItemManager.DoRemoves();

            Facepunch.Pool.FreeList(ref list);

            return num1;
        }

        #endregion

        #region Commands

        [ConsoleCommand("vendingscrapexchange.set")]
        private void AmountCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (player == null || !IsLootingMachine(player))
                return;
            
            if (!arg.HasArgs())
                return;

            CreateUI(player, arg.GetInt(0), false);
        }

        [ConsoleCommand("vendingscrapexchange.scrap")]
        private void ScrapCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (player == null || !IsLootingMachine(player))
                return;

            if (!arg.HasArgs())
            {
                UiHelpers.Popup(player, GetMessage(MESSAGE_INVALID, player.UserIDString), POPUP_ERROR_COLOR,
                    POPUP_FONT_COLOR, _config.PopupUiPosition[0], _config.PopupUiPosition[1]);
                PlayEffect(player, DENIED_PREFAB);
                return;
            }

            int amount = arg.GetInt(0);

            if (amount <= 0 || !HasAmount(player, amount))
            {
                UiHelpers.Popup(player, GetMessage(MESSAGE_ENOUGH, player.UserIDString), POPUP_ERROR_COLOR,
                    POPUP_FONT_COLOR, _config.PopupUiPosition[0], _config.PopupUiPosition[1]);
                PlayEffect(player, DENIED_PREFAB);
                return;
            }

            TakeAmount(player, amount);

            double exchanged = (amount / (double) 100 * _config.ExchangeRate);

            CurrencyCommand(player, exchanged);

            UiHelpers.Popup(player, GetMessage(MESSAGE_EXCHANGED, player.UserIDString, exchanged), POPUP_SUCCESS_COLOR,
                GREEN_BUTTON_FONT_COLOR, _config.PopupUiPosition[0], _config.PopupUiPosition[1]);
            PlayEffect(player, GRANTED_PREFAB);

            CreateUI(player, 0, false);
        }

        #endregion
        
        #region Helpers

        private bool HasPermission(BasePlayer player)
            => permission.UserHasPermission(player.UserIDString, PERM_USE);

        private bool IsAllowedMachine(string prefab)
            => _config.AllowedMachines.Length == 0 || _config.AllowedMachines.Contains(prefab);

        private bool IsLootingMachine(BasePlayer player)
        {
            NPCVendingMachine machine = player.inventory.loot.entitySource as NPCVendingMachine;

            return machine != null && IsAllowedMachine(machine.PrefabName);
        }

        private void PlayEffect(BasePlayer player, string prefabPath)
        {
            if (player?.Connection == null)
                return;

            _effectInstance.Init(Effect.Type.Generic, player.ServerPosition, Vector3.zero);
            _effectInstance.pooledString = prefabPath;
            EffectNetwork.Send(_effectInstance, player.Connection);
            _effectInstance.Clear();
        }

        #endregion
    }
}

// --- End of file: ScrapVendingExchange.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InvFoundation.cs ---
// --- Original Local Path: InvFoundation.cs ---

using System;
using Rust;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("InvFoundation", "sami37", "1.1.0", ResourceId = 2096)]
    [Description("Invulnerable foundation")]
    public class InvFoundation : RustPlugin
    {
        #region Building Owners Support
        [PluginReference("BuildingOwners")]
        Plugin BuildingOwners;
        #endregion

        #region Building Owners Support
        [PluginReference("EntityOwner")]
        Plugin EntityOwner;
        #endregion

        private Dictionary<string, object> damageList => GetConfig("DamageList", defaultDamageScale()); 
        private bool UseEntityOwner => GetConfig("UseEntityOwner", false);
        private bool UseBuildOwners => GetConfig("UseBuildingOwner", false);
        private bool UseDamageScaling => GetConfig("UseDamageScaling", false);
        static int colisionentity = LayerMask.GetMask("Construction");
        private readonly int cupboardMask = LayerMask.GetMask("Trigger");
        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

		static Dictionary<string,object> defaultDamageScale()
		{
			var dp = new Dictionary<string, object>();
            dp.Add("Bullet", 0.0);
            dp.Add("Blunt", 0.0);
            dp.Add("Stab", 0.0);
            dp.Add("Slash", 0.0);
            dp.Add("Explosion", 0.0);

			return dp;
		}


        void Loaded()
        {
            Config["UseBuildingOwner"] = UseBuildOwners;
            Config["UseEntityOwner"] = UseEntityOwner;
            Config["UseDamageScaling"] = UseDamageScaling;
            Config["DamageList"] = damageList;
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
            SaveConfig();
        }

        private void OnServerInitialized()
        {
            Config["DamageList"] = damageList;
            SaveConfig();
            var messages = new Dictionary<string, string>
            {
				{"NoPerm", "You don't have permission to do this."}
            };
            lang.RegisterMessages(messages, this);
        }
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null)
                return;

            if (entity is BuildingBlock)
            {
                BuildingBlock block = entity as BuildingBlock;
                if (block == null) return;
                if (hitInfo.Initiator == null) return;
                BasePlayer attacker = hitInfo.Initiator.ToPlayer();
                if (attacker == null) return;


                if (block.LookupPrefab().name.Contains("foundation") && !IsOwner(attacker, block) && !CupboardPrivlidge(attacker, block.transform.position))
                {
                    if (!UseDamageScaling)
                    {
                        hitInfo.damageTypes = new DamageTypeList();
                        hitInfo.DoHitEffects = false;
                        hitInfo.HitMaterial = 0;
                        SendReply(attacker, lang.GetMessage("NoPerm", this, attacker.UserIDString));
                        return;
                    }
                    DamageType type = hitInfo.damageTypes.GetMajorityDamageType();
                    object modifier;
                    float mod = 0;
                    if (damageList.TryGetValue(type.ToString(), out modifier))
                    {
                        mod = Convert.ToSingle(modifier);
                        if (mod != 0)
                        {
                            hitInfo.damageTypes.Scale(type, mod);
                        }
                        else
                        {
                            hitInfo.damageTypes = new DamageTypeList();
                            hitInfo.DoHitEffects = false;
                            hitInfo.HitMaterial = 0;
                            SendReply(attacker, lang.GetMessage("NoPerm", this, attacker.UserIDString));
                        }
                    }
                }
            }
        }

        bool IsOwner(BasePlayer player, BaseEntity targetEntity)
        {
            if (targetEntity == null) return false;
            if (targetEntity.OwnerID == player.userID) return true;
            BuildingBlock block = targetEntity.GetComponent<BuildingBlock>();
            if (block == null)
            {
                RaycastHit supportHit;
                if (Physics.Raycast(targetEntity.transform.position + new Vector3(0f, 0.1f, 0f), new Vector3(0f, -1f, 0f), out supportHit, 3f, colisionentity))
                {
                    BaseEntity supportEnt = supportHit.GetEntity();
                    if (supportEnt != null)
                    {
                        block = supportEnt.GetComponent<BuildingBlock>();
                    }
                }
            }
            if (block != null)
            {
				if (UseBuildOwners)
				{
					if (BuildingOwners != null && BuildingOwners.IsLoaded)
					{
                        var returnhook = Interface.GetMod().CallHook("FindBlockData", new object[] {block});
                        if (returnhook is string)
                        {
                            string ownerid = (string) returnhook;
                            if (player.UserIDString == ownerid) return true;
                        }
                    }
                }
				if (UseEntityOwner)
				{
					if (EntityOwner != null && EntityOwner.IsLoaded)
					{
                        var returnhook = Interface.GetMod().CallHook("FindEntityData", new object[] {targetEntity});
                        if (returnhook is string)
                        {
                            string ownerid = (string) returnhook;
                            if (player.UserIDString == ownerid) return true;
                        }
                    }
                }
            }
            return false;
        }
        private bool CupboardPrivlidge(BasePlayer player, Vector3 position)
        {
            var hits = Physics.OverlapSphere(position, 2f, cupboardMask);
            foreach (var collider in hits)
            {
                var buildingPrivlidge = collider.GetComponentInParent<BuildingPrivlidge>();
                if (buildingPrivlidge == null) continue;

                List<string> ids = (from id in buildingPrivlidge.authorizedPlayers select id.userid.ToString()).ToList();
                foreach (string priv in ids)
                {
                    if (priv == player.UserIDString)
                    {
                        return true;
                    }
                }        
            }
            return false;
        }

    }
}

// --- End of file: InvFoundation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DVMenu.cs ---
// --- Original Local Path: DVMenu.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DVMenu", "ClayMond", "0.0.5")]
    [Description("Спасибо за покупку - by russia-oxide.ru")]
    class DVMenu : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin ImageLibrary;
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);

        #endregion

        #region Vars
        public List<BasePlayer> IsOpenMenu = new List<BasePlayer>();
        public List<string> ActiveEvent = new List<string>();
        #endregion

        #region Configuration


        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройки плагина")]
            public SettingsPlugin SettingPlugin = new SettingsPlugin();

            internal class SettingsPlugin
            {
                [JsonProperty("Настройка иконки в панели")]
                public string PNG;
                [JsonProperty("Настройка логотипа в панели")]
                public string Logo;
                [JsonProperty("Командая при нажатие на логотип")]
                public string Bind;
                [JsonProperty("HEX Цвет панели")]
                public string HexColorPanel;
				[JsonProperty("HEX Цвет текста панели")]
				public string TextColorPanel;
                [JsonProperty("Интервал обновления информационной панели")]
                public int IntervalUpdateInfoPanel;
                [JsonProperty("Интервал обновления ивентов")]
                public int IntervalUpdateEvents;

            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    SettingPlugin = new SettingsPlugin
                    {
                        HexColorPanel = "#FFFFFF",
						TextColorPanel = "#FFFFFF",
                        IntervalUpdateInfoPanel = 5,
                        IntervalUpdateEvents = 5,
						Bind = "chat.say /info",
						Logo = "https://i.ibb.co/6Fzdntv/wolf.png",
                        PNG = "https://i.ibb.co/D74C9sZ/PHTlu4K.png",
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region UI

        #region Parent
        public static string INTERFACE_PARENT_PANEL = "INTERFACE_MENU_PARENT_PANEL";
		public static string LOGO_PANEL = "LOGO_PANEL";
        #endregion

        void OnPlayerConnected(BasePlayer player)
        {
            UI_Panel_Interface(player);
			LOGO_UI(player);
        }


        void UI_Panel_Interface(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, INTERFACE_PARENT_PANEL);
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-200 -50", OffsetMax = "-3 -3" },
                Image = { Color = "0 0 0 0" }
            }, "Hud", INTERFACE_PARENT_PANEL);

            container.Add(new CuiElement
            {
                Parent = INTERFACE_PARENT_PANEL,
                Name = "Joined",
                Components = {
                        new CuiImageComponent {
                            Png = GetImage("PNG_PANEL"),
                            Color = HexToRustFormat(config.SettingPlugin.HexColorPanel),
							
                        },
                        new CuiRectTransformComponent { AnchorMin = "0.7700684 0.07777759", AnchorMax = "0.9768711 0.922222" }
                    },
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1" },
                Text = { Text = $"<size=9>ЗАХОДЯТ</size>\n<size=16>{SingletonComponent<ServerMgr>.Instance.connectionQueue.Joining}</size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(config.SettingPlugin.TextColorPanel) }
            }, "Joined");

            container.Add(new CuiElement
            {
                Parent = INTERFACE_PARENT_PANEL,
                Name = "Sleepers",
                Components = {
                        new CuiImageComponent {
                            Png = GetImage("PNG_PANEL"),
							Color = HexToRustFormat(config.SettingPlugin.HexColorPanel),
                        },
                        new CuiRectTransformComponent { AnchorMin = "0.5390563 0.07777759", AnchorMax = "0.745859 0.922222" }
                    },
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1" },
                Text = { Text = $"<size=9>СПЯЩИЕ</size>\n<size=16>{BasePlayer.sleepingPlayerList.Count.ToString()}</size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(config.SettingPlugin.TextColorPanel) }
            }, "Sleepers");

            container.Add(new CuiElement
            {
                Parent = INTERFACE_PARENT_PANEL,
                Name = "Online",
                Components = {
                        new CuiImageComponent {
                            Png = GetImage("PNG_PANEL"),
							Color = HexToRustFormat(config.SettingPlugin.HexColorPanel),
                        },
                        new CuiRectTransformComponent { AnchorMin = "0.3074842 0.07777759", AnchorMax = "0.514289 0.922222" }
                    },
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1" },
                Text = { Text = $"<size=9>ОНЛАЙН</size>\n<size=16>{BasePlayer.activePlayerList.Count.ToString()}</size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(config.SettingPlugin.TextColorPanel) }
            }, "Online");

            CuiHelper.AddUi(player, container);
        }

 		void LOGO_UI(BasePlayer player)
		{
            CuiElementContainer container = new CuiElementContainer();
			CuiHelper.DestroyUi(player, LOGO_PANEL);
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "10 -77", OffsetMax = "80 -8" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", LOGO_PANEL);
			
            container.Add(new CuiElement
            {
                Parent = LOGO_PANEL,
                Name = "LogoURL",
                Components = {
                        new CuiImageComponent {
                            Png = GetImage("LOGO_PANEL"),
							Color = "1 1 1 1",
							Material = "assets/icons/greyout.mat",
                        },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1.1" }
                    },
            });
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = config.SettingPlugin.Bind },
                Text = { Text = "" }
            }, LOGO_PANEL);
			
			CuiHelper.AddUi(player, container);
		}
 
        #endregion


        #region Hooks
        private void OnServerInitialized()
        {
			
			Puts("Спасибо за покупку плагина");
			Puts("Thank you for purchasing the plugin");
			
            LoadImage();

            timer.Every(config.SettingPlugin.IntervalUpdateInfoPanel, () =>
            {
				foreach(var player in BasePlayer.activePlayerList)
				    LOGO_UI(player);
            });

            timer.Every(config.SettingPlugin.IntervalUpdateInfoPanel, () =>
            {
				foreach(var player in BasePlayer.activePlayerList)
				    UI_Panel_Interface(player);
            });
            
			foreach(var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        } 

        #endregion

        #region HelpMetods
        private static string HexToRustFormat(string hex)
        {
            UnityEngine.Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        void LoadImage()
        {

            AddImage(config.SettingPlugin.PNG, "PNG_PANEL");
			AddImage(config.SettingPlugin.Logo, "LOGO_PANEL");
        }

        #endregion
    }
}


// --- End of file: DVMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VitalKillFeed-1.0.3.cs ---
// --- Original Local Path: VitalKillFeed-1.0.3.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("VitalKillFeed", "Xonafied", "1.0.3")]
    [Description("Vital kill feed msgs")]

    public class VitalKillFeed : CovalencePlugin
    {
        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["killmsg"] = "<color=#C57039>[KillFeed]</color> {0} killed you from {1} meters away with a {2}",
                ["killmsg2"] = "<color=#C57039>[KillFeed]</color> You killed {0} from {1} meters away",
                ["killtoggle"] = "Kill feed messages are now {0}"
            }, this);
        }

        #endregion Localization

        private static readonly string permhide = "rustxkillfeed.hide";

        #region Hooks

        void OnServerInitialized()
        {
            //Register Perms
            permission.RegisterPermission(permhide, this);
            AddCovalenceCommand("kf", "ToggleDeathMsgs");
        }

        void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (player == null || player.IsNpc) return;

            var customInfo = new CustomInfo
            {
                info = info,
                weapon = info.Weapon.ShortPrefabName
            };

            var initiatorPlayer = info.InitiatorPlayer;
            if (initiatorPlayer != null && !initiatorPlayer.IsNpc)
            {
                customInfo.weapon = initiatorPlayer.GetActiveItem()?.info.displayName.english ?? customInfo.weapon;
                SendHitInfoData(initiatorPlayer, customInfo, player);
            }

            if (_deathData.TryGetValue(player.userID, out CustomInfo existingInfo))
            {
                existingInfo = customInfo;
            }
            else
            {
                _deathData.Add(player.userID, customInfo);
            }
        }


        void OnPlayerRespawn(BasePlayer player, BasePlayer.SpawnPoint spawnPoint) => SendHitInfoData(player);

        void OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag) => SendHitInfoData(player);

        #endregion

        #region Methods
        private Dictionary<ulong, CustomInfo> _deathData = new Dictionary<ulong, CustomInfo>();

        public struct CustomInfo
        {
            public HitInfo info;
            public string weapon;
        }
        private void SendHitInfoData(BasePlayer player)
        {
            if (!_deathData.TryGetValue(player.userID, out CustomInfo custominfo))
                return;

            if (HasPerm(player.UserIDString, permhide))
                return;

            string killerName = custominfo.info.InitiatorPlayer?.displayName ?? "Unknown";
            double dist = Math.Round(custominfo.info.ProjectileDistance, 0);

            player.Invoke(() => {
                ChatMessage(player.IPlayer, "killmsg", killerName, dist, custominfo.weapon);
            }, 0.3f);
        }

        private void SendHitInfoData(BasePlayer player, CustomInfo custominfo, BasePlayer killed)
        {
            if (HasPerm(player.UserIDString, permhide))
                return;

            double dist = Math.Round(custominfo.info.ProjectileDistance, 0);

            ChatMessage(player.IPlayer, "killmsg2", killed.displayName, dist);
        }

        #endregion Methods

        #region Commands
        private void ToggleDeathMsgs(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer? player = iplayer.Object as BasePlayer;
            if (player == null) return;

            if (!HasPerm(player.UserIDString, permhide))
            {
                permission.GrantUserPermission(player.UserIDString, permhide, this);
                ChatMessage(iplayer, "killtoggle", "disabled");
                return;
            }

            permission.RevokeUserPermission(player.UserIDString, permhide);
            ChatMessage(iplayer, "killtoggle", "enabled");
        }
        #endregion

        #region Helpers
        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }
        private void ChatMessage(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected)
                player.Message(GetLang(langKey, player.Id, args));
            else Puts(GetLang(langKey, player.Id, args));
        }
        #endregion Helpers
    }
}

// --- End of file: VitalKillFeed-1.0.3.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomNPC.cs ---
// --- Original Local Path: CustomNPC.cs ---

﻿using Facepunch;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityEngine.AI;

namespace Oxide.Plugins
{
    [Info("CustomNPC", "k1lly0u", "1.2.2")]
    class CustomNPC : RustPlugin
    {
        #region Fields
        [PluginReference] private Plugin Kits;

        private Hash<Plugin, List<HumanAI>> _humanAIRef = new Hash<Plugin, List<HumanAI>>();

        private static CustomNPC Instance;
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            Instance = this;
        }

        private void OnEntityKill(ScientistNPC scientistNpc)
        {
            if (scientistNpc == null)
                return;

            HumanAI humanAI = scientistNpc.GetComponent<HumanAI>();
            if (humanAI == null)
                return;

            foreach (KeyValuePair<Plugin, List<HumanAI>> kvp in _humanAIRef)
                kvp.Value.Remove(humanAI);

            UnityEngine.Object.Destroy(humanAI);
        }

        private object OnNpcTarget(ScientistNPC scientistNpc, BasePlayer target)
        {
            if (scientistNpc == null)
                return null;

            HumanAI humanAI = scientistNpc.GetComponent<HumanAI>();
            if (humanAI == null)
                return null;

            if (target.IsSleeping() || target.IsFlying)
                return true;

            return null;
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            List<HumanAI> list;
            if (_humanAIRef.TryGetValue(plugin, out list))
            {
                for (int i = list.Count - 1; i >= 0; i--)
                {
                    HumanAI humanAI = list[i];
                    if (humanAI != null)
                        humanAI.Despawn();
                }

                _humanAIRef.Remove(plugin);
            }
        }

        private void Unload()
        {
            foreach (KeyValuePair<Plugin, List<HumanAI>> kvp in _humanAIRef)
            {
                for (int i = kvp.Value.Count - 1; i >= 0; i--)
                {
                    HumanAI humanAI = kvp.Value[i];
                    if (humanAI != null)
                        humanAI.Despawn();
                }
            }

            _humanAIRef.Clear();

            Instance = null;
        }
        #endregion

        #region Functions        
        private HumanAI CreateHumanAI(Vector3 position, Settings settings)
        {
            object point = settings.EnableNavMesh ? FindPointOnNavmesh(position, 60) : position;
            if (point is Vector3)
            {
                position = (Vector3)point;

                if (settings.EnableNavMesh && (position.y < -0.25f || (settings.KillInSafeZone && IsInSafeZone(position))))
                    return null;

                const string SCIENTIST_PREFAB = "assets/rust.ai/agents/npcplayer/humannpc/heavyscientist/heavyscientist.prefab";

                ScientistNPC npcPlayer = InstantiateEntity(SCIENTIST_PREFAB, position);
                npcPlayer.enableSaving = false;

                BaseAIBrain<global::HumanNPC> defaultBrain = npcPlayer.GetComponent<BaseAIBrain<global::HumanNPC>>();
                defaultBrain._baseEntity = npcPlayer;
                UnityEngine.Object.DestroyImmediate(defaultBrain);

                HumanAI humanAI = npcPlayer.gameObject.AddComponent<HumanAI>();
                npcPlayer._brain = humanAI.Brain = npcPlayer.gameObject.AddComponent<CustomAIBrain>();

                npcPlayer.Spawn();

                humanAI.Setup(settings);

                return humanAI;
            }

            return null;
        }

        private HumanAI ConvertHumanAI(ScientistNPC scientistNPC, Settings settings)
        {
            Vector3 position = scientistNPC.transform.position;
            object point = FindPointOnNavmesh(position, 60);
            if (point is Vector3)
            {
                position = (Vector3)point;

                if (position.y < -0.25f || (settings.KillInSafeZone && IsInSafeZone(position)))
                    return null;

                HumanAI humanAI = scientistNPC.gameObject.AddComponent<HumanAI>();
                humanAI.Setup(settings);

                return humanAI;
            }

            return null;
        }

        private static ScientistNPC InstantiateEntity(string type, Vector3 position)
        {
            GameObject gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, Quaternion.identity);
            gameObject.name = type;

            UnityEngine.SceneManagement.SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            ScientistNPC component = gameObject.GetComponent<ScientistNPC>();
            return component;
        }

        private static bool IsInSafeZone(Vector3 position)
        {
            int count = Physics.OverlapSphereNonAlloc(position, 1f, Vis.colBuffer, 1 << 18, QueryTriggerInteraction.Collide);
            for (int i = 0; i < count; i++)
            {
                Collider collider = Vis.colBuffer[i];
                if (collider.GetComponent<TriggerSafeZone>())
                    return true;
            }

            return false;
        }

        private static void StripInventory(BasePlayer player, bool skipWear = false)
        {
            Item[] allItems = player.inventory.AllItems();

            for (int i = allItems.Length - 1; i >= 0; i--)
            {
                Item item = allItems[i];
                if (skipWear && item?.parent == player.inventory.containerWear)
                    continue;

                item.RemoveFromContainer();
                item.Remove();
            }
        }
        #endregion

        #region API
        /// <summary>
        /// Spawns a new ScientistNPC and add's a HumanAI component on top
        /// </summary>
        /// <param name="plugin">The plugin the NPC belongs to</param>
        /// <param name="position">The spawn position</param>
        /// <param name="settingsJson">The settings JObject</param>
        /// <returns></returns>
        private ScientistNPC SpawnNPC(Plugin plugin, Vector3 position, JObject settingsJson)
        {
            if (Rust.Ai.AiManager.nav_disable)
            {
                Debug.LogWarning($"[CustomNPC] - NPC's can not be spawned when the Navmesh is disabled!\nYou can turn it on with the 'aimanager.nav_disable false' convar");
                return null;
            }

            Settings settings = settingsJson.ToObject<Settings>();

            HumanAI npc = CreateHumanAI(position, settings);
            if (npc == null)
                return null;

            List<HumanAI> list;
            if (!_humanAIRef.TryGetValue(plugin, out list))
                list = _humanAIRef[plugin] = new List<HumanAI>();

            list.Add(npc);

            return npc.Entity;
        }

        /// <summary>
        /// Converts an already spawned ScientistNPC to a HumanAI
        /// </summary>
        /// <param name="plugin">The plugin the NPC belongs to</param>
        /// <param name="scientistNPC">The target NPC</param>
        /// <param name="settingsJson">The settings JObject</param>
        /// <returns></returns>
        private bool ConvertNPC(Plugin plugin, ScientistNPC scientistNPC, JObject settingsJson)
        {
            Settings settings = settingsJson.ToObject<Settings>();

            HumanAI npc = ConvertHumanAI(scientistNPC, settings);
            if (npc == null)
                return false;

            List<HumanAI> list;
            if (!_humanAIRef.TryGetValue(plugin, out list))
                list = _humanAIRef[plugin] = new List<HumanAI>();

            list.Add(npc);

            return true;
        }

        /// <summary>
        /// Allows plugins to add a custom AI state to the NPC
        /// </summary>
        /// <param name="scientistNPC">The target NPC</param>
        /// <param name="state">The custom AI state</param>
        /// <returns>true if successfull, false if not</returns>
        private bool AddCustomAIState(ScientistNPC scientistNPC, BaseAIBrain<global::HumanNPC>.BasicAIState state)
        {
            HumanAI humanAI = scientistNPC.GetComponent<HumanAI>();
            if (humanAI != null)
            {
                humanAI.Brain.AddState(state);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Set the base position the NPC will roam around
        /// </summary>
        /// <param name="scientistNPC">The target NPC</param>
        /// <param name="position">The base roam position</param>
        private void SetRoamHomePosition(ScientistNPC scientistNPC, Vector3 position)
        {
            HumanAI humanAI = scientistNPC.GetComponent<HumanAI>();
            if (humanAI != null)
            {
                object point = FindPointOnNavmesh(position, 20);
                if (point is Vector3)
                    position = (Vector3)point;
                
                humanAI._roamBasePosition = position;
            }
        }

        /// <summary>
        /// Enables the NPC's NavMeshAgent
        /// </summary>
        /// <param name="scientistNPC">The target NPC</param>
        /// <returns></returns>
        private bool EnableNavAgent(ScientistNPC scientistNPC)
        {
            HumanAI humanAI = scientistNPC.GetComponent<HumanAI>();
            if (humanAI != null)
            {
                object point = FindPointOnNavmesh(scientistNPC.transform.position, 20);
                if (point is Vector3)
                {
                    Vector3 position = (Vector3)point;
                    scientistNPC.NavAgent.Warp(position);
                    scientistNPC.NavAgent.enabled = true;
                    scientistNPC.transform.position = position;

                    humanAI._NavMeshEnabled = true;
                    humanAI.NavMeshEnabled = true;

                    scientistNPC.NavAgent.isStopped = false;
                    humanAI.SetDestination(position);

                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Force the NPC to equip their weapon
        /// </summary>
        /// <param name="scientistNPC">The target NPC</param>
        /// <returns></returns>
        private void EquipWeapon(ScientistNPC scientistNPC)
        {
            HumanAI humanAI = scientistNPC.GetComponent<HumanAI>();
            if (humanAI != null)
                humanAI.EquipWeapon();
        }

        /// <summary>
        /// Force the NPC to holster their weapon
        /// </summary>
        /// <param name="scientistNPC">The target NPC</param>
        /// <returns></returns>
        private void HolsterWeapon(ScientistNPC scientistNPC)
        {
            HumanAI humanAI = scientistNPC.GetComponent<HumanAI>();
            if (humanAI != null)
                humanAI.HolsterWeapon();
        }

        /// <summary>
        /// Send the NPC to the target destination (requires the MoveToDestination state)
        /// </summary>
        /// <param name="scientistNPC">The target NPC</param>
        /// <param name="destination">The destination</param>
        /// <param name="speed">The speed at which they will move towards the destination</param>
        /// <param name="onReachedDestination">A callback for once they have reached the destination</param>
        private void SetDestination(ScientistNPC scientistNPC, Vector3 destination, global::HumanNPC.SpeedType speed, Action onReachedDestination)
        {
            HumanAI humanAI = scientistNPC.GetComponent<HumanAI>();
            if (humanAI != null)
                humanAI.SetDestination(destination, speed, onReachedDestination);
        }
        #endregion

        #region Settings
        /// <summary>
        /// This the the settings class. The JObject passed through the hook will be converted to this class structure
        /// </summary>
        internal class Settings
        {
            public List<string> States = new List<string>(); // The logic states to apply to the NPC


            public string NPCType; // The type of NPC (Scientist, Murderer, HeavyScientist)

            public string DisplayName; // The name of the NPC

            public float Health; // The NPCs initial health


            public float SightRange; // The NPCs sight range

            public float RoamRange; // The maximum distance from it's spawn point the NPC will roam      

            public float ChaseRange; // The distance from it's spawn point the NPC will chase a target to      


            public string Kit; // The kit to give the NPC

            public bool StripCorpseLoot; // Removes the NPC corpse loot table


            public bool KillInSafeZone; // Kill the NPC if they enter a safe zone, prevent spawn if in a safe zone

            public float DespawnTime; // Despawn the NPC after this amount of time (seconds)


            public bool StartDead; // Spawn the NPC dead

            public bool StartWounded; // NPC spawns in a wounded state

            public float WoundedDuration; // The amount of time the NPC will be in the wounded state before attempting to recover

            public float WoundedRecoveryChance; // The chance the NPC will recover from the wounded state (0.0 - 100.0)


            public bool EnableNavMesh = true; // Enables the NavMeshAgent component on spawn

            public bool EquipWeapon = true; // Equips a weapon on spawn

            public bool CanUseWeaponMounted; // Can equip a weapon whilst mounted
        }
        #endregion

        #region NavMesh
        private static NavMeshHit navmeshHit;

        private static RaycastHit raycastHit;

        private static Collider[] _buffer = new Collider[256];

        private const int WORLD_LAYER = 65536;

        internal static object FindPointOnNavmesh(Vector3 targetPosition, float maxDistance = 4f)
        {
            for (int i = 0; i < 10; i++)
            {
                Vector3 position = i == 0 ? targetPosition : targetPosition + (UnityEngine.Random.onUnitSphere * (maxDistance * 0.5f));
                if (NavMesh.SamplePosition(position, out navmeshHit, maxDistance * 0.5f, 1))
                {
                    if (IsInRockPrefab(navmeshHit.position))
                        continue;

                    if (IsNearWorldCollider(navmeshHit.position))
                        continue;

                    return navmeshHit.position;
                }
            }
            return null;
        }

        private static bool IsInRockPrefab(Vector3 position)
        {
            Physics.queriesHitBackfaces = true;

            bool isInRock = Physics.Raycast(position, Vector3.up, out raycastHit, 20f, WORLD_LAYER, QueryTriggerInteraction.Ignore) &&
                            blockedColliders.Any(s => raycastHit.collider?.gameObject?.name.Contains(s) ?? false);

            Physics.queriesHitBackfaces = false;

            return isInRock;
        }

        private static bool IsNearWorldCollider(Vector3 position)
        {
            Physics.queriesHitBackfaces = true;

            int count = Physics.OverlapSphereNonAlloc(position, 2f, _buffer, WORLD_LAYER, QueryTriggerInteraction.Ignore);
            Physics.queriesHitBackfaces = false;

            int removed = 0;
            for (int i = 0; i < count; i++)
            {
                if (acceptedColliders.Any(s => _buffer[i].gameObject.name.Contains(s)))
                    removed++;
            }

            return removed != count;
        }

        private static string[] acceptedColliders = new string[] { "road", "rocket_factory", "train_track", "runway", "_grounds", "concrete_slabs", "office", "industrial", "junkyard" };

        private static string[] blockedColliders = new string[] { "rock", "junk", "range", "invisible" };
        #endregion

        #region NPC Component
        public class HumanAI : MonoBehaviour
        {
            internal ScientistNPC Entity { get; private set; }

            internal Transform Transform { get; private set; }

            internal CustomAIBrain Brain { get; set; }


            internal AttackEntity _attackEntity;

            internal Vector3 _roamBasePosition;

            internal Settings _settings;

            internal bool HasHomePosition { get; private set; }

            internal float DistanceFromBase => Vector3.Distance(Transform.position, _roamBasePosition);

            internal bool _NavMeshEnabled
            {
                get
                {
                    return (bool)typeof(global::HumanNPC).GetField("navmeshEnabled", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance).GetValue(Entity);
                }
                set
                {
                    typeof(global::HumanNPC).GetField("navmeshEnabled", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance).SetValue(Entity, value);
                }
            }

            internal bool NavMeshEnabled { get; set; }

            private const int AREA_MASK = 1;

            private const int AGENT_TYPE_ID = -1372625422;

            private void Awake()
            {
                Entity = GetComponent<ScientistNPC>();
                Transform = Entity.transform;

                _roamBasePosition = Transform.position;
            }

            private void Start()
            {
                //Destroy(GetComponent<HumanBrain>());
                //Entity._brain = Brain = gameObject.AddComponent<CustomAIBrain>();
                //Brain.UseAIDesign = false;
            }

            internal void Setup(Settings settings)
            {
                this._settings = settings;

                Entity.CancelInvoke(Entity.EnableNavAgent);
                Entity.CancelInvoke(Entity.EquipTest);                

                if (settings.StripCorpseLoot)
                    Entity.LootSpawnSlots = new LootContainer.LootSpawnSlot[0];

                if (!string.IsNullOrEmpty(settings.DisplayName))
                    Entity.displayName = settings.DisplayName;

                if (settings.StartDead)
                {
                    UpdateGear();
                    Entity.Invoke(Die, 1f);
                    return;
                }

                if (settings.SightRange != 0f)
                {
                    Entity.sightRange = settings.SightRange;
                    Entity.sightRangeLarge = settings.SightRange * 3;
                }

                Entity.NavAgent.areaMask = AREA_MASK;
                Entity.NavAgent.agentTypeID = AGENT_TYPE_ID;

                if (settings.EnableNavMesh)
                    Entity.Invoke(EnableNavAgent, 0.25f);

                if (settings.Health != 0f)
                    Entity.InitializeHealth(settings.Health, settings.Health);

                if (settings.DespawnTime != 0f)
                    Entity.Invoke(Despawn, settings.DespawnTime);

                UpdateGear();

                if (settings.StartWounded)
                    Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, true);
                else
                {
                    if (settings.EquipWeapon)
                        Entity.Invoke(EquipWeapon, 0.25f);
                }

                if (_settings.NPCType.Equals("Murderer"))
                {
                    Entity.DeathEffects = ZombieDeathEffects;
                    Entity.RadioChatterEffects = ZombieChatterEffects;
                    Entity.IdleChatterRepeatRange = new Vector2(10f, 15f);
                }

                Entity.InvokeRandomized(UpdateTick, 1f, 4f, 1f);
            }

            internal void AddStates()
            {
                Brain.ClearStates();

                for (int i = 0; i < _settings.States.Count; i++)
                {
                    string state = _settings.States[i];

                    switch (state)
                    {
                        case "IdleState":
                            Brain.AddState(new CustomAIBrain.IdleState(this));
                            break;
                        case "RoamState":
                            Brain.AddState(new CustomAIBrain.RoamState(this, _settings.RoamRange));
                            break;
                        case "ChaseState":
                            Brain.AddState(new CustomAIBrain.ChaseState(this, _settings.ChaseRange));
                            break;
                        case "CombatState":
                            Brain.AddState(new CustomAIBrain.CombatState(this, _settings.ChaseRange));
                            break;
                        case "MountedState":
                            Brain.AddState(new CustomAIBrain.MountedState(this, _settings.CanUseWeaponMounted));
                            break;
                        case "MoveDestinationState":
                            Brain.AddState(new CustomAIBrain.MoveDestinationState(this));
                            break;
                        case "FallingState":
                            Brain.AddState(new CustomAIBrain.FallingState(this));
                            break;
                        default:
                            break;
                    }
                }

                if (_settings.StartWounded && _settings.WoundedDuration != 0f)
                    Brain.AddState(new CustomAIBrain.WoundedState(this, _settings.WoundedDuration, _settings.WoundedRecoveryChance));
            }

            private void UpdateGear()
            {
                if (!string.IsNullOrEmpty(_settings.Kit))
                {
                    StripInventory(Entity);
                    Instance.Kits?.Call("GiveKit", Entity, _settings.Kit);
                }
                else
                {
                    if (_settings.NPCType == "Murderer")
                    {
                        StripInventory(Entity);

                        ItemManager.CreateByName("halloween.surgeonsuit").MoveToContainer(Entity.inventory.containerWear);
                        ItemManager.CreateByName("gloweyes").MoveToContainer(Entity.inventory.containerWear);
                        ItemManager.CreateByName("machete").MoveToContainer(Entity.inventory.containerBelt);
                    }
                    else if (_settings.NPCType == "Scientist")
                    {
                        StripInventory(Entity);

                        ItemManager.CreateByName("hazmatsuit_scientist").MoveToContainer(Entity.inventory.containerWear);
                        switch (UnityEngine.Random.Range(0, 2))
                        {
                            case 0:
                                ItemManager.CreateByName("smg.mp5").MoveToContainer(Entity.inventory.containerBelt, 0);
                                break;
                            case 1:
                                ItemManager.CreateByName("shotgun.spas12").MoveToContainer(Entity.inventory.containerBelt, 0);
                                break;
                            default:
                                ItemManager.CreateByName("pistol.m92").MoveToContainer(Entity.inventory.containerBelt, 0);
                                break;
                        }
                    }
                }
            }

            internal void EnableNavAgent()
            {
                NavMeshHit navMeshHit;

                if (!NavMesh.SamplePosition(Transform.position + (Vector3.up * 1f), out navMeshHit, 20f, -1))
                {
                    Debug.Log("Failed to sample navmesh");
                    return;
                }

                Entity.NavAgent.Warp(navMeshHit.position);
                Transform.position = navMeshHit.position;

                _NavMeshEnabled = NavMeshEnabled = true;

                Entity.NavAgent.enabled = true;
                Entity.NavAgent.isStopped = false;
                SetDestination(Transform.position);
            }

            internal void DisableNavAgent()
            {
                if (!_NavMeshEnabled)
                    return;

                Entity.NavAgent.destination = Transform.position; 
                Entity.NavAgent.isStopped = true;
                Entity.NavAgent.enabled = false;

                _NavMeshEnabled = NavMeshEnabled = false;
            }

            internal void SetDestination(Vector3 destination)
            {
                if (NavMeshEnabled)
                {
                    if (!_NavMeshEnabled)
                        _NavMeshEnabled = true;

                    Entity.NavAgent.enabled = true;
                    Entity.NavAgent.isStopped = false;
                    Entity.SetDestination(destination);
                }
            }

            internal void SetDestination(Vector3 destination, global::HumanNPC.SpeedType speed, Action onReachedDestination)
            {
                CustomAIBrain.MoveDestinationState moveDestinationState = Brain.GetState<CustomAIBrain.MoveDestinationState>() as CustomAIBrain.MoveDestinationState;
                if (moveDestinationState != null)
                    moveDestinationState.SetDestination(destination, speed, onReachedDestination);                
            }

            internal void ForgetEntity(BaseEntity baseEntity)
            {
                Entity.myMemory.Players.Remove(baseEntity);
                Entity.myMemory.Targets.Remove(baseEntity);
                Entity.myMemory.Threats.Remove(baseEntity);
                Entity.myMemory.Friendlies.Remove(baseEntity);
                Entity.myMemory.LOS.Remove(baseEntity);
            }

            private void UpdateTick()
            {
                if (Entity == null || Entity.IsDestroyed)
                {
                    Destroy(this);
                    return;
                }

                if (_attackEntity == null)
                    _attackEntity = Entity.GetAttackEntity();
            }

            internal void EquipWeapon()
            {
                if (Entity == null || Entity.IsDestroyed || Entity.IsDead())
                    return;

                if (Entity.isMounted && !_settings.CanUseWeaponMounted)
                    return;

                for (int i = 0; i < Entity.inventory.containerBelt.itemList.Count; i++)
                {
                    Item slot = Entity.inventory.containerBelt.GetSlot(i);
                    if (slot != null)
                    {
                        Entity.UpdateActiveItem(Entity.inventory.containerBelt.GetSlot(i).uid);

                        BaseEntity heldEntity = slot.GetHeldEntity();
                        if (heldEntity != null)
                        {
                            _attackEntity = heldEntity.GetComponent<AttackEntity>();

                            if (_attackEntity != null)
                                _attackEntity.TopUpAmmo();

                            if (_attackEntity is BaseProjectile)
                                _attackEntity.effectiveRange *= 2f;
                        }

                        return;
                    }
                }
            }

            internal void HolsterWeapon()
            {
                Entity.svActiveItemID = 0;

                Item activeItem = Entity.GetActiveItem();
                if (activeItem != null)
                {
                    HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
                    if (heldEntity != null)
                    {
                        heldEntity.SetHeld(false);
                    }
                }

                Entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                Entity.inventory.UpdatedVisibleHolsteredItems();
            }

            internal void Die()
            {
                if (Entity == null || Entity.IsDestroyed || Entity.IsDead())
                    return;

                Entity.Die(new HitInfo(Entity, Entity, DamageType.Explosion, 1000f));
            }

            internal void Die(HitInfo hitInfo)
            {
                if (Entity == null || Entity.IsDestroyed || Entity.IsDead())
                    return;

                Entity.Die(hitInfo);
            }

            internal void Despawn()
            {
                if (Entity == null || Entity.IsDestroyed || Entity.IsDead())
                    return;

                StripInventory(Entity);
                Entity.Kill();
            }

            private void OnDestroy()
            {
                Facepunch.Pool.FreeList(ref friendlies);

                Destroy(Brain);

                if (Entity != null)
                {                    
                    Entity.CancelInvoke(EnableNavAgent);
                    Entity.CancelInvoke(EquipWeapon);
                    Entity.CancelInvoke(UpdateTick);
                    Entity.CancelInvoke(Despawn);
                    Entity.CancelInvoke(Die);
                }
            }

            private readonly static GameObjectRef[] ZombieDeathEffects = new GameObjectRef[]
            {
                new GameObjectRef(){ guid = GameManifest.guidToPath.FirstOrDefault(x => x.Value.Equals("assets/prefabs/npc/murderer/sound/death.prefab")).Key }
            };

            private readonly static GameObjectRef[] ZombieChatterEffects = new GameObjectRef[]
            {
                new GameObjectRef(){ guid = GameManifest.guidToPath.FirstOrDefault(x => x.Value.Equals("assets/prefabs/npc/murderer/sound/breathing.prefab")).Key }
            };

            #region Senses
            private float nextSenseUpdateTime;

            private float nextFriendlyUpdateTime;

            private const float FRIENDLY_UPDATE_INTERVAL = 5f;
           
            private const float SENSE_UPDATE_INTERVAL = 0.5f;

            private const float SENSE_RANGE = 40f;

            private const float VISION_CONE = -0.4f;

            private static readonly BaseEntity[] QueryResults = new BaseEntity[64];

            private static readonly BasePlayer[] PlayerQueryResults = new BasePlayer[64];

            private List<HumanAI> friendlies = Facepunch.Pool.GetList<HumanAI>();

            internal void UpdateSenses()
            {
                if (Entity == null)
                    return;

                if (Time.time < nextSenseUpdateTime)
                    return;

                nextSenseUpdateTime = Time.time + SENSE_UPDATE_INTERVAL;

                SenseBrains();
                SensePlayers();
            }

            internal void UpdateNearbyFriendlies()
            {
                if (Entity == null)
                    return;

                if (Time.time < nextFriendlyUpdateTime)
                    return;

                nextFriendlyUpdateTime = Time.time + FRIENDLY_UPDATE_INTERVAL;

                friendlies.Clear();

                BaseEntity.Query.Server.GetPlayersInSphere(Transform.position, 40f, PlayerQueryResults, new Func<BasePlayer, bool>(IsFriendlyPlayer));               
            }

            private void SenseBrains()
            {
                int brainsInSphere = BaseEntity.Query.Server.GetBrainsInSphere(Transform.position, _settings.SightRange, QueryResults, new Func<BaseEntity, bool>(CaresAbout));
                for (int i = 0; i < brainsInSphere; i++)                
                    Entity.myMemory.SetKnown(QueryResults[i], Entity, null);                
            }

            private void SensePlayers()
            {
                ScientistNPC scientistNPC = Entity;
                int playersInSphere = BaseEntity.Query.Server.GetPlayersInSphere(Transform.position, _settings.SightRange, PlayerQueryResults, new Func<BasePlayer, bool>(CaresAbout));
                for (int i = 0; i < playersInSphere; i++)
                {
                    BasePlayer result = PlayerQueryResults[i];

                    Entity.myMemory.SetKnown(result, Entity, null);

                    for (int y = 0; y < friendlies.Count; y++)
                    {
                        scientistNPC = friendlies[y]?.Entity;

                        if (scientistNPC != null)
                            scientistNPC.myMemory.SetKnown(result, scientistNPC, null);
                    }
                }
            }

            private bool IsFriendlyPlayer(BasePlayer player)
            {
                if (!player?.IsNpc ?? false)
                    return false;

                HumanAI humanAI = player.GetComponent<HumanAI>();
                if (humanAI != null)
                {
                    friendlies.Add(humanAI);
                    return true;
                }

                return false;
            }

            private bool CaresAbout(BaseEntity entity)
            {
                if (entity == null)                
                    return false;
                
                if (entity.EqualNetID(Entity))                
                    return false;
                
                if (entity.Health() <= 0f)                
                    return false;
                
                if (!CanSenseType(entity))                
                    return false;                

                if (entity is BasePlayer && (entity as BasePlayer).InSafeZone())                
                    return false;
                
                if (entity is BaseCombatEntity && (entity as BaseCombatEntity).TimeSinceLastNoise <= 1f && (entity as BaseCombatEntity).CanLastNoiseBeHeard(Transform.position, SENSE_RANGE))                
                    return true;
                
                if (!IsTargetInVision(entity))                
                    return false;

                bool hasLOS = CanSeeTarget(entity);
                Entity.myMemory.SetLOS(entity, hasLOS);

                if (!hasLOS)
                    return false;

                return true;                
            }

            private bool CanSenseType(BaseEntity ent)
            {
                BasePlayer basePlayer = ent as BasePlayer;
                if (basePlayer != null && !basePlayer.IsNpc)
                    return true;

                if (ent is BaseNpc)                
                    return true;
                                
                if (ent is TimedExplosive)                
                    return true;                
               
                return false;
            }

            private bool CanSeeTarget(BaseEntity entity)
            {
                BasePlayer basePlayer = entity as BasePlayer;
                if (basePlayer == null)                
                    return true;
                
                return Entity.IsPlayerVisibleToUs(basePlayer);
            }

            private bool IsTargetInVision(BaseEntity target)
            {
                Vector3 vector3 = Vector3Ex.Direction(target.transform.position, Transform.position);
                return Vector3.Dot((Entity != null ? Entity.eyes.BodyForward() : Transform.forward), vector3) >= VISION_CONE;
            }
            #endregion

        }
        #endregion

        #region States
        public class CustomAIBrain : BaseAIBrain<global::HumanNPC>
        {
            private HumanAI humanAI;

            private void Awake()
            {
                humanAI = GetComponent<HumanAI>();
            }

            public override void AddStates()
            {
                base.AddStates();
                humanAI.AddStates();
            }

            public override void InitializeAI()
            {                
                global::HumanNPC humanNpc = GetEntity();

                UseAIDesign = false;

                base.InitializeAI();

                ThinkMode = AIThinkMode.Interval;
                thinkRate = 0.25f;
                PathFinder = new HumanPathFinder();
                ((HumanPathFinder)PathFinder).Init(humanNpc);
            }

            public override void Think(float delta)
            {
                if (!ConVar.AI.think || states == null)
                    return;

                lastThinkTime = Time.time;
                if (sleeping)
                    return;

                humanAI.UpdateNearbyFriendlies();
                humanAI.UpdateSenses();

                if (CurrentState != null)                
                    CurrentState.StateThink(delta); 

                if (CurrentState == null || CurrentState.CanLeave())
                {
                    float highest = 0f;
                    BasicAIState state = null;

                    foreach (BasicAIState value in states.Values)
                    {
                        if (value == null || !value.CanEnter())
                            continue;

                        float weight = value.GetWeight();
                        if (weight <= highest)
                            continue;

                        highest = weight;
                        state = value;
                    }

                    if (state != CurrentState)
                        SwitchToState(state, -1);
                }
            }

            internal void ClearStates()
            {
                if (states != null)
                    states.Clear();
            }

            internal BasicAIState GetState<T>() where T : BasicAIState
            {
                foreach(BasicAIState basicAIState in states.Values)
                {
                    if (basicAIState is T)
                        return basicAIState;
                }

                return null;
            }

            public class IdleState : BaseAIBrain<global::HumanNPC>.BasicAIState
            {
                private readonly HumanAI humanAI;

                public IdleState(HumanAI humanAI) : base(AIState.Idle)
                {
                    this.humanAI = humanAI;
                }

                public override float GetWeight() => 0.1f;

                public override void StateEnter()
                {
                    humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.SlowWalk);
                    base.StateEnter();
                }
            }

            public class WoundedState : BaseAIBrain<global::HumanNPC>.BasicAIState
            {
                private readonly HumanAI humanAI;
                private readonly float woundedDuration;
                private readonly float woundedRecoveryChance;

                private bool isIncapacitated;
                private Vector3 destination;

                public WoundedState(HumanAI humanAI, float woundedDuration, float woundedRecoveryChance) : base(AIState.Orbit)
                {
                    this.humanAI = humanAI;
                    this.woundedDuration = woundedDuration;
                    this.woundedRecoveryChance = woundedRecoveryChance;
                }

                public override float GetWeight() => humanAI.Entity.HasPlayerFlag(BasePlayer.PlayerFlags.Wounded) ? 100f : 0f;

                public override void StateEnter()
                {
                    base.StateEnter();

                    if (UnityEngine.Random.value > 0.5f)
                    {
                        humanAI.Entity.health = (float)UnityEngine.Random.Range(ConVar.Server.crawlingminhealth, ConVar.Server.crawlingmaxhealth);
                        humanAI.Entity.metabolism.bleeding.@value = 0f;
                        humanAI.Entity.healingWhileCrawling = 0f;
                        
                        isIncapacitated = false;
                        destination = humanAI.Entity.ServerPosition;
                        humanAI.Entity.NavAgent.speed = BasePlayer.crawlSpeed * 0.75f;
                    }
                    else
                    {
                        humanAI.Entity.health = UnityEngine.Random.Range(2f, 6f);
                        humanAI.Entity.metabolism.bleeding.@value = 0f;
                        humanAI.Entity.healingWhileCrawling = 0f;
                        humanAI.Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Incapacitated, true);
                        isIncapacitated = true;
                    }

                    humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Crouch);

                    humanAI.Entity.SetServerFall(true);
                    humanAI.Entity.SendNetworkUpdateImmediate(false);
                }

                public override void StateLeave()
                {
                    base.StateLeave();

                    humanAI.Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);
                    humanAI.Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Incapacitated, false);
                    humanAI.Entity.SetServerFall(false);
                }

                public override StateStatus StateThink(float delta)
                {
                    base.StateThink(delta);

                    if (!humanAI.Entity.IsDead())
                    {
                        if (!isIncapacitated)
                        {
                            if (Vector3.Distance(humanAI.transform.position, destination) < 1f)
                            {
                                Vector2 random = UnityEngine.Random.insideUnitCircle.normalized * 25f;
                                object d = FindPointOnNavmesh(humanAI.transform.position + new Vector3(random.x, 0f, random.y), 4f);

                                if (d is Vector3)
                                {
                                    destination = (Vector3)d;
                                    humanAI.SetDestination(destination);
                                }
                            }

                            Vector3 dest = humanAI.Transform.position;
                            if (humanAI.Entity.HasPath)                            
                                dest = humanAI.Entity.NavAgent.nextPosition;

                            humanAI.Entity.ServerPosition = dest;
                            humanAI.Entity.SetAimDirection(humanAI.Entity.GetAimDirection());
                        }

                        if (TimeInState >= woundedDuration)
                        {
                            if (UnityEngine.Random.Range(0, 100) >= woundedRecoveryChance)
                                humanAI.Die();
                            else
                            {
                                humanAI.Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);
                                humanAI.EquipWeapon();
                            }

                            return StateStatus.Finished;
                        }
                    }

                    return StateStatus.Running;
                }
            }

            public class ChaseState : BaseAIBrain<global::HumanNPC>.BasicAIState
            {
                private readonly HumanAI humanAI;
                private readonly float chaseRange;

                public ChaseState(HumanAI humanAI, float chaseRange) : base(AIState.Chase)
                {
                    this.humanAI = humanAI;
                    this.chaseRange = chaseRange;
                }

                public override float GetWeight()
                {
                    float weight = 0f;

                    if (!humanAI.Entity.HasTarget())
                        return 0f;

                    if (humanAI.HasHomePosition && humanAI.DistanceFromBase > chaseRange)
                        return 0f;

                    if ((humanAI.Entity.currentTarget as BasePlayer)?.IsFlying ?? false)
                    {
                        humanAI.ForgetEntity(humanAI.Entity.currentTarget);
                        humanAI.Entity.currentTarget = null;
                        humanAI.Entity.currentTargetLOS = false;
                        return 0f;
                    }

                    if (humanAI._attackEntity is BaseProjectile && (humanAI.Entity.AmmoFractionRemaining() < 0.3f || humanAI.Entity.IsReloading()))
                        weight -= 1f;

                    if (humanAI.Entity.HasTarget())
                        weight += 0.5f;

                    if (humanAI.Entity.CanSeeTarget())
                        weight -= 0.5f;
                    else weight += 1f;

                    if (!(humanAI._attackEntity is BaseProjectile) || humanAI.Entity.DistanceToTarget() > humanAI.Entity.GetIdealDistanceFromTarget())
                        weight += 1f;

                    return weight;
                }

                public override void StateEnter()
                {
                    base.StateEnter();
                    humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Walk);
                }

                public override StateStatus StateThink(float delta)
                {
                    base.StateThink(delta);

                    if (!humanAI.Entity.HasTarget())
                        return StateStatus.Error;

                    bool hasProjectileWeapon = humanAI._attackEntity is BaseProjectile;

                    float distanceToTarget = Vector3.Distance(humanAI.Entity.currentTarget.transform.position, humanAI.Transform.position);

                    if (!hasProjectileWeapon)
                        humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Sprint);

                    else humanAI.Entity.SetDesiredSpeed(distanceToTarget < 5f ? global::HumanNPC.SpeedType.SlowWalk :
                                                distanceToTarget >= 10f ? global::HumanNPC.SpeedType.Sprint :
                                                global::HumanNPC.SpeedType.Walk);

                    Vector3 position = humanAI.Transform.position;

                    if (!hasProjectileWeapon)
                        humanAI.SetDestination(humanAI.Entity.currentTarget.transform.position);
                    else
                    {
                        AIInformationZone aiInformationZone = humanAI.Entity.GetInformationZone(humanAI.Entity.currentTarget.transform.position);
                        if (aiInformationZone != null)
                        {
                            AIMovePoint bestMovePointNear = aiInformationZone.GetBestMovePointNear(humanAI.Entity.currentTarget.transform.position, humanAI.Transform.position, 0f, 35f, true, null);
                            if (!bestMovePointNear)
                            {
                                position = brain.PathFinder.GetRandomPositionAround(humanAI.Entity.currentTarget.transform.position, 1f, 2f);
                            }
                            else
                            {
                                bestMovePointNear.SetUsedBy(humanAI.Entity, 5f);
                                position = brain.PathFinder.GetRandomPositionAround(bestMovePointNear.transform.position, 0f, bestMovePointNear.radius - 0.3f);
                            }
                        }
                        else position = brain.PathFinder.GetRandomPositionAround(humanAI.Entity.currentTarget.transform.position, 10f, 20f);

                        humanAI.SetDestination(position);
                    }

                    return StateStatus.Running;
                }
            }

            public class CombatState : BaseAIBrain<global::HumanNPC>.BasicAIState
            {
                private readonly HumanAI humanAI;
                private readonly float chaseRange;

                private float nextStrafeTime;

                public CombatState(HumanAI humanAI, float chaseRange) : base(AIState.Combat)
                {
                    this.humanAI = humanAI;
                    this.chaseRange = chaseRange;
                }

                public override float GetWeight()
                {
                    if (!humanAI.Entity.HasTarget())
                        return 0f;

                    if (!humanAI.Entity.TargetInRange())
                        return 0f;

                    if (humanAI.HasHomePosition && humanAI.DistanceFromBase > chaseRange)
                        return 0f;

                    if (humanAI._attackEntity == null)
                        return 0f;

                    if ((humanAI.Entity.currentTarget as BasePlayer)?.IsFlying ?? false)
                    {
                        humanAI.ForgetEntity(humanAI.Entity.currentTarget);
                        humanAI.Entity.currentTarget = null;
                        humanAI.Entity.currentTargetLOS = false;
                        return 0f;
                    }

                    float weight = 0f;
                    if (humanAI._attackEntity is BaseProjectile)
                    {
                        float single = 1f - Mathf.InverseLerp(humanAI.Entity.GetIdealDistanceFromTarget(), humanAI.Entity.EngagementRange(), humanAI.Entity.DistanceToTarget());

                        weight = 0.5f * single;

                        if (humanAI.Entity.CanSeeTarget())
                            weight += 1f;
                    }
                    else
                    {
                        if (Vector3.Distance(humanAI.Transform.position, humanAI.Entity.currentTarget.transform.position) < humanAI._attackEntity.effectiveRange)
                            weight = 5f;
                    }

                    return weight;
                }

                public override void StateEnter()
                {
                    base.StateEnter();

                    brain.mainInterestPoint = humanAI.Transform.position;
                    humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Walk);

                    if (humanAI._attackEntity is BaseMelee)
                        DoMeleeAttack();
                }

                public override void StateLeave()
                {
                    humanAI.Entity.SetDucked(false);
                    base.StateLeave();
                }

                public override StateStatus StateThink(float delta)
                {
                    base.StateThink(delta);

                    if (!humanAI.Entity.HasTarget())
                        return StateStatus.Error;

                    if (humanAI._attackEntity is BaseProjectile)
                    {
                        if (Time.time > nextStrafeTime)
                        {
                            if (UnityEngine.Random.Range(0, 3) == 1)
                            {
                                nextStrafeTime = Time.time + UnityEngine.Random.Range(2f, 3f);
                                humanAI.Entity.SetDucked(true);
                                humanAI.Entity.Stop();
                                return StateStatus.Running;
                            }

                            nextStrafeTime = Time.time + UnityEngine.Random.Range(3f, 4f);
                            humanAI.Entity.SetDucked(false);
                            humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Walk);
                            humanAI.SetDestination(brain.PathFinder.GetRandomPositionAround(brain.mainInterestPoint, 1f, 2f));
                        }
                    }
                    else if (humanAI._attackEntity is BaseMelee)
                    {
                        humanAI.Entity.nextTriggerTime = Time.time + 30f;

                        if (Vector3.Distance(humanAI.Transform.position, humanAI.Entity.currentTarget.transform.position) < humanAI._attackEntity.effectiveRange)
                            DoMeleeAttack();
                        else
                        {
                            humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Sprint);
                            humanAI.SetDestination(humanAI.Entity.currentTarget.transform.position);
                        }
                    }

                    return StateStatus.Running;
                }

                private void DoMeleeAttack() // Hackery to make ScientistNPC's do melee damage
                {
                    if (humanAI._attackEntity == null || !(humanAI._attackEntity is BaseMelee))
                        return;

                    BaseMelee baseMelee = humanAI._attackEntity as BaseMelee;
                    if (baseMelee.HasAttackCooldown())
                        return;

                    baseMelee.StartAttackCooldown(baseMelee.repeatDelay * 2f);
                    humanAI.Entity.SignalBroadcast(BaseEntity.Signal.Attack, string.Empty, null);

                    if (baseMelee.swingEffect.isValid)
                        Effect.server.Run(baseMelee.swingEffect.resourcePath, baseMelee.transform.position, Vector3.forward, humanAI.Entity.net.connection, false);

                    DoMeleeDamage(humanAI._attackEntity as BaseMelee);
                }

                private void DoMeleeDamage(BaseMelee baseMelee)
                {
                    Vector3 position = humanAI.Entity.eyes.position;
                    Vector3 forward = humanAI.Entity.eyes.BodyForward();

                    for (int i = 0; i < 2; i++)
                    {
                        List<RaycastHit> list = Pool.GetList<RaycastHit>();

                        GamePhysics.TraceAll(new Ray(position - (forward * (i == 0 ? 0f : 0.2f)), forward), (i == 0 ? 0f : baseMelee.attackRadius), list, baseMelee.effectiveRange + 0.2f, 1219701521, QueryTriggerInteraction.UseGlobal);

                        bool hasHit = false;
                        for (int j = 0; j < list.Count; j++)
                        {
                            RaycastHit raycastHit = list[j];
                            BaseEntity hitEntity = raycastHit.GetEntity();

                            if (hitEntity != null && hitEntity != humanAI.Entity && !hitEntity.EqualNetID(humanAI.Entity) && !(hitEntity is ScientistNPC))
                            {
                                float damageAmount = 0f;
                                foreach (DamageTypeEntry damageType in baseMelee.damageTypes)
                                    damageAmount += damageType.amount;

                                hitEntity.OnAttacked(new HitInfo(humanAI.Entity, hitEntity, DamageType.Slash, damageAmount * baseMelee.npcDamageScale));

                                HitInfo hitInfo = Pool.Get<HitInfo>();
                                hitInfo.HitEntity = hitEntity;
                                hitInfo.HitPositionWorld = raycastHit.point;
                                hitInfo.HitNormalWorld = -forward;

                                if (hitEntity is BaseNpc || hitEntity is BasePlayer)
                                    hitInfo.HitMaterial = StringPool.Get("Flesh");
                                else hitInfo.HitMaterial = StringPool.Get((raycastHit.GetCollider().sharedMaterial != null ? raycastHit.GetCollider().sharedMaterial.GetName() : "generic"));

                                Effect.server.ImpactEffect(hitInfo);
                                Pool.Free(ref hitInfo);

                                hasHit = true;

                                if (hitEntity.ShouldBlockProjectiles())
                                    break;
                            }
                        }

                        Pool.FreeList(ref list);
                        if (hasHit)
                            break;
                    }
                }
            }

            public class RoamState : BaseAIBrain<global::HumanNPC>.BasicAIState
            {
                private readonly HumanAI humanAI;

                private readonly float roamRange;

                private float nextSetDestinationTime;

                private float currentDestinationTime;

                private bool isAtDestination;

                private Vector3 roamDestination;

                public RoamState(HumanAI humanAI, float roamRange) : base (AIState.Roam)
                {
                    this.humanAI = humanAI;
                    this.roamRange = roamRange;
                }

                public override float GetWeight()
                {
                    if (!humanAI.Entity.HasTarget() && humanAI.Entity.SecondsSinceAttacked > 10f)
                        return 5f;

                    return 0f;
                }

                public override void StateEnter()
                {
                    humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.SlowWalk);
                    humanAI.Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Relaxed, true);

                    humanAI.Entity.IsDormant = false;

                    roamDestination = humanAI.Transform.position;
                    nextSetDestinationTime = Time.time;
                    isAtDestination = true;

                    base.StateEnter();
                }

                public override void StateLeave()
                {
                    humanAI.Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Relaxed, false);
                    base.StateLeave();
                }

                public override StateStatus StateThink(float delta)
                {
                    base.StateThink(delta);

                    if (humanAI.DistanceFromBase > roamRange)
                    {
                        roamDestination = humanAI._roamBasePosition;
                        humanAI.SetDestination(roamDestination);

                        currentDestinationTime = 0;
                        isAtDestination = false;

                        humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Sprint);
                    }
                    else
                    {
                        if (Vector3.Distance(humanAI.Transform.position, roamDestination) < 3f)
                        {
                            if (!isAtDestination)
                            {
                                nextSetDestinationTime = Time.time + UnityEngine.Random.Range(2f, 4f);
                                isAtDestination = true;

                                humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.SlowWalk);
                                return StateStatus.Running;
                            }

                            if (Time.time > nextSetDestinationTime && isAtDestination)
                            {
                                Vector2 random = UnityEngine.Random.insideUnitCircle * (roamRange - 5f);

                                roamDestination = humanAI._roamBasePosition + new Vector3(random.x, 0f, random.y);
                                roamDestination.y = TerrainMeta.HeightMap.GetHeight(roamDestination);

                                if (NavMesh.SamplePosition(roamDestination, out navmeshHit, 5f, humanAI.Entity.NavAgent.areaMask))
                                    roamDestination = navmeshHit.position;

                                humanAI.SetDestination(roamDestination);

                                isAtDestination = false;
                                currentDestinationTime = 0;
                            }
                        }
                        else
                        {
                            currentDestinationTime += delta;
                            if (currentDestinationTime > 30f)
                            {
                                isAtDestination = true;
                                roamDestination = humanAI.transform.position;
                            }

                            humanAI.SetDestination(roamDestination);
                        }
                    }

                    return StateStatus.Running;
                }
            }

            public class MountedState : BaseAIBrain<global::HumanNPC>.BasicAIState
            {
                private readonly HumanAI humanAI;
                private readonly bool canUseWeapon;

                public MountedState(HumanAI humanAI, bool canUseWeapon) : base(AIState.Mounted)
                {
                    this.humanAI = humanAI;
                    this.canUseWeapon = canUseWeapon;
                }

                public override float GetWeight()
                {
                    if (humanAI.Entity.isMounted)
                        return 400f;
                    return 0f;
                }

                public override void StateEnter()
                {
                    humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Walk);

                    if (!canUseWeapon)
                        humanAI.HolsterWeapon();

                    humanAI.DisableNavAgent();

                    base.StateEnter();
                }

                public override void StateLeave()
                {
                    humanAI.EnableNavAgent();

                    humanAI.EquipWeapon();

                    base.StateLeave();
                }
            }

            public class MoveDestinationState : BaseAIBrain<global::HumanNPC>.BasicAIState
            {
                private readonly HumanAI humanAI;

                private Vector3 destination;
                private global::HumanNPC.SpeedType speed;

                private Action onReachedDestination;

                private bool hasDestination;

                public MoveDestinationState(HumanAI humanAI) : base (AIState.MoveTowards)
                {
                    this.humanAI = humanAI;
                }

                public void SetDestination(Vector3 destination, global::HumanNPC.SpeedType speed, Action onReachedDestination)
                {
                    if (NavMesh.SamplePosition(destination, out navmeshHit, 5f, humanAI.Entity.NavAgent.areaMask))
                        destination = navmeshHit.position;

                    this.destination = destination;
                    this.speed = speed;
                    this.onReachedDestination = onReachedDestination;

                    hasDestination = true;
                }

                public override float GetWeight()
                {
                    if (hasDestination)
                        return 300f;
                    return 0f;
                }

                public override void StateEnter()
                {
                    humanAI.Entity.SetDesiredSpeed(speed);
                    humanAI.SetDestination(destination);

                    base.StateEnter();
                }

                public override void StateLeave()
                {
                    humanAI.EnableNavAgent();

                    humanAI.EquipWeapon();

                    base.StateLeave();
                }

                public override StateStatus StateThink(float delta)
                {
                    base.StateThink(delta);

                    if (Vector3.Distance(humanAI.Transform.position, destination) < 3f)
                    {
                        if (onReachedDestination != null)
                        {
                            onReachedDestination.Invoke();
                            onReachedDestination = null;
                        }

                        humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.Walk);

                        hasDestination = false;

                        return StateStatus.Finished;
                    }
                    else
                    {
                        humanAI.Entity.SetDesiredSpeed(speed);
                        humanAI.SetDestination(destination);

                        return StateStatus.Running;
                    }
                }
            }

            public class FallingState : BaseAIBrain<global::HumanNPC>.BasicAIState
            {
                private readonly HumanAI humanAI;

                public FallingState(HumanAI humanAI) : base (AIState.Land)
                {
                    this.humanAI = humanAI;
                }

                public override float GetWeight()
                {
                    if (humanAI.Entity.modelState.flying)
                        return 500f;

                    return 0f;
                }

                public override void StateEnter()
                {
                    humanAI.Entity.SetDesiredSpeed(global::HumanNPC.SpeedType.SlowWalk);

                    humanAI.DisableNavAgent();
                    humanAI.HolsterWeapon();

                    base.StateEnter();
                }

                public override void StateLeave()
                {
                    base.StateLeave();

                    humanAI.EnableNavAgent();
                    humanAI.EquipWeapon();
                }
            }
        }
        #endregion

        #region Testing
        [ChatCommand("spawnnpc")]
        private void cmdSpawnNPC(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
                return;

            int amount = 3;
            if (args.Length > 0)
                int.TryParse(args[0], out amount);

            for (int i = 0; i < amount; i++)
            {
                Vector3 position = player.transform.position + (UnityEngine.Random.onUnitSphere * 20);

                JObject settings = new JObject()
                {
                    ["DisplayName"] = "ScientistNPC",
                    ["Health"] = 100,
                    ["NPCType"] = "HeavyScientist",
                    ["SightRange"] = 60,
                    ["RoamRange"] = 50f,
                    ["ChaseRange"] = 90f,
                    ["EnableNavMesh"] = true,
                    ["EquipWeapon"] = true,
                    ["Kit"] = string.Empty,
                    ["StripCorpseLoot"] = false,
                    ["KillInSafeZone"] = true,
                    ["DespawnTime"] = 0,
                    ["StartDead"] = false,
                    ["StartWounded"] = true,
                    ["WoundedDuration"] = 180,
                    ["WoundedRecoveryChance"] = 10,
                    ["States"] = new JArray { "IdleState", "RoamState", "ChaseState", "CombatState" }
                };

                SpawnNPC(this, position, settings);
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion       
    }
}


// --- End of file: CustomNPC.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FlashBang.cs ---
// --- Original Local Path: FlashBang.cs ---

using UnityEngine;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Rust;
using Oxide.Core.Plugins;
using System.Collections.Generic;
using System;
using System.Reflection;
using Oxide.Core;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("FlashBang", "PaiN", "0.6", ResourceId = 1283)]
    [Description("Replaces grenade with a flashbang grenade.")]
    class FlashBang : RustPlugin
    {
		
		class Data
		{
			public List<FlashInfo> FlashInfo = new List<FlashInfo>{};
		} 
		 
		Data data;
		
		class FlashInfo
		{
			public int ID;
			public int Duration;
			public string Power;
			public int Radius;
	
			public FlashInfo(int num, int dur, string pow, int rad)
			{
				ID = num;
				Duration = dur;
				Power = pow;
				Radius = rad;
			}
				
			public FlashInfo()
			{ 
			}
		}
		
		void Loaded()
		{
			permission.RegisterPermission("flashbang.admin", this);
			data = Interface.GetMod().DataFileSystem.ReadObject<Data>("FlashBang_Settings"); 
			foreach(FlashInfo info in data.FlashInfo)
			{Puts($"{info.ID}");}
			if(data.FlashInfo == null)
			Puts("There are not FlashBang settings! Type /fhelp to check the commands!");	
			

		}
		
        #region GUI
		void UseUI(BasePlayer player, string strength)
		{
			var elements = new CuiElementContainer();
				elements.Add(new CuiElement
				{  
					Name = "FlashBang",
					Parent = "Overlay",
					FadeOut = 0.5f,
					Components =
					{
						new CuiImageComponent
						{
							Color = $"1.0 1.0 1.0 {strength}",
							FadeIn = 0.5f
						}, 
						new CuiRectTransformComponent
						{
							AnchorMin = "0 0",
							AnchorMax = "1 1"
						}
					}
				});
			CuiHelper.AddUi(player, elements);
		}

        #endregion
		
		int GetNewId()
		{		
			int id = 0;
			foreach(FlashInfo info in data.FlashInfo)
			{
				id = Math.Max(0, info.ID);
			}
			return id + 1;
		}

        void OnWeaponThrown(BasePlayer player, BaseEntity entity)
        {
            if (entity.name.Contains("grenade.f1"))
            {
				if(data.FlashInfo == null)
				{
					Puts(player.displayName + " tried to throw a flashbang but there aren't any settings. || /fb help");
					return;
				}
                PrintToChat("<color=orange>FlashBang System</color> : <color=cyan>" + player.displayName + " </color>has thrown a flashbang!");
                timer.Once(3, () => Flash(player, entity));
            }
        }
		
		[ChatCommand("fb")]
		void cmdFB(BasePlayer player, string cmd, string[] args)
		{
			if(args.Length == 0)
			{ 
				player.SendConsoleCommand("chat.say \"/fb help\" ");
				return;
			}
			ulong steamId = player.userID;
			switch(args[0])
			{
				case "add":			
					if(!permission.UserHasPermission(steamId.ToString(), "flashbang.admin"))
					{
						SendReply(player, "You do not have permission to use this command!");
						return;
					}
					if(args.Length != 4)
					{
						SendReply(player, "/fb add <Duration> <Radius> <Power>");
						return;
					}   
					int fnum;
					int dur = Convert.ToInt32(args[1]); 
					int rad = Convert.ToInt32(args[2]);
					string pow = Convert.ToString(args[3]);
					if(data.FlashInfo == null)
					{
						fnum = 1;
					}
					else
					{
						fnum = GetNewId();
					}
					var info = new FlashInfo(fnum,dur,pow,rad);
					data.FlashInfo.Add(info);
					SendReply(player, "You have added a new FlashBang setting!");
					Interface.GetMod().DataFileSystem.WriteObject("FlashBang_Settings", data);
					break;
				case "help":	
					if(!permission.UserHasPermission(steamId.ToString(), "flashbang.admin"))
					{
						SendReply(player, "You do not have permission to use this command!");
						return;
					}
					SendReply(player, "/fb add <Duration> <Radius> <Power>");
					SendReply(player, "/fb remove <ID> ");
					SendReply(player, "/fb list");
				break;
				case "remove":
					if(!permission.UserHasPermission(steamId.ToString(), "flashbang.admin"))
					{
						SendReply(player, "You do not have permission to use this command!");
						return;
					}
					if(args.Length != 2) 
					{
						SendReply(player, "/fb remove <ID> || /fb list");
						return;
					}
					foreach(FlashInfo infos in data.FlashInfo)
					{
						if(infos.ID.ToString() == args[1].ToString())
						{
							data.FlashInfo.Remove(infos);
							SendReply(player, "You have removed the flashbang setting ID: " + infos.ID.ToString());
							Interface.GetMod().DataFileSystem.WriteObject("FlashBang_Settings", data);
							break;
						}
					}
				break;
				case "list":
					if(!permission.UserHasPermission(steamId.ToString(), "flashbang.admin"))
					{
						SendReply(player, "You do not have permission to use this command!");
						return;
					}
					SendReply(player, "<color=#91FFB5>Current Flashbang Settings</color>");
					foreach(FlashInfo infom in data.FlashInfo)
					{
						SendReply(player, "ID: <color=#91FFB5>{2}</color>\nDuration: <color=cyan>{0}</color> \nPower:<color=orange> {1} </color> \nRadius: <color=lime>{3}</color>", infom.Duration, infom.Power, infom.ID, infom.Radius);
						SendReply(player, "<color=#91FFB5>*************</color>");										
					}
					SendReply(player, "<color=#91FFB5>*************</color>");
				break;
			}
			
		}

        void Flash(BasePlayer player, BaseEntity entity)
        {
            Vector3 flashPos = entity.GetEstimatedWorldPosition();
            entity.Kill();
            foreach(BasePlayer current in BasePlayer.activePlayerList)
            {
				foreach(FlashInfo info in data.FlashInfo)
				{
					if (Vector3.Distance(current.transform.position, flashPos) <= info.Radius)
					{
						UseUI(current, info.Power);
						timer.Once(info.Duration, () => CuiHelper.DestroyUi(current, "FlashBang"));
						return;
					}
				}
            }

        }

        void Unloaded()
        {
            foreach(BasePlayer player in BasePlayer.activePlayerList)
			CuiHelper.DestroyUi(player, "FlashBang");
        }
    }
}


// --- End of file: FlashBang.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BerrySpawn.cs ---
// --- Original Local Path: BerrySpawn.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Drawing;
using System.IO;
using System.Drawing.Imaging;
using Newtonsoft.Json.Converters;
using Facepunch;
using VLB;

using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Rust;

namespace Oxide.Plugins
{
    [Info("BerrySpawn", "EcoSmile", "1.0.3")]
    class BerrySpawn : RustPlugin
    {
        static BerrySpawn ins;
        PluginConfig config;

        public class PluginConfig
        {
            [JsonProperty("Время респавна кустов (в секундах)")]
            public float RespawnTime;
            [JsonProperty("Минимальное расстояние между кустами (Рекомендуется не менее 20)")]
            public float Distance;
        }

        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                RespawnTime = 300,
                Distance = 20
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        Coroutine coroutine;
        List<Vector3> Spawnpoint = new List<Vector3>();

        void LoadData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("BerrySpawnPoint"))
            {
                Spawnpoint = Interface.Oxide.DataFileSystem.ReadObject<List<Vector3>>("BerrySpawnPoint");
            }
            else
            {
                Interface.Oxide.DataFileSystem.WriteObject("BerrySpawnPoint", Spawnpoint = new List<Vector3>());
            }
        }

        private void OnServerInitialized()
        {
            ins = this;
            LoadConfig();
            LoadData();
            if (ConVar.Server.level == "Procedural Map") return;
            coroutine = ServerMgr.Instance.StartCoroutine(spawnBerry());
        }

        void Unload() 
        {
            if (coroutine != null)
                ServerMgr.Instance.StopCoroutine(coroutine);

            Interface.Oxide.DataFileSystem.WriteObject("BerrySpawnPoint", Spawnpoint);
        }

        void OnNewSave()
        {
            Interface.Oxide.DataFileSystem.WriteObject("BerrySpawnPoint", Spawnpoint = new List<Vector3>());
        }

        Vector3 RandomCircle(Vector3 center, float radius)
        {
            float ang = UnityEngine.Random.value * 360;
            float distance = UnityEngine.Random.Range(5, radius);
            Vector3 pos;
            pos.x = center.x + distance * Mathf.Sin(ang * Mathf.Deg2Rad);
            pos.z = center.z + distance * Mathf.Cos(ang * Mathf.Deg2Rad);
            pos.y = center.y;
            pos.y = GetGroundPosition(pos);
            return pos;
        }

        float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;
            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity,
                LayerMask.GetMask(new[] { "Terrain" })) && !hit.collider.name.Contains("rock_cliff")) return Mathf.Max(hit.point.y, y);
            return y;
        }
        

        private bool TestPosIsValid(Vector3 position)
        {
            var resources = new List<CollectibleEntity>();
            Vis.Entities(position, config.Distance, resources);
            if (resources.Where(x => x.ShortPrefabName.Contains("berry")).Count() > 0)
                return false;

            return true;
        }
           

        List<string> berryPrefab = new List<string>()
        {
            "assets/bundled/prefabs/autospawn/collectable/berry-white/berry-white-collectable.prefab",
            "assets/bundled/prefabs/autospawn/collectable/berry-yellow/berry-yellow-collectable.prefab",
            "assets/bundled/prefabs/autospawn/collectable/berry-green/berry-green-collectable.prefab",
            "assets/bundled/prefabs/autospawn/collectable/berry-red/berry-red-collectable.prefab",
            "assets/bundled/prefabs/autospawn/collectable/berry-blue/berry-blue-collectable.prefab"
        };


        IEnumerator spawnBerry()
        {
            var biomMap = TerrainMeta.Terrain.GetComponent<TerrainBiomeMap>();
            var tundraEntity = BaseCombatEntity.serverEntities.entityList.Where(x => x.Value.PrefabName.Contains("v3_tundra_forestside"));
            if (tundraEntity.Count() > Spawnpoint.Count)
            {
                Spawnpoint.Clear();
                foreach (var mm in tundraEntity)
                {
                    if (biomMap.GetBiome(mm.Value.transform.position, 4) >= 0.98f)
                    {
                        var pos = RandomCircle(mm.Value.transform.position, 10);
                        Spawnpoint.Add(pos);
                    }
                    yield return null;
                }
            }

            foreach (var berry in Spawnpoint)
            {
                if (TestPosIsValid(berry))
                {
                    var ent = GameManager.server.CreateEntity(berryPrefab.GetRandom(), berry);
                    ent.Spawn();
                }
                yield return null;
            }

            yield return CoroutineEx.waitForSecondsRealtime(config.RespawnTime);

            coroutine = ServerMgr.Instance.StartCoroutine(spawnBerry());
        }
    }
}


// --- End of file: BerrySpawn.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TeleportGUI.cs ---
// --- Original Local Path: TeleportGUI.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    /*
        This plugin was written solely by PsychoTea.
        Please do not, under any circumstances, redistribute this code.
        If you find any bugs, please report them either directly to me at bensparkes8@gmail.com,
        or on the chaoscode.io page.
        The same applies for feature requests.
        For any enquiries please also email me at bensparkes8@gmail.com
        I do write private plugins.
    */

    [Info("TeleportGUI", "PsychoTea", "1.6.2")]

    class TeleportGUI : RustPlugin
    {
        #region Fields

        private const string permUse = "teleportgui.use";
        private const string permCancel = "teleportgui.tpcancel";
        private const string permBack = "teleportgui.tpback";
        private const string permHere = "teleportgui.tphere";
        private const string permSleepers = "teleportgui.sleepers";

        private static TeleportGUI Instance;

        private Dictionary<BasePlayer, bool> GUIOpen = new Dictionary<BasePlayer, bool>();
        private Dictionary<BasePlayer, Vector3> LastTeleport = new Dictionary<BasePlayer, Vector3>();
        private List<GameObject> GameObjects = new List<GameObject>();

        private bool DebuggingMode = false;

        [PluginReference] private Plugin Economics, ServerRewards, NoEscape, ZoneManager;

        #endregion

        #region Classes 

        class GUIManager
        {
            public static Dictionary<BasePlayer, GUIManager> Players = new Dictionary<BasePlayer, GUIManager>();

            public int Page = 1;
            public bool TPHere = false;
            public bool Sleepers = false;

            public static GUIManager Get(BasePlayer player)
            {
                if (Players.ContainsKey(player)) return Players[player];
                Players.Add(player, new GUIManager());
                return Players[player];
            }
        }

        class TeleportRequest : MonoBehaviour
        {
            private BasePlayer _from;
            private BasePlayer _to;

            private bool _tpHere;
            private double _time;
            private bool _playerIsPaying;

            public static void Create(BasePlayer from, BasePlayer to, double timeoutTime, bool tpHere, bool playerIsPaying)
            {
                var gameObject = new GameObject();

                var tpReq = gameObject.AddComponent<TeleportRequest>();
                tpReq._from = from;
                tpReq._to = to;
                tpReq._tpHere = tpHere;
                tpReq._time = timeoutTime;
                tpReq._playerIsPaying = playerIsPaying;

                Instance.GameObjects.Add(gameObject);
            }

            void Start()
            {
                if (_tpHere)
                {
                    Instance.SendReply(_from, Instance.GetMessage("HereRequestSent").Replace("{0}", _to.displayName));
                    Instance.SendReply(_to, Instance.GetMessage("HereRequestRecieved").Replace("{0}", _from.displayName));
                }
                else
                {
                    Instance.SendReply(_from, Instance.GetMessage("RequestSent").Replace("{0}", _to.displayName));
                    Instance.SendReply(_to, Instance.GetMessage("RequestRecieved").Replace("{0}", _from.displayName));
                }

                PendingRequest pr = _to.gameObject.AddComponent<PendingRequest>();
                pr.From = _from;
                pr.TeleportRequest = this;
                InvokeRepeating("TimerTick", 0, 1.0f);
            }

            void TimerTick()
            {
                if (_time == 0) RequestTimeOut();
                _time--;
            }

            public void RequestAccepted()
            {
                int timeUntilTP = Instance.ConfigFile.DefaultTimeUntilTeleport;

                var lowestTimeUntilTP = Instance.ConfigFile.TimeUntilTeleport
                    .Where(x => Instance.permission.UserHasPermission(_from.UserIDString, x.Key) &&
                                x.Value < timeUntilTP)
                    .OrderBy(x => x.Value)
                    .FirstOrDefault();
                if (!lowestTimeUntilTP.Equals(default(KeyValuePair<string, int>)))
                {
                    timeUntilTP = lowestTimeUntilTP.Value;
                }

                Instance.SendReply(_from, Instance.GetMessage("RequestToAccepted").Replace("{0}", _to.displayName).Replace("{1}", timeUntilTP.ToString("N1")));
                Instance.SendReply(_to, Instance.GetMessage("RequestFromAccepted").Replace("{0}", _from.displayName).Replace("{1}", timeUntilTP.ToString("N1")));

                Teleporter teleporter = _from.gameObject.AddComponent<Teleporter>();
                teleporter.Create(_from, _to, timeUntilTP);

                PendingRequest pr = _to.gameObject.GetComponent<PendingRequest>();
                if (pr != null) GameObject.Destroy(pr);

                CancelInvoke();

                GameObject.Destroy(this.gameObject);
            }

            public void RequestDeclined()
            {
                if (_from != null)
                {
                    if (_tpHere)
                    {
                        Instance.SendReply(_from, Instance.GetMessage("HereRequestToDenied").Replace("{0}", _to.displayName));
                    }
                    else
                    {
                        Instance.SendReply(_from, Instance.GetMessage("RequestToDenied").Replace("{0}", _to.displayName));
                    }

                    if (Instance.EconomicsInstalled() &&
                        Instance.ConfigFile.UseEconomicsPlugin &&
                        _playerIsPaying)
                    {
                        Instance.RefundPlayerEconomics(_from);
                    }

                    if (Instance.ServerRewardsInstalled() &&
                        Instance.ConfigFile.UseServerRewardsPlugin &&
                        _playerIsPaying)
                    {
                        Instance.RefundServerRewards(_from);
                    }
                }

                if (_to != null)
                {
                    if (_tpHere)
                    {
                        Instance.SendReply(_to, Instance.GetMessage("HereRequestFromDenied").Replace("{0}", _from.displayName));
                    }
                    else
                    {
                        Instance.SendReply(_to, Instance.GetMessage("RequestFromDenied").Replace("{0}", _from.displayName));
                    }
                }

                PendingRequest pendingReq = _to?.gameObject?.GetComponent<PendingRequest>();
                if (pendingReq != null) GameObject.Destroy(pendingReq);

                GameObject.Destroy(this.gameObject);
            }

            public void RequestCancelled()
            {
                if (_from != null)
                {
                    Instance.SendReply(_from, Instance.GetMessage("TeleportRequestToCancelled").Replace("{0}", _to.displayName));

                    if (Instance.EconomicsInstalled() &&
                        Instance.ConfigFile.UseEconomicsPlugin &&
                        _playerIsPaying)
                    {
                        Instance.RefundPlayerEconomics(_from);
                    }

                    if (Instance.ServerRewardsInstalled() &&
                        Instance.ConfigFile.UseServerRewardsPlugin &&
                        _playerIsPaying)
                    {
                        Instance.RefundServerRewards(_from);
                    }
                }

                if (_to != null)
                {
                    Instance.SendReply(_to, Instance.GetMessage("TeleportRequestFromCancelled").Replace("{0}", _from.displayName));
                }

                PendingRequest pr = _to?.gameObject?.GetComponent<PendingRequest>();
                if (pr != null) GameObject.Destroy(pr);

                GameObject.Destroy(this.gameObject);
            }

            void RequestTimeOut()
            {
                if (_from != null)
                {
                    if (_tpHere)
                    {
                        Instance.SendReply(_from, Instance.GetMessage("HereRequestToTimedOut").Replace("{0}", _to.displayName));
                    }
                    else
                    {
                        Instance.SendReply(_from, Instance.GetMessage("RequestToTimedOut").Replace("{0}", _to.displayName));
                    }

                    if (Instance.EconomicsInstalled() && Instance.ConfigFile.UseEconomicsPlugin)
                        Instance.RefundPlayerEconomics(_from);
                    if (Instance.ServerRewardsInstalled() && Instance.ConfigFile.UseServerRewardsPlugin)
                        Instance.RefundServerRewards(_from);
                }

                if (_to != null)
                {
                    if (_tpHere)
                    {
                        Instance.SendReply(_to, Instance.GetMessage("HereRequestFromTimedOut").Replace("{0}", _from.displayName));
                    }
                    else
                    {
                        Instance.SendReply(_to, Instance.GetMessage("RequestFromTimedOut").Replace("{0}", _from.displayName));
                    }
                }

                PendingRequest pr = _to?.gameObject?.GetComponent<PendingRequest>();
                if (pr != null) GameObject.Destroy(pr);
                GameObject.Destroy(this.gameObject);
            }

            void CancelRequest()
            {
                Instance.SendReply(_from, Instance.GetMessage("BlockTPTakeDamage"));

                if (Instance.EconomicsInstalled() && Instance.ConfigFile.UseEconomicsPlugin)
                    Instance.RefundPlayerEconomics(_from);

                if (Instance.ServerRewardsInstalled() && Instance.ConfigFile.UseServerRewardsPlugin)
                    Instance.RefundServerRewards(_from);

                PendingRequest pr = _to.gameObject.GetComponent<PendingRequest>();
                if (pr != null) GameObject.Destroy(pr);

                GameObject.Destroy(this.gameObject);
            }

            void OnDestroy()
            {
                CancelInvoke();
                Instance.GameObjects.Remove(this.gameObject);
            }
        }

        class PendingRequest : MonoBehaviour
        {
            public BasePlayer From;
            public TeleportRequest TeleportRequest;
        }

        class Teleporter : MonoBehaviour
        {
            private GameObject _gameObject;
            private BasePlayer _from;
            private BasePlayer _to;
            private int _timeUtilTeleport;

            public void Create(BasePlayer from, BasePlayer to, int timeUntilTeleport)
            {
                this._gameObject = new GameObject();
                this._timeUtilTeleport = timeUntilTeleport;
                this._from = from;
                this._to = to;

                Instance.GameObjects.Add(_gameObject);
            }

            void Start() => InvokeRepeating("TimerTick", 0, 1.0f);

            void TimerTick()
            {
                if (_timeUtilTeleport == 0) Teleport();
                _timeUtilTeleport--;
            }

            void Teleport()
            {
                Vector3 currentPos = _from.transform.position;
                Instance.RecordLastTP(_from, currentPos);

                Instance.Teleport(_from, _to);

                Instance.SendReply(_from, Instance.GetMessage("YouTeleportedTo").Replace("{0}", _to.displayName));
                Instance.SendReply(_to, Instance.GetMessage("TeleportedToYou").Replace("{0}", _from.displayName));

                double cooldown = Instance.ConfigFile.DefaultCooldown;

                var lowestCooldown = Instance.ConfigFile.Cooldowns
                    .Where(x => Instance.permission.UserHasPermission(_from.UserIDString, x.Key) &&
                                x.Value < cooldown)
                    .OrderBy(x => x.Value)
                    .FirstOrDefault();
                if (!lowestCooldown.Equals(default(KeyValuePair<string, double>)))
                {
                    cooldown = lowestCooldown.Value;
                }

                Instance.storedData.Cooldowns.Add(_from.userID, cooldown);

                if (Instance.ConfigFile.DefaultDailyLimit > 0 &&
                    !Instance.HasReachedDailyLimit(_from))
                {
                    int usesRemaining = Instance.IncrementUses(_from);
                    Instance.SendReply(_from, Instance.GetMessage("TeleportsRemaining").Replace("{0}", usesRemaining.ToString()));
                }

                GameObject.Destroy(this.gameObject.GetComponent<Teleporter>());
            }

            public void CancelTeleport()
            {
                Instance.SendReply(_from, Instance.GetMessage("TeleportToCancelled").Replace("{0}", _to.displayName));
                Instance.SendReply(_to, Instance.GetMessage("TeleportFromCancelled").Replace("{0}", _from.displayName));

                if (Instance.EconomicsInstalled() && Instance.ConfigFile.UseEconomicsPlugin)
                    Instance.RefundPlayerEconomics(_from);

                if (Instance.ServerRewardsInstalled() && Instance.ConfigFile.UseServerRewardsPlugin)
                    Instance.RefundServerRewards(_from);

                GameObject.Destroy(this.gameObject.GetComponent<Teleporter>());
            }

            void StartSleeping(BasePlayer player)
            {
                if (player.IsSleeping())
                    return;
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
                if (!BasePlayer.sleepingPlayerList.Contains(player))
                    BasePlayer.sleepingPlayerList.Add(player);
                player.CancelInvoke("InventoryUpdate");
            }

            void OnDestory()
            {
                CancelInvoke();
                Instance.GameObjects.Remove(_gameObject);
            }
        }

        class CooldownManager : MonoBehaviour
        {
            GameObject GameObject;

            public static void Create()
            {
                CooldownManager cm = new CooldownManager();
                cm.GameObject = new GameObject();
                cm.GameObject.AddComponent<CooldownManager>();
                Instance.GameObjects.Add(cm.GameObject);
            }

            void Start()
            {
                InvokeRepeating("TimerTick", 0, 1.0f);
            }

            void TimerTick()
            {
                if (Instance?.storedData?.Cooldowns == null) return;

                foreach (KeyValuePair<ulong, double> kvp in new Dictionary<ulong, double>(Instance.storedData.Cooldowns))
                {
                    Instance.storedData.Cooldowns[kvp.Key]--;

                    if (kvp.Value == 0)
                    {
                        Instance.storedData.Cooldowns.Remove(kvp.Key);
                    }
                }
            }

            void OnDestroy()
            {
                Instance?.SaveData();
                CancelInvoke();
                Instance.GameObjects.Remove(GameObject);
            }
        }

        class StoredData
        {
            public Dictionary<ulong, double> Cooldowns = new Dictionary<ulong, double>();
            public Dictionary<ulong, int> UsesToday = new Dictionary<ulong, int>();
        }
        StoredData storedData;

        #endregion

        #region Oxide Hooks

        void Init()
        {
            // Debugging mode should be enabled?
            if (ConVar.Server.hostname == "PsychoTea's Testing Server")
            {
                DebuggingMode = true;
                Puts("Debugging mode enabled.");
            }

            // Register regular permissions
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permCancel, this);
            permission.RegisterPermission(permBack, this);
            permission.RegisterPermission(permHere, this);
            permission.RegisterPermission(permSleepers, this);

            // Register config permissions
            foreach (string perm in ConfigFile.Cooldowns.Keys)
                if (!permission.PermissionExists(perm, this))
                    permission.RegisterPermission(perm, this);

            foreach (string perm in ConfigFile.DailyLimit.Keys)
                if (!permission.PermissionExists(perm, this))
                    permission.RegisterPermission(perm, this);

            foreach (string perm in ConfigFile.TimeUntilTeleport.Keys)
                if (!permission.PermissionExists(perm, this))
                    permission.RegisterPermission(perm, this);

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "NoPermission", "You do not have permission to use this command." },
                { "TeleportTitle", "Teleport" },
                { "RequestSent", "Teleport request sent to {0}." },
                { "HereRequestSent", "Teleport here request sent to {0}." },
                { "RequestRecieved", "Teleport request from {0}. Open the teleport GUI (/tp) to accept." },
                { "HereRequestRecieved", "Teleport here request from {0}. Open the teleport GUI (/tp) to accept." },
                { "RequestToTimedOut", "Your teleport request to {0} timed out." },
                { "HereRequestToTimedOut", "Your teleport here request to {0} timed out." },
                { "RequestFromTimedOut", "The teleport request from {0} timed out." },
                { "HereRequestFromTimedOut", "The teleport here request from {0} timed out." },
                { "HasPendingRequest", "{0} already has a pending teleport request." },
                { "RequestFrom", "Request from {0}" },
                { "RequestToAccepted", "Your teleport request to {0} was accepted. Teleporting in {1} seconds." },
                { "RequestFromAccepted", "Teleport request from {0} accepted. Telporting in {1} seconds." },
                { "RequestToDenied", "Your teleport request to {0} was denied." },
                { "HereRequestToDenied", "Your teleport here request to {0} was denied." },
                { "RequestFromDenied", "Teleport request from {0} denied." },
                { "HereRequestFromDenied", "Teleport here request from {0} denied." },
                { "YouTeleportedTo", "You teleported to {0}." },
                { "TeleportedToYou", "{0} teleported to you." },
                { "OnCooldown", "Your teleport is on cooldown for {0} seconds." },
                { "NoPendingRequests", "You don't have any pending requests." },
                { "SyntaxTPR", "Incorrect usage! /tpr {name}" },
                { "PlayerNotFound", "The player \"{0}\" was not found." },
                { "PlayerIDNotFound", "A player with the user ID {0} was not found." },
                { "MultiplePlayersFound", "Multiple players were found with the name {0}." },
                { "CantTeleportToSelf", "You can't teleport to yourself, silly!" },
                { "PlayerIsBuildBlocked", "You may not use teleport whilst building blocked!" },
                { "TargetIsBuildBlocked", "The person you're trying to teleport to is building blocked." },
                { "LocationIsBuildBlocked", "You are building blocked in the location you're trying to teleport to." },
                { "PlayerIsBleeding", "You may not use teleport whilst bleeding." },
                { "CantAffordEconomics", "You can't afford this! Price: ${0}" },
                { "EconomicsYouSpent", "You spent ${0} on this teleport." },
                { "EconomicsRefunded", "You were refunded ${0}." },
                { "CantAffordServerRewards", "You can't afford this! Price: {0}RP" },
                { "ServerRewardsYouSpent", "You spent {0}RP on this teleport." },
                { "ServerRewardsRefunded", "You were refunded {0}RP." },
                { "BlockTPCrafting", "You may not use teleport whilst crafting." },
                { "MaxTeleportsReached", "You have reached your max teleports for today." },
                { "TeleportsRemaining", "{0} teleports remaining today." },
                { "TeleportRequestFromCancelled", "Teleport request from {0} cancelled." },
                { "TeleportRequestToCancelled", "Teleport request to {0} cancelled." },
                { "TeleportRequestCancelled", "Teleport request cancelled." },
                { "TeleportToCancelled", "Teleport to {0} cancelled." },
                { "TeleportFromCancelled", "Teleport from {0} cancelled." },
                { "NoBackLocation", "You have no previous location to return to." },
                { "TeleportedBack", "Teleported back to your previous location." },
                { "SyntaxTPHere", "Incorrect usage! /tphere {name}" },
                { "TPPos-InvalidSyntax", "Incorrect usage! /tp {x} {y} {z}" },
                { "TPToPos", "Teleported to {x}, {y}, {z}" },
                { "NothingToCancel", "You have no teleports to cancel." },
                { "CantTeleportFromZone", "You may not teleport out of a ZoneManager zone." },
                { "CantTeleportToZone", "You may not teleport into a ZoneManager zone." },
                { "CantTPWhilstWounded", "You may not TP whilst wounded." },
                { "IsEscapeBlocked", "You are currently escape blocked and may not teleport." }
            }, this, "en");

            ReadData();

            foreach (string cmdAlias in ConfigFile.TPCommandAliases)
                cmd.AddChatCommand(cmdAlias, this, "tpCommand");

            timer.Once(TimeUntilMidnight(), () => ResetDailyUses());

            if (DebuggingMode) BasePlayer.activePlayerList.ForEach(x => ShowTeleportUI(x));
        }

        void OnServerInitialized()
        {
            Instance = this;

            CooldownManager.Create();

            if (Economics == null && ConfigFile.UseEconomicsPlugin)
            {
                Debug.LogError("[TeleportGUI] Error! Economics is enabled in the config but is not installed! Please install Economics or disable 'UseEconomicsPlugin' in the config!");
            }

            if (ServerRewards == null && ConfigFile.UseServerRewardsPlugin)
            {
                Debug.LogError("[TeleportGUI] Error! ServerRewards is enabled in the config but is not installed! Please install ServerRewards or disable 'UseServerRewardsPlugin' in the config!");
            }

            if (!ConfigFile.UseEconomicsPlugin &&
                !ConfigFile.UseServerRewardsPlugin &&
                ConfigFile.PayAfterUsingDailyLimits)
            {
                Debug.LogError("[TeleportGUI] Error! PayAfterUsingDailyLimits is set in the config, but neither UseEconomicsPlugin or UseServerRewardsPlugin is set! Please fix this error before loading TeleportGUI again. Unloading...");
                Interface.Oxide.UnloadPlugin(this.Title);
                return;
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (!(entity is BasePlayer)) return;
            BasePlayer player = entity as BasePlayer;
            if (player == null) return;

            if (!HasComponent<Teleporter>(player)) return;
            if (!ConfigFile.CancelTeleportOnDamage) return;

            var teleporter = player.gameObject.GetComponent<Teleporter>();
            teleporter.CancelTeleport();
        }

        void Unload()
        {
            foreach (GameObject go in GameObjects)
            {
                if (go == null) continue;
                if (HasComponent<Teleporter>(go) ||
                    HasComponent<PendingRequest>(go) ||
                    HasComponent<CooldownManager>(go))
                    GameObject.Destroy(go);
            }
            GameObjects.Clear();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CloseUI(player);

            SaveData();
        }

        #endregion

        #region Config

        ConfigData ConfigFile;

        class ConfigData
        {
            public bool PrefixEnabled = true;
            public string PrefixText = "<color=orange>TP: </color>";
            public int DefaultTimeUntilTeleport = 15;
            public Dictionary<string, int> TimeUntilTeleport = new Dictionary<string, int>()
            {
                { "teleportgui.vip", 10 },
                { "teleportgui.elite", 5 },
                { "teleportgui.god", 3 },
                { "teleportgui.none", 0 }
            };
            public List<string> TPCommandAliases = new List<string>() { };
            public double RequestTimeoutTime = 30;
            public double DefaultCooldown = 180;
            public Dictionary<string, double> Cooldowns = new Dictionary<string, double>()
            {
                { "teleportgui.vip", 60 },
                { "teleportgui.elite", 30 },
                { "teleportgui.god", 15 },
                { "teleportgui.none", 0 }
            };
            public int DefaultDailyLimit = 3;
            public Dictionary<string, int> DailyLimit = new Dictionary<string, int>()
            {
                { "teleportgui.vip", 5 },
                { "teleportgui.elite", 8 },
                { "teleportgui.god", 15 },
                { "teleportgui.none", 9999 }
            };
            public bool AdminTPSilent = false;
            public bool AdminTPEnabled = false;
            public bool AllowTeleportWhilstBleeding = false;
            public bool AllowTeleportToBuildBlockedPlayer = false;
            public bool AllowTeleportFromBuildBlock = false;
            public bool UseEconomicsPlugin = false;
            public double EconomicsPrice = 100;
            public bool UseServerRewardsPlugin = false;
            public int ServerRewardsPrice = 10;
            public bool PayAfterUsingDailyLimits = false;
            public bool BlockTPCrafting = true;
            public bool AllowSpecialCharacters = false;
            public bool CancelTeleportOnDamage = true;
            public bool CanTeleportIntoZone = true;
            public bool CanTeleportFromZone = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            ConfigFile = Config.ReadObject<ConfigData>();
            Config.WriteObject(ConfigFile, true);
        }

        protected override void LoadDefaultConfig() => ConfigFile = new ConfigData();

        protected override void SaveConfig() => Config.WriteObject(ConfigFile, true);

        #endregion

        #region Commands

        [ChatCommand("tp")]
        void TPCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }

            if (player.IsAdmin && args.Length > 0)
            {
                if (args.Length < 3)
                {
                    SendReply(player, GetMessage("TPPos-InvalidSyntax"));
                    return;
                }

                float x, y, z;
                if (!float.TryParse(args[0], out x) || !float.TryParse(args[1], out y) || !float.TryParse(args[2], out z))
                {
                    SendReply(player, GetMessage("TPPos-InvalidSyntax"));
                    return;
                }

                Teleport(player, new Vector3(x, y, z));
                SendReply(player, GetMessage("TPToPos")
                                    .Replace("{x}", x.ToString("N1"))
                                    .Replace("{y}", y.ToString("N1"))
                                    .Replace("{z}", z.ToString("N1")));
                return;
            }

            ShowTeleportUI(player);
        }

        [ChatCommand("tpr")]
        void TPRCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, GetMessage("SyntaxTPR"));
                return;
            }

            string name = args[0];
            for (int i = 1; i < args.Length; i++)
                name += " " + args[i];

            List<BasePlayer> matches = FindByNameMulti(name);
            if (matches.Count() == 0)
            {
                SendReply(player, GetMessage("PlayerNotFound").Replace("{0}", name));
                return;
            }
            else if (matches.Count() > 1)
            {
                SendReply(player, GetMessage("MultiplePlayersFound").Replace("{0}", name));
                return;
            }
            BasePlayer targetPlayer = matches.First();

            if (targetPlayer == player && !DebuggingMode)
            {
                SendReply(player, GetMessage("CantTeleportToSelf"));
                return;
            }

            TPR(player, targetPlayer, false);
            return;
        }

        [ChatCommand("tpa")]
        void TPACommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }

            TeleportRequest tr = player.gameObject.GetComponent<PendingRequest>()?.TeleportRequest;

            if (tr == null)
            {
                SendReply(player, GetMessage("NoPendingRequests"));
                return;
            }

            tr.RequestAccepted();
            CloseUI(player);
        }

        [ChatCommand("tpd")]
        void TPDCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }

            TeleportRequest tr = player.gameObject.GetComponent<PendingRequest>()?.TeleportRequest;

            if (tr == null)
            {
                SendReply(player, GetMessage("NoPendingRequests"));
                return;
            }

            tr.RequestDeclined();
            CloseUI(player);
        }

        [ChatCommand("tpc")]
        void TPCCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player, permCancel))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }

            TPC(player);
        }

        [ChatCommand("tpb")]
        void TPBCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player, permBack))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }

            TPB(player);
        }

        [ChatCommand("tpahere")]
        void TPAHereCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player, permHere))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, GetMessage("SyntaxTPHere"));
                return;
            }

            string targetName = string.Join(" ", args);

            List<BasePlayer> matches = FindByNameMulti(targetName);
            if (matches.Count() == 0)
            {
                SendReply(player, GetMessage("PlayerNotFound").Replace("{0}", targetName));
                return;
            }
            if (matches.Count > 1)
            {
                SendReply(player, GetMessage("MultiplePlayersFound").Replace("{0}", targetName));
                return;
            }
            BasePlayer targetPlayer = matches.First();

            TPHere(player, targetPlayer.userID);
        }

        [ConsoleCommand("tpgui")]
        void TPGuiCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null) return;
            BasePlayer player = arg.Player();

            string[] args = arg.Args ?? new string[] { };

            #region Check Perm
            if (!HasPerm(player))
            {
                SendReply(player, GetMessage("NoPermission"));
                return;
            }
            #endregion

            #region Open GUI
            if (args.Length == 0)
            {
                ShowTeleportUI(player);
                return;
            }

            if (args[0] == "True") //Because apparently bind b tpgui runs "tpgui True" -.-
            {
                ShowTeleportUI(player);
                return;
            }
            #endregion

            #region Close
            if (args[0] == "close")
            {
                CloseUI(player);
                return;
            }
            #endregion

            #region To
            if (args[0] == "to")
            {
                if (args.Length < 2) return;

                CloseUI(player);

                string userIDString = args[1];
                ulong userID;
                if (!ulong.TryParse(userIDString, out userID)) return;

                var guiSettings = GUIManager.Get(player);

                if (guiSettings.Sleepers)
                {
                    var target = BasePlayer.sleepingPlayerList.FirstOrDefault(x => x.userID == userID);
                    if (target == null)
                    {
                        SendReply(player, GetMessage("PlayerIDNotFound").Replace("{0}", userIDString));
                        return;
                    }

                    SendReply(player, GetMessage("YouTeleportedTo").Replace("{0}", target.displayName));
                    RecordLastTP(player, player.transform.position);
                    Teleport(player, target);
                    return;
                }

                BasePlayer targetPlayer = BasePlayer.FindByID(userID);

                if (targetPlayer == null)
                {
                    SendReply(player, GetMessage("PlayerIDNotFound").Replace("{0}", userIDString));
                    return;
                }

                TPR(player, targetPlayer, false);
                return;
            }
            #endregion

            #region Accept
            if (args[0] == "accept")
            {
                TeleportRequest tr = player.gameObject.GetComponent<PendingRequest>()?.TeleportRequest;
                if (tr == null)
                {
                    SendReply(player, GetMessage("NoPendingRequests"));
                    return;
                }

                tr.RequestAccepted();
                CloseUI(player);
                return;
            }
            #endregion

            #region Decline
            if (args[0] == "decline")
            {
                TeleportRequest tr = player.gameObject.GetComponent<PendingRequest>()?.TeleportRequest;
                if (tr == null)
                {
                    SendReply(player, GetMessage("NoPendingRequests"));
                    return;
                }

                tr.RequestDeclined();
                CloseUI(player);
                return;
            }
            #endregion

            #region Back
            if (args[0] == "back")
            {
                if (!HasPerm(player, permBack))
                {
                    SendReply(player, GetMessage("NoPermission"));
                    return;
                }

                TPB(player);
                CloseUI(player);
                return;
            }
            #endregion

            #region Cancel
            if (args[0] == "cancel")
            {
                if (!HasPerm(player, permCancel))
                {
                    SendReply(player, GetMessage("NoPermission"));
                    return;
                }

                TPC(player);
                CloseUI(player);
                return;
            }
            #endreg